Original Text,NULL
The Java Collection interface (java.util.Collection) is one of the root interfaces of the Java Collection API.,"(""Java Collection"", ""The Java Collection interface is part of the Java Collection API"", ""Java Collection API""); (""java.util.Collection"", ""The java.util.Collection is part of the Java Collection API"", ""Java Collection API"")"
Adding an element to a Collection is done via the add() method.,NULL
"The add() method adds the given element to the collection, and returns true if the Collection changed as a result of calling the add() method.","(""Add"", ""The add() method is related to the Collection class because it is used to add an element to the collection."", ""Collection"")"
"On the other hand, if you called add() on a List and the List already contained that element, the element would then exist twice in the List.","(""List"", ""The List class has a method called add(), which suggests a relationship between the two entities."", ""add()"")"
"The remove() method removes the given element from the Collection and returns true if the removed element was present in the Collection, and was removed.",NULL
"If the element was not present, the remove() method returns false.",NULL
You can also add a collection of objects to a Java Collection using the addAll().,NULL
The Java Collection addAll() adds all elements found in the Collection passed as parameter to the method.,"(""Java"", ""Java is related to Collection because it is the programming language in which the Collection class is used"", ""Collection""); (""Collection"", ""Collection is related to addAll() because addAll() is a method of the Collection class"", ""addAll()"")"
"If you had called add() with the Collection as parameter instead, the Collection object itself would have been added, not its elements.",NULL
Exactly how the addAll() method behaves depends on the Collection subtype.,NULL
The Java Collection removeAll() removes all elements found the Collection passed as parameter to the method.,"(""removeAll()"", ""The removeAll() method is related to the Collection class because it is used to remove elements from the Collection."", ""Collection""); (""Java"", ""The Java package is related to the Collection class because Collection is part of the Java Collection framework."", ""Collection"")"
"contains() returns true if the collection contains the element, and false if not.",NULL
"containsAll() returns true if the collection contains all the elements in the parameter collection, and false if not.",NULL
You can check the size of a collection using the size() method.,NULL
The Java Stream API provides a more functional programming approach to iterating and processing elements of e.g.,NULL
You obtain a stream from a collection by calling the stream() method of the given collection.,"(""Collection"", ""The Collection class is related to the Stream() method because the Stream() method is called on a collection to obtain a stream."", ""Stream()"")"
Then a Stream of strings is obtained by calling the items.stream() method.,"(""Stream"", ""Stream is related to items because a Stream of strings is obtained from items"", ""items""); (""items"", ""items is related to stream because the stream method is called on items"", ""stream"")"
"This is similar to how you obtain an Iterator by calling the items.iterator() method, but a Stream is a different animal than an Iterator.","(""Iterator"", ""The Iterator entity is related to the items.iterator() method because the method is used to obtain an Iterator."", ""items.iterator()""); (""Stream"", ""The Stream entity is related to the items.iterator() method because the text compares the process of obtaining a Stream to the process of obtaining an Iterator using the items.iterator() method."", ""items.iterator()"")"
The Predicate interface contains a function called test() which the lambda expression passed as parameter above is matched against.,"(""Predicate"", ""The Predicate interface contains a function called test(), indicating that test() is a method of the Predicate interface."", ""test""); (""Predicate"", ""The lambda expression is passed as a parameter to the Predicate interface, indicating that the lambda expression is related to the Predicate interface."", ""lambda expression"")"
"If you look at the lambda expression above, you can see that it takes a single parameter item and returns a boolean - the result of the item.startsWith(""o"") method call.","(""Item"", ""The Item class has a relationship with the StartsWith method because the method is called on an item."", ""StartsWith""); (""StartsWith"", ""The StartsWith method has a relationship with the Boolean class because it returns a boolean value."", ""Boolean"")"
"When you call the filter() method on a Stream, the filter passed as parameter to the filter() method is stored internally.","(""Stream"", ""The Stream class has a method called filter(), indicating a relationship between the two."", ""filter()""); (""filter()"", ""The filter() method takes a filter as a parameter, indicating a relationship between the filter() method and the filter."", ""filter"")"
"The parameter passed to the filter() function determines what items in the stream should be processed, and which that should be excluded from the processing.","(""Filter"", ""The Filter method uses a Parameter to determine which items to process."", ""Parameter""); (""Filter"", ""The Filter method is used to process items in a Stream."", ""Stream"")"
"If the Predicate.test() method of the parameter passed to filter() returns true for an item, that means it should be processed.","(""Predicate"", ""The Predicate class has a test method, indicating a relationship between the class and its method."", ""test""); (""filter"", ""The filter method uses the Predicate class, indicating a relationship between the filter method and the Predicate class."", ""Predicate"")"
The collect() method is one of the stream processing methods on the Stream interface.,NULL
"The min() and max() methods return an Optional instance which has a get() method on, which you use to obtain the value.","(""Min"", ""The min() method returns an Optional instance"", ""Optional""); (""Max"", ""The max() method returns an Optional instance"", ""Optional""); (""Get"", ""The get() method is used on an Optional instance"", ""Optional""); (""Min"", ""The get() method is used to obtain the value returned by the min() method"", ""Get"")"
In case the stream has no elements the get() method will return null.,NULL
The Comparator.comparing() method creates a Comparator based on the lambda expression passed to it.,NULL
"In fact, the comparing() method takes a Function which is a functional interface suited for lambda expressions.",NULL
The count() method simply returns the number of elements in the stream after filtering has been applied.,NULL
The count() method returns a long which is the count of elements in the stream after filtering etc.,NULL
The reduce() method can reduce the elements of a stream to a single value.,NULL
"The reduce() method takes a BinaryOperator as parameter, which can easily be implemented using a lambda expression.",NULL
The BinaryOperator.apply() method is the method implemented by the lambda expression above.,NULL
"Thus, the value created by the reduce() function is the accumulated value after processing the last element in the stream.",NULL
The reduce() method taking a BinaryOperator as parameter returns an Optional .,"(""Reduce"", ""The reduce() method takes a BinaryOperator as a parameter, indicating a relationship between the two."", ""BinaryOperator"")"
"In case the stream contains no elements, the Optional.get() returns null.","(""Optional"", ""The Optional class contains the get method"", ""get"")"
"This version of the reduce() method returns the accumulated value directly, and not an Optional.",NULL
The reduce() method can be combined with the filter() method too.,NULL
"The Java Collections class, java.util.Collections, contains a long list of utility methods for working with collections in Java.","(""java.util.Collections"", ""java.util.Collections is a part of the java.util package"", ""java.util""); (""Java Collections"", ""Java Collections is another name for the java.util.Collections class"", ""java.util.Collections""); (""java.util.Collections"", ""java.util.Collections contains a list of utility methods"", ""utility methods"")"
The Java Collections addAll() method can add a variable number of elements to a Collection (typically either a List or a Set .,"(""Java Collections"", ""The Java Collections package contains the addAll() method"", ""addAll()""); (""addAll()"", ""The addAll() method can add elements to a Collection"", ""Collection""); (""Collection"", ""A Collection can be a List"", ""List"")"
Here is a java code example of calling the Collections addAll() method:,NULL
The Collections binarySearch() method can search a Java List for an element using a binary search algorithm.,"(""Collections"", ""The binarySearch() method is part of the Collections class"", ""binarySearch()""); (""binarySearch()"", ""The binarySearch() method can search a Java List for an element"", ""List""); (""Java"", ""List is a part of the Java package"", ""List"")"
The List must be sorted in ascending order before you search it using binarySearch() .,NULL
Here is an example of searching a List using the Collections binarySearch() method:,"(""Collections"", ""The binarySearch() method is part of the Collections class, indicating a clear relationship between the two entities."", ""binarySearch()""); (""List"", ""The binarySearch() method is used to search a List, indicating a clear relationship between the two entities."", ""binarySearch()"")"
The Collections copy() method can copy all elements of a List into another List.,"(""Collections"", ""The copy() method is part of the Collections class"", ""copy()""); (""copy()"", ""The copy() method can copy all elements of a List into another List"", ""List"")"
Here is a Java example of calling the Collections copy() method:,NULL
The Collections reverse() method can reverse the elements in a Java List.,"(""Collections"", ""The reverse() method is part of the Collections class"", ""reverse()""); (""reverse()"", ""The reverse() method can reverse the elements in a Java List"", ""List""); (""Collections"", ""The Collections class has a method that can operate on a List"", ""List""); (""Java"", ""List is a part of the Java package"", ""List"")"
The Collections shuffle() method can shuffle the elements of a List.,"(""Collections"", ""The shuffle() method is part of the Collections class"", ""shuffle()""); (""shuffle()"", ""The shuffle() method can shuffle the elements of a List"", ""List"")"
Here is an example of shuffling a list with the Collections shuffle() method:,NULL
Here is an example of sorting a Java List using Collections sort() method:,"(""Collections"", ""The Collections class contains the sort() method, indicating a clear relationship between the two entities as the method is part of the class."", ""sort()""); (""List"", ""The List class is related to the Collections class because the Collections class provides methods, such as sort(), that can be used with List objects."", ""Collections"")"
The Java Collections copy() method can copy one List into another.,"(""Java Collections"", ""The copy() method is part of the Java Collections package."", ""copy()""); (""copy()"", ""The copy() method can copy one List into another, indicating a relationship between the method and the List class."", ""List"")"
You provide the source and destination List instances as parameters to the copy() method.,"(""copy()"", ""The copy() method is related to the List class because it is called on List instances."", ""List"")"
The Collections min() method can find the minimum element in a List according to the natural ordering of the elements (see my Java List sorting tutorial).,"(""Collections"", ""The min() method is part of the Collections class"", ""min()""); (""Collections"", ""The Collections class can operate on a List, such as finding the minimum element"", ""List"")"
Here is an example of finding the minimum element in a Java List using Collections min() method:,"(""Collections"", ""The Collections class contains the min() method, indicating a clear relationship between the two entities as the method is part of the class."", ""min()""); (""Java"", ""The Java package contains the List class, indicating a clear relationship between the two entities as the class is part of the package."", ""List""); (""Java"", ""The Java package contains the Collections class, indicating a clear relationship between the two entities as the class is part of the package."", ""Collections""); (""List"", ""The List class is related to the min() method as the method can be used to find the minimum element in a List, indicating a clear functional relationship between the two entities."", ""min()"")"
The Collections max() method can find the maximum element in a List according to the natural order of the elements (see my Java List sorting tutorial).,"(""Collections"", ""The max() method is part of the Collections class"", ""max()""); (""Collections"", ""The Collections class can operate on a List, as seen with the max() method"", ""List"")"
The Java Collections replaceAll() method can replace all occurrences of one element with another element.,NULL
You pass the element to replace and the element to replace it with as parameters to the replaceAll() method.,"(""ReplaceAll"", ""The ReplaceAll method is related to the Element because it takes an element as a parameter to replace."", ""Element"")"
"The Collections replaceAll() method returns true if any elements were replaced, and false if not.",NULL
The Collections replaceAll() method uses the equals() method of each element to determine if the element is equal to the element to replace or not.,"(""Collections"", ""The Collections class contains the replaceAll() method, indicating a relationship between the class and the method."", ""replaceAll()"")"
I have a written a few more details about how the equals() method works in my section about the Java equals() method.,NULL
The unmodifiableSet() method in the Java Collections class can create an immutable (unmodifiable) Set from a normal Java Set .,"(""Java Collections"", ""The unmodifiableSet() method is part of the Java Collections class, indicating a relationship between the two."", ""unmodifiableSet()""); (""unmodifiableSet()"", ""The unmodifiableSet() method creates an immutable Set, indicating a relationship between the method and the Set class."", ""Set"")"
"The Java Comparable interface,java.lang.Comparable, represents an object which can be compared to other objects.","(""java.lang"", ""java.lang is a package that contains the java.lang.Comparable class"", ""java.lang.Comparable""); (""Java"", ""The Java language has a Comparable interface"", ""Comparable"")"
Several of the built-in classes in Java implements the Java Comparable interface.,"(""Java"", ""Java is related to Comparable because Java has built-in classes that implement the Comparable interface"", ""Comparable""); (""Java"", ""Java is related to itself as it is mentioned that Java has built-in classes"", ""Java"")"
"You can also implement the Java Comparable interface yourself, to make your own classes comparable.","(""Java"", ""Java is related to Comparable because the Java language can be used to implement the Comparable interface"", ""Comparable"")"
"When a class implements the Java Comparable interface, this means that instances (objects) of that class can be compared to each other, as mentioned above.",NULL
Please keep in mind that the Comparable interface is intended for comparison of objects of the same class.,"(""Comparable"", ""The Comparable interface is intended for comparison of objects of the same class, indicating a relationship between the Comparable interface and objects of the same class."", ""objects"")"
In the following section I will explain how the compareTo() method works.,NULL
The Java Comparable compareTo() method takes a single object as parameter and returns an int value.,NULL
"The int returned signal whether the object the compareTo() method is called on is larger than, equal to or smaller than the parameter object.","(""CompareTo"", ""The compareTo method is called on an object, indicating a relationship between the two."", ""Object"")"
"The Java Integer class implements the Comparable interface, so you can call compareTo() Here is an example:","(""Integer"", ""The Integer class implements the Comparable interface, indicating a relationship between the two."", ""Comparable""); (""Integer"", ""The compareTo method is called on the Integer class, indicating a relationship between the two."", ""compareTo"")"
Since the value 45 is smaller than 99 - the first comparison ( valA.compareTo(valB) = 45.compareTo(99) ) results in the value -1 being returned.,"(""ValA"", ""ValA uses the CompareTo method to compare its value with ValB"", ""CompareTo""); (""ValB"", ""ValB is compared with ValA using the CompareTo method"", ""CompareTo""); (""CompareTo"", ""The CompareTo method is used by ValA to determine its relationship with ValB"", ""ValA"")"
"In the second comparison, when 99 is compared to 45 ( valB.compareTo(valA) = 99.compareTo(45) ) the result is 1 - because 99 is larger than 45.","(""ValB"", ""ValB uses the CompareTo method to compare values"", ""CompareTo""); (""ValA"", ""ValA uses the CompareTo method to compare values"", ""CompareTo"")"
Here is an example of a Spaceship class which can compare itself to other Spaceship instances:,NULL
This way you can implement compareTo() to compare base on multiple factors.,NULL
"By specifying a type parameter when implementing the Comparable interface, the compareTo() method parameter changes from Object to whatever type you have specified.","(""Comparable"", ""The compareTo() method is part of the Comparable interface, indicating a clear relationship between the two entities."", ""compareTo()""); (""compareTo()"", ""The compareTo() method parameter is of type Object by default, indicating a relationship between the compareTo() method and the Object class."", ""Object"")"
"Notice how there is no type parameter specified after the ""implements Comparable"" interface in the class declaration.",NULL
"Notice also, how the parameter type of the compareTo() object is no longer Spaceship, but Object.","(""CompareTo"", ""The compareTo method is related to the Object class because it takes an Object as a parameter."", ""Object"")"
"Finally, also notice how it is now necessary to cast the parameter of the compareTo() method to Spaceship explicitly.",NULL
"Notice too, that the compareTo() method should throw a NullPointerException if the parameter object is null.",NULL
"Similarly, the compareTo() method should throw a ClassCastException if the input parameter is not of the same class as the class of the object compareTo() is called on.","(""CompareTo"", ""The compareTo() method throws a ClassCastException, indicating a relationship between the two."", ""ClassCastException""); (""CompareTo"", ""The compareTo() method takes an input parameter, establishing a relationship between the method and the parameter."", ""Input Parameter"")"
You can just cast to the desired class (as in the example above).,NULL
"If the classes do not match, the Java VM will throw a ClassCastException.","(""Java VM"", ""The Java VM throws a ClassCastException, indicating a relationship between the two entities as the Java VM is the source that throws the exception."", ""ClassCastException""); (""Class"", ""A ClassCastException is thrown when the classes do not match, indicating a relationship between classes and the exception."", ""ClassCastException"")"
"The Java Comparator interface, java.util.Comparator, represents a component that can compare two objects so they can be sorted using sorting functionality in Java.","(""Java Comparator"", ""The Java Comparator interface is represented by the java.util.Comparator package, indicating a clear relationship between the two entities."", ""java.util.Comparator""); (""Java Comparator"", ""The Java Comparator interface uses the compare method to compare two objects, indicating a clear relationship between the two entities."", ""compare"")"
When sorting e.g a Java List you can pass a Java Comparator to the sorting method.,"(""List"", ""The List class is related to the sorting method because it is the object being sorted."", ""sorting""); (""Comparator"", ""The Comparator class is related to the sorting method because it is used to define the sorting order."", ""sorting"")"
"This method, the compare() method, takes two objects which the Comparator implementation is intended to compare.",NULL
The compare() method returns an int which signals which of the two objects was larger.,NULL
Imagine you have the following Spaceship class that you would like to be able to compare instances of:,NULL
"Notice that the Spaceship class already implements the Comparable interface which compares Spaceship objects on spaceshipClass first, and then registrationNo.","(""Spaceship"", ""The Spaceship class implements the Comparable interface, indicating a relationship between the two entities."", ""Comparable""); (""Spaceship"", ""The spaceshipClass is used to compare Spaceship objects, indicating that spaceshipClass is a method or attribute of the Spaceship class."", ""spaceshipClass"")"
"First, notice how the SpaceshipComparator class implements the Comparator interface with the type Spaceship specified inside the < > characters ( implements Comparator<Spaceship> ).","(""SpaceshipComparator"", ""SpaceshipComparator implements Comparator, indicating a relationship between the two entities where SpaceshipComparator is a subclass or implementation of Comparator"", ""Comparator""); (""SpaceshipComparator"", ""SpaceshipComparator implements Comparator with the type Spaceship specified, indicating a relationship between SpaceshipComparator and Spaceship where Spaceship is the type being compared by SpaceshipComparator"", ""Spaceship"")"
"Setting the generic type of the Comparator implementation to Spaceship means that the parameter types of the compare() method can be set to Spaceship, and not Object as it would have been - if no generic type had been specified ( implements Comparator ).","(""Comparator"", ""The Comparator class contains the compare() method, indicating a relationship between the two entities as the compare() method is a part of the Comparator class."", ""compare()""); (""Comparator"", ""The Comparator class is related to the Spaceship class because the generic type of the Comparator implementation is set to Spaceship, indicating that the Comparator is used to compare Spaceship objects."", ""Spaceship"")"
"A Java Comparator implementation is pretty much always specialized to be able to compare objects of a specific type (class), so specifying a generic type in your Comparator implementation almost always makes sense.","(""Comparator implementation"", ""A Java Comparator implementation is a specific type of class that is used for comparing objects, thus they are related"", ""Java""); (""Comparator"", ""Comparator is a class that has an implementation, thus they are related"", ""Comparator implementation"")"
"Second, notice how the compare() method returns the registrationNo of the first Spaceship parameter compared to the registrationNo of the second Spaceship parameter.","(""Compare"", ""The compare method is related to the Spaceship class because it compares the registrationNo of two Spaceship parameters."", ""Spaceship""); (""Compare"", ""The compare method is related to the registrationNo method because it returns the registrationNo of the first Spaceship parameter compared to the registrationNo of the second Spaceship parameter."", ""RegistrationNo"")"
"Imagine if the registrationNo variable of the Spaceship class was an int instead, so getRegistrationNo() would return an int.","(""Spaceship"", ""The getRegistrationNo() method is related to the Spaceship class because it is mentioned as a method that would return an int if the registrationNo variable of the Spaceship class was an int."", ""getRegistrationNo()""); (""Spaceship"", ""The Spaceship class is related to the registrationNo variable because it is mentioned as having a registrationNo variable."", ""registrationNo"")"
"The Java Deque interface, java.util.Deque, represents a double ended queue, meaning a queue where you can add and remove elements to and from both ends of the queue.",NULL
The LinkedList class is a pretty standard Deque and Queue implementation.,"(""LinkedList"", ""LinkedList is a Deque implementation"", ""Deque"")"
The Java ArrayDeque class stores its elements internally in an array.,"(""ArrayDeque"", ""The ArrayDeque class stores its elements internally in an array, indicating a relationship between ArrayDeque and array."", ""array"")"
Before you can use a Java Deque you must create an instance of one of the classes that implements the Deque interface.,NULL
You add elements to the beginning end of a Deque using the add() method.,NULL
"If the element cannot be inserted into the Deque, the add() method will throw an exception.",NULL
"This is different from the offer() method, which will return false if it cannot insert the element.",NULL
The addLast() method also adds an element to the end (tail) of a Java Deque.,NULL
This is the Deque interface's equivalent of the add() method inherited from the Queue interface.,"(""Deque"", ""The Deque interface has an equivalent of the add() method, indicating a relationship between the Deque class and the add() method."", ""add()""); (""Queue"", ""The add() method is inherited from the Queue interface, indicating a relationship between the Queue class and the add() method."", ""add()"")"
Here is an example of adding an element to a Java Deque instance using the addLast() method:,"(""Deque"", ""The Deque class has a method called addLast(), indicating a relationship between the Deque class and the addLast() method."", ""addLast()""); (""Java"", ""The Deque class is part of the Java package, indicating a relationship between the Java package and the Deque class."", ""Deque"")"
"If the element cannot be inserted into the Deque, the addLast() method will throw an exception.",NULL
This is different from the offerLast() method which will return false if the element cannot be added to the Deque.,NULL
To add an element at the beginning (head) instead of the end of a Java Deque you call the addFirst() method instead.,NULL
"If the element cannot be added to the beginning of the Deque, the addFirst() method will throw an exception.",NULL
This is different from the offerFirst() method which will return false if an element cannot be inserted in the beginning of the Deque.,NULL
The offer() method adds an element to the end (tail) of the Deque.,NULL
This is different from the add() method which will throw an exception is adding an element to the end of the Deque fails.,NULL
Here is an example of how to add an element to the end of a Java Deque using the offer() method:,NULL
"The offerLast() method adds an element to the end (tail) of the Deque, just like offer().","(""OfferLast"", ""The offerLast() method adds an element to the end (tail) of the Deque"", ""Deque"")"
The method name offerLast() is just a bit more saying about where the element is added to the Deque.,NULL
This is different from the addLast() method which will throw an exception is adding an element to the end of the Deque fails.,NULL
Here is an example of how to add an element to the end of a Java Deque using the offerLast() method:,NULL
The offerFirst() method adds an element to the beginning (head) of the Deque.,NULL
This is different from the addFirst() method which will throw an exception is adding an element to the beginning of the Deque fails.,NULL
Here is an example of how to add an element to the beginning of a Java Deque using the offerFirst() method:,NULL
The push() method adds an element to the beginning (head) of a Java Deque method.,NULL
"If adding the element fails, for instance if the Deque is full, the push() method will throw an exception.","(""Deque"", ""The Deque class has a method called push(), indicating a relationship between the two."", ""push()""); (""push()"", ""The push() method is related to the exception class because it throws an exception when the Deque is full, indicating a cause-and-effect relationship between the two."", ""exception"")"
Here is an example of adding an element to the beginning of a Java Deque using the push() method:,"(""Deque"", ""The push method is used in the context of the Deque class, indicating a relationship between the two as the push method is a part of the Deque's functionality."", ""push""); (""Java"", ""The Deque class is part of the Java package, indicating a relationship between the two as Deque is a component of Java's collections framework."", ""Deque"")"
The peek() method returns the first element from the beginning (head) of a Java Deque without removing it.,"(""Peek"", ""The peek() method operates on a Java Deque, indicating a relationship between the two."", ""Java Deque""); (""Java Deque"", ""Java Deque is a part of the Java package, indicating a relationship between the two."", ""Java"")"
Here is an example of peeking at the first element of a Java Deque using the peek() method:,"(""Deque"", ""The Deque class has a method called peek, which suggests a relationship between the two entities as the peek method is used in conjunction with the Deque class."", ""peek""); (""Java"", ""The Java package is related to the Deque class as Deque is a part of the Java package, specifically the java.util package."", ""Deque"")"
The peekFirst() method returns the first element from the beginning (head) of a Java Deque without removing it.,NULL
"This is similar to how peek() works, but the method name peekFirst() is a bit more saying about which end of the Deque you peek at.","(""Peek"", ""Peek and Peekfirst are related as they are both methods that seem to have similar functionality, with Peekfirst being more specific about the end of the Deque it is peeking at."", ""Peekfirst""); (""Peekfirst"", ""Peekfirst is a method that is used in relation to the Deque class, as it is used to peek at one end of the Deque."", ""Deque"")"
Here is an example of peeking at the first element of a Java Deque using the peekFirst() method:,NULL
To peek at the last element of a Java Deque you can use the peekLast() method.,NULL
Here is an example of peeking at the last element of a Java Deque using the peekLast() method:,NULL
The getFirst() method returns the first element from the beginning (head) of a Java Deque without removing it.,NULL
Here is an example of peeking at the first element of a Java Deque using the getFirst() method:,NULL
To peek at the last element of a Java Deque you can use the getLast() method.,NULL
Here is an example of peeking at the last element of a Java Deque using the getLast() method:,"(""Deque"", ""The getLast method is used in conjunction with the Deque class to retrieve the last element."", ""getLast""); (""Java"", ""The Deque class is part of the Java package, indicating a relationship between the two."", ""Deque"")"
The remove() method removes the first element of a Java Deque.,NULL
The remove() method returns the element that is removed from the Deque.,NULL
Here is an example of removing the first element a Java Deque using the remove() method:,"(""Deque"", ""The Deque class has a relationship with the remove() method because the remove() method is used to remove the first element from a Java Deque."", ""remove()""); (""Java"", ""The Java package has a relationship with the Deque class because Deque is a part of the Java package."", ""Deque"")"
This is different from poll() which returns null if the Deque is empty.,NULL
The removeFirst() method also removes the first element from a Deque - the element at the head of the Deque.,NULL
Here is an example of removing the first element of a Java Deque using the removeFirst() method:,NULL
This is different from pollFirst() which returns null if the Deque is empty.,NULL
The removeLast() method removes the last element of a Deque - meaning the element at the tail of the Deque.,NULL
Here is an example of removing the last element of a Java Deque using the removeLast() method:,NULL
After running this Java example the removedElement variable will point to the String object element 2 - since that element was the last element of the Deque when removeLast() was called.,"(""RemovedElement"", ""The removedElement variable is related to the Deque because it points to the String object that was removed from the Deque when removeLast() was called."", ""Deque""); (""RemoveLast"", ""The removeLast() method is related to the Deque because it is a method that operates on the Deque, specifically removing the last element from it."", ""Deque"")"
This is different from pollLast() which returns null if the Deque is empty.,NULL
The poll() method removes an element from the beginning of the Deque.,NULL
This is different than remove() which throws an exception if the Deque is empty.,NULL
Here is an example of removing the first element from a Java Deque using the poll() method:,"(""Deque"", ""The poll() method is used in conjunction with the Deque class to remove the first element."", ""poll()""); (""Java"", ""The Deque class is part of the Java package."", ""Deque"")"
"The pollFirst() method removes an element from the beginning of the Deque, just like poll().","(""PollFirst"", ""The pollFirst() method is related to the Deque class because it operates on the Deque, removing an element from its beginning."", ""Deque""); (""Poll"", ""The poll() method is related to the Deque class because it is compared to pollFirst() which operates on the Deque, implying that poll() also operates on the Deque."", ""Deque"")"
The method name pollFirst() is just a bit more saying about from where the method removes elements.,NULL
This is different than removeFirst() which throws an exception if the Deque is empty.,NULL
Here is an example of removing the first element from a Java Deque using the pollFirst() method:,NULL
The pollLast() method removes an element from the end (tail) of the Deque.,NULL
This is different than removeLast() which throws an exception if the Deque is empty.,NULL
Here is an example of removing the last element from a Java Deque using the pollLast() method:,NULL
The pop() method removes an element from the beginning (head) of a Java Deque.,NULL
"If removing the element fails, for instance if the Deque is empty, the pop() method will throw an exception.","(""Deque"", ""The Deque class has a method called pop(), indicating a relationship between the two."", ""pop()""); (""pop()"", ""The pop() method is related to the exception class because it throws an exception when the Deque is empty, indicating a cause-and-effect relationship between the two."", ""exception"")"
Here is an example of removing the first element from a Java Deque using the pop() method:,"(""Deque"", ""The Deque class has a relationship with the pop method because the pop method is used to remove the first element from a Deque."", ""pop""); (""Java"", ""The Java package has a relationship with the Deque class because Deque is a part of the Java package."", ""Deque"")"
You can use the Java Deque contains() method to check if a Deque contains a given element.,"(""Deque"", ""The Deque class has a contains() method, indicating a relationship between the two."", ""contains()""); (""Java"", ""The Deque class is part of the Java package, indicating a relationship between the two."", ""Deque"")"
"The contains() method will return true if the Deque contains the element, and false if not.",NULL
Here is an example of checking if a Java Deque contains a specific element using the contains() method:,"(""Deque"", ""The Deque class has a relationship with the contains() method because the contains() method is used to check if a specific element is present in a Deque object."", ""contains()""); (""Java"", ""The Java package has a relationship with the Deque class because Deque is a part of the Java package."", ""Deque"")"
The Java Deque size() method returns the number of elements stored in the Java Deque at the time you invoke the method.,NULL
Here is an example of obtaining the number of elements in a Java Deque using its size() method:,NULL
After running this code the size variable will contain the value 2 because the Deque contains 2 element at the time size() is called.,"(""Deque"", ""The Deque class has a method called size() that returns the number of elements in the Deque."", ""size()""); (""size"", ""The size variable is related to the size() method because the size variable will contain the value returned by the size() method."", ""size()"")"
"When you have specified a generic type for a Java collection, that generic type also works for the Iterator returned by the iterator() method.","(""Java collection"", ""The Java collection returns an Iterator when the iterator() method is called."", ""Iterator""); (""iterator()"", ""The iterator() method returns an Iterator."", ""Iterator"")"
Notice how it is not necessary to cast the String returned from the iterator.next() method call.,NULL
"Because the Iterator has its generic type set to String, the Java compiler already knows that next() will return a String.","(""Iterator"", ""The Iterator class has a method called next(), indicating a relationship between the two."", ""next()""); (""next()"", ""The next() method returns a String, indicating a relationship between the method and the class."", ""String""); (""Iterator"", ""The Iterator has its generic type set to String, indicating a relationship between the class and the type."", ""String""); (""Java"", ""The Java compiler is aware of the Iterator class, indicating a relationship between the package and the class."", ""Iterator""); (""Java"", ""The Java compiler is aware of the String class, indicating a relationship between the package and the class."", ""String"")"
The methods hashCode() and equals() play a distinct role in the objects you insert into Java collections.,"(""HashCode"", ""HashCode method is used in Java Collections"", ""Java Collections"")"
equals() is used in most collections to determine if a collection contains a given element.,NULL
"The ArrayList iterates all its elements and execute ""123"".equals(element) to determine if the element is equal to the parameter object ""123"".","(""ArrayList"", ""The ArrayList class uses the equals method to compare elements."", ""equals"")"
It is the String.equals() implementation that determines if two strings are equal.,NULL
"The ArrayList again iterates all its elements and execute ""123"".equals(element) to determine if the element is equal to the parameter object ""123"".","(""ArrayList"", ""The ArrayList class uses the equals method to compare elements."", ""equals"")"
"As you can see, a proper implementation of .equals() is essential for your own classes to work well with the Java Collection classes.","(""Java Collection"", ""The Java Collection class is related to the .equals() method because a proper implementation of .equals() is essential for classes to work well with the Java Collection classes."", "".equals()"")"
"That depends on your application, the classes, and what you are trying to do.",NULL
"The hashCode() method of objects is used when you insert them into a HashTable, HashMap or HashSet.","(""hashCode()"", ""The hashCode() method is used when you insert objects into a HashTable"", ""HashTable""); (""hashCode()"", ""The hashCode() method is used when you insert objects into a HashMap"", ""HashMap"")"
"If you do not know the theory of how a hashtable works internally, you can read about hastables on Wikipedia.org.",NULL
The hashtable then iterates this area (all keys with the same hash code) and uses the key's equals() method to find the right key.,"(""Hashtable"", ""The hashtable contains keys, so it is related to the Key class."", ""Key""); (""Key"", ""The key uses the equals() method to find the right key, so the Key class is related to the equals() method."", ""Equals()"")"
"So, as you can see, a combination of the hashCode() and equals() methods are used when storing and when looking up objects in a hashtable.","(""Hashcode"", ""The Hashcode method is used when storing objects in a Hashtable"", ""Hashtable""); (""Equals"", ""The Equals method is used when looking up objects in a Hashtable"", ""Hashtable"")"
"Here are two rules that are good to know about implementing the hashCode() method in your own classes, if the hashtables in the Java Collections API are to work correctly:","(""HashCode"", ""The hashCode method is related to the Java Collections API because it is used to ensure the correct functioning of hashtables in the API."", ""Java Collections API""); (""Classes"", ""The Classes entity is related to the HashCode entity because the hashCode method is implemented in classes."", ""HashCode"")"
Here are two example implementation of the hashCode() method matching the equals() methods shown earlier:,NULL
For a 100% precise description of how to implement equals() and hashCode() you should check out the official JavaDoc's.,"(""equals()"", ""They are related because they are both methods that are often implemented together in Java classes."", ""hashCode()""); (""JavaDoc"", ""JavaDoc is related to equals() because it provides a description of how to implement the equals() method."", ""equals()"")"
The purpose of this text was mostly to explain how they are used by the Java Collection classes.,NULL
"This means, that a class that implements the Java Iterable interface can have its elements iterated.","(""Class"", ""A class implements the Java Iterable interface, indicating a relationship between the two."", ""Java Iterable""); (""Java Iterable"", ""Java Iterable is an interface, indicating a relationship between the two."", ""Interface""); (""Class"", ""A class can implement an interface, indicating a relationship between the two."", ""Interface""); (""Java"", ""Java Iterable is part of the Java package, indicating a relationship between the two."", ""Java Iterable""); (""Java"", ""A class can be part of the Java package, indicating a relationship between the two."", ""Class"")"
"You can iterate the objects of a Java Iterable in three ways: Via the , by obtaining a Java Iterator from the Iterable, or by calling the Java Iterable forEach() method.","(""Iterable"", ""The Iterable and Iterator are related because you can obtain an Iterator from the Iterable."", ""Iterator""); (""Iterable"", ""The Iterable and forEach() method are related because the forEach() method is called on the Iterable."", ""forEach()"")"
"Then it uses a for-each loop to iterate the elements of the List, and print out the toString() value of each element.",NULL
The second way you can iterate the elements of a Java Iterable is by obtaining a Java Iterator from it by calling the Iterable iterator() method.,"(""Iterable"", ""The Iterable class is related to the Iterator class because an Iterator can be obtained from an Iterable by calling the iterator() method."", ""Iterator""); (""Iterable"", ""The Iterable class is related to the iterator() method because the iterator() method is called on an Iterable to obtain an Iterator."", ""iterator()"")"
The third way to iterate the elements of a Java Iterable is via its forEach() method.,NULL
Here is an example of iterating the elements of an Iterable via its forEach() method:,NULL
The Java Iterable interface (java.lang.Iterable) is one of the root interfaces of the Java Collections API.,"(""Iterable"", ""The Iterable interface is part of the Java Collections API"", ""Java Collections API""); (""Iterable"", ""The Iterable interface is defined in the java.lang.Iterable package"", ""java.lang.Iterable"")"
"Therefore, there are several classes in Java that implements the Java Iterable interface.",NULL
You can obtain a Java Spliterator from a Java Iterable via its spliterator() method.,"(""Java Iterable"", ""The Java Iterable and the spliterator() method are related because the spliterator() method is invoked on a Java Iterable to obtain a Java Spliterator."", ""spliterator()""); (""spliterator()"", ""The spliterator() method and the Java Spliterator are related because the spliterator() method returns a Java Spliterator."", ""Java Spliterator"")"
"If you are writing some code that needs to iterate a collection lots of times in a tight loop, let's say iterate a Java List thousands of times per second, iterating the List via the Java for-each loop is slower than iterating the list via a standard for-loop as seen here: () .","(""Java"", ""Java is a class that contains the List class"", ""List""); (""Java"", ""Java is a class that contains the for-each loop method"", ""for-each loop""); (""Java"", ""Java is a class that contains the for-loop method"", ""for-loop""); (""List"", ""The List class can be iterated using the for-each loop method"", ""for-each loop"")"
"The reason the for-each loop is slower is, that each iteration will call the List iterator() method, which will create a new Iterator object.","(""List"", ""The List class has a method called iterator(), which establishes a relationship between the two entities."", ""iterator()""); (""iterator()"", ""The iterator() method creates a new Iterator object, indicating a relationship between the method and the class."", ""Iterator"")"
The standard Java collection interface Collection contains a method called iterator().,NULL
By calling iterator() you can obtain an iterator from the given Collection.,"(""iterator()"", ""The iterator() method is related to the Collection class because it is called on a Collection object to obtain an iterator."", ""Collection""); (""Iterator"", ""The Iterator class is related to the Collection class because an iterator can be obtained from a Collection object."", ""Collection"")"
"You can also obtain an Iterator from many of the Java Collection data structures, e.g.",NULL
The first method is the Iterator hasNext() method which returns true if the Iterator contains more elements.,NULL
"In other words, if the Iterator has not yet iterated over all of the elements in the collection the Iterator was obtained from - the hasNext() method will return true.","(""Iterator"", ""The Iterator class has a hasNext() method, indicating a relationship between the two entities."", ""hasNext()""); (""Iterator"", ""The Iterator is obtained from a collection, indicating a relationship between the two entities, where the Iterator is dependent on the collection."", ""collection"")"
If the Iterator has iterated over all elements in the underlying collection - the hasNext() method returns false.,"(""Iterator"", ""The Iterator class has a method called hasNext(), indicating a relationship between the two."", ""hasNext()""); (""Iterator"", ""The Iterator is iterating over the elements in the underlying collection, indicating a relationship between the two."", ""collection"")"
The second method to pay attention to is the next() method.,NULL
The next() method returns the next element of the collection the Iterator is iterating over.,"(""Next"", ""The next() method is related to the Iterator class because it is used to retrieve the next element from the collection that the Iterator is iterating over."", ""Iterator""); (""Iterator"", ""The Iterator class is related to the Collection class because it is used to iterate over the elements of the collection."", ""Collection"")"
In that case you will get a ConcurrentModificationException the next time you call the Iterator next() method.,"(""ConcurrentModificationException"", ""ConcurrentModificationException is related to Iterator because it is thrown when using the Iterator's next() method"", ""Iterator""); (""Iterator"", ""Iterator is related to next because next is a method of the Iterator class"", ""next"")"
The Java Iterator interface has a remove() method which lets you remove the element just returned by next() from the underlying collection.,"(""Iterator"", ""The Iterator interface has a remove() method, indicating a clear relationship between the two."", ""remove()""); (""Iterator"", ""The Iterator interface is related to the next() method, as the remove() method removes the element returned by next(), indicating a relationship between the Iterator and next()."", ""next()"")"
"The Java Iterator forEachRemaining() method can iterate over all of the elements remaining in the Iterator internally, and for each element call a Java Lambda Expression passed as parameter to forEachRemaining() .","(""Iterator"", ""The Iterator class has a method called forEachRemaining(), indicating a relationship between the two."", ""forEachRemaining()""); (""forEachRemaining()"", ""The forEachRemaining() method takes a Lambda Expression as a parameter, indicating a relationship between the two."", ""Lambda Expression"")"
Here is an example of using the Java Iterator forEachRemaining() method:,"(""Iterator"", ""The Iterator class has a method called forEachRemaining(), indicating a clear relationship between the two entities."", ""forEachRemaining()""); (""Java"", ""The Java package contains the Iterator class, indicating a clear relationship between the two entities."", ""Iterator"")"
"The Java List interface, java.util.List, represents an ordered sequence of objects.",NULL
"If the List is not typed, using Java Generics, then you can even mix objects of different types (classes) in the same List.","(""List"", ""List is using Java Generics"", ""Java Generics"")"
These List implementations are explained in more detail in my java.util.concurrent tutorial .,NULL
You create a List instance by creating an instance of one of the classes that implements the List interface.,NULL
"Remember, most often you will use the ArrayList class, but there can be cases where using one of the other implementations might make sense.","(""ArrayList"", ""The ArrayList class is related to itself as it is being described and used as an example in the given text."", ""ArrayList""); (""ArrayList"", ""The ArrayList class is related to itself as it is being described and used as an example in the given text, however this relationship is not that useful."", ""ArrayList"")"
"Thus, you need to cast them to the concrete class (or interface) that you know the object to be of.",NULL
You insert elements (objects) into a Java List using its add() method.,NULL
Here is an example of adding elements to a Java List using the add() method:,"(""List"", ""The List class has an add() method, indicating a relationship between the two."", ""add()""); (""Java"", ""The Java package contains the List class, indicating a relationship between the two."", ""List"")"
The first three add() calls add a String instance to the end of the list.,"(""Add"", ""The add() method is used to add a String instance to the end of the list, indicating a relationship between the add() method and the String class."", ""String""); (""Add"", ""The add() method is used to add elements to the end of the list, indicating a relationship between the add() method and the List class."", ""List"")"
"The List interface has a version of the add() method that takes an index as first parameter, and the element to insert as the second parameter.",NULL
"The addAll() method takes a Collection as parameter, so you can pass either a List or Java Set as parameter.","(""AddAll"", ""The addAll() method takes a Collection as parameter, indicating a relationship between the method and the class."", ""Collection""); (""AddAll"", ""The addAll() method can take a List as parameter, indicating a relationship between the method and the class."", ""List""); (""AddAll"", ""The addAll() method can take a Set as parameter, indicating a relationship between the method and the class."", ""Set""); (""Collection"", ""List is a subclass of Collection, indicating a relationship between the two classes."", ""List"")"
"In other words, you can add all elements from a List or Set into a List with addAll() .","(""List"", ""The List class has a method called addAll() to add all elements from a List or Set into it"", ""addAll()""); (""Set"", ""The Set class can have its elements added to a List using the addAll() method"", ""addAll()"")"
The indexOf() method finds the index of the first occurrence in the List of the given element.,NULL
The lastIndexOf() method finds the index of the last occurrence in the List of a given element.,NULL
You can check if a Java List contains a given element using the List contains() method.,"(""List"", ""The List class has a method called contains(), which establishes a relationship between the two entities."", ""contains()""); (""Java"", ""The Java package contains the List class, which establishes a relationship between the two entities."", ""List"")"
Here is an example of checking if a Java List contains an element using the contains() method:,NULL
"Obviously, if the input parameter to contains() is null, the contains() method will not use the equals() method to compare against each element, but rather use the == operator.","(""Contains"", ""The contains() method will use the equals() method to compare against each element if the input parameter is not null."", ""Equals""); (""Contains"", ""The contains() method takes an input parameter to compare against each element."", ""Input Parameter"")"
The Java List interface contains a clear() method which removes all elements from the list when called.,"(""List"", ""The clear method is part of the List interface, indicating a clear relationship between the two."", ""clear""); (""Java"", ""The List interface is part of the Java package, indicating a relationship between the Java package and the List class."", ""List"")"
Here is simple example of removing all elements from a List (clearing) with the clear() method:,NULL
"After the clear() method has been called, the List will be completely empty.",NULL
The Java List interface has a method called retainAll() which is capable of retaining all elements from one List which are also present in another List.,NULL
"In other words, the retain() method removes all the elements from the target List which are not found in the other List.",NULL
Here is a Java example of calling the List retainAll() method:,NULL
"Third, the retainAll() method is called on list, passing otherList as parameter.","(""RetainAll"", ""The RetainAll method is called on the List object, indicating a relationship between the method and the class."", ""List""); (""OtherList"", ""The OtherList is passed as a parameter to the RetainAll method, indicating a relationship between the OtherList class and the RetainAll method."", ""RetainAll"")"
"After list.retainAll(otherList) has finished executing, the list will only contain those elements which were both present in list and otherList before retainAll() was called.","(""List"", ""List is related to RetainAll because RetainAll is a method called on the List object."", ""RetainAll""); (""RetainAll"", ""RetainAll is related to OtherList because OtherList is passed as an argument to the RetainAll method."", ""OtherList"")"
You can obtain the number of elements in the List by calling the size() method.,NULL
The Java List interface has a method called subList() which can create a new List with a subset of the elements from the original List.,"(""Java List"", ""The Java List interface has a method called subList(), indicating that subList() is a method of the Java List interface."", ""subList()""); (""Java List"", ""The Java List interface is related to the List interface, as indicated by the phrase 'The Java List interface' which implies that Java List is a type of List."", ""List"")"
The subList() method takes 2 parameters: A start index and and end index.,NULL
Here is a Java example of creating a sublist of elements from another List using the subList() method:,NULL
"After executing the list.subList(1,3) instruction the sublist will contain the elements at index 1 and 2.","(""LIST"", ""The LIST class contains the SUBLIST method, which is used to get a subset of the list."", ""SUBLIST"")"
"The list.subList(1,3) call will include index 1, but exclude index 3, thereby keeping the elements at index 1 and 2.",NULL
You can convert a Java List to a Java Array using the List toArray() method.,"(""List"", ""The List class has a relationship with the toArray() method because the toArray() method is used to convert a Java List to a Java Array."", ""toArray()""); (""Array"", ""The Array class has a relationship with the toArray() method because the toArray() method is used to convert a Java List to a Java Array, resulting in an Array object."", ""toArray()"")"
"Note that even if we pass a String array of size 0 to the toArray(), the array returned will have all the elements in the List in it.","(""String"", ""String is passed as an argument to the toArray() method, indicating a relationship between the two entities."", ""toArray""); (""List"", ""The toArray() method is called on the List entity, indicating a relationship between the two entities."", ""toArray"")"
It is the Arrays.asList() method that converts the array to a List.,"(""Arrays"", ""The Arrays class contains the asList method."", ""asList""); (""asList"", ""The asList method returns a List object."", ""List"")"
You can sort a Java List using the Collections sort() method.,"(""List"", ""The List class is related to the Collections class because the Collections class has a method that can be used to sort a List."", ""Collections""); (""Collections"", ""The Collections class is related to the sort() method because the sort() method is a part of the Collections class."", ""sort()"")"
"If the List contains objects that implement the Comparable interface (java.lang.Comparable), then the objects can compare themselves to each other.","(""List"", ""The List contains objects that implement the Comparable interface, indicating a relationship between the two."", ""Comparable""); (""List"", ""The List contains objects that implement the java.lang.Comparable interface, indicating a relationship between the two."", ""java.lang.Comparable"")"
"The Java String class implements the Comparable interface, you can sort them in their natural order, using the Collections sort() method.","(""String"", ""The String class implements the Comparable interface, indicating a clear relationship between the two entities."", ""Comparable""); (""String"", ""The String class can be sorted using the sort() method, indicating a relationship between the String class and the sort() method."", ""sort()"")"
"If the objects in the Java List do not implement the Comparable interface, or if you want to sort the objects in another order than their compare() implementation, then you need to use a Comparator implementation (java.util.Comparator).","(""Java List"", ""The Java List uses the Comparable interface to sort its objects"", ""Comparable""); (""Java List"", ""The Java List can use a Comparator implementation to sort its objects in a different order"", ""Comparator""); (""Comparable"", ""The Comparable interface is used in the java.util.Comparator package as an alternative for sorting"", ""java.util.Comparator"")"
You obtain an Iterator by calling the iterator() method of the List interface.,"(""Iterator"", ""Iterator is obtained by calling the iterator() method"", ""iterator()""); (""iterator()"", ""The iterator() method is part of the List interface"", ""List"")"
Once you have obtained an Iterator you can keep calling its hasNext() method until it returns false.,NULL
Calling hasNext() is done inside a while loop as you can see.,NULL
Inside the while loop you call the Iterator next() method of the Iterator interface to obtain the next element pointed to by the Iterator.,"(""Iterator"", ""The Iterator class has a method called next() to obtain the next element."", ""next()""); (""Iterator"", ""The Iterator interface is related to the Iterator class as it defines the methods that the Iterator class implements."", ""Iterator"")"
"Inside the for loop the example accesses the elements in the List via its get() method, passing the incrementing variable i as parameter.","(""List"", ""The List class has a get() method that is used to access its elements."", ""get()""); (""get()"", ""The get() method takes the variable i as a parameter to access a specific element in the List."", ""i"")"
"Again, if the List is typed using Java Generics to e.g.",NULL
"Hence, the compiler knows that only a String can be returned from the get() method.",NULL
Therefore you do not need to cast the element returned by get() to String.,NULL
Obtaining a Stream from a List in Java is done by calling the List stream() method.,"(""List"", ""The List class has a stream() method, indicating a relationship between the two entities."", ""stream()""); (""stream()"", ""The stream() method returns a Stream, indicating a relationship between the two entities."", ""Stream"")"
It is the last line of this example that calls the List stream() method to obtain the Stream representing the elements in the List.,"(""List"", ""The List class is related to the stream() method because it calls this method to obtain the Stream representing its elements."", ""stream()""); (""stream()"", ""The stream() method is related to the Stream class because it returns an instance of this class, representing the elements in the List."", ""Stream"")"
Once you have obtained a Stream from a List you can iterate the Stream by calling its forEach() method.,"(""Stream"", ""The Stream class has a forEach() method that can be called to iterate the Stream."", ""forEach()""); (""List"", ""A Stream can be obtained from a List."", ""Stream"")"
Here is an example of iterating the elements of a List using the Stream forEach() method:,"(""List"", ""The List class is related to the Stream class because the Stream class is used to iterate the elements of a List"", ""Stream""); (""Stream"", ""The Stream class is related to the forEach() method because the forEach() method is a part of the Stream class"", ""forEach()"")"
"Calling the forEach() method will make the Stream iterate all the element of the Stream internally, and call the Consumer passed as parameter to the forEach() method for each element in the Stream.","(""Stream"", ""The Stream class has a forEach() method that can be called on it."", ""forEach()""); (""forEach()"", ""The forEach() method takes a Consumer as a parameter."", ""Consumer"")"
"The Java Map interface, java.util.Map, represents a mapping between a key and a value.","(""java.util"", ""java.util is a package that contains the java.util.Map interface"", ""java.util.Map""); (""Java Map"", ""Java Map is another name for the java.util.Map interface"", ""java.util.Map"")"
To create a Java Map you must create an instance of one the classes that implement the Java Map interface.,NULL
To add elements to a Map you call its put() method.,NULL
The three put() calls maps a string value to a string key.,"(""Put"", ""The put() method is related to the String class because it maps a string value to a string key."", ""String"")"
Here is an example of auto-boxing primitive parameters passed to the put() method:,NULL
The value passed to the put() method in the above example is a primitive int.,NULL
"Java auto-boxes it inside an Integer instance though, because the put() method requires an Oject instance as both key and value.","(""Integer"", ""The Integer class is related to the put() method because the put() method requires an Object instance, and Integer is a subclass of Object, which can be used as an argument for the put() method."", ""put()""); (""Object"", ""The Object class is related to the put() method because the put() method requires an Object instance as both key and value."", ""put()"")"
Auto-boxing would also happen if you passed a primitive as key to the put() method.,"(""put()"", ""The put() method is related to primitive because it accepts a primitive as a key."", ""primitive""); (""Auto-boxing"", ""Auto-boxing is related to primitive because it happens when a primitive is passed as an argument."", ""primitive"")"
"If you call put() more than once with the same key, the latest value passed to put() for that key will overwrite what is already stored in the Map for that key.","(""Map"", ""The Map class has a method called put() that is used to store values in the Map."", ""put()""); (""put()"", ""The put() method takes a key as an argument to store and retrieve values from the Map."", ""key"")"
To obtain the value stored by the null key you call the get() method with null as parameter value.,NULL
Just keep in mind that you will get a null out when you call get() later with that key - so this will return null:,NULL
The Java Map interface has a method called putAll() which can copy all key + value pairs (entries) from another Map instance into itself.,"(""Map"", ""The Map interface has a method called putAll(), indicating a clear relationship between the two as the method is part of the interface."", ""putAll()"")"
Here is an example of copying all entries from one Java Map into another via putAll():,NULL
"Calling mapB.putAll(mapA) will only copy entries from mapA into mapB, not from mapB into mapA.","(""MapA"", ""MapA and MapB are related because they are both involved in the putAll operation, where entries are copied from mapA into mapB""}"", ""MapB""); (""PutAll"", ""PutAll is a method that is called on mapA, indicating a relationship between the two""}"", ""MapA"")"
"To copy entries the other way, you would have to execute the code mapA.putAll(mapB).","(""MAPA"", ""MAPA is the source of the PUTALL method, which is used to copy entries from MAPB"", ""PUTALL""); (""PUTALL"", ""PUTALL method is used to copy entries from MAPB to MAPA"", ""MAPB"")"
"To get a specific element stored in a Java Map you call its get() method, passing along the key for that element as parameter.","(""Map"", ""The Map class has a get() method, which is used to retrieve a specific element from the map."", ""get()""); (""Java"", ""The Map class is part of the Java package, indicating that Map is a Java class."", ""Map"")"
"Notice that the get() method returns a Java Object, so we have to cast it to a String (because we know the value is a String).","(""Get"", ""The get() method returns a Java Object, indicating a relationship between the Get method and the Java Object class."", ""Java Object""); (""Get"", ""The get() method is cast to a String, indicating a relationship between the Get method and the String class."", ""String"")"
"If we had specified a generic type for the key and value of the Map, then it would not have been necessary to cast the object returned by get() method.",NULL
The Java Map interface has a getOrDefault() method which can return a default value supplied by you - in case no value is stored in the Map by the given key.,"(""Java Map"", ""The Java Map interface has a getOrDefault() method, indicating that getOrDefault() is a method of the Java Map interface."", ""getOrDefault()""); (""Map"", ""The Map interface has a getOrDefault() method, indicating that getOrDefault() is a method of the Map interface."", ""getOrDefault()"")"
"This example creates a Map and stores three values in it using the keys A, B and C. Then the example calls the Map getOrDefault() method, passing the String E as key, along with a default value - the String default value.","(""Map"", ""The Map class has a method called getOrDefault, which establishes a relationship between the two entities."", ""getOrDefault""); (""Map"", ""The Map class uses the String class as keys, which establishes a relationship between the two entities."", ""String"")"
Since the Map does not contain any object stored by the key E the given default value will be returned - which is the String default value passed as the last parameter to the getOrDefault() method.,"(""Map"", ""The Map class has a method called getOrDefault(), which suggests a relationship between the Map class and the getOrDefault() method."", ""getOrDefault()""); (""String"", ""The String class is related to the getOrDefault() method because the method returns a default value of type String, indicating a connection between the String class and the getOrDefault() method."", ""getOrDefault()"")"
You can check if a Java Map contains a specific key using the containsKey() method.,NULL
You can iterate all the keys of a Java Map via its keySet() method.,NULL
"As you can see, the key Iterator returns every key stored in a Java Map, one by one (one for each call to next()).","(""Iterator"", ""The Iterator is related to the Map because it returns every key stored in a Java Map."", ""Map""); (""Iterator"", ""The Iterator is related to the next() method because the next() method is called on the Iterator to retrieve the next key."", ""next()"")"
"Once you have the key, you can obtain the element stored for that key using the Map get() method.","(""Map"", ""The Map class has a get() method, indicating a relationship between the two entities."", ""get()""); (""key"", ""The key is used in conjunction with the Map class, suggesting a relationship between the key and the Map."", ""Map"")"
"In the example above, the Iterator next() method returns an Object - and so does the get() method.","(""Iterator"", ""The Iterator class has a next() method"", ""next()""); (""Iterator"", ""The Iterator class has a get() method"", ""get()""); (""next()"", ""The next() method returns an Object"", ""Object"")"
Notice how a generic type is now also specified for the Iterator obtained from map.keySet().iterator().,"(""Map"", ""Map has a method keySet() that returns a KeySet object"", ""KeySet""); (""KeySet"", ""KeySet has a method iterator() that returns an Iterator object"", ""Iterator"")"
You obtain a Collection of the values stored in a Map via the values() method.,"(""Collection"", ""Collection is the return type of the values() method"", ""values()""); (""Map"", ""The values() method is used to obtain a Collection of the values stored in a Map"", ""values()"")"
Notice how the key and value can be obtained from each Map.Entry instance.,"(""Map.Entry"", ""The key is obtained from each Map.Entry instance, indicating a relationship between Map.Entry and key."", ""key""); (""Map.Entry"", ""The value is obtained from each Map.Entry instance, indicating a relationship between Map.Entry and value."", ""value"")"
You can remove all entries in a Java Map using the clear() method.,NULL
It is possible to replace an element in a Java Map using the replace() method.,NULL
The replace() method will only insert the new value if there is already an existing value mapped to the key.,NULL
"This is different from how put() works, which always insert the value no matter what.",NULL
Here is an example of replacing one value with another using the Java Map replace() method:,"(""Map"", ""The Map class contains the replace() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""replace()""); (""Java"", ""The Java package contains the Map class, indicating a clear relationship between the two entities as the class is a part of the package."", ""Map"")"
You can read the number of entries in a Java Map using the size() method.,NULL
The number of entries in a Java Map is also referred to as the Map size - hence the method name size() .,NULL
Here is an example of reading the number of entries in a Map using the size() method:,NULL
This method is called isEmpty() and it returns either true or false.,NULL
The isEmpty() method will return false if the Map instance contains 1 or more entries.,NULL
The Map compute() method takes a key object and a lambda expression as parameters.,NULL
Here is an example of calling the Java Map compute() method:,"(""Map"", ""The compute() method is a part of the Map class, indicating a clear relationship between the two entities as the method is used in conjunction with the class."", ""compute()""); (""Java"", ""The Map class is part of the Java package, indicating a relationship between the two entities as the class is defined within the package."", ""Map"")"
"The compute() method will call the lambda expression internally, passing the key object and whatever value is stored in the Map for that key object, as parameters to the lambda expression.","(""Compute"", ""The compute() method will call the lambda expression internally, indicating a relationship between the two entities where the compute method invokes the lambda expression."", ""Lambda Expression""); (""Map"", ""The key object is stored in the Map, indicating a relationship between the Map and the Key where the Map contains or is associated with the Key."", ""Key"")"
"In the example above you can see that the lambda expression checks if the value mapped to the given key is null or not, before calling toString().toUpperCase() on it.",NULL
"The Map computeIfAbsent() method works similarly to the compute() method, but the lambda expression is only called if no entry exists already for the given key.","(""Map"", ""The computeIfAbsent() method is related to the Map class because it is described as a method that works similarly to another method, implying that it is a method of the Map class."", ""computeIfAbsent()""); (""Map"", ""The compute() method is related to the Map class because the text compares the behavior of computeIfAbsent() to compute(), suggesting that compute() is also a method of the Map class."", ""compute()"")"
"However, the lambda expression could have calculated the value in any way it needed to - e.g.",NULL
"The Map merge() method takes a key, a value, and a lambda expression implementing the BiFunction interface as parameters.","(""Map"", ""The Map class has a method called merge(), indicating a relationship between the class and the method."", ""merge()"")"
"If the Map does not have an entry for the key, or if the value for the key is null, the value passed as parameter to the merge() method is inserted for the given key.","(""Map"", ""The Map has an entry for the key, indicating a relationship between the Map class and the key class."", ""key""); (""Map"", ""The merge() method is called on the Map, indicating a relationship between the Map class and the merge() method."", ""merge()"")"
"The Java NavigableMap interface, java.util.NavigableMap, is a sub-interface of the Java SortedMap interface.","(""NavigableMap"", ""NavigableMap is a sub-interface of SortedMap, indicating a clear inheritance relationship between the two interfaces"", ""SortedMap"")"
The java.util package only has one implementation of the NavigableMap interface: The java.util.TreeMap class.,"(""Java.Util"", ""The java.util package contains the TreeMap class"", ""TreeMap""); (""Java.Util"", ""The java.util package has an implementation of the NavigableMap interface"", ""NavigableMap"")"
"There is a Java NavigableMap implementation in the java.util.concurrent package too, but that is outside the scope of this tutorial.",NULL
To create a Java NavigableMap you must create an instance of one of the classes that implements the NavigableMap interface.,"(""NavigableMap"", ""NavigableMap is a part of Java"", ""Java"")"
Here is an example of creating an instance of the Java TreeMap class which implements the NavigableMap interface:,"(""TreeMap"", ""TreeMap implements the NavigableMap interface"", ""NavigableMap""); (""TreeMap"", ""TreeMap is a part of the Java package"", ""Java"")"
The first interesting navigation method of NavigableMap is the descendingKeySet() method.,NULL
The descendingKeySet() method returns a NavigableSet in which the order of the elements is reversed compared to the original key set.,NULL
The descendingMap() method returns a NavigableMap which is a view of the original Map.,"(""DescendingMap"", ""The descendingMap() method returns a NavigableMap which is a view of the original Map, indicating that DescendingMap is related to NavigableMap as its return type"", ""NavigableMap""); (""DescendingMap"", ""The descendingMap() method returns a NavigableMap which is a view of the original Map, indicating that DescendingMap is related to Map as it operates on a Map object"", ""Map"")"
"The headMap() method returns a view of the original NavigableMap which only contains elements that are ""less than"" the given element.",NULL
"The tailMap() method is similar to the headMap() method, except that tailMap() returns all elements that are equal to or higher than the given parameter element.",NULL
"The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys ""c"", ""d"" and ""e"", as these keys are considered equal to or larger than the parameter value ""c"" passed to the tailMap() method.","(""TailMap"", ""The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys 'c', 'd' and 'e'"", ""NavigableMap""); (""TailMap"", ""The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys 'c', 'd' and 'e'"", ""SortedMap""); (""NavigableMap"", ""The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys 'c', 'd' and 'e', as these keys are considered equal to or larger than the parameter value 'c' passed to the tailMap() method"", ""TailMap""); (""SortedMap"", ""The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys 'c', 'd' and 'e'"", ""NavigableMap"")"
The subMap() allows you to pass two parameters demarcating the boundaries of the view map to return.,NULL
The ceilingKey() method returns the least (smallest) key in this map that is greater than or equal to the element passed as parameter to the ceilingKey() method.,NULL
"Thus, floorKey() returns the greatest key which is less than or equal to the parameter value passed to ceilingKey().",NULL
The higherKey() method returns the least (smallest) element in this map that is greater than (not equal too) the element passed as parameter to the higherKey() method.,NULL
"Thus, lowerKey() returns the greatest key which is lower than the parameter value passed to the lowerKey() method.",NULL
"In the example above, the returned lowerKey will be ""1"", as this is the highest key which is lower than the parameter value ""2"" passed to the lowerKey() method.","(""Lowerkey"", ""The Lowerkey method is related to the Lowerkey class because it is likely a part of that class."", ""Lowerkey""); (""Lowerkey()"", ""The Lowerkey() method is related to the Lowerkey class because the method is likely a part of that class."", ""Lowerkey""); (""Parameter"", ""The Parameter class is related to the Lowerkey() method because the method takes a parameter value."", ""Lowerkey()""); (""Parameter value"", ""The Parameter value class is related to the Lowerkey() method because the method is passed a parameter value."", ""Lowerkey()""); (""Example"", ""The Example package is related to the Lowerkey() method because the method is used in the example."", ""Lowerkey()""); (""Returned lowerKey"", ""The Returned lowerKey class is related to the Lowerkey() method because the method returns a lowerKey."", ""Lowerkey()""); (""Highest key"", ""The Highest key class is related to the Lowerkey() method because the method returns the highest key which is lower than the parameter value."", ""Lowerkey()""); (""Parameter value"", ""The Parameter value class is related to the Highest key class because the highest key is determined based on the parameter value."", ""Highest key""); (""Lowerkey() method"", ""The Lowerkey() method is related to the Lowerkey class because it is likely a part of that class."", ""Lowerkey"")"
"methods, except they return a Map.Entry instead of the key object itself.","(""methods"", ""methods return a Map.Entry instead of the key object itself, indicating a relationship between the two entities"", ""Map.Entry""); (""methods"", ""methods return the key object itself, indicating a relationship between the two entities"", ""key"")"
"Each of the methods ceilingEntry(), floorEntry(), higherEntry() and lowerEntry() will be covered in the following sections.","(""Ceilingentry"", ""These two methods are related as they are both used for entry points in a data structure, with ceilingEntry() returning the lowest entry that is greater than or equal to the given key, and floorEntry() returning the greatest entry that is less than or equal to the given key."", ""Floorentry""); (""Highentry"", ""These two methods are related as they are both used for finding nearby entries, with higherEntry() returning the lowest entry that is greater than the given key, and lowerEntry() returning the greatest entry that is less than the given key."", ""Lowentry""); (""Ceilingentry"", ""These two methods are related as they both return entries that are greater than or equal to a given key, with ceilingEntry() returning the lowest such entry and higherEntry() returning the next entry after the given key."", ""Highentry"")"
The ceilingEntry() method returns the key + value stored for the least (smallest) key in the NavigableMap which is higher than or equal to the parameter value passed to the ceilingEntry() method.,NULL
The floorEntry() method returns the key + value for the greatest key which is equal to or lower than the parameter value passed to the floorEntry() method.,NULL
The lowerEntry() method in the NavigableMap interface returns the key + value pair for the highest key which is lower than the parameter value passed to the lowerEntry() method.,NULL
"The Java NavigableSet interface, java.util.NavigableSet, is a subtype of the Java SortedSet interface.","(""NavigableSet"", ""NavigableSet is a subtype of SortedSet, indicating a clear inheritance relationship between the two classes"", ""SortedSet""); (""java.util.NavigableSet"", ""java.util.NavigableSet is a package that contains the NavigableSet class, indicating a containment relationship between the package and the class"", ""NavigableSet"")"
The descendingSet() method returns a NavigableSet in which the order of the elements is reversed compared to this one.,NULL
The subSet() method allows you to pass two parameters demarcating the boundaries of the view set to return.,NULL
"The pollLast() method returns and removes the ""last"" element in the NavigableSet.",NULL
To set properties in a Java Properties instance you use the setProperty() method.,NULL
Notice the first line of the properties file is actually the comment that was passed as second parameter to the store() method call in the code example in the previous section about storing properties to a property file.,"(""Store"", ""The store method is related to properties because it is used to store properties to a property file."", ""Properties""); (""Code"", ""The code is related to the section because the code example is in the section about storing properties to a property file."", ""Section"")"
You can load properties from an XML property file into a Java Properties object via its loadFromXML() method.,NULL
To load properties from a file available on the classpath you need to obtain a Class instance first.,NULL
The file would have to be located in the root directory of the classpath.,"(""Classpath"", ""The file would have to be located in the root directory of the classpath, indicating a relationship between the classpath and the file."", ""File""); (""Root"", ""The file would have to be located in the root directory of the classpath, indicating a relationship between the root directory and the classpath."", ""Classpath"")"
The getProperty() method comes in a version that takes an extra parameter which is the default value to return in case the Properties instance does not contain a value for the given key.,NULL
The System class also has a getProperty() and setProperty() method which are shortcuts to the Properties getProperty() and setProperty() methods of the System Properties instance.,"(""System"", ""The System class has a getProperty() method which is a shortcut to the Properties getProperty() method, indicating a relationship between the System class and the getProperty() method."", ""getProperty()""); (""System"", ""The System class has a setProperty() method which is a shortcut to the Properties setProperty() method, indicating a relationship between the System class and the setProperty() method."", ""setProperty()""); (""Properties"", ""The Properties class has a getProperty() method which is related to the System class's getProperty() method, indicating a relationship between the Properties class and the getProperty() method."", ""getProperty()""); (""Properties"", ""The Properties class has a setProperty() method which is related to the System class's setProperty() method, indicating a relationship between the Properties class and the setProperty() method."", ""setProperty()"")"
Just to make it clear: You should NOT use the put() and get() method of the Properties class!,"(""Properties"", ""The put() method is related to the Properties class because it is mentioned as a method that should not be used with the Properties class."", ""put()"")"
"Instead, the Properties class should have just had an internal Hashtable to keep the property key,value pairs in.",NULL
"The add() method throws an exception in that case, whereas the offer() method just returns false.",NULL
The remove() method throws an exception if the Queue is empty.,NULL
"If the Queue is empty, the element() method throws a NoSuchElementException.","(""Queue"", ""The Queue class has an element method that can be called on it, indicating a relationship between the two."", ""element""); (""element"", ""The element method throws a NoSuchElementException when the Queue is empty, indicating a relationship between the method and the exception."", ""NoSuchElementException"")"
You can remove all elements from a Java Queue using its clear() method.,NULL
After running this code the size variable should contain the value 3 - because the Queue contains 3 elements at the time size() is called.,"(""Queue"", ""The Queue class has a method called size, indicating a relationship between the Queue class and the size method."", ""size"")"
"The Java Set interface, java.util.Set, represents a collection of objects where each object in the Java Set is unique.",NULL
"There are also Set implementations in the java.util.concurrent package, but I will leave the concurrency utilities out of this tutorial.","(""Set"", ""Set is a class that has implementations in the java.util.concurrent package"", ""Java.Util.Concurrent""); (""Java.Util.Concurrent"", ""java.util.concurrent is a sub-package of java.util"", ""Java.Util"")"
To add elements to a Set you call its add() method.,NULL
The Java List interface has a method called addAll() which adds all elements from another Collection (List or Set) to the Set.,"(""Java List"", ""The Java List interface has a method called addAll(), indicating that addAll() is a method of Java List."", ""addAll()""); (""addAll()"", ""The addAll() method adds all elements from another Collection, indicating that addAll() is related to Collection."", ""Collection""); (""Collection"", ""Collection is a parent interface of List, as indicated by the text that mentions Collection (List or Set)."", ""List""); (""Collection"", ""Collection is a parent interface of Set, as indicated by the text that mentions Collection (List or Set)."", ""Set""); (""Java List"", ""Java List is a subtype of Collection, as indicated by the context of the sentence."", ""Collection"")"
"After running this Java code the isEmpty variable will contain the value true, because the Set size() method returns 0 - because the Set in the example contains no elements.","(""Set"", ""The Set class has a Size method that returns the number of elements in the Set."", ""Size"")"
"The order of the sorting in a Java SortedMap is either the natural sorting order of the elements (if they implement java.lang.Comparable), or the order determined by a Comparator that you can give to the SortedSet.","(""SortedMap"", ""The SortedMap uses the natural sorting order of the elements if they implement java.lang.Comparable"", ""java.lang.Comparable""); (""SortedMap"", ""The SortedMap uses the order determined by a Comparator that you can give to it"", ""Comparator"")"
Here is an example of obtaining the Comparator used by a SortedMap via its comparator() method:,"(""SortedMap"", ""The comparator() method is used by the SortedMap class, indicating a relationship between the two."", ""comparator()"")"
All elements with a key that is smaller than / earlier than the parameter passed to the headMap() method.,"(""Headmap"", ""The Headmap method is related to the Parameter because the method takes a parameter as an input to compare with the key of elements."", ""Parameter""); (""Elements"", ""The Elements are related to the Headmap method because the method operates on elements with a key that is smaller than or earlier than the parameter passed to it."", ""Headmap"")"
Here is an example of obtaining a tail map from a SortedMap via its tailMap() method:,NULL
Here is an example of obtaining a submap from a Java SortedMap via its subMap() method:,"(""SortedMap"", ""The SortedMap class has a subMap method, indicating a relationship between the two entities."", ""subMap"")"
"For the SortedSet to be able to determine the natural order of the elements, the elements must implement the java.lang.Comparable interface.",NULL
You can get the first element of a SortedSet according to its sort order by calling the first() method of the SortedSet.,NULL
Here is an example of obtaining a head set from a Java SortedSet via its headSet() method:,"(""SortedSet"", ""The SortedSet class has a method called headSet(), indicating a relationship between the two."", ""headSet()""); (""Java"", ""The text mentions a Java SortedSet, indicating that SortedSet is a part of the Java package."", ""SortedSet"")"
The Java SortedSet interface has a method named subSet() method which will return a new SortedSet which is a subset of the SortedSet the subSet() method is called on.,"(""SortedSet"", ""The subSet() method is a part of the SortedSet interface, indicating a relationship between the two."", ""subSet()""); (""SortedSet"", ""The SortedSet interface and the SortedSet class are related as the interface defines the methods that can be used by the class."", ""SortedSet"")"
You can sort a Java List collections using the java.util.Collections.sort() method.,NULL
The compare() method compares two objects to each other and should:,NULL
"The Java Stack class, java.util.Stack, is a classical stack data structure.","(""Java Stack"", ""The Java Stack class is another name for the java.util.Stack class, indicating they are related."", ""java.util.Stack""); (""java.util.Stack"", ""The java.util.Stack class is part of the java.util package, indicating they are related."", ""java.util"")"
You push elements onto a Java Stack using its push() method.,NULL
After running this Java example the topElement variable will contain the String object 1 which was pushed onto the Stack just before peek() was called.,"(""Stack"", ""The Stack class has a method called peek, indicating a relationship between the Stack class and the peek method."", ""peek""); (""Stack"", ""The Stack class is used to push a String object, indicating a relationship between the Stack class and the String class."", ""String"")"
Here is an example of obtaining the size of a Java Stack via its size() method:,"(""Stack"", ""The size() method is a part of the Stack class, indicating a relationship between the two as the method is used to obtain the size of the Stack."", ""size()""); (""Java"", ""The Stack class is part of the Java package, indicating a relationship between the two as the Stack class is a component of the Java package."", ""Stack"")"
The parallelizable part is thus equal to 1 - 0.4 = 0.6 .,NULL
Note: The content of this text is a part result of a M.Sc.,"(""M.Sc."", ""M.Sc. is related to Note because M.Sc. is mentioned in the note."", ""Note""); (""Note"", ""Note is related to The content because The content is part of the note."", ""The content""); (""The content"", ""The content is related to part because part is a description of The content."", ""part""); (""part"", ""part is related to result because part is a result of something."", ""result""); (""result"", ""result is related to this text because this text is the result."", ""this text""); (""this text"", ""this text is related to a because a is a description of this text."", ""a""); (""a"", ""a is related to of because a is a part of something."", ""of""); (""of"", ""of is related to a because of is a description of a."", ""a""); (""a"", ""a is related to M.Sc. because a is a M.Sc."", ""M.Sc."")"
The BoundedSemaphore class shown below has two test-and-set methods: take() and release().,"(""BoundedSemaphore"", ""The BoundedSemaphore class has the take() method, indicating a relationship between the class and the method."", ""take()"")"
"As you can see, the lock() method first checks if the locked member variable is equal to false (check), and if it is it ses locked to true (then act).","(""Lock"", ""The Lock method is related to the Locked class because it checks and modifies the locked member variable."", ""Locked"")"
"The atomic lock() method is actually an example of ""compare and swap"".","(""Lock"", ""The lock method is related to the atomic attribute because it is described as an atomic lock method."", ""Atomic"")"
"Of course parallel worker code may also be spread over many different classes, but the execution sequence is often easier to read from the code.",NULL
"Threads are instances of class java.lang.Thread, or instances of subclasses of this class.","(""Java.Lang.Thread"", ""Threads are instances of class java.lang.Thread, indicating a clear inheritance relationship between the two entities."", ""Threads"")"
The run() method is what is executed by the thread after you call start().,"(""Run"", ""The run() method is executed by the thread"", ""Thread""); (""Start"", ""The start() method is called on the thread"", ""Thread"")"
"This example will print out the text ""Thread running"" once the run() method is executed by the new thread.","(""Thread"", ""The run method is executed by the Thread class, indicating a relationship between the two entities."", ""run""); (""thread"", ""The text mentions 'the new thread' which implies a relationship between the thread entity and the Thread class."", ""Thread"")"
"After printing that text, the run() method exits, and the thread running the run() method will stop.",NULL
When the thread is started it will call the run() method of the MyRunnable instance instead of executing it's own run() method.,"(""MyRunnable"", ""MyRunnable is related to run() because it is the class that contains the run() method."", ""run()"")"
Instead the run() method is executed by the thread that created the thread.,NULL
The Thread.currentThread() method returns a reference to the Thread instance executing currentThread() .,NULL
A thread can pause itself by calling the static method Thread.sleep() .,NULL
The original stop() method would not provide any guarantees about in what state the thread was stopped.,NULL
The keepRunning() method is called internally by the thread executing the MyRunnable's run() method.,"(""MyRunnable"", ""The MyRunnable class has a Run method, indicating a relationship between the class and the method."", ""Run""); (""KeepRunning"", ""The KeepRunning method is related to the MyRunnable class because it is called internally by the thread executing the MyRunnable's Run method."", ""MyRunnable"")"
Please keep in mind that if your Runnable implementation needs more than just the run() method (e.g.,NULL
"Every time a thread takes a lock it is noted in a data structure (map, graph etc.)","(""Thread"", ""A thread takes a lock, indicating that the thread and lock are related through the action of taking a lock."", ""Lock""); (""Lock"", ""The lock is noted in a data structure, indicating that the lock and data structure are related through the action of noting the lock."", ""Data Structure""); (""Thread"", ""The thread's action of taking a lock is noted in a data structure, indicating that the thread and data structure are related through this action."", ""Data Structure""); (""Map"", ""A map is an example of a data structure, indicating that the map and data structure are related through the map being a type of data structure."", ""Data Structure"")"
"Next thread 1 tries to call child.setParentOnly() method, but the child object is locked by thread 2, so the method call just blocks.","(""thread 1"", ""thread 1 tries to call a method on the child object"", ""child""); (""thread 2"", ""the child object is locked by thread 2"", ""child""); (""thread 1"", ""thread 1 is blocked by thread 2 because thread 2 has locked the child object"", ""thread 2"")"
In the following code example I have created an example of such a communication mechanism - a Java class called FrameExchanger.,NULL
"That means, that if the drawing thread is waiting in the while-loop in the takeFrame() method, the drawing thread could exit that while-loop, and take the old Frame object.","(""Drawing Thread"", ""The drawing thread is waiting in the while-loop in the takeFrame() method, indicating a relationship between the drawing thread and the takeFrame() method."", ""Takeframe""); (""Takeframe"", ""The takeFrame() method takes the old Frame object, indicating a relationship between the takeFrame() method and the Frame object."", ""Frame"")"
"Imagine if the Java VM reordered the instructions inside the storeFrame() method, like this:",NULL
"This reordering does not break the code in the takeFrame() method, as the frame variable is still written to before the hasNewFrame variable is written to.","(""Takeframe"", ""The takeFrame method is related to the frame variable because it writes to the frame variable before the hasNewFrame variable is written to."", ""Frame"")"
In the set() method the synchronized block at the end of the method will force all the variables to be synchronized to main memory after being updated.,"(""Set"", ""The set() method updates variables that are synchronized to main memory"", ""Main Memory"")"
"The original Java memory model was insufficient, so the Java memory model was revised in Java 1.5.","(""Java"", ""The Java memory model is a part of the Java class, as it is a fundamental concept in Java."", ""Java memory model""); (""Java"", ""Java 1.5 is a version of the Java package, indicating a relationship between the Java class and its package."", ""Java 1.5"")"
Each thread executing methodOne() will also create their own copy of localVariable2.,"(""Thread"", ""Each thread executing methodOne, indicating that Thread is related to Methodone through execution."", ""Methodone""); (""Methodone"", ""Methodone creates a copy of localVariable2, indicating that Methodone is related to Localvariable2 through creation or usage."", ""Localvariable2"")"
Notice the use of the synchronized keyword in the add() method declaration.,NULL
Only one thread can execute inside any of the two add() and subtract() methods at any given time.,NULL
These methods are synchronized on the class object of the class the methods belong to:,"(""Method"", ""The methods belong to the class, indicating a relationship between the method and the class it belongs to."", ""Class""); (""Method"", ""The methods are synchronized on the class object, indicating a relationship between the method and the class object."", ""Class Object"")"
"Here are the two classes used in the example above, Counter and CounterThread.",NULL
"If the two threads had referenced two separate Counter instances, there would have been no problems calling the add() methods simultaneously.",NULL
"That means, that if you are synchronizing multiple blocks on the same primitive wrapper object (e.g.","(""Primitive Wrapper"", ""The Primitive Wrapper is related to Blocks because it is used to synchronize multiple blocks."", ""Blocks""); (""Synchronizing"", ""The Synchronizing method is related to the Primitive Wrapper because it is used to synchronize on the wrapper object."", ""Primitive Wrapper"")"
Just focus on how inside the synchronized block inside the count() method calls the count() method recursively.,NULL
Once a ThreadLocal has been created you can set the value to be stored in it using its set() method.,NULL
The first way to specify an initial value for a Java ThreadLocal variable is to create a subclass of ThreadLocal which overrides its initialValue() method.,"(""ThreadLocal"", ""ThreadLocal is related to initialValue() because it overrides this method in its subclass."", ""initialValue()""); (""Java"", ""Java is related to ThreadLocal because ThreadLocal is a part of the Java package."", ""ThreadLocal"")"
Here is how providing a Supplier implementation as a lambda expression to withInitial() looks:,NULL
"Both threads execute the run() method, and thus sets different values on the ThreadLocal instance.","(""ThreadLocal"", ""The ThreadLocal instance is being accessed and modified by the run() method, indicating a relationship between the two."", ""run""); (""Thread"", ""The Thread executes the run() method, indicating a relationship between the two."", ""run"")"
"Once the update() method writes a value to days, the newly written values to years and months are also written to main memory.","(""UPDATE"", ""The update() method writes a value to days"", ""DAYS""); (""UPDATE"", ""The update() method triggers the writing of newly written values to years"", ""YEARS""); (""UPDATE"", ""The update() method triggers the writing of newly written values to months"", ""MONTHS""); (""DAYS"", ""The value written to days is also written to main memory"", ""MAIN MEMORY""); (""YEARS"", ""The newly written value to years is also written to main memory"", ""MAIN MEMORY"")"
"While isLocked is true, the thread calling lock() is parked waiting in the wait() call.","(""LOCK"", ""The lock method is related to the isLocked method because the isLocked method determines whether the lock method can proceed."", ""ISLOCKED""); (""THREAD"", ""The thread class is related to the lock method because the thread calls the lock method."", ""LOCK""); (""THREAD"", ""The thread class is related to the wait method because the thread waits in the wait call."", ""WAIT"")"
"Notice how both outer() and inner() are declared synchronized, which in Java is equivalent to a synchronized(this) block.","(""Outer"", ""Outer method is declared in Java, which is a class"", ""Java""); (""Inner"", ""Inner method is declared in Java, which is a class"", ""Java"")"
"This will fail (meaning the thread will be blocked), since the Lock instance was locked already in the outer() method.",NULL
"If either the lock is unlocked (isLocked = false) or the calling thread is the thread that locked the Lock instance, the while loop will not execute, and the thread calling lock() will be allowed to exit the method.","(""Lock"", ""The Lock class has a lock method, indicating a relationship between the two entities."", ""lock""); (""Lock"", ""The Lock class has an isLocked method, indicating a relationship between the two entities."", ""isLocked"")"
"If you click a button that starts a long task, and the thread executing the task is the thread updating the windows, buttons etc., then the application will appear unresponsive while the task executes.","(""Button"", ""The button is related to the thread because clicking the button starts a long task that is executed by the thread."", ""Thread""); (""Thread"", ""The thread is related to the task because it is the thread that executes the task."", ""Task""); (""Thread"", ""The thread is related to the application because it is the thread that updates the windows, buttons, etc. of the application."", ""Application""); (""Application"", ""The application is related to the windows because the application has windows that are updated by the thread."", ""Windows""); (""Application"", ""The application is related to the buttons because the application has buttons that are updated by the thread."", ""Buttons"")"
It will remain blocked until the thread waiting in lock() leaves the synchronized(this) block.,"(""Thread"", ""The thread is waiting in the lock, indicating a relationship between the Thread and Lock entities."", ""Lock""); (""Thread"", ""The thread is waiting in the synchronized block, indicating a relationship between the Thread and Synchronized entities."", ""Synchronized"")"
"That you would not call wait() and notify() on an internal monitor object, but rather on the This is probably true.","(""WAIT"", ""Both WAIT and NOTIFY are methods that are called on an object, indicating a relationship between them as they are used in similar contexts."")
{completion_delimiter}

The final answer is:
(""entity"",""WAIT"",""method"", ""NOTIFY"")"
"All threads calling unlock() will remain blocked indefinately, waiting for the waiting thread to release the lock on ""this"".","(""Thread"", ""A thread is related to a lock because it waits for the lock to be released."", ""Lock""); (""Unlock"", ""The unlock method is related to the lock because it is used to release the lock."", ""Lock"")"
"If two threads execute this code and both of them read the value of myVar, add one to it and write the value back to main memory, then you risk that instead of 2 being added to the myVar variable, only 1 will be added (e.g.",NULL
"*/ public void incB() { this.countB++; } /** * Many reading threads may call this method */ public long countA() { return this.countA; } /** * Many reading threads may call this method */ public long countB() { return this.countB; } } As you can see, the DoubleWriterCounter now contains two volatile variables, and two pairs of incrementation and read methods.","(""DoubleWriterCounter"", ""The DoubleWriterCounter class contains the incB method, indicating a relationship between the class and the method."", ""incB""); (""DoubleWriterCounter"", ""The DoubleWriterCounter class contains the countA method, indicating a relationship between the class and the method."", ""countA""); (""DoubleWriterCounter"", ""The DoubleWriterCounter class contains the countB method, indicating a relationship between the class and the method."", ""countB""); (""incB"", ""The incB method is related to the countB method as it increments the variable that countB reads, indicating a relationship between the two methods."", ""countB"")"
"That means, that it is possible for two different threads to call the inc() method and execute the long prevCount = this.count.get() statement, and thus both obtain the previous count for the counter.","(""Inc"", ""The Inc method is related to the Counter class because it is used to increment the counter."", ""Counter""); (""Thread"", ""The Thread class is related to the Inc method because multiple threads can call the Inc method."", ""Inc""); (""Thread"", ""The Thread class is related to the Counter class because multiple threads can access the counter."", ""Counter"")"
"public void modify() { while(!attemptModifyASR()); } public boolean attemptModifyASR(){ boolean modified = false; IntendedModification currentlyOngoingMod = ongoingMod.getReference(); int stamp = ongoingMod.getStamp(); if(currentlyOngoingMod == null){ //copy data structure state - for use //in intended modification //prepare intended modification IntendedModification newMod = new IntendedModification(); boolean modSubmitted = ongoingMod.compareAndSet(null, newMod, stamp, stamp + 1); if(modSubmitted){ //complete modification via a series of compare-and-swap operations.","(""Modify"", ""The Modify method is related to the AttemptModifyASR method because Modify calls AttemptModifyASR in its while loop."", ""AttemptModifyASR""); (""AttemptModifyASR"", ""The AttemptModifyASR method is related to the OngoingMod class because it uses the getReference and getStamp methods of OngoingMod."", ""OngoingMod""); (""AttemptModifyASR"", ""The AttemptModifyASR method is related to the IntendedModification class because it creates a new instance of IntendedModification and uses its methods."", ""IntendedModification"")"
"The check-then-act pattern means, that two or more threads check a given condition, for instance if a Map contains a given value, and then go on to act based on that information, e.g.","(""Map"", ""The Map is related to the check-then-act pattern as it is used as an example of where the pattern is applied"", ""check-then-act pattern""); (""check-then-act pattern"", ""The check-then-act pattern is related to threads as it describes a behavior that occurs when two or more threads check a condition and then act on it"", ""threads"")"
"If two or more threads call the checkThenAct() method on the same CheckThenActExample object, then two or more threads may execute the if-statement at the same time, evaluate sharedMap.containsKey(""key"") to true, and thus move into the body code block of the if-statement.","(""CheckThenActExample"", ""The checkThenAct() method is called on a CheckThenActExample object, indicating a relationship between the class and the method."", ""checkThenAct()""); (""CheckThenActExample"", ""The sharedMap is used within the CheckThenActExample class, specifically in the if-statement of the checkThenAct() method, indicating a relationship between the class and the sharedMap."", ""sharedMap"")"
Java 5 comes with read / write lock implementations in the java.util.concurrent package.,NULL
"If a thread awakened by notify() was a read access thread, it would be put back to waiting because there are threads waiting for write access.","(""Notify"", ""The notify method is related to the Thread class because it is used to awaken a thread that is waiting for a notification."", ""Thread"")"
Here is how the lockWrite() and unlockWrite() methods look after that change:,NULL
"If unlockWrite() was not called from inside a finally-clause, and an exception was thrown from the critical section, the ReadWriteLock would remain write locked forever, causing all threads calling lockRead() or lockWrite() on that ReadWriteLock instance to halt indefinately.","(""UnlockWrite"", ""UnlockWrite is a method that is related to ReadWriteLock, as it is used to unlock the write lock of the ReadWriteLock instance"", ""ReadWriteLock""); (""LockRead"", ""LockRead is a method that is related to ReadWriteLock, as it is used to lock the read lock of the ReadWriteLock instance"", ""ReadWriteLock""); (""LockWrite"", ""LockWrite is a method that is related to ReadWriteLock, as it is used to lock the write lock of the ReadWriteLock instance"", ""ReadWriteLock""); (""UnlockWrite"", ""UnlockWrite and LockRead are related, as UnlockWrite is used to unlock the write lock, which would allow LockRead to proceed"", ""LockRead"")"
The take() method sends a signal which is stored internally in the Semaphore.,NULL
The names take() and release() may seem a bit odd when using a semaphore for signaling.,"(""TAKE"", ""The take() method is related to the semaphore class because it is used for signaling when using a semaphore."", ""SEMAPHORE""); (""RELEASE"", ""The release() method is related to the semaphore class because it is used for signaling when using a semaphore."", ""SEMAPHORE"")"
In contrast to the signaling use case the methods take() and release() are now called by the same thread.,NULL
In a classic multi-threaded architecture you will typically assign each task to a separate thread for execution.,"(""TASK"", ""A task is assigned to a thread for execution, indicating a relationship between the two entities."", ""THREAD""); (""THREAD"", ""A thread is an instance of a class, indicating a relationship between the two entities."", ""CLASS""); (""TASK"", ""A task can be considered a class of work, indicating a relationship between the two entities."", ""CLASS""); (""PACKAGE"", ""A package typically contains one or more classes, indicating a relationship between the two entities."", ""CLASS""); (""PACKAGE"", ""A package can contain one or more methods, indicating a relationship between the two entities."", ""METHOD"")"
"Imagine that isLocked is false, and two threads call lock() at the same time.",NULL
Imagine what will happen if two threads call lock() at the same time when the lock is unlocked.,"(""Lock"", ""The Lock class is related to the Thread class because threads call the lock() method to acquire the lock."", ""Thread"")"
"When the thread calling lock() right after calls queueObject.wait() it will remain blocked until some other thread calls unlock(), which may never happen.","(""Thread"", ""The thread is related to the lock because it calls the lock() method, which is used for synchronization."", ""Lock""); (""Thread"", ""The thread is related to the queue object because it calls the wait() method on it, which is used for waiting for a signal."", ""QueueObject""); (""Lock"", ""The lock is related to the queue object because the lock is used to protect access to the queue object, and the wait() method is called after acquiring the lock."", ""QueueObject"")"
A simple implementation of the Lock class could look like this:,NULL
The result is that multiple threads can end up having called wait() inside lock().,"(""Thread"", ""A thread can call wait() inside a lock, indicating that threads and locks are related in the context of synchronization."", ""Lock""); (""Thread"", ""Threads can end up having called wait(), indicating that threads and the wait method are related in the context of thread execution."", ""Wait"")"
"So, the current version of the Lock class makes no different guarantees with respect to fairness than synchronized version of doSynchronized().",NULL
You will notice that the implementation has changed a bit with respect to synchronization and wait() / notify() compared to the Lock class shown earlier.,"(""Implementation"", ""The implementation is compared to the Lock class, indicating a relationship between the two."", ""Lock""); (""Lock"", ""The Lock class is related to the wait() method, as it is used in conjunction with wait() and notify()."", ""Wait""); (""Lock"", ""The Lock class is related to the notify() method, as it is used in conjunction with wait() and notify()."", ""Notify""); (""Implementation"", ""The implementation has changed with respect to synchronization, indicating a relationship between the two."", ""Synchronization""); (""Implementation"", ""The implementation has changed with respect to wait() / notify(), indicating a relationship between the implementation and the wait() method."", ""Wait"")"
The doWait() and doNotify() methods store the signal internally in the QueueObject.,"(""DOWAIT"", ""The doWait() method stores the signal internally in the QueueObject, indicating a relationship between the doWait() method and the QueueObject class."", ""QUEUEOBJECT""); (""DONOTIFY"", ""The doNotify() method stores the signal internally in the QueueObject, indicating a relationship between the doNotify() method and the QueueObject class."", ""QUEUEOBJECT"")"
If you compare the Lock and FairLock classes you will notice that there is somewhat more going on inside the lock() and unlock() in the FairLock class.,"(""Lock"", ""The Lock class contains the lock() method, indicating a relationship between the two."", ""lock()""); (""Lock"", ""The Lock class contains the unlock() method, indicating a relationship between the two."", ""unlock()""); (""FairLock"", ""The FairLock class contains the lock() method, indicating a relationship between the two."", ""lock()""); (""FairLock"", ""The FairLock class contains the unlock() method, indicating a relationship between the two."", ""unlock()"")"
You can read more about it in my text on the java.util.concurrent.ExecutorService.,NULL
Then each thread in the pool is stopped by calling doStop() on each thread.,"(""Thread"", ""A thread is part of a pool, indicating a relationship between the two entities."", ""Pool""); (""Thread"", ""The doStop method is called on each thread, indicating a relationship between the thread entity and the doStop method entity."", ""DoStop"")"
"Notice how the add() method returns a new ImmutableValue instance with the result of the add operation, rather than adding the value to itself.",NULL
"To make the Calculator class thread safe you could have declared the getValue(), setValue(), and add() methods synchronized.","(""Calculator"", ""The Calculator class contains the getValue() method, indicating a relationship between the class and the method."", ""getValue()""); (""Calculator"", ""The Calculator class contains the setValue() method, indicating a relationship between the class and the method."", ""setValue()"")"
"Therefore, when they call the add() method on the NotThreadSafe instance it leads to race condition.",NULL
"The class java.lang.Object defines three methods, wait(), notify(), and notifyAll(), to facilitate this.","(""Java.Lang.Object"", ""Java.Lang.Object defines the Wait() method to facilitate synchronization"", ""Wait()""); (""Java.Lang.Object"", ""Java.Lang.Object defines the Notify() method to facilitate synchronization"", ""Notify()"")"
"The waiting thread would call doWait(), and the notifying thread would call doNotify().",NULL
"A thread cannot call wait(), notify() or notifyAll() without holding the lock on the object the method is called on.","(""Thread"", ""A thread cannot call wait() without holding the lock on the object the method is called on, indicating a relationship between the Thread class and the Wait method."", ""Wait""); (""Thread"", ""A thread cannot call notify() without holding the lock on the object the method is called on, indicating a relationship between the Thread class and the Notify method."", ""Notify"")"
"In other words: The awakened thread must reobtain the lock on the monitor object before it can exit the wait() call, because the wait call is nested inside a synchronized block.","(""Thread"", ""The thread must reobtain the lock on the monitor object, indicating a relationship between the two."", ""Monitor""); (""Thread"", ""The thread is the one calling the wait() method, establishing a relationship between the thread and the wait method."", ""Wait""); (""Monitor"", ""The wait() call is related to the monitor object, as it is nested inside a synchronized block on the monitor object."", ""Wait""); (""Thread"", ""The thread is the one that must reobtain the lock on the monitor object before it can exit the wait() call, which is nested inside a synchronized block, indicating a relationship between the thread and the synchronized block."", ""Synchronized""); (""Monitor"", ""The monitor object is the one on which the synchronized block is applied, establishing a relationship between the monitor object and the synchronized block."", ""Synchronized"")"
"Also, notice how the doWait() method now checks the wasSignalled variable before calling wait().","(""DOWAIT"", ""The doWait() method checks the wasSignalled variable before calling wait()."", ""WASSIGNALED"")"
Notice how the wait() call is now nested inside a while loop instead of an if-statement.,"(""Wait"", ""The wait() call is now nested inside a while loop, indicating a relationship between the wait method and the while class."", ""While"")"
"The problem with calling wait() and notify() on the empty string, or any other constant string is, that the JVM/Compiler internally translates constant strings into the same object.","(""JVM"", ""JVM and Compiler are related as they are both involved in the process of translating constant strings into the same object."", ""Compiler""); (""wait"", ""wait is a method that can be called on a string object, indicating a relationship between the two."", ""string""); (""notify"", ""notify is a method that can be called on a string object, indicating a relationship between the two."", ""string""); (""JVM"", ""the JVM internally translates constant strings into the same object, indicating a relationship between the JVM and string."", ""string"")"
"The problem is, that since the doNotify() call only calls notify() and not notifyAll(), only one thread is awakened even if 4 threads are waiting on the same string instance (the empty string).","(""DoNotify"", ""DoNotify calls Notify, indicating a relationship between the two methods"", ""Notify""); (""Notify"", ""Notify is called on a string instance, indicating a relationship between the method and the class"", ""String""); (""NotifyAll"", ""NotifyAll is also related to string instances, as it is an alternative to Notify and is used in the same context"", ""String""); (""DoNotify"", ""DoNotify is related to string instances, as it calls Notify which is used on string instances"", ""String"")"
"The AtomicBoolean class provides you with a boolean variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().",NULL
You can swap the value of an AtomicBoolean using the getAndSet() method.,NULL
"Thus, the compareAndSet() method can be used to implemented simple synchronizers like locks.",NULL
You can set the value of an AtomicInteger instance via the set() method.,NULL
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicInteger.,"(""GetAndIncrement"", ""GetAndIncrement is a method that operates on the AtomicInteger class, adding 1 to its value"", ""AtomicInteger""); (""IncrementAndGet"", ""IncrementAndGet is a method that operates on the AtomicInteger class, adding 1 to its value"", ""AtomicInteger""); (""GetAndAdd"", ""GetAndAdd is a method that operates on the AtomicInteger class, adding a value to it"", ""AtomicInteger""); (""AddAndGet"", ""AddAndGet is a method that operates on the AtomicInteger class, adding a value to it"", ""AtomicInteger""); (""GetAndIncrement"", ""GetAndIncrement works similarly to GetAndAdd, but adds 1 to the value"", ""GetAndAdd"")"
Here is an example showing how calling the get() method looks:,NULL
Only one thread at a time can execute the compareAndSet() method.,NULL
The incrementAndGet() method increments (adds 1) to the value of a given element and returns the new value of that element.,NULL
You should check out the JavaDoc for the AtomicIntegerArray class to learn more about those methods.,NULL
You can set the value of an AtomicLong instance via the set() method.,NULL
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicLong.,"(""GetAndIncrement"", ""GetAndIncrement method is related to AtomicLong class because it operates on the value of AtomicLong"", ""AtomicLong""); (""IncrementAndGet"", ""IncrementAndGet method is related to AtomicLong class because it operates on the value of AtomicLong"", ""AtomicLong""); (""GetAndAdd"", ""GetAndAdd method is related to AtomicLong class because it operates on the value of AtomicLong"", ""AtomicLong""); (""AddAndGet"", ""AddAndGet method is related to AtomicLong class because it operates on the value of AtomicLong"", ""AtomicLong""); (""GetAndIncrement"", ""GetAndIncrement and GetAndAdd methods are related because they have similar functionality, with GetAndIncrement adding 1 to the value"", ""GetAndAdd"")"
Calling addAndGet() is also an atomic operation (like all operations on the AtomicLongArray).,NULL
"AtomicReference even has an advanced compareAndSet() method which lets you compare the reference to an expected value (reference) and if they are equal, set a new reference inside the AtomicReference object.",NULL
Notice how it is necessary to cast the reference returned by get() to a String because get() returns an Object reference when the AtomicReference is untyped.,"(""AtomicReference"", ""The get method is related to the AtomicReference class because it is used to retrieve a value from the AtomicReference."", ""get""); (""get"", ""The get method is related to the Object class because it returns an Object reference."", ""Object"")"
There is no difference to see in the use of the set() method for an untyped or typed reference.,NULL
"The second time the stored reference is the new reference just set in the call to compareAndSet() before, so the stored reference is of course not equal to the initial reference.","(""CompareAndSet"", ""The method compareAndSet() is related to the Stored Reference because it sets the new reference that is compared to the stored reference."", ""Stored Reference""); (""CompareAndSet"", ""The method compareAndSet() is related to the Initial Reference because it is used to compare the stored reference to the initial reference."", ""Initial Reference"")"
"The final compareAndSet() call will succeed, because the expected reference is newRef and the expected stamp is newStamp.","(""CompareAndSet"", ""The CompareAndSet method uses NewRef as the expected reference."", ""NewRef"")"
Thread 1 can copy the reference and stamp out of the AtomicStampedReference atomically using get().,"(""Thread"", ""Thread can use AtomicStampedReference to copy the reference and stamp out atomically"", ""AtomicStampedReference""); (""Thread"", ""Thread can use get() to copy the reference and stamp out of the AtomicStampedReference atomically"", ""get"")"
"If another thread changes the reference from A to B and then back to A, then the stamp will have changed (provided threads update the stamp sensibly - e.g increment it).","(""Thread"", ""A thread can change the reference, indicating a relationship between the two entities."", ""Reference""); (""Thread"", ""A thread can update the stamp, indicating a relationship between the two entities."", ""Stamp"")"
"The BlockingDeque interface in the java.util.concurrent class represents a deque which is thread safe to put into, and take instances from.",NULL
"The BlockingDeque class is a Deque which blocks threads tring to insert or remove elements from the deque, in case it is either not possible to insert or remove elements from the deque.",NULL
The java.util.concurrent package has the following implementations of the BlockingDeque interface:,NULL
The java.util.concurrent.ConcurrentMap interface represents a Map which is capable of handling concurrent access (puts and gets) to it.,"(""ConcurrentMap"", ""ConcurrentMap is part of the java.util.concurrent package"", ""java.util.concurrent"")"
"The ConcurrentMap has a few extra atomic methods in addition to the methods it inherits from its superinterface, java.util.Map.","(""ConcurrentMap"", ""ConcurrentMap inherits methods from java.util.Map, indicating a subclass relationship"", ""java.util.Map""); (""ConcurrentMap"", ""ConcurrentMap has atomic methods, indicating a composition relationship where ConcurrentMap contains or provides atomic methods"", ""atomic methods"")"
The java.util.concurrent package contains the following implementations of the ConcurrentMap interface:,NULL
"The ConcurrentHashMap is very similar to the java.util.HashTable class, except that ConcurrentHashMap offers better concurrency than HashTable does.","(""ConcurrentHashMap"", ""ConcurrentHashMap is similar to HashTable, indicating a relationship between the two classes"", ""HashTable""); (""HashTable"", ""HashTable is part of the java.util package, indicating a relationship between the class and the package"", ""java.util"")"
"The java.util.concurrent.ConcurrentNavigableMap class is a java.util.NavigableMap with support for concurrent access, and which has concurrent access enabled for its submaps.","(""ConcurrentNavigableMap"", ""ConcurrentNavigableMap is a type of NavigableMap, indicating an inheritance relationship between the two classes"", ""NavigableMap""); (""ConcurrentNavigableMap"", ""ConcurrentNavigableMap is part of the java.util.concurrent package, indicating a containment relationship between the package and the class"", ""java.util.concurrent"")"
"The ""submaps"" are the maps returned by various methods like headMap(), subMap() and tailMap().","(""Submaps"", ""Submaps are returned by the Headmap method"", ""Headmap""); (""Submaps"", ""Submaps are returned by the Submap method"", ""Submap"")"
Here is an example illustrating the use of the headMap() method.,NULL
Here is an example illustrating the use of the tailMap() method:,NULL
"The subMap() method returns a view of the original map which contains all keys from (including), to (excluding) two keys given as parameters to the method.",NULL
A java.util.concurrent.CountDownLatch is a concurrency construct that allows one or more threads to wait for a given set of operations to complete.,NULL
Threads waiting for this count to reach zero can call one of the await() methods.,"(""Threads"", ""Threads can call the await() method, indicating a relationship between the two entities."", ""await()""); (""count"", ""Threads are waiting for the count to reach zero, indicating a relationship between the two entities."", ""Threads"")"
"After the Decrementer has called countDown() 3 times on the CountDownLatch, the waiting Waiter is released from the await() call.","(""Decrementer"", ""The Decrementer calls the countDown() method on the CountDownLatch, indicating a relationship between the Decrementer class and the CountDownLatch class."", ""CountDownLatch""); (""CountDownLatch"", ""The CountDownLatch has a method called countDown(), indicating a relationship between the CountDownLatch class and its method countDown()."", ""countDown()""); (""Waiter"", ""The Waiter is released from the await() call, indicating a relationship between the Waiter class and its method await()."", ""await()"")"
The java.util.concurrent.CyclicBarrier class is a synchronization mechanism that can synchronize threads progressing through some algorithm.,NULL
The threads wait for each other by calling the await() method on the CyclicBarrier.,"(""threads"", ""The threads wait for each other by calling the await() method on the CyclicBarrier, indicating that threads are related to CyclicBarrier through the await() method."", ""CyclicBarrier""); (""await()"", ""The await() method is called on the CyclicBarrier, indicating that await() is a method of CyclicBarrier."", ""CyclicBarrier"")"
The value returned by the getDelay() method should be the delay remaining before this element can be released.,NULL
"If 0 or a negative value is returned, the delay will be considered expired, and the element released at the next take() etc.",NULL
The TimeUnit instance passed to the getDelay() method is an Enum that tells which time unit the delay should be returned in.,"(""TimeUnit"", ""The TimeUnit instance is passed to the getDelay() method, indicating a relationship between the two."", ""getDelay()""); (""getDelay()"", ""The getDelay() method returns a delay in a time unit specified by an Enum, indicating a relationship between the method and the Enum."", ""Enum"")"
"The Delayed interface also extends the java.lang.Comparable interface, as you can see, which means that Delayed objects can be compared to each other.",NULL
You will have to create your own implementation of the Delayed interface to use the DelayQueue class.,NULL
The java.util.concurrent.Exchanger class represents a kind of rendezvous point where two threads can exchange objects.,NULL
Exchanging objects is done via one of the two exchange() methods.,"(""Exchanging"", ""Exchanging is related to Exchange because Exchanging is done via one of the two exchange() methods."", ""Exchange"")"
"The Java BlockingQueue interface, java.util.concurrent.BlockingQueue, represents a queue which is thread safe to put elements into, and take elements out of from.","(""Java"", ""Java has a BlockingQueue interface which represents a queue that is thread safe to put elements into and take elements out of"", ""BlockingQueue""); (""java.util.concurrent.BlockingQueue"", ""java.util.concurrent.BlockingQueue is a part of the java.util.concurrent package"", ""java.util.concurrent""); (""BlockingQueue"", ""The BlockingQueue interface is implemented by java.util.concurrent.BlockingQueue"", ""java.util.concurrent.BlockingQueue"")"
The java.util.concurrent package has the following implementations of the BlockingQueue interface:,NULL
"First, the BlockingQueueExample class which starts a Producer and a Consumer in separate threads.","(""BlockingQueueExample"", ""The BlockingQueueExample class starts a Producer in a separate thread, indicating a relationship between the two."", ""Producer""); (""BlockingQueueExample"", ""The BlockingQueueExample class starts a Consumer in a separate thread, indicating a relationship between the two."", ""Consumer"")"
"It just takes out the objects from the queue, and prints them to System.out.",NULL
The Java BlockingQueue add() method will add the element passed as parameter to this method if the BlockingQueue has space for it internally.,"(""BlockingQueue"", ""The BlockingQueue class has an add() method, indicating a relationship between the two entities as the method is a part of the class."", ""add()""); (""Java"", ""The Java package contains the BlockingQueue class, indicating a relationship between the two entities as the class is part of the package."", ""BlockingQueue"")"
"If the BlockingQueue does not have space internally for this new element, the add() method throws an IllegalStateException.","(""BlockingQueue"", ""The BlockingQueue class contains the add() method, which suggests a relationship between the two entities as the method is a part of the class's functionality."", ""add()""); (""add()"", ""The add() method is related to the IllegalStateException because the method throws this exception when the BlockingQueue does not have space internally for a new element, indicating a cause-and-effect relationship between the method's execution and the exception being thrown."", ""IllegalStateException"")"
The BlockingQueue offer() method will add the element passed as parameter to this method if the BlockingQueue has space for it internally.,NULL
"If the BlockingQueue does not have space internally for this new element, the offer() method return false.",NULL
The BlockingQueue offer() method exists in a version which takes a time out as parameter.,NULL
"This version of the offer() method will add the element passed as parameter if the BlockingQueue has space for it internally, or space becomes available.","(""Offer"", ""The offer method is used in conjunction with the BlockingQueue class, indicating a relationship between the two entities."", ""Blockingqueue"")"
"If the BlockingQueue does not have or get space internally for this new element within the time out, this version of the offer() method returns false.",NULL
The BlockingQueue put() method inserts the element into the BlockingQueue if it has space for it internally.,NULL
"If the BlockingQueue does not have space for the new element, the put() method will block the thread calling the put() method until the BlockingQueue as space internally for the new element.","(""BlockingQueue"", ""The put() method is related to the BlockingQueue because it is a method that can be called on a BlockingQueue object, and its behavior is dependent on the state of the BlockingQueue."", ""put()"")"
The Java BlockingQueue take() method will remove the first element in the BlockingQueue.,"(""BlockingQueue"", ""The take() method is a part of the BlockingQueue class, indicating a relationship between the two entities."", ""take()""); (""Java"", ""The BlockingQueue class is part of the Java package, indicating a relationship between the two entities."", ""BlockingQueue"")"
"If the BlockingQueue does not contain any elements, the take() method will block the thread calling take() until an element is inserted into the BlockingQueue.",NULL
The BlockingQueue poll() method will remove the first element in the BlockingQueue.,NULL
"If the BlockingQueue does not contain any elements, the poll() method will return null.",NULL
"If the BlockingQueue does not contain any elements, this version of the poll() method will wait for an element to become available for the given amount of time passed to it as parameter.",NULL
The remove() method will use the o.equals(element) to decide if the object o passed as parameter matches a given element in the BlockingQueue.,"(""Remove"", ""The remove() method will use the o.equals(element) to decide if the object o passed as parameter matches a given element, indicating a relationship between the remove() method and the equals() method."", ""Equals""); (""Remove"", ""The remove() method is used in the context of the BlockingQueue, indicating a relationship between the remove() method and the BlockingQueue class."", ""Blockingqueue""); (""Equals"", ""The equals() method is called on the object o, indicating a relationship between the equals() method and the object o."", ""O"")"
"The remove() method will return true if an element was removed, and false if not.",NULL
The BlockingQueue peek() method will return the first element of the BlockingQueue without removing it.,NULL
"If the BlockingQueue does not contain any elements, the peek() method will return null.",NULL
The BlockingQueue element() method will return the first element of the BlockingQueue without removing it.,NULL
"If the BlockingQueue does not contain any elements, the element() method will throw a NoSuchElementException.","(""BlockingQueue"", ""The BlockingQueue class contains the element method, indicating a relationship between the two entities."", ""element""); (""element"", ""The element method is related to the NoSuchElementException because it throws this exception when the BlockingQueue is empty, indicating a causal relationship between the method and the exception."", ""NoSuchElementException"")"
The BlockingQueue contains(Object o) method will return true if the BlockingQueue contains an object matching the object passed as parameter to the contains() method.,"(""BlockingQueue"", ""The BlockingQueue class has a contains method, indicating a relationship between the class and the method."", ""contains""); (""contains"", ""The contains method is related to the contains() method, as they are referring to the same method with the same functionality, but contains() is a more specific reference to the method."", ""contains()"")"
"The Objects.equals(o, element) statement is used to check if the parameter object o matches a given element in the BlockingQueue.","(""Objects"", ""The Objects class contains the equals method, which is used for comparison."", ""equals""); (""equals"", ""The equals method is used in the context of the BlockingQueue class to compare objects."", ""BlockingQueue"")"
The BlockingQueue size() method returns the number of elements stored in BlockingQueue.,NULL
The BlockingQueue remainingCapacity() method returns the remaining (unused) capacity of the BlockingQueue.,NULL
"The Java Callable interface, java.util.concurrent.Callable, represents an asynchronous task which can be executed by a separate thread.","(""Java Callable"", ""The Java Callable interface is represented by the java.util.concurrent.Callable class"", ""java.util.concurrent.Callable""); (""java.util.concurrent.Callable"", ""java.util.concurrent.Callable is part of the java.util.concurrent package"", ""java.util.concurrent"")"
The call() method is called in order to execute the asynchronous task.,NULL
The call() method can also thrown an Exception in case the task fails during execution.,"(""Call"", ""The Call method can throw an Exception when the task fails during execution, indicating a relationship between the method and the exception."", ""Exception"")"
The result of that is that the call() method will return a String.,NULL
The call() implementation just returns a String representation of the current time in milliseconds.,"(""Call"", ""The Call method returns a String representation of the current time in milliseconds, indicating a relationship between the Call method and the String class."", ""String"")"
"A Java Callable is different from a Runnable in that the Runnable interface's run() method does not return a value, and it cannot throw checked exceptions (only RuntimeExceptions).","(""Runnable"", ""The Runnable interface has a run() method, indicating a clear relationship between the two entities."", ""run()"")"
"Additionally, a Runnable was originally designed for long running concurrent execution, e.g.",NULL
"Java 5 added a new Java package to the Java platform, the java.util.concurrent package.","(""Java 5"", ""Java 5 added the java.util.concurrent package to the Java platform"", ""java.util.concurrent"")"
This package contains a set of classes that makes it easier to develop concurrent (multithreaded) applications in Java.,"(""Package"", ""The package contains a set of classes"", ""Classes""); (""Package"", ""The package is used to develop applications in Java"", ""Java"")"
"Before this package was added, you would have to program your utility classes yourself.",NULL
"In this tutorial I will take you through the new java.util.concurrent classes, one by one, so you can learn how to use them.","(""Java"", ""Java is related to Util because Util is a package in Java"", ""Util""); (""Util"", ""Util is related to Concurrent because Concurrent is a sub-package of Util"", ""Concurrent"")"
Here is a list of the topics covered in this java.util.concurrent trail.,"(""Java"", ""Java is related to Util as it is part of the java.util package"", ""Util""); (""Util"", ""Util is related to Concurrent as it is the parent package of java.util.concurrent"", ""Concurrent"")"
"If you disagree with anything I write here about the java.util.concurrent utilities, or just have comments, questions, etc, feel free to send me an email.","(""Java"", ""Java is related to Util because Util is a package in Java"", ""Util""); (""Util"", ""Util is related to Concurrent because Concurrent is a sub-package of Util"", ""Concurrent"")"
"The Java ExecutorService interface, java.util.concurrent.ExecutorService, represents an asynchronous execution mechanism which is capable of executing tasks concurrently in the background.",NULL
First an ExecutorService is created using the Executors newFixedThreadPool() factory method.,"(""ExecutorService"", ""ExecutorService is created using the Executors"", ""Executors""); (""Executors"", ""newFixedThreadPool() is a factory method of the Executors class"", ""newFixedThreadPool()"")"
"Second, an anonymous implementation of the Runnable interface is passed to the execute() method.",NULL
"In fact, the implementation of the ExecutorService interface present in the java.util.concurrent package is a thread pool implementation.",NULL
"However, you can use the Executors factory class to create ExecutorService instances too.",NULL
"The Java ExecutorService execute(Runnable) method takes a java.lang.Runnable object, and executes it asynchronously.","(""ExecutorService"", ""The ExecutorService class contains the execute method."", ""execute""); (""execute"", ""The execute method takes a Runnable object as a parameter."", ""Runnable""); (""ExecutorService"", ""The ExecutorService class uses a Runnable object in its execute method."", ""Runnable""); (""java.lang"", ""The Runnable class is part of the java.lang package."", ""Runnable"")"
The submit() method returns a Java Future object which can be used to check when the Runnable has completed.,"(""Submit"", ""The submit() method returns a Java Future object, indicating a clear relationship between the two entities as the method returns an object of the Java Future class"", ""Java Future"")"
"The invokeAny() method takes a collection of Callable objects, or subinterfaces of Callable.",NULL
"If one Callable finishes, so that a result is returned from invokeAny(), then the rest of the Callable instances are cancelled.",NULL
The invokeAll() method invokes all of the Callable objects you pass to it in the collection passed as parameter.,NULL
The invokeAll() returns a list of Future objects via which you can obtain the results of the executions of each Callable.,"(""InvokeAll"", ""InvokeAll method returns a list of Future objects"", ""Future""); (""InvokeAll"", ""InvokeAll method is used to execute Callable objects"", ""Callable"")"
The main difference between the Runnable run() method and the Callable call() method is that the call() method can return an Object from the method call.,"(""Runnable"", ""The Runnable class has a run() method"", ""run()""); (""Callable"", ""The Callable class has a call() method"", ""call()"")"
"Another difference between call() and run() is that call() can throw an exception, whereas run() cannot (except for unchecked exceptions - subclasses of RuntimeException).","(""Call"", ""Call can throw an exception that is a subclass of RuntimeException"", ""RuntimeException""); (""Run"", ""Run cannot throw a checked exception, but can throw an unchecked exception that is a subclass of RuntimeException"", ""RuntimeException"")"
You can cancel a task (Runnable or Callable) submitted to a Java ExecutorService by calling the cancel() method on the Future returned when the task is submitted.,"(""Runnable"", ""A Runnable task can be submitted to an ExecutorService."", ""ExecutorService""); (""Callable"", ""A Callable task can be submitted to an ExecutorService."", ""ExecutorService""); (""Future"", ""The Future returned when a task is submitted to an ExecutorService."", ""ExecutorService""); (""cancel"", ""The cancel() method is called on the Future returned when a task is submitted."", ""Future""); (""Runnable"", ""A Runnable task is associated with a Future when it is submitted."", ""Future"")"
Here is an example of cancelling a task by calling the Future.cancel() method:,NULL
"If your application is started via a main() method and your main thread exits your application, the application will keep running if you have an active ExexutorService in your application.","(""Application"", ""The application is started via the main method, indicating a relationship between the application and the main method."", ""Main""); (""Application"", ""The application will keep running if it has an active ExecutorService, indicating a relationship between the application and the ExecutorService."", ""ExecutorService""); (""Main"", ""The main method is used to start the application, indicating a relationship between the main method and the application."", ""Application"")"
To terminate the threads inside the ExecutorService you call its shutdown() method.,NULL
"All tasks submitted to the ExecutorService before shutdown() is called, are executed.",NULL
"If you want to shut down the ExecutorService immediately, you can call the shutdownNow() method.",NULL
"The ExecutorService awaitTermination() method will block the thread calling it until either the ExecutorService has shutdown completely, or until a given time out occurs.",NULL
The awaitTermination() method is typically called after calling shutdown() or shutdownNow().,"(""AwaitTermination"", ""The awaitTermination() method is typically called after calling shutdown() or shutdownNow(), indicating a sequence of operations where shutdown() precedes awaitTermination()."", ""Shutdown"")"
"The ForkJoinPool located in the java.util.concurrent package, so the full class name is java.util.concurrent.ForkJoinPool.","(""ForkJoinPool"", ""ForkJoinPool is located in the java.util.concurrent package, indicating a containment relationship"", ""java.util.concurrent""); (""java.util.concurrent.ForkJoinPool"", ""java.util.concurrent.ForkJoinPool is located in the java.util.concurrent package, indicating a containment relationship"", ""java.util.concurrent"")"
These two types of tasks are represented by the RecursiveAction and RecursiveTask classes.,NULL
"If the workLoad is above a certain threshold, the work is split into subtasks which are also scheduled for execution (via the .fork() method of the subtasks.","(""Workload"", ""The workload is split into subtasks, indicating a relationship between the two entities where subtasks are derived from the workload."", ""Subtasks"")"
The class MyRecursiveTask extends RecursiveTask<Long> which means that the result returned from the task is a Long .,"(""MyRecursiveTask"", ""MyRecursiveTask extends RecursiveTask, indicating an inheritance relationship between the two classes"", ""RecursiveTask""); (""MyRecursiveTask"", ""The result returned from MyRecursiveTask is a Long, indicating that MyRecursiveTask is related to Long as its return type"", ""Long"")"
"The MyRecursiveTask example also breaks the work down into subtasks, and schedules these subtasks for execution using their fork() method.",NULL
"Additionally, this example then receives the result returned by each subtask by calling the join() method of each subtask.",NULL
Notice how you get the final result out from the ForkJoinPool.invoke() method call.,NULL
"A Java Future, java.util.concurrent.Future, represents the result of an asynchronous computation.",NULL
"To obtain the result, you call one of the two get() methods on the Future.",NULL
"The get() methods both return an Object, but the return type can also be a generic return type (meaning an object of a specific class, and not just an Object).",NULL
Here is an example of obtaining the result from a Java Future via its get() method:,NULL
"If you call the get() method before the asynchronous task has completed, the get() method will block until the result is ready.","(""Get()"", ""The get() method is related to itself because it is mentioned as being called before the asynchronous task has completed, and it will block until the result is ready, implying that the same get() method is being referred to in both instances."", ""Get()"")"
There is a version of the get() method which can time out after an amount of time has passed which you can specify via method parameters.,NULL
You can cancel the asynchronous task represented by a Java Future instance by calling the Future cancel() method.,"(""Future"", ""The Future class has a cancel method, indicating a relationship between the two entities."", ""cancel""); (""Future"", ""The Future class is part of the Java package, indicating a relationship between the two entities."", ""Java"")"
Here is an example of canceling a task via the Java Future cancel() method:,"(""Java"", ""The Java package contains the Future class"", ""Future""); (""Future"", ""The Future class has a cancel() method"", ""cancel()"")"
You can check if the asynchronous task is done (and a result available) by calling the Future isDone() method.,NULL
Here is an example of calling the Java Future isDone() method:,"(""Future"", ""The Future class has an isDone() method, indicating a relationship between the two entities as the method isDone() is part of the Future class."", ""isDone()""); (""Java"", ""The Java package contains the Future class, indicating a relationship between the two entities as the Future class is part of the Java package."", ""Future"")"
"The Java Lock interface, java.util.concurrent.locks.Lock, represents a concurrent lock which can be used to guard against race conditions inside critical sections.","(""Java Lock"", ""The Java Lock interface is represented by the java.util.concurrent.locks.Lock class, indicating a clear relationship between the two entities as one is an implementation of the other."", ""java.util.concurrent.locks.Lock""); (""java.util.concurrent.locks.Lock"", ""The java.util.concurrent.locks.Lock class is part of the java.util.concurrent.locks package, indicating a clear relationship between the two entities as one is contained within the other."", ""java.util.concurrent.locks"")"
You must create an instance of a class that implements the Lock interface.,NULL
The java.util.concurrent.locks package has the following implementations of the Lock interface:,NULL
In the following sections I will explain how to use the ReentrantLock class as a Lock.,NULL
"To create an instance of the ReentrantLock class you simply use the new operator, like this:",NULL
To lock the Lock instance you must call its lock() method.,NULL
To unlock the Lock instance you must call its unlock() method.,NULL
Any other thread calling lock() will be blocked until the thread that locked the lock calls unlock().,"(""Lock"", ""The Lock class has a method called lock(), which is used to acquire the lock."", ""lock()""); (""Lock"", ""The Lock class has a method called unlock(), which is used to release the lock."", ""unlock()"")"
"Finally unlock() is called, and the Lock is now unlocked so other threads can lock it.",NULL
"If you look at the example in the previous section, imagine what happens if an exception is thrown between the call to lock.lock() and lock.unlock() .","(""Lock"", ""The source entity Lock and the target entity Lock.Lock are related to each other because Lock.Lock is a method of the Lock class."", ""Lock.Lock""); (""Lock"", ""The source entity Lock and the target entity Lock.Unlock are related to each other because Lock.Unlock is a method of the Lock class."", ""Lock.Unlock"")"
"The exception would interrupt the program flow, and the call to lock.unlock() would never be executed.","(""Exception"", ""The exception would interrupt the program flow, which is related to the lock."", ""Lock""); (""Lock"", ""The lock has an unlock method, indicating a relationship between the two."", ""Unlock"")"
"To better understand how using a Lock looks different from using a synchronized block, I have created two simple concurrent Counter classes which protects their internal count in different ways.","(""Lock"", ""The Lock class is related to the Counter class because the Counter class uses a Lock to protect its internal count."", ""Counter"")"
"The first class uses a synchronized block, and the second class uses a Java Lock:","(""Class"", ""The first class uses a synchronized block, indicating a relationship between the Class entity and the Synchronized Block method"", ""Synchronized Block"")"
Notice that the CounterLock class is longer than the CounterSynchronized class.,NULL
"Notice how the calculate() method both locks the Calculator instance's Lock before performing any calculations, and also call the add() and subtract() methods which also locks the lock.","(""Calculator"", ""The Calculator instance has a Lock, indicating a composition relationship between the two classes."", ""Lock""); (""calculate()"", ""The calculate() method locks the Lock, indicating that the method uses or interacts with the Lock."", ""Lock""); (""calculate()"", ""The calculate() method calls the add() method, indicating a method invocation relationship between the two methods."", ""add()""); (""calculate()"", ""The calculate() method calls the subtract() method, indicating a method invocation relationship between the two methods."", ""subtract()""); (""add()"", ""The add() method locks the Lock, indicating that the method uses or interacts with the Lock."", ""Lock"")"
The ReentrantLock class has a constructor that takes a boolean parameter specifying whether the ReentrantLock should provide fairness or not to waiting threads.,"(""ReentrantLock"", ""The ReentrantLock class has a constructor, indicating that the constructor is a method of the ReentrantLock class."", ""constructor""); (""constructor"", ""The constructor takes a boolean parameter, indicating that the boolean type is related to the constructor method."", ""boolean"")"
"Please note, that the method tryLock() (covered later in this Java Lock tutorial) with no parameters does not respect the fairness mode of the ReentrantLock.",NULL
"If the Lock instance is already locked, the thread calling lock() is blocked until the Lock is unlocked.","(""Lock"", ""The Lock class has a method called lock(), indicating a relationship between the Lock class and the lock() method."", ""lock()""); (""thread"", ""The thread is blocked until the Lock is unlocked, indicating a relationship between the thread and the Lock class."", ""Lock"")"
The lockInterruptibly() method locks the Lock unless the thread calling the method has been interrupted.,"(""Lock"", ""The lockInterruptibly() method is related to the Lock class because it is described as a method that locks the Lock."", ""lockInterruptibly()"")"
"The tryLock(long timeout, TimeUnit timeUnit) works like the tryLock() method, except it waits up the given timeout before giving up trying to lock the Lock.","(""Trylock"", ""The tryLock method is related to the Lock class because it is used to lock the Lock."", ""Lock""); (""Trylock(long Timeout, TimeUnit Timeunit)"", ""The tryLock(long timeout, TimeUnit timeUnit) method is related to the Lock class because it is used to lock the Lock with a given timeout."", ""Lock"")"
The Java ReentrantLock getHoldCount() method returns the number of times a given thread has locked this Lock instance.,"(""ReentrantLock"", ""The getHoldCount() method is a part of the ReentrantLock class, indicating a relationship between the two."", ""getHoldCount()""); (""ReentrantLock"", ""ReentrantLock is a type of Lock, indicating an inheritance relationship between the two."", ""Lock""); (""ReentrantLock"", ""The ReentrantLock class is part of the Java package, indicating a containment relationship between the two."", ""Java""); (""getHoldCount()"", ""The getHoldCount() method is part of the Java package, indicating a containment relationship between the two."", ""Java"")"
The ReentrantLock getQueueLength() method returns the number of threads waiting to lock the Lock.,"(""ReentrantLock"", ""The getQueueLength() method is a part of the ReentrantLock class, indicating a relationship between the two."", ""getQueueLength()""); (""ReentrantLock"", ""The ReentrantLock is a type of Lock, indicating a relationship between the two, with ReentrantLock being a specific implementation of the Lock class."", ""Lock"")"
"The ReentrantLock hasQueuedThreads() method returns true if any threads are queued up waiting to lock this Lock, and false if not.","(""ReentrantLock"", ""The ReentrantLock class has a method called hasQueuedThreads(), indicating a relationship between the class and the method."", ""hasQueuedThreads()""); (""ReentrantLock"", ""The ReentrantLock class is a type of Lock, indicating a relationship between the two classes."", ""Lock"")"
"The ReentrantLock isFair() method returns true if this Lock guarantees fairness among threads waiting to lock it, and false if not.","(""ReentrantLock"", ""The ReentrantLock class has an isFair() method, indicating a relationship between the class and the method."", ""isFair()""); (""ReentrantLock"", ""The ReentrantLock class is a type of Lock, indicating a relationship between the two classes."", ""Lock"")"
"The ReentrantLock isHeldByCurrentThread() method returns true if the Lock is held (locked) by the thread calling isHeldByCurrentThread(), and false if not.",NULL
"The ReentrantLock isLocked() method returns true if the Lock is currently locked, and false if not.","(""ReentrantLock"", ""The ReentrantLock class has an isLocked() method, indicating a relationship between the class and the method."", ""isLocked()""); (""Lock"", ""The Lock class is related to the isLocked() method, as the method is used to check the lock status of the Lock."", ""isLocked()"")"
"If no upper bound is specified, Integer.MAX_VALUE is used as the upper bound.",NULL
All elements inserted into the PriorityBlockingQueue must implement the java.lang.Comparable interface.,NULL
Notice that the PriorityBlockingQueue does not enforce any specific behaviour for elements that have equal priority (compare() == 0).,NULL
"The java.util.concurrent.ScheduledExecutorService is an ExecutorService which can schedule tasks to run after a delay, or to execute repeatedly with a fixed interval of time in between each execution.","(""ScheduledExecutorService"", ""ScheduledExecutorService is a subclass of ExecutorService, as indicated by the 'is an' phrase in the text, showing an inheritance relationship between the two classes"", ""ExecutorService""); (""ScheduledExecutorService"", ""ScheduledExecutorService is part of the java.util.concurrent package, as indicated by the package name prefix in the text, showing a containment relationship between the package and the class"", ""java.util.concurrent"")"
Then an anonymous implementation of the Callable interface is created and passed to the schedule() method.,NULL
"Since ScheduledExecutorService is an interface, you will have to use its implementation in the java.util.concurrent package, in order to use it.",NULL
"However, you can use the Executors factory class to create ScheduledExecutorService instances too.",NULL
"This method works like the method version taking a Callable as parameter, except a Runnable cannot return a value, so the ScheduledFuture.get() method returns null when the task is finished.","(""ScheduledFuture"", ""The get method is a part of the ScheduledFuture class, indicating a relationship between the two entities."", ""get""); (""Runnable"", ""The Runnable entity is related to the ScheduledFuture entity because a Runnable is used as a parameter in a method that returns a ScheduledFuture."", ""ScheduledFuture"")"
This method works very much like scheduleAtFixedRate() except that the period is interpreted differently.,NULL
"In the scheduleAtFixedRate() method the period is interpreted as a delay between the start of the previous execution, until the start of the next execution.",NULL
You shut down a ScheduledExecutorService using the shutdown() or shutdownNow() methods which are inherited from the ExecutorService interface.,"(""ScheduledExecutorService"", ""ScheduledExecutorService uses the shutdown method to shut down the service"", ""shutdown""); (""ScheduledExecutorService"", ""ScheduledExecutorService uses the shutdownNow method to shut down the service immediately"", ""shutdownNow"")"
For each call to acquire() a permit is taken by the calling thread.,"(""Acquire"", ""The Acquire method takes a permit, indicating a relationship between the two."", ""Permit""); (""Acquire"", ""The Acquire method is called by a thread, indicating a relationship between the two."", ""Thread"")"
For each call to release() a permit is returned to the semaphore.,"(""Release"", ""The Release method is related to the Semaphore class because it is called on the semaphore to return a permit."", ""Semaphore""); (""Semaphore"", ""The Semaphore class is related to the Permit class because a permit is returned to the semaphore when the release method is called."", ""Permit"")"
"Thus, at most N threads can pass the acquire() method without any release() calls, where N is the number of permits the semaphore was initialized with.","(""Acquire"", ""The acquire method is related to the Semaphore class because it is used to acquire a permit from the semaphore."", ""Semaphore""); (""Release"", ""The release method is related to the Semaphore class because it is used to release a permit back to the semaphore."", ""Semaphore"")"
"If you use a semaphore to send signals between threads, then you would typically have one thread call the acquire() method, and the other thread to call the release() method.","(""Semaphore"", ""The Semaphore class has an Acquire method, which is used to send signals between threads."", ""Acquire""); (""Semaphore"", ""The Semaphore class has a Release method, which is used to send signals between threads."", ""Release"")"
"If no permits are available, the acquire() call will block until a permit is released by another thread.","(""Acquire"", ""The acquire() method is related to Permit because it is used to acquire a permit."", ""Permit""); (""Thread"", ""A thread is related to a permit because a thread can release a permit."", ""Permit"")"
"Similarly, a release() calls is blocked if no more permits can be released into this semaphore.",NULL
"For instance, if acquire was called after Thread 1 had inserted an object in a shared list, and Thread 2 had called release() just before taking an object from that list, you had essentially created a blocking queue.","(""Acquire"", ""Acquire is called by Thread 1, indicating a relationship between the method and the thread"", ""Thread 1""); (""Thread 1"", ""Thread 1 inserts an object in the shared list, indicating a relationship between the thread and the shared list"", ""Shared List""); (""Release"", ""Release is called by Thread 2, indicating a relationship between the method and the thread"", ""Thread 2""); (""Thread 2"", ""Thread 2 takes an object from the shared list, indicating a relationship between the thread and the shared list"", ""Shared List"")"
"That is, there is no guarantee that the first thread to call acquire() is also the first thread to obtain a permit.","(""Acquire"", ""The acquire method is called by a thread to obtain a permit, indicating a relationship between the acquire method and the thread."", ""Thread""); (""Thread"", ""A thread obtains a permit, indicating a relationship between the thread and the permit."", ""Permit"")"
"If you want to enforce fairness, the Semaphore class has a constructor that takes a boolean telling if the semaphore should enforce fairness.",NULL
Calling this class a queue is a bit of an overstatement.,NULL
"However, unless you need to specify all these parameters explicitly for your ThreadPoolExecutor, it is often easier to use one of the factory methods in the java.util.concurrent.Executors class, as shown in the ExecutorService text.","(""ThreadPoolExecutor"", ""ThreadPoolExecutor is related to Executors because Executors provides factory methods for creating ThreadPoolExecutor instances"", ""Executors""); (""Executors"", ""Executors is part of the java.util.concurrent package"", ""java.util.concurrent""); (""ExecutorService"", ""ExecutorService is part of the java.util.concurrent package"", ""java.util.concurrent""); (""ThreadPoolExecutor"", ""ThreadPoolExecutor implements the ExecutorService interface"", ""ExecutorService"")"
"A Java Certificate class instance contains name plus other details of the entity it identifies, plus possibly a digital signature from a Certificate Authority (CA).","(""Certificate"", ""A Certificate class instance may contain a digital signature from a Certificate Authority (CA), indicating a relationship between the two entities."", ""Certificate Authority"")"
"The Java Certificate class is an abstract class, so while you may use Certificate as variable type, your variable will always point to a subclass of Certificate.",NULL
The Java Certificate class has one subclass - the X509Certificate class.,NULL
This class represents an X.509 certificate which is used as identity certificate in HTTPS and TLS.,"(""X.509"", ""X.509 certificate is used in HTTPS"", ""HTTPS"")"
The Java Certificate getEncoded() method returns an encoded version of the Certificate as a byte array.,"(""Java Certificate"", ""The getEncoded() method is a part of the Java Certificate class, indicating a relationship between the two."", ""getEncoded()""); (""getEncoded()"", ""The getEncoded() method returns an encoded version of the Certificate, indicating a relationship between the method and the Certificate class."", ""Certificate"")"
"For instance, if the Certificate is an X509Certificate the returned byte array will contain an X.590 (ASN.1 DER) encoded version of the Certificate instance.","(""Certificate"", ""The Certificate is a type of X509Certificate, indicating a subclass relationship between the two entities."", ""X509Certificate""); (""Certificate"", ""The Certificate is related to the byte array because the byte array contains an encoded version of the Certificate instance."", ""byte array""); (""X509Certificate"", ""The X509Certificate is related to the byte array because the byte array will contain an X.590 (ASN.1 DER) encoded version of the X509Certificate instance."", ""byte array"")"
The Java Certificate getPublicKey() method returns the PublicKey of this Certificate instance.,"(""Certificate"", ""The getPublicKey() method is a part of the Certificate class, indicating a relationship between the two."", ""getPublicKey()""); (""getPublicKey()"", ""The getPublicKey() method returns a PublicKey, indicating a relationship between the method and the class."", ""PublicKey"")"
The Java Certificate getType() method returns the type of the Certificate instance.,"(""Certificate"", ""The getType() method is a part of the Certificate class, indicating a relationship between the two."", ""getType()""); (""Java"", ""The Certificate class is part of the Java package, indicating a relationship between the two."", ""Certificate"")"
The Java CertificateFactory class (java.security.cert.CertificateFactory) is capable of creating Java Certificate instances from binary certificate encodings like X.509 (ASN.1 DER).,"(""CertificateFactory"", ""The CertificateFactory class is capable of creating Certificate instances"", ""Certificate""); (""CertificateFactory"", ""The CertificateFactory class is part of the java.security.cert package"", ""java.security.cert"")"
"To read more about the Java Certificate class, see the Java Certificate tutorial.",NULL
See the Java CertPath tutorial for more information about the CertPath class.,NULL
This example creates a CertificateFactory instance capable of creating X.509 certificate instances (X509Certificate - a subclass of Certificate).,"(""X509Certificate"", ""X509Certificate is a subclass of Certificate, indicating a clear inheritance relationship between the two classes"", ""Certificate""); (""CertificateFactory"", ""CertificateFactory is capable of creating X509Certificate instances, indicating a clear creation relationship between the factory class and the certificate class"", ""X509Certificate"")"
You create a CertPath instance by calling the CertificateFactory generateCertPath() method.,"(""CertPath"", ""CertPath is created by calling the generateCertPath() method of CertificateFactory"", ""CertificateFactory""); (""CertificateFactory"", ""The generateCertPath() method is a part of the CertificateFactory class"", ""generateCertPath()"")"
"The Java CertPath class (java.security.cert.CertPath represents a chain of cryptographic identity certificates (Java Certificate objects), where each certificate is the digital signer of the next certificate in the chain.","(""CertPath"", ""The CertPath class represents a chain of Java Certificate objects, indicating a relationship between the two classes."", ""Java Certificate""); (""java.security.cert.CertPath"", ""The java.security.cert.CertPath class represents a chain of Java Certificate objects, indicating a relationship between the two classes."", ""Java Certificate"")"
The Java CertPath class is typically used to verify an identity certificate along with the certificates of the Certificate Authorities (CAs) that signed the certificate.,"(""Java CertPath"", ""The Java CertPath class is used to verify an identity certificate along with the certificates of the Certificate Authorities (CAs) that signed the certificate, indicating a relationship between Java CertPath and Certificate Authorities."", ""Certificate Authorities""); (""Java CertPath"", ""The Java CertPath class is used to verify an identity certificate along with the certificates of the Certificate Authorities (CAs) that signed the certificate, indicating a relationship between Java CertPath and CAs."", ""CAs"")"
Once you have a Java CertPath instance you can obtain the Certificate instances the CertPath consists of by calling the CertPath getCertificates() method.,"(""CertPath"", ""The CertPath class has a relationship with the getCertificates method because the getCertificates method is called on a CertPath instance."", ""getCertificates""); (""CertPath"", ""The CertPath class has a relationship with the Certificate class because a CertPath instance consists of Certificate instances."", ""Certificate"")"
The CertPath getType() method returns a string telling what type of certificates (e.g.,NULL
Here is an example of obtaining the CertPath type via getType():,NULL
That is why the Java class is called Cipher and not e.g.,NULL
This Java Cipher tutorial will explain how the Cipher class of the Java Cryptography API works.,NULL
Before you can use a Java Cipher you just create an instance of the Cipher class.,NULL
You create a Cipher instance by calling its getInstance() method with a parameter telling what type of encryption algorithm you want to use.,NULL
There are several overridden versions of both update() and doFinal() which takes different parameters.,NULL
"If you have to encrypt or decrypt a single block of data, just call the doFinal() with the data to encrypt or decrypt.",NULL
"If you have to encrypt or decrypt multiple blocks of data, e.g.",NULL
"multiple blocks from a large file, you call the update() once for each block of data, and finish with a call to doFinal() with the last data block.",NULL
"The reason a call to doFinal() is needed for the last block of data is, that some encryption algorithms need to pad the the data to fit a certain cipher block size (e.g.",NULL
"Hence the calls to update() for intermediate blocks of data, and the call to doFinal() for the last block of data.",NULL
"When decrypting multiple blocks of data you also call the Cipher update() method for intermediate data blocks, and the doFinal() method for the last block.","(""Cipher"", ""The Cipher class has an update() method, indicating a relationship between the two."", ""update()""); (""Cipher"", ""The Cipher class has a doFinal() method, indicating a relationship between the two."", ""doFinal()"")"
The Java Cipher class encryption and decryption methods can encrypt or decrypt part of the data stored in a byte array.,"(""Cipher"", ""The Cipher class has an encryption method"", ""encryption"")"
You simply pass an offset and length to the update() and / or doFinal() method.,NULL
You can encrypt or decrypt data into an existing byte array by passing the destination byte array as parameter to the update() and / or doFinal() method.,NULL
If you want to set a different offset for the dest byte array there is a version of update() and doFinal() which takes an offset parameter extra.,NULL
Here is an example of calling the doFinal() method with an offset into the dest array:,NULL
"When you call the doFinal() method on a Cipher instance, the Cipher instance is returned to the state it had just after initialization.",NULL
Notice the call to update() and then doFinal() for these two blocks of data.,NULL
This is done with the doFinal() call with the third data block.,NULL
After this doFinal() call you can encrypt yet another block of data with the same Java Cipher instance.,"(""DoFinal"", ""The DoFinal method is called on a Java Cipher instance, indicating a relationship between the method and the class."", ""Java Cipher"")"
JCA is structured around some central general purpose classes and interfaces.,"(""JCA"", ""JCA is structured around some central general purpose classes"", ""classes"")"
"Thus, you may use a Cipher class to encrypt and decrypt some data, but the concrete cipher implementation (encryption algorithm) depends on the concrete provider used.",NULL
The most commonly used of these classes are covered throughout the rest of this Java Cryptography tutorial.,NULL
The Provider (java.security.Provider) class is a central class in the Java cryptography API.,NULL
"The Cipher class is explained in more detail in the text on the Java Cipher class, but I will give a brief introduction to the Cipher class in the following sections.","(""Cipher"", ""The Cipher class and Java Cipher class are related because they are both referring to the same concept of a Cipher in Java, with Java Cipher being a more specific mention of the class."", ""Java Cipher"")"
"The Cipher.getInstance(...) method take a String identifying which encryption algorithm to use, as well as a few other configurations of the algorithm.",NULL
"To initialize a Cipher instance to decrypt data you have to use the Cipher.DECRYPT_MODE, like this:",NULL
You do so by calling the Cipher update() or doFinal() methods.,"(""Cipher"", ""The Cipher class has a relationship with the update() method because it is called on Cipher."", ""update()"")"
The update() method is used if you are encrypting or decrypting part of a bigger chunk of data.,NULL
"The doFinal() method is called when you are encrypting the last part of the big chunk of data, or if the block you pass to doFinal() represents the complete data block to encrypt.",NULL
Here is an example of encrypting some data with the doFinal() method,NULL
To decrypt data you would have passed cipher text (encrypted data) into the doFinal() or doUpdate() method instead.,NULL
"The example in the previous section about the Cipher class used a very simple, hardcoded key.",NULL
You can use the Java KeyGenerator class to generate more random encryption keys.,NULL
"The resulting SecretKey instance can be passed to the Cipher.init() method, like this:","(""SecretKey"", ""The SecretKey instance is related to the Cipher class because it is passed to the Cipher.init() method."", ""Cipher""); (""Cipher"", ""The Cipher class is related to the init method because the init method is a part of the Cipher class."", ""init"")"
To generate an asymmetric key pair you can use the KeyPairGenerator (java.security.KeyPairGenerator).,NULL
The KeyStore class is quite advanced so it is described in more detail in its own Java KeyStore Tutorial.,NULL
You can use the Java MessageDigest (java.security.MessageDigest) to calculate message digests.,"(""Java MessageDigest"", ""Java MessageDigest is another name for java.security.MessageDigest"", ""java.security.MessageDigest""); (""java.security.MessageDigest"", ""java.security.MessageDigest is a part of the java.security package"", ""java.security"")"
In order to calculate a message digest of some data you call the update() or digest() method.,NULL
"The update() method can be called multiple times, and the message digest is updated internally.",NULL
"When you have passed all the data you want to include in the message digest, you call digest() and get the resulting message digest data out.","(""Digest"", ""The Digest method is related to the Message class because it is used to get the resulting message digest data out."", ""Message"")"
Here is an example of calling update() several times followed by a digest() call:,NULL
You can also call digest() a single time passing all the data to calculate the message digest from.,"(""Digest"", ""The source entity Digest and the target entity Message are related to each other because the digest method is used to calculate the message digest."", ""Message"")"
The Java Mac class is used to create a MAC from a message.,NULL
"The Mac class is described in more detail in the Java Mac tutorial, but below is a short introduction.",NULL
"You create a Java Mac instance by calling the Mac.getInstance() method, passing as parameter the name of the algorithm to use.","(""Mac"", ""The Mac class has a method called getInstance, indicating a clear relationship between the two entities as the method is part of the class."", ""getInstance""); (""Mac"", ""The Mac class is part of the Java package, indicating a relationship between the class and the package as the class is implemented in Java."", ""Java"")"
Once the Mac instance is initialized you can calculate a MAC from data by calling the update() and doFinal() method.,"(""Mac"", ""The Mac class has a method called update(), indicating a relationship between the two."", ""update()""); (""Mac"", ""The Mac class has a method called doFinal(), indicating a relationship between the two."", ""doFinal()"")"
"If you have all the data to calculate the MAC for, you can call the doFinal() method immediately.",NULL
"If you only have the access to the data in separate blocks, call update() multiple times with the data, and finish off with a call to doFinal().",NULL
You do so by calling the initSign(...) method passing the private key to use to sign the data.,NULL
You do so by calling update() passing the data to sign as parameter.,NULL
You can call the update() method several times with more data to include when creating the signature.,NULL
When all the data has been passed to the update() method you call the sign() method to obtain the digital signature.,NULL
This is done by calling the initVerify(...) method passing as parameter the public key to use to verify the signature.,NULL
"Once initialized into verification mode, you call the update() method with the data the signature is signing, and finish with a call to verify() which returns true or false depending on whether the signature could be verified or not.",NULL
Here is a full example of both creating and verifying a digital signature with the Signature class:,NULL
The Java KeyGenerator class (javax.crypto.KeyGenerator) is used to generate symmetric encryption keys.,"(""Java KeyGenerator"", ""The Java KeyGenerator class is part of the javax.crypto package"", ""javax.crypto.KeyGenerator"")"
Before you can use the Java KeyGenerator class you must create a KeyGenerator instance.,NULL
You create a KeyGenerator instance by calling the static method getInstance() passing as parameter the name of the encryption algorithm to create a key for.,"(""KeyGenerator"", ""KeyGenerator is related to getInstance because getInstance is a method used to create a KeyGenerator instance"", ""getInstance""); (""getInstance"", ""getInstance is related to encryption algorithm because the encryption algorithm is passed as a parameter to getInstance"", ""encryption algorithm"")"
Initializing a KeyGenerator instance is done by calling its init() method.,NULL
"The KeyGenerator init() method takes two parameters: The bit size of the keys to generate, and a SecureRandom that is used during key generation.","(""KeyGenerator"", ""The KeyGenerator class contains the init() method, indicating a relationship between the class and its method."", ""init()""); (""init()"", ""The init() method takes a SecureRandom as a parameter, indicating that the method uses or interacts with the SecureRandom class."", ""SecureRandom"")"
Generating a key is done by calling the KeyGenerator generateKey() method.,NULL
You can access the PublicKey of a KeyPair by calling its getPublic() method.,"(""KeyPair"", ""A KeyPair has a PublicKey that can be accessed through it."", ""PublicKey""); (""KeyPair"", ""The getPublic method is called on a KeyPair to access its PublicKey."", ""getPublic"")"
You can access the PrivateKey of a KeyPair by calling the getPrivate() method.,"(""KeyPair"", ""A KeyPair has a PrivateKey that can be accessed by calling the getPrivate method."", ""PrivateKey""); (""KeyPair"", ""The getPrivate method is called on a KeyPair to access its PrivateKey."", ""getPrivate()"")"
The Java KeyPairGenerator class (java.security.KeyPairGenerator) is used to generate asymmetric encryption / decryption key pairs.,NULL
Creating a KeyPairGenerator instance is done by calling the method getInstance() method.,NULL
The getInstance() method takes the name of the encryption algorithm to generate the key pair for.,"(""Getinstance()"", ""The getInstance() method takes the name of the encryption algorithm, indicating a relationship between the method and the algorithm."", ""Encryption Algorithm"")"
To generate a KeyPair with a KeyPairGenerator you call the generateKeyPair() method.,"(""KeyPairGenerator"", ""KeyPairGenerator uses the generateKeyPair() method to generate a KeyPair"", ""generateKeyPair()""); (""KeyPair"", ""The generateKeyPair() method is used to generate a KeyPair"", ""generateKeyPair()"")"
This makes the KeyStore class a useful mechanism to handle encryption keys securely.,NULL
You can create a Java KeyStore instance by calling its getInstance() method.,NULL
It is also possible to create other types of KeyStore instance by passing a different parameter to the getInstance() method.,NULL
That is why the KeyStore class assumes that you must read its data in before you can use it.,NULL
Loading the KeyStore data from a file or other storage is done by calling the KeyStore load() method.,"(""KeyStore"", ""The KeyStore class has a load() method, indicating a relationship between the two entities as the method is a part of the class."", ""load()"")"
This example loads the KeyStore file located in the keystore.ks file.,NULL
You can get the keys of a Java KeyStore instance via its getEntry() method.,"(""Java KeyStore"", ""The Java KeyStore instance has a getEntry() method, indicating a relationship between the class and the method."", ""getEntry()""); (""Java"", ""The Java KeyStore is part of the Java package, indicating a relationship between the package and the class."", ""Java KeyStore"")"
"Thus, to access a key you must pass the key alias and password to the getEntry() method.",NULL
"If you know that the key entry you want to access is a private key, you can cast the KeyStore.Entry instance to a KeyStore.PrivateKeyEntry.","(""KeyStore.Entry"", ""KeyStore.Entry is related to KeyStore.PrivateKeyEntry because a KeyStore.Entry instance can be cast to a KeyStore.PrivateKeyEntry, indicating a subclass or implementation relationship"", ""KeyStore.PrivateKeyEntry""); (""KeyStore"", ""KeyStore is related to KeyStore.Entry because KeyStore.Entry is a part of the KeyStore class, indicating a containment or namespace relationship"", ""KeyStore.Entry"")"
"After casting to a KeyStore.PrivateKeyEntry you can access the private key, certificate and certificate chain via these methods:","(""KeyStore.PrivateKeyEntry"", ""KeyStore.PrivateKeyEntry is related to private key because it provides access to the private key via its methods"", ""private key""); (""KeyStore.PrivateKeyEntry"", ""KeyStore.PrivateKeyEntry is related to certificate because it provides access to the certificate via its methods"", ""certificate"")"
"Sometimes you may want to store a KeyStore to some storage (disk, database etc.)","(""KeyStore"", ""KeyStore is being stored to some storage"", ""storage""); (""storage"", ""storage can be a disk"", ""disk"")"
"To execute it, open a command line (cmd, console, shell etc.).",NULL
This Keytool -delete command will remove the KeyStore entry with the alias testkey from the KeyStore stored in the file keystore.jks .,"(""Keytool"", ""The Keytool class is related to the KeyStore class because the Keytool command is used to manage the KeyStore entries."", ""KeyStore""); (""Keytool"", ""The Keytool class is related to the -delete method because the -delete command is a method of the Keytool class used to remove KeyStore entries."", ""-delete""); (""KeyStore"", ""The KeyStore class is related to the keystore.jks package because the KeyStore is stored in the keystore.jks file."", ""keystore.jks"")"
"Once generated, the certificate request should be sent to the CA you want to create a certificate for you (e.g.","(""NONE"", ""NO RELATIONSHIPS FOUND"")
######################


Note: The output is based on the provided text, which does not contain any clear entities or relationships of the specified types. In a real-world scenario, the output would depend on the actual content of the API text.


Here is the output with the specified delimiters:


(""entity"",""NONE"",""NONE"", ""NONE"")"
"This command will generate a certificate request for the key stored with alias testkey in the keystore file keystore.jks, and write the certificate request into the file named certreq.certreq .","(""Key"", ""The key is stored in the keystore"", ""Keystore""); (""Generate"", ""The generate method is used to create a certificate request"", ""Certificate""); (""Write"", ""The write method is used to store the certificate request in a file"", ""Certificate""); (""Keystore"", ""The keystore is used as an input for the generate method"", ""Generate"")"
The Java Mac (javax.crypto.Mac class can create a Message Authentication Code (MAC) from binary data.,"(""Java"", ""Java is related to Mac because Mac is a part of the Java ecosystem, specifically the Java Mac is mentioned in the context of creating a Message Authentication Code (MAC)."", ""Mac""); (""Mac"", ""Mac is related to javax.crypto.Mac because javax.crypto.Mac is a class that can create a Message Authentication Code (MAC), which is what Mac is."", ""javax.crypto.Mac""); (""javax.crypto.Mac"", ""javax.crypto.Mac is related to Message Authentication Code because it can create a Message Authentication Code (MAC) from binary data."", ""Message Authentication Code""); (""javax.crypto.Mac"", ""javax.crypto.Mac is related to MAC because it can create a MAC from binary data."", ""MAC""); (""Java"", ""Java is related to javax.crypto.Mac because javax.crypto.Mac is a class in the Java ecosystem."", ""javax.crypto.Mac""); (""Java"", ""Java is related to Message Authentication Code because Java has a class (javax.crypto.Mac) that can create a Message Authentication Code (MAC)."", ""Message Authentication Code""); (""Java"", ""Java is related to MAC because Java has a class (javax.crypto.Mac) that can create a MAC."", ""MAC""); (""Mac"", ""Mac is related to Message Authentication Code because a Mac is a type of Message Authentication Code."", ""Message Authentication Code""); (""Mac"", ""Mac is related to MAC because they are essentially the same thing, with Mac being a type of MAC."", ""MAC"")"
Before you can use the Java Mac class you must create a Mac instance.,"(""Mac"", ""The Mac class is part of the Java package, indicating a relationship between the two entities."", ""Java"")"
The String parameter passed to the Mac getInstance() method contains the name of the MAC algorithm to use.,"(""String"", ""The String parameter is passed to the getInstance method, indicating a relationship between the two entities."", ""getInstance""); (""Mac"", ""The getInstance method is used to get an instance of the Mac class, indicating a relationship between the two entities."", ""getInstance"")"
You initialize the Mac instance by calling its init() method passing as parameter the secret key to be used by the Mac instance.,"(""Mac"", ""The Mac class has an init() method, which establishes a relationship between the two entities as the init() method is a part of the Mac class."", ""init()""); (""init()"", ""The init() method is related to the secret key as it takes the secret key as a parameter, indicating that the secret key is used by the init() method."", ""secret key"")"
To calculate a MAC value you call the Mac update() or doFinal() method.,"(""MAC"", ""MAC and Mac are related as they are likely referring to the same class, with Mac being an instance or object of the MAC class"", ""Mac""); (""Mac"", ""Mac and update() are related as update() is a method that can be called on the Mac class"", ""update()"")"
"If you only have a single block of data to calculate the MAC for, you can call doFinal() directly, like this:",NULL
"If you have multiple blocks of data to calculate the MAC for, e.g.",NULL
"if you are reading a file block by block, then you must call the update() method with each block, and finish with a call to doFinal().",NULL
The Java MessageDigest class represents a cryptographic hash function which can calculate a message digest from binary data.,NULL
This tutorial only explains how to use the Java Cryptography API representation of a message digest in the MessageDigest class.,NULL
To create a Java MessageDigest instance you call the static getInstance() method of the MessageDigest class.,NULL
The text parameter passed to the getInstance() method is the name of the concrete message digest algorithm to use.,"(""GetInstance"", ""The getInstance() method is related to the Message Digest class because it is used to get an instance of a concrete message digest algorithm."", ""Message Digest""); (""Text"", ""The Text parameter is related to the getInstance() method because it is passed to this method."", ""GetInstance"")"
"If you have a single block of data to calculate a message digest from, use the digest() method.",NULL
"If you have multiple blocks of data to include in the same message digest, call the update() method and finish off with a call to digest().",NULL
The Java Signature class (java.security.Signature) can create a digital signature for binary data.,"(""Java Signature"", ""The Java Signature class is part of the java.security.Signature package, indicating a relationship between the class and the package."", ""java.security.Signature""); (""Java Signature"", ""The Java Signature class has a method to create a digital signature, indicating a relationship between the class and the method."", ""create"")"
Before you can use the Java Signature class you must create a Signature instance.,NULL
You create a Signature instance by calling the static getInstance() method.,NULL
The String passed as parameter to the getInstance() method is the name of the digital signature algorithm to use.,NULL
"You create a digital signature by calling the update() method one or more times, finishing with a call to sign().",NULL
Therefore I have put together this little trail on Java's date and time classes.,"(""Java"", ""Java has a date class"", ""Date""); (""Java"", ""Java has a time class"", ""Time"")"
Hopefully that will help you get an overview of Java's date and time classes.,"(""Java"", ""Java has a date class"", ""Date""); (""Java"", ""Java has a time class"", ""Time"")"
I also hope it may clear up some of the confusion Sun has created with Java's many date and time classes.,"(""Java"", ""Java has a date class"", ""Date""); (""Java"", ""Java has a time class"", ""Time""); (""Sun"", ""Sun created Java"", ""Java""); (""Sun"", ""Sun created confusion with Java's date classes"", ""Date"")"
"Actually, the Java date time API has been changed (cleaned up) in Java 8 with the introduction of a whole new set of classes.","(""Java"", ""Java is a part of Java 8, which introduced changes to the Java date time API"", ""Java 8""); (""Java date time API"", ""The Java date time API was changed in Java 8 with the introduction of a new set of classes"", ""Java 8"")"
The new Java date time API is located in the Java package java.time which is part of the standard Java 8 class library.,"(""java.time"", ""The Java date time API is located in the java.time package, indicating a clear relationship between the two entities."", ""Java date time API""); (""Java 8"", ""The java.time package is part of the standard Java 8 class library, indicating a clear relationship between the two entities."", ""java.time""); (""Java 8"", ""The Java date time API is part of the standard Java 8 class library, indicating a clear relationship between the two entities."", ""Java date time API""); (""Java"", ""Java 8 is a version of the Java class library, indicating a clear relationship between the two entities."", ""Java 8""); (""Java"", ""The java.time package is part of the Java class library, indicating a clear relationship between the two entities."", ""java.time"")"
You will see this new date and time representation in many of the classes in the new Java date time API.,"(""Java"", ""The Java package contains the Date class, indicating a relationship between the two entities."", ""Date""); (""Java"", ""The Java package contains the Time class, indicating a relationship between the two entities."", ""Time"")"
The java.time package also contains a set of subpackages which contain more utilities etc.,NULL
"For instance the java.time.chrono contains classes to work with Japanese, Thai, Taiwanese and Islamic calendars.","(""Java.Time.Chrono"", ""The Java.Time.Chrono package contains the Japanese class to work with Japanese calendars."", ""Japanese""); (""Java.Time.Chrono"", ""The Java.Time.Chrono package contains the Thai class to work with Thai calendars."", ""Thai""); (""Java.Time.Chrono"", ""The Java.Time.Chrono package contains the Taiwanese class to work with Taiwanese calendars."", ""Taiwanese"")"
The java.time.format package contains classes used to parse and format dates from and to strings.,NULL
The core of the Java 8 date time API consists of the following classes:,"(""Java 8 date time API"", ""The Java 8 date time API is a part of the Java package, indicating a relationship between the two entities."", ""Java"")"
Java 7 has the following date and time classes and methods.,"(""Java 7"", ""Java 7 has the following date and time classes and methods, indicating that Java 7 is related to date and time classes as it contains them"", ""date and time classes""); (""date and time classes"", ""date and time classes are part of Java 7, indicating that date and time classes are related to Java 7 as they are contained within it"", ""Java 7""); (""methods"", ""methods are part of Java 7, indicating that methods are related to Java 7 as they are contained within it"", ""Java 7"")"
"Each of these classes are also explained in their own pages, later.",NULL
If you need to do simple timing the System.currentTimeMillis() method will do just fine.,NULL
"If you just need an object to hold a date, for instance as a property in a simple domain model object, you can use the java.util.Date class.",NULL
"If you need to read and write the date and time to a database, use the java.sql.Date and java.sql.Timestamp classes.","(""Java.Sql.Date"", ""Both are used for reading and writing date and time to a database, indicating a relationship in their usage and functionality."", ""Java.Sql.Timestamp""); (""Java.Sql"", ""Java.Sql is the package that contains the Java.Sql.Date class, indicating a containment relationship."", ""Java.Sql.Date"")"
"If you need to do date calculations like adding days or months to another date, or check what weekday (monday, tuesday etc.)","(""Date"", ""Date is related to Calculations because date calculations are performed on a date"", ""Calculations""); (""Date"", ""Date is related to Weekday because a date has a weekday"", ""Weekday"")"
"a given date is, or convert dates and times between time zones, use the java.util.Calendar and java.util.GregorianCalendar classes.",NULL
The Java DateTimeFormatter class is used to parse and format dates represented with the classes in the Java 8 date time API.,NULL
The DateTimeFormatter is located in the java.time.format package so the fully qualified class name is java.time.format.DateTimeFormatter.,"(""DateTimeFormatter"", ""The DateTimeFormatter is located in the java.time.format package, indicating a containment relationship."", ""java.time.format"")"
The DateTimeFormatter class contains a set of predefined (constant) instances which can parse and format dates from standard date formats.,"(""DateTimeFormatter"", ""The DateTimeFormatter class is related to dates because it can parse and format dates from standard date formats."", ""dates"")"
You can read about them in the JavaDoc for the DateTimeFormatter class.,NULL
Once you have an instance of a DateTimeFormatter you can format a date using its format() method.,NULL
A Duration object (java.time.Duration) represents a period of time between two Instant objects.,"(""Duration"", ""A Duration object represents a period of time between two Instant objects, indicating a relationship between the two classes."", ""Instant""); (""Duration"", ""The Duration class is part of the java.time.Duration package, indicating a relationship between the class and the package."", ""java.time.Duration"")"
The Duration class was added to the Java date time API from Java 8.,"(""Duration"", ""The Duration class is part of the Java date time API, which is a package in Java."", ""Java"")"
Creating a Duration object is done using one of the Duration class factory methods.,NULL
Here is an example of how to create a Duration object using the between() method:,NULL
This is somewhat different from what we are used to with System.getCurrentTimeMillis() where a moment in time (or a period between two moments) is represented as a number of milliseconds.,NULL
The toNanos() is different from the getNano() in that the getNano() only returns the part of the Duration which is less than one second.,"(""ToNanos"", ""ToNanos and GetNano are related as they both deal with time measurements, but they differ in their return values, with ToNanos returning the entire duration in nanoseconds and GetNano returning only the part of the duration less than one second."", ""GetNano""); (""ToNanos"", ""ToNanos is a method that is likely part of the Duration class, as it operates on the duration to return its value in nanoseconds."", ""Duration"")"
The toNanos() method returns the full time interval converted to nanoseconds.,NULL
You might be asking yourself if there is not a toSeconds() method.,NULL
You can obtain the seconds part of the Duration using the getSeconds() method as explained earlier.,NULL
The Duration class contains a set of methods you can use to perform calculations based on a Duration object.,"(""Duration"", ""The Duration class contains a Duration object, indicating a relationship between the class and its object."", ""Duration"")"
The Instant class in the Java date time API (java.time.Instant) represents a specific moment on the time line.,"(""Instant"", ""The Instant class is part of the Java date time API, which is a package."", ""Java""); (""java.time.Instant"", ""java.time.Instant is another representation of the Instant class, indicating they are the same entity."", ""Instant"")"
"Time is measured using 86.400 seconds per day, moving forward from the origin.",NULL
You create an Instant instance using one of the Instant class factory methods.,NULL
"For instance, to create an Instant which represents this exact moment of now, call Instant.now(), like this:",NULL
The Instant class also has several methods which can be used to make calculations relative to an Instant.,NULL
The LocalDate class in the Java 8 date time API represents a local date which is a date without time zone information.,NULL
"The LocalDate Java class is located in the java.time package, so its fully qualified class name is java.time.LocalDate.",NULL
Here is an example of creating a LocalDate using the now() method:,NULL
"The LocalDate's of() method creates a LocalDate instance representing a specific day of a specific month of a specific year, but without time zone information.",NULL
Notice how the getMonth() and getDayOfWeek() methods return an enum instead of an int.,NULL
From these enums you can obtain their information as int values by calling their getValue() methods.,"(""Enums"", ""Enums are related to GetValue because Enums have a method called getValue() to obtain their information as int values"", ""GetValue""); (""Enums"", ""Enums are related to Information because Enums can obtain their information as int values"", ""Information"")"
You can perform a set of simple date calculations with the LocalDate class using one or more of the following methods:,NULL
The LocalDateTime class in the Java 8 date time API (java.time.LocalDateTime) represents a local date and time without any time zone information.,"(""LocalDateTime"", ""The LocalDateTime class is part of the Java 8 date time API"", ""Java 8 date time API""); (""LocalDateTime"", ""The LocalDateTime class is represented by the java.time.LocalDateTime package"", ""java.time.LocalDateTime"")"
You could view the LocalDateTime as a combination of the LocalDate and LocalTime classes of the Java 8 date time API.,"(""LocalDateTime"", ""LocalDateTime is a combination of LocalDate and LocalTime, indicating a compositional relationship between them"", ""LocalDate""); (""LocalDateTime"", ""LocalDateTime is a combination of LocalDate and LocalTime, indicating a compositional relationship between them"", ""LocalTime""); (""LocalDate"", ""LocalDate is part of the Java 8 date time API, indicating a membership relationship between them"", ""Java 8 date time API""); (""LocalTime"", ""LocalTime is part of the Java 8 date time API, indicating a membership relationship between them"", ""Java 8 date time API"")"
Here is an example that shows how to create a LocalDateTime object via the now() method:,NULL
"The parameters to the of() method are year, month, day (of month), hours, minutes, seconds and nanoseconds.","(""OF"", ""The OF method takes YEAR as one of its parameters"", ""YEAR""); (""OF"", ""The OF method takes MONTH as one of its parameters"", ""MONTH""); (""OF"", ""The OF method takes DAY as one of its parameters"", ""DAY""); (""OF"", ""The OF method takes HOURS as one of its parameters"", ""HOURS""); (""OF"", ""The OF method takes MINUTES as one of its parameters"", ""MINUTES""); (""OF"", ""The OF method takes SECONDS as one of its parameters"", ""SECONDS"")"
Via the methods that return an enum you can get an int representation of the enum by calling the getValue() of the enum .,"(""Enum"", ""The Enum class has a method called GetValue, indicating a relationship between the two entities."", ""GetValue""); (""Methods"", ""The methods are used to return an enum, indicating a relationship between the two entities."", ""Enum"")"
The LocalTime class in the Java 8 date time API represents a specific time of day without any time zone information.,NULL
"The LocalTime class is immutable, so all calculations on LocalTime objects return a new LocalTime instance.",NULL
"There are also other versions of the of() method that only takes hours and minutes, or hours, minutes and seconds as parameters.",NULL
The LocalTime class contains a set of methods that enable you to perform local time calculations.,NULL
The static method System.currentTimeMillis() returns the time since January 1st 1970 in milliseconds.,NULL
"The returned long value can be used to initialize java.util.Date, java.sql.Date, java.sql.Timestamp and java.util.GregorianCalendar objects.","(""Java.Util.Date"", ""Both Java.Util.Date and Java.Sql.Date are related as they can be initialized with the same long value returned by a method."", ""Java.Sql.Date""); (""Java.Util.Date"", ""Both Java.Util.Date and Java.Sql.Timestamp are related as they can be initialized with the same long value returned by a method."", ""Java.Sql.Timestamp""); (""Java.Util.Date"", ""Both Java.Util.Date and Java.Util.Gregoriancalendar are related as they can be initialized with the same long value returned by a method."", ""Java.Util.Gregoriancalendar""); (""Java.Sql.Date"", ""Both Java.Sql.Date and Java.Sql.Timestamp are related as they can be initialized with the same long value returned by a method."", ""Java.Sql.Timestamp""); (""Java.Sql.Date"", ""Both Java.Sql.Date and Java.Util.Gregoriancalendar are related as they can be initialized with the same long value returned by a method."", ""Java.Util.Gregoriancalendar"")"
The granularity of the System.currentTimeMillis() method is larger than 1 millisecond.,NULL
Measuring time in Java is easiest to do with the System.currentTimeMillis() method.,"(""System"", ""The System class contains the System.currentTimeMillis() method, indicating a clear relationship between the two entities."", ""System.currentTimeMillis()""); (""Java"", ""The System class is part of the Java package, indicating a relationship between the Java package and the System class."", ""System"")"
The variable totalTime will now contain the total time it took to execute the callOperationToTime() method.,NULL
"Because System.currentTimeMillis() does not return the time that accurately, it is a good idea to execute the operation to measure more than once.",NULL
"Another good reason to repeat the operation to measure a lot of times is to allow the Java virtual machine to load the classes containing the code, JIT-compile it, and perhaps even optimize it.","(""Java Virtual Machine"", ""The Java Virtual Machine loads the classes containing the code."", ""classes""); (""Java Virtual Machine"", ""The Java Virtual Machine JIT-compiles the code."", ""JIT-compile""); (""Java Virtual Machine"", ""The Java Virtual Machine optimizes the code."", ""optimize""); (""classes"", ""The classes containing the code are JIT-compiled by the Java Virtual Machine."", ""JIT-compile""); (""classes"", ""The classes containing the code are optimized by the Java Virtual Machine."", ""optimize""); (""JIT-compile"", ""JIT-compile is a step that may lead to optimization."", ""optimize""); (""Java"", ""Java is the programming language that uses the Java Virtual Machine."", ""Java Virtual Machine""); (""Java"", ""Java is the programming language that has classes."", ""classes""); (""Java"", ""Java code is JIT-compiled."", ""JIT-compile"")"
"The calculations listed earlier in this text are rather trivial yet tedious to do, and could be encapsulated in a Timer class.",NULL
The ZonedDateTime class in the Java 8 date time API represents a date and time with time zone information.,NULL
The first way is to call the now() method of the ZonedDateTime class.,NULL
Here is an example of creating a ZonedDateTime object using the now() method:,NULL
Another way to create a ZonedDateTime object is to use the of() method which can create a ZonedDateTime object from a concrete date and time.,NULL
Here is an example of creating a ZonedDateTime object using the of() method:,NULL
From the enums you can return an int representation of their value using their getValue() methods.,NULL
The ZonedDateTime class contains a set of methods used for date time calculations.,"(""ZonedDateTime"", ""The ZonedDateTime class contains a set of methods, indicating that the set of methods is a part of the ZonedDateTime class"", ""set of methods""); (""ZonedDateTime"", ""The ZonedDateTime class is used for date time calculations, indicating that the class has a relationship with date time calculations through its methods"", ""date time calculations"")"
The time zones are represented by the ZoneId class as shown in the earlier example.,NULL
The parameter passed to the of() method is the ID of the time zone to create a ZoneId for.,"(""Of"", ""The Of method is used to create a ZoneId, indicating a relationship between the Of method and the ZoneId class."", ""ZoneId""); (""Id"", ""The Id is passed as a parameter to create a ZoneId, indicating a relationship between the Id and the ZoneId class."", ""ZoneId"")"
"You can find the UTC offset for the desired time zone and create an ID matching it by combining ""UTC"" with the offset (e.g.","(""UTC"", ""UTC and ID are related because they are both used in the process of creating an ID matching the desired time zone"", ""ID""); (""UTC"", ""UTC and offset are related because the offset is used in combination with UTC to create an ID matching the desired time zone"", ""offset"")"
"If you need to set a date on a java.sql.PreparedStatement or get a date from a java.sql.ResultSet, you will interact with java.sql.Date.","(""Java.Sql.PreparedStatement"", ""Java.Sql.PreparedStatement is related to Java.Sql.Date because you can set a date on a Java.Sql.PreparedStatement"", ""Java.Sql.Date""); (""Java.Sql.ResultSet"", ""Java.Sql.ResultSet is related to Java.Sql.Date because you can get a date from a Java.Sql.ResultSet"", ""Java.Sql.Date"")"
"Actually, java.sql.Date extends java.util.Date, so anything you can do with a java.util.Date you can also do with a java.sql.Date.",NULL
"The biggest difference between java.sql.Date and java.util.Date is that the java.sql.Date only keeps the date, not the time, of the date it represents.",NULL
"So, for instance, if you create a java.sql.Date using the date and time 2009-12-24 23:20, then the time (23:20) would be cut off.","(""Date"", ""The Date class is part of the sql package, indicating a relationship between the two entities."", ""sql""); (""Java"", ""The Java programming language utilizes the sql package, establishing a connection between the two entities."", ""sql"")"
"If you need to keep the time, use a java.sql.Timestamp instead.","(""Java"", ""Java is related to Sql because Sql is a package within Java"", ""Sql""); (""Sql"", ""Sql is related to Timestamp because Timestamp is a class within the Sql package"", ""Timestamp"")"
"If you need to set a date + time on a java.sql.PreparedStatement or get a date + time from a java.sql.ResultSet, you will interact with java.sql.Timestamp.",NULL
"Actually, java.sql.Timestamp extends java.util.Date, so anything you can do with a java.util.Date you can also do with a java.sql.Timestamp.",NULL
"The biggest difference between java.sql.Date and java.sql.Timestamp is that the java.sql.Date only keeps the date, not the time, of the date it represents.",NULL
One difference in the java.sql.Timestamp from its superclass java.util.Date is its ability to hold the nanoseconds of a date too.,NULL
You can get and set the nanoseconds using the getNanos() and setNanos().,NULL
Java's java.util.Calendar class is used to do date and time arithmetic.,"(""java.util"", ""The java.util package contains the Calendar class, indicating a relationship between the two."", ""Calendar""); (""Java"", ""The Java class is related to the Calendar class because Java is the programming language in which the Calendar class is used."", ""Calendar"")"
"Whenever you have something slightly more advanced than just representing a date and time, this is the class to use.",NULL
"Java only comes with a Gregorian calendar implementation, the java.util.GregorianCalendar class.","(""GregorianCalendar"", ""GregorianCalendar is part of the java.util package"", ""java.util"")"
"The Calendar class has a couple of methods you can use to access the year, month, day, hour, minutes, seconds, milliseconds and time zone of a given date.",NULL
The Calendar class has a corresponding set() method so you can set these fields too.,NULL
"The add() method is really handy when doing date arithmetics like adding or subtracting years, months, days, hours etc.",NULL
"To subtract from the fields call the add() method with negative values, like this:",NULL
There are a few minor traps in the Calendar class that you should be aware of to avoid unnecessary headaches.,NULL
The MONTH field of the Calendar class does not go from 1 to 12 like they do when we write dates otherwise.,NULL
"That means that 1 = sunday, 2 = monday, ..., 7 = saturday.",NULL
If you need to do heavy or complex date and time calculations it is a good idea to read the class documentation for java.util.Calendar in the official JavaDoc's.,"(""java.util.Calendar"", ""java.util.Calendar is a class in the Java package"", ""Java""); (""java.util.Calendar"", ""java.util.Calendar's documentation can be found in JavaDoc"", ""JavaDoc"")"
The class documentation contains more detail about the specific behaviour of the class.,NULL
Today most of the methods in the class are deprecated in favor of the java.util.Calendar class.,"(""Methods"", ""The methods are part of the class, indicating a relationship between them"", ""Today""); (""Java.Util.Calendar"", ""The methods in the class are deprecated in favor of the java.util.Calendar class, indicating a replacement relationship"", ""Methods"")"
You can still use the java.util.Date class to represent a date though.,NULL
"You can access the date and time contained in a java.util.Date instance using the getTime() method, like this:",NULL
"You can also create a java.util.Date from a time in milliseconds, like this:","(""Java"", ""Java is a package that contains the Util package"", ""Util""); (""Util"", ""Util is a package that contains the Date class"", ""Date"")"
You can compare java.util.Date instance because the class implements the java.lang.Comparable interface.,NULL
"The comparison follows the rules for the Comparable interface, meaning the compareTo() method returns:",NULL
"The Java TimeZone class is a class that represents time zones, and is helpful when doing calendar arithmetics across time zones.",NULL
The java.util.TimeZone class is used in conjunction with the java.util.Calendar class.,NULL
Note: In the Java 8 date time API the time zones are represented by the java.time.ZoneId class.,"(""Java 8 date time API"", ""The java.time.ZoneId class is part of the Java 8 date time API, representing time zones."", ""java.time.ZoneId""); (""Java"", ""The Java 8 date time API is a part of the Java package."", ""Java 8 date time API""); (""Java"", ""The java.time.ZoneId class is part of the Java package, specifically in the Java 8 date time API."", ""java.time.ZoneId""); (""8"", ""The Java 8 date time API is a part of the Java package, specifically version 8."", ""Java 8 date time API"")"
But you only need to use the ZoneId class if you are using the Java 8 date time classes (like the ZonedDateTime class).,"(""ZoneId"", ""The ZoneId class is related to the ZonedDateTime class because ZoneId is used in conjunction with ZonedDateTime when working with Java 8 date time classes."", ""ZonedDateTime""); (""ZoneId"", ""The ZoneId class is related to Java 8 because it is part of the Java 8 date time classes."", ""Java 8"")"
If you use a Calendar (from the Java 7 and earlier date time API) you can still use the java.util.TimeZone class.,"(""Calendar"", ""The Calendar class is part of the Java package, indicating a relationship between the two entities."", ""Java""); (""java.util.TimeZone"", ""The java.util.TimeZone class is part of the Java package, indicating a relationship between the two entities."", ""Java"")"
The first method (TimeZone.getDefault()) returns the default time zone for the system (computer) this program is running on.,"(""TimeZone"", ""The TimeZone class contains the getDefault method, indicating a relationship between the two."", ""getDefault""); (""getDefault"", ""The getDefault method returns the default time zone, indicating a relationship between the method and the time zone."", ""default time zone"")"
"The second method (TimeZone.getTimeZone(""Europe/Copenhagen"")) returns the TimeZone corresponding to the given time zone ID (in this example ""Europe/Copenhagen"").",NULL
"The getOffset() method returns the offset in milliseconds for the given time zone to UTC, at the given time.","(""GetOffset"", ""The getOffset() method is related to Time Zone because it returns the offset in milliseconds for the given time zone to UTC."", ""Time Zone""); (""Time Zone"", ""Time Zone and UTC are related because the offset is calculated from the given time zone to UTC."", ""UTC"")"
The Calendar class is capable of converting the date and time between time zones.,"(""Calendar"", ""The Calendar class is capable of converting the date and time between time zones, indicating a relationship between the Calendar class and the date."", ""date""); (""Calendar"", ""The Calendar class is capable of converting the date and time between time zones, indicating a relationship between the Calendar class and the time."", ""time"")"
"Here is a list of the available time zone ids in the TimeZone class, printed as returned by TimeZone.getAvailableIDs().",NULL
"It is possible to both parse dates from strings, and format dates to strings, using Java's java.text.SimpleDateFormat class.","(""SimpleDateFormat"", ""SimpleDateFormat is a part of the java.text package"", ""java.text""); (""Java"", ""Java has a class called SimpleDateFormat"", ""SimpleDateFormat"")"
It is also possible to parse and format dates using the newer Java DateTimeFormatter which is able to parse and format dates from and to the newer date time classes added in Java 8.,"(""DateTimeFormatter"", ""The DateTimeFormatter class is related to Java 8 because it is able to parse and format dates from and to the newer date time classes added in Java 8."", ""Java 8""); (""Java"", ""Java 8 is a version of the Java package, indicating a relationship between the two."", ""Java 8"")"
"Even though both classes for parsing and formatting dates are covered in more detail in their own texts, I will show you a few examples of how to use them below.","(""Classes"", ""Classes is related to Parsing because both are classes for parsing and formatting dates"", ""Parsing""); (""Classes"", ""Classes is related to Formatting because both are classes for parsing and formatting dates"", ""Formatting"")"
Here is an example of how to format and parse a date using the SimpleDateFormat class.,NULL
The string passed as parameter to the SimpleDateFormat class is a pattern that tells how the instance is to parse and format dates.,NULL
"For a full list, see the official JavaDoc for the SimpleDateFormat class.",NULL
Another way to format dates is to use the DateTimeFormatter which works with the newer date time classes added in Java 8.,NULL
In the example above we use the DateTimeFormatter.BASIC_ISO_DATE instance which is configured to parse and format dates using the ISO date time format.,NULL
"Exceptions are regular Java classes that extends java.lang.Exception, or any of the other built-in exception classes.","(""Exceptions"", ""Exceptions are related to java.lang.Exception because they extend it"", ""java.lang.Exception""); (""Java"", ""Java is related to Exceptions because Exceptions are regular Java classes"", ""Exceptions"")"
"If a method declares that it throws an exception A, then it is also legal to throw subclasses of A.",NULL
"In the example above the ""System.out.println(result);"" statement will not get executed if an exception is thrown fromt the divide method.","(""System"", ""System is a class that contains the out class"", ""out""); (""System"", ""The divide method is not directly related to the System class in this context, but it is mentioned as a method that may throw an exception"", ""divide""); (""out"", ""out is a class that contains the println method"", ""println"")"
"In the example above the ""System.out.println(""Division attempt done"");"" statement will always get executed.","(""System"", ""System is a class that contains out as a static field"", ""out""); (""out"", ""out is an object that has a method called println"", ""println"")"
Here is how the callDivide() method would look in that case.,NULL
"Thus the ""System.out.println(result);"" method will not get executed if an exception is thrown from the divide method.",NULL
"If the reader.read() method call throws an IOException, the following System.out.println((char) i ); is not executed.","(""Reader"", ""The Reader class has a method called Read, indicating a relationship between the two."", ""Read""); (""System"", ""The System class has a method called Println, indicating a relationship between the two."", ""Println""); (""Read"", ""The Read method is related to the System class because the outcome of the Read method call affects the execution of the System.out.println statement."", ""System"")"
"Neither is the last reader.close() or the System.out.println(""--- File End ---""); statements.","(""Reader"", ""The Reader class has a close method, indicating a relationship between the two."", ""close"")"
Instead the program skips directly to the catch(IOException e){ ... } catch clause.,NULL
"If an exception is thrown from the reader.read() method then program execution is halted, and the exception is passed up the call stack to the method that called openFile().","(""Reader"", ""The Reader class contains the Read method, indicating a relationship between the two."", ""Read""); (""Read"", ""The Read method is called by the Openfile method, as indicated by the call stack, showing a relationship between the two methods."", ""Openfile"")"
"If the calling method also just throws the method on, the calling method is also interrupted at the openFile() method call, and the exception passed on up the call stack.","(""Calling Method"", ""The calling method is related to the OpenFile() method because it calls the OpenFile() method and is interrupted at that method call."", ""OpenFile()""); (""Calling Method"", ""The calling method is related to the call stack because the exception is passed on up the call stack from the calling method."", ""Call Stack"")"
That is why the previous example had the reader.close() method call in the finally block wrapped in a try-catch block:,NULL
"That way the System.out.println(""--- File End ---""); method call will always be executed.","(""System.out.println"", ""The System.out.println method is a part of the System class, indicating a relationship between the two entities."", ""System"")"
Notice how the two exception class names in the first catch block are separated by the pipe character |.,NULL
The pipe character between exception class names is how you declare multiple exceptions to be caught by the same catch clause.,NULL
If storeDataFromUrl() wants to call readDataFromUrl() it has only two choices.,NULL
Notice how the readDataFromUrl() method no longer declares that it throws BadUrlException.,NULL
"The storeDataFromUrl() method can still choose to catch the exception but it no longer has to, and it no longer has to declare that it propagates the exception.",NULL
As you can see the readNumberFromUrl() needs to declare throwing both the BadUrlException and the BadNumberException that are thrown from the readDataFromUrl() and converData() methods.,"(""ReadNumberFromUrl"", ""The ReadNumberFromUrl method declares throwing the BadUrlException, indicating a relationship between the two entities."", ""BadUrlException""); (""ReadNumberFromUrl"", ""The ReadNumberFromUrl method declares throwing the BadNumberException, indicating a relationship between the two entities."", ""BadNumberException""); (""ReadDataFromUrl"", ""The BadUrlException is thrown from the ReadDataFromUrl method, indicating a relationship between the two entities."", ""BadUrlException""); (""ConverData"", ""The BadNumberException is thrown from the ConverData method, indicating a relationship between the two entities."", ""BadNumberException""); (""ReadNumberFromUrl"", ""The ReadNumberFromUrl method is related to the ReadDataFromUrl method as it needs to declare throwing exceptions thrown by ReadDataFromUrl."", ""ReadDataFromUrl"")"
Imagine how many exceptions would need to be declared at the top level methods of an application with thousands of classes.,"(""Exceptions"", ""Exceptions are related to Methods because they need to be declared at the top level of methods in an application."", ""Methods""); (""Methods"", ""Methods are related to Application because they are part of the application's structure."", ""Application""); (""Exceptions"", ""Exceptions are related to Application because they are handled within the application's scope."", ""Application""); (""Classes"", ""Classes are related to Application because the application is composed of thousands of classes."", ""Application"")"
As you can see the readNumberFromUrl() method now only declares throwing ApplicationException.,NULL
Notice how the readNumberFromUrl() method does not declare throwing the ApplicationException even if it throws it.,NULL
All exceptions thrown in the application must be a subclass of the base exception.,NULL
As you know a method throwing Exception may also throw any subclass of Exception.,NULL
They are subclasses of the ApplicationException so they will get propagated up the call stack.,NULL
Argument 5 (Pro Unchecked Exceptions) Checked exceptions declared on methods become part of a the class or interface contract.,"(""Argument 5"", ""Argument 5 is related to Pro Unchecked Exceptions as it is mentioned alongside it in the context of exceptions"", ""Pro Unchecked Exceptions""); (""Pro Unchecked Exceptions"", ""Pro Unchecked Exceptions is related to Checked exceptions as they are both types of exceptions being discussed"", ""Checked exceptions""); (""Checked exceptions"", ""Checked exceptions are related to methods because they are declared on methods"", ""methods""); (""methods"", ""methods are related to class or interface contract because checked exceptions declared on methods become part of the contract"", ""class or interface contract"")"
The only requirement is that the new exceptions thrown are subclasses of the base exception.,NULL
Anders Hejlsberg on checked vs. unchecked exceptions http://www.artima.com/intv/handcuffs.html James Gosling on checked exceptions http://www.artima.com/intv/solid.html Bill Venners on Exceptions http://www.artima.com/interfacedesign/exceptions.html Bruce Eckel on checked exceptions http://www.artima.com/intv/typingP.html Designing with Exceptions (Bill Venners - www.artima.com) http://www.artima.com/designtechniques/desexcept.html Effective Java (Joshua Bloch - Addison Wesley 2001) Daniel Pietraru - in favor of checked exceptions Exceptional Java - Checked exceptions are priceless茂驴�?For everything else there is the RuntimeException,NULL
Checked exceptions declared on methods become part of a the class or interface contract.,"(""Exceptions"", ""Exceptions are declared on methods"", ""Methods""); (""Methods"", ""Methods become part of a class contract"", ""Class""); (""Methods"", ""Methods become part of an interface contract"", ""Interface"")"
As you can see the method1() throws an EnrichableException which is a superclass for enrichable exceptions.,NULL
"Notice how method2() calls the addInfo() method on the caught EnrichableException, and rethrow it afterwards.","(""method2"", ""method2() calls the addInfo() method on the caught EnrichableException"", ""EnrichableException""); (""method2"", ""method2() calls the addInfo() method"", ""addInfo"")"
"Notice how method1() adds the code ""ERROR1"" to the thrown EnrichableException to uniquely identify that error cause.",NULL
But notice too that method1() is called from both method2() and method3().,"(""Method2"", ""Method2 calls Method1"", ""Method1"")"
"Though the error may seem the same to method1() no matter which of method2() and method3() that called it, this may important to know for the developer investigating the error.","(""Method1"", ""Method1 is related to Method2 because Method2 is one of the methods that called Method1, which may be relevant for error investigation."", ""Method2""); (""Method1"", ""Method1 is related to Method3 because Method3 is one of the methods that called Method1, which may be relevant for error investigation."", ""Method3"")"
Here is an example where the addInfo() method has been changed to accommodate this:,NULL
Two new parameters have been added to the addInfo() method and the constructor of the EnrichableException.,"(""EnrichableException"", ""The addInfo() method is a part of the EnrichableException class, indicating a relationship between the two."", ""addInfo()""); (""EnrichableException"", ""The constructor is a part of the EnrichableException class, indicating a relationship between the two."", ""constructor"")"
An error identification for an exception thrown by method1() when called from method2() will now look like this:,NULL
When method1() is called from method3() the error identification will look like this:,NULL
As you can see it is now possible to distinguish an exception thrown from method1() via method2() from the same exception thrown from method1() via method3().,"(""Method1"", ""Method1 and Method2 are related because an exception thrown from Method1 can be distinguished when it is called via Method2."", ""Method2""); (""Method1"", ""Method1 and Method3 are related because an exception thrown from Method1 can be distinguished when it is called via Method3."", ""Method3"")"
"Here is an example where method1() catches a non-enrichable exception and wraps it in an enrichable exception, and throws the enrichable exception:","(""Method1"", ""Method1 is related to Exception because it catches and wraps a non-enrichable exception in an enrichable exception"", ""Exception"")"
Exceptions caught in the program will be passed to the handleException() which will decide what concrete exception to throw instead.,NULL
If the EnrichableException is unchecked it is not necessary to declare it in the handleException() method.,NULL
You may need to change the class definition to suit your own needs.,NULL
"If an exception is thrown from within the try block, and another exception is thrown from the input.close() call in the finally block, both exceptions are preserved in the MyException instance, and propagated up the call stack.","(""MyException"", ""MyException is related to try because an exception thrown from within the try block is preserved in the MyException instance"", ""try""); (""MyException"", ""MyException is related to finally because an exception thrown from the input.close() call in the finally block is preserved in the MyException instance"", ""finally""); (""try"", ""try and finally are related because they are both blocks in the same exception handling mechanism"", ""finally""); (""try"", ""try is related to input.close because the input.close() call is made after the try block"", ""input.close"")"
"RuntimeExceptions thrown from the try-block are not preserved, if the input.close() call also throws an exception.","(""RuntimeException"", ""The RuntimeException is thrown from the try-block, indicating a clear relationship between the two entities as the try-block is the source of the exception."", ""try-block""); (""try-block"", ""The try-block contains the input.close call, suggesting a relationship between the try-block and the input.close method, as the latter is executed within the scope of the former."", ""input.close"")"
Notice how the process() method calls the doProcess() method inside the try-catch block.,NULL
"You will use the template by subclassing it, and overriding the doProcess() method.",NULL
"This example creates an anonymous subclass of the InputStreamProcessingTemplate class, instantiates an instance of the subclass, and calls its process() method.",NULL
"You will typically also get more help from your IDE's code completion when writing it, because the IDE will recognize both the doProcess() and process() methods.",NULL
Instead of subclassing the InputStreamProcessingTempate you could rewrite it to take an instance of an InputStreamProcessor interface.,NULL
"This is the InputStreamProcessor, which is called from inside the try block (processor.process(input)).",NULL
"It doesn't look much different from the previous usage, except the call to the InputStreamProcessingTemplate.process() method is now closer to the top of the code.",NULL
Notice how the call to the template's process() method is now a static method call.,NULL
"The advantage of exception hierarchies is that if you decide to catch (using try-catch) a certain exception in the hierarchy, then you will automatically also catch all subclasses of that exception too.","(""Exception"", ""The Exception class is related to the Try method because exceptions are often caught using a try-catch block."", ""Try""); (""Exception"", ""The Exception class is related to the Catch method because exceptions are often caught using a catch block."", ""Catch"")"
"In the example with FileNotFoundException, if you catch IOException which is the superclass of FileNotFoundException, you will also catch FileNotFoundException.",NULL
"But, multiple catch blocks can also be used in the case where all the exceptions thrown inside the try-block are the same type or subclasses of that type.","(""Catch"", ""The catch block is used in conjunction with the try-block to handle exceptions."", ""Try-Block""); (""Catch"", ""The catch block is used to catch and handle exceptions that are thrown."", ""Exceptions"")"
"The fact that FileNotFoundException is a subclass of IOException gives us the choice of either treating all IOExceptions the same, or catch some of IOExceptions subclasses individually, as is done in the code example above.",NULL
"If the catch(FileNotFoundException e) block is removed any FileNotFoundException will be caught by the catch(IOException e) block, since FileNotFoundException is a subclass of IOException.",NULL
"If a method can throw either a certain exception A, or any subclasses of A (Asub), then it is enough to declare in the method declaration that the method throws A.",NULL
It is then allowed to throw subclasses of A from the method too.,NULL
"You are allowed to declare the subclasses in the throws clause of the method, even if you don't really need to.","(""Subclasses"", ""Subclasses are declared in the throws clause of the Method"", ""Method""); (""Throws Clause"", ""The throws clause is a part of the Method"", ""Method"")"
"As long as the superclass of any declared exception is also declared thrown, it doesn't have any effect on the code to include the throwing of the subclass.","(""Superclass"", ""The superclass is related to the exception because it is the superclass of any declared exception."", ""Exception""); (""Superclass"", ""The superclass is related to the subclass because the subclass is a subclass of the superclass."", ""Subclass"")"
"It is still possible to handle the two exceptions with each their own catch-block as shown earlier, even if only the superclass is declared thrown.","(""Exception"", ""The Exception is handled by the Catch-Block, indicating a relationship between the two entities."", ""Catch-Block""); (""Superclass"", ""The Superclass is related to the Exception, as the Exception is a subclass of the Superclass."", ""Exception"")"
"If you need more granularity on the exceptions thrown, for instance because you think the exceptions may be handled differently, then add new exceptions as subclasses of your API or application base exception.","(""API"", ""The API is related to Exceptions because the text mentions adding new exceptions as subclasses of the API or application base exception, indicating that the API is a source of exceptions."", ""Exceptions""); (""Application"", ""The Application is related to Exceptions because the text mentions adding new exceptions as subclasses of the API or application base exception, indicating that the Application is also a source of exceptions."", ""Exceptions""); (""API"", ""The API is related to the Base Exception because the text mentions that new exceptions should be added as subclasses of the API or application base exception, indicating that the API has a base exception."", ""Base Exception"")"
"In Mr. Persister we could add a ConnectionOpenException, QueryException, UpdateException, CommitException, and ConnectionCloseException as subclasses of PersistenceException.","(""ConnectionOpenException"", ""ConnectionOpenException is a subclass of PersistenceException"", ""PersistenceException""); (""QueryException"", ""QueryException is a subclass of PersistenceException"", ""PersistenceException""); (""UpdateException"", ""UpdateException is a subclass of PersistenceException"", ""PersistenceException""); (""CommitException"", ""CommitException is a subclass of PersistenceException"", ""PersistenceException""); (""ConnectionCloseException"", ""ConnectionCloseException is a subclass of PersistenceException"", ""PersistenceException""); (""Mr. Persister"", ""Mr. Persister could have ConnectionOpenException as a subclass of PersistenceException"", ""ConnectionOpenException""); (""Mr. Persister"", ""Mr. Persister could have QueryException as a subclass of PersistenceException"", ""QueryException""); (""Mr. Persister"", ""Mr. Persister could have UpdateException as a subclass of PersistenceException"", ""UpdateException""); (""Mr. Persister"", ""Mr. Persister could have CommitException as a subclass of PersistenceException"", ""CommitException""); (""Mr. Persister"", ""Mr. Persister could have ConnectionCloseException as a subclass of PersistenceException"", ""ConnectionCloseException"")"
Summary In this text we have seen that exception hierarchies can be created by subclassing exception classes.,NULL
"It is a good idea to create a base exception for your API or application, and have all other exceptions subclass this base exception.","(""Exception"", ""The Exception is related to the Base Exception because the text suggests that all other exceptions should subclass this base exception, indicating a subclass relationship."", ""Base Exception""); (""API"", ""The API is related to the Exception because the text mentions creating a base exception for your API, indicating that the API uses or defines exceptions."", ""Exception"")"
Individual subclasses makes it possible (but not obligatory) to catch and handle these individual exceptions differently.,"(""Individual"", ""Individual is a class that has subclasses"", ""subclasses""); (""subclasses"", ""subclasses can catch and handle exceptions"", ""exceptions"")"
In this text we have seen that exception hierarchies can be created by subclassing exception classes.,NULL
Exception wrapping is a standard feature in Java since JDK 1.4.,"(""Exception"", ""Exception is a part of the Java ecosystem, which provides a standard feature of exception wrapping"", ""Java""); (""Java"", ""Java is closely related to JDK, as JDK is a specific implementation of the Java platform"", ""JDK"")"
They also have a getCause() method that will return the wrapped exception.,NULL
"When a request is successfully processed, you can write the whole execution context object to a log file, as a single, coherent structure (e.g.","(""Request"", ""The request is related to the execution context because the execution context object is written to a log file after a request is successfully processed."", ""Execution Context""); (""Execution Context"", ""The execution context is related to the log because the whole execution context object is written to a log file as a single, coherent structure."", ""Log""); (""Request"", ""The request is related to the log because when a request is successfully processed, the execution context object is written to a log file."", ""Log""); (""Write"", ""The write method is related to the log because it is used to write the execution context object to a log file."", ""Log""); (""Write"", ""The write method is related to the execution context because it is used to write the whole execution context object to a log file."", ""Execution Context"")"
"It's implemented as a single class called ExecutionContext, which keeps all calls to it internally in a list.",NULL
Notice how each method ( level1() to level3() ) calls the ExecutionContext.,"(""level1()"", ""level1() method calls the ExecutionContext"", ""ExecutionContext""); (""level2()"", ""level2() method calls the ExecutionContext"", ""ExecutionContext"")"
"Therefore, I have developed an ExecutionContextTree class, which can contain this information.",NULL
"The pre() call creates a new node, and attaches it to the parent node (if any).","(""Pre"", ""The pre() call creates a new node, indicating a relationship between the Pre method and the Node class."", ""Node""); (""Node"", ""The text mentions a parent node, indicating a relationship between the Node class and the Parent Node class, where a Node can be a Parent Node."", ""Parent Node"")"
"Any calls to pre() after this one, will result in new nodes being attached to the newly created node.",NULL
The post() call removes the node as the current parent in the execution tree.,"(""Post"", ""The post() call removes the node, indicating that the Post method is related to the Node class."", ""Node""); (""Post"", ""The post() call removes the node as the current parent in the execution tree, indicating that the Post method is related to the Execution Tree class."", ""Execution Tree"")"
The next call to pre() will now attach a node to the parent of the node just removed as parent node.,"(""Pre"", ""The method Pre is related to Node because it attaches a node to the parent of the node just removed as parent node."", ""Node""); (""Pre"", ""The method Pre is related to Parent Node because it attaches a node to the parent of the node just removed as parent node."", ""Parent Node"")"
"As you can see, the pre() and post() calls are very often insert at the start and end of a method call.","(""Pre"", ""Both Pre and Post are related as they are often used together in method calls, with Pre typically being called before and Post being called after the main method."", ""Post""); (""Pre"", ""Pre is related to method as it is often inserted at the start of a method call."", ""method"")"
"If the input.close() call fails, and an IOException is thrown, then it is caught, wrapped and rethrown.","(""Input"", ""The Input class has a method called Close, indicating a relationship between the two."", ""Close""); (""Close"", ""The Close method can throw an IOException, indicating a relationship between the two."", ""IOException"")"
All classes implementing this interface can be used inside the try-with-resources construct.,NULL
The Java try-with-resources construct does not just work with Java's built-in classes.,"(""Java"", ""The Java try-with-resources construct is related to Java because it is a part of the Java language."", ""try-with-resources""); (""Try-with-resources"", ""The try-with-resources construct is related to Java because it is used with Java's built-in classes."", ""Java""); (""Java"", ""The Java try-with-resources construct is related to Java because it is a part of the Java language."", ""Try-with-resources""); (""Try-with-resources"", ""The try-with-resources construct is related to Java's built-in classes because it works with them."", ""Java's built-in classes"")"
"You can also implement the java.lang.AutoCloseable interface in your own classes, and use them with the try-with-resources construct.",NULL
Any class that implements this interface can be used with the Java try-with-resources construct.,"(""Class"", ""A class can implement an interface, and in this context, any class that implements this interface can be used with the Java try-with-resources construct."", ""Interface""); (""Interface"", ""The interface is used in the context of the Java try-with-resources construct, indicating a relationship between the interface and the Java package."", ""Java"")"
Here is the output printed to System.out when the method myAutoClosable() is called:,"(""System.out"", ""The method myAutoClosable() is printing output to System.out, indicating a relationship between the two entities."", ""myAutoClosable""); (""System"", ""System.out is an object of the System class, indicating a relationship between the two entities."", ""System.out"")"
"If an exception is thrown both from inside the try-with-resources block, and when a resource is closed (when close() is called), the exception thrown inside the try block will be propagated up the call stack.","(""Try-With-Resources"", ""The try-with-resources block uses the close method when a resource is closed."", ""Close""); (""Try-With-Resources"", ""The try-with-resources block throws an exception when an error occurs."", ""Exception"")"
"In that case, the exception thrown when attempted closed will be propagated up the call stack to the main() method where the try-catch block will catch it.",NULL
"In that case, the Throwable array returned from e.getSuppessed() will be an empty array (size of 0).","(""e"", ""e is an object that has a method called getSuppressed, indicating a relationship between the two"", ""getSuppressed""); (""getSuppressed"", ""getSuppressed is a method that returns a Throwable array, indicating a relationship between the method and the class"", ""Throwable"")"
"In case the parameter to resourceOne.doOp() was changed to true also, the doOp() method would throw an exception.",NULL
"In that case, it is this exception that is propagated up the call stack to the main() method.",NULL
The exception thrown when attempting to close the resource would be available inside the Throwable array returned by e.getSuppressed().,"(""e"", ""e is an object that has a method called getSuppressed, indicating a relationship between the two"", ""getSuppressed""); (""Throwable"", ""e is an instance of the Throwable class, indicating a relationship between the two"", ""e"")"
"However, in the example above I have forced both resources to throw an exception when attempted closed, and the first resource to throw an exception when used (when doOp() is called).",NULL
The two exceptions thrown when attempting to close the resources are available in the Throwable array returned by e.getSuppressed().,"(""e"", ""e is an object that has a method called getSuppressed, indicating a relationship between the two"", ""getSuppressed""); (""Throwable"", ""e is an instance of the Throwable class, indicating a relationship between the two"", ""e"")"
"In case an exception is thrown when attempting to close one of the resources, these exceptions will be available from the exception's getSuppressed() method inside the catch block.","(""Exception"", ""The Exception class has a method called getSuppressed, which indicates a relationship between the two."", ""GetSuppressed"")"
"In the example above, the AutoClosableResource is configured to throw an exception both when doOp() is called, and when it is attempted closed (via close()).","(""AutoClosableResource"", ""The AutoClosableResource class has a method called doOp(), indicating a relationship between the class and the method."", ""doOp()"")"
"The exception thrown from doOp() is caught in the catch block, its getSuppressed() method returns an array with the exception thrown when the resource was attempted closed.","(""DoOp"", ""The exception thrown from doOp() is caught in the catch block, indicating a relationship between the doOp method and the Exception class"", ""Exception"")"
"The getSuppressed() method of that exception will return an empty array, since no exceptions where suppressed.",NULL
The Throwable class has a method named addSuppressed() which takes a Throwable object as parameter.,"(""Throwable"", ""The Throwable class has a method named addSuppressed(), indicating a relationship between the Throwable class and the addSuppressed() method."", ""addSuppressed()"")"
"Using the addSuppressed() method it is possible to add suppressed exceptions to another exception, in case you need that.",NULL
"To understand why, look at the following method which reads a file and prints it to the System.out:","(""Method"", ""The Method is related to File because it reads a file"", ""File""); (""Method"", ""The Method is related to System.out because it prints to System.out"", ""System.out"")"
"The InputStream's close() method may throw an exception too, if closing it fails.",NULL
You will have to code your own exception class in order to make exception enrichment possible.,NULL
"However, the ExceptionHandler can throw all the unchecked exceptions it wants (RuntimeException and subclasses of it).",NULL
"In contrast, inside a DAO class you will most likely not be able to interact with the user to correct the error.",NULL
In this example the validate() method throws an exception as soon as an validation error is found.,NULL
"Notice how it is not necessary to cast the object obtained from the List.get() method call, as is normally necessary.","(""List"", ""The List class has a get method, indicating a relationship between the two entities."", ""get"")"
Notice how it is not necessary to cast the object returned from the iterator.next() next call.,"(""Iterator"", ""The Iterator class has a method called Next, indicating a relationship between the two entities."", ""Next""); (""Next"", ""The Next method returns an Object, establishing a relationship between the method and the class."", ""Object"")"
"Adding and getting elements to a generic Map is done using the put() and get() methods, just like you have always done:","(""Map"", ""The Map class uses the put() method to add elements."", ""put()""); (""Map"", ""The Map class uses the get() method to retrieve elements."", ""get()"")"
Also notice how it is not necessary to cast the String instance returned by the get() method.,NULL
Most often you iterate the key Set and access the values for each key via the Map.get() method.,"(""Map"", ""The Map class has a method called Map.get(), indicating a clear relationship between the two entities."", ""Map.get()""); (""Map"", ""The Map class is related to the Set class because the key Set is iterated to access the values for each key via the Map, indicating a relationship between the Map and Set classes."", ""Set""); (""Map"", ""The Map class is related to the key class because the key is used to access the values via the Map, indicating a relationship between the Map and key classes."", ""key""); (""Set"", ""The Set class is related to the key class because the key Set is iterated, indicating a relationship between the Set and key classes."", ""key"")"
"Adding elements to a generic Set is done using the add() method, just like you have always done:",NULL
Generics is not restricted to the predefined classes in the Java API's.,NULL
The <T> is a type token that signals that this class can have a type set when instantiated.,NULL
Notice how it is not necessary to cast the object returned from the factory.createInstance() method.,NULL
Notice how we can call the addAndReturn() method using both String's and Integer's and their corresponding collections.,"(""String"", ""The String class is related to the addAndReturn() method because it is used as an argument to call this method."", ""addAndReturn()"")"
"Java Generic's wildcards is a mechanism in Java Generics aimed at making it possible to cast a collection of a certain class, e.g A, to a collection of a subclass or superclass of A.","(""Java Generics"", ""Java Generics is related to A because A is an example of a class used in Java Generics"", ""A""); (""Java Generic"", ""Java Generic is related to A because A is an example of a class used in Java Generic's wildcards mechanism"", ""A"")"
"In listA you can insert objects that are either instances of A, or subclasses of A (B and C).","(""A"", ""B is a subclass of A"", ""B""); (""A"", ""C is a subclass of A"", ""C""); (""ListA"", ""ListA can contain instances of A"", ""A""); (""ListA"", ""ListA can contain instances of B, which is a subclass of A"", ""B"")"
When you then try to take objects out of listB you could risk to get non-B objects out (e.g.,NULL
Thus you could insert non-B objects into a list declared to hold B (or B subclass) instances.,NULL
"Imagine you have a method that processes the elements of a List, e.g.",NULL
The processElements() method can now be called with any generic List as parameter.,NULL
"When you know that the instances in the collection are of instances of A or subclasses of A, it is safe to read the instances of the collection and cast them to A instances.",NULL
"You can now call the processElements() method with either a List<A>, List<B> or List<C>.","(""ProcessElements"", ""The ProcessElements method can be called with List<A> as an argument, indicating a relationship between the two."", ""List<A>""); (""ProcessElements"", ""The ProcessElements method can be called with List<B> as an argument, indicating a relationship between the two."", ""List<B>"")"
"super A> means that the list is typed to either the A class, or a superclass of A.","(""A"", ""A is related to its superclass because the text states 'super A' which implies a superclass relationship"", ""superclass of A""); (""list"", ""The list is related to the A class because the text states 'the list is typed to either the A class' which implies a typing relationship"", ""A"")"
"When you know that the list is typed to either A, or a superclass of A, it is safe to insert instances of A or subclasses of A (e.g.",NULL
"All of the elements inserted here are either A instances, or instances of A's superclass.",NULL
"Since both B and C extend A, if A had a superclass, B and C would also be instances of that superclass.","(""A"", ""A is the superclass that B extends"", ""B""); (""A"", ""A is the superclass that C extends"", ""C"")"
"You can now call insertElements() with either a List<A>, or a List typed to a superclass of A.","(""InsertElements"", ""InsertElements is a method that can be called with a List<A> as an argument"", ""List<A>"")"
"The insertElements() method cannot read from the list though, except if it casts the read objects to Object.","(""InsertElements"", ""The insertElements method is related to the List because it cannot read from the list."", ""List""); (""InsertElements"", ""The insertElements method is related to the Object because it casts the read objects to Object."", ""Object"")"
"The elements already present in the list when insertElements() is called could be of any type that is either an A or superclass of A, but it is not possible to know exactly which class it is.",NULL
"However, since any class eventually subclass Object you can read objects from the list if you cast them to Object.","(""Class"", ""A class is related to Object because any class eventually subclasses Object."", ""Object""); (""Class"", ""A class is related to List because you can read objects from the list if you cast them to the class type, in this case Object, which is a class."", ""List"")"
Here are a few examples of calls to the getInstance() method:,NULL
As you can see the return type changes depending on what class object you pass in as parameter to the method.,"(""Method"", ""The method is related to the class because it is called on a class object."", ""Class""); (""Object"", ""The object is related to the method because it is passed as a parameter to the method."", ""Method"")"
It is possible to use your own collection type classes with the new for-loop.,NULL
And here is the corresponding implementation skeleton of the MyIterator class:,NULL
Generics add a way to specify concrete types to general purpose classes and methods that operated on Object before.,"(""Generics"", ""Generics is related to classes because it adds a way to specify concrete types to general purpose classes"", ""classes""); (""Generics"", ""Generics is related to methods because it adds a way to specify concrete types to general purpose methods"", ""methods"")"
"Note: Java generics can be used with other classes than the collection classes, but it is easiest to show the basics of Java generics using collections.","(""Java"", ""Java is related to Generics because Java generics are a feature of the Java programming language"", ""Generics""); (""Java"", ""Java is related to Collections because Java collections are a part of the Java programming language and are often used with Java generics"", ""Collections"")"
"When you just write a diamond operator as generic type, the Java compiler will assume that the class instantiated is to have the same type as the variable it is assigned to.","(""Java Compiler"", ""The Java compiler is related to the diamond operator because it assumes the class instantiated is to have the same type as the variable it is assigned to when a diamond operator is used as a generic type."", ""Diamond Operator""); (""Java Compiler"", ""The Java compiler is related to the generic type because it makes assumptions about the type of class being instantiated when a generic type is used with a diamond operator."", ""Generic Type""); (""Java Compiler"", ""The Java compiler is related to the variable because it assigns the instantiated class to the variable and assumes the class type is the same as the variable type."", ""Variable""); (""Diamond Operator"", ""The diamond operator is related to the generic type because it is used to specify the generic type in the class instantiation."", ""Generic Type""); (""Diamond Operator"", ""The diamond operator is related to the variable because the type of the variable is used to determine the type of the class being instantiated when the diamond operator is used."", ""Variable"")"
This for-loop is shorter than original while-loop where you would iterate the collections Iterator and call Iterator.next() to obtain the next instance.,"(""Iterator"", ""Iterator and next are related because next is a method called on the Iterator class to obtain the next instance."", ""next"")"
It is of course possible to use Generics for other classes than the Java collections.,"(""Generics"", ""Generics is used for Java collections"", ""Java collections""); (""Java"", ""Java collections is a part of Java"", ""Java collections"")"
"Using Java generics in your own classes is described in more detail in the tutorials about generic classes, generic methods and using class objects as type literals.","(""Java"", ""Java is related to Generic Classes because Java is the programming language in which generic classes are used"", ""Generic Classes""); (""Java"", ""Java is related to Generic Methods because Java is the programming language in which generic methods are used"", ""Generic Methods""); (""Generic Classes"", ""Generic Classes are related to Tutorials because tutorials provide more information about generic classes"", ""Tutorials""); (""Generic Methods"", ""Generic Methods are related to Tutorials because tutorials provide more information about generic methods"", ""Tutorials"")"
The java.text.DateFormat class is used to format dates as strings according to a specific Locale.,"(""DateFormat"", ""The DateFormat class is used to format dates according to a specific Locale, indicating a relationship between the two."", ""Locale""); (""java.text"", ""The DateFormat class is part of the java.text package, indicating a containment relationship."", ""DateFormat"")"
You create a DateFormat using the getDateInstance() and getTimeInstance() method of the DateFormat class.,"(""DateFormat"", ""The DateFormat class has a getDateInstance method, indicating a relationship between the two entities."", ""getDateInstance""); (""DateFormat"", ""The DateFormat class has a getTimeInstance method, indicating a relationship between the two entities."", ""getTimeInstance""); (""getDateInstance"", ""The getDateInstance method is used to create a DateFormat, indicating a relationship between the two entities."", ""DateFormat"")"
The date format parameter can be chosen among the following constants in the DateFormat class:,NULL
"In order to format only time and not the date itself, you need a time instance of the DateFormat class.","(""DateFormat"", ""The DateFormat class is related to the time class because an instance of the time class is needed to format time using the DateFormat class."", ""time"")"
The java.text.DecimalFormat class is used to format numbers using a formatting pattern you specify yourself.,"(""Java.Text.Decimalformat"", ""The java.text.DecimalFormat class is used to format numbers using a formatting pattern you specify yourself, indicating that Java.Text.Decimalformat and DecimalFormat are related as they refer to the same class."", ""DecimalFormat"")"
This text explains how to use the DecimalFormat class to format different types of numbers.,NULL
You can change this pattern later using the applyPattern() or applyLocalizedPattern() method.,NULL
The applyPattern() method simply applies a new pattern to the DecimalFormat instance as if it were created with that pattern.,NULL
The applyLocalizedPattern() does the same as applyPattern() except it interpretes the characters in the pattern according to the Locale the DecimalFormat was created with.,"(""Applylocalizedpattern"", ""Applylocalizedpattern and Applypattern are related as they share similar functionality, with the key difference being Applylocalizedpattern interprets characters according to the Locale"", ""Applypattern""); (""Applylocalizedpattern"", ""Applylocalizedpattern is a method that is used in conjunction with the DecimalFormat class, as it is used to format numbers according to the Locale the DecimalFormat was created with"", ""Decimalformat"")"
You format a number using the format() method of the DecimalFormat instance.,"(""DecimalFormat"", ""The DecimalFormat class has a method called format(), indicating a relationship between the class and the method."", ""format()""); (""format()"", ""The format() method is used to format a number, indicating a relationship between the method and the number class."", ""Number"")"
"For a full explanation of what these methods do, see the JavaDoc for the DecimalFormatSymbols class.",NULL
The DecimalFormat class has a method called setGroupingSize() which sets how many digits of the integer part to group.,NULL
"The java.text.BreakIterator class is used to find character, word and sentence boundaries across different languages.","(""Java.Text.BreakIterator"", ""The Java.Text.BreakIterator class is part of the Java.Text package, indicating a relationship between the class and the package."", ""Java.Text""); (""Java.Text.BreakIterator"", ""The Java.Text.BreakIterator class is used to find character boundaries, indicating a relationship between the class and characters."", ""Character""); (""Java.Text.BreakIterator"", ""The Java.Text.BreakIterator class is used to find word boundaries, indicating a relationship between the class and words."", ""Word"")"
You create an instance that can recognize one of the above boundaries using the corresponding factory method in the BreakIterator class.,NULL
"A character instance of the BreakIterator class finds character boundaries for user characters, not unicode characters.",NULL
"This example creates a BreakIterator targeted at the British language, and sets the text to find character breaks in using the setText() method.","(""BreakIterator"", ""The BreakIterator class uses the setText() method to set the text for finding character breaks."", ""setText()"")"
"Again, here the first() and next() methods return the unicode index of the found word boundary.",NULL
"Notice how the isWord() method uses the Character.isLetterOrDigit() method to determine if a character is a letter or digit, or something else (like semicolon, quote etc.).","(""Isword"", ""The Isword method uses the Isletterordigit method to determine if a character is a letter or digit."", ""Isletterordigit""); (""Isword"", ""The Isword method is related to the Character class because it uses the Isletterordigit method from this class."", ""Character"")"
"The Character.isLetterOrDigit() checks according to the unicode characters if a character is a letter or digit - and thus not just in the english language, but also in other languages.",NULL
Java has some methods in the java.lang.Character class that are useful in internationalization of Java applications.,"(""java.lang.Character"", ""The java.lang.Character class has some methods that are useful in internationalization of Java applications."", ""methods""); (""java.lang"", ""The java.lang.Character class is part of the java.lang package."", ""java.lang.Character""); (""Java"", ""Java has some packages like java.lang that are useful in internationalization of Java applications."", ""java.lang"")"
"To safely check if a character is a letter, number or space character you need to use the methods in java.lang.Character to do so.","(""Character"", ""Character is a class within the java.lang package"", ""java.lang"")"
The Character class also has a getType() method which returns the type of a certain character.,NULL
The returned type is an int which matches a set of predefined constants in the Character class.,NULL
Look in the JavaDoc for the Character class for more constants.,NULL
The Character class also has a method that enables you to determine if the value of a given int defines a character in unicode.,"(""Character"", ""The Character class has a method that uses an int to determine if its value defines a character"", ""int"")"
"Thus, simply using the String.compareTo() method may not work for all languages.",NULL
"To sort a collection of strings according to the rules of a certain Locale, you use a java.text.Collator instance created for that specific Locale.","(""Collator"", ""A Collator instance is created for a specific Locale, indicating a relationship between the two."", ""Locale""); (""Java"", ""The Collator class is part of the java.text package, which is a part of the Java package, indicating a relationship between the two."", ""Collator"")"
To compare two strings using the Collator instance you call the compare() method.,NULL
The compare() method returns an int with the same meaning as the String.compareTo() method:,NULL
A 0 means that the two strings have the same order - e.g.,NULL
There are more rules you can use with the RuleBasedCollator class.,NULL
You normalize a string using the static normalize() method of the java.text.Normalizer class.,NULL
The first parameter to the normalize() method is the text to normalize.,NULL
You can use the String class to convert a byte array to a String instance.,NULL
You can convert the text of a String to another format using the getBytes() method.,NULL
The Reader and Writer classes are stream oriented classes that enable a Java application to read and write streams of characters.,"(""Reader"", ""The Reader class is part of the Java application, indicating a relationship between the two entities."", ""Java""); (""Writer"", ""The Writer class is part of the Java application, indicating a relationship between the two entities."", ""Java"")"
This is done using the second constructor paramter in the InputStreamReader class.,NULL
"Input is everything that your application receives from its users, either directly through the user interface, sent to it via service calls (e.g.","(""Application"", ""The application receives input from its users, indicating a relationship between the two entities."", ""User""); (""Application"", ""The application receives input directly through the user interface, indicating a relationship between the application and the interface."", ""Interface""); (""Application"", ""The application receives input sent to it via service calls, indicating a relationship between the application and the service."", ""Service""); (""User"", ""The user interacts with the application through the user interface, indicating a relationship between the user and the interface."", ""Interface"")"
"The internationalization layer should convert from whatever character encoding the input comes in (ascii, UTF-8 etc.)","(""Internationalization Layer"", ""The internationalization layer should convert from whatever character encoding the input comes in, indicating a relationship between the internationalization layer and character encoding"", ""Character Encoding""); (""Internationalization Layer"", ""The internationalization layer should convert from whatever character encoding the input comes in, indicating a relationship between the internationalization layer and the input"", ""Input"")"
Java has a set of built-in classes that can help you handle internationalization of your application.,"(""Java"", ""Java has a set of built-in classes"", ""Classes""); (""Classes"", ""classes can help you handle internationalization of your application"", ""Application"")"
Each of these classes are covered in more detail in later texts in this trail.,"(""Classes"", ""Classes are covered in more detail in later Texts"", ""Texts""); (""Texts"", ""Texts are part of this Trail"", ""Trail"")"
In Java you can convert between time zones using the java.util.Calendar class.,"(""java.util.Calendar"", ""java.util.Calendar is a part of the java.util package"", ""java.util""); (""Java"", ""Java is a programming language that utilizes the java.util.Calendar class"", ""java.util.Calendar"")"
"Please not, that the Calendar.getTimeInMillis() always returns the time in UTC, regardless of the time zone set on the Calendar instance.","(""Calendar"", ""The Calendar class has a method called getTimeInMillis, indicating a relationship between the class and the method."", ""getTimeInMillis""); (""Calendar"", ""The text mentions a Calendar instance, which is related to the Calendar class, indicating that the instance is an example or a part of the class."", ""Calendar instance"")"
"As you saw in the example, you get the time zone from the java.util.TimeZone class.",NULL
You can obtain a list of the available time zone ID's using the TimeZone.getAvailableIDs() .,NULL
"This examples obtains all the available time zone ID's, and then prints them to System.out.","(""System"", ""System is related to System.out because System.out is an object of the System class"", ""System.out""); (""available"", ""available and prints are related because they are both methods used in the same context to obtain and print time zone IDs"", ""prints""); (""System"", ""System is related to available because the available method is used to obtain time zone IDs, which are then printed using System.out"", ""available""); (""System"", ""System is related to prints because the prints method is used to print the time zone IDs to System.out"", ""prints""); (""System.out"", ""System.out is related to available because the available method provides the time zone IDs that are printed to System.out"", ""available"")"
"I have described the java.util.TimeZone class in more detail in my Java Date Time tutorial, in the TimeZone class.","(""java.util.TimeZone"", ""The java.util.TimeZone class is described in more detail in the Java Date Time tutorial, indicating a relationship between the two."", ""Java Date Time""); (""java.util.TimeZone"", ""The java.util.TimeZone class and the TimeZone class are related as they are referred to interchangeably in the text, suggesting they are the same entity."", ""TimeZone"")"
"This Java internationalization tutorial is ""work in progress"", so if you spot a a missing description of a feature etc., please be patient.",NULL
"The Java Locale class, java.util.Locale, is used to represent a ""geographical, political or cultural"" region to localize a given text, number, date or operation to.","(""Java Locale"", ""Java Locale is another name for java.util.Locale, indicating they are the same entity"", ""java.util.Locale""); (""java.util.Locale"", ""java.util.Locale is a class within the java.util package, indicating a containment relationship"", ""java.util"")"
The Locale class cannot do any internationalization or localization by itself.,"(""Locale"", ""The Locale class is related to internationalization because it is mentioned that it cannot do any internationalization by itself."", ""internationalization"")"
"The Locale class complies with the BCP 47 (IETF BCP 47, ""Tags for Identifying Languages"") standard.",NULL
"The Locale class also has support for the LDML (UTS#35 ""Unicode Locale Data Markup Language"") standard, which is a BCP 47-compatible extension for locale data exchange.","(""Locale"", ""The Locale class has support for the LDML standard"", ""LDML""); (""Locale"", ""The Locale class has support for UTS#35, which is the Unicode Locale Data Markup Language standard"", ""UTS#35""); (""Locale"", ""The Locale class has support for BCP 47-compatible extension for locale data exchange"", ""BCP 47""); (""LDML"", ""LDML is defined by UTS#35, which is the Unicode Locale Data Markup Language standard"", ""UTS#35""); (""LDML"", ""LDML is a BCP 47-compatible extension for locale data exchange"", ""BCP 47"")"
"Language codes are case insensitive, but the Locale class always use lowercase versions of the language codes.",NULL
"Script codes are case insensitive, but the Locale class always uses a version with the first letter in uppercase, and the rest in lowercase.",NULL
"The country code is a 2 character code following the ISO 3166 standard, or a UN M.49 numeric area code.","(""COUNTRY CODE"", ""The country code follows the ISO 3166 standard"", ""ISO 3166"")"
"The country code is case insensitive, but the Locale class uses an uppercase version of the country code.",NULL
See the JavaDoc for the Locale class for more detail about variant.,NULL
"For instance, what calendar to use when displaying dates (Gregorian, Arab, Japanese etc.).","(""Calendar"", ""The Calendar entity is related to the Dates entity because calendars are used to display dates."", ""Dates""); (""Calendar"", ""The Calendar entity is related to the Gregorian entity because Gregorian is a type of calendar."", ""Gregorian""); (""Calendar"", ""The Calendar entity is related to the Arab entity because Arab is a type of calendar."", ""Arab""); (""Calendar"", ""The Calendar entity is related to the Japanese entity because Japanese is a type of calendar."", ""Japanese""); (""Dates"", ""The Dates entity is related to the Gregorian entity because dates can be displayed in the Gregorian calendar."", ""Gregorian""); (""Dates"", ""The Dates entity is related to the Arab entity because dates can be displayed in the Arab calendar."", ""Arab""); (""Dates"", ""The Dates entity is related to the Japanese entity because dates can be displayed in the Japanese calendar."", ""Japanese""); (""Gregorian"", ""The Gregorian entity is related to the Arab entity because both are types of calendars."", ""Arab""); (""Gregorian"", ""The Gregorian entity is related to the Japanese entity because both are types of calendars."", ""Japanese"")"
See the JavaDoc for the Locale class for more detail about extensions.,NULL
Creating a java.util.Locale instance can be done in four different ways:,"(""Java.Util.Locale"", ""Java.Util.Locale is a part of the Java.Util package"", ""Java.Util""); (""Creating"", ""The Creating method is used to create an instance of Java.Util.Locale"", ""Java.Util.Locale"")"
The java.util.Locale class contains a set of constants that represent the most commonly used languages in the world.,NULL
You can also create a java.util.Locale instance by using one of its constructors.,"(""Java.Util.Locale"", ""Java.Util.Locale is related to Constructors because it can be created by using one of its constructors."", ""Constructors""); (""Java.Util"", ""Java.Util is related to Java.Util.Locale because Java.Util.Locale is a part of the Java.Util package."", ""Java.Util.Locale"")"
From Java 7 you can use the Locale.Builder class to build a Locale instance.,"(""Locale.Builder"", ""Locale.Builder is used to build a Locale instance, indicating a relationship between the two classes"", ""Locale"")"
The factory method Locale.forLanguageTag() can also be used to create a Locale instance.,"(""Locale"", ""Locale.forLanguageTag() is a method of the Locale class"", ""Locale.forLanguageTag()"")"
The ResourceBundle class is covered in more detail in the text about the ResourceBundle class.,NULL
"Finally, I may want to show how a given application works to a person who doesn't speak the language that my application is localized to (e.g.",NULL
"English or Danish), so I may want to temporarily change language to e.g.",NULL
The java.text.NumberFormat class is used to format numbers according to a specific Locale.,NULL
Formatting a number using a NumberFormatter is done using the format() method.,NULL
"Notice that numbers like 100.00 might be formatted without the decimals, as 100.",NULL
Formatting a number as a currency is still done using the format() method.,NULL
"You can also set the Currency object to use for formatting a number as a currency, using the setCurrency() method on the NumberFormat class.","(""NumberFormat"", ""The setCurrency() method is related to the NumberFormat class because it is used on the NumberFormat class to set the currency object."", ""setCurrency()""); (""setCurrency()"", ""The setCurrency() method is related to the Currency class because it is used to set the Currency object for formatting a number as a currency."", ""Currency"")"
Formatting a number as a percentage is also done using the format() method.,NULL
You can set the rounding mode using the setRoundingMode() method of the NumberFormat class.,NULL
"Had the NumberFormat instance been created using a UK Locale instance, the number had been parsed to 10000, because the comma would have been interpreted as a integer separator (e.g.",NULL
"The Java ResourceBundle class, java.util.ResourceBundle, is used to store texts and components that are locale sensitive.",NULL
"A user's locale is represented by the Java Locale class, by the way.",NULL
This text takes a closer look at the ResourceBundle class and its subclasses.,NULL
The PropertyResourceBundle class stores localized texts in standard Java property files.,NULL
Then you pass that Locale instance to the ResourceBundle.getBundle() method along with the name of the resource bundle to load.,"(""Locale"", ""Locale instance is passed to the ResourceBundle.getBundle() method"", ""ResourceBundle"")"
Finally you can access the localized values in the ResourceBundle via its different getString() and getObject() etc.,"(""ResourceBundle"", ""The ResourceBundle class has a method called getString(), indicating a clear relationship between the two."", ""getString()"")"
"You are never actually creating a ResourceBundle instance, but an instance of one of its two subclasses.","(""ResourceBundle"", ""Subclass1 is a subclass of ResourceBundle"", ""Subclass1"")"
"First the ResourceBundle class will look for a ListResourceBundle, and then for a PropertyResourceBundle.","(""ResourceBundle"", ""ResourceBundle is related to ListResourceBundle because it will look for a ListResourceBundle"", ""ListResourceBundle"")"
"It does so by matching the name of the requested resource bundle (first parameter in the getBundle() method) against the class names of a ListResourceBundle first, and if none found, against a property file resource bundle.","(""Getbundle"", ""The Getbundle method is related to Listresourcebundle because it matches the name of the requested resource bundle against the class names of a ListResourceBundle first."", ""Listresourcebundle"")"
For this example to work you should put a standard Java property file named MyBundle.properties in a Java package named i18n.,NULL
"Make sure this property file is available on your class path when you run the above code, meaning the property file should be located among the classes of your application, and in the i18n package.","(""Class Path"", ""The property file should be located among the classes of the application on the class path."", ""Property File""); (""I18n"", ""The property file should be located in the i18n package."", ""Property File"")"
The name of a resource bundle is like a class name.,NULL
"Thus, i18n.MyBundle means a property file named MyBundle.properties in the package (directory) i18n.","(""I18N"", ""I18N is the package where MyBundle is located"", ""MyBundle""); (""I18N"", ""I18N is the package where MyBundle.properties is located"", ""MyBundle.properties"")"
"In case no property file is available for the language (Locale) passed to the ResourceBundle.getBundle() method, and the system has no default Locale set (e.g.","(""ResourceBundle"", ""The ResourceBundle class has a method called getBundle, indicating a relationship between the two."", ""getBundle""); (""ResourceBundle"", ""The ResourceBundle class is related to the Locale class, as it uses Locale to get a bundle, indicating a dependency between the two."", ""Locale"")"
You can also use a set of classes to contain your resources.,"(""CLASSES"", ""The classes are related to the resources because they are used to contain them."", ""RESOURCES"")"
"Like with the property files, you create a set of classes with a bundle base name and language suffixes.","(""Classes"", ""Classes are related to Property because they are both mentioned in the context of being created with a bundle base name and language suffixes."", ""Property""); (""Classes"", ""Classes are related to Bundle because they are created with a bundle base name."", ""Bundle"")"
Here is an example implementation of the default bundle class file:,NULL
"You can also obtain a set of all keys contained in the ResourceBundle using the keySet() method, like this:",NULL
The java.text.SimpleDateFormat class is used to both parse and format dates according to a formatting pattern you specify yourself.,NULL
This text explains how to use the SimpleDateFormat class to format dates.,NULL
Once you have created a SimpleDateFormat instance you can format dates using its format() method.,NULL
The Date instance passed to the format() method is a java.util.Date instance.,"(""Date"", ""The Date class is related to the format() method because the Date instance is passed to the format() method."", ""format()"")"
"The Java SimpleDateFormat class is also capable of formatting a Date object into a StringBuffer, instead of returning an individual String with the date formatted.","(""SimpleDateFormat"", ""The SimpleDateFormat class is capable of formatting a Date object"", ""Date""); (""SimpleDateFormat"", ""The SimpleDateFormat class is capable of formatting a Date object into a String"", ""String""); (""SimpleDateFormat"", ""The SimpleDateFormat class is capable of formatting a Date object into a StringBuffer"", ""StringBuffer""); (""Date"", ""A Date object can be formatted into a String"", ""String"")"
"The SimpleDateFormat class does this via a version of the format() method that takes the Date, StringBuffer and a FieldPosition instance as parameters.","(""SimpleDateFormat"", ""The SimpleDateFormat class contains the format() method, indicating a relationship between the two."", ""format()""); (""format()"", ""The format() method takes a Date as a parameter, indicating that it operates on or uses a Date object."", ""Date""); (""format()"", ""The format() method takes a StringBuffer as a parameter, indicating that it uses or modifies a StringBuffer object."", ""StringBuffer"")"
It seems the format() method appends the formatted String to the end of the StringBuffer no matter what the int value passed to the FieldPosition constructor is.,"(""Format"", ""The format() method is related to the String class because it is used to format a String."", ""String""); (""Format"", ""The format() method is related to the StringBuffer class because it appends the formatted String to the end of the StringBuffer."", ""StringBuffer""); (""Format"", ""The format() method is related to the FieldPosition class because the FieldPosition constructor is used in conjunction with the format() method."", ""FieldPosition""); (""String"", ""The String class is related to the StringBuffer class because a String is appended to the StringBuffer."", ""StringBuffer""); (""String"", ""The String class is related to the FieldPosition class because the FieldPosition is used when formatting a String."", ""FieldPosition"")"
You can parse a String into a java.util.Date instance using the parse() method of the SimpleDateFormat instance.,"(""String"", ""The String is parsed into a Date using the SimpleDateFormat, indicating a relationship between the two."", ""SimpleDateFormat""); (""SimpleDateFormat"", ""The parse() method is a part of the SimpleDateFormat class, indicating a relationship between the method and the class."", ""parse()""); (""String"", ""The String is parsed into a java.util.Date, indicating a relationship between the two."", ""java.util.Date""); (""SimpleDateFormat"", ""The SimpleDateFormat is part of the java.util package, indicating a relationship between the class and the package."", ""java.util""); (""java.util.Date"", ""The java.util.Date is part of the java.util package, indicating a relationship between the class and the package."", ""java.util""); (""parse()"", ""The parse() method takes a String as input, indicating a relationship between the method and the class."", ""String"")"
"For instance, you can write either yy for a 2-character version of the year (e.g.",NULL
"12), or you can write yyyy for a 4-character version of the year (e.g.",NULL
"For more information about the patterns accepted, see the JavaDoc for the SimpleDateFormat class.",NULL
"The indices in this array must start from one, to be indexable by the Calendar.SUNDAY, Calendar.MONDAY etc.","(""Calendar"", ""Calendar.SUNDAY is a method of the Calendar class"", ""Calendar.SUNDAY"")"
See the JavaDoc for the java.text.DateFormatSymbols class for more details about these methods and symbols.,"(""JavaDoc"", ""The JavaDoc is related to the DateFormatSymbols class because it provides more details about the class and its methods."", ""DateFormatSymbols""); (""java.text"", ""The java.text package is related to the DateFormatSymbols class because it is the package where the class is located."", ""DateFormatSymbols"")"
You can set the time zone of a SimpleDateFormat using its setTimeZone() method.,NULL
The setTimeZone() method takes an Java TimeZone instance (java.util.TimeZone) as parameter.,"(""Settimezone"", ""The setTimeZone() method takes a Java TimeZone instance as parameter, indicating that setTimeZone() is related to Java Util Timezone."", ""Java Util Timezone""); (""Java Util"", ""Java Util Timezone is a part of the Java Util package, indicating that Java Util and Java Util Timezone are related."", ""Java Util Timezone"")"
"Of these ISO time zone formats, the Java SimpleDateFormat class only supports the second format (+hhmm), or the format ending with the Z character.",NULL
"This is to make the SimpleDateFormat class treat them as literal characters to be inserted, instead of trying to interpret them as representing some part of the date.",NULL
"The Java BufferedInputStream class, java.io.BufferedInputStream, provides transparent reading of chunks of bytes and buffering for a Java InputStream, including any subclasses of InputStream.","(""BufferedInputStream"", ""BufferedInputStream is a subclass of InputStream, providing buffering for any subclasses of InputStream"", ""InputStream""); (""BufferedInputStream"", ""BufferedInputStream is part of the java.io package"", ""java.io"")"
"The BufferedInputStream creates a byte array internally, and attempts to fill the array by calling the InputStream.read(byte[]) methods on the underlying InputStream.","(""BufferedInputStream"", ""The BufferedInputStream attempts to fill the array by calling the InputStream.read(byte[]) methods on the underlying InputStream, indicating a relationship between the two classes."", ""InputStream""); (""BufferedInputStream"", ""The BufferedInputStream calls the read method on the underlying InputStream, indicating a relationship between the class and the method."", ""read"")"
An interesting aspect to note about the BufferedInputStream is that is supports the mark() and reset() methods inherited from the InputStream.,"(""BufferedInputStream"", ""The BufferedInputStream is related to the mark() method because it supports this method inherited from the InputStream."", ""mark()""); (""BufferedInputStream"", ""The BufferedInputStream is related to the reset() method because it supports this method inherited from the InputStream."", ""reset()""); (""BufferedInputStream"", ""The BufferedInputStream is related to the InputStream because it inherits methods from the InputStream."", ""InputStream""); (""mark()"", ""The mark() method is related to the InputStream because it is inherited from the InputStream."", ""InputStream"")"
"In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not, but the BufferedInputStream supports them.","(""MarkSupported"", ""The MarkSupported method is related to BufferedInputStream because it can be used to check if mark() and reset() are supported on a given BufferedInputStream."", ""BufferedInputStream""); (""Mark"", ""The Mark method is related to BufferedInputStream because it is supported by BufferedInputStream."", ""BufferedInputStream""); (""Reset"", ""The Reset method is related to BufferedInputStream because it is supported by BufferedInputStream."", ""BufferedInputStream""); (""Mark"", ""The Mark method is related to InputStream because it can be called on an InputStream."", ""InputStream""); (""Reset"", ""The Reset method is related to InputStream because it can be called on an InputStream."", ""InputStream""); (""MarkSupported"", ""The MarkSupported method is related to InputStream because it can be used to check if mark() and reset() are supported on a given InputStream."", ""InputStream"")"
You close a BufferedInputStream by calling the close() method inherited from InputStream.,"(""BufferedInputStream"", ""BufferedInputStream is related to close() because close() is a method that can be called on a BufferedInputStream object."", ""close()""); (""close()"", ""close() is related to InputStream because close() is a method inherited from InputStream."", ""InputStream"")"
Notice how the while loop continues until a -1 value is read from the BufferedInputStream read() method.,NULL
"After that, the while loop exits, and the BufferedInputStream close() method is called.",NULL
"If an exception is thrown while reading data from the BufferedInputStream, the close() method is never called.","(""BufferedInputStream"", ""The close() method is related to the BufferedInputStream because it is called on the BufferedInputStream object when it is no longer needed, but in this case, it is never called due to an exception being thrown."", ""close()""); (""exception"", ""The exception is related to the BufferedInputStream because it is thrown while reading data from the BufferedInputStream, which prevents the close() method from being called."", ""BufferedInputStream"")"
Proper exception handling for use of Java IO classes is also explained in my tutorial on Java IO Exception Handling.,NULL
"The setSource() method actually returns a reference to the ReusableBufferedInputStream, so you can actually create a ReusableBufferedInputStream and set the source in a single instruction:",NULL
"Note, that this implementation only overrides the read() method of the InputStream class that it extends.",NULL
"The Java BufferedOutputStream class, java.io.BufferedOutputStream, is used to capture bytes written to the BufferedOutputStream in a buffer, and write the whole buffer in one batch to an underlying Java OutputStream for increased performance.","(""BufferedOutputStream"", ""The BufferedOutputStream class is related to the OutputStream class because it writes the whole buffer in one batch to an underlying Java OutputStream for increased performance."", ""OutputStream""); (""BufferedOutputStream"", ""The BufferedOutputStream class is related to the java.io.BufferedOutputStream package because it is a part of this package, as indicated by its full name java.io.BufferedOutputStream."", ""java.io.BufferedOutputStream"")"
The only difference is that you may need to call flush() if you need to be absolutely sure that the data written until now is flushed out of the buffer and onto the network or disk.,NULL
To write data to a Java BufferedOutputStream you can use its write() method.,NULL
The write() method takes an int which contains the byte value of the byte to write.,NULL
Here is an example of writing data to a Java BufferedOutputStream using its write() method:,NULL
"Since the Java BufferedOutputStream is a subclass of OutputStream, you can write arrays of bytes to the BufferedOutputStream too, instead of just a single byte at a time.",NULL
If you want to make sure that all written data is written to disk without having to close the BufferedOutputStream you can call its flush() method.,NULL
"Calling flush() will make sure that all data which has been written to the BufferedOutputStream so far, is fully written to the underlying OutputStream too, plus flush() will also have been called on the underlying OutputStream.","(""Flush"", ""The Flush method is called on the BufferedOutputStream to ensure all data is written to the underlying OutputStream."", ""BufferedOutputStream""); (""BufferedOutputStream"", ""The BufferedOutputStream writes data to the underlying OutputStream."", ""OutputStream"")"
Here is an example of calling the Java BufferedOutputStream flush() method:,"(""BufferedOutputStream"", ""The BufferedOutputStream class has a flush() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""flush()""); (""Java"", ""The Java package contains the BufferedOutputStream class, indicating a relationship between the package and the class as the class is part of the package."", ""BufferedOutputStream"")"
"The concrete implementations of hasMoreData() and getMoreData() are left out, but they are not really super important to understand the principle of this example.",NULL
"What matters is, that once the while loop ends, and you are done writing data to the BufferedOutputStream, its close() method is called, which closes the BufferedOutputStream .","(""BufferedOutputStream"", ""The close() method is a part of the BufferedOutputStream class, indicating a relationship between the two entities as the method is used to close the BufferedOutputStream."", ""close()"")"
"In case the write() method throws an exception, the close() method will never get called.",NULL
"Once the try block is exited, the close() method of the BufferedOutputStream is called automatically, because the BufferedOutputStream was declared inside the parentheses of the try block.","(""BufferedOutputStream"", ""The close() method is a part of the BufferedOutputStream class, indicating a relationship between the two."", ""close()""); (""try"", ""The BufferedOutputStream was declared inside the parentheses of the try block, indicating a relationship between the try block and the BufferedOutputStream."", ""BufferedOutputStream"")"
"Even if an exception is thrown from inside the try block, the close() method is still called before the exception is propagated up the call stack.","(""Try"", ""The close() method is called from within the try block, indicating a relationship between the try block and the close() method."", ""Close""); (""Exception"", ""An exception is thrown from inside the try block, indicating a relationship between the exception and the try block."", ""Try"")"
"The Java BufferedReader class, java.io.BufferedReader, provides buffering for your Java Reader instances.","(""BufferedReader"", ""BufferedReader provides buffering for Reader instances, indicating a clear relationship between the two classes"", ""Reader""); (""BufferedReader"", ""BufferedReader is part of the java.io package, indicating a clear relationship between the class and the package"", ""java.io"")"
"The Java BufferedReader class is a subclass of the Java Reader class, so you can use a BufferedReader anywhere a Reader is required.","(""BufferedReader"", ""BufferedReader is a subclass of Reader, indicating an inheritance relationship between the two classes"", ""Reader"")"
Each character returned from read() is thus returned from this internal array.,NULL
The readLine() method will return a textual line (all text until at line break is found) read from the BufferedReader.,NULL
"If there is no more data to read from the underlying Reader, then the BufferedReader's readLine() method will return null .","(""BufferedReader"", ""The BufferedReader class has a readLine() method, indicating a relationship between the two entities as the method is a part of the class."", ""readLine()"")"
The read() method of a Java BufferedReader returns an int which contains the char value of the next character read.,"(""BufferedReader"", ""The read() method is a part of the BufferedReader class, indicating a clear relationship between the two entities."", ""read()""); (""Java"", ""The BufferedReader class is part of the Java package, indicating a clear relationship between the two entities."", ""BufferedReader"")"
"If the read() method returns -1, there is no more data to read in the BufferedReader, and it can be closed.",NULL
"If not, it processes that char and continues reading until -1 is returned from the BufferedReader read() method.",NULL
"As mentioned earlier, the BufferedReader will actually read an array of characters from the underlying Reader and return these characters one by one, rather than forwarding every read() call to the underlying Reader.","(""BufferedReader"", ""BufferedReader is related to Reader because it reads an array of characters from the underlying Reader"", ""Reader""); (""BufferedReader"", ""BufferedReader is related to read() because it uses this method to return characters one by one"", ""read()"")"
"The Java BufferedReader class also has a read() method that takes a char array as parameter, as well as a start offset and length.",NULL
The char array is where the read() method will read the characters into.,NULL
The offset parameter is where in the char array the read() method should start reading into.,"(""Read"", ""The read method uses the offset parameter to determine where to start reading in the char array"", ""Offset""); (""Read"", ""The read method reads into the char array"", ""Char Array"")"
The length parameter is how many characters the read() method should read into the char array from the offset and forward.,"(""Read"", ""The read() method is related to the length parameter because the length parameter determines how many characters the read() method should read."", ""Length""); (""Read"", ""The read() method is related to the offset parameter because the offset parameter determines the starting position from which the read() method should read."", ""Offset""); (""Read"", ""The read() method is related to the char array because the read() method reads characters into the char array."", ""Char Array""); (""Length"", ""The length parameter is related to the char array because the length parameter determines how many characters should be read into the char array."", ""Char Array"")"
The Java BufferedReader has a special read method named readLine() which reads a full line of text from the BufferedReader's internal buffer.,"(""BufferedReader"", ""The BufferedReader class has a special read method named readLine(), indicating a clear relationship between the two entities as the method is a part of the class."", ""readLine()"")"
"If there are no more lines to read from the BufferedReader, the readLine() method returns null.",NULL
The Java BufferedReader class has a method named skip() which can be used to skip over a number of characters in the input that you do not want to read.,"(""BufferedReader"", ""The BufferedReader class has a method named skip(), indicating a clear relationship between the two as the method is part of the class."", ""skip()""); (""Java"", ""The Java BufferedReader class indicates that the BufferedReader class is part of the Java package, showing a relationship between the two."", ""BufferedReader"")"
You pass the number of characters to skip as parameter to the skip() method.,NULL
Notice how there is no longer any explicit close() method call.,NULL
"The setSource() method actually returns a reference to the ReusableBufferedReader, so you can actually create a ReusableBufferedReader and set the source in a single instruction:",NULL
"Note, that this implementation only overrides the read() and read(char[] dest, int offset, int length) methods of the Reader class that it extends.","(""Reader"", ""The read() method is part of the Reader class, indicating a clear relationship between the two entities."", ""read()""); (""Reader"", ""The read(char[] dest, int offset, int length) method is part of the Reader class, indicating a clear relationship between the two entities."", ""read(char[] dest, int offset, int length)"")"
"The Java BufferedWriter is a Java Writer subclass, so it can be used anywhere a Writer is required.",NULL
The BufferedWriter adds one extra method though: The newLine() method which can write a new-line character to the underlying Writer.,"(""BufferedWriter"", ""The BufferedWriter class has a method called newLine(), indicating a relationship between the two."", ""newLine()"")"
"In addition, you may need to call flush() if you need to be absolutely sure that the characters written until now is flushed out of the buffer and onto the network or disk.","(""Flush"", ""The Flush method is related to the Buffer because it is used to ensure that the characters written until now are flushed out of the buffer and onto the network or disk."", ""Buffer""); (""Buffer"", ""The Buffer is related to the Network because the characters flushed out of the buffer are written onto the network."", ""Network""); (""Buffer"", ""The Buffer is related to the Disk because the characters flushed out of the buffer are written onto the disk."", ""Disk""); (""Flush"", ""The Flush method is related to the Network because it ensures that the characters written until now are flushed out of the buffer and onto the network."", ""Network"")"
"Since the BufferedWriter collects the characters written internally in a buffer before writing them to the underlying Writer, the speedup is not as noticeable as with other Writer classes (that do not use buffering).",NULL
The Java BufferedWriter's flush() method flushes all data written to the BufferedWriter to the underlying data destination.,"(""BufferedWriter"", ""The flush() method is a part of the BufferedWriter class, indicating a clear relationship between the two entities as the method is used to perform an operation on the BufferedWriter."", ""flush()""); (""BufferedWriter"", ""The BufferedWriter is related to the data destination as it writes data to the underlying data destination, indicating a clear relationship between the two entities as the BufferedWriter performs an operation on the data destination."", ""data destination"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your BufferedWriter has).","(""Flush"", ""The Flush method is related to the BufferedWriter class because it is used to assure that any buffered data will be flushed to the destination of the BufferedWriter."", ""BufferedWriter"")"
Here is an example of flushing data written to a Java BufferedWriter by calling its flush() method:,"(""BufferedWriter"", ""The flush() method is called on a BufferedWriter object, indicating a relationship between the two."", ""flush()""); (""Java"", ""BufferedWriter is a class in the Java package, indicating a relationship between the two."", ""BufferedWriter"")"
"The Java ByteArrayInputStream class, java.io.ByteArrayInputStream, of the Java IO API enables you to read data from byte arrays as streams of bytes.","(""ByteArrayInputStream"", ""The ByteArrayInputStream class is part of the java.io package"", ""java.io.ByteArrayInputStream""); (""ByteArrayInputStream"", ""The ByteArrayInputStream class is part of the Java IO API"", ""Java IO API"")"
"In other words, the ByteArrayInputStream class can turn a byte array into an InputStream.",NULL
"The ByteArrayInputStream class is a subclass of the InputStream class, so you can use a ByteArrayInputStream as an InputStream.","(""ByteArrayInputStream"", ""The ByteArrayInputStream class is a subclass of the InputStream class"", ""InputStream"")"
The ByteArrayInputStream also has a set of additional methods that are specific to the ByteArrayInputStream class.,NULL
To use a Java ByteArrayInputStream you must first create an instance of the ByteArrayInputStream class.,NULL
"You read bytes from a Java ByteArrayInputStream just like you would from a regular InputStream, via its read() method.","(""ByteArrayInputStream"", ""The ByteArrayInputStream class has a read() method, indicating a clear relationship between the two entities."", ""read()""); (""InputStream"", ""The InputStream class also has a read() method, indicating a relationship between the InputStream class and the read() method."", ""read()"")"
"The read() will return the next byte from the byte array, or -1 if the end of the byte array (or byte array section) has been reached.",NULL
The Java ByteArrayInputStream available() method tells you how many bytes are still available in the ByteArrayInputStream.,"(""ByteArrayInputStream"", ""The available() method is a part of the ByteArrayInputStream class, indicating a relationship between the two."", ""available()""); (""Java"", ""The ByteArrayInputStream class is part of the Java package, indicating a relationship between the two."", ""ByteArrayInputStream"")"
The mark() method of the ByteArrayInputStream class sets an internal mark at the current byte position - meaning right after the previous byte read.,"(""ByteArrayInputStream"", ""The mark() method is a part of the ByteArrayInputStream class, indicating a relationship between the two entities as the method belongs to the class."", ""mark()"")"
"The mark() method takes a parameter telling how many bytes can be read past this mark, before this mark becomes invalid.","(""Mark"", ""The Mark method takes a parameter, indicating that the Mark method is related to the parameter."", ""parameter"")"
Here is an example of setting a mark in a ByteArrayInputStream via its mark() method:,NULL
The reset() method of the ByteArrayInputStream resets how far it has read into the byte array.,NULL
The Java ByteArrayInputStream skip() method enables you to skip over a number of bytes from the underlying byte array.,"(""ByteArrayInputStream"", ""The skip() method is a part of the ByteArrayInputStream class, indicating a clear relationship between the two entities."", ""skip()""); (""Java"", ""The ByteArrayInputStream class is part of the Java package, indicating a clear relationship between the two entities."", ""ByteArrayInputStream"")"
Here is an example of skipping over a number of bytes using the ByteArrayInputStream skip() method:,NULL
Notice how the while loop continues until a -1 value is read from the ByteArrayInputStream read() method.,"(""While Loop"", ""The while loop is related to ByteArrayInputStream because it uses the read() method of ByteArrayInputStream to control its flow."", ""ByteArrayInputStream""); (""While Loop"", ""The while loop is related to the read() method because it continues until a -1 value is read from the ByteArrayInputStream."", ""Read"")"
"After that, the while loop exits, and the ByteArrayInputStream close() method is called.",NULL
"If an exception is thrown while reading data from the ByteArrayInputStream, the close() method is never called.","(""ByteArrayInputStream"", ""The close() method is related to the ByteArrayInputStream class because it is a method that can be called on an instance of ByteArrayInputStream."", ""close()""); (""ByteArrayInputStream"", ""The ByteArrayInputStream class is related to the exception class because an exception can be thrown while reading data from a ByteArrayInputStream."", ""exception"")"
"The Java ByteArrayOutputStream class, java.io.ByteArrayOutputStream of the Java IO API enables you to capture data written to a stream in a byte array.","(""ByteArrayOutputStream"", ""ByteArrayOutputStream is a part of the java.io package"", ""java.io.ByteArrayOutputStream""); (""ByteArrayOutputStream"", ""ByteArrayOutputStream is a part of the Java IO API"", ""Java IO API"")"
You write your data to the ByteArrayOutputStream and when you are done you call the its toByteArray() method to obtain all the written data in a byte array.,NULL
"Since the Java ByteArrayOutputStream class is a subclass of the Java OutputStream class, you write bytes to it using the same write methods that OutputStream has:","(""ByteArrayOutputStream"", ""ByteArrayOutputStream is a subclass of OutputStream, indicating a inheritance relationship between the two classes"", ""OutputStream""); (""ByteArrayOutputStream"", ""ByteArrayOutputStream uses the write method, indicating a usage relationship between the class and the method"", ""write"")"
"Once you have finished writing to the ByteArrayOutputStream you can obtain all the bytes written as a Java byte array, using the ByteArrayOutputStream toByteArray() method.",NULL
Being a subclass of OutputStream the ByteArrayOutputStream also has a close() method.,"(""ByteArrayOutputStream"", ""ByteArrayOutputStream is a subclass of OutputStream, indicating a inheritance relationship between the two classes"", ""OutputStream""); (""ByteArrayOutputStream"", ""ByteArrayOutputStream has a close() method, indicating that close() is a method of the ByteArrayOutputStream class"", ""close()"")"
But calling the close() method has no effect on the ByteArrayOutputStream.,NULL
"The Java DataInputStream class, java.io.DataInputStream, enables you to read Java primitives (int, float, long etc.)","(""Java DataInputStream"", ""The Java DataInputStream class is part of the java.io package, as indicated by its full name java.io.DataInputStream"", ""java.io.DataInputStream""); (""Java DataInputStream"", ""The Java DataInputStream class enables you to read Java primitives, including int"", ""int""); (""Java DataInputStream"", ""The Java DataInputStream class enables you to read Java primitives, including float"", ""float"")"
"The Java DataInputStream class is a subclass of InputStream, so DataInputStream also has the basic read methods that enable you to read a single byte or an array of bytes from the underlying InputStream, in case you need that.","(""DataInputStream"", ""DataInputStream is a subclass of InputStream, indicating a inheritance relationship between the two classes"", ""InputStream""); (""DataInputStream"", ""DataInputStream has the basic read methods, indicating that read is a method of DataInputStream"", ""read"")"
"As mentioned earlier, the DataInputStream class is often used together with a DataOutputStream.",NULL
You can read a Java boolean from the DataInputStream using its readBoolean() method.,NULL
Here is an example of reading a boolean from a Java DataInputStream using readBoolean():,NULL
You can read a Java byte from the DataInputStream using its readByte() method.,NULL
Here is an example of reading a byte from a Java DataInputStream using readByte():,"(""DataInputStream"", ""DataInputStream uses the readByte() method to read a byte from the input stream"", ""readByte()""); (""Java"", ""DataInputStream is a part of the Java package"", ""DataInputStream"")"
You can read a Java unsigned byte (only positive values) from the DataInputStream using its readUnsignedByte() method.,NULL
Here is an example of reading an unsigned byte from a Java DataInputStream using readUnsignedByte():,"(""DataInputStream"", ""DataInputStream uses the readUnsignedByte() method to read an unsigned byte"", ""readUnsignedByte()""); (""Java"", ""Java is the package that contains the DataInputStream class"", ""DataInputStream"")"
You can read a Java char from the DataInputStream using its readChar() method.,NULL
Here is an example of reading a char from a Java DataInputStream using readChar():,NULL
You can read a Java double from the DataInputStream using its readDouble() method.,NULL
Here is an example of reading a double from a Java DataInputStream using readDouble():,NULL
You can read a Java float from the DataInputStream using its readFloat() method.,NULL
Here is an example of reading a float from a Java DataInputStream using readFloat():,NULL
You can read a Java short from the DataInputStream using its readShort() method.,NULL
Here is an example of reading a short from a Java DataInputStream using readShort():,"(""DataInputStream"", ""DataInputStream uses the readShort() method to read a short from the input stream"", ""readShort()""); (""Java"", ""Java is the package that contains the DataInputStream class"", ""DataInputStream"")"
You can read a Java unsigned short (only positive values) from the DataInputStream using its readUnsignedShort() method.,NULL
Here is an example of reading an unsigned short from a Java DataInputStream using readUnsignedShort():,NULL
You can read a Java int from the DataInputStream using its readInt() method.,NULL
Here is an example of reading an int from a Java DataInputStream using readInt():,NULL
You can read a Java long from the DataInputStream using its readLong() method.,NULL
Here is an example of reading an int from a Java DataInputStream using readLong():,"(""DataInputStream"", ""DataInputStream uses the readLong() method to read a long value from the input stream"", ""readLong()""); (""Java"", ""DataInputStream is a part of the Java package"", ""DataInputStream"")"
You can read a Java String from the DataInputStream using its readUTF() method.,"(""DataInputStream"", ""The DataInputStream class has a readUTF() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""readUTF()""); (""readUTF()"", ""The readUTF() method is used to read a Java String, establishing a relationship between the method and the String class as the method's return type or the type of data it handles."", ""String"")"
Here is an example of reading a String from a Java DataInputStream using readUTF():,"(""DataInputStream"", ""DataInputStream contains the method readUTF()"" "", ""readUTF()""); (""String"", ""String is read from DataInputStream using the readUTF() method"" "", ""DataInputStream"")"
"The Java File class, java.io.File in the Java IO API gives you access to the underlying file system.","(""Java File"", ""The Java File class is located in the java.io.File package, indicating a clear relationship between the two entities."", ""java.io.File""); (""Java File"", ""The Java File class is part of the Java IO API, indicating a clear relationship between the two entities."", ""Java IO API"")"
Note: The Java File class only gives you access to the file and directory meta data.,NULL
Note: If you are want to Java NIO (Java's non-blocking IO API) you will have to use the java.nio.FileChannel class instead.,"(""Java NIO"", ""Java NIO is related to java.nio.FileChannel because java.nio.FileChannel is a class used in Java NIO"", ""java.nio.FileChannel""); (""Java"", ""Java is related to Java NIO because Java NIO is a part of the Java API"", ""Java NIO"")"
"Both Java File and FileChannel works, but in case you want a pure Java NIO solution use the Java NIO FileChannel class.","(""Java File"", ""Both Java File and FileChannel are mentioned as alternatives, indicating a relationship between them."", ""FileChannel""); (""Java NIO"", ""The Java NIO package is related to the FileChannel class, as it is mentioned that FileChannel is a part of the Java NIO solution."", ""FileChannel"")"
"Before you can do anything with the file system or File class, you must create a Java File instance.",NULL
The Java File class also has a few other constructors you can use to instantiate File instances in different ways.,NULL
You can check if a file referenced by a Java File object exists using the File exists() method.,"(""File"", ""The File class has an exists() method, indicating a relationship between the two entities."", ""exists()"")"
You can use the Java File class to create directories if they don't already exists.,NULL
The File class contains the method mkdir() and mkdirs() for that purpose.,"(""File"", ""The File class contains the method mkdir() for creating a directory."", ""mkdir()"")"
The mkdir() method creates a single directory if it does not already exist.,NULL
Here is an example of creating a single directory via the Java File class:,NULL
"The mkdir() returns true if the directory was created, and false if not.",NULL
The mkdirs() will create all directories that are missing in the path the File object represents.,NULL
Here is an example of creating multiple directories via the Java File class:,NULL
"The mkdirs() method will return true if all the directories were created, and false if not.",NULL
The Java File class enables you to read the length in bytes of a file.,"(""File"", ""The File class is part of the Java package, indicating a relationship between the two entities."", ""Java"")"
"To read the length of a file, call the File length() method.",NULL
Here is an example of reading the length of a file via the Java File length() method:,"(""File"", ""The File class contains the length() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""length()""); (""Java"", ""The Java package contains the File class, indicating a relationship between the package and the class as the class is part of the package."", ""File"")"
"To rename (or move) a file, call the method renameTo() on the File class.",NULL
"As briefly mentioned earlier, the renameTo() method can also be used to move a file to a different directory.",NULL
The new file name passed to the renameTo() method does not have to be in the same directory as the file was already residing in.,NULL
"The renameTo() method returns boolean (true or false), indicating whether the renaming was successful.",NULL
"The Java File renameTo() method also works for directories, by the way.",NULL
"The delete() method returns boolean (true or false), indicating whether the deletion was successful.",NULL
"The Java File delete() method also works for directories, meaning you can also delete directories with it.",NULL
The Java File delete() method can only delete a directory if the directory is empty.,NULL
"You can check if a File object points to a file or directory, by calling its isDirectory() method.",NULL
You can obtain a list of all the files in a directory by calling either the Java File list() method or the listFiles() method.,"(""File"", ""The File class has a method called list() to obtain a list of all the files in a directory"", ""list()""); (""File"", ""The File class has a method called listFiles() to obtain a list of all the files in a directory"", ""listFiles()"")"
The list() method returns an array of String's with the file and / or directory names of directory the File object points to.,"(""List"", ""The list() method returns an array of String's with the file and / or directory names of directory the File object points to, indicating a relationship between the List method and the File class."", ""File""); (""List"", ""The list() method returns an array of String's, indicating a relationship between the List method and the String class."", ""String""); (""List"", ""The list() method returns an array, indicating a relationship between the List method and the Array class."", ""Array""); (""File"", ""The File object points to a directory with file and / or directory names of type String, indicating a relationship between the File class and the String class."", ""String"")"
The listFiles() returns an array of File objects representing the files and / or directories in the directory the File points to.,NULL
Here is an example of listing all files in a directory via the Java File list() and listFiles() methods:,"(""File"", ""The File class contains the list() method, indicating a relationship between the two."", ""list()""); (""File"", ""The File class contains the listFiles() method, indicating a relationship between the two."", ""listFiles()"")"
"The Java FileInputStream class, java.io.FileInputStream, makes it possible to read the contents of a file as a stream of bytes.",NULL
"Note also, that since FileInputStream is a subclass of InputStream, we can cast the created FileInputStream to an InputStream everywhere we want to, as we do in the example above.",NULL
The FileInputStream class has a three different constructors you can use to create a FileInputStream instance.,NULL
"Actually, in my experience Java will also understand if you use a / as directory separator on Windows (e.g.",NULL
The read() method of a FileInputStream returns an int which contains the byte value of the byte read.,NULL
"If the read() method returns -1, there is no more data to read in the FileInputStream, and it can be closed.",NULL
You use the read() method just like the read() method of an InputStream.,NULL
Being an InputStream the FileInputStream also has two read() methods which can read data into a byte array.,"(""FileInputStream"", ""FileInputStream is a subclass of InputStream, indicating a clear inheritance relationship between the two classes"", ""InputStream""); (""FileInputStream"", ""FileInputStream has two read() methods, indicating that the class has or contains the method"", ""read()"")"
"These methods are inherited from the Java InputStream class, by the way.","(""InputStream"", ""The InputStream class is part of the Java package, indicating a relationship between the two entities."", ""Java"")"
"If all bytes have been read from the FileInputStream, these read() methods will return -1.",NULL
Therefore it is necessary to inspect the value returned from these read() method calls.,NULL
The doSomethingWithData() method implementation has been left out of this example to keep it short.,NULL
"Notice, that a BufferedInputStream is an InputStream subclass and can be used in any place where an InputStream can be used.",NULL
You close a FileInputStream by calling the close() method inherited from InputStream.,"(""FileInputStream"", ""FileInputStream is related to close() because close() is a method that can be called on a FileInputStream object"", ""close()""); (""close()"", ""close() is related to InputStream because close() is a method inherited from InputStream"", ""InputStream"")"
Notice how the while loop continues until a -1 value is read from the FileInputStream read() method.,NULL
"After that, the while loop exits, and the FileInputStream close() method is called.",NULL
"If an exception is thrown while reading data from the FileInputStream, the close() method is never called.","(""FileInputStream"", ""The close() method is related to the FileInputStream class because it is called on an instance of FileInputStream to release system resources."", ""close()""); (""exception"", ""An exception is related to the FileInputStream because it can be thrown while reading data from the FileInputStream."", ""FileInputStream"")"
"The Java FileOutputStream class, java.io.FileOutputStream, makes it possible to write a file as a stream of bytes.",NULL
The Java FileOutputStream class is a subclass of Java OutputStream meaning you can use a FileOutputStream as an OutputStream.,"(""FileOutputStream"", ""FileOutputStream is a subclass of OutputStream, meaning it inherits its properties and methods, thus establishing a clear inheritance relationship between the two classes."", ""OutputStream"")"
The Java FileOutputStream class contains a set of different useful constructors.,"(""FileOutputStream"", ""The Java FileOutputStream class indicates that FileOutputStream is a part of Java, thus they are related."", ""Java""); (""FileOutputStream"", ""The FileOutputStream class contains a set of different useful constructors, thus FileOutputStream and constructors are related as the class contains the constructors."", ""constructors"")"
To write data to a Java FileOutputStream you can use its write() method.,NULL
Here is an example of writing data to a Java FileOutputStream using its write() method:,"(""FileOutputStream"", ""The write() method is a part of the FileOutputStream class, indicating a relationship between the two entities."", ""write()""); (""Java"", ""FileOutputStream is a class in the Java package, indicating a relationship between the two entities."", ""FileOutputStream"")"
"Since the Java FileOutputStream is a subclass of OutputStream, you can write arrays of bytes to the FileOutputStream too, instead of just a single byte at a time.",NULL
If you want to make sure that all written data is written to disk without having to close the FileOutputStream you can call its flush() method.,NULL
"Calling flush() will make sure that all data which has been written to the FileOutputStream so far, is fully written to disk too.",NULL
Here is an example of calling the Java FileOutputStream flush() method:,NULL
Here is an example of closing a Java FileOutputStream by calling its close() method:,"(""FileOutputStream"", ""The close() method is a part of the FileOutputStream class, indicating a relationship between the two."", ""close()""); (""Java"", ""The FileOutputStream class is part of the Java package, indicating a relationship between the two."", ""FileOutputStream"")"
"Unfortunately, if an exception is thrown during the write() call in the example above, that exception will cause the program flow to break before the close() method is called.","(""Exception"", ""The exception is thrown during the write() call, indicating a relationship between the Exception class and the Write method."", ""Write""); (""Exception"", ""The exception causes the program flow to break before the close() method is called, indicating a relationship between the Exception class and the Close method."", ""Close"")"
"In other words, the FileOutputStream close() will be called automatically for you.",NULL
You can convert a FileOutputStream to a character based Writer using the Java OutputStreamWriter class.,"(""FileOutputStream"", ""FileOutputStream can be converted to a character based Writer using the Java OutputStreamWriter class, indicating a conversion relationship between the two."", ""OutputStreamWriter"")"
"The Java FileReader class, java.io.FileReader makes it possible to read the contents of a file as a stream of characters.",NULL
"The Java FileReader is a subclass of the Java Reader class, so it has many of the same methods.",NULL
The read() method of the Java FileReader returns an int which contains the char value of the character read.,"(""FileReader"", ""The read() method is a part of the FileReader class, indicating a clear relationship between the two entities."", ""read()""); (""Java"", ""The FileReader class is part of the Java programming language, indicating a relationship between the Java entity and the FileReader entity."", ""FileReader"")"
"If the read() method returns -1, there is no more data to read in the FileReader, and it can be closed.",NULL
"Notice, that a BufferedReader is a Reader subclass and can be used in any place where an Reader can be used.",NULL
Notice how there is no longer any explicit close() method call to the FileReader instance.,NULL
"The Java FileWriter class, java.io.FileWriter, makes it possible to write characters to a file.",NULL
"The Java FileWriter class is a subclass of the Java Writer class, by the way.",NULL
The Java FileWriter's flush() method flushes all data written to the FileWriter to the underlying file.,NULL
By calling flush() you can assure that any buffered data will be flushed (written) to disk.,NULL
Here is an example of flushing data written to a Java FileWriter by calling its flush() method:,NULL
Notice how there is no longer any explicit close() method call to the FileWriter instance.,NULL
"The Java InputStream class, java.io.InputStream, represents an ordered stream of bytes.",NULL
The Java InputStream class is the base class (superclass) of all input streams in the Java IO API.,NULL
"Each subclass of InputStream typically has a very specific use, but can be used as an InputStream.",NULL
FileInputStream is a subclass of InputStream so it is safe to assign an instance of FileInputStream to an InputStream variable (the inputstream variable).,"(""FileInputStream"", ""FileInputStream is a subclass of InputStream, indicating a inheritance relationship between the two classes"", ""InputStream"")"
The read() method of an InputStream returns an int which contains the byte value of the byte read.,NULL
"If the read() method returns -1, the end of stream has been reached, meaning there is no more data to read in the InputStream.",NULL
The InputStream class also contains two read() methods which can read data from the InputStream's source into a byte array.,"(""InputStream"", ""The InputStream class contains the read() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""read()"")"
"Inside the while loop the doSomethingWithData() method is called, passing along the data byte array as well as how many bytes were read into the array as parameters.","(""DoSomethingWithdata"", ""The DoSomethingWithData method is clearly related to the Data because it is passing along the data byte array as a parameter."", ""Data""); (""While Loop"", ""The While Loop is clearly related to the DoSomethingWithData method because it is calling the method inside the loop."", ""DoSomethingWithdata"")"
The Java InputStream class contains a method called readAllBytes() (since Java 9).,"(""InputStream"", ""The InputStream class contains the readAllBytes() method, indicating a clear relationship between the two entities."", ""readAllBytes()""); (""Java"", ""The Java package is related to the InputStream class, as InputStream is part of the Java library."", ""InputStream"")"
Here is an example of reading all bytes from a Java InputStream via readAllBytes():,NULL
The InputStream class has two methods called mark() and reset() which subclasses of InputStream may or may not support.,"(""InputStream"", ""The InputStream class has a method called mark() which subclasses of InputStream may or may not support."", ""mark()"")"
"If an InputStream subclass supports the mark() and reset() methods, then that subclass should override the markSupported() to return true.","(""InputStream"", ""InputStream is related to mark() because mark() is a method that can be supported by InputStream subclasses"", ""mark()""); (""InputStream"", ""InputStream is related to reset() because reset() is a method that can be supported by InputStream subclasses"", ""reset()""); (""InputStream"", ""InputStream is related to markSupported() because markSupported() is a method that should be overridden by InputStream subclasses to return true if they support mark() and reset()"", ""markSupported()""); (""mark()"", ""mark() is related to markSupported() because markSupported() indicates whether mark() is supported"", ""markSupported()""); (""reset()"", ""reset() is related to markSupported() because markSupported() indicates whether reset() is supported"", ""markSupported()"")"
If the markSupported() method returns false then mark() and reset() are not supported.,"(""MarkSupported"", ""The markSupported method is related to the mark method because markSupported determines whether the mark operation is supported."", ""Mark"")"
The mark() sets a mark internally in the InputStream which marks the point in the stream to which data has been read so far.,NULL
"If the code using the InputStream wants to go back to the point in the stream where the mark was set, the code calls reset() on the InputStream.","(""InputStream"", ""The reset() method is called on the InputStream, indicating a relationship between the two."", ""reset()""); (""code"", ""The code uses the InputStream, indicating a relationship between the two."", ""InputStream"")"
The methods mark() and reset() methods are typically used when implementing parsers.,"(""Mark"", ""Both Mark and Reset are methods typically used when implementing parsers, indicating a relationship between them in the context of parser implementation."", ""Reset""); (""Mark"", ""Mark method is used when implementing parsers, indicating a relationship between the Mark method and the concept of parsers."", ""Parsers"")"
Notice how the while loop continues until a -1 value is read from the InputStream read() method.,NULL
"After that, the while loop exits, and the InputStream close() method is called.",NULL
"If an exception is thrown while reading data from the InputStream, the close() method is never called.","(""InputStream"", ""The close() method is related to the InputStream because it is called on the InputStream object when it is closed."", ""close()""); (""Exception"", ""The Exception class is related to the close() method because if an exception is thrown, the close() method is never called."", ""close()"")"
"The Java InputStreamReader class, java.io.InputStreamReader, wraps a Java InputStream, thereby turning the byte based InputStream into a character based Reader.","(""InputStreamReader"", ""The InputStreamReader class wraps a Java InputStream, indicating a clear relationship between the two classes."", ""InputStream""); (""InputStreamReader"", ""The InputStreamReader class turns the byte based InputStream into a character based Reader, indicating a clear relationship between the InputStreamReader and Reader classes."", ""Reader""); (""InputStream"", ""The InputStream is turned into a Reader, indicating a clear relationship between the InputStream and Reader classes."", ""Reader""); (""java.io"", ""The InputStreamReader class is part of the java.io package, indicating a clear relationship between the package and the class."", ""InputStreamReader"")"
The Java InputStreamReader class is thus a subclass of the Java Reader class.,NULL
You can get the character encoding used by a Java InputStreamReader instance via its getEncoding() method.,"(""InputStreamReader"", ""The InputStreamReader class has a getEncoding() method, indicating a clear relationship between the two entities."", ""getEncoding()""); (""Java"", ""The InputStreamReader class is part of the Java package, indicating a clear relationship between the two entities."", ""InputStreamReader"")"
The read() method of an InputStreamReader returns an int which contains the char value of the char read.,NULL
"If the read() method returns -1, the end of stream has been reached, meaning there is no more data to read in the InputStreamReader.",NULL
"As you can see, the while loop keeps running until a -1 is read from the InputStreamReader read() method.",NULL
"Once all the data is written to it, simply call the method toByteArray() or toCharArray, and all the data written is returned in array form.",NULL
The Java CharArrayReader class (java.io.CharArrayReader) enables you to read the contents of a char array as a character stream.,NULL
"The Java CharArrayReader is handy when you have data in a char array, but need to pass that data to some component which can only read from a Reader (or a Reader subclass).","(""CharArrayReader"", ""CharArrayReader is a subclass of Reader, as indicated by the term 'Reader subclass' in the text, which establishes a clear relationship between the two entities."", ""Reader"")"
Closing a CharArrayReader can be done using the close() method like this:,NULL
Notice that there is no explicit close() call on the CharArrayReader.,NULL
The Java CharArrayWriter class (java.io.CharArrayWriter) makes it possible to write characters via the Writer methods (CharArrayWriter is a subclass of Writer) and convert the written characters into a char array.,"(""CharArrayWriter"", ""CharArrayWriter is a subclass of Writer, indicating a clear inheritance relationship between the two classes"", ""Writer""); (""CharArrayWriter"", ""CharArrayWriter is part of the java.io package, indicating a clear containment relationship between the package and the class"", ""java.io"")"
"The Java CharArrayWriter class is handy when you have a component that can only write characters to a Writer, but you need the characters as a char array.","(""CharArrayWriter"", ""The Java CharArrayWriter class is related to the Writer because it is used when a component can only write characters to a Writer"", ""Writer"")"
"Simply pass that component a CharArrayWriter and when all characters are written to it, call toCharArray() on the CharArrayWriter.","(""CharArrayWriter"", ""The CharArrayWriter class has a method called toCharArray, indicating a relationship between the two."", ""toCharArray"")"
"Third, the written characters are obtained as a char array by calling the toCharArray() method on the CharArrayWriter.",NULL
Notice how there is no longer any explicit close() method call to the CharArrayWriter instance.,NULL
The Java DataOutputStream class enables you to write Java primitives to OutputStream's instead of only bytes.,"(""DataOutputStream"", ""DataOutputStream is related to OutputStream because it enables writing to OutputStream's"", ""OutputStream""); (""DataOutputStream"", ""DataOutputStream is related to Java because it is a Java class"", ""Java"")"
"As mentioned earlier, the DataOutputStream class is often used together with a DataInputStream.",NULL
But what happens if an exception is thrown from inside the doSomethingWithData() method?,NULL
"Well, to catch that situation you will have to wrap the call to close() in a try-catch block too, like this:",NULL
"But, what happens if an exception is also thrown from the input.close() method?","(""Input"", ""The Input class has a Close method, indicating a relationship between the two entities."", ""Close""); (""Close"", ""The Close method can throw an Exception, indicating a relationship between the two entities."", ""Exception"")"
"Separate pages will describe each of these methods or classes in more detail, including examples of their usage etc.","(""Separate"", ""Separate and Pages are related as they are both mentioned in the context of describing methods or classes in more detail."", ""Pages""); (""Methods"", ""Methods and Classes are related as they are both described in more detail on separate pages, including examples of their usage."", ""Classes""); (""Usage"", ""Usage is related to Methods as it is mentioned as an example of their usage."", ""Methods"")"
The Java IO API contains the following classes which are relevant to working with files in Java:,NULL
"These classes are explained in more detail in their own texts, but the sections below will give a brief introduction to these classes.","(""Classes"", ""These classes are explained in more detail in their own texts, indicating a relationship between classes and texts."", ""Texts""); (""Classes"", ""The sections below will give a brief introduction to these classes, indicating a relationship between classes and sections."", ""Sections"")"
"These two classes lets you read a file one byte or character at a time from the start to the end of the file, or read the bytes into an array of byte or char, again from start towards the end of the file.","(""File"", ""The File class is related to the Byte class because it allows reading a file one byte at a time."", ""Byte""); (""File"", ""The File class is related to the Array class because it allows reading the bytes into an array of byte."", ""Array"")"
"As I have already mentioned, you can get random access to files with Java IO via the RandomAccessFile class.",NULL
Both file and directory information is available via the File class.,"(""File"", ""The File class is related to file because it provides information about it."", ""file"")"
The FilterInputStream is a base class for implementing your own filtering input streams.,NULL
"It is intended to be a base class for your own subclasses, but in my opinion you might as well just subclass InputStream directly.","(""InputStream"", ""InputStream is related to subclass because it is mentioned that one might as well just subclass InputStream directly"", ""subclass""); (""base class"", ""base class is related to subclass because a base class is intended to be a base for your own subclasses"", ""subclass"")"
I cannot see that this class actually adds or changes any behaviour in InputStream except that it takes an InputStream in its constructor.,NULL
The FilterOutputStream is a base class for implementing your own filtering output streams.,NULL
I cannot see that this class actually adds or changes any behaviour in OutputStream except that it takes an OutputStream in its constructor.,NULL
"If you choose to extend this class you might as well extend the OutputStream class directly, and avoid the extra class in the hierarchy.","(""OutputStream"", ""The OutputStream class is related to the concept of extending a class, as it is mentioned as a possible class to extend directly."", ""class"")"
The FilterReader is a base class for implementing your own filtering readers.,NULL
"Like with FilterInputStream, I see no sensible purpose for this class.",NULL
I cannot see that this class actually adds or changes any behaviour in Reader except that it takes a Reader in its constructor.,NULL
"If you choose to extend this class you might as well extend the Reader class directly, and avoid the extra class in the hierarchy.",NULL
The FilterWriter is a base class for implementing your own filtering Writer's.,NULL
"Like with FilterOutputStream, I see no sensible purpose for this class.",NULL
I cannot see that this class actually adds or changes any behaviour in Writer except that it takes a Writer in its constructor.,NULL
"If you choose to extend this class you might as well extend the Writer class directly, and avoid the extra class in the hierarchy.",NULL
Some of the classes in the Java IO API are designed to help you parse input.,NULL
The purpose was rather to give you above quick list of classes related to parsing of input data.,"(""Purpose"", ""The purpose is related to classes because it is giving a list of classes."", ""Classes""); (""Classes"", ""Classes are related to Input Data because the classes are used for parsing of input data."", ""Input Data"")"
If you have to parse data you will often end up writing your own classes that use some of the classes in this list.,"(""Data"", ""Data is often parsed using classes, so they are related in the context of parsing data."", ""Classes""); (""Classes"", ""Classes are used in the context of a list, so they are related in the context of the provided text."", ""List""); (""Parse"", ""The parse method is used on data, so they are related in the context of parsing."", ""Data"")"
The Java LineNumberReader class (java.io.LineNumberReader is a BufferedReader that keeps track of line numbers of the read characters.,"(""LineNumberReader"", ""LineNumberReader is a subclass of BufferedReader, as indicated by the phrase 'a BufferedReader' in the text, which establishes an inheritance relationship between the two classes"", ""BufferedReader""); (""LineNumberReader"", ""LineNumberReader is part of the java.io package, as indicated by the phrase 'java.io.LineNumberReader' in the text, which establishes a containment relationship between the package and the class"", ""java.io"")"
You can get the current line number from the LineNumberReader by calling the getLineNumber() method.,NULL
"You can also set the current line number, should you need to, by calling the setLineNumber() method.",NULL
Since FileOutputStream is a subclass of OutputStream this should be no problem.,NULL
In this example the process() method cannot see if the InputStream it gets as parameter comes from the file system or the network (the example only shows the file system version).,"(""Process"", ""The process() method gets InputStream as a parameter, indicating a relationship between the two."", ""InputStream""); (""Process"", ""The process() method is related to the file system as it is mentioned that the InputStream comes from the file system."", ""File System"")"
The Java ObjectInputStream class (java.io.ObjectInputStream) enables you to read Java objects from an InputStream instead of just raw bytes.,"(""ObjectInputStream"", ""ObjectInputStream is related to InputStream because it reads Java objects from an InputStream"", ""InputStream""); (""ObjectInputStream"", ""ObjectInputStream is related to java.io because it is part of the java.io package"", ""java.io"")"
"For this ObjectInputStream example to work the object you read must be an instance of MyClass, and must have been serialized into the file ""object.data"" via an ObjectOutputStream.","(""ObjectInputStream"", ""ObjectInputStream is related to MyClass because it is used to read an instance of MyClass from a file."", ""MyClass""); (""ObjectInputStream"", ""ObjectInputStream is related to ObjectOutputStream because they are both used for serialization and deserialization, and the object read by ObjectInputStream must have been serialized by ObjectOutputStream."", ""ObjectOutputStream"")"
Before you can serialize and de-serialize objects the class of the object must implement java.io.Serializable.,"(""Java"", ""Java is related to Serializable because the class of the object must implement java.io.Serializable, indicating that Java is the language in which the Serializable class is used"", ""Serializable"")"
"After that the ObjectInputStream is also closed, and the values read into the Person object are printed to System.out.","(""ObjectInputStream"", ""The ObjectInputStream is used to read values into the Person object, indicating a relationship between the two."", ""Person""); (""Person"", ""The values read into the Person object are printed to System.out, indicating a relationship between the two."", ""System.out""); (""ObjectInputStream"", ""The ObjectInputStream is used to read values which are then printed to System.out, indicating a relationship between the two."", ""System.out""); (""read"", ""The read method is used with the ObjectInputStream to read values."", ""ObjectInputStream""); (""print"", ""The print method is used with System.out to print values."", ""System.out"")"
The Java ObjectOutputStream class (java.io.ObjectOutputStream) enables you to write Java objects to an OutputStream instead of just raw bytes.,"(""ObjectOutputStream"", ""The ObjectOutputStream class is related to the OutputStream class because it enables writing Java objects to an OutputStream."", ""OutputStream""); (""ObjectOutputStream"", ""The ObjectOutputStream class is related to the java.io package because it is part of that package, as indicated by its fully qualified name java.io.ObjectOutputStream."", ""java.io.ObjectOutputStream"")"
In this text I will try to give you an overview of the classes in the Java IO (java.io) package.,NULL
"More specifically, I will try to group the classes after their purpose.",NULL
"This grouping should make it easier for you in the future, to determine the purpose of a class, or find the class you need for a specific purpose.",NULL
"Java IO contains many subclasses of the InputStream, OutputStream, Reader and Writer classes.","(""Java IO"", ""Java IO contains many subclasses of the InputStream class"", ""InputStream""); (""Java IO"", ""Java IO contains many subclasses of the OutputStream class"", ""OutputStream""); (""Java IO"", ""Java IO contains many subclasses of the Reader class"", ""Reader"")"
"The reason is, that all of these subclasses are addressing various different purposes.",NULL
These purposes are nice to know about when reading through the Java IO classes.,NULL
They make it somewhat easier to understand what the classes are targeting.,NULL
"Having discussed sources, destinations, input, output and the various IO purposes targeted by the Java IO classes, here is a table listing most (if not all) Java IO classes divided by input, output, being byte based or character based, and any more specific purpose they may be addressing, like buffering, parsing etc.","(""Java IO"", ""Java IO is related to Input because it is mentioned as one of the purposes targeted by the Java IO classes"", ""Input""); (""Java IO"", ""Java IO is related to Output because it is mentioned as one of the purposes targeted by the Java IO classes"", ""Output""); (""Java IO classes"", ""Java IO classes are related to IO because they are part of the Java IO package"", ""IO""); (""Input"", ""Input is related to IO because it is one of the purposes addressed by the Java IO classes"", ""IO"")"
The PipedInputStream class makes it possible to read the contents of a pipe as a stream of bytes.,NULL
The read() method of a PipedInputStream returns an int which contains the byte value of the byte read.,NULL
"If the read() method returns -1, there is no more data to read in the stream, and it can be closed.",NULL
"Since PipedInputStream is a subclass of InputStream, PipedInputStream has the same basic methods and use patterns as an InputStream.",NULL
The PipedOutputStream class makes it possible to write to a Java pipe as a stream of bytes.,NULL
The write() method of a PipedOutputStream takes an int which contains the byte value of the byte to write.,"(""PipedOutputStream"", ""The write() method is a part of the PipedOutputStream class, indicating a relationship between the two."", ""write()"")"
"Since PipedOutputStream is a subclass of OutputStream, PipedOutputStream has the same basic methods and use patterns as an OutputStream.",NULL
The Java PipedReader class (java.io.PipedReader) makes it possible to read the contents of a pipe as a stream of characters.,NULL
"If the read() method returns -1, there is no more data to read in the PipedReader, and it can be closed.",NULL
Notice how there is no longer any explicit close() method call to the PipedReader instance.,"(""PipedReader"", ""The close method is related to the PipedReader class because it is a method that can be called on an instance of PipedReader."", ""close"")"
The Java PipedWriter class (java.io.PipedWriter) makes it possible to write to a Java pipe as a stream of characters.,NULL
"There are also versions of the write() method that take a String, char array etc.","(""Write"", ""The write method is related to String because it takes a String as a parameter."", ""String"")"
Notice how there is no longer any explicit close() method call to the PipedWriter instance.,"(""PipedWriter"", ""The PipedWriter class has a close() method, indicating a relationship between the two entities as the method is a part of the class."", ""close()""); (""close()"", ""The close() method is called on an instance, showing a relationship between the method and the instance it is being called on."", ""instance"")"
Creating a pipe using Java IO is done via the PipedOutputStream and PipedInputStream classes.,"(""PipedOutputStream"", ""Both PipedOutputStream and PipedInputStream are used together to create a pipe in Java IO, indicating a relationship between the two classes."", ""PipedInputStream""); (""PipedOutputStream"", ""PipedOutputStream is part of the Java IO package, indicating a relationship between the class and the package."", ""Java IO"")"
"If the AtomicReferenceArray has a generic type, the get() method returns objects of that type.","(""AtomicReferenceArray"", ""The get() method is a part of the AtomicReferenceArray class, indicating a relationship between the two."", ""get()"")"
"For instance, if the generic type is String, then you can call get() like this:",NULL
The set() method sets the value of an element with a specific index.,NULL
The index and value is passed as parameters to the set() method.,"(""Index"", ""The index is passed as a parameter to the set() method, indicating a relationship between the two."", ""Set"")"
"The compareAndSet() method of the AtomicReferenceArray can compare the current reference stored in a given element with an expected reference, and if the references are the same, swap the current reference with a new reference.",NULL
You should check out the JavaDoc for the AtomicReferenceArray class to learn more about those methods.,"(""AtomicReferenceArray"", ""The AtomicReferenceArray class is related to JavaDoc because the JavaDoc is a documentation package that provides information about the AtomicReferenceArray class."", ""JavaDoc"")"
The AtomicStampedReference class provides an object reference variable which can be read and written atomically.,NULL
"The reference and stamp can be swapped using a single atomic compare-and-swap operation, via the compareAndSet() method.","(""CompareAndSet"", ""The compareAndSet method is related to the reference because it is used to swap the reference and stamp."", ""reference""); (""CompareAndSet"", ""The compareAndSet method is related to the stamp because it is used to swap the reference and stamp."", ""stamp"")"
You can get the reference stored in an AtomicStampedReference using the AtomicStampedReference's getReference() method.,NULL
If you have an untyped AtomicStampedReference then the getReference() method returns an Object reference.,"(""AtomicStampedReference"", ""The getReference() method is a part of the AtomicStampedReference class, indicating a relationship between the two."", ""getReference()""); (""getReference()"", ""The getReference() method returns an Object reference, indicating a relationship between the method and the Object class."", ""Object"")"
If you have a typed AtomicStampedReference then getReference() returns a reference to the type you declared on the AtomicStampedReference variable when you created it.,"(""AtomicStampedReference"", ""The getReference method is related to the AtomicStampedReference class because it is used to retrieve a reference from the AtomicStampedReference variable."", ""getReference""); (""AtomicStampedReference variable"", ""The AtomicStampedReference variable is related to the AtomicStampedReference class because it is an instance of the class."", ""AtomicStampedReference"")"
Notice how it is necessary to cast the reference returned by getReference() to a String because getReference() returns an Object reference when the AtomicStampedReference is untyped.,"(""AtomicStampedReference"", ""The getReference method is related to the AtomicStampedReference class because it is mentioned as a method that can be called on an AtomicStampedReference object."", ""getReference""); (""getReference"", ""The getReference method is related to the String class because it is necessary to cast the reference returned by getReference to a String."", ""String""); (""getReference"", ""The getReference method is related to the Object class because getReference returns an Object reference when the AtomicStampedReference is untyped."", ""Object""); (""AtomicStampedReference"", ""The AtomicStampedReference class is related to the String class because the reference returned by getReference needs to be cast to a String, implying that the AtomicStampedReference can hold a String value."", ""String"")"
Notice how it is no longer necessary to cast the referenced returned by getReference() because the compiler knows it will return a String reference.,NULL
The AtomicStampedReference also contains a getStamp() method which can be used to obtain the internally stored stamp.,NULL
"You can obtain both reference and stamp from an AtomicStampedReference in a single, atomic operation using the get() method.","(""AtomicStampedReference"", ""The get() method is a part of the AtomicStampedReference class, indicating a relationship between the two."", ""get()""); (""AtomicStampedReference"", ""The AtomicStampedReference class contains a reference, indicating a relationship between the two."", ""reference""); (""AtomicStampedReference"", ""The AtomicStampedReference class contains a stamp, indicating a relationship between the two."", ""stamp""); (""get()"", ""The get() method returns a reference, indicating a relationship between the two."", ""reference"")"
The get() method returns the reference as return value from the method.,"(""Get"", ""The get() method returns the reference as return value from the method, indicating that Get is related to Reference as it returns a Reference."", ""Reference"")"
The stamp is inserted into an int[] array that is passed as parameter to the get() method.,"(""Int[]"", ""The Int[] array is passed as a parameter to the Get() method, indicating a relationship between the two."", ""Get()""); (""Array"", ""The Array class is related to the Get() method because the method operates on an array, specifically the Int[] array."", ""Get()"")"
You can set the reference stored in an AtomicStampedReference instance using its set() method.,"(""AtomicStampedReference"", ""The AtomicStampedReference class has a set method, indicating a relationship between the class and its method."", ""set""); (""set"", ""The set method is used on an instance of the AtomicStampedReference class, indicating a relationship between the method and the instance."", ""instance"")"
In an untyped AtomicStampedReference instance the set() method takes an Object reference as first parameter.,"(""AtomicStampedReference"", ""The set method is a part of the AtomicStampedReference class, indicating a relationship between the two entities."", ""set""); (""set"", ""The set method takes an Object reference as a parameter, indicating a relationship between the set method and the Object class."", ""Object"")"
In a typed AtomicStampedReference the set() method takes whatever type as parameter you declared as its type when you declared the AtomicStampedReference.,NULL
"The compareAndSet() method can compare the reference stored in the AtomicStampedReference instance with an expected reference, and the stored stamp with an expected stamp, and if they two references and stamps are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicStampedReference instance.","(""CompareAndSet"", ""The compareAndSet method is used in conjunction with the AtomicStampedReference instance to compare and set references."", ""AtomicStampedReference""); (""CompareAndSet"", ""The compareAndSet method uses the equals method for comparison, but it checks for reference equality (==) instead of object equality."", ""Equals"")"
If compareAndSet() sets a new reference in the AtomicStampedReference the compareAndSet() method returns true.,NULL
This example first creates an AtomicStampedReference and then uses compareAndSet() to swap the reference and stamp.,NULL
After the first compareAndSet() call the example attempts to swap the reference and stamp two times without success.,"(""CompareAndSet"", ""The source entity CompareAndSet is related to the target entity Reference because the text mentions 'swap the reference' in the context of the compareAndSet() call."", ""Reference""); (""CompareAndSet"", ""The source entity CompareAndSet is related to the target entity Stamp because the text mentions 'swap the reference and stamp' in the context of the compareAndSet() call."", ""Stamp"")"
"The first time the initialRef is passed as expected reference, but the internally stored reference is newRef at this time, so the compareAndSet() call fails.","(""Initialref"", ""The initialRef is passed as an expected reference to the compareAndSet() method, indicating a relationship between the two."", ""Compareandset"")"
"The second time the initialStamp is passed as the expected stamp, but the internally stored stamp is newStamp at this time, so the compareAndSet() call fails.","(""InitialStamp"", ""InitialStamp is passed to the CompareAndSet method as the expected stamp"", ""CompareAndSet""); (""NewStamp"", ""NewStamp is the internally stored stamp that causes the CompareAndSet method to fail"", ""CompareAndSet"")"
"The ceilingEntry() is thus similar to the ceilingKey() method, except the ceilingKey() method only returns the key, and ceilingKey() returns a Map.Entry object containing both the key and value.","(""CeilingEntry"", ""CeilingEntry is similar to CeilingKey, except CeilingKey returns only the key, while CeilingEntry returns a Map.Entry object containing both the key and value."", ""CeilingKey""); (""CeilingEntry"", ""CeilingEntry returns a Map.Entry object, indicating a relationship between the CeilingEntry method and the Map.Entry class."", ""Map.Entry"")"
"The floorEntry returned in the example above will contain the key + value pair ""c"" + ""3"" , because key ""c"" is the greatest key which is lower than or equal to the parameter value ""c"" passed to the floorEntry() method.","(""FloorEntry"", ""The floorEntry is related to the key because it contains the key + value pair."", ""Key""); (""Floorentry"", ""The floorEntry method is related to the FloorEntry class because it returns a FloorEntry object."", ""FloorEntry"")"
"In the example above the returned ceilingEntry will contain the key ""c"" and the value ""3"", since the key ""c"" is the smallest key that is greater than or equal to the parameter value ""c"" passed to ceilingEntry() .",NULL
The higherEntry() method returns the key + value stored for the smallest key that is higher than the parameter value passed to the higherEntry() method.,NULL
"The higherEntry returned in the example above will contain the key + value pair ""d"" + ""4"" because the key ""d"" is the lowest key which is higher than the parameter value ""c"" passed to the higherEntry() method.","(""HigherEntry"", ""The HigherEntry is related to the Key because it contains the key + value pair."", ""Key""); (""HigherEntry"", ""The HigherEntry method is related to the HigherEntry class because it is a method of that class."", ""HigherEntry""); (""Key"", ""The Key is related to the Value because they are paired together in the higherEntry."", ""Value"")"
"The lowerEntry returned in this example will be the key + value pair ""a"" + ""1"" since ""a"" is the highest key which is lower than the parameter value ""b"" passed to the lowerEntry() method.","(""LowerEntry"", ""The lowerEntry is related to the lowerEntry() method because the method is used to retrieve the lowerEntry.""}"", ""Lowerentry""); (""Key"", ""The Key and Value are related because they form a pair in the example given.""}"", ""Value""); (""Key"", ""The Key is related to the Pair because the key is part of the pair.""}"", ""Pair""); (""Value"", ""The Value is related to the Pair because the value is part of the pair.""}"", ""Pair""); (""Lowerentry"", ""The lowerEntry() method is related to the Key because the method uses the key to determine the lower entry.""}"", ""Key""); (""Lowerentry"", ""The lowerEntry() method is related to the Value because the method uses the value to determine the lower entry.""}"", ""Value"")"
"The pollFirstEntry() method returns and removes the ""first"" entry (key + value) in the NavigableMap or null if the map is empty.",NULL
"The pollLastEntry() returns and removes the ""last"" element in the map or null if the map is empty.",NULL
In Java 6 to 13 there is only one implementation of the NavigableSet interface in the java.util package: The java.util.TreeSet class.,NULL
There is an implementation in the java.util.concurrent package called ConcurrentSkipListSet but that is outside the scope of this trail.,NULL
To create a Java NavigableSet you must create an instance of one of the classes implementing the NavigableSet interface.,NULL
Here is an example of creating an instance of the class TreeSet which implements the NavigableSet interface:,NULL
"The descendingIterator() method allows you to iterate the elements of the NavigableSet (which is also a SortedSet) in reverse order, without changing the order of the elements internally.","(""NavigableSet"", ""The descendingIterator() method is a part of the NavigableSet class, indicating a relationship between the two."", ""descendingIterator()"")"
"The headSet() method returns a view of the original NavigableSet which only contains elements that are ""less than"" the given element.",NULL
"The floor() method does the opposite of the ceiling() method, meaning it returns the greatest element that is less than or equal to the given parameter value.",NULL
The higher() method returns the least (smallest) element in this set that is greater than (not equal too) the element passed as parameter to the higher() method.,NULL
"The tailSet() method works the same way as the headSet() method, except it returns all elements that are equal to or higher than the given parameter element.",NULL
The ceiling() method returns the least (smallest) element in this set that is greater than or equal to the element passed as parameter to the ceiling() method.,NULL
"The lower() method does the opposite of the higher() method, meaning it returns the highest element that is less than (not equal to) the given parameter.",NULL
"The pollFirst() method returns and removes the ""first"" element in the NavigableSet or null if the set is empty.",NULL
"The Java Properties class can write the key, value pairs to a properties file on disk, and read the properties back in again.","(""Java Properties"", ""Java Properties is another name for the Properties class"", ""Properties""); (""Properties"", ""The Properties class can write the key, value pairs to a properties file"", ""key""); (""Properties"", ""The Properties class can write the key, value pairs to a properties file"", ""value""); (""Properties"", ""The Properties class can write the key, value pairs to a properties file"", ""properties file""); (""properties file"", ""the properties file is located on disk"", ""disk"")"
To use the Java Properties class you must first create a Properties instance.,"(""Properties"", ""The Properties class is part of the Java package, indicating a relationship between the two entities."", ""Java"")"
"The Java Properties class, java.util.Properties, is like a Java Map of Java String key and value pairs.","(""java.util.Properties"", ""java.util.Properties is compared to Java Map, indicating a relationship between the two classes"", ""Java Map""); (""java.util.Properties"", ""java.util.Properties is described as a map of Java String key and value pairs, indicating a relationship between java.util.Properties and Java String"", ""Java String"")"
"To get properties from a Java Properties object you use the getProperty() method, passing the key of the property to get as parameter.",NULL
"You can remove a property from a Java Properties instance using its remove() method, passing as parameter to remove() the key for the property to remove.","(""Properties"", ""The Properties class has a remove method, indicating a relationship between the two."", ""remove""); (""Java"", ""The Properties class is part of the Java package, indicating a relationship between the two."", ""Properties"")"
You store the contents of a Properties object via its store() method.,NULL
You can also load properties stored in a property file back into a Java Properties object via its load() method.,"(""Java Properties"", ""The Java Properties class has a load() method, indicating a relationship between the two entities as the method is a part of the class."", ""load()""); (""Properties"", ""The Properties class is related to the load() method because the method is used to load properties into a Properties object, suggesting a connection between the class and the method."", ""load()"")"
By default the load() method will assume that the loaded file is encoded using ISO-8859-1 (Latin-1).,NULL
The Java Properties class can also write the key-value pairs stored in it to an XML file via its storeToXML().,"(""Java Properties"", ""The Java Properties class has a method called storeToXML(), which indicates a relationship between the class and the method."", ""storeToXML()"")"
"Notice how the comment passed to the storeToXML() method is enclosed in a comment XML element, and not in an XML comment (<!-- -->) .",NULL
By default the loadFromXML() method will assume that the XML file is stored using the UTF-8 encoding.,NULL
It is possible to load properties into a Java Properties from a file that is available on the classpath.,"(""Properties"", ""The Properties class has a method to load properties, so Properties and load are related."", ""load""); (""Java"", ""Java is the programming language in which the Properties class is used, so Java and Properties are related."", ""Properties""); (""classpath"", ""A file can be made available on the classpath, so classpath and file are related."", ""file""); (""Properties"", ""Properties can be loaded from a file on the classpath, so Properties and classpath are related."", ""classpath""); (""load"", ""The load method can be used to load properties from a file, so load and file are related."", ""file""); (""Java"", ""Java uses the classpath to find and load classes and other resources, so Java and classpath are related."", ""classpath""); (""Java"", ""Java can read and write files, so Java and file are related."", ""file""); (""load"", ""The load method can load properties from a file on the classpath, so load and classpath are related."", ""classpath""); (""Properties"", ""Properties can be loaded from a file, so Properties and file are related."", ""file"")"
"That file could thus be located inside the same JAR file as the application loading the properties, or inside another JAR file or directory available on the Java classpath when your Java application is executed.","(""File"", ""The file is located inside the same Jar file as the application loading the properties"", ""Jar""); (""Jar"", ""The file could be located inside another Jar file or directory available on the Java classpath"", ""Directory""); (""Java"", ""The Java application is executed and loads the properties"", ""Application""); (""Application"", ""The application loads the properties"", ""Properties""); (""Classpath"", ""The Java classpath is used when the Java application is executed"", ""Java""); (""Directory"", ""The directory is available on the Java classpath"", ""Classpath"")"
In the example below I obtain it from the class that contains the main() method of my application:,"(""Class"", ""The class contains the main() method, indicating a relationship between the class and the method."", ""Method""); (""Application"", ""The application is related to the class because it is stated that the class contains the main() method of the application."", ""Class"")"
Once I have the Class instance I can call its getResourceAsStream() method which returns a Java InputStream referencing the file.,"(""Class"", ""The Class instance has a getResourceAsStream() method, indicating a relationship between the two."", ""getResourceAsStream()""); (""getResourceAsStream()"", ""The getResourceAsStream() method returns an InputStream, indicating a relationship between the two."", ""InputStream"")"
Here is an example of obtaining a reference to a file from the classpath:,NULL
"If you put it into a subdirectory, the path passed to getResourceAsStream() should reflect that.",NULL
"Using the InputStream you can load the file into a Java Properties instance, using either the load() or loadFromXML() methods explained earlier in this Java Properties tutorial.","(""InputStream"", ""The InputStream is used to load the file into a Java Properties instance"", ""Java Properties""); (""Java Properties"", ""The load() method is used in conjunction with Java Properties"", ""load()""); (""Java Properties"", ""The loadFromXML() method is used in conjunction with Java Properties"", ""loadFromXML()""); (""InputStream"", ""The InputStream is used with the load() method to load the file"", ""load()"")"
"The ResourceBundle class is covered as part of that tutorial, in the Java ResourceBundle tutorial.",NULL
The Java Properties class has the ability to provide default property values for properties that do not have any key registered in the Properties instance.,"(""Java Properties"", ""The Java Properties class has the ability to provide default property values for properties that do not have any key registered in the Properties instance, indicating a relationship between Java Properties and Properties."", ""Properties"")"
Here is an example of calling getProperty() with a default value:,NULL
"If the Properties instance does not contain a property for the key preferredLanguage, then the value Danish will be returned - instead of returning null which would have been returned if no default value had been passed to getProperty().","(""Properties"", ""The Properties class contains a method called getProperty, which is used to retrieve a property value."", ""getProperty""); (""Properties"", ""The Properties instance is checked for a property called preferredLanguage, indicating a relationship between the Properties class and the preferredLanguage property."", ""preferredLanguage"")"
The Java Properties class can be instantiated with another Properties instance containing default values to use when the newly created Properties instance does not contain a value for a requested property key.,"(""Java Properties"", ""The Java Properties class can be instantiated with another Properties instance, indicating a relationship between the two."", ""Properties instance""); (""Properties"", ""The Properties class is related to the Properties instance as the instance is an example of the class."", ""Properties instance"")"
"The Java Properties class is a subclass of the Java Hashtable class, and as I will show you - this is actually a design mistake!",NULL
"It is a great example of when the classic ""Is a / Has a"" OOP rule about when to use inheritance vs. composition fails.","(""OOP"", ""OOP is related to Inheritance because it is a fundamental concept in Object-Oriented Programming that utilizes inheritance."", ""Inheritance""); (""OOP"", ""OOP is related to Composition because it is another fundamental concept in Object-Oriented Programming that utilizes composition."", ""Composition"")"
"Being a subclass of Hashtable, you can actually use the get() and put() method of the Hashtable class, which allow the use of non-string keys and values.","(""Hashtable"", ""The get() method is related to the Hashtable class because it is a method that can be used with Hashtable."", ""get()"")"
"This defeats the purpose of the Properties class, which is to function as a string,string map.","(""Properties"", ""The Properties class is related to string because it is designed to function as a string, string map."", ""string"")"
Notice how it is possible to call put() with non-string values.,NULL
"If instead the value passed to put() had been two strings, then it would have worked as expected.",NULL
Notice how the second value passed to put() is now also a string.,NULL
"Even if you can get get() and put() to work, I would recommend that you do not use these methods.",NULL
"Using that formulation, Properties would not have been made a subclass of Hashtable, because Properties should not be usable as a Hashtable .",NULL
"The Java Queue interface, java.util.Queue represents a data structure designed to have elements inserted at the end of the queue, and elements removed from the beginning of the queue.",NULL
"There are also Queue implementations in the java.util.concurrent package, but I will leave the concurrency utilities out of this tutorial.",NULL
"The add() and offer() methods differ in how the behave if the Queue is full, so no more elements can be added.","(""Add"", ""The Add method is related to the Queue class because it is used to add elements to the Queue."", ""Queue""); (""Offer"", ""The Offer method is related to the Queue class because it is used to offer elements to the Queue."", ""Queue"")"
Here are two examples of adding elements to a Java Queue via its add() and offer() methods:,"(""Queue"", ""The Queue class has an add() method, indicating a relationship between the two."", ""add()""); (""Queue"", ""The Queue class has an offer() method, indicating a relationship between the two."", ""offer()"")"
To take an element from a Java Queue you can call either its poll() or remove() method.,"(""Queue"", ""The Queue class has a poll() method, indicating a relationship between the two."", ""poll()""); (""Queue"", ""The Queue class has a remove() method, indicating a relationship between the two."", ""remove()"")"
The poll() and remove() both removes the first element in the Queue.,"(""POLL"", ""The poll() method is related to the Queue class because it operates on the Queue, specifically removing the first element."", ""QUEUE""); (""REMOVE"", ""The remove() method is related to the Queue class because it also operates on the Queue, removing the first element, similar to the poll() method."", ""QUEUE"")"
Here are two examples of taking an element from a Java Queue using its poll() and remove() methods:,"(""Queue"", ""The Queue class has a poll() method, indicating a relationship between the two."", ""poll()""); (""Queue"", ""The Queue class has a remove() method, indicating a relationship between the two."", ""remove()"")"
"The call to poll() will remove the first element of the Queue - which is the first Java String instance added - ""element 1"".","(""Queue"", ""The Queue class has a method called poll(), indicating a relationship between the two."", ""poll""); (""Queue"", ""The Queue class is used to hold Java String instances, indicating a relationship between the two."", ""String"")"
"The call to rmove() will remove the second element of the Queue - which after the first poll() call is now the String instance added - ""element 2"".","(""Queue"", ""The Queue class has a method called rmove, indicating a relationship between the two."", ""rmove""); (""Queue"", ""The Queue class has a method called poll, indicating a relationship between the two."", ""poll"")"
Here is an example of peeking at the first element of a Java Queue using the element() method:,"(""Queue"", ""The Queue class has an element() method, indicating a relationship between the two."", ""element()""); (""Java"", ""The Queue class is part of the Java package, indicating a relationship between the two."", ""Queue"")"
The peek() works like the element() method except it does not throw an exception if the Queue is empty.,"(""Peek"", ""The peek() method is related to the Queue class because it operates on a Queue object."", ""Queue""); (""Element"", ""The element() method is related to the Queue class because it operates on a Queue object."", ""Queue"")"
Here is an example of peeking at the first element of a Queue using the peek() method:,NULL
"To remove elements from a Java Queue, you call the remove() method.",NULL
Here is an example of removing all elements from a Java Queue via its clear() method:,NULL
You can read the number of elements stored in a Java Queue via its size() method.,NULL
Here is an example of obtaining the size of a Java Queue via its size() method:,"(""Queue"", ""The Queue class has a size() method, indicating a relationship between the two as the method is used to obtain the size of a Queue object."", ""size()""); (""Java"", ""The Java package contains the Queue class, indicating a relationship between the two as Queue is a part of the Java package."", ""Queue"")"
You can check if a Java Queue contains a certain element via its contains() method.,NULL
"The contains() method will return true if the Queue contains the given element, and false if not.",NULL
"The contains() method is actually inherited from the Collection interface, but in practice that doesn't matter.",NULL
"If the Set is not typed, using Java Generics, then you can even mix objects of different types (classes) in the same Set.","(""Set"", ""The Set is using Java Generics, indicating a relationship between the two entities."", ""Java Generics""); (""Set"", ""The Set contains objects, indicating a relationship between the two entities."", ""objects"")"
This example creates a HashSet which is one of the classes in the Java APIs that implement the Set interface.,"(""HashSet"", ""HashSet is related to Set because it implements the Set interface"", ""Set""); (""HashSet"", ""HashSet is related to Java APIs because it is one of the classes in the Java APIs"", ""Java APIs"")"
"In other words, the order in which the elements whould be sorted if you used a Collections.sort() on a List or array containing these elements.","(""Collections"", ""The Collections class contains the sort method, indicating a clear relationship between the two entities."", ""sort""); (""List"", ""The List class can be used with the sort method, as indicated by the phrase 'on a List or array containing these elements', showing a relationship between the List class and the sort method."", ""sort""); (""array"", ""The array class can be used with the sort method, as indicated by the phrase 'on a List or array containing these elements', showing a relationship between the array class and the sort method."", ""sort""); (""Collections"", ""The Collections class is related to the List class, as the sort method from the Collections class can be used on a List."", ""List""); (""Collections"", ""The Collections class is related to the array class, as the sort method from the Collections class can be used on an array."", ""array"")"
The Java Set static factory methods are called of() and take either zero or more parameters.,NULL
"Here is first an example of creating an empty, immutable Set using Set.of() :",NULL
Specifying a generic type of the Set returned by Set.of() looks like this:,NULL
Here is an example of how creating a Set containing elements using the Set.of() method looks:,NULL
The three add() calls add a String instance to the set.,"(""Add"", ""The add() method is used to add a String instance to the set, indicating a relationship between the add method and the String class."", ""String"")"
You obtain an Iterator from a Set by calling the iterator() method.,"(""Iterator"", ""Iterator is obtained from Set"", ""Set""); (""Set"", ""The iterator() method is called on a Set"", ""iterator()"")"
You can remove all elements from a Java Set using the clear() method.,NULL
The Java Set interface as a method called removeAll() which removes all elements in the Set which are also present in another Collection.,"(""Set"", ""The Set class has a method called removeAll(), indicating a relationship between the two."", ""removeAll()""); (""removeAll()"", ""The removeAll() method is related to the Collection class because it removes elements present in another Collection, indicating a relationship between the two."", ""Collection"")"
"The element three has been removed, because it was present in set2, which was given as parameter to set.removeAll(set2) .","(""Set"", ""The class Set has a method called Removeall, indicating a relationship between the two."", ""Removeall""); (""Set2"", ""Set2 is an instance of the class Set, indicating a relationship between the two."", ""Set"")"
You can check the size of a Java Set using the size() method.,NULL
"You can check if a Java Set is empty, meaning it contains no elements, by calling the isEmpty() method on the Set.",NULL
You can also check if a Set is empty by comparing the value returned by the size() method with 0.,NULL
You can check if a Java Set contains a given element (object) by calling the contains() method.,NULL
"You can convert a Java Set to a Java List by creating a List and calling its addAll() method, passing the Set as parameter to the addAll() method.","(""Set"", ""The Set is converted to a List by calling the addAll() method on the List and passing the Set as a parameter."", ""List""); (""List"", ""The List has an addAll() method that is used to convert a Set to a List."", ""addAll()"")"
"The Java SortedMap interface, java.util.SortedMap, is a subtype of the java.util.Map interface, with the addition that the elements stored in a Java SortedMap map are sorted internally.","(""Java SortedMap"", ""Java SortedMap is a subtype of java.util.Map, indicating an inheritance relationship between the two classes"", ""java.util.Map""); (""java.util.SortedMap"", ""java.util.SortedMap is the package where the Java SortedMap class is located, indicating a containment relationship between the package and the class"", ""Java SortedMap"")"
Java comes with a built-in implementation of the Java SortedMap interface called TreeMap (java.util.TreeMap).,"(""TreeMap"", ""TreeMap is an implementation of the Java SortedMap interface"", ""Java SortedMap""); (""TreeMap"", ""TreeMap is located in the java.util package"", ""java.util.TreeMap"")"
But it is also possible to iterate the elements in descending order using the method TreeMap.descendingKeySet().,"(""TreeMap"", ""TreeMap is a class that has a method called descendingKeySet()"", ""TreeMap.descendingKeySet()""); (""TreeMap"", ""TreeMap is a class that has a method called descendingKeySet()"", ""descendingKeySet"")"
"You iterate the keys of a SortedMap by calling its keySet() method, like this:",NULL
"Remember, if you want to iterate the keys in descending order rather than ascending order, use the sortedMap.descendingKeySet().iterator() method, like this:","(""Sortedmap"", ""The Sortedmap class has a method called descendingKeySet() that returns a set of keys in descending order, which is related to the Descendingkeyset method."", ""Descendingkeyset""); (""Descendingkeyset"", ""The Descendingkeyset method is related to the Iterator method because the iterator() method is called on the result of descendingKeySet() to iterate over the keys in descending order."", ""Iterator"")"
"If your Java SortedMap was created using a Comparator, you can obtain the Comparator used via the SortedMap comparator() method.","(""SortedMap"", ""The SortedMap class has a relationship with the comparator() method because the method is used to obtain the Comparator used by the SortedMap."", ""comparator()""); (""SortedMap"", ""The SortedMap class has a relationship with the Comparator class because the Comparator is used to create the SortedMap."", ""Comparator"")"
Here is an example of obtaining the first key of a SortedMap via its firstKey() method:,NULL
Here is an example of obtaining the last key of a SortedMap via its lastKey() method:,NULL
The SortedMap interface has a method named headMap() which returns a new Map which contains the first elements of the SortedMap according to the sort order used.,"(""SortedMap"", ""The SortedMap interface has a method named headMap() which returns a new Map, indicating that headMap() is a method of the SortedMap interface."", ""headMap()""); (""headMap()"", ""The headMap() method returns a new Map, indicating that headMap() is related to Map as its return type."", ""Map"")"
The headMap() method takes a parameter that acts as a delimiter for what elements gets included in the returned head map.,NULL
Here is an example of obtaining a head map from a SortedMap via its headMap() method:,NULL
The SortedMap interface has a method named tailMap() which returns a new Map which contains the last elements of the SortedMap according to the sort order used.,"(""SortedMap"", ""The SortedMap interface has a method named tailMap(), indicating that tailMap() is a method of the SortedMap interface."", ""tailMap()""); (""tailMap()"", ""The tailMap() method returns a new Map, indicating that the result of the tailMap() method is related to the Map interface."", ""Map"")"
The tailMap() method takes a parameter that acts as a delimiter for what elements gets included in the returned tail map.,NULL
All elements with a key that is equal to or larger than the parameter passed to the tailMap() method.,"(""Tailmap"", ""The tailMap() method takes a parameter, indicating that the method and the parameter are related as the method uses the parameter to perform its operation."", ""Parameter""); (""Key"", ""The key is compared to the parameter passed to the tailMap() method, indicating that the key and the parameter are related as they are used in a comparison."", ""Parameter"")"
"The tail map returned will contain the key, value pairs (""c"", ""3""), (""d"", ""4"") and (""e"", ""5""), since ""c"", ""d"" and ""e"" are larger than or equal to the ""c"" passed as parameter to tailMap() .",NULL
The Java SortedMap also has a method named subMap() which can return a new Map which is a submap of the SortedMap.,"(""Java SortedMap"", ""The Java SortedMap has a method named subMap(), indicating a relationship between the class and the method."", ""subMap()""); (""subMap()"", ""The subMap() method can return a new Map, indicating a relationship between the method and the class it returns."", ""Map"")"
The subMap() method takes two parameters which act as delimiters for what elements are included in the returned submap.,NULL
"The Java SortedSet interface, java.util.SortedSet, is a subtype of the java.util.Set interface.","(""java.util.SortedSet"", ""java.util.SortedSet is a subtype of java.util.Set, indicating an inheritance relationship between the two entities"", ""java.util.Set""); (""SortedSet"", ""SortedSet is implemented by java.util.SortedSet, indicating a realization relationship between the interface and its subtype"", ""java.util.SortedSet"")"
The Java Collections API only has one implementation of the Java SortedSet interface - the java.util.TreeSet class.,"(""Java Collections API"", ""The Java Collections API has an interface called Java SortedSet"", ""Java SortedSet""); (""Java SortedSet"", ""The Java SortedSet interface has an implementation called java.util.TreeSet"", ""java.util.TreeSet"")"
"The java.util.concurrent package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail.",NULL
"It it possible to pass a Comparator, java.util.Comparator implementation to the constructor of the TreeSet.","(""TreeSet"", ""TreeSet is related to Comparator because it is possible to pass a Comparator implementation to the constructor of the TreeSet"", ""Comparator""); (""Comparator"", ""Comparator is related to java.util because Comparator is an implementation in the java.util package"", ""java.util"")"
But it is also possible to iterate the elements in descending order using the method TreeSet.descendingIterator().,NULL
"If you created your SortedSet with a Comparator, you can obtain that Comparator via the SortedSet comparator() method.","(""SortedSet"", ""The SortedSet class has a relationship with the comparator() method because it is a method that can be called on a SortedSet object to obtain its Comparator."", ""comparator()""); (""SortedSet"", ""The SortedSet class has a relationship with the Comparator class because a SortedSet can be created with a Comparator, and the comparator() method returns the Comparator used to create the SortedSet."", ""Comparator"")"
Here is an example of obtaining the Comparator used by a SortedSet via the comparator() method:,"(""SortedSet"", ""The comparator() method is used by the SortedSet class, indicating a relationship between the two."", ""comparator()"")"
You add elements to a Java SortedSet in the same way you do with a normal Java Set - via its add() method.,"(""SortedSet"", ""The SortedSet class has an add method to add elements to it"", ""add""); (""Set"", ""The Set class also has an add method to add elements to it"", ""add"")"
"To remove an element from a SortedSet you call its remove() method, passing the element to remove as parameter.",NULL
You can get the last element of a SortedSet according to its sort order by calling the last() method of the SortedSet.,NULL
"You call the SortedSet iterator() method which returns an Iterator, and then you can iterate the elements via that.","(""SortedSet"", ""The SortedSet class has an iterator() method that is used to return an Iterator."", ""iterator()"")"
"The Java SortedSet interface has a method named headSet() which returns another SortedSet with all elements that are smaller than (ahead of) a given parameter value, according to the sort order used by the SortedSet.",NULL
"After running this code the headSet will contain the elements ""a"" and ""b"" since these two elements are smaller than (ahead of) the parameter value ""c"" that was passed to the headSet() method.","(""HeadSet"", ""The HeadSet class contains the HeadSet() method, indicating a relationship between the two entities as the method is part of the class."", ""HeadSet()"")"
"The Java SortedSet interface has a method named setSet() which returns another SortedSet with all elements that are greater than or equal to (tailing) a given parameter value, according to the sort order used by the SortedSet.",NULL
Here is an example of obtaining a tail set from a Java SortedSet via its tailSet() method:,NULL
"After running this code the tailSet will contain the elements ""c"", ""d"" and ""e"", since these three elements are greater than or equal to (tailing) the parameter value ""c"" that was passed to the tailSet() method.","(""Tailset"", ""The Tailset method is related to the Codes package because it is being used in the code."", ""Codes"")"
The subSet() method takes two parameter values which specify what elements the returned SortedSet should contain.,NULL
Here is an example of obtaining a subset of a Java SortedSet via its subSet() method:,"(""SortedSet"", ""The SortedSet class has a method called subSet, which indicates a relationship between the two entities."", ""subSet""); (""Java"", ""The Java package contains the SortedSet class, indicating a relationship between the two entities."", ""SortedSet"")"
Notice how there is no longer a cast of the object returned from iterator.next() needed.,"(""Iterator"", ""The Iterator class has a method called Next, indicating a relationship between the two."", ""Next""); (""Next"", ""The Next method returns an Object, indicating a relationship between the two."", ""Object"")"
"Because the generic type of the SortedSet is String, the compiler knows that the iterator is an Iterato<String>, so next() return String objects.","(""SortedSet"", ""The SortedSet class uses an iterator to iterate over its elements."", ""iterator""); (""iterator"", ""The iterator has a next method that returns the next element in the iteration."", ""next""); (""SortedSet"", ""The SortedSet class is defined with a generic type of String, indicating that it contains String objects."", ""String""); (""iterator"", ""The iterator returns String objects, as defined by the generic type of the SortedSet."", ""String"")"
For objects to have a natural order they must implement the interface java.lang.Comparable.,"(""Java"", ""Java is a package that contains the Lang package"", ""Lang""); (""Lang"", ""Lang is a package that contains the Comparable interface"", ""Comparable"")"
"The compareTo() method should compare this object to another object, return an int value.",NULL
"So, if a string is less than another string by alphabetic comparison it will return a negative number from the compareTo() method.",NULL
When you implement the compareTo() method in your own classes you will have to decide how these objects should be compared to each other.,NULL
Notice how the Collections.sort() method now takes a java.util.Comparator as parameter in addition to the List.,"(""Collections"", ""The Collections class contains the sort method."", ""sort""); (""sort"", ""The sort method takes a java.util.Comparator as a parameter."", ""java.util.Comparator""); (""sort"", ""The sort method takes a List as a parameter."", ""List""); (""Collections"", ""The Collections class is related to java.util.Comparator through the sort method."", ""java.util.Comparator"")"
"There are a few more requirements to the implementation of the compare() method, but these are the primary requirements.",NULL
"If you want to compare objects by more than one factor, start by comparing by the first factor (e.g first name).",NULL
"Then, if the first factors are equal, compare by the second factor (e.g.",NULL
"The Java Stack class actually implements the Java List interface, but you rarely use a Stack as a List - except perhaps if you need to inspect all elements currently stored on the stack.","(""Stack"", ""The Stack class implements the List interface"", ""List""); (""Stack"", ""The Java Stack class is part of the Java package"", ""Java"")"
"Please note, that the Java Stack class is a subclass of Vector, an older Java class which is synchronized.",NULL
"Additionally, the Vector class uses several older (no longer recommended) parts of Java, like the Enumeration which is superseded by the Iterator interface.","(""Vector"", ""The Vector class uses the Enumeration, indicating a relationship between the two entities."", ""Enumeration""); (""Vector"", ""The Vector class is related to the Iterator interface because the Enumeration used by Vector is superseded by the Iterator interface."", ""Iterator""); (""Vector"", ""The Vector class is part of the Java package, indicating a relationship between the two entities."", ""Java""); (""Enumeration"", ""The Enumeration is part of the Java package, indicating a relationship between the two entities."", ""Java"")"
To use a Java Stack you must first create an instance of the Stack class.,NULL
You pop an element off a Java Stack using the pop() method.,NULL
Here is an example of popping an element off a Stack using the pop() method:,NULL
"The Java Stack class has a method called peek() which enables you to see what the top element on the Stack is, without popping off the element.","(""Stack"", ""The Stack class has a method called peek(), indicating that peek() is a method of the Stack class."", ""peek()"")"
The String object is still present on the Stack after calling peek().,"(""String"", ""The String object is related to the Stack because it is present on the Stack after a certain operation."", ""Stack""); (""peek"", ""The peek method is related to the Stack because it is an operation called on the Stack."", ""Stack"")"
"You can search for an object on the stack to get it's index, using the search() method.",NULL
The object's equals() method is called on every object on the Stack to determine if the searched-for object is present on the Stack.,"(""Stack"", ""The Stack class contains objects, indicating a relationship between the two entities."", ""object""); (""object"", ""The equals() method is called on every object, indicating a relationship between the object class and the equals() method."", ""equals()"")"
"You can obtain the size of a Java Stack, meaning the number of elements currently stored on the Stack, via the Stack size() method.","(""Stack"", ""The Stack class has a method called size() to obtain its size."", ""size()""); (""Java"", ""The Stack class is part of the Java package."", ""Stack"")"
"After running this code the size variable will contain the value 3, since the Stack in the example contains 3 elements at the time its size() method is called.","(""Stack"", ""The Stack class has a size() method, indicating a relationship between the two."", ""size()""); (""size()"", ""The size() method is related to the size variable, as the method's return value is assigned to the variable."", ""size"")"
You do so by first obtaining a Stream from the Stack via the stream() method.,"(""Stream"", ""Stream is obtained from Stack via the stream() method"", ""Stack""); (""Stack"", ""Stack uses the stream() method to provide a Stream"", ""stream()"")"
"Notice, that this example uses a Java Lambda as parameter to the Stream.forEach() method.","(""Stream"", ""The Stream class has a method called forEach, indicating a relationship between the two entities."", ""forEach""); (""Java Lambda"", ""The Java Lambda is used as a parameter to the Stream.forEach() method, indicating a relationship between the Java Lambda class and the Stream class."", ""Stream"")"
"If B is 0.4, O is 2 and N is 5, then the calculation looks like this:","(""B"", ""B and O are related as they are part of the same calculation"", ""O""); (""B"", ""B and N are related as they are part of the same calculation"", ""N"")"
"With B = 0.4, O = 2 and N = 5, the calculation becomes:",NULL
The non-parallelizable part of the programs is 40% which out of a total time of 1 is equal to 0.4 .,NULL
"That means, that if you optimize the non-parallelizable (sequential) part by a factor of 2, and paralellize the parallelizable part by a factor of 5, the new optimized version of the program or algorithm would run a maximum of 2.77777 times faster than the old version.",NULL
Once a thread want to notify the waiting threads it calls notifyAll() on the object the waiting threads called wait() on.,"(""Thread"", ""Thread uses NotifyAll to notify waiting threads"", ""NotifyAll""); (""Thread"", ""Thread uses Wait to wait for notification"", ""Wait"")"
Just have the notifying thread call notify() on the object the waiting threads have called wait() on.,"(""Notifying"", ""The notifying thread calls notify() on the object."", ""Object""); (""Waiting"", ""The waiting threads call wait() on the object."", ""Object"")"
"To achive this each waiting thread must call wait() on its own, separate object.","(""Thread"", ""A thread must call the wait method to achieve the desired outcome"", ""Wait""); (""Thread"", ""Each thread must have its own separate object to call wait on"", ""Object"")"
When the notifying thread wants to notify a specific waiting thread it will call notify() on the object this specific thread has called wait() on.,"(""Notifying Thread"", ""The notifying thread calls the notify method to notify a waiting thread."", ""Notify""); (""Waiting Thread"", ""The waiting thread has called the wait method on an object."", ""Wait""); (""Notifying Thread"", ""The notifying thread wants to notify a specific waiting thread, indicating a relationship between the two threads."", ""Waiting Thread"")"
Threads calling lockWrite() first sets the state before the test (writeRequests++).,NULL
The lockWrite() method of a ReadWriteLock class shown below is an example of a test-and-set method.,NULL
A typical example of a set method is the unlock() method of a Lock class.,NULL
Then it tests the internal state against the access condition in the canGrantWriteAccess() method.,"(""Internal State"", ""Internal State is tested against the access condition in the CanGrantWriteAccess method, indicating a relationship between the internal state and the method."", ""CanGrantWriteAccess"")"
Java 5 comes with blocking queue implementations in the java.util.concurrent package.,"(""Java 5"", ""Java 5 comes with blocking queue implementations in the java.util.concurrent package, indicating that Java 5 is related to the java.util.concurrent package"", ""java.util.concurrent"")"
Notice how notifyAll() is only called from enqueue() and dequeue() if the queue size is equal to the size bounds (0 or limit).,"(""NotifyAll"", ""NotifyAll is called from Enqueue when the queue size is equal to the size bounds"", ""Enqueue""); (""NotifyAll"", ""NotifyAll is called from Dequeue when the queue size is equal to the size bounds"", ""Dequeue"")"
"If the queue size is not equal to either bound when enqueue() or dequeue() is called, there can be no threads waiting to either enqueue or dequeue items.","(""Queue"", ""The Queue class has a method called Enqueue, indicating a relationship between the two."", ""Enqueue""); (""Queue"", ""The Queue class has a method called Dequeue, indicating a relationship between the two."", ""Dequeue"")"
"If multiple threads had access to the same MyLock instance, the above lock() function would not be guaranteed to work.","(""MyLock"", ""The MyLock class has a lock method, indicating a relationship between the two entities."", ""lock""); (""thread"", ""Multiple threads have access to the same MyLock instance, indicating a relationship between the two entities."", ""MyLock"")"
Here is the code example from earlier with the lock() method turned into an atomic block of code using the synchronized keyword:,"(""Lock"", ""The Lock class is related to the Method because the lock() method is used within the context of a class"", ""Method""); (""Synchronized"", ""The Synchronized method is related to the Method because it is used to turn the lock() method into an atomic block of code"", ""Method"")"
Now the lock() method is synchronized so only one thread can executed it at a time on the same MyLock instance.,NULL
"The lock() method compares the variable locked to the expected value false and if locked is equal to this expected value, it swaps the variable's value to true .",NULL
From Java 5 you can get access to these functions in the CPU via some of the new atomic classes in the java.util.concurrent.atomic package.,"(""Java 5"", ""Java 5 provides access to functions in the CPU via some of the new atomic classes in the java.util.concurrent.atomic package"", ""java.util.concurrent.atomic""); (""java.util.concurrent.atomic"", ""java.util.concurrent.atomic package provides access to functions in the CPU via some of the new atomic classes"", ""CPU""); (""Java"", ""Java has a package called java.util.concurrent.atomic"", ""java.util.concurrent.atomic""); (""Java"", ""Java can get access to these functions in the CPU via some of the new atomic classes in the java.util.concurrent.atomic package"", ""CPU"")"
Here is an example showing how to implement the lock() method shown earlier using the AtomicBoolean class:,NULL
"This class has a compareAndSet() function which will compare the value of the AtomicBoolean instance to an expected value, and if has the expected value, it swaps the value with a new value.","(""Class"", ""The Class has a CompareAndSet method, indicating a relationship between the two entities."", ""CompareAndSet""); (""CompareAndSet"", ""The CompareAndSet method is used in conjunction with the AtomicBoolean class, suggesting a relationship between the two entities."", ""AtomicBoolean"")"
"The compareAndSet() method returns true if the value was swapped, and false if not.",NULL
Many of the concurrency utilities in the java.util.concurrent Java package are designed for use with this model.,NULL
Non-blocking IO means that when a worker starts an IO operation (e.g.,"(""FileInputStream"", ""The FileInputStream class contains the read method, which is used for IO operations."", ""read""); (""java.io"", ""The java.io package contains the FileInputStream class, which provides input/output functionality."", ""FileInputStream"")"
"When the IO operation finishes, the result of the IO operation ( e.g.",NULL
It just needs to know what channel to forward the job to (or send the message to etc.).,"(""CHANNEL"", ""The channel is related to the job because it is the destination for forwarding the job."", ""JOB""); (""CHANNEL"", ""The channel is related to the message because it is the destination for sending the message."", ""MESSAGE"")"
"The main disadvantage of the assembly line concurrency model is that the execution of a job is often spread out over multiple workers, and thus over multiple classes in your project.","(""Assembly Line"", ""The assembly line is an implementation of the concurrency model"", ""Concurrency Model""); (""Job"", ""A job is executed on the assembly line"", ""Assembly Line""); (""Job"", ""A job is part of a project"", ""Project"")"
With Java 7 we got the java.util.concurrent package contains the ForkAndJoinPool which can help you implement something similar to functional parallelism.,"(""java.util.concurrent"", ""The java.util.concurrent package contains the ForkAndJoinPool class, indicating a relationship between the package and the class."", ""ForkAndJoinPool""); (""Java"", ""The Java language has a package called java.util.concurrent, indicating a relationship between the language and the package."", ""java.util.concurrent"")"
"However, if the system is concurrently executing multiple other tasks (like e.g.",NULL
when a Java application is started its main() method is executed by the main thread - a special thread that is created by the Java VM to run your application.,"(""Java Application"", ""The Java Application is related to the Main Thread because the Main Thread is created by the Java VM to run the Java Application."", ""Main Thread""); (""Java VM"", ""The Java VM is related to the Main Thread because the Java VM creates the Main Thread to run the application."", ""Main Thread""); (""Main"", ""The Main method is related to the Java Application because the Main method is executed by the Java Application when it is started."", ""Java Application"")"
"To start the Java thread you will call its start() method, like this:",NULL
The first is to create a subclass of Thread and override the run() method.,NULL
The second method is to pass an object that implements Runnable (java.lang.Runnable to the Thread constructor.,"(""Thread"", ""Thread is related to Runnable because it accepts an object that implements Runnable in its constructor"", ""Runnable""); (""Thread"", ""Thread is related to java.lang.Runnable because it uses the Runnable interface from this package in its constructor"", ""java.lang.Runnable"")"
"The first way to specify what code a thread is to run, is to create a subclass of Thread and override the run() method.",NULL
The start() call will return as soon as the thread is started.,NULL
The run() method will execute as if executed by a different CPU.,NULL
"When the run() method executes it will print out the text ""MyThread running"".",NULL
You can also create an anonymous subclass of Thread like this:,NULL
The second way to specify what code a thread should run is by creating a class that implements the java.lang.Runnable interface.,"(""Runnable"", ""Runnable is part of the Java.Lang package"", ""Java.Lang"")"
Whatever the thread is supposed to do when it executes must be included in the implementation of the run() method.,NULL
The first way to implement the Java Runnable interface is by creating your own Java class that implements the Runnable interface.,"(""Java"", ""The Java class is related to the Runnable interface because it implements the Runnable interface."", ""Runnable"")"
Here is an example of a custom Java class that implements the Runnable interface:,"(""Java"", ""Java is a package that contains the Runnable interface"", ""Runnable"")"
Here is an example of an anonymous Java class that implements the Runnable interface:,"(""Java"", ""Java is related to Runnable because Java is the programming language that implements the Runnable interface"", ""Runnable""); (""Java"", ""Java is related to itself as it is the language and also has classes and packages, but no specific relationship can be determined from the given text"", ""Java"")"
"Apart from being an anononymous class, this example is quite similar to the example that used a custom class to implement the Runnable interface.","(""Anononymous Class"", ""Anononymous class is related to Runnable interface because it is used to implement the interface."", ""Runnable Interface""); (""Custom Class"", ""Custom class is related to Runnable interface because it is used to implement the interface."", ""Runnable Interface"")"
"To have the run() method executed by a thread, pass an instance of a class, anonymous class or lambda expression that implements the Runnable interface to a Thread in its constructor.","(""Thread"", ""The Thread class is related to the Runnable interface because an instance of a class that implements the Runnable interface is passed to the Thread constructor."", ""Runnable""); (""Thread"", ""The Thread class is related to the run method because the run method is executed by a Thread."", ""run"")"
Sometimes you may have to implement Runnable as well as subclass Thread.,NULL
"For instance, if creating a subclass of Thread that can execute more than one Runnable.",NULL
"When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start(), like this:","(""Thread"", ""The Thread class has a run() method that should not be called directly when creating and starting a thread"", ""run()""); (""Thread"", ""The Thread class has a start() method that should be called instead of run() when creating and starting a thread"", ""start()"")"
At first you may not notice anything because the Runnable's run() method is executed like you expected.,NULL
"To have the run() method of the MyRunnable instance called by the new created thread, newThread, you MUST call the newThread.start() method.","(""MyRunnable"", ""The run method is a part of the MyRunnable class, indicating a relationship between the two entities."", ""run""); (""newThread"", ""The start method is called on the newThread entity, indicating a relationship between the two entities."", ""start"")"
"For instance, if multiple threads write to System.out it can be handy to see which thread wrote the text.",NULL
"Notice however, that since the MyRunnable class is not a subclass of Thread, it does not have access to the getName() method of the thread executing it.","(""MyRunnable"", ""MyRunnable is not a subclass of Thread, indicating a potential inheritance relationship"", ""Thread""); (""MyRunnable"", ""MyRunnable does not have access to the getName() method, indicating that getName() is a method that MyRunnable would like to use but cannot due to the lack of inheritance from Thread"", ""getName()"")"
First it prints out the name of the thread executing the main() method.,NULL
"Note that even if the threads are started in sequence (1, 2, 3 etc.)",NULL
"they may not execute sequentially, meaning thread 1 may not be the first thread to write its name to System.out.",NULL
The sleep() method will attempt to sleep that number of milliseconds before resuming execution.,NULL
"The Thread sleep() is not 100% precise, but it is pretty good still.",NULL
Here is an example of pausing a Java thread for 3 seconds (3.000 millliseconds) by calling the Thread sleep() method:,"(""Thread"", ""The Thread class has a sleep() method, indicating a relationship between the two entities as the sleep() method is a part of the Thread class."", ""sleep()""); (""Java"", ""The Java package contains the Thread class, indicating a relationship between the two entities as the Thread class is a part of the Java package."", ""Thread"")"
"The thread executing the Java code above, will sleep for approximately 10 seconds (10.000 milliseconds).",NULL
"The Java Thread class contains a stop() method, but it is deprecated.","(""Thread"", ""The Thread class contains the stop() method, indicating a clear relationship between the two entities."", ""stop()"")"
Instead of calling the stop() method you will have to implement your thread code so it can be stopped.,NULL
Here is an example of a class that implements Runnable which contains an extra method called doStop() which signals to the Runnable to stop.,NULL
The doStop() is intended to be called from another thread than the thread executing the MyRunnable's run() method.,"(""MyRunnable"", ""MyRunnable is related to DoStop because DoStop is intended to be called in relation to the execution of MyRunnable's run method"", ""DoStop""); (""MyRunnable"", ""MyRunnable is related to Run because Run is a method of MyRunnable"", ""Run"")"
As long as doStop() has not been called the keepRunning() method will return true - meaning the thread executing the run() method will keep running.,"(""DoStop"", ""The doStop and keepRunning methods are related because the state of doStop affects the return value of keepRunning, indicating a dependency between the two methods."", ""KeepRunning""); (""KeepRunning"", ""The keepRunning and run methods are related because the return value of keepRunning determines whether the thread executing the run method will continue running, establishing a cause-and-effect relationship between the two methods."", ""Run"")"
"Here is an example of starting a Java thread that executes an instance of the above MyRunnable class, and stopping it again after a delay:","(""MyRunnable"", ""MyRunnable is related to Thread because it is an instance of the Runnable interface which is implemented by Thread"", ""Thread""); (""Java"", ""Java is related to MyRunnable because MyRunnable is a Java class"", ""MyRunnable"")"
"Then the thread executing the main() method (the main thread) sleeps for 10 seconds, and then calls the doStop() method of the MyRunnable instance.","(""Main"", ""The main() method is related to the MyRunnable instance because it calls the doStop() method on it."", ""MyRunnable""); (""Main"", ""The main() method is related to the doStop() method because it calls the doStop() method after sleeping for 10 seconds."", ""DoStop"")"
"This will cause the thread executing the MyRunnable method to stop, because the keepRunning() will return false after doStop() has been called.","(""MyRunnable"", ""MyRunnable is related to keepRunning because keepRunning is a method that is being executed by the thread running MyRunnable"", ""keepRunning""); (""MyRunnable"", ""MyRunnable is related to doStop because doStop is a method that affects the execution of MyRunnable by causing the thread to stop"", ""doStop"")"
"a stop() or pause() method too), then you can no longer create your Runnable implementation with a Java lambda expression.","(""Stop"", ""The Stop method is related to the Runnable class because it is mentioned in the context of creating a Runnable implementation."", ""Runnable""); (""Pause"", ""The Pause method is related to the Runnable class because it is mentioned in the context of creating a Runnable implementation."", ""Runnable""); (""Java"", ""The Java package is related to the Runnable class because the Runnable class is part of the Java package."", ""Runnable""); (""Java"", ""The Java package is related to the Stop method because the Stop method is used in a Java lambda expression."", ""Stop"")"
"Instead you must use a custom class, or a custom interface that extends Runnable which has the extra methods, and which is implemented by an anonymous class.","(""Custom Interface"", ""Custom Interface extends Runnable, indicating a clear inheritance relationship between the two classes"", ""Runnable""); (""Custom Interface"", ""Custom Interface has the extra methods, indicating that the interface defines or includes these methods"", ""Extra Methods""); (""Anonymous Class"", ""Anonymous Class implements Custom Interface, indicating a clear implementation relationship between the anonymous class and the custom interface"", ""Custom Interface"")"
You will have to create a custom lock class or use one of the Java 5 concurrency constructs in the java.util.concurrency package.,"(""Lock"", ""The Lock class is related to the java.util.concurrency package because it is suggested to use one of the Java 5 concurrency constructs in this package as an alternative to creating a custom lock class."", ""java.util.concurrency"")"
Here is an example of a TreeNode class that call synchronized methods in different instances:,NULL
"If a thread (1) calls the parent.addChild(child) method at the same time as another thread (2) calls the child.setParent(parent) method, on the same parent and child instances, a deadlock can occur.","(""Thread"", ""Thread is related to Addchild because it calls the method"", ""Addchild""); (""Thread"", ""Thread is related to Setparent because it calls the method"", ""Setparent""); (""Parent"", ""Parent is related to Addchild because it has the method"", ""Addchild""); (""Child"", ""Child is related to Setparent because it has the method"", ""Setparent""); (""Parent"", ""Parent is related to Child because a parent can have a child"", ""Child"")"
Here is some pseudo code that illustrates this: Thread 1: parent.addChild(child); //locks parent --> child.setParentOnly(parent); Thread 2: child.setParent(parent); //locks child --> parent.addChildOnly() First thread 1 calls parent.addChild(child).,"(""parent"", ""parent and child are related because the parent.addChild method is called with child as an argument, indicating a parent-child relationship"", ""child""); (""child"", ""child and parent are related because the child.setParent method is called with parent as an argument, indicating a child-parent relationship"", ""parent""); (""parent.addChild"", ""parent.addChild method is related to child because it is called with child as an argument, indicating that the method operates on the child entity"", ""child""); (""child.setParent"", ""child.setParent method is related to parent because it is called with parent as an argument, indicating that the method operates on the parent entity"", ""parent""); (""Thread 1"", ""Thread 1 is related to parent because it calls the parent.addChild method, indicating that Thread 1 operates on the parent entity"", ""parent""); (""Thread 1"", ""Thread 1 is related to child because it calls the parent.addChild method with child as an argument, indicating that Thread 1 operates on the child entity"", ""child""); (""Thread 2"", ""Thread 2 is related to child because it calls the child.setParent method, indicating that Thread 2 operates on the child entity"", ""child"")"
Since addChild() is synchronized thread 1 effectively locks the parent object for access from other treads.,"(""ADDCHILD"", ""The addChild method is related to the parent object because it locks the parent object for access from other threads."", ""PARENT""); (""THREAD"", ""The thread class is related to the parent object because thread 1 effectively locks the parent object for access from other threads."", ""PARENT"")"
Since setParent() is synchronized thread 2 effectively locks the child object for acces from other threads.,"(""Thread"", ""Thread is related to Child because thread 2 effectively locks the child object for access from other threads."", ""Child""); (""SetParent"", ""SetParent is related to Child because the setParent() method is used to lock the child object for access from other threads."", ""Child"")"
"Thread 2 also tries to call parent.addChildOnly() but the parent object is locked by thread 1, causing thread 2 to block on that method call.","(""Thread 2"", ""Thread 2 tries to call parent.addChildOnly() method, indicating a relationship between the two"", ""parent.addChildOnly()""); (""Thread 1"", ""The parent object is locked by thread 1, indicating a relationship between thread 1 and the parent object"", ""parent""); (""Thread 2"", ""Thread 2 is blocked due to the parent object being locked, indicating a relationship between thread 2 and the parent object"", ""parent"")"
"Note: The two threads must call parent.addChild(child) and child.setParent(parent) at the same time as described above, and on the same two parent and child instances for a deadlock to occur.","(""Parent"", ""The Parent class has a method called AddChild, indicating a relationship between the two."", ""AddChild""); (""Child"", ""The Child class has a method called SetParent, indicating a relationship between the two."", ""SetParent"")"
Thread 1: parent.addChild(child); //locks parent --> child.setParentOnly(parent); Thread 2: child.setParent(parent); //locks child --> parent.addChildOnly() First thread 1 calls parent.addChild(child).,"(""Parent"", ""Parent and Child are related because the addChild method is called on the Parent object with the Child object as an argument, indicating a parent-child relationship."", ""Child""); (""Child"", ""Child and Parent are related because the setParent method is called on the Child object with the Parent object as an argument, indicating a child-parent relationship."", ""Parent""); (""AddChild"", ""The AddChild method is related to the Parent class because it is called on the Parent object."", ""Parent""); (""SetParent"", ""The SetParent method is related to the Child class because it is called on the Child object."", ""Child""); (""AddChildOnly"", ""The AddChildOnly method is related to the Parent class because it is called on the Parent object."", ""Parent"")"
By far the best book on the java.util.concurrent package in Java 5 and forward.,NULL
"https://lmax-exchange.github.io/disruptor/ The LMAX Disrupter concurrent data structure (a single reader, single writer queue-like structure with high concurrency).",NULL
It is not important how this class looks in order to understand how the FrameExchanger works.,NULL
"The producing thread will call storeFrame() continuously, and the drawing thread will call takeFrame() continuously.",NULL
Notice how the three instructions inside the storeFrame() method seem like they do not depend on each other.,NULL
Notice that the first instruction is a read of a volatile variable (other.volatileVarC).,NULL
"When other.volatileVarC is read in from main memory, the other.nonVolatileB and other.nonVolatileA are also read in from main memory.","(""Other"", ""Other has a method called Volatilevarc"", ""Volatilevarc""); (""Other"", ""Other has a method called Nonvolatileb"", ""Nonvolatileb""); (""Other"", ""Other has a method called Nonvolatilea"", ""Nonvolatilea""); (""Volatilevarc"", ""Volatilevarc is related to Nonvolatileb as they are both read from main memory when the other is accessed"", ""Nonvolatileb""); (""Volatilevarc"", ""Volatilevarc is related to Nonvolatilea as they are both read from main memory when the other is accessed"", ""Nonvolatilea"")"
"To illustrate why this guarantee is necessary, let us modify the FrameExchanger class from earlier in this tutorial to have the hasNewFrame variable be declared volatile:","(""FrameExchanger"", ""The FrameExchanger class has a variable named hasNewFrame, indicating a relationship between the class and the variable."", ""hasNewFrame"")"
"Additionally, every time the drawing thread reads the hasNewFrame variable in the while-loop inside the takeFrame() method, the frame and framesStoredCount will also be refreshed from main memory.","(""TakeFrame"", ""The takeFrame() method reads the hasNewFrame variable, indicating a relationship between the two."", ""HasNewFrame""); (""TakeFrame"", ""The takeFrame() method refreshes the frame from main memory, indicating a relationship between the two."", ""Frame""); (""TakeFrame"", ""The takeFrame() method refreshes the framesStoredCount from main memory, indicating a relationship between the two."", ""FramesStoredCount""); (""HasNewFrame"", ""The hasNewFrame variable is related to the frame, as the frame is refreshed when hasNewFrame is read."", ""Frame""); (""HasNewFrame"", ""The hasNewFrame variable is related to the framesStoredCount, as the framesStoredCount is refreshed when hasNewFrame is read."", ""FramesStoredCount""); (""Frame"", ""The frame and framesStoredCount are both refreshed from main memory, indicating a relationship between the two."", ""FramesStoredCount""); (""Frame"", ""The frame is refreshed from main memory, indicating a relationship between the two."", ""Main Memory""); (""FramesStoredCount"", ""The framesStoredCount is refreshed from main memory, indicating a relationship between the two."", ""Main Memory""); (""HasNewFrame"", ""The hasNewFrame variable is related to main memory, as it is read from main memory."", ""Main Memory"")"
"This means, that the drawing thread executing the takeFrame() method may exit the while-loop before the new value is assigned to the frame variable.","(""Takeframe"", ""The takeFrame() method is executed by the drawing thread, indicating a relationship between the two."", ""Drawing Thread""); (""Drawing Thread"", ""The drawing thread exits the while-loop, indicating that the drawing thread is related to the while-loop."", ""While-Loop""); (""Takeframe"", ""The takeFrame() method is related to the frame variable, as the new value is assigned to the frame variable after the method is executed."", ""Frame"")"
"As you can see, the reordering of the instructions inside storeFrame() method may make the application malfunction.",NULL
"In the case of the storeFrame() method that means that the two first write instructions cannot be reordered to happen after the last write to hasNewFrame, since hasNewFrame is a volatile variable.",NULL
"Because of the volatile read visibility guarantee, when this.volatileVarA is read from main memory, so are all other variables visible to the thread at that time.","(""VolatileVarA"", ""VolatileVarA is read from main memory by the Main thread, thus establishing a relationship between the two."", ""Main""); (""Thread"", ""The visibility guarantee of VolatileVarA affects the visibility of variables to the Thread, thus establishing a relationship between the two."", ""VolatileVarA"")"
"Thus, this.nonVolatileVarB and this.nonVolatileVarC are also read in from main memory at the same time.","(""THIS"", ""THIS is the class that contains the method or variable NONVOLATILEVARB"", ""NONVOLATILEVARB""); (""THIS"", ""THIS is the class that contains the method or variable NONVOLATILEVARC"", ""NONVOLATILEVARC""); (""THIS"", ""THIS is accessing variables from the package MAIN"", ""MAIN""); (""NONVOLATILEVARB"", ""NONVOLATILEVARB is being read from the package MAIN"", ""MAIN"")"
"With regards to the takeFrame() method, the first read of a volatile variable is the read of the hasNewFrame field inside the while-loop.",NULL
Notice the two synchronized blocks inside the set() and get() method.,NULL
In the get() method the synchronized block is placed at the beginning of the method.,NULL
"When the thread calling get() enters the synchronized block, all variables are re-read in from main memory.","(""Thread"", ""The thread is related to get() because it is the one calling the get() method, which is likely part of a class that the thread is using."", ""Get""); (""Thread"", ""The thread is related to main memory because when it calls get(), it re-reads variables from main memory, indicating a dependency on main memory for its operation."", ""Main Memory"")"
"To illustrate why, I will use the get() method of the ValueExchanger shown earlier:",NULL
"As you can see, the synchronized block at the beginning of the method will guarantee that all of the variables this.valC, this.valB and this.valA are refreshed (read in) from main memory.","(""Synchronized"", ""The synchronized block is related to ValC because it guarantees that ValC is refreshed from main memory."", ""ValC""); (""Synchronized"", ""The synchronized block is related to ValB because it guarantees that ValB is refreshed from main memory."", ""ValB""); (""Synchronized"", ""The synchronized block is related to ValA because it guarantees that ValA is refreshed from main memory."", ""ValA""); (""Main"", ""The Main method is related to the Synchronized block because the Synchronized block is used to refresh variables from main memory."", ""Synchronized""); (""Main"", ""The Main method is related to ValC because ValC is refreshed from main memory."", ""ValC""); (""Main"", ""The Main method is related to ValB because ValB is refreshed from main memory."", ""ValB"")"
"To illustrate why, I will use the set() method of the ValueExchanger shown earlier:",NULL
"As you can see, the synchronized block at the end of the method will guarantee that all of the changed variables this.valA, this.valB and this.valC will be written back to (flushed) to main memory when the thread calling set() exits the synchronized blocks.","(""Synchronized"", ""The synchronized block is related to the set method because it is used at the end of the set method to guarantee that all changed variables are written back to main memory."", ""Set""); (""Set"", ""The set method is related to the thread because the thread is the one calling the set method and exiting the synchronized blocks."", ""Thread""); (""Thread"", ""The thread is related to main memory because when the thread exits the synchronized blocks, the changed variables are written back to main memory."", ""Main Memory""); (""Synchronized"", ""The synchronized block is related to the thread because it is used to guarantee that only one thread can execute the block at a time."", ""Thread"")"
Static class variables are also stored on the heap along with the class definition.,"(""Static"", ""Static is a type of class variable stored on the heap along with the class definition, indicating a relationship between the two."", ""Class""); (""Class"", ""Class variables are stored on the heap along with the class definition, indicating a relationship between the class and its variables."", ""Variables"")"
If two threads were executing the run() method then the diagram shown earlier would be the outcome.,NULL
methodOne() declares a primitive local variable (localVariable1 of type int) and an local variable which is an object reference (localVariable2).,"(""Methodone"", ""Methodone declares Localvariable1 as a primitive local variable"", ""Localvariable1"")"
Each thread executing methodOne() will create its own copy of localVariable1 and localVariable2 on their respective thread stacks.,"(""Thread"", ""Each thread executing methodOne, indicating that Thread is related to Methodone through execution"", ""Methodone""); (""Thread"", ""Each thread creates its own copy of localVariable1, indicating that Thread is related to Localvariable1 through creation"", ""Localvariable1""); (""Thread"", ""Each thread creates its own copy of localVariable2, indicating that Thread is related to Localvariable2 through creation"", ""Localvariable2""); (""Methodone"", ""Methodone uses localVariable1, indicating that Methodone is related to Localvariable1 through usage"", ""Localvariable1"")"
The localVariable1 reference will be stored in one copy per thread executing methodTwo().,"(""Methodtwo"", ""Methodtwo is executed by Thread, indicating a relationship between the method being executed and the thread executing it"", ""Thread""); (""Localvariable1"", ""Localvariable1 is stored in one copy per thread executing Methodtwo, indicating a relationship between the local variable and the method"", ""Methodtwo"")"
The Integer objects created inside methodTwo() correspond to Object 1 and Object 5 in the diagram above.,"(""Integer"", ""The Integer objects are created inside methodTwo(), indicating a relationship between the Integer class and the methodTwo() method"", ""methodTwo()""); (""Object"", ""The text mentions 'Object 1 and Object 5' in relation to 'The Integer objects', suggesting a relationship between the Object class and the Integer class"", ""Integer"")"
Notice also the two member variables in the class MySharedObject of type long which is a primitive type.,NULL
That is why Java 5 got a whole set of concurrency utility classes to help developers implement more fine grained concurrency control than what you get with synchronized.,"(""Java 5"", ""Java 5 includes Concurrency Utility Classes to help with concurrency control"", ""Concurrency Utility Classes""); (""Concurrency Utility Classes"", ""Concurrency Utility Classes provide more fine-grained concurrency control than what you get with Synchronized"", ""Synchronized"")"
Also here the synchronized keyword tells Java that the add() method is synchronized.,"(""Java"", ""The Java class contains the add method."", ""Add"")"
Synchronized static methods are synchronized on the class object of the class the synchronized static method belongs to.,"(""CLASS"", ""A class contains multiple methods, and in this context, a synchronized static method belongs to a class."", ""METHOD"")"
"Since only one class object exists in the Java VM per class, only one thread can execute inside a static synchronized method in the same class.","(""Class"", ""A class can have multiple methods, and in this context, a static synchronized method is being discussed in relation to a class."", ""Method""); (""Method"", ""A thread can execute a method, and in this case, only one thread can execute inside a static synchronized method."", ""Thread""); (""Class"", ""A class object exists in the Java VM, indicating a relationship between the class and the Java VM."", ""Java VM"")"
"In case a class contains more than one static synchronized method, only one thread can execute inside any of these methods at the same time.","(""Class"", ""A class contains more than one static synchronized method."", ""Method""); (""Method"", ""Only one thread can execute inside any of these methods at the same time."", ""Thread"")"
If Thread A is executing add() then Thread B cannot execute neither add() nor subtract() until Thread A has exited add().,"(""Thread A"", ""Thread A is executing the add() method"", ""add()""); (""Thread B"", ""Thread B cannot execute the add() method until Thread A has exited"", ""add()""); (""Thread B"", ""Thread B cannot execute the subtract() method until Thread A has exited add()"", ""subtract()"")"
"If the static synchronized methods are located in different classes, then one thread can execute inside the static synchronized methods of each class.","(""Static"", ""The static method is located in a class."", ""Class""); (""Synchronized"", ""The synchronized method is located in a class."", ""Class""); (""Thread"", ""One thread can execute inside the static synchronized methods of each class."", ""Class""); (""Thread"", ""One thread can execute inside the static synchronized methods."", ""Static"")"
One thread per class regardless of which static synchronized method it calls.,"(""Thread"", ""A thread is related to a class because one thread is assigned per class"", ""Class""); (""Thread"", ""A thread is related to a method because it calls a static synchronized method"", ""Method"")"
"Had the second synchronized block been synchronized on a different object than MyClass.class, then one thread could execute inside each method at the same time.",NULL
It is even possible to use synchronized blocks inside a Java Lambda Expression as well as inside anonymous classes.,"(""Java"", ""Java is related to Lambda Expression because Lambda Expression is used inside Java"", ""Lambda Expression""); (""Java"", ""Java is related to synchronized blocks because synchronized blocks are used inside Java"", ""synchronized blocks""); (""Java"", ""Java is related to anonymous classes because anonymous classes are used inside Java"", ""anonymous classes""); (""Lambda Expression"", ""Lambda Expression is related to synchronized blocks because synchronized blocks are used inside Lambda Expression"", ""synchronized blocks""); (""anonymous classes"", ""anonymous classes are related to synchronized blocks because synchronized blocks are used inside anonymous classes"", ""synchronized blocks"")"
Notice that the synchronized block is synchronized on the class object of the class containing the lambda expression.,"(""Class"", ""The lambda expression is contained in the class, as indicated by the phrase 'the class containing the lambda expression'."", ""Lambda Expression""); (""Class"", ""The synchronized block is synchronized on the class object, indicating a relationship between the class and the synchronized block."", ""Synchronized Block"")"
"It could have been synchronized on another object too, if that would have made more sense (given a specific use case), but using the class object is fine for this example.",NULL
"The Counter.add() method is synchronized on the instance, because the add method is an instance method, and marked as synchronized.",NULL
Therefore only one of the threads can call the add() method at a time.,NULL
"The other thread will wait until the first thread leaves the add() method, before it can execute the method itself.","(""Thread"", ""The Thread class is related to the Add method because threads are executing the Add method."", ""Add"")"
Calling add() on counterA will thus not block a call to add() on counterB.,"(""CounterA"", ""CounterA is related to Add because Add is a method called on CounterA"", ""Add""); (""CounterB"", ""CounterB is related to Add because Add is a method called on CounterB"", ""Add"")"
Without the use of the synchronized keyword (or the Java volatile keyword) there is no guarantee that when one thread changes the value of a variable shared with other threads (e.g.,"(""Thread"", ""A thread can change the value of a shared variable."", ""Variable""); (""Synchronized"", ""The synchronized keyword is used to guarantee that when one thread changes the value of a variable shared with other threads."", ""Thread""); (""Volatile"", ""The Java volatile keyword is used to guarantee that when one thread changes the value of a variable shared with other threads."", ""Thread""); (""Synchronized"", ""The synchronized keyword is used to guarantee that changes to a shared variable are visible to all threads."", ""Variable"")"
"If you call Integer.valueOf(1) multiple times, it might actually return the same wrapper object instance for the same input parameter values.","(""Integer"", ""Integer is a class that has a method called valueOf"", ""valueOf"")"
"use Integer.valueOf(1) multiple times as monitor object), then you risk that those synchronized blocks all get synchronized on the same object.","(""Integer"", ""Integer is a class that has a method called valueOf"", ""valueOf"")"
"To be on the safe side, synchronize on this - or on a new Object() .",NULL
Java actually comes with a built in ReadWriteLock class you can use.,NULL
Java actually comes with a built-in Java Semaphore class you can use.,NULL
"Thus, the thread calling count() may eventually enter the same synchronized block multiple times.","(""Thread"", ""The thread is calling the count() method, indicating a relationship between the two entities."", ""Count""); (""Thread"", ""The thread may enter the synchronized block, indicating a relationship between the two entities."", ""Synchronized Block"")"
The Java ThreadLocal class enables you to create variables that can only be read and written by the same thread.,NULL
"Thus, the Java ThreadLocal class provides a simple way to make code thread safe that would not otherwise be so.",NULL
You read the value stored in a ThreadLocal using its get() method.,NULL
"Additionally, you do not have to typecast the value returned by get().",NULL
It is possible to set an initial value for a Java ThreadLocal which will get used the first time get() is called - before set() has been called with a new value.,"(""ThreadLocal"", ""ThreadLocal uses the get method to retrieve its value"", ""get""); (""ThreadLocal"", ""ThreadLocal uses the set method to set its value"", ""set"")"
"The easiest way to create a subclass of ThreadLocal is to simply create an anonymous subclass, right where you create the ThreadLocal variable.","(""ThreadLocal"", ""ThreadLocal is a subclass of Thread, indicating a clear inheritance relationship between the two classes"", ""Thread"")"
Here is an example of creating an anonymous subclass of ThreadLocal which overrides the initialValue() method:,NULL
"Only if you return the exact same object from the initialValue() method, will all threads see the same object.",NULL
"Here is an example of creating a ThreadLocal using its withInitial() static factory method, passing a simple Supplier implementation as parameter:","(""ThreadLocal"", ""ThreadLocal has a method called withInitial, which is used to create a new instance of ThreadLocal"", ""withInitial"")"
Notice how the format() method calls the getThreadLocalSimpleDateFormat() method to obtain a Java SimpleDatFormat instance.,"(""Format"", ""The Format method calls the GetThreadLocalSimpleDateFormat method to obtain a Java SimpleDateFormat instance."", ""GetThreadLocalSimpleDateFormat""); (""GetThreadLocalSimpleDateFormat"", ""The GetThreadLocalSimpleDateFormat method returns a Java SimpleDateFormat instance."", ""SimpleDateFormat"")"
"The SimpleDateFormat class is not thread safe, so multiple threads cannot use it at the same time.",NULL
"To solve this problem, the MyDateFormatter class above creates a SimpleDateFormat per thread, so each thread calling the format() method will use its own SimpleDateFormat instance.","(""MyDateFormatter"", ""MyDateFormatter class creates a SimpleDateFormat instance"", ""SimpleDateFormat""); (""MyDateFormatter"", ""MyDateFormatter class has a format() method"", ""format()"")"
"If the access to the set() call had been synchronized, and it had not been a ThreadLocal object, the second thread would have overridden the value set by the first thread.","(""Set"", ""The Set class is related to the Thread class because the text mentions that the second thread would have overridden the value set by the first thread, implying that threads interact with sets."", ""Thread""); (""Thread"", ""The Thread class is related to the ThreadLocal class because the text mentions that if it had not been a ThreadLocal object, the second thread would have overridden the value set by the first thread, implying that ThreadLocal is used in the context of threads."", ""ThreadLocal"")"
"The udpate() method writes three variables, of which only days is volatile.",NULL
Notice the totalDays() method starts by reading the value of days into the total variable.,"(""TotalDays"", ""The TotalDays method reads the value of days into the total variable, indicating that TotalDays is related to Total."", ""Total"")"
Let us look at the MyClass class from the example earlier in this Java volatile tutorial:,NULL
As an alternative to a synchronized block you could also use one of the many atomic data types found in the java.util.concurrent package.,"(""Java"", ""Java is related to Util because Util is a part of the Java package hierarchy"", ""Util""); (""Util"", ""Util is related to Concurrent because Concurrent is a sub-package of Util"", ""Concurrent"")"
"From Java 5 the package java.util.concurrent.locks contains several lock implementations, so you may not have to implement your own locks.",NULL
"The Counter class could have been written like this instead, using a Lock instead of a synchronized block:",NULL
The lock() method locks the Lock instance so that all threads calling lock() are blocked until unlock() is executed.,"(""Lock"", ""The lock() method is related to the Lock class because it is used to lock the Lock instance."", ""lock()""); (""Lock"", ""The unlock() method is related to the Lock class because it is used to unlock the Lock instance."", ""unlock()"")"
Spin locks and the methods wait() and notify() are covered in more detail in the text Thread Signaling.,"(""Spin Locks"", ""Spin locks are related to the method wait() as they are both covered in the text Thread Signaling, indicating a connection between the class and the method."", ""Wait""); (""Spin Locks"", ""Spin locks are related to the method notify() as they are both covered in the text Thread Signaling, indicating a connection between the class and the method."", ""Notify""); (""Wait"", ""The method wait() is related to the package Thread Signaling as it is covered in more detail in the text, indicating a connection between the method and the package."", ""Thread Signaling""); (""Notify"", ""The method notify() is related to the package Thread Signaling as it is covered in more detail in the text, indicating a connection between the method and the package."", ""Thread Signaling""); (""Spin Locks"", ""Spin locks are related to the package Thread Signaling as they are covered in more detail in the text, indicating a connection between the class and the package."", ""Thread Signaling"")"
"In case the thread should return unexpectedly from the wait() call without having received a notify() call (AKA a Spurious Wakeup) the thread re-checks the isLocked condition to see if it is safe to proceed or not, rather than just assume that being awakened means it is safe to proceed.","(""Thread"", ""The thread uses the wait() call, indicating a relationship between the Thread class and the Wait method"", ""Wait""); (""Thread"", ""The thread receives a notify() call, indicating a relationship between the Thread class and the Notify method"", ""Notify""); (""Thread"", ""The thread checks the isLocked condition, indicating a relationship between the Thread class and the Islocked method"", ""Islocked""); (""Wait"", ""The wait() call is related to the notify() call, as the thread waits for a notification"", ""Notify""); (""Wait"", ""The wait() call is related to the isLocked condition, as the thread re-checks the condition after being awakened"", ""Islocked"")"
"If isLocked is false, the thread exits the while(isLocked) loop, and sets isLocked back to true, to lock the Lock instance for other threads calling lock().","(""Thread"", ""The Thread class is related to the Lock class because a thread is trying to lock the Lock instance."", ""Lock""); (""Lock"", ""The Lock class is related to the IsLocked variable because the Lock instance is being locked and unlocked based on the value of IsLocked."", ""IsLocked"")"
"When the thread is done with the code in the critical section (the code between lock() and unlock()), the thread calls unlock().","(""Thread"", ""The thread uses the lock to access the critical section, indicating a relationship between the Thread and Lock entities."", ""Lock""); (""Thread"", ""The thread calls unlock when it is done with the critical section, indicating a relationship between the Thread and Unlock entities."", ""Unlock"")"
"Executing unlock() sets isLocked back to false, and notifies (awakens) one of the threads waiting in the wait() call in the lock() method, if any.","(""Unlock"", ""Unlock method sets Islocked variable back to false"", ""Islocked""); (""Unlock"", ""Unlock method notifies one of the threads waiting in the Wait method"", ""Wait""); (""Unlock"", ""Unlock method is related to Lock method as it is used in the same context of thread waiting and notification"", ""Lock"")"
"If a thread calls outer() there is no problem calling inner() from inside outer(), since both methods (or blocks) are synchronized on the same monitor object (""this"").","(""Thread"", ""Thread calls the Outer method, establishing a relationship between the two entities"", ""Outer""); (""Outer"", ""Outer method contains a call to the Inner method, indicating a relationship between the two entities"", ""Inner"")"
"However, even if synchronized blocks are reentrant, the Lock class shown earlier is not reentrant.",NULL
"If we rewrite the Reentrant class like below, the thread calling outer() will be blocked inside the lock.lock() in the inner() method.","(""Reentrant"", ""The Reentrant class contains the outer() method, indicating a relationship between the two entities."", ""outer()""); (""Reentrant"", ""The Reentrant class contains the inner() method, indicating a relationship between the two entities."", ""inner()""); (""outer()"", ""The outer() method calls the inner() method, indicating a relationship between the two entities."", ""inner()""); (""outer()"", ""The outer() method is blocked by the lock.lock() method, indicating a relationship between the two entities."", ""lock.lock()""); (""inner()"", ""The inner() method uses the lock.lock() method, indicating a relationship between the two entities."", ""lock.lock()"")"
Inside the inner() method the thread will again try to lock the Lock instance.,NULL
"The reason the thread will be blocked the second time it calls lock() without having called unlock() in between, is apparent when we look at the lock() implementation:","(""Lock"", ""The Lock and Unlock entities are related because they are both methods that are used in conjunction with each other to manage thread access, with Lock being used to block a thread and Unlock being used to unblock it."", ""Unlock""); (""Lock"", ""The Lock entity is related to the Thread entity because the lock() method is called by a thread, and the thread will be blocked if it calls lock() without having called unlock() in between."", ""Thread"")"
It is the condition inside the while loop (spin lock) that determines if a thread is allowed to exit the lock() method or not.,"(""While Loop"", ""The while loop contains the condition for the lock method to determine if a thread can exit."", ""Lock""); (""Lock"", ""The lock method determines if a thread is allowed to exit or not."", ""Thread"")"
To make the Lock class reentrant we need to make a small change:,NULL
"Otherwise, a single call to unlock() will unlock the lock, even if the lock has been locked multiple times.",NULL
"We don't want the lock to be unlocked until the thread that locked it, has executed the same amount of unlock() calls as lock() calls.","(""Lock"", ""The lock is related to the thread because the thread is the one that locks and unlocks it."", ""Thread""); (""Lock"", ""The lock and unlock methods are related because they are used in conjunction with each other to manage the lock state."", ""Unlock""); (""Thread"", ""The thread is related to the lock method because it is the one that calls the lock method."", ""Lock"")"
"When guarding a critical section with a Lock, and the critical section may throw exceptions, it is important to call the unlock() method from inside a finally-clause.",NULL
"If unlock() was not called from inside a finally-clause, and an exception was thrown from the critical section, the Lock would remain locked forever, causing all threads calling lock() on that Lock instance to halt indefinately.","(""Lock"", ""The unlock() method is related to the Lock class because it is used to unlock the Lock instance."", ""unlock()"")"
"Imagine then, that one of the clients sends a request that takes a long time to process - e.g.",NULL
"Notice how the lock() method first synchronizes on ""this"", then synchronizes on the monitorObject member.","(""Lock"", ""The Lock method is related to MonitorObject because it synchronizes on the monitorObject member."", ""MonitorObject"")"
"If isLocked is true however, the thread calling lock() is parked waiting in the monitorObject.wait() call.","(""Lock"", ""The lock method is related to the monitorobject because it is used in conjunction with the monitorobject's wait call."", ""Monitorobject""); (""Islocked"", ""The islocked method is related to the lock method because the lock method's behavior is dependent on the value of islocked."", ""Lock"")"
"The problem with this is, that the call to monitorObject.wait() only releases the synchronization monitor on the monitorObject member, and not the synchronization monitor associated with ""this"".","(""MonitorObject"", ""MonitorObject is related to Wait because Wait is a method called on MonitorObject"", ""Wait""); (""This"", ""This is related to MonitorObject because both are involved in synchronization monitors"", ""MonitorObject"")"
When the thread that locked the Lock in the first place tries to unlock it by calling unlock() it will be blocked trying to enter the synchronized(this) block in the unlock() method.,"(""Lock"", ""The Lock class has an unlock() method, indicating a relationship between the two entities as the method is used to unlock the Lock."", ""unlock()""); (""thread"", ""The thread is related to the Lock as it is the one that locked the Lock in the first place, and it tries to unlock it."", ""Lock""); (""thread"", ""The thread is related to the unlock() method as it is the one that calls the unlock() method to unlock the Lock."", ""unlock()""); (""Lock"", ""The Lock is related to the synchronized(this) method as the method is used to block the thread that tries to unlock the Lock."", ""synchronized(this)"")"
"But the thread waiting in the lock() method will not leave that block until the isLocked is set to false, and a monitorObject.notify() is executed, as it happens in unlock().","(""Lock"", ""The Lock class is related to the Monitorobject class because the lock() method is waiting for a notification from the monitorObject"", ""Monitorobject""); (""Lock"", ""The Lock method is related to the Unlock method because the thread waiting in the lock() method will leave the block when the unlock() method is executed"", ""Unlock""); (""Monitorobject"", ""The Monitorobject class is related to the Notify method because the monitorObject.notify() is executed to notify the waiting thread"", ""Notify""); (""Lock"", ""The Lock method is related to the Notify method because the lock() method is waiting for a notification from the notify() method"", ""Notify"")"
"Put shortly, the thread waiting in lock() needs an unlock() call to execute successfully for it to exit lock() and the synchronized blocks inside it.","(""Lock"", ""The Lock class needs an Unlock method call to execute successfully for it to exit the lock and the synchronized blocks inside it."", ""Unlock"")"
"But, no thread can actually execute unlock() until the thread waiting in lock() leaves the outer synchronized block.","(""Thread"", ""A thread can execute the lock() method, indicating a relationship between the Thread class and the Lock method"", ""Lock""); (""Thread"", ""A thread can execute the unlock() method, indicating a relationship between the Thread class and the Unlock method"", ""Unlock"")"
This result is that any thread calling either lock() or unlock() will become blocked indefinately.,"(""Thread"", ""A thread is related to a lock because it can call the lock() method, which can cause the thread to become blocked indefinitely."", ""Lock"")"
"When doing so you want each thread to call wait() on each their own queue object, so that you can notify the threads one at a time.","(""Thread"", ""A thread is related to a queue because each thread calls wait() on its own queue object"", ""Queue""); (""Queue"", ""A queue is related to a thread because each thread has its own queue object to call wait() on"", ""Thread""); (""Thread"", ""A thread is related to the wait() method because each thread calls wait() on its queue object"", ""Wait""); (""Queue"", ""A queue is related to the wait() method because wait() is called on each queue object"", ""Wait""); (""Thread"", ""A thread is related to the notify() method because threads can be notified one at a time"", ""Notify"")"
"At first glance this implementation may look fine, but notice how the lock() method calls queueObject.wait(); from inside two synchronized blocks.","(""Lock"", ""The Lock class is related to the QueueObject class because the lock() method calls queueObject.wait() from inside two synchronized blocks, indicating that Lock is used to synchronize access to QueueObject."", ""QueueObject""); (""Lock"", ""The Lock method is related to the Wait method because lock() calls wait() from inside two synchronized blocks, indicating that Lock uses Wait to pause the execution of the current thread."", ""Wait"")"
"When a thread calls queueObject.wait()it releases the lock on the QueueObject instance, but not the lock associated with ""this"".","(""QueueObject"", ""The QueueObject class has a method called wait, indicating a relationship between the class and the method."", ""wait""); (""thread"", ""A thread calls the wait method on a QueueObject instance, indicating a relationship between the thread and the QueueObject class."", ""QueueObject"")"
"Notice too, that the unlock() method is declared synchronized which equals a synchronized(this) block.",NULL
"This means, that if a thread is waiting inside lock() the monitor object associated with ""this"" will be locked by the waiting thread.","(""Thread"", ""A thread is waiting inside the lock() method, indicating a relationship between the Thread class and the Lock method"", ""Lock""); (""Thread"", ""The monitor object associated with the thread will be locked by the waiting thread, indicating a relationship between the Thread class and the Monitor class"", ""Monitor"")"
"But this will never happen, since this only happens if a thread succeeds in sending a signal to the waiting thread, and this can only be sent by executing the unlock() method.",NULL
"For instance, the different implementations of the java.util.concurrent.BlockingQueue interface are all blocking data structures.",NULL
"Other threads will read the value of the volatile from main memory every time, instead of from e.g.","(""Other"", ""Other threads are related to threads because they are mentioned together in the context of reading the value of the volatile from main memory"", ""threads""); (""threads"", ""threads are related to main because they read the value of the volatile from main memory"", ""main""); (""main"", ""main is related to memory because the value of the volatile is read from main memory"", ""memory"")"
"Thus, this code may still lead to race conditions if performed by more than one thread: volatile myVar = 0; ... int temp = myVar; temp++; myVar = temp; First the value of the volatile variable myVar is read from main memory into a temp variable.","(""Myvar"", ""Myvar is read from main memory"", ""Main Memory""); (""Myvar"", ""The value of myVar is read into a temp variable"", ""Temp"")"
"Here is a single writer counter which does not use synchronization but is still concurrent: public class SingleWriterCounter { private volatile long count = 0; /** * Only one thread may ever call this method, * or it will lead to race conditions.","(""SingleWriterCounter"", ""The SingleWriterCounter class has a member variable count, indicating a relationship between the class and the variable."", ""count""); (""SingleWriterCounter"", ""The SingleWriterCounter class is related to itself as it is described in the context of the class."", ""SingleWriterCounter""); (""SingleWriterCounter"", ""The class SingleWriterCounter is related to itself, as the method is part of the class."", ""SingleWriterCounter""); (""SingleWriterCounter"", ""The class SingleWriterCounter has a method which is related to the class."", ""SingleWriterCounter""); (""SingleWriterCounter"", ""The SingleWriterCounter class is related to the method as the method is part of the class."", ""SingleWriterCounter""); (""SingleWriterCounter"", ""The SingleWriterCounter class has a member variable count, indicating a relationship between the class and the variable."", ""count""); (""SingleWriterCounter"", ""The SingleWriterCounter class is related to itself as it is described in the context of the class, and has a method."", ""SingleWriterCounter""); (""SingleWriterCounter"", ""The SingleWriterCounter class has a member variable count, indicating a relationship between the class and the variable, and the class has a method."", ""count""); (""SingleWriterCounter"", ""The SingleWriterCounter class is related to itself as it is described in the context of the class, and has a method, and a variable."", ""SingleWriterCounter""); (""SingleWriterCounter"", ""The SingleWriterCounter class has a member variable count, indicating a relationship between the class and the variable, and the class has a method, and is related to itself."", ""count""); (""SingleWriterCounter"", ""The SingleWriterCounter class is related to itself, and has a method, and a variable, and is described in the context of the class."", ""SingleWriterCounter""); (""SingleWriterCounter"", ""The SingleWriterCounter class has a member variable count, indicating a relationship between the class and the variable, and the class has a method, and is related to itself, and is described in the context of the class."", ""count""); (""SingleWriterCounter"", ""The SingleWriterCounter class is related to itself as it is described in the context of the class, and has a method, and a variable, and the class has the method."", ""SingleWriterCounter""); (""SingleWriterCounter"", ""The SingleWriterCounter class has a member variable count, indicating a relationship between the class and the variable, and the class has a method, and is related to itself, and is described in the context of the class, and the class has the method."", ""count""); (""SingleWriterCounter"", ""The SingleWriterCounter class is related to itself as it is described in the context of the class, and has a method, and a variable, and the class has the method, and the class is related to itself."", ""SingleWriterCounter""); (""SingleWriterCounter"", ""The SingleWriterCounter class has a member variable count, indicating a relationship between the class and the variable, and the class has a method, and is related to itself, and is described in the context of the class, and the class has the method, and the class is related to itself."", ""count""); (""SingleWriterCounter"", ""The SingleWriterCounter class is related to itself, and has a method, and a variable, and the class has the method, and the class is related to itself, and the class is described in the context of the class."", ""SingleWriterCounter""); (""SingleWriterCounter"", ""The SingleWriterCounter class has a member variable count, indicating a relationship between the class and the variable, and the class has a method, and is related to itself, and is described in the context of the class, and the class has the method, and the class is related to itself, and the class is described in the context of the class."", ""count""); (""SingleWriterCounter"", ""The SingleWriterCounter class is related to itself as it is described in the context of the class, and has a method, and a variable, and the class has the method, and the class is related to itself, and the class is described in the context of the class, and the class has the method."", ""SingleWriterCounter""); (""SingleWriterCounter"", ""The SingleWriterCounter class has a member variable count, indicating a relationship between the class and the variable, and the class has a method, and is related to itself, and is described in the context of the class, and the class has the method, and the class is related to itself, and the class is described in the context of the class, and the class has the method."", ""count""); (""SingleWriterCounter"", ""The SingleWriterCounter class is related to itself, and has a method, and a variable, and the class has the method, and the class is related to itself, and the class is described in the context of the class, and the class has the method, and the class is related to itself."", ""SingleWriterCounter""); (""SingleWriterCounter"", ""The SingleWriterCounter class has a member variable count, indicating a relationship between the class and the variable, and the class has a method, and is related to itself, and is described in the context of the class, and the class has the method, and the class is related to itself, and the class is described in the context of the class, and the class has the method, and the class is related to itself."", ""count"")"
"I mean, only the same, single thread is ever allowed to call inc().",NULL
"Here is a simple double writer counter class that shows how that could look: public class DoubleWriterCounter { private volatile long countA = 0; private volatile long countB = 0; /** * Only one (and the same from thereon) thread may ever call this method, * or it will lead to race conditions.","(""DoubleWriterCounter"", ""DoubleWriterCounter is related to countA because countA is a variable declared within the DoubleWriterCounter class"", ""countA"")"
"*/ public void incA() { this.countA++; } /** * Only one (and the same from thereon) thread may ever call this method, * or it will lead to race conditions.","(""IncA"", ""The IncA method is clearly related to the CountA variable because it increments the value of CountA."", ""CountA"")"
"Only a single thread may ever call incA(), and only a single thread may ever call incB().",NULL
This is how such exclusive access could look using a synchronized block in Java: public class SynchronizedCounter { long count = 0; public void inc() { synchronized(this) { count++; } } public long count() { synchronized(this) { return this.count; } } } Notice how the inc() and count() methods both contain a synchronized block.,"(""SynchronizedCounter"", ""The inc method is a part of the SynchronizedCounter class, indicating a clear relationship between the two entities."", ""inc""); (""SynchronizedCounter"", ""The count method is a part of the SynchronizedCounter class, indicating a clear relationship between the two entities."", ""count"")"
This is what we want to avoid - synchronized blocks and wait() - notify() calls etc.,"(""Synchronized"", ""Synchronized is related to Wait because they are both used for thread synchronization"", ""Wait""); (""Synchronized"", ""Synchronized is related to Notify because they are both used for thread synchronization"", ""Notify"")"
What is interesting about this version is the implementation of the inc() method.,NULL
"Instead it contains these lines: boolean updated = false; while(!updated){ long prevCount = this.count.get(); updated = this.count.compareAndSet(prevCount, prevCount + 1); } These lines are not an atomic operation.","(""Updated"", ""The Updated variable is related to the Count class because it is used to track the update status of the count variable, which is an instance of the Count class."", ""Count""); (""Count"", ""The Count class is related to the Compareandset method because the Compareandset method is used to update the count variable, which is an instance of the Count class."", ""Compareandset""); (""Prevcount"", ""The Prevcount variable is related to the Count class because it stores the previous value of the count, which is an instance of the Count class."", ""Count""); (""Updated"", ""The Updated variable is related to the Prevcount variable because both are used in the while loop to update the count."", ""Prevcount""); (""While"", ""The While method is related to the Updated variable because the while loop continues to execute until the updated variable is set to true."", ""Updated""); (""While"", ""The While method is related to the Count class because the while loop is used to update the count variable, which is an instance of the Count class."", ""Count""); (""While"", ""The While method is related to the Compareandset method because the while loop uses the Compareandset method to update the count variable."", ""Compareandset"")"
The compareAndSet() method is typically supported by compare-and-swap instructions directly in the CPU.,NULL
"Since compareAndSet() is an atomic operation, the threads will execute this method sequentially (one at a time).","(""CompareAndSet"", ""The source entity CompareAndSet is related to the target entity Thread because the text states that threads will execute the CompareAndSet method sequentially."", ""Thread"")"
"If no other thread has called inc() in the meantime, the second iteration will succeed in updating the AtomicLong to 22.",NULL
Instead Java provides the AtomicStampedReference class which can swap a reference and a stamp atomically using a compare-and-swap operation.,NULL
"import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicStampedReference; public class NonblockingTemplate { public static class IntendedModification { public AtomicBoolean completed = new AtomicBoolean(false); } private AtomicStampedReference<IntendedModification> ongoingMod = new AtomicStampedReference<IntendedModification>(null, 0); //declare the state of the data structure here.","(""NonblockingTemplate"", ""NonblockingTemplate contains IntendedModification as an inner class"", ""IntendedModification""); (""NonblockingTemplate"", ""NonblockingTemplate uses AtomicStampedReference as a data member"", ""AtomicStampedReference""); (""NonblockingTemplate"", ""NonblockingTemplate uses AtomicBoolean as a data member through its inner class IntendedModification"", ""AtomicBoolean""); (""IntendedModification"", ""IntendedModification contains AtomicBoolean as a data member"", ""AtomicBoolean"")"
"Multiple threads can access the same instance of this counter, as long as only one thread calls inc().","(""COUNTER"", ""The counter is accessed by multiple threads, indicating a relationship between the counter and the threads."", ""THREAD""); (""INC"", ""The inc() method is called on an instance of the counter, indicating a relationship between the inc() method and the counter."", ""COUNTER"")"
Here is a simple double writer counter class that shows how that could look:,NULL
Notice how the inc() and count() methods both contain a synchronized block.,NULL
Here is how the same counter class could look using an AtomicLong instead:,NULL
"Imagine if two threads, A and B, are executing the add method on the same instance of the Counter class.","(""Counter"", ""The Counter class has an add method, indicating a relationship between the class and the method."", ""add""); (""A"", ""Thread A is executing a method on an instance of the Counter class, indicating a relationship between the thread and the class."", ""Counter""); (""B"", ""Thread B is executing a method on an instance of the Counter class, indicating a relationship between the thread and the class."", ""Counter""); (""A"", ""Thread A is executing the add method, indicating a relationship between the thread and the method."", ""add"")"
The code in the add() method is not executed as a single atomic instruction by the Java virtual machine.,NULL
"Instead of 5, the value left in this.count will be the value written by the last thread to write its value.","(""Thread"", ""The Thread entity is related to the Count entity because the last thread to write its value affects the value left in this.count."", ""Count""); (""Write"", ""The Write method is related to the Count entity because the value written by the last thread to write its value is left in this.count."", ""Count"")"
The code in the add() method in the example earlier contains a critical section.,NULL
Thread synchronization can also be achieved using other synchronization constructs like locks or atomic variables like java.util.concurrent.atomic.AtomicInteger.,"(""java.util.concurrent.atomic.AtomicInteger"", ""java.util.concurrent.atomic.AtomicInteger is a class within the java.util.concurrent.atomic package"", ""java.util.concurrent.atomic"")"
Notice how the add() method adds values to two different sum member variables.,NULL
Now two threads can execute the add() method at the same time.,NULL
This way threads will have to wait less for each other to execute the add() method.,NULL
The rules for read access are implemented in the lockRead() method.,NULL
The rules for write access are implemented in the lockWrite() method.,NULL
It is worth noting that both unlockRead() and unlockWrite() calls notifyAll() rather than notify().,"(""Unlockread"", ""Unlockread is related to Notifyall because it calls Notifyall instead of Notify""}"", ""Notifyall"")"
By calling noftifyAll() all waiting threads are awakened and check if they can get the desired access.,NULL
"If multiple threads are waiting for read access and none for write access, and unlockWrite() is called, all threads waiting for read access are granted read access at once - not one by one.","(""Thread"", ""Thread is related to Unlockwrite because threads are waiting for read access and unlockWrite() is called to grant access"", ""Unlockwrite""); (""Thread"", ""Thread is related to Read because multiple threads are waiting for read access"", ""Read"")"
Here is how the lockRead() and unlockRead() methods looks after that change:,NULL
To achieve this the writeLock() method should be changed a bit.,NULL
Here is how the canGrantReadAccess() method will look with that change:,NULL
"When guarding a critical section with a ReadWriteLock, and the critical section may throw exceptions, it is important to call the readUnlock() and writeUnlock() methods from inside a finally-clause.","(""ReadWriteLock"", ""The ReadWriteLock class has a method called readUnlock(), indicating a relationship between the two entities."", ""readUnlock()""); (""ReadWriteLock"", ""The ReadWriteLock class has a method called writeUnlock(), indicating a relationship between the two entities."", ""writeUnlock()"")"
"The only thing that could unlock the ReadWriteLockagain would be if the ReadWriteLock is reentrant, and the thread that had it locked when the exception was thrown, later succeeds in locking it, executing the critical section and calling unlockWrite() again afterwards.",NULL
Calling unlockWrite() from a finally-clause is a much more robust solution.,NULL
"If a thread calls lock() twice without calling unlock() in between, the second call to lock() will block.","(""Thread"", ""A thread calls the lock() method, indicating a relationship between the Thread class and the Lock class"", ""Lock""); (""Lock"", ""The lock() method is related to the unlock() method, as a thread must call unlock() after calling lock()"", ""Unlock"")"
Java 5 comes with semaphore implementations in the java.util.concurrent package so you don't have to implement your own semaphores.,"(""java.util.concurrent"", ""The java.util.concurrent package contains semaphore implementations, indicating a clear relationship between the two entities."", ""semaphore""); (""Java 5"", ""Java 5 comes with the java.util.concurrent package, indicating that Java 5 is related to the package."", ""java.util.concurrent"")"
"You can read more about it in the java.util.concurrent.Semaphore text, in my java.util.concurrent tutorial.","(""Java.Util.Concurrent.Semaphore"", ""Java.Util.Concurrent.Semaphore is a part of the Java.Util.Concurrent package, as indicated by its fully qualified name."", ""Java.Util.Concurrent""); (""Java.Util.Concurrent.Tutorial"", ""The Java.Util.Concurrent.Tutorial is related to the Java.Util.Concurrent package, as it is mentioned as a tutorial for the package."", ""Java.Util.Concurrent"")"
"When received the signal flag is cleared again, and the release() method exited.",NULL
You will call take() instead of notify() and release() instead of wait().,"(""TAKE"", ""TAKE is related to NOTIFY because TAKE is called instead of NOTIFY"", ""NOTIFY"")"
"If the call to take() happens before the call to release() the thread calling release() will still know that take() was called, because the signal is stored internally in the signal variable.","(""Take"", ""The take() and release() methods are related because they are both involved in the same synchronization process, with take() happening before release()."", ""Release""); (""Signal"", ""The Signal class is related to the take() method because the signal is stored internally in the signal variable when take() is called."", ""Take""); (""Signal"", ""The Signal class is related to the release() method because the signal stored internally in the signal variable is used by the thread calling release()."", ""Release""); (""Thread"", ""The Thread class is related to the take() method because the thread is the one calling take()."", ""Take""); (""Thread"", ""The Thread class is related to the release() method because the thread is the one calling release()."", ""Release"")"
The Semaphore implementation in the previous section does not count the number of signals sent to it by take() method calls.,NULL
Notice how the take() method now blocks if the number of signals is equal to the upper bound.,NULL
"Not until a thread has called release() will the thread calling take() be allowed to deliver its signal, if the BoundedSemaphore has reached its upper signal limit.","(""BoundedSemaphore"", ""The BoundedSemaphore class has a method called release(), which is related to the semaphore's functionality."", ""release()""); (""BoundedSemaphore"", ""The BoundedSemaphore class has a method called take(), which is related to the semaphore's functionality and is affected by the release() method."", ""take()"")"
"To do so, set the upper bound to 1, and have the call to take() and release() guard the critical section.","(""Take"", ""The Take method is related to the Critical Section because it is used to guard the critical section."", ""Critical Section""); (""Release"", ""The Release method is related to the Critical Section because it is used to guard the critical section."", ""Critical Section"")"
"Since only one thread is allowed to take the semaphore, all other threads calling take() will be blocked until release() is called.","(""Semaphore"", ""The Semaphore entity is related to the Take method because the Take method is used to acquire the semaphore."", ""Take""); (""Semaphore"", ""The Semaphore entity is related to the Release method because the Release method is used to release the semaphore."", ""Release""); (""Thread"", ""The Thread entity is related to the Take method because threads call the Take method to acquire the semaphore."", ""Take""); (""Thread"", ""The Thread entity is related to the Release method because the Release method is called to allow blocked threads to proceed."", ""Release"")"
The call to release() will never block since there has always been a call to take() first.,NULL
The relase() method is called from inside a finally-block to make sure it is called even if an exception is thrown from the critical section.,"(""Release"", ""The Release method is called from inside a Finally-Block to ensure it is executed even if an exception occurs."", ""Finally-Block"")"
A classic multi-threaded architecture can also sometimes lead to congestion when multiple threads try to access the same data structure at the same time.,"(""Classic"", ""Classic and Multi-threaded are related as they both describe a type of architecture"", ""Multi-threaded""); (""Multi-threaded"", ""Multi-threaded and Threads are related as multi-threaded refers to the use of multiple threads"", ""Threads""); (""Threads"", ""Threads and Data are related as threads try to access the same data structure"", ""Data""); (""Threads"", ""Threads and Structure are related as threads try to access the same data structure"", ""Structure""); (""Access"", ""Access and Data are related as threads try to access the data"", ""Data""); (""Access"", ""Access and Structure are related as threads try to access the data structure"", ""Structure""); (""Architecture"", ""Architecture and Data are related as the architecture can lead to congestion when accessing data"", ""Data""); (""Architecture"", ""Architecture and Structure are related as the architecture can lead to congestion when accessing the data structure"", ""Structure"")"
The alternative to a classic multithreaded architecture is a single-threaded or same-threaded.,NULL
"This kind of thread loop is both used in server applications (web services, services etc.)","(""Thread Loop"", ""Thread Loop is used in Server Applications"", ""Server Applications""); (""Thread Loop"", ""Thread Loop is used in Web Services, which are a type of server application"", ""Web Services""); (""Thread Loop"", ""Thread Loop is used in Services, which are a type of server application"", ""Services""); (""Server Applications"", ""Web Services are a type of server application"", ""Web Services""); (""Server Applications"", ""Services are a type of server application"", ""Services"")"
"For instance, the task executor could keep the tasks in different lists internally, and e.g.",NULL
"If a one-off task is waiting for some asynchronous operation to finish, e.g.",NULL
"Notice how the synchronized(queueObject) with its queueObject.wait() call is nested inside the synchronized(this) block, resulting in the nested monitor lockout problem.","(""Queueobject"", ""Queueobject is used inside the Synchronized block, indicating a relationship between the two entities as the Synchronized method is applied to the Queueobject"", ""Synchronized""); (""This"", ""This is related to Synchronized as the Synchronized method is applied to This, indicating a relationship between the class instance and the method"", ""Synchronized"")"
"Note: Only the lock() method is shown, since it is the only method I have changed.",NULL
The first synchronized(this) block checks the condition by setting mustWait = isLocked || waitingThreads.get(0) != queueObject.,"(""Synchronized"", ""The Synchronized block is related to 'this' as it is using the 'this' keyword as an argument."", ""This""); (""Synchronized"", ""The Synchronized block is related to 'isLocked' as it is using the 'isLocked' method to check a condition."", ""Islocked""); (""Synchronized"", ""The Synchronized block is related to 'waitingThreads' as it is using the 'waitingThreads' class to get the first waiting thread."", ""Waitingthreads""); (""Synchronized"", ""The Synchronized block is related to 'queueObject' as it is using the 'queueObject' class to compare with the first waiting thread."", ""Queueobject""); (""Waitingthreads"", ""The 'waitingThreads' class is related to the 'get' method as it is using the 'get' method to retrieve the first waiting thread."", ""Get""); (""Islocked"", ""The 'isLocked' method is related to 'this' as it is likely an instance method of the class that 'this' refers to."", ""This"")"
Imagine that the FairLock instance is locked when a thread calls lock().,NULL
"Then imagine that the thread calling lock() is preempted, and the thread that locked the lock calls unlock().","(""Thread"", ""The thread is calling the lock() method of the Lock class, indicating a relationship between the two entities."", ""Lock"")"
"If you look at the unlock() implementation shown earlier, you will notice that it calls queueObject.notify().","(""Unlock"", ""The Unlock method is related to the Notify method because it calls Notify in its implementation."", ""Notify""); (""Unlock"", ""The Unlock method is related to the Queueobject class because it uses an instance of Queueobject to call the Notify method."", ""Queueobject"")"
"But, since the thread waiting in lock() has not yet called queueObject.wait(), the call to queueObject.notify() passes into oblivion.","(""Thread"", ""The thread is waiting in lock, indicating a relationship between the Thread class and the Lock class or method."", ""Lock""); (""Thread"", ""The thread is waiting for queueObject, indicating a relationship between the Thread class and the QueueObject class."", ""QueueObject""); (""QueueObject"", ""The call to queueObject.wait() indicates a relationship between the QueueObject class and the Wait method."", ""Wait"")"
The missed signals problems is the reason that the FairLock implementation shown in the text Starvation and Fairness has turned the QueueObject class into a semaphore with two methods: doWait() and doNotify().,"(""QueueObject"", ""The QueueObject class has a method called doWait(), indicating a clear relationship between the class and the method."", ""doWait()""); (""QueueObject"", ""The QueueObject class has a method called doNotify(), indicating a clear relationship between the class and the method."", ""doNotify()"")"
"That way the signal is not missed, even if doNotify() is called before doWait().",NULL
The notify() method makes no guarantee about what thread is awakened if multiple thread have called wait() on the object notify() is called on.,"(""Notify"", ""The notify() method is called on an object, indicating a relationship between the notify method and the object it is called on."", ""Object""); (""Wait"", ""The wait() method is called on an object, indicating a relationship between the wait method and the object it is called on."", ""Object"")"
"If more than one thread call the doSynchronized() method, some of them will be blocked until the first thread granted access has left the method.",NULL
Instead the critical section is guarded by the lock.lock() and lock.unlock() calls.,"(""Lock"", ""The Lock class is related to the lock() method because the lock() method is called on an instance of the Lock class to acquire the lock."", ""lock()""); (""Lock"", ""The Lock class is related to the unlock() method because the unlock() method is called on an instance of the Lock class to release the lock."", ""unlock()"")"
"If you look at the Synchronizer class above and look into this Lock implementation you will notice that threads are now blocked trying to access the lock() method, if more than one thread calls lock() simultanously.","(""Synchronizer"", ""The Synchronizer class is related to the Lock class because it uses the Lock implementation."", ""Lock""); (""Lock"", ""The Lock class is related to the lock() method because the lock() method is part of the Lock implementation."", ""lock()"")"
"Second, if the lock is locked, the threads are blocked in the wait() call inside the while(isLocked) loop in the lock() method.","(""Lock"", ""The Lock class contains the Wait method, indicating a relationship between the two entities."", ""Wait""); (""Lock"", ""The Lock class contains the Islocked method, indicating a relationship between the two entities."", ""Islocked"")"
"Remember that a thread calling wait() releases the synchronization lock on the Lock instance, so threads waiting to enter lock() can now do so.","(""Thread"", ""A thread calls wait() on a Lock instance, releasing the synchronization lock, allowing other threads to enter lock()"", ""Lock""); (""Thread"", ""A thread can call the wait() method, which is related to the thread's state and behavior"", ""Wait""); (""Lock"", ""The Lock instance has a wait() method that can be called by a thread, which releases the synchronization lock on the Lock instance"", ""Wait""); (""Thread"", ""A thread can call the lock() method on a Lock instance, which is related to the thread's synchronization and access to shared resources"", ""Lock"")"
"If you look back at the doSynchronized() method you will notice that the comment between lock() and unlock() states, that the code in between these two calls take a ""long"" time to execute.","(""DoSynchronized"", ""The DoSynchronized method contains a call to the Lock method, indicating a relationship between the two."", ""Lock""); (""DoSynchronized"", ""The DoSynchronized method also contains a call to the Unlock method, indicating a relationship between the two."", ""Unlock"")"
Let us further assume that this code takes long time to execute compared to entering the lock() method and calling wait() because the lock is locked.,"(""Lock"", ""The Lock class has a method called wait, indicating a relationship between the Lock class and the wait method."", ""Wait"")"
"This means that the majority of the time waited to be able to lock the lock and enter the critical section is spent waiting in the wait() call inside the lock() method, not being blocked trying to enter the lock() method.","(""Lock"", ""The Wait method is called inside the Lock method, indicating a relationship between the two entities."", ""Wait"")"
Nor does wait() make any guarantees about what thread is awakened when notify() is called.,NULL
The current version of the Lock class calls its own wait() method.,NULL
"If instead each thread calls wait() on a separate object, so that only one thread has called wait() on each object, the Lock class can decide which of these objects to call notify() on, thereby effectively selecting exactly what thread to awaken.","(""Lock"", ""The Lock class can decide which object to call notify() on after a thread has called wait() on that object, indicating a relationship between the Lock class and the wait method."", ""wait""); (""Lock"", ""The Lock class calls notify() on an object, indicating a relationship between the Lock class and the notify method."", ""notify"")"
Below is shown the previous Lock class turned into a fair lock called FairLock.,NULL
"Exactly how I arrived at this design beginning from the previous Lock class is a longer story involving several incremental design steps, each fixing the problem of the previous step: Nested Monitor Lockout, Slipped Conditions, and Missed Signals.","(""Lock"", ""Lock is related to Nested Monitor Lockout because it is mentioned as a problem that was fixed in the design steps involving the Lock class"", ""Nested Monitor Lockout""); (""Lock"", ""Lock is related to Slipped Conditions because it is mentioned as a problem that was fixed in the design steps involving the Lock class"", ""Slipped Conditions"")"
"What is important is, that every thread calling lock() is now queued, and only the first thread in the queue is allowed to lock the FairLock instance, if it is unlocked.","(""FairLock"", ""The FairLock class has a lock method, indicating that lock is a method of the FairLock class, and thus they are related."", ""lock"")"
First you might notice that the lock() method is no longer declared synchronized.,NULL
FairLock creates a new instance of QueueObject and enqueue it for each thread calling lock().,"(""FairLock"", ""FairLock creates a new instance of QueueObject"", ""QueueObject""); (""FairLock"", ""FairLock has a method called lock"", ""lock"")"
"The thread calling unlock() will take the top QueueObject in the queue and call doNotify() on it, to awaken the thread waiting on that object.","(""unlock()"", ""The thread calling unlock() will take the top QueueObject in the queue, indicating a relationship between the unlock() method and the QueueObject class."", ""QueueObject""); (""doNotify()"", ""The doNotify() method is called on the QueueObject, indicating a relationship between the doNotify() method and the QueueObject class."", ""QueueObject"")"
"This is done to avoid missed signals caused by a thread being preempted just before calling queueObject.doWait(), by another thread which calls unlock() and thereby queueObject.doNotify().","(""QueueObject"", ""QueueObject is related to DoWait because DoWait is a method that is called on QueueObject"", ""DoWait""); (""QueueObject"", ""QueueObject is related to DoNotify because DoNotify is a method that is called on QueueObject"", ""DoNotify"")"
"The queueObject.doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout, so another thread can actually call unlock() when no thread is executing inside the synchronized(this) block in lock() method.","(""QueueObject"", ""The QueueObject is related to the DoWait method because it is the object on which the doWait() call is made."", ""DoWait""); (""QueueObject"", ""The QueueObject is related to the Lock method because it is the object being locked in the synchronized(this) block."", ""Lock""); (""QueueObject"", ""The QueueObject is related to the Unlock method because it is the object that can be unlocked when no thread is executing inside the synchronized(this) block."", ""Unlock""); (""DoWait"", ""The DoWait method is related to the Lock method because the doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout, which is related to the lock() method."", ""Lock"")"
"Finally, notice how the queueObject.doWait() is called inside a try - catch block.",NULL
"In case an InterruptedException is thrown the thread leaves the lock() method, and we need to dequeue it.","(""InterruptedException"", ""The InterruptedException is thrown from the lock() method, indicating a relationship between the two."", ""lock()""); (""thread"", ""The thread leaves the lock() method when an InterruptedException is thrown, showing a relationship between the thread and the lock() method."", ""lock()"")"
Threads waiting on an object (called wait() on it) remain waiting indefinitely,"(""Threads"", ""Threads are waiting on an Object, which indicates a relationship between the two entities, as Threads are calling the wait() method on the Object"", ""Object""); (""Threads"", ""Threads are calling the wait() method, which indicates a relationship between the Threads entity and the wait() method, as Threads are using this method to wait on an object"", ""wait()"")"
"In a desktop app the foreground thread (UI thread) could be responding to the user events - a.g. opening a file, or downloading a file, or saving a file etc.","(""Desktop App"", ""The desktop app contains the foreground thread, which is responsible for handling user events."", ""Foreground Thread""); (""Foreground Thread"", ""The foreground thread is also known as the UI thread, which handles user interface events."", ""UI Thread""); (""Foreground Thread"", ""The foreground thread responds to user events, such as opening, downloading, or saving a file."", ""User Events""); (""Foreground Thread"", ""The foreground thread performs actions on a file, such as opening, downloading, or saving it."", ""File""); (""UI Thread"", ""The UI thread handles user events, such as interacting with the desktop app."", ""User Events"")"
"Each thread consumes a certain amount of computer resources, such as memory (RAM), so if you have too many threads active at the same time, the total amount of resources (e.g.","(""THREAD"", ""A thread consumes a certain amount of memory"", ""MEMORY"")"
RAM) that is consumed may cause the computer to slow down - e.g.,NULL
"Java comes with built in thread pools in the java.util.concurrent package, so you don't have to implement your own thread pool.",NULL
"Below here is the PoolThreadRunnable class which implements the Runnable interface, so it can be executed by a Java thread:","(""PoolThreadRunnable"", ""PoolThreadRunnable implements the Runnable interface, indicating a clear relationship between the two entities as one is implementing the other"", ""Runnable""); (""PoolThreadRunnable"", ""PoolThreadRunnable is executed by a Java thread, indicating a relationship between the PoolThreadRunnable class and the Java package as the class is being used within the context of Java"", ""Java"")"
"A ThreadPool class which is the public interface to the thread pool, and a PoolThread class which implements the threads that execute the tasks.",NULL
To execute a task the method ThreadPool.execute(Runnable r) is called with a Runnable implementation as parameter.,"(""ThreadPool"", ""ThreadPool class has an execute method"", ""execute""); (""execute"", ""The execute method takes a Runnable implementation as a parameter"", ""Runnable"")"
Notice how the execute() method will throw an IllegalStateException if execute() is called after stop() has been called.,"(""Execute"", ""The execute method is related to the stop method because execute will throw an exception if stop has been called previously."", ""Stop"")"
"This makes sure that a thread blocked in a wait() call inside the taskQueue.dequeue() call breaks out of the wait() call, and leaves the dequeue() method call with an InterruptedException thrown.","(""Thread"", ""A thread is blocked in a wait() call inside the taskQueue.dequeue() call, indicating a relationship between the Thread and TaskQueue entities."", ""TaskQueue""); (""TaskQueue"", ""The taskQueue.dequeue() call is a method of the TaskQueue entity, indicating a relationship between the TaskQueue and Dequeue entities."", ""Dequeue""); (""Thread"", ""A thread is blocked in a wait() call inside the taskQueue.dequeue() call, indicating a relationship between the Thread and Dequeue entities."", ""Dequeue"")"
"This exception is caught in the PoolThread.run() method, reported, and then the isStopped variable is checked.","(""PoolThread"", ""The PoolThread class contains the run method, indicating a clear relationship between the two entities."", ""run""); (""PoolThread"", ""The isStopped variable is checked in the context of the PoolThread, suggesting a relationship between the PoolThread class and the isStopped variable."", ""isStopped"")"
"Since isStopped is now true, the PoolThread.run() will exit and the thread dies.","(""PoolThread"", ""The PoolThread class contains the run method, indicating a relationship between the two."", ""run"")"
Notice how it is possible to change that reference through both the setValue() and add() methods.,NULL
"Therefore, even if the Calculator class uses an immutable object internally, it is not itself immutable, and therefore not thread safe.",NULL
"In other words: The ImmutableValue class is thread safe, but the use of it is not.",NULL
"The LocalObject instance in this example is not returned from the method, nor is it passed to any other objects that are accessible from outside the someMethod() method.",NULL
Each thread executing the someMethod() method will create its own LocalObject instance and assign it to the localObject reference.,"(""someMethod()"", ""The someMethod() method creates an instance of LocalObject, indicating a relationship between the two entities."", ""LocalObject""); (""someMethod()"", ""The someMethod() method assigns the created LocalObject instance to the localObject reference, indicating a relationship between the two entities."", ""localObject"")"
"Even if the LocalObject instance is passed as parameter to other methods in the same class, or in other classes, the use of it is thread safe.","(""LocalObject"", ""LocalObject is related to methods because it is passed as a parameter to other methods"", ""methods""); (""LocalObject"", ""LocalObject is related to class because it is an instance of a class"", ""class"")"
If two threads call the add() method simultaneously on the same NotThreadSafe instance then it leads to race conditions.,"(""NotThreadSafe"", ""The add() method is called on an instance of the NotThreadSafe class, indicating a relationship between the two entities."", ""add()"")"
"However, if two threads call the add() method simultaneously on different instances then it does not lead to race condition.","(""Add"", ""The add() method is called by two threads simultaneously, indicating a relationship between the method and the threads."", ""Threads"")"
"In other words, it is waiting for a signal from thread A which causes hasDataToProcess() to return true.",NULL
Notice how the while loop keeps executing until hasDataToProcess() returns true.,NULL
A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object.,"(""Thread"", ""A thread calls wait() on an object, indicating a relationship between the Thread and the Object it is waiting on."", ""Object""); (""Thread"", ""A thread calls wait() on an object, indicating a relationship between the Thread and the wait method it invokes."", ""Wait""); (""Thread"", ""Another thread calls notify() on an object that a thread is waiting on, indicating a relationship between the Thread and the notify method that can activate it."", ""Notify""); (""Object"", ""Wait is called on an object, indicating a relationship between the object and the wait method."", ""Wait"")"
In order to call either wait() or notify the calling thread must first obtain the lock on that object.,"(""Thread"", ""The thread must obtain the lock on the object to call wait or notify, indicating a relationship between the thread and the object."", ""Object""); (""Thread"", ""The thread calls the wait method, indicating a relationship between the thread and the wait method."", ""Wait""); (""Thread"", ""The thread calls the notify method, indicating a relationship between the thread and the notify method."", ""Notify""); (""Object"", ""The wait method is called on the object, indicating a relationship between the object and the wait method."", ""Wait"")"
"In other words, the calling thread must call wait() or notify() from inside a synchronized block.","(""Thread"", ""The Thread class is related to the Wait method because the calling thread must call wait() from inside a synchronized block."", ""Wait""); (""Thread"", ""The Thread class is related to the Notify method because the calling thread must call notify() from inside a synchronized block."", ""Notify""); (""Thread"", ""The Thread class is related to the Synchronized block because the calling thread must be inside a synchronized block to call wait() or notify()."", ""Synchronized""); (""Wait"", ""The Wait method is related to the Synchronized block because wait() must be called from inside a synchronized block."", ""Synchronized"")"
Here is a modified version of MySignal called MyWaitNotify that uses wait() and notify().,"(""MyWaitNotify"", ""MyWaitNotify is a modified version of MySignal"", ""MySignal""); (""MyWaitNotify"", ""MyWaitNotify uses the wait() method"", ""wait"")"
"When a thread calls notify() on an object, one of the threads waiting on that object are awakened and allowed to execute.","(""Thread"", ""A thread calls notify() on an object, indicating a relationship between the thread and the object."", ""Object""); (""Notify"", ""The notify() method is called on an object, indicating a relationship between the notify method and the object."", ""Object"")"
There is also a notifyAll() method that will wake all threads waiting on a given object.,NULL
As you can see both the waiting and notifying thread calls wait() and notify() from within a synchronized block.,"(""Waiting"", ""The Waiting thread calls the wait() method"", ""Wait""); (""Notifying"", ""The Notifying thread calls the notify() method"", ""Notify""); (""Waiting"", ""The Waiting thread may also be related to the notify() method, as it is likely waiting for a notification"", ""Notify"")"
Will the waiting thread not block the notifying thread from ever entering the synchronized block in doNotify()?,"(""Waiting Thread"", ""The waiting thread and the notifying thread are related because they are both involved in the notification process, where the notifying thread is trying to notify the waiting thread."", ""Notifying Thread""); (""Waiting Thread"", ""The waiting thread and the doNotify method are related because the waiting thread is waiting for the notification that is supposed to be sent by the doNotify method."", ""DoNotify""); (""Notifying Thread"", ""The notifying thread and the doNotify method are related because the notifying thread is the one calling the doNotify method to send the notification."", ""DoNotify""); (""Waiting Thread"", ""The waiting thread and the synchronized block are related because the waiting thread is trying to enter the synchronized block."", ""Synchronized Block"")"
Once a thread calls wait() it releases the lock it holds on the monitor object.,"(""Thread"", ""A thread calls wait() on a monitor object, indicating a relationship between the two."", ""Monitor""); (""Thread"", ""A thread releases the lock it holds, indicating that the thread has a relationship with the lock."", ""Lock""); (""Monitor"", ""The lock is held on the monitor object, indicating a relationship between the monitor and the lock."", ""Lock"")"
"This allows other threads to call wait() or notify() too, since these methods must be called from inside a synchronized block.","(""Wait"", ""Both Wait and Notify are methods that must be called from inside a synchronized block, indicating a relationship between them as they are used in similar contexts."", ""Notify""); (""Wait"", ""Wait is related to Synchronized Block because it must be called from inside a synchronized block."", ""Synchronized Block"")"
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block.,"(""Thread"", ""A thread is related to the wait() call as it is the one that is awakened and needs to exit the wait() call."", ""Wait""); (""Thread"", ""A thread is related to the notify() call as it is the one that is awakened by the thread calling notify()."", ""Notify"")"
"If multiple threads are awakened using notifyAll() only one awakened thread at a time can exit the wait() method, since each thread must obtain the lock on the monitor object in turn before exiting wait().","(""NotifyAll"", ""NotifyAll is related to Wait because NotifyAll is used to awaken threads that are waiting using the Wait method"", ""Wait""); (""Wait"", ""Wait is related to Monitor because Wait requires obtaining the lock on the monitor object before exiting"", ""Monitor"")"
The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called.,NULL
"Therefore, if a thread calls notify() before the thread to signal has called wait(), the signal will be missed by the waiting thread.","(""Notify"", ""The notify method is related to the Thread class because it is called by a thread."", ""Thread""); (""Wait"", ""The wait method is related to the Thread class because it is called by a thread."", ""Thread"")"
To avoid losing signals they should be stored inside the signal class.,NULL
Notice how the doNotify() method now sets the wasSignalled variable to true before calling notify().,"(""DoNotify"", ""The DoNotify method sets the WasSignalled variable to true"", ""WasSignalled"")"
In fact it only calls wait() if no signal was received in between the previous doWait() call and this.,NULL
For inexplicable reasons it is possible for threads to wake up even if notify() and notifyAll() has not been called.,"(""Threads"", ""Threads can be affected by the Notify method, as it can wake them up"", ""Notify""); (""Threads"", ""Threads can be affected by the Notifyall method, as it can wake them up"", ""Notifyall"")"
If a spurious wakeup occurs in the MyWaitNofity2 class's doWait() method the waiting thread may continue processing without having received a proper signal to do so!,NULL
"The while loop is also a nice solution if you have multiple threads waiting, which are all awakened using notifyAll(), but only one of them should be allowed to continue.","(""While Loop"", ""The while loop is related to notifyAll() because it is used as a solution when multiple threads are waiting and notifyAll() is used to awaken them"", ""Notifyall""); (""Threads"", ""Threads are related to notifyAll() because notifyAll() is used to awaken multiple threads"", ""Notifyall"")"
"Only one thread at a time will be able to obtain the lock on the monitor object, meaning only one thread can exit the wait() call and clear the wasSignalled flag.","(""Monitor"", ""The Monitor class has a method called Wait, which is used to make a thread wait until it is signalled."", ""Wait""); (""Wait"", ""The Wait method is related to the WasSignalled flag, as it is used to clear this flag when a thread is signalled."", ""WasSignalled"")"
"Once this thread then exits the synchronized block in the doWait() method, the other threads can exit the wait() call and check the wasSignalled member variable inside the while loop.","(""Thread"", ""The Thread exits the synchronized block in the doWait() method, indicating a relationship between the Thread and the doWait() method."", ""DoWait""); (""Thread"", ""The Thread exits the wait() call, indicating a relationship between the Thread and the wait() method."", ""Wait""); (""DoWait"", ""The doWait() method is related to the wait() method as they are both mentioned in the context of the Thread exiting the synchronized block and the wait() call."", ""Wait""); (""Thread"", ""The Thread checks the wasSignalled member variable, indicating a relationship between the Thread and the wasSignalled variable."", ""WasSignalled"")"
"An earlier version of this text had an edition of the MyWaitNotify example class which used a constant string ( """" ) as monitor object.",NULL
This also means that threads calling doWait() on the first MyWaitNotify instance risk being awakened by doNotify() calls on the second MyWaitNotify instance.,"(""MyWaitNotify"", ""MyWaitNotify instance has a method called doWait() which is being called by threads"", ""doWait()""); (""MyWaitNotify"", ""MyWaitNotify instance is being affected by doNotify() calls which can awaken threads waiting on it"", ""doNotify()"")"
"Remember, that even if the 4 threads call wait() and notify() on the same shared string instance, the signals from the doWait() and doNotify() calls are stored individually in the two MyWaitNotify instances.","(""MyWaitNotify"", ""MyWaitNotify is related to wait because wait is called on the shared string instance, which is stored individually in the MyWaitNotify instances."", ""wait""); (""MyWaitNotify"", ""MyWaitNotify is related to notify because notify is called on the shared string instance, which is stored individually in the MyWaitNotify instances."", ""notify""); (""MyWaitNotify"", ""MyWaitNotify is related to doWait because the signals from the doWait calls are stored individually in the MyWaitNotify instances."", ""doWait""); (""MyWaitNotify"", ""MyWaitNotify is related to doNotify because the signals from the doNotify calls are stored individually in the MyWaitNotify instances."", ""doNotify""); (""wait"", ""wait and notify are related because they are both called on the same shared string instance."", ""notify"")"
"A doNotify() call on the MyWaitNotify 1 may wake threads waiting in MyWaitNotify 2, but the signal will only be stored in MyWaitNotify 1.","(""MyWaitNotify 1"", ""MyWaitNotify 1 is related to doNotify() because a doNotify() call is made on it"", ""doNotify()""); (""MyWaitNotify 2"", ""MyWaitNotify 2 is related to doNotify() because threads waiting in MyWaitNotify 2 may be woken by a doNotify() call on MyWaitNotify 1"", ""doNotify()"")"
"After all, if doNotify() is called on the second MyWaitNotify instance all that can really happen is that Thread A and B are awakened by mistake.","(""MyWaitNotify"", ""MyWaitNotify is related to doNotify because doNotify is a method that can be called on an instance of MyWaitNotify"", ""doNotify""); (""Thread A"", ""Thread A is related to MyWaitNotify because Thread A is awakened by a call to doNotify on a MyWaitNotify instance"", ""MyWaitNotify"")"
"This awakened thread (A or B) will check its signal in the while loop, and go back to waiting because doNotify() was not called on the first MyWaitNotify instance, in which they are waiting.",NULL
"If the doNotify() method had called notifyAll() instead of notify(), all waiting threads had been awakened and checked for signals in turn.","(""DoNotify"", ""The doNotify method is related to notify because it had called notify instead of notifyAll, indicating a possible alternative or replacement relationship"", ""Notify""); (""DoNotify"", ""The doNotify method is related to notifyAll because it is mentioned as an alternative that doNotify could have called, indicating a possible replacement or comparison relationship"", ""Notifyall"")"
"Thread A and B would have gone back to waiting, but one of either C or D would have noticed the signal and left the doWait() method call.","(""Thread A"", ""Thread A is related to doWait() because it would have gone back to waiting after calling the doWait() method"", ""doWait()""); (""Thread B"", ""Thread B is related to doWait() because it would have gone back to waiting after calling the doWait() method"", ""doWait()""); (""Thread C"", ""Thread C is related to doWait() because it would have noticed the signal and left the doWait() method call"", ""doWait()"")"
"The other of C and D would go back to waiting, because the thread discovering the signal clears it on the way out of doWait().","(""C"", ""C is related to doWait() because it is mentioned as being affected by the thread discovering the signal that is cleared on the way out of doWait()"" "", ""doWait()"")"
"You may be tempted then to always call notifyAll() instead notify(), but this is a bad idea performance wise.",NULL
"For instance, each MyWaitNotify3 (example from earlier sections) instance has its own MonitorObject instance rather than using the empty string for wait() / notify() calls.","(""MyWaitNotify3"", ""MyWaitNotify3 instance has its own MonitorObject instance"", ""MonitorObject""); (""MyWaitNotify3"", ""MyWaitNotify3 instance uses wait() call"", ""wait""); (""MyWaitNotify3"", ""MyWaitNotify3 instance uses notify() call"", ""notify""); (""MonitorObject"", ""MonitorObject instance is used for wait() call"", ""wait"")"
"The AtomicBoolean class is located in the java.util.concurrent.atomic package, so the full class name is java.util.concurrent.atomic.AtomicBoolean .","(""AtomicBoolean"", ""The AtomicBoolean class is located in the java.util.concurrent.atomic package"", ""java.util.concurrent.atomic""); (""java.util.concurrent.atomic.AtomicBoolean"", ""java.util.concurrent.atomic.AtomicBoolean is located in the java.util.concurrent.atomic package"", ""java.util.concurrent.atomic"")"
You can get the value of an AtomicBoolean using the get() method.,NULL
You can set the value of an AtomicBoolean using the set() method.,NULL
"The getAndSet() method returns the AtomicBoolean's current value, and sets a new value for it.",NULL
"The method compareAndSet() allows you to compare the current value of the AtomicBoolean to an expected value, and if current value is equal to the expected value, a new value can be set on the AtomicBoolean.",NULL
"The compareAndSet() method is atomic, so only a single thread can execute it at the same time.",NULL
"The AtomicInteger class provides you with a int variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().","(""AtomicInteger"", ""The AtomicInteger class provides a int variable, indicating a relationship between the AtomicInteger class and the int variable."", ""int"")"
"The AtomicInteger class is located in the java.util.concurrent.atomic package, so the full class name is java.util.concurrent.atomic.AtomicInteger .",NULL
You can get the value of an AtomicInteger instance via the get() method.,NULL
The AtomicInteger class contains a few methods you can use to add a value to the AtomicInteger and get its value returned.,"(""AtomicInteger"", ""The AtomicInteger class contains the add method, indicating a relationship between the AtomicInteger class and its add method."", ""Add"")"
"The first method, addAndGet() adds a number to the AtomicInteger and returns its value after the addition.",NULL
"The second method, getAndAdd() also adds a number to the AtomicInteger but returns the value the AtomicInteger had before the value was added.",NULL
The AtomicInteger class also contains a few methods for subtracting values from the AtomicInteger value atomically.,NULL
The decrementAndGet() subtracts 1 from the AtomicInteger value and returns its value after the subtraction.,NULL
The getAndDecrement() also subtracts 1 from the AtomicInteger value but returns the value the AtomicInteger had before the subtraction.,NULL
The Java AtomicIntegerArray class (java.util.concurrent.atomic.AtomicIntegerArray) represents an array of int .,NULL
You can get the value of a given element using the get() method on the AtomicIntegerArray.,NULL
You can set the value of a given element using the set() method on the AtomicIntegerArray.,NULL
Here is an example showing how calling the set() method looks:,NULL
"The compareAndSet() method is used to compare the value of a given element with a specified value, and if the two values are equal, set a new value for that element.",NULL
"The compareAndSet() method returns a boolean with the value true if the element had a new value set, and false if not (if the element did not have the expected value).",NULL
Calling addAndGet() is also an atomic operation (like all operations on the AtomicIntegerArray).,NULL
"The getAndAdd() method does the same as the addAndGet() method, except the getAndAdd() method returns the value of the element before a value is added to it.",NULL
"The getAndIncrement() method does the same as the incrementAndGet() method, except the getAndIncrement() method returns the value of the element before it is incremented.",NULL
The decrementAndGet() method decrements (subtracts 1) to the value of a given element and returns the new value of that element.,NULL
"The getAndDecrement() method does the same as the decrementAndGet() method, except the getAndDecrement() method returns the value of the element before it is decremented.",NULL
"The AtomicLong class provides you with a long variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().",NULL
"The AtomicLong class is located in the java.util.concurrent.atomic package, so the full class name is java.util.concurrent.atomic.AtomicLong .",NULL
You can get the value of an AtomicLong instance via the get() method.,NULL
The AtomicLong class contains a few methods you can use to add a value to the AtomicLong and get its value returned.,"(""AtomicLong"", ""The AtomicLong class contains a few methods, indicating a relationship between the class and its methods"", ""methods""); (""AtomicLong"", ""The AtomicLong class has methods to get its value returned, indicating a relationship between the class and the value it holds"", ""value"")"
"The first method, addAndGet() adds a number to the AtomicLong and returns its value after the addition.",NULL
"The second method, getAndAdd() also adds a number to the AtomicLong but returns the value the AtomicLong had before the value was added.",NULL
The AtomicLong class also contains a few methods for subtracting values from the AtomicLong value atomically.,"(""AtomicLong"", ""The AtomicLong class contains methods for subtracting values, indicating a relationship between the class and its methods"", ""subtracting values"")"
The decrementAndGet() subtracts 1 from the AtomicLong value and returns its value after the subtraction.,NULL
The getAndDecrement() also subtracts 1 from the AtomicLong value but returns the value the AtomicLong had before the subtraction.,NULL
The Java AtomicLongArray class (java.util.concurrent.atomic.AtomicLongArray) represents an array of long .,NULL
You can get the value of a given element using the get() method on the AtomicLongArray.,NULL
You can set the value of a given element using the set() method on the AtomicLongArray.,NULL
You should check out the JavaDoc for the AtomicLongArray class to learn more about those methods.,NULL
The AtomicReference class provides an object reference variable which can be read and written atomically.,NULL
By atomic is meant that multiple threads attempting to change the same AtomicReference (e.g.,NULL
You can get the reference stored in an AtomicReference using the AtomicReference's get() method.,NULL
If you have an untyped AtomicReference then the get() method returns an Object reference.,"(""AtomicReference"", ""The get() method is a part of the AtomicReference class, indicating a relationship between the two."", ""get()""); (""get()"", ""The get() method returns an Object reference, indicating a relationship between the get() method and the Object class."", ""Object"")"
If you have a typed AtomicReference then get() returns a reference to the type you declared on the AtomicReference variable when you created it.,"(""AtomicReference"", ""The get() method is related to the AtomicReference class because it is used to retrieve a reference to the type declared on the AtomicReference variable."", ""get()""); (""AtomicReference variable"", ""The get() method is related to the AtomicReference variable because it is used to retrieve a reference to the type declared on the AtomicReference variable when it is created."", ""get()"")"
Notice how it is no longer necessary to cast the referenced returned by get() because the compiler knows it will return a String reference.,NULL
You can set the reference stored in an AtomicReference instance using its set() method.,"(""AtomicReference"", ""The set() method is used in conjunction with the AtomicReference class, indicating a relationship between the two, as the method is a part of the class's functionality."", ""set()""); (""instance"", ""The instance is an object of the AtomicReference class, showing a relationship between the two, as the instance is a specific example of the class."", ""AtomicReference"")"
In an untyped AtomicReference instance the set() method takes an Object reference as parameter.,"(""AtomicReference"", ""The set() method is a part of the AtomicReference class, indicating a relationship between the two."", ""set()""); (""set()"", ""The set() method takes an Object reference as a parameter, indicating a relationship between the set() method and the Object class."", ""Object"")"
In a typed AtomicReference the set() method takes whatever type as parameter you declared as its type when you declared the AtomicReference.,NULL
"The compareAndSet() method can compare the reference stored in the AtomicReference instance with an expected reference, and if they two references are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicReference instance.","(""CompareAndSet"", ""The compareAndSet() method can compare the reference stored in the AtomicReference instance"", ""AtomicReference"")"
If compareAndSet() sets a new reference in the AtomicReference the compareAndSet() method returns true.,NULL
"Then it calls comparesAndSet() two times to compare the stored reference to the initial reference, and set a new reference if the stored reference is equal to the initial reference.","(""ComparesAndSet"", ""ComparesAndSet is related to the initial reference because it compares the stored reference to the initial reference"", ""initial reference"")"
"Thus, a new reference is not set on the AtomicReference and the compareAndSet() method returns false.",NULL
The AtomicReferenceArray in the java.util.concurrent.atomic package is an array of object references which can be updated atomically.,NULL
"The second constructor takes a E[] array as parameter, where E is the type (class) of the object references.",NULL
The get() method returns the value of the element with the given index.,"(""Get"", ""The get() method returns the value of the element with the given index, indicating that Get is related to Element."", ""Element"")"
The read() method of a Java PipedReader returns an int which contains the char value of the character read.,"(""PipedReader"", ""The read() method is a part of the PipedReader class, indicating a clear relationship between the two."", ""read()""); (""Java"", ""PipedReader is a class in the Java package, indicating a clear relationship between the two."", ""PipedReader"")"
The write() method of a PipedWriter takes an int which contains the byte value of the byte to write.,"(""PipedWriter"", ""The write() method is a part of the PipedWriter class, indicating a clear relationship between the two."", ""write()"")"
You can also connect the two pipe streams using their connect() methods.,NULL
Both PipedInputStream and PipedOutputStream has a connect() method that can connect one to the other.,"(""PipedInputStream"", ""They are related because they can be connected to each other using the connect() method."", ""PipedOutputStream""); (""PipedInputStream"", ""PipedInputStream has a connect() method that can be used to connect it to another stream."", ""connect()"")"
"The read() and write() calls on the streams are blocking, meaning if you try to use the same thread to both read and write, this may result in the thread deadlocking itself.","(""Read"", ""The read() method is called on the streams, indicating a relationship between the Read method and the Streams class."", ""Streams""); (""Write"", ""The write() method is called on the streams, indicating a relationship between the Write method and the Streams class."", ""Streams"")"
The Java PrintStream class (java.io.PrintStream) enables you to write formatted data to an underlying OutputStream.,"(""PrintStream"", ""The PrintStream class writes formatted data to an underlying OutputStream, indicating a relationship between the two classes."", ""OutputStream""); (""PrintStream"", ""The PrintStream class is part of the java.io package, indicating a relationship between the class and the package."", ""java.io"")"
"The PrintStream class can format primitive types like int, long etc.","(""PrintStream"", ""The PrintStream class can format primitive types like int"", ""int"")"
You may be familiar with these two well-known PrintStream instances in Java: System.out and System.err .,"(""System.out"", ""System.out is an instance of the PrintStream class"", ""PrintStream""); (""System.err"", ""System.err is an instance of the PrintStream class"", ""PrintStream""); (""System.out"", ""System.out is a member of the System class"", ""System"")"
"The Java PrintStream class contains the powerful format() and printf() methods (they do exactly the same, but the name ""printf"" is more familiar to C-programmers).","(""PrintStream"", ""The PrintStream class contains the format() method, indicating a clear relationship between the class and the method."", ""format()""); (""PrintStream"", ""The PrintStream class contains the printf() method, indicating a clear relationship between the class and the method."", ""printf()"")"
The Java PrintWriter class (java.io.PrintWriter) enables you to write formatted data to an underlying Writer.,"(""PrintWriter"", ""The PrintWriter class enables you to write formatted data to an underlying Writer, indicating a relationship between PrintWriter and Writer."", ""Writer""); (""PrintWriter"", ""The PrintWriter class is located in the java.io package, indicating a relationship between PrintWriter and the java.io package."", ""java.io"")"
The PrintWriter class has all the same methods as the PrintStream except for the methods to write raw bytes.,"(""PrintWriter"", ""The PrintWriter class has all the same methods as the PrintStream except for the methods to write raw bytes, indicating a relationship between the two classes."", ""PrintStream""); (""PrintWriter"", ""The PrintWriter class has methods, indicating a relationship between the class and its methods."", ""methods"")"
Being a Writer subclass the PrintWriter is intended to write text.,NULL
"Third, the example calls the advanced printf() method of the PrintWriter which can insert formatted numbers into a text string.",NULL
"In that way the PrintWriter is a bit different from other Writer subclasses which tend to have mostly constructors that can take other Writer instances as parameters (except for a few, like OutputStreamWriter).","(""PrintWriter"", ""PrintWriter is a subclass of Writer"", ""Writer""); (""OutputStreamWriter"", ""OutputStreamWriter is a subclass of Writer"", ""Writer"")"
The Java PrintWriter class contains the powerful format() and printf() methods.,"(""PrintWriter"", ""The PrintWriter class contains the format() method, indicating a clear relationship between the two."", ""format()"")"
"The format() and printf() methods allow you to mix text and data in very advanced ways, using a formatting string.",NULL
The Java Reader (java.io.Reader) and Java Writer class (java.io.Writer) in Java IO work much like the InputStream and OutputStream with the exception that Reader and Writer are character based.,"(""Java Reader"", ""Java Reader is a part of the java.io.Reader package"", ""java.io.Reader""); (""Java Writer"", ""Java Writer is a part of the java.io.Writer package"", ""java.io.Writer""); (""Java Reader"", ""Java Reader works much like the InputStream, with the exception that Reader is character based"", ""InputStream""); (""Java Writer"", ""Java Writer works much like the OutputStream, with the exception that Writer is character based"", ""OutputStream""); (""java.io.Reader"", ""java.io.Reader is a part of the java.io package"", ""java.io""); (""java.io.Writer"", ""java.io.Writer is a part of the java.io package"", ""java.io""); (""InputStream"", ""InputStream and OutputStream are related in that they are both used for input/output operations, similar to how Reader and Writer are used"", ""OutputStream"")"
The Java Reader is the base class of all Reader's in the Java IO API.,"(""Java Reader"", ""The Java Reader is a subclass of Reader, indicating a clear inheritance relationship between the two classes."", ""Reader""); (""Java Reader"", ""The Java Reader is part of the Java IO API, indicating a clear membership relationship between the class and the package."", ""Java IO API"")"
The Java Writer class is the base class of all Writers in the Java IO API.,"(""Java Writer class"", ""The Java Writer class is the base class of all Writers, indicating a clear inheritance relationship between the two."", ""Writers""); (""Java Writer class"", ""The Java Writer class is part of the Java IO API, indicating that it belongs to or is contained within this package."", ""Java IO API"")"
Before you can use the SequenceInputStream you must import it in your Java class.,NULL
"This import statement should be at the top of your Java class, right under the package declaration.","(""Java Class"", ""The import statement is related to the Java class because it should be at the top of the Java class."", ""Import Statement""); (""Java Class"", ""The Java class is related to the package declaration because the package declaration is right above the Java class."", ""Package Declaration"")"
"The FileInputStream extends the InputStream class, so they can be used with the SequenceInputStream.","(""FileInputStream"", ""FileInputStream extends the InputStream class, indicating a subclass relationship"", ""InputStream""); (""FileInputStream"", ""FileInputStream can be used with the SequenceInputStream, indicating a usage relationship"", ""SequenceInputStream"")"
"When there is no more data to read from the second InputStream, the SequenceInputStream read() method will return -1, just like any other InputStream does.","(""SequenceInputStream"", ""The SequenceInputStream class has a read() method, indicating a relationship between the two."", ""read()""); (""InputStream"", ""The InputStream class also has a read() method, indicating a relationship between the two."", ""read()"")"
The Java Serializable interface (java.io.Serializable is a marker interface your classes must implement if they are to be serialized and deserialized.,"(""java.io"", ""java.io is a package that contains the java.io.Serializable interface"", ""java.io.Serializable""); (""Java"", ""Java has a Serializable interface that is used for serialization and deserialization"", ""Serializable""); (""Java"", ""Java has a package named java.io that contains various interfaces and classes for input/output operations"", ""java.io"")"
"Therefore, a class implementing Serializable does not have to implement any specific methods.",NULL
Implementing Serializable thus just tells the Java serialization classes that this class is intended for object serialization.,"(""Serializable"", ""The Serializable class is related to the Java class because it is used to tell the Java serialization classes that this class is intended for object serialization."", ""Java"")"
Here is an example of a class that implements the Java Serializable interface:,"(""Class"", ""The Class entity is related to the Serializable entity because it implements the Serializable interface."", ""Serializable""); (""Java"", ""The Java entity is related to the Class entity because the Class is an example in Java."", ""Class"")"
"As you can see, the Person class implements the Serializable interface, but does not actually implement any methods.",NULL
"In addition to implementing the Serializable interface, a class intended for serialization should also contain a private static final long variable named serialVersionUID.","(""Serializable"", ""A class intended for serialization should implement the Serializable interface."", ""class"")"
"Here is the Person class from before, with a serialVersionUID variable added:",NULL
"The serialVersionUID variable is used by Java's object serialization API to determine if a deserialized object was serialized (written) with the same version of the class, as it is now attempting to deserialize it into.","(""Java"", ""Java uses the Serialization API for object serialization"", ""Serialization""); (""Serialization"", ""The Serialization API is used to serialize and deserialize objects"", ""Object""); (""SerialVersionUID"", ""The serialVersionUID variable is used to determine the version of the object being deserialized"", ""Object"")"
Now the serialized Person object may not correspond to the new version of the Person class.,NULL
To detect such problems a class implementing Serializable should contain a serialVersionUID field.,NULL
"If you make big changes to the class, you should also change its serialVersionUID value.",NULL
"These other object serialization mechanisms typically do not require your Java classes to implement Serializable, by the way.",NULL
"They are typically using Java Reflection to inspect your class, so implementing the Serializable interface would be superflous - it would not add any useful information.","(""Java"", ""Java uses Reflection to inspect classes"", ""Reflection""); (""Java"", ""Java has the Serializable interface"", ""Serializable"")"
The class java.io.InputStream is the base class for all Java IO input streams.,NULL
"If you are writing a component that needs to read input from a stream, try to make our component depend on an InputStream, rather than any of it's subclasses (e.g.",NULL
"Doing so makes your code able to work with all types of input streams, instead of only the concrete subclass.","(""Code"", ""Code is able to work with all types of input streams"", ""Input Streams"")"
Otherwise your code will not be able to call the unread() method on the PushbackInputStream.,NULL
You typically read data from an InputStream by calling the read() method.,NULL
The read() method returns a int containing the byte value of the byte read.,NULL
"If there is no more data to be read, the read() method typically returns -1;",NULL
The class java.io.OutputStream is the base class of all Java IO output streams.,"(""java.io"", ""java.io is the package that contains the OutputStream class"", ""OutputStream"")"
"If you are writing a component that needs to write output to a stream, try to make sure that component depends on an OutputStream and not one of its subclasses.","(""OutputStream"", ""The OutputStream class is related to the component because the component depends on it to write output to a stream."", ""component"")"
You can even write your own stream classes to wrap the standard stream classes that comes with Java.,NULL
The Java StringReader class enables you to turn an ordinary String into a Reader.,"(""StringReader"", ""The StringReader class is related to the String class because it enables you to turn an ordinary String into a Reader."", ""String"")"
Closing a Java StringReader can be done using the close() method like this:,NULL
Notice that there is no explicit close() call on the StringReader.,NULL
The Java StringWriter class (java.io.StringWriter) enables you to obtain the characters written to a Writer as a String.,"(""StringWriter"", ""StringWriter is a type of Writer, as it enables you to obtain the characters written to a Writer as a String"", ""Writer""); (""StringWriter"", ""StringWriter is part of the java.io package"", ""java.io"")"
Third the characters written to the StringWriter are obtained via the two methods toString() and getBuffer().,"(""StringWriter"", ""The toString() method is related to the StringWriter class because it is used to obtain the characters written to the StringWriter."", ""toString()"")"
The method toString() returns the characters written to the StringWriter as a String.,"(""StringWriter"", ""The method toString() is related to StringWriter because it is used to return the characters written to the StringWriter."", ""toString()""); (""toString()"", ""The method toString() is related to String because it returns the characters as a String."", ""String"")"
The method getBuffer() returns the StringBuffer used by the StringWriter to build the string from the written characters.,"(""StringWriter"", ""The getBuffer() method is used by the StringWriter class to return the StringBuffer."", ""getBuffer()""); (""StringBuffer"", ""The getBuffer() method returns the StringBuffer used by the StringWriter."", ""getBuffer()"")"
Notice how there is no longer any explicit close() method call to the StringWriter instance.,"(""StringWriter"", ""The close() method is related to the StringWriter class because it is a method that can be called on an instance of StringWriter."", ""close()""); (""close()"", ""The close() method is related to the instance because it is a method that is called on an instance of a class, in this case, StringWriter."", ""instance"")"
The Java IO API is located in the Java IO package (java.io).,"(""Java IO API"", ""The Java IO API is located in the Java IO package, indicating a clear relationship between the two entities as the API is part of the package."", ""Java IO""); (""Java IO API"", ""The Java IO API is located in the java.io package, indicating a clear relationship between the two entities as the API is part of the package."", ""java.io"")"
If you look at the Java IO classes in the java.io package the vast amount of choices can be rather confusing.,NULL
"The purpose of this tutorial is to try to give you an overview of how all these classes are grouped, and the purpose behind them, so you don't have to wonder whether you chose the right class, or whether a class already exists for your purpose.","(""Tutorial"", ""The tutorial is related to the class because it provides an overview of how classes are grouped and their purpose."", ""Class"")"
"That tutorial gives you a quick overview of the central concepts in the Java IO API, and an overview of all the central classes in the Java IO API.","(""Java IO API"", ""Java IO API and Java IO are related as they refer to the same Java Input/Output package, with Java IO being a subset or abbreviation of Java IO API"", ""Java IO""); (""Java IO API"", ""Java IO API and IO API are related as they refer to the same Java Input/Output package, with IO API being a subset or abbreviation of Java IO API"", ""IO API"")"
The java.io package doesn't actually address all types of input and output.,"(""Java.io"", ""The Java.io package is related to input because it is mentioned in the context of addressing types of input and output."", ""input"")"
"Those types of input are covered elsewhere, for instance by the JFC classes in the Swing project, or the Servlet and HTTP packages in the Java Enterprise Edition.","(""JFC"", ""JFC classes are part of the Swing project"", ""Swing""); (""Servlet"", ""Servlet package is part of the Java Enterprise Edition"", ""Java Enterprise Edition"")"
"However, the Java IO package does not contain classes to open network sockets which are necessary for network communication.",NULL
"Once you have opened a socket (network connection) though, you read and write data to and from it via Java IO's InputStream and OutputStream classes.","(""InputStream"", ""InputStream is a part of Java IO, which provides input/output functionality"", ""Java IO"")"
"It contains classes that does much of the same as the Java IO and Java Networking APIs, but Java NIO can work in non-blocking mode.","(""Java NIO"", ""Java NIO is related to Java IO because it does much of the same as Java IO"", ""Java IO"")"
The tutorial trail called Java How To's and Utilities also contain a few Java IO utilities - e.g.,NULL
"Here is a table listing most (if not all) Java IO classes divided by input, output, being byte based or character based, and any more specific purpose they may be addressing, like buffering, parsing etc.","(""Java IO"", ""Java IO is related to Input because it includes input classes"", ""Input""); (""Java IO"", ""Java IO is related to Output because it includes output classes"", ""Output""); (""Java IO"", ""Java IO is related to Byte because it includes byte-based classes"", ""Byte""); (""Java IO"", ""Java IO is related to Character because it includes character-based classes"", ""Character""); (""Input"", ""Input and Output are related because they are both types of Java IO classes"", ""Output"")"
"The Java OutputStream class, java.io.OutputStream, is the base class of all output streams in the Java IO API.","(""OutputStream"", ""The OutputStream class is part of the java.io package, indicating a relationship between the two."", ""java.io.OutputStream""); (""OutputStream"", ""The OutputStream class is part of the Java IO API, indicating a relationship between the two."", ""Java IO API"")"
Subclasses of OutputStream include the Java BufferedOutputStream and the Java FileOutputStream among others.,"(""OutputStream"", ""BufferedOutputStream is a subclass of OutputStream"", ""BufferedOutputStream"")"
Here are some of the well-known subclasses of the Java OutputStream class:,NULL
The write() method of an OutputStream takes an int which contains the byte value of the byte to write.,NULL
This OutputStream write() example first creates a FileOutputStream to which the data will be written.,"(""OutputStream"", ""The OutputStream class has a method called write(), indicating a clear relationship between the two."", ""write()""); (""FileOutputStream"", ""FileOutputStream is a subclass of OutputStream, indicating a clear relationship between the two."", ""OutputStream"")"
The condition to exit the while loop is the return value of the method hasMoreData().,NULL
"The implementation of hasMoreData() is not shown, but imagine that it returns true if there is more data to write, and false if not.",NULL
"Inside the while loop the example calls the method getMoreData() to get the next data to write to the OutputStream, and then writes that data to the OutputStream.","(""While Loop"", ""The while loop calls the getMoreData method to get the next data."", ""GetMoreData""); (""GetMoreData"", ""The getMoreData method provides data to be written to the OutputStream."", ""OutputStream"")"
The Java OutputStream's flush() method flushes all data written to the OutputStream to the underlying data destination.,NULL
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your OutputStream has).",NULL
Here is an example of flushing data written to a Java OutputStream by calling its flush() method:,NULL
"What matters is, that once the while loop ends, and you are done writing data to the OutputStream, its close() method is called, which closes the OutputStream .",NULL
"Once the try block is exited, the close() method of the OutputStream is called automatically, because the OutputStream was declared inside the parentheses of the try block.","(""OutputStream"", ""The close() method is a part of the OutputStream class, indicating a relationship between the two entities."", ""close()""); (""try"", ""The OutputStream was declared inside the parentheses of the try block, indicating that the try block has a relationship with the OutputStream."", ""OutputStream"")"
You can convert a OutputStream to a character based Writer using the Java OutputStreamWriter class.,"(""OutputStream"", ""OutputStream is converted to a character based Writer using the Java OutputStreamWriter class"", ""OutputStreamWriter"")"
"The Java OutputStreamWriter class, java.io.OutputStreamWriter, is intended to wrap an Java OutputStream and thereby turning the byte based output stream into a character based Writer.","(""OutputStreamWriter"", ""OutputStreamWriter is intended to wrap an OutputStream, indicating a clear relationship between the two classes"", ""OutputStream""); (""OutputStreamWriter"", ""OutputStreamWriter turns the byte based output stream into a character based Writer, indicating a clear relationship between the two classes"", ""Writer""); (""OutputStreamWriter"", ""java.io.OutputStreamWriter is the package where the OutputStreamWriter class is located, indicating a clear relationship between the class and the package"", ""java.io.OutputStreamWriter""); (""OutputStream"", ""java.io is the package where the OutputStream class is likely located, given the context of the OutputStreamWriter class, indicating a relationship between the class and the package"", ""java.io.OutputStreamWriter"")"
"The Java OutputStreamWriter is useful if you need to write characters to a file, encoded as e.g.",NULL
The Java OutputStreamWriter is a subclass of the Java Writer class.,NULL
"The Java OutputStreamWriter also has alternative constructors that allow you to specify the character set (ISO-Latin1, UTF-8, UTF-16 etc.)",NULL
The Java OutputStreamWriter's flush() method flushes all data written to the OutputStreamWriter to the underlying data destination.,"(""OutputStreamWriter"", ""The flush() method is a part of the OutputStreamWriter class, indicating a relationship between the two."", ""flush()""); (""java"", ""The OutputStreamWriter is part of the Java package, indicating a relationship between the two."", ""OutputStreamWriter"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your OutputStreamWriter has).",NULL
Here is an example of flushing data written to a Java OutputStreamWriter by calling its flush() method:,NULL
These bytes will then be read again the next time you call read().,"(""READ"", ""The method READ is related to BYTES because it is used to read bytes."", ""BYTES"")"
"The Java PushbackInputStream is a subclass of the Java InputStream so it inherits its public methods - read(), close() etc.","(""PushbackInputStream"", ""PushbackInputStream is a subclass of InputStream, indicating an inheritance relationship"", ""InputStream""); (""PushbackInputStream"", ""PushbackInputStream inherits the read() method from its superclass"", ""read()""); (""PushbackInputStream"", ""PushbackInputStream inherits the close() method from its superclass"", ""close()"")"
The call to read() reads a byte just like from an InputStream.,NULL
The call to unread() pushes a byte back into the PushbackInputStream.,NULL
The next time read() is called the pushed back bytes will be read first.,NULL
"If you push back multiple bytes into the PushbackInputStream, the latest byte pushed back will be returned first from read(), just like on a stack.","(""PushbackInputStream"", ""The PushbackInputStream class has a read() method that returns the latest byte pushed back."", ""read()"")"
"You read bytes from the Java PushbackInputStream via its read() method, just like you do from a regular InputStream .","(""PushbackInputStream"", ""The PushbackInputStream class has a read() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""read()""); (""InputStream"", ""The InputStream class also has a read() method, indicating a relationship between the InputStream class and the read() method, as the method is part of this class."", ""read()"")"
"Notice, that once the PushbackInputStream has no more bytes to read, from its underlying PushbackInputStream, the read() method will return -1.","(""PushbackInputStream"", ""The read() method is a part of the PushbackInputStream class, indicating a relationship between the two entities as the method is used to read bytes from the PushbackInputStream."", ""read()"")"
To push a byte back into the Java PushbackInputStream you use the unread() method.,"(""PushbackInputStream"", ""The PushbackInputStream class contains the unread() method, indicating a clear relationship between the two entities as the method is used in conjunction with the class."", ""unread()""); (""Java"", ""The Java package is related to the PushbackInputStream class, as the class is part of the Java package, providing a connection between the two entities."", ""PushbackInputStream"")"
"This example first reads a byte from the PushbackInputStream, then pushes it back into the PushbackInputStream, and then reads that byte back again with the final read() call.","(""PushbackInputStream"", ""The PushbackInputStream is related to the read method because it is the object on which the read method is called."", ""read"")"
"The Java PushbackReader class, java.io.PushbackReader, is intended to be used when you parse data from a Reader.","(""PushbackReader"", ""The PushbackReader class is related to the Reader class because it is intended to be used when you parse data from a Reader."", ""Reader"")"
These characters will then be read again the next time you call read().,NULL
The call to read() reads a character from the PushbackReader just like from any other Reader.,"(""PushbackReader"", ""The PushbackReader class has a read() method that reads a character from it."", ""read()""); (""Reader"", ""The Reader class has a read() method that reads a character from it, and PushbackReader is compared to any other Reader in this context."", ""read()"")"
The call to unread() pushes a character back into the PushbackReader.,NULL
The next time read() is called the pushed back characters will be read first.,NULL
"If you push back multiple characters into the PushbackReader, the latest pushed back character will be returned first from the read() method, just like with a stack.",NULL
You read characters from a Java PushbackReader just like you do from a Java Reader - because PushbackReader is a Java Reader subclass.,NULL
"In other words, you use its read() method which is inherited from the Reader class.",NULL
Here is an example of reading characters from a Java PushbackReader via its read() method:,"(""PushbackReader"", ""The PushbackReader class has a read() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""read()""); (""Java"", ""The Java package contains the PushbackReader class, establishing a relationship between the package and the class as the class is a component of the package."", ""PushbackReader"")"
"The read() returns an int which you will have to cast to a char yourself, as shown in the example above.","(""Read"", ""The Read method returns an Int, indicating a relationship between the two entities."", ""Int""); (""Read"", ""The Read method returns an int which you will have to cast to a Char yourself, indicating a relationship between the Read method and Char."", ""Char"")"
When there are no characters available in the PushbackReader the read() method will return the int value -1.,NULL
To push a character back into a Java PushbackReader you must call its unread() method.,NULL
"This way the nextToken() method can ""sample"" the first character of the next token, and based on that decide what kind of token it is, and what read method to call for that kind of token.",NULL
"For the readSingleTokenWord() however, it is necessary, as the character read is the first character of the token's value.","(""ReadSingleTokenWord"", ""The ReadSingleTokenWord method is related to the Token class because it reads the first character of the token's value."", ""Token""); (""Token"", ""The Token class is related to the Character class because a token's value is composed of characters."", ""Character"")"
"The implementations of the readDoubleQuotedToken(), readSingleQuotedToken() and readSingleWordToken() have been left out to keep the example short.","(""ReadDoubleQuotedToken"", ""These two methods are related as they are both mentioned together in the context of being left out to keep the example short, implying they are part of a similar functionality or category."", ""ReadSingleQuotedToken""); (""ReadDoubleQuotedToken"", ""These two methods are related as they are both mentioned together in the context of being left out to keep the example short, implying they are part of a similar functionality or category."", ""ReadSingleWordToken"")"
"Just imagine they read a token enclosed by double quotes (""), single quotes (') or a token which ends with a non-word character (e.g.",NULL
The Java RandomAccessFile class in the Java IO API allows you to move navigate a file and read from it or write to it as you please.,NULL
Before you can work with the RandomAccessFile class you must instantiate it.,NULL
You can obtain the current position of a Java RandomAccessFile using its getFilePointer() method.,NULL
Here is an example of obtaining the current position of a RandomAccessFile using its getFilePointer() method:,NULL
Reading a byte from a Java RandomAccessFile is done using its read() method.,NULL
The read() method reads the byte located a the position in the file currently pointed to by the file pointer in the RandomAccessFile instance.,"(""RandomAccessFile"", ""The read() method is a part of the RandomAccessFile class, indicating a relationship between the two."", ""read()""); (""RandomAccessFile"", ""The RandomAccessFile instance is related to the file, as it reads from the file."", ""file""); (""RandomAccessFile"", ""The RandomAccessFile instance is related to the file pointer, as the file pointer is used to point to the position in the file."", ""file pointer""); (""read()"", ""The read() method is related to the file, as it reads the byte located at the position in the file."", ""file"")"
Here is a thing the JavaDoc forgets to mention: The read() method increments the file pointer to point to the next byte in the file after the byte just read!,"(""Read"", ""The Read method is related to the File because it increments the file pointer to point to the next byte in the file after the byte just read."", ""File"")"
This means that you can continue to call read() without having to manually move the file pointer.,NULL
This example reads a sequence of bytes into the dest byte array passed as parameter to the read() method.,NULL
The read() method will start reading in the file from the current file position of the RandomAccessFile.,NULL
"The read() method will start writing data into the byte array starting from the array position provided by the offset parameter, and at most the number of bytes provided by the length parameter.","(""Read"", ""The read() method uses the offset parameter to determine the starting position for writing data into the byte array."", ""Offset"")"
You can write a single byte to a RandomAccessFile using its write() method which takes an int as parameter.,"(""RandomAccessFile"", ""The RandomAccessFile class has a write() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""write()""); (""write()"", ""The write() method takes an int as a parameter, establishing a relationship between the method and the int data type as the method utilizes the int type for its operation."", ""int"")"
"Remember, calling this write() method will advance the file position of the RandomAccessFile by 1.","(""RandomAccessFile"", ""The write() method is called on the RandomAccessFile class, indicating a relationship between the two entities."", ""write()"")"
Writing to a RandomAccessFile can be done using one it its many write() methods.,NULL
Just like with the read() method the write() method advances the file pointer after being called.,NULL
The RandomAccessFile has a close() method which must be called when you are done using the RandomAccessFile instance.,NULL
You can see example of calls to close() in the examples above.,NULL
"The Java Reader class, java.io.Reader, is the base class for all Reader subclasses in the Java IO API.","(""Java Reader"", ""The Java Reader class is also known as java.io.Reader, indicating they are the same entity."", ""java.io.Reader""); (""Java Reader"", ""The Java Reader class is part of the Java IO API, indicating it belongs to the Java IO package."", ""Java IO""); (""java.io.Reader"", ""java.io.Reader is part of the Java IO API, indicating it belongs to the Java IO package."", ""Java IO""); (""Reader"", ""The Reader class is part of the Java IO API, indicating it belongs to the Java IO package."", ""Java IO""); (""Java Reader"", ""The Java Reader class is the base class for all Reader subclasses, indicating a subclass relationship."", ""Reader"")"
"This is done when you instantiate the Reader (actually, when you instantiate one of its subclasses).",NULL
You will normally use a Reader subclass rather than a Reader directly.,NULL
Here is an example of creating a Java FileReader which is a subclass of Java Reader:,NULL
The read() method of a Java Reader returns an int which contains the char value of the next character read.,NULL
"If the read() method returns -1, there is no more data to read in the Reader, and it can be closed.",NULL
"If not, it processes that char and continues reading until -1 is returned from the Reader read() method.",NULL
"The Java Reader class also has a read() method that takes a char array as parameter, as well as a start offset and length.","(""Reader"", ""The Reader class has a read() method, indicating that read() is a part of the Reader class."", ""read()"")"
The Java Reader class has a method named skip() which can be used to skip over a number of characters in the input that you do not want to read.,NULL
The Java StreamTokenizer class (java.io.StreamTokenizer) can tokenize the characters read from a Reader into tokens.,"(""StreamTokenizer"", ""The StreamTokenizer class can tokenize the characters read from a Reader into tokens, indicating a relationship between the two classes."", ""Reader""); (""StreamTokenizer"", ""The StreamTokenizer class is located in the java.io package, indicating a relationship between the class and the package."", ""java.io"")"
You do so by calling the nextToken() method of the StreamTokenizer inside a loop.,"(""StreamTokenizer"", ""The nextToken() method is a part of the StreamTokenizer class, indicating a clear relationship between the two entities as the method is called on the class."", ""nextToken()"")"
"After each call to nextToken() the StreamTokenizer has several fields you can read to see what kind of token was read, it's value etc.",NULL
"Java has 3 streams called System.in, System.out, and System.err which are commonly used to provide input to, and output from Java applications.","(""Java"", ""Java has System.in as one of its streams, indicating a relationship between the two."", ""System.in""); (""Java"", ""Java has System.out as one of its streams, indicating a relationship between the two."", ""System.out"")"
Most commonly used is probably System.out for writing output to the console from console programs (command line applications).,"(""System.out"", ""System.out is used for writing output to the console from console programs"", ""console programs""); (""console programs"", ""console programs use System.out for writing output to the console"", ""System.out""); (""console"", ""System.out is used for writing output to the console"", ""System.out"")"
"System.in, System.out and System.err are initialized by the Java runtime when a Java VM starts up, so you don't have to instantiate any streams yourself (although you can exchange them at runtime).","(""System.in"", ""System.in is initialized by the Java runtime when a Java VM starts up"", ""Java runtime""); (""System.out"", ""System.out is initialized by the Java runtime when a Java VM starts up"", ""Java runtime""); (""System.err"", ""System.err is initialized by the Java runtime when a Java VM starts up"", ""Java runtime""); (""Java VM"", ""The Java runtime is responsible for the Java VM startup"", ""Java runtime""); (""Java"", ""Java is the package that contains the Java VM"", ""Java VM"")"
System.in is an InputStream which is typically connected to keyboard input of console programs.,"(""System.in"", ""System.in is an instance of InputStream, indicating a clear inheritance relationship between the two entities."", ""InputStream""); (""System.in"", ""System.in is connected to keyboard input, indicating a clear relationship of input source and destination."", ""keyboard input""); (""System.in"", ""System.in is typically connected to keyboard input of console programs, indicating a clear relationship of input source and program type."", ""console programs"")"
"In other words, if you start a Java application from the command line, and you type something on the keyboard while the CLI console (or terminal) has focus, the keyboard input can typically be read via System.in from inside that Java application.","(""Java application"", ""The Java application can read keyboard input via System.in"", ""System.in""); (""CLI console"", ""The Java application is started from the CLI console"", ""Java application""); (""keyboard"", ""The keyboard input can be read by the Java application"", ""Java application""); (""CLI"", ""The CLI console is part of the CLI"", ""CLI console"")"
"However, it is only keyboard input directed to that Java application (the console / terminnal that started the application) which can be read via System.in.","(""System"", ""System.in is a method of the System class, indicating a relationship between the two entities"", ""System.in""); (""Java"", ""The System class is part of the Java package, indicating a relationship between the two entities"", ""System"")"
Keyboard input for other applications cannot be read via System.in .,"(""System"", ""System.in is a method of the System class, indicating a relationship between the two entities."", ""System.in"")"
"System.in is not used as often since data is commonly passed to a command line Java application via command line arguments, files, or possibly via network connections if the application is designed for that.","(""System.in"", ""System.in is used in command line Java applications"", ""command line Java application""); (""command line Java application"", ""command line Java applications receive data via command line arguments"", ""command line arguments""); (""command line Java application"", ""command line Java applications receive data via files"", ""files""); (""command line Java application"", ""command line Java applications receive data via network connections if designed for that"", ""network connections"")"
System.out normally outputs the data you write to it to the CLI console / terminal.,"(""System.out"", ""System.out outputs data to the CLI console / terminal, indicating a relationship between the two entities."", ""CLI""); (""System.out"", ""System.out outputs data to the console, indicating a relationship between the two entities."", ""console""); (""System.out"", ""System.out outputs data to the terminal, indicating a relationship between the two entities."", ""terminal""); (""CLI"", ""The CLI console is a part of the command-line interface, indicating a relationship between the two entities."", ""console""); (""CLI"", ""The CLI terminal is another term for the command-line interface, indicating a relationship between the two entities."", ""terminal"")"
System.out is often used from console-only programs like command line tools as a way to display the result of their execution to the user.,"(""System.out"", ""System.out is used from console-only programs as a way to display the result of their execution to the user."", ""console-only programs"")"
System.err works like System.out except it is normally only used to output error texts.,NULL
"Some programs (like Eclipse) will show the output to System.err in red text, to make it more obvious that it is error text.",NULL
"Even if the 3 System streams are static members of the java.lang.System class, and are pre-instantiated at JVM startup, you can change what streams to use for each of them.","(""System"", ""System is a part of the java.lang.System class"", ""java.lang.System""); (""java.lang.System"", ""java.lang.System is related to JVM as it is pre-instantiated at JVM startup"", ""JVM"")"
"Just set a new InputStream for System.in or a new OutputStream for System.out or System.err, and all further data will be read / written to the new stream.","(""System"", ""System.in is a method of the System class"", ""System.in""); (""System"", ""System.out is a method of the System class"", ""System.out""); (""System"", ""System.err is a method of the System class"", ""System.err""); (""InputStream"", ""InputStream is related to System.in as it can be set as a new stream for System.in"", ""System.in""); (""OutputStream"", ""OutputStream is related to System.out as it can be set as a new stream for System.out"", ""System.out""); (""OutputStream"", ""OutputStream is related to System.err as it can be set as a new stream for System.err"", ""System.err"")"
"To set a new System stream, use one of th emethods System.setIn(), System.setOut() or System.setErr().","(""System"", ""System is the class that contains the method setIn()"", ""setIn""); (""System"", ""System is the class that contains the method setOut()"", ""setOut"")"
"Now all data written to System.out should be redirected into the file ""c:\\data\\system.out.txt"".","(""System.out"", ""System.out is related to the file because it is being redirected into it"", ""file"")"
"Keep in mind though, that you should make sure to flush System.out and close the file before the JVM shuts down, to be sure that all data written to System.out is actually flushed to the file.","(""System.out"", ""System.out is related to JVM because the JVM shuts down and this affects the flushing of data written to System.out"", ""JVM""); (""System.out"", ""System.out is related to the file because data written to System.out is flushed to the file"", ""file"")"
The Java Writer class (java.io.Writer) is the base class for all Writer subclasses in the Java IO API.,"(""Java Writer class"", ""The Java Writer class is also known as java.io.Writer, indicating they are the same entity."", ""java.io.Writer""); (""Java Writer class"", ""The Java Writer class is part of the Java IO API, indicating a relationship between the class and the package."", ""Java IO API"")"
"The Java Writer subclasses can normally handle UTF-8 and UTF-16 encoding for you, so you don't have to worry about that.","(""Java Writer"", ""Java Writer is related to UTF-8 because it can handle UTF-8 encoding"", ""UTF-8"")"
You will normally use a Writer subclass rather than a Writer directly.,NULL
The Java Writer's flush() method flushes all data written to the Writer to the underlying data destination.,NULL
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your Writer has).",NULL
Here is an example of flushing data written to a Java Writer by calling its flush() method:,"(""Writer"", ""The Writer class has a flush() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""flush()""); (""Java"", ""The Java package contains the Writer class, indicating a relationship between the package and the class as the class is part of the package."", ""Writer"")"
"The concrete implementations of hasMoreCharacters() and getNextCharacter() are left out, but they are not really super important to understand the principle of this example.",NULL
"What matters is, that once the while loop ends, and you are done writing data to the Writer, its close() method is called, which closes the Writer .",NULL
"Once the try block is exited, the close() method of the Writer is called automatically, because the Writer was declared inside the parentheses of the try block.","(""Writer"", ""The close() method is a part of the Writer class, indicating a relationship between the two entities."", ""close()""); (""try"", ""The Writer was declared inside the parentheses of the try block, indicating that the try block has a relationship with the Writer entity."", ""Writer"")"
"The SQL dialect used by the various different databases will vary slightly, so to be 100% database independent, you SQL must also be 100% database independent (i.e.",NULL
The Java String parameter passed to the Class forName() method is the name of the JDBC driver class for the given JDBC driver.,"(""Java"", ""Java is related to String because Java is a programming language that uses the String class"", ""String""); (""Java"", ""Java is related to Class because Java is an object-oriented programming language that uses classes, including the Class class"", ""Class""); (""Java"", ""Java is related to JDBC because Java is a programming language that uses JDBC for database connectivity"", ""JDBC""); (""String"", ""String is related to Class because the String parameter is passed to the Class forName() method"", ""Class""); (""String"", ""String is related to JDBC because the String parameter represents the name of the JDBC driver class"", ""JDBC""); (""Class"", ""Class is related to JDBC because the Class forName() method is used to load the JDBC driver class"", ""JDBC""); (""forName()"", ""forName() is related to Class because forName() is a method of the Class class"", ""Class""); (""forName()"", ""forName() is related to JDBC because the forName() method is used to load the JDBC driver class"", ""JDBC"")"
You will have to find the right class name for the JDBC driver you are using.,NULL
"Typically, each database has its own JDBC driver, so you will have to look up what the JDBC driver class name is (if you are using pre Java 6).","(""JDBC"", ""JDBC is related to JDBC driver because a JDBC driver is typically used to connect to a JDBC database"", ""JDBC driver""); (""Java"", ""Java is related to JDBC because JDBC is a Java-based API for connecting to databases"", ""JDBC"")"
"First you add the SQL statements to be executed in the batch, using the addBatch() method.",NULL
The int[] array returned by the executeBatch() method is an array of int telling how many records were affected by each executed SQL statement in the batch.,"(""Executebatch"", ""The executeBatch() method returns an int[] array"", ""Int"")"
"Second, each set of parameter values are inserted into the preparedStatement, and the addBatch() method is called.","(""Parameter"", ""The parameters are inserted into the PreparedStatement"", ""PreparedStatement"")"
"Third, the executeBatch() method is called, which executes all the batch updates.",NULL
"By the way, imagine that the used Person class looks like this:",NULL
A java.sql.CallableStatement is used to call stored procedures in a database.,"(""CallableStatement"", ""CallableStatement is a part of the java.sql package"", ""java.sql"")"
"A stored procedure is like a function or method in a class, except it lives inside the database.","(""Stored Procedure"", ""A stored procedure is compared to a function or method in a class, indicating a relationship between the two concepts."", ""Class""); (""Function"", ""A function is compared to a method in a class, indicating a relationship between the two concepts."", ""Class""); (""Method"", ""A method is said to be in a class, indicating a relationship between the two concepts."", ""Class"")"
You create an instance of a CallableStatement by calling the prepareCall() method on a connection object.,"(""CallableStatement"", ""CallableStatement is created by calling the prepareCall() method"", ""prepareCall()""); (""prepareCall()"", ""The prepareCall() method is called on a connection object"", ""connection"")"
"If the stored procedure returns a ResultSet, and you need a non-default ResultSet (e.g.",NULL
The executeQuery() method is used if the stored procedure returns a ResultSet.,NULL
"If the stored procedure just updates the database, you can call the executeUpdate() method instead, like this:",NULL
"The JDBC Connection class, java.sql.Connection, represents a database connection to a relational database.","(""JDBC Connection"", ""JDBC Connection is another name for the java.sql.Connection class"", ""java.sql.Connection""); (""java.sql.Connection"", ""java.sql.Connection is a part of the java.sql package"", ""java.sql"")"
Each JDBC driver has a primary driver class that initializes the driver when it is loaded.,NULL
You open a JDBC Connection by call the java.sql.DriverManager class method getConnection().,"(""java.sql.DriverManager"", ""The java.sql.DriverManager class contains the getConnection method, indicating a relationship between the two entities."", ""getConnection""); (""JDBC Connection"", ""A JDBC Connection is opened by calling the java.sql.DriverManager class, establishing a relationship between the two entities."", ""java.sql.DriverManager"")"
This is how calling getConnection() only with the URL as parameter looks:,NULL
"The second variant of getConnection() takes both a database URL, a user name and a password as parameters.","(""GETCONNECTION"", ""The getConnection method takes a database URL as a parameter, indicating a relationship between the two."", ""DATABASE URL""); (""GETCONNECTION"", ""The getConnection method takes a user name as a parameter, indicating a relationship between the two."", ""USER NAME"")"
Here is an example of calling that variant of getConnection() :,NULL
The third variant of getConnection() takes a database URL and a Properties object as parameter.,NULL
"The JDBC Connection setAutoCommit() method is used to switch the connection into, or out of, auto commit mode.",NULL
"When not in auto commit mode, each database transaction must be explicitly committed by calling the Connection commit() method.",NULL
"Keep in mind, that if some of the operations in the transaction fail, you would most likely want to call the rollback() method instead of commit().","(""Transaction"", ""The Transaction class is related to the Rollback method because it is likely to call the rollback() method if some operations in the transaction fail."", ""Rollback"")"
The Java JDBC Connection rollback() method rolls back the operations executed within the currently ongoing transaction.,"(""Java"", ""The Java class is related to the JDBC Connection class because JDBC is a Java API."", ""JDBC Connection""); (""JDBC Connection"", ""The JDBC Connection class is related to the rollback() method because the rollback() method is used with the JDBC Connection class."", ""rollback()"")"
Exactly how to handle the calls to commit() and / or rollback() is covered in the JDBC Transactions Tutorial.,"(""JDBC"", ""JDBC is related to Transactions because it is mentioned as a part of the JDBC Transactions Tutorial."", ""Transactions""); (""JDBC"", ""JDBC is related to commit because it is mentioned as a part of the JDBC Transactions Tutorial that covers how to handle calls to commit()."", ""commit""); (""JDBC"", ""JDBC is related to rollback because it is mentioned as a part of the JDBC Transactions Tutorial that covers how to handle calls to rollback()."", ""rollback""); (""Transactions"", ""Transactions is related to commit because it is mentioned as a part of the JDBC Transactions Tutorial that covers how to handle calls to commit()."", ""commit""); (""Transactions"", ""Transactions is related to rollback because it is mentioned as a part of the JDBC Transactions Tutorial that covers how to handle calls to rollback()."", ""rollback"")"
Here is a simple example of calling the JDBC Connection rollback() method:,"(""JDBC Connection"", ""The JDBC Connection class has a rollback() method, indicating a relationship between the two entities as the method is a part of the class."", ""rollback()"")"
Notice how rollback() is called within the catch-block of a try-catch block.,"(""Rollback"", ""Rollback is called within the try-block, indicating a relationship between the method and the class"", ""Try"")"
Here is an example of creating a JDBC Statement instance via the JDBC Connection createStatement() method:,"(""JDBC Connection"", ""JDBC Connection uses the createStatement() method to create a JDBC Statement instance"", ""createStatement()""); (""JDBC Connection"", ""JDBC Connection creates a JDBC Statement instance via the createStatement() method"", ""JDBC Statement"")"
Here is an example of creating a JDBC PreparedStatement instance via the JDBC Connection prepareStatement() method:,"(""JDBC Connection"", ""The prepareStatement() method is a part of the JDBC Connection class, indicating a relationship between the two entities."", ""prepareStatement()""); (""JDBC Connection"", ""The JDBC Connection class is used to create a JDBC PreparedStatement instance via the prepareStatement() method, indicating a relationship between the two entities."", ""JDBC PreparedStatement"")"
The JDBC Connection getMetaData() method returns a JDBC DatabaseMetaData object which can be used to introspect the database the JDBC Connection is connected to.,"(""JDBC Connection"", ""The JDBC Connection uses the getMetaData() method to retrieve metadata."", ""getMetaData()""); (""getMetaData()"", ""The getMetaData() method returns a JDBC DatabaseMetaData object."", ""JDBC DatabaseMetaData"")"
Here is an example of creating a JDBC DatabaseMetaData object via the JDBC Connection getMetaData() method:,"(""JDBC Connection"", ""The getMetaData() method is a part of the JDBC Connection class, indicating a relationship between the two."", ""getMetaData()""); (""JDBC Connection"", ""The JDBC DatabaseMetaData object is created via the JDBC Connection, indicating a relationship between the two."", ""JDBC DatabaseMetaData"")"
Through the java.sql.DatabaseMetaData interface you can obtain meta data about the database you have connected to.,NULL
"First you call the getTables() method, passing it 4 parameters which are all null.",NULL
The ResultSet returned from the getTables() method contains a list of table names matching the 4 given parameters (which were all null).,NULL
The ResultSet returned by the getColumns() method contains a list of columns for the given table.,"(""getColumns()"", ""The getColumns() method returns a ResultSet, indicating a clear relationship between the two entities."", ""ResultSet""); (""table"", ""The ResultSet contains a list of columns for the given table, indicating a relationship between the table and the ResultSet."", ""ResultSet"")"
The column type is an integer matching one of the type constants found in java.sql.Types,"(""Java"", ""Java is related to Sql because Sql is a part of the Java package"", ""Sql"")"
"First you call the getPrimaryKeys() method, passing 3 parameters to it.",NULL
The ResultSet returned by the getPrimaryKeys() method contains a list of columns which make up the primary key of the given table.,"(""getPrimaryKeys"", ""The getPrimaryKeys method returns a ResultSet, indicating a clear relationship between the two entities."", ""ResultSet""); (""table"", ""The ResultSet contains information about the primary key of the given table, indicating a relationship between the table and the ResultSet."", ""ResultSet"")"
"A JDBC driver is a set of Java classes that implement the JDBC interfaces, targeting a specific database.","(""JDBC"", ""JDBC is related to JDBC interfaces because a JDBC driver implements the JDBC interfaces"", ""JDBC interfaces""); (""JDBC"", ""JDBC is related to Java because a JDBC driver is a set of Java classes"", ""Java"")"
A JDBC driver is a collection of Java classes that enables you to connect to a certain database.,"(""JDBC"", ""JDBC is a collection of Java classes"", ""Java""); (""JDBC"", ""JDBC enables you to connect to a certain database"", ""database"")"
"This works for executing queries too, using the executeQuery() method, which returns a ResultSet.",NULL
"The ResultSet.next() method moves to the next row in the ResultSet, if there are anymore rows.",NULL
You need to call next() at least one time before you can read any data.,NULL
Before the first next() call the ResultSet is positioned before the first row.,NULL
"You can get column data for the current row by calling some of the getXXX() methods, where XXX is a primitive data type.",NULL
The column name to get the value of is passed as parameter to any of these getXXX() method calls.,"(""Getxxx"", ""The getxxx method is related to Column Name because it is used to get the value of the column."", ""Column Name"")"
"You can get the index of a given column by calling the ResultSet.findColumn() method, like this:",NULL
The text about queries shows how the result of a query is returned as a java.sql.ResultSet.,"(""Java"", ""Java is related to Sql because Sql is a part of the Java package"", ""Sql""); (""Java"", ""Java is related to ResultSet because ResultSet is a class in the Java package"", ""ResultSet"")"
"The next() method returns true if the ResultSet has a next record, and moves the ResultSet to point to the next record.",NULL
"If there were no more records, next() returns false, and you can no longer.",NULL
"Once the next() method has returned false, you should not call it anymore.",NULL
Here is an example of iterating a ResultSet using the next() method:,NULL
"As you can see, the next() method is actually called before the first record is accessed.",NULL
"Once next() has been called once, it points at the first record.",NULL
"Similarly, when next() is called and returns false, the ResultSet is actually pointing after the last record.",NULL
You do so by calling one or more of the many getXXX() methods.,"(""GetXXX"", ""The GetXXX method is related to the User class because it is being called by the user."", ""User"")"
"You pass the name of the column to get the value of, to the many getXXX() methods.",NULL
"There are a lot of getXXX() methods you can call, which return the value of the column as a certain data type, e.g.",NULL
Here is a list of quick examples of these getXXX() methods:,NULL
The getXXX() methods also come in versions that take a column index instead of a column name.,"(""GetXXX"", ""The getXXX() methods are related to the column index because they come in versions that take a column index instead of a column name."", ""column index"")"
"If you do not know the index of a certain column you can find the index of that column using the ResultSet.findColumn(String columnName) method, like this:",NULL
The DatabaseMetaData.supportsResultSetType(int type) method returns true or false depending on whether the given type is supported or not.,NULL
The DatabaseMetaData.supportsResultSetConcurrency(int concurrency) method returns true or false depending on whether the given concurrency mode is supported or not.,NULL
It is when updateRow() is called that the database is updated with the values of the row.,"(""UpdateRow"", ""UpdateRow method is related to the Database because it updates the database with the values of the row."", ""Database"")"
"If you call updateRow() inside a transaction, the data is not actually committed to the database until the transaction is committed.","(""UpdateRow"", ""UpdateRow is related to Transaction because it is called inside a transaction"", ""Transaction""); (""Transaction"", ""Transaction is related to Database because it commits data to the database"", ""Database"")"
"The row pointed to after calling moveToInsertRow() is a special row, a buffer, which you can use to build up the row until all column values has been set on the row.",NULL
"Once the row is ready to be inserted into the ResultSet, call the insertRow() method.",NULL
"If you need to insert another row, explicitly call moveToInsertRow() to signal this to the ResultSet.",NULL
The ResultSet holdability determines if a ResultSet is closed when the commit() method of the underlying connection is called.,"(""ResultSet"", ""The ResultSet is related to the commit() method because the commit() method affects the ResultSet's holdability."", ""commit()""); (""ResultSet"", ""The ResultSet is related to the connection because the ResultSet is associated with the underlying connection."", ""connection"")"
The DatabaseMetaData.supportsResultSetHoldability(int holdability) returns true or false depending on whether the given holdability mode is supported or not.,NULL
The CLOSE_CURSORS_OVER_COMMIT holdability means that all ResultSet instances are closed when connection.commit() method is called on the connection that created the ResultSet.,"(""CLOSE_CURSORS_OVER_COMMIT"", ""The CLOSE_CURSORS_OVER_COMMIT holdability is related to ResultSet because it determines the behavior of all ResultSet instances when the commit method is called."", ""ResultSet""); (""connection"", ""The connection is related to ResultSet because it is the entity that creates the ResultSet instances."", ""ResultSet""); (""connection"", ""The connection is related to the commit method because the commit method is called on the connection."", ""commit"")"
The HOLD_CURSORS_OVER_COMMIT holdability means that the ResultSet is kept open when the connection.commit() method is called on the connection that created the ResultSet.,"(""HOLD_CURSORS_OVER_COMMIT"", ""HOLD_CURSORS_OVER_COMMIT is related to ResultSet because it determines the holdability of the ResultSet"", ""ResultSet""); (""connection"", ""The connection that created the ResultSet is related to the ResultSet because it has control over the ResultSet's lifetime"", ""ResultSet""); (""connection"", ""The connection is related to the connection.commit method because the method is called on the connection"", ""connection.commit"")"
"Thus, you can open a ResultSet, update rows in it, call connection.commit() and still keep the same ResultSet open for future transactions on the same rows.","(""ResultSet"", ""The ResultSet is related to the connection because it is used in the context of a database transaction, and the connection is used to commit changes made to the ResultSet."", ""connection""); (""connection"", ""The connection and commit are related because the commit method is called on the connection object to save changes made to the database."", ""commit"")"
"The Java JDBC Statement, java.sql.Statement, interface is used to execute SQL statements against a relational database.","(""Java"", ""Java is related to JDBC because JDBC is a Java API"", ""JDBC""); (""Java"", ""Java is related to Statement because Statement is a Java interface"", ""Statement""); (""JDBC"", ""JDBC is related to Statement because Statement is used to execute SQL statements against a relational database using JDBC"", ""Statement""); (""java.sql"", ""java.sql is related to Statement because Statement is an interface in the java.sql package"", ""Statement"")"
"You do so by calling its executeQuery() method, passing an SQL statement as parameter.",NULL
The Statement executeQuery() method returns a Java JDBC ResultSet which can be used to navigate the response of the query.,"(""Statement"", ""The Statement class has a method called executeQuery(), indicating a relationship between the two."", ""executeQuery()""); (""executeQuery()"", ""The executeQuery() method returns a ResultSet, indicating a relationship between the two, where executeQuery() is the source and ResultSet is the target."", ""ResultSet"")"
Here is an example of calling the Java JDBC Statement executeQuery() and navigating the returned ResultSet:,"(""Statement"", ""The Statement class has a method called executeQuery(), indicating a clear relationship between the two."", ""executeQuery()""); (""Statement"", ""The Statement class is related to the ResultSet class because the executeQuery() method of the Statement class returns a ResultSet object."", ""ResultSet""); (""JDBC"", ""The JDBC package is related to the Statement class because the Statement class is part of the JDBC package."", ""Statement"")"
"The rowsAffected returned by the statement.executeUpdate(sql) call, tells how many records in the database were affected by the SQL statement.","(""Statement"", ""The ExecuteUpdate method is a part of the Statement class, indicating a relationship between the two entities."", ""ExecuteUpdate""); (""Statement"", ""The RowsAffected is returned by the Statement, indicating a relationship between the Statement class and the RowsAffected class."", ""RowsAffected"")"
The classic example of when transactions are necessary is the example of bank accounts.,"(""Bank Accounts"", ""Bank accounts are related to transactions because transactions are often used to manage and update the state of bank accounts."", ""Transactions"")"
"But, instead of calling the executeQuery() method, you call the executeUpdate() method.",NULL
The executeUpdate() method is used for both of these types of updates.,NULL
"Again, the rowsAffected returned by the statement.executeUpdate(sql) call, tells how many records in the database were affected by the SQL statement.","(""Statement"", ""The Statement class has a method called ExecuteUpdate, which establishes a relationship between the two entities."", ""ExecuteUpdate""); (""ExecuteUpdate"", ""The ExecuteUpdate method returns the RowsAffected, which establishes a relationship between the two entities."", ""RowsAffected""); (""Statement"", ""The Statement class uses the ExecuteUpdate method to get the RowsAffected, which establishes a relationship between the two entities."", ""RowsAffected""); (""Sql"", ""The Sql statement is used by the Statement class, which establishes a relationship between the two entities."", ""Statement""); (""Sql"", ""The Sql statement is used with the ExecuteUpdate method, which establishes a relationship between the two entities."", ""ExecuteUpdate"")"
"Once you have installed the Java SDK, test that you have it working by opening a command prompt (textual interface to your computer, ala Unix Shell, Windows CMD etc.)","(""Java SDK"", ""Java SDK and Unix Shell are related as they are both used as examples of command prompts or textual interfaces to a computer."", ""Unix Shell""); (""Java SDK"", ""Java SDK and Windows CMD are related as they are both used as examples of command prompts or textual interfaces to a computer."", ""Windows CMD"")"
"A Java abstract class is a class which cannot be instantiated, meaning you cannot create new instances of an abstract class.","(""Java"", ""Java is related to Abstract Class because an Abstract Class is a type of Java class"", ""Abstract Class""); (""Abstract Class"", ""Abstract Class is related to Instances because you cannot create new instances of an abstract class"", ""Instances"")"
The purpose of an abstract class is to function as a base for subclasses.,NULL
"This Java abstract class tutorial explains how abstract classes are created in Java, what rules apply to them.","(""Java"", ""Java is related to Abstract because Java is the programming language in which abstract classes are created"", ""Abstract""); (""Java"", ""Java is related to Class because Java is the programming language in which classes are created"", ""Class"")"
This tutorial gets into the purpose of abstract classes in Java in more detail towards the end of this text.,NULL
In Java you declare that a class is abstract by adding the abstract keyword to the class declaration.,"(""Java"", ""Java is related to Abstract because Java is the programming language in which the abstract class is declared"", ""Abstract""); (""Java"", ""Java is related to the Abstract keyword because the Abstract keyword is used in Java to declare an abstract class"", ""Abstract keyword"")"
That is all there is to declaring an abstract class in Java.,NULL
"If you try to compile the code above the Java compiler will generate an error, saying that you cannot instantiate MyAbstractClass because it is an abstract class.",NULL
"If a class has an abstract method, the whole class must be declared abstract.",NULL
Not all methods in an abstract class have to be abstract methods.,"(""Abstract Class"", ""An abstract class contains abstract methods, indicating a clear relationship between the two entities."", ""Abstract Methods""); (""Abstract Class"", ""An abstract class can have both abstract and non-abstract methods, showing a relationship between the class and its methods."", ""Methods"")"
An abstract class can have a mixture of abstract and non-abstract methods.,"(""Abstract Class"", ""An abstract class can have abstract methods, indicating a clear relationship between the two entities as the class contains the methods."", ""Abstract Methods"")"
Subclasses of an abstract class must implement (override) all abstract methods of its abstract superclass.,"(""Subclasses"", ""Subclasses are related to Abstract Class because they inherit from it and must implement its abstract methods."", ""Abstract Class""); (""Abstract Class"", ""Abstract Class is related to Abstract Methods because it has abstract methods that must be implemented by its subclasses."", ""Abstract Methods""); (""Subclasses"", ""Subclasses are related to Abstract Methods because they must implement all abstract methods of their abstract superclass."", ""Abstract Methods""); (""Abstract Class"", ""Abstract Class is related to Superclass because it is a type of superclass that has abstract methods."", ""Superclass"")"
The non-abstract methods of the superclass are just inherited as they are.,NULL
Notice how MySubClass has to implement the abstract method abstractMethod() from its abstract superclass MyAbstractClass.,"(""MySubClass"", ""MySubClass is a subclass of MyAbstractClass, indicating a clear inheritance relationship between the two classes."", ""MyAbstractClass""); (""MySubClass"", ""MySubClass has to implement the abstract method abstractMethod(), indicating a clear implementation relationship between the class MySubClass and the method abstractMethod()."", ""abstractMethod()"")"
"The only time a subclass of an abstract class is not forced to implement all abstract methods of its superclass, is if the subclass is also an abstract class.","(""Subclass"", ""A subclass is related to its superclass because it inherits properties and methods from it."", ""Superclass""); (""Subclass"", ""A subclass can be an abstract class, which means it does not have to implement all abstract methods of its superclass."", ""Abstract Class""); (""Superclass"", ""A superclass can be an abstract class, which means it has abstract methods that need to be implemented by its subclasses."", ""Abstract Class""); (""Abstract Class"", ""An abstract class has abstract methods that need to be implemented by its subclasses."", ""Abstract Methods""); (""Subclass"", ""A subclass is related to abstract methods because it may need to implement them if it is not an abstract class."", ""Abstract Methods"")"
The purpose of abstract classes is to function as base classes which can be extended by subclasses to create a full implementation.,NULL
"If the steps before and after the action are always the same, the 3-step process could be implemented in an abstract superclass with this Java code:","(""Java"", ""Java is related to Abstract because Abstract is a concept in Java that can be used to implement the 3-step process in an abstract superclass"", ""Abstract""); (""Java"", ""Java is related to Superclass because Superclass is a concept in Java that can be used to implement the 3-step process"", ""Superclass"")"
Subclasses of MyAbstractProcess can now extend MyAbstractProcess and just override the action() method.,"(""MyAbstractProcess"", ""MyAbstractProcess has an action() method that can be overridden by its subclasses"", ""action()""); (""Subclasses"", ""Subclasses are related to MyAbstractProcess because they can extend it and override its methods"", ""MyAbstractProcess"")"
"When the process() method of the subclass is called, the full process is executed, including the stepBefore() and stepAfter() of the abstract superclass, and the action() method of the subclass.",NULL
"Of course, the MyAbstractProcess did not have to be an abstract class to function as a base class.",NULL
"However, by making the method to implement abstract, and thus the class too, you signal clearly to users of this class that this class should not be used as it is.",NULL
"Instead it should be used as a base class for a subclass, and that the abstract method should be implemented in the subclass.","(""Class"", ""The Class entity is related to the Subclass entity because a subclass is a specific type of class that inherits properties from the base class."", ""Subclass""); (""Class"", ""The Class entity is related to the Method entity because a class can contain multiple methods, and in this context, the abstract method should be implemented in the subclass."", ""Method"")"
The above example did not have a default implementation for the action() method.,NULL
In some cases your superclass might actually have a default implementation for the method that subclasses are supposed to override.,"(""Superclass"", ""The superclass has a default implementation for the method."", ""Method""); (""Subclasses"", ""The subclasses are supposed to override the method."", ""Method"")"
"You can still make the superclass abstract though, even if it contains no abstract methods.",NULL
"Notice how the processURLData() is an abstract method, and that URLProcessorBase is an abstract class.",NULL
Subclasses of URLProcessorBase have to implement the processURLData() method because it is an abstract method.,NULL
Subclasses of URLProcessorBase abstract class can process data downloaded from URLs without worrying about opening and closing the network connection to the URL.,"(""URLProcessorBase"", ""URLProcessorBase is related to Subclasses because Subclasses are defined as subclasses of URLProcessorBase, indicating an inheritance relationship"", ""Subclasses"")"
Subclasses only need to worry about processing the data from the InputStream passed to the processURLData() method.,"(""Subclasses"", ""Subclasses are related to the processURLData() method because they need to implement this method to process the data from the InputStream."", ""processURLData()""); (""processURLData()"", ""The processURLData() method is related to the InputStream because it processes the data from the InputStream."", ""InputStream"")"
This makes it easier to implement classes that processes data from URLs.,NULL
"Notice how the subclass only implements the processURLData() method, and nothing more.",NULL
The rest of the code is inherited from the URLProcessorBase superclass.,NULL
Here is an example of how to use the URLProcessorImpl class:,NULL
"The process() method is called, which is implemented in the URLProcessorBase superclass.",NULL
This method in turn calls the processURLData() in the URLProcessorImpl class.,NULL
The example I showed you above with the URLProcessorBase class is actually an example of the Template Method design pattern.,NULL
"The Template Method design pattern provides a partial implementation of some process, which subclasses can complete when extending the Template Method base class.","(""Template Method"", ""The Template Method is a part of the Template Method design pattern, indicating a clear relationship between the two entities."", ""Template Method design pattern""); (""Template Method"", ""The Template Method is extended by subclasses, indicating a clear relationship between the Template Method and the subclasses."", ""subclasses"")"
"A Java access modifier specifies which classes can access a given class and its fields, constructors and methods.","(""Class"", ""A class has fields, which are related to it."", ""Fields""); (""Class"", ""A class has constructors, which are related to it."", ""Constructors""); (""Class"", ""A class has methods, which are related to it."", ""Methods""); (""Access Modifier"", ""An access modifier specifies the accessibility of a class."", ""Class""); (""Java"", ""Java is a programming language that uses classes."", ""Class"")"
"Access modifiers can be specified separately for a class, its constructors, fields and methods.","(""Class"", ""A class has constructors, indicating a relationship between the two entities."", ""Constructors""); (""Class"", ""A class has fields, indicating a relationship between the two entities."", ""Fields"")"
"Assigning an access modifier to a class, constructor, field or method is also sometimes referred to as ""marking"" that class, constructor, field or method as that which the access modifier specifies.","(""Class"", ""A class can contain a method, and an access modifier can be assigned to both."", ""Method""); (""Class"", ""A class can contain a constructor, and an access modifier can be assigned to both."", ""Constructor""); (""Class"", ""A class can contain a field, and an access modifier can be assigned to both."", ""Field""); (""Method"", ""A method is part of a class, and an access modifier can be assigned to both."", ""Class""); (""Constructor"", ""A constructor is part of a class, and an access modifier can be assigned to both."", ""Class"")"
"If a method or variable is marked as private (has the private access modifier assigned to it), then only code inside the same class can access the variable, or call the method.","(""Method"", ""A method is related to a class because it can be called by code inside the same class."", ""Class""); (""Variable"", ""A variable is related to a class because it can be accessed by code inside the same class."", ""Class""); (""Private"", ""A private access modifier is related to a method because it can be assigned to a method to restrict its access."", ""Method""); (""Private"", ""A private access modifier is related to a variable because it can be assigned to a variable to restrict its access."", ""Variable"")"
"Code inside subclasses cannot access the variable or method, nor can code from any external class.","(""Subclasses"", ""Subclasses cannot access the variable, indicating a relationship between the two entities."", ""Variable""); (""Subclasses"", ""Subclasses cannot access the method, indicating a relationship between the two entities."", ""Method""); (""External Class"", ""External class cannot access the variable, indicating a relationship between the two entities."", ""Variable"")"
"Marking a class with the private access modifier would mean that no other class could access it, which means that you could not really use the class at all.","(""Class"", ""The class is related to the access modifier because the access modifier is used to restrict access to the class."", ""Access Modifier"")"
"That means, that the member variable time inside the Clock class cannot be accessed from code outside the Clock class.","(""Clock"", ""The time variable is a member of the Clock class, indicating a containment relationship between the two entities."", ""time"")"
"In some cases the fields are truly private, meaning they are only used internally in the class.",NULL
In other cases the fields can be accessed via accessor methods (e.g.,NULL
In the above example the two methods getTime() and setTime() can access the time member variable.,"(""GETTIME()"", ""getTime() can access the time member variable"", ""TIME"")"
"If a constructor in a class is assigned the private Java access modifier, that means that the constructor cannot be called from anywhere outside the class.","(""Constructor"", ""The constructor is a part of the class and is assigned the private access modifier, indicating a relationship between the two."", ""Class""); (""Constructor"", ""The constructor is assigned the private access modifier, indicating a relationship between the constructor and the private access modifier."", ""Private"")"
"A private constructor can still get called from other constructors, or from static methods in the same class.","(""Constructor"", ""A private constructor is part of the same class and can be called from other constructors or static methods in the class."", ""Class""); (""Constructors"", ""Constructors are part of a class and can call a private constructor."", ""Class"")"
This version of the Clock class contains a private constructor and a public constructor.,"(""Clock"", ""The Clock class contains a private constructor and a public constructor, indicating a relationship between the Clock class and its constructors."", ""constructor"")"
The private constructor is called from the public constructor (the statement this();).,NULL
The private constructor is also called from the static method newClock().,NULL
The above example only serves to show you that a private constructor can be called from public constructors and from static methods inside the same class.,"(""Constructor"", ""A constructor is a part of a class, and is used to initialize objects of that class."", ""Class""); (""Constructors"", ""Constructors are methods of a class that are used to initialize objects of that class."", ""Class""); (""Methods"", ""Methods are part of a class, and are used to perform specific actions."", ""Class"")"
"The default access modifier means that code inside the class itself as well as code inside classes in the same package as this class, can access the class, field, constructor or method which the default access modifier is assigned to.","(""Class"", ""The class is related to the package because code inside classes in the same package can access the class."", ""Package""); (""Method"", ""The method is related to the class because code inside the class itself can access the method."", ""Class""); (""Field"", ""The field is related to the class because code inside the class itself can access the field."", ""Class""); (""Constructor"", ""The constructor is related to the class because code inside the class itself can access the constructor."", ""Class""); (""Method"", ""The method is related to the package because code inside classes in the same package can access the method."", ""Package""); (""Field"", ""The field is related to the package because code inside classes in the same package can access the field."", ""Package""); (""Constructor"", ""The constructor is related to the package because code inside classes in the same package can access the constructor."", ""Package"")"
"Subclasses cannot access methods and member variables (fields) in the superclass, if they these methods and fields are marked with the default access modifier, unless the subclass is located in the same package as the superclass.","(""Subclasses"", ""Subclasses are related to the superclass because they cannot access methods and member variables in the superclass unless they are in the same package."", ""Superclass""); (""Subclasses"", ""Subclasses are related to the package because they can access methods and member variables in the superclass if they are located in the same package as the superclass."", ""Package""); (""Superclass"", ""The superclass is related to the package because methods and member variables in the superclass can be accessed by subclasses in the same package."", ""Package""); (""Methods"", ""Methods are related to the superclass because they are part of the superclass and can be accessed by subclasses in the same package."", ""Superclass"")"
"The time field in the Clock class has no access modifier, which means that it is implicitly assigned the default / package access modifier.","(""Clock"", ""The time field is in the Clock class"", ""time"")"
"Therefore, the ClockReader class can read the time member variable of the Clock object, provided that ClockReader and Clock are located in the same Java package.","(""ClockReader"", ""ClockReader can read the time member variable of the Clock object"", ""Clock""); (""ClockReader"", ""ClockReader is located in the Java package"", ""Java"")"
"The protected access modifier provides the same access as the default access modifier, with the addition that subclasses can access protected methods and member variables (fields) of the superclass.","(""Subclasses"", ""Subclasses can access protected methods and member variables of the superclass, indicating a relationship between the two entities."", ""Protected"")"
This is true even if the subclass is not located in the same package as the superclass.,"(""Subclass"", ""The subclass is related to the superclass because it is a derived class that inherits properties from the superclass."", ""Superclass""); (""Subclass"", ""The subclass is related to the package because it can be located in a package, although not necessarily the same package as the superclass."", ""Package"")"
In the above example the subclass SmartClock has a method called getTimeInSeconds() which accesses the time variable of the superclass Clock.,"(""SmartClock"", ""SmartClock has a method called getTimeInSeconds(), indicating a relationship between the class and the method"", ""getTimeInSeconds()""); (""SmartClock"", ""SmartClock is a subclass of Clock, indicating a relationship between the two classes"", ""Clock"")"
"The Java access modifier public means that all code can access the class, field, constructor or method, regardless of where the accessing code is located.","(""Java"", ""Java has a public access modifier"", ""Public""); (""Public"", ""Public is an access modifier for a class"", ""Class""); (""Public"", ""Public is an access modifier for a field"", ""Field""); (""Public"", ""Public is an access modifier for a constructor"", ""Constructor""); (""Public"", ""Public is an access modifier for a method"", ""Method""); (""Code"", ""Code can access the class"", ""Class""); (""Code"", ""Code can access the field"", ""Field""); (""Code"", ""Code can access the constructor"", ""Constructor"")"
The accessing code can be in a different class and different package.,"(""Accessing Code"", ""The accessing code can be in a different class, indicating they are related."", ""Class""); (""Accessing Code"", ""The accessing code can be in a different package, indicating they are related."", ""Package"")"
The time field in the Clock class is marked with the public Java access modifier.,"(""Clock"", ""The time field is a member of the Clock class"", ""time""); (""time"", ""The time field is marked with the public access modifier"", ""public""); (""Clock"", ""The Clock class contains a field marked with the public access modifier"", ""public""); (""Java"", ""The public access modifier is used in the Java language"", ""public"")"
"Therefore, the ClockReader class can access the time field in the Clock no matter what package the ClockReader is located in.","(""ClockReader"", ""The ClockReader class can access the time field in the Clock, indicating a relationship between the two classes."", ""Clock""); (""ClockReader"", ""The ClockReader class can access the time field, indicating a relationship between the ClockReader class and the time field."", ""time"")"
"It is important to keep in mind that the Java access modifier assigned to a Java class takes precedence over any access modifiers assigned to fields, constructors and methods of that class.","(""Java class"", ""The Java access modifier is assigned to a Java class"", ""Java access modifier""); (""Java class"", ""The fields are part of a Java class"", ""fields""); (""Java class"", ""The constructors are part of a Java class"", ""constructors""); (""Java class"", ""The methods are part of a Java class"", ""methods""); (""Java access modifier"", ""The Java access modifier assigned to a Java class takes precedence over any access modifiers assigned to fields"", ""fields""); (""Java access modifier"", ""The Java access modifier assigned to a Java class takes precedence over any access modifiers assigned to constructors"", ""constructors"")"
"If the class is marked with the default access modifier, then no other class outside the same Java package can access that class, including its constructors, fields and methods.","(""Class"", ""The class is part of the Java package and its accessibility is affected by it."", ""Package""); (""Package"", ""The package determines the accessibility of the class when it has the default access modifier."", ""Class""); (""Class"", ""The class has constructors which are affected by the access modifier of the class."", ""Constructors""); (""Class"", ""The class has fields which are affected by the access modifier of the class."", ""Fields""); (""Class"", ""The class has methods which are affected by the access modifier of the class."", ""Methods""); (""Package"", ""The package affects the accessibility of the constructors of a class with the default access modifier."", ""Constructors""); (""Package"", ""The package affects the accessibility of the fields of a class with the default access modifier."", ""Fields"")"
The Java access modifiers private and protected cannot be assigned to a class.,"(""Java"", ""Java is related to Access Modifiers because Access Modifiers are a fundamental concept in Java programming."", ""Access Modifiers""); (""Private"", ""Private and Protected are related because they are both access modifiers in Java."", ""Protected""); (""Java"", ""Java is related to Private because Private is an access modifier used in Java programming."", ""Private""); (""Java"", ""Java is related to Protected because Protected is an access modifier used in Java programming."", ""Protected""); (""Access Modifiers"", ""Access Modifiers is related to Private because Private is a type of access modifier."", ""Private""); (""Access Modifiers"", ""Access Modifiers is related to Protected because Protected is a type of access modifier."", ""Protected"")"
Java interfaces are meant to specify fields and methods that are publicly available in classes that implement the interfaces.,"(""Java"", ""Java is related to Interfaces because Java is the programming language that uses Interfaces."", ""Interfaces""); (""Interfaces"", ""Interfaces are related to Fields because Interfaces specify fields that are publicly available in classes."", ""Fields""); (""Interfaces"", ""Interfaces are related to Methods because Interfaces specify methods that are publicly available in classes."", ""Methods""); (""Java"", ""Java is related to Fields because Java is the programming language that has classes which implement fields."", ""Fields"")"
"When you create a subclass of some class, the methods in the subclass cannot have less accessible access modifiers assigned to them than they had in the superclass.","(""Subclass"", ""A subclass is related to its superclass because it inherits properties and methods from it."", ""Superclass""); (""Subclass"", ""The methods in a subclass are related to the subclass because they are defined within it."", ""Methods""); (""Superclass"", ""The methods in a superclass are related to the superclass because they are defined within it and can be inherited by subclasses."", ""Methods""); (""Methods"", ""Methods are related to access modifiers because access modifiers determine the accessibility of methods in a class."", ""Access Modifiers""); (""Subclass"", ""A subclass is related to access modifiers because the access modifiers of its methods cannot be less accessible than those in its superclass."", ""Access Modifiers"")"
"For instance, if a method in the superclass is public then it must be public in the subclass too, in case the subclass overrides the method.",NULL
If a method in the superclass is protected then it must be either protected or public in the subclass.,"(""Superclass"", ""The superclass contains a method"", ""Method""); (""Subclass"", ""The subclass inherits or overrides the method from the superclass"", ""Method"")"
"For instance, if a method is assigned the default access modifier in the superclass, then it is allowed to assign the overridden method in the subclass the public access modifier.","(""Method"", ""A method is assigned the default access modifier in the superclass"", ""Superclass""); (""Method"", ""The overridden method in the subclass can be assigned the public access modifier"", ""Subclass""); (""Superclass"", ""The subclass overrides a method from the superclass"", ""Subclass""); (""Default Access Modifier"", ""The default access modifier in the superclass allows the public access modifier in the subclass for an overridden method"", ""Public Access Modifier""); (""Method"", ""A method is assigned the default access modifier"", ""Default Access Modifier"")"
"The build process includes generating source code, compiling the source, generating XML files (e.g.","(""Build"", ""The build process includes generating source code, indicating a relationship between Build and Process."", ""Process""); (""Process"", ""The build process includes generating source code, indicating a relationship between Process and Source."", ""Source""); (""Source"", ""The build process includes generating source code, indicating a relationship between Source and Code."", ""Code""); (""Code"", ""The build process includes generating XML files, indicating a relationship between Code and XML."", ""XML""); (""Generating"", ""The build process includes generating source code, indicating a relationship between Generating and Source."", ""Source""); (""Compiling"", ""The build process includes compiling the source, indicating a relationship between Compiling and Source."", ""Source""); (""Generating"", ""The build process includes generating XML files, indicating a relationship between Generating and XML."", ""XML"")"
"You can place Java annotations above classes, interfaces, methods, method parameters, fields and local variables.","(""Java"", ""Java uses Annotations to provide metadata about classes, interfaces, methods, method parameters, fields and local variables."", ""Annotations""); (""Annotations"", ""Annotations can be placed above interfaces to provide additional information."", ""Interfaces""); (""Annotations"", ""Annotations can be placed above methods to provide additional information about the method's behavior or parameters."", ""Methods""); (""Annotations"", ""Annotations can be placed above method parameters to provide additional information about the parameters."", ""Method Parameters""); (""Annotations"", ""Annotations can be placed above fields to provide additional information about the fields."", ""Fields""); (""Annotations"", ""Annotations can be placed above local variables to provide additional information about the variables."", ""Local Variables""); (""Java"", ""Java is an object-oriented programming language that supports interfaces."", ""Interfaces""); (""Java"", ""Java is an object-oriented programming language that supports methods."", ""Methods""); (""Java"", ""Java is an object-oriented programming language that supports fields."", ""Fields""); (""Java"", ""Java is an object-oriented programming language that supports local variables."", ""Local Variables""); (""Interfaces"", ""Interfaces can contain method declarations."", ""Methods""); (""Methods"", ""Methods can have method parameters."", ""Method Parameters""); (""Methods"", ""Methods can access and modify fields."", ""Fields""); (""Methods"", ""Methods can declare and use local variables."", ""Local Variables"")"
"Here is a bigger example with annotations above both the class, fields, methods, parameters and local variables:","(""Class"", ""A class contains one or more methods, thus they are related."", ""Method""); (""Class"", ""A class is often part of a package, thus they are related."", ""Package""); (""Method"", ""A method is defined inside a class, thus they are related."", ""Class"")"
"If your code uses deprecated classes, methods or fields, the compiler will give you a warning.","(""Code"", ""The code is related to the compiler because the compiler gives a warning when the code uses deprecated classes, methods or fields."", ""Compiler""); (""Compiler"", ""The compiler is related to the warning because it gives the warning when the code uses deprecated classes, methods or fields."", ""Warning""); (""Code"", ""The code is related to the classes because it uses deprecated classes."", ""Classes""); (""Code"", ""The code is related to the methods because it uses deprecated methods."", ""Methods"")"
"If the method does not match a method in the superclass, the compiler will give you an error.","(""Method"", ""The method is related to the superclass because it is being compared to a method in the superclass to check for a match."", ""Superclass""); (""Method"", ""The method is related to the compiler because the compiler checks if the method matches a method in the superclass and gives an error if it does not."", ""Compiler"")"
"In case someone changed the name of the overridden method in the superclass, your subclass method would no longer override it.","(""Subclass"", ""The subclass is related to the superclass because it overrides a method from the superclass."", ""Superclass""); (""Subclass"", ""The subclass is related to the method because it contains a method that overrides a method from the superclass."", ""Method"")"
"In case the method doTheThing() in MySuperClass changes signature so that the same method in the subclass no longer overrides it, the compiler will generate an error.","(""MySuperClass"", ""MySuperClass contains the method doTheThing()"", ""doTheThing()"")"
"Annotations are defined in their own file, just like a Java class or interface.","(""Annotations"", ""Annotations are defined in their own file, just like a Java class, indicating a relationship between the two."", ""Java class""); (""Annotations"", ""Annotations are defined in their own file, just like an interface, indicating a relationship between the two."", ""interface"")"
"RetentionPolicy.CLASS means that the annotation is stored in the .class file, but not available at runtime.",NULL
"RetentionPolicy.SOURCE means that the annotation is only available in the source code, and not in the .class files and not a runtime.",NULL
"The second line declares an array of references to objects of the class MyClass, which symbolizes a class you have created yourself.",NULL
Personally I prefer to locate the square brackets [] after the data type (e.g.,NULL
Java allows you to create an array of references to any type of object (to instances of any class).,"(""Java"", ""Java allows you to create an array, indicating a relationship between Java and Array"", ""Array""); (""Java"", ""Java allows you to create an array of references to any type of object, indicating a relationship between Java and Object"", ""Object"")"
Notice how the values to be inserted into the array are listed inside the { ... } block.,NULL
"Of course, if the insertIntoArray() method is located in a different class than the above code, you would need an object of that class in order to be able to call the method.",NULL
"Or, if the insertIntoArray() method was static, you would need to put the class name and a dot in front of the method name.",NULL
"This removeFromArray() method takes two parameters: The array to remove the element from, and the index of the element to remove.","(""RemoveFromArray"", ""The removeFromArray method operates on an array to remove an element from it"", ""Array"")"
"Of course, if the removeFromArray() method is located in a different class than the above code, you would need an object of that class in order to be able to call the method.",NULL
"Or, if the removeFromArray() method was static, you would need to put the class name and a dot in front of the method name.",NULL
The example first sets the minVal to Integer.MAX_VALUE which is the highest possible value an int can take.,"(""Integer"", ""Integer is the class that contains the MAX_VALUE method"", ""MAX_VALUE""); (""Integer"", ""The minVal is being set to a value from the Integer class"", ""minVal"")"
"Java contains a special utility class that makes it easier for you to perform many often used array operations like copying and sorting arrays, filling in data, searching in arrays etc.",NULL
The utility class is called Arrays and is located in the standard Java package java.util.,NULL
I will cover a few of the methods found in this class in the following sections.,NULL
"Remember, in order to use java.util.Arrays in your Java classes you must import it.",NULL
Here is how importing java.util.Arrays could look in a Java class of your own:,"(""Java"", ""The Java class is related to java.util.Arrays because it is importing the package."", ""java.util.Arrays""); (""import"", ""The import method is related to java.util.Arrays because it is used to import the package."", ""java.util.Arrays"")"
It is this statement that imports the class java.util.Arrays into your Java class.,"(""java.util.Arrays"", ""java.util.Arrays is a class within the java.util package"", ""java.util"")"
The second method to copy a Java array is to use the Arrays.copyOf() method.,"(""Arrays"", ""The source entity Arrays is related to the target entity Arrays.copyOf() because Arrays.copyOf() is a method of the Arrays class."", ""Arrays.copyOf()""); (""Java"", ""The source entity Java is related to the target entity Arrays because Arrays is a class in the Java package."", ""Arrays"")"
The third method to copy a Java array is to use the Arrays.copyOfRange() method.,"(""Arrays"", ""The Arrays class contains the Arrays.copyOfRange() method, indicating a clear relationship between the two entities as the method is part of the class."", ""Arrays.copyOfRange()""); (""Java"", ""The Arrays class is part of the Java package, indicating a relationship between the two entities as the class belongs to the package."", ""Arrays"")"
"The Arrays.copyOfRange() method copies a range of an array, not necessarily the full array.",NULL
Here is how copying a full array using Arrays.copyOfRange() in Java looks:,"(""Arrays"", ""Arrays is a class that contains the method Arrays.copyOfRange()"", ""Arrays.copyOfRange()""); (""Arrays"", ""Arrays is a class in the Java package"", ""Java"")"
You can convert an Java array of primitive types to a String using the Arrays.toString() method.,"(""Arrays"", ""The Arrays class contains the toString method, indicating a clear relationship between the two entities as the method is part of the class."", ""toString""); (""Java"", ""The Java package is related to the Arrays class because Arrays is a part of the Java package, providing functionality for Java applications."", ""Arrays"")"
Here is an example of how to convert an array of int to a String using Arrays.toString():,"(""Arrays"", ""Arrays is a class that contains the method toString()"", ""toString""); (""Arrays"", ""The Arrays class is used to convert an array to a String using the toString() method"", ""String""); (""Arrays"", ""The Arrays class is used to convert an array of int to a String"", ""int""); (""toString"", ""The toString method is used to convert an array to a String"", ""String"")"
You can sort the elements of an array using the Arrays.sort() method.,NULL
After the for loop the array is converted to a String using Arrays.toString() and printed out to the console (command line).,"(""Arrays"", ""Arrays is a class that has a method called toString"", ""toString""); (""Arrays"", ""The output of Arrays.toString() is printed to the console"", ""console"")"
The Arrays.sort() example shown earlier only works for Java arrays of primitive data types.,"(""Arrays"", ""The Arrays class contains the sort method, indicating a clear relationship between the two entities as the sort method is a part of the Arrays class."", ""sort"")"
Here is first the class for the objects we want to sort:,NULL
The class Employee is a simple model of an employee (I have created the Employee class).,NULL
Here is first an example of sorting an array of Employee objects by their name using the Arrays.sort() method:,"(""Arrays"", ""The Arrays class contains the sort() method, indicating a clear relationship between the two entities as the method is part of the class."", ""Arrays.sort()""); (""Employee"", ""The Employee class is related to the Arrays.sort() method because the method is used to sort an array of Employee objects, indicating that the method operates on instances of the Employee class."", ""Arrays.sort()"")"
The array is of type Employee - the class I showed you earlier.,NULL
"As parameter to the Arrays.sort() method we pass the employee array, and a Comparator implementation which can determine the order of Employee objects.","(""Arrays.sort"", ""The Arrays.sort method is a part of the Arrays class, indicating a clear relationship between the two entities."", ""Arrays""); (""Arrays.sort"", ""The Arrays.sort method takes a Comparator implementation as a parameter, indicating a relationship between the method and the Comparator class."", ""Comparator""); (""Arrays.sort"", ""The Arrays.sort method is used to sort an array of Employee objects, indicating a relationship between the method and the Employee class."", ""Employee"")"
Anonymous implementations of interfaces are covered in my text about nested classes in Java.,"(""Anonymous"", ""Anonymous is an implementation of Interfaces"", ""Interfaces""); (""Nested Classes"", ""Anonymous is a type of Nested Classes"", ""Anonymous""); (""Java"", ""Java is a language that supports Nested Classes"", ""Nested Classes""); (""Java"", ""Java is a language that supports Interfaces"", ""Interfaces"")"
What is important to catch in this example is the implementation of the compare() method of the anonymous inner implementation of the Comparator interface.,NULL
In the example above we simply call the String.compare() method which does the comparison for us (compares the employee names).,NULL
"Here is the example from before, with a modified implementation of the compare() method of the anonymous implementation of the Comparator interface:",NULL
Notice how the compare() method returns the difference between the employee ids by subtracting one from the other.,NULL
"To compare the Employee objects in the array first by their name, and if that is the same, then by their employee id, the compare() implementation would look like this:","(""Employee"", ""The compare() method is used to compare Employee objects, indicating a relationship between the Employee class and the compare() method."", ""compare()""); (""array"", ""The Employee objects are stored in an array, indicating a relationship between the array and the Employee class."", ""Employee"")"
These Arrays.fill() methods can fill an array with a given value.,NULL
Here is an example of using Arrays.fill() to fill an int array:,"(""Arrays"", ""The Arrays class contains the fill method, indicating a clear relationship between the two entities."", ""fill""); (""Arrays"", ""The Arrays class is used to manipulate arrays, indicating a relationship between the Arrays class and the array entity."", ""array""); (""fill"", ""The fill method is used to fill an array, indicating a clear relationship between the fill method and the array entity."", ""array""); (""Arrays"", ""The Arrays class can be used with int arrays, indicating a relationship between the Arrays class and the int entity."", ""int""); (""fill"", ""The fill method can be used to fill an int array, indicating a relationship between the fill method and the int entity."", ""int"")"
"There is a version of the Arrays.fill() method which takes a from and to index, so only elements with indexes in this interval are filled with the given value.",NULL
"You can do so yourself, or via the Arrays.sort() method covered earlier in this text.",NULL
The binarySearch() method will return the index in the array in which the element was found.,NULL
"If all elements in the array are smaller than the sought value, then binarySearch() will return - length of the array - 1.",NULL
Therefore binarySearch() will return -length (-6) - 1 = -6 -1 = -7.,NULL
The Arrays.binarySearch() method also exists in a version where you just search part of the array.,NULL
"This version of binarySearch() works just like the other version, except in the cases where no matching element is found.",NULL
"If no element is found matching within the index interval, then binarySearch() will still return the index of where the value should have been inserted.","(""Binarysearch"", ""Binarysearch is related to Index because it is used to search for an element within an index interval"", ""Index"")"
"But, if all values in the interval are smaller than the sought value, binarySearch() will return -toIndex -1 , and not -array length - 1.","(""Binarysearch"", ""Binarysearch is related to Interval because the method is used to search for a value within an interval"", ""Interval"")"
The java.util.Arrays class contains a set of methods called equals() which can be used to check if two Java arrays are equal.,NULL
"Java classes are some of the core building blocks of Java applications, toolkits, frameworks, APIs etc.","(""Java"", ""Java is a core building block of Java applications"", ""Java applications""); (""Java"", ""Java is a core building block of Java toolkits"", ""Java toolkits""); (""Java"", ""Java is a core building block of Java frameworks"", ""Java frameworks"")"
"A small Java application may consist of a single Java class with a main() method in, as covered in the Java main method tutorial.","(""Java application"", ""A Java application may consist of a single Java class, indicating that the Java application is composed of or contains a Java class."", ""Java class""); (""Java class"", ""The Java class contains a main() method, indicating that the main() method is a part of the Java class."", ""main()"")"
"As your Java application grows, keeping all the code in the same class makes it harder and harder to keep an overview of the code.","(""Class"", ""The class contains the code, and as the Java application grows, keeping all the code in the same class makes it harder to keep an overview of the code."", ""Code""); (""Java Application"", ""The Java application grows and this growth is related to the class, as all the code is kept in the same class."", ""Class"")"
Therefore it might be beneficial to start splitting the Java code up into multiple classes.,NULL
"A Java class is a single, coherent unit of Java code which belongs together.","(""Java class"", ""A Java class is a single, coherent unit of Java code which belongs together, indicating that Java class and Java code are related as the former is composed of the latter."", ""Java code"")"
A Java class may contain a mix of data (variables) and actions (methods).,"(""Class"", ""A Java class may contain a mix of data and actions, which implies that methods are part of a class"", ""Methods"")"
Grouping variables and operations on these variables into Java classes makes it easier to structure your Java program when it gets too big to fit comfortably inside a single Java class.,"(""Java classes"", ""Java classes are used to structure the Java program when it gets too big to fit comfortably inside a single Java class"", ""Java program""); (""variables"", ""variables are grouped into Java classes"", ""Java classes""); (""operations"", ""operations on variables are grouped into Java classes"", ""Java classes"")"
"Therefore, as the class grows, the file you are editing grows too, and becomes harder to keep an overview of in your head.",NULL
"Your Java application will typically have to contain at least a single Java class, but it may contain as many classes as you see fit to divide your application into.","(""Java application"", ""The Java application contains at least a single Java class, indicating a clear relationship between the two entities."", ""Java class"")"
"Java also comes with a lot of predefined classes for you, so you don't have to code every little function you might desire yourself.",NULL
"Fields are variables (data) that are local to the class, or instances (objects) of that class.","(""Fields"", ""Fields are variables that are local to the class, indicating a relationship between Fields and Class"", ""Class"")"
Methods are operations that the class or instances of that class can perform.,NULL
Nested classes are Java classes that are defined inside another class.,"(""Nested classes"", ""Nested classes are a type of Java classes"", ""Java classes""); (""Nested classes"", ""Nested classes are defined inside another class"", ""another class"")"
"Nested classes are typically intended to either be used only internally be the Java class that contains them, or to be used in connection with the class that contains them.",NULL
Nested classes are covered in more detail in my Java nested class tutorial.,"(""Nested classes"", ""Nested classes are a part of the Java programming language, indicating a relationship between the two entities"", ""Java""); (""Java nested class tutorial"", ""The Java nested class tutorial provides more information about Nested classes, indicating a relationship between the two entities"", ""Nested classes"")"
"Sometimes you have classes that only contain fields (data), and sometimes you have classes that only contain methods (operations).","(""Classes"", ""Classes are related to Fields because they can contain fields that hold data."", ""Fields"")"
It depends on what the Java class is supposed to do.,NULL
All it takes to define a class in Java is this:,NULL
The above class definition should be put in its own file named MyClass.java.,NULL
"Java files should be named the same as the name of the class they contain, with the .java as file name extension.","(""Java"", ""Java files are related to Java because they are used to contain Java classes"", ""Java files""); (""Java files"", ""Java files are related to class because they are named the same as the class they contain"", ""class"")"
Make sure you keep the same uppercase and lowercase characters from the class name in the file name too.,NULL
"Only put a single class definition in each Java file, unless your class contains inner classes of some kind.","(""Java"", ""A Java file contains a single Java class definition."", ""Java file""); (""Java"", ""A Java class can contain inner classes."", ""inner classes"")"
"As mentioned earlier, a Java class can contain data in the shape of variables.",NULL
The next example shows a Java class which is to model a car.,NULL
A constructor is a special method that is called when an object of the given class is created (explained later).,"(""Constructor"", ""A constructor is a special method that is called when an object of the given class is created, indicating a relationship between the constructor method and the class."", ""Class"")"
The purpose of a constructor is to initialize the fields in the class.,"(""Constructor"", ""The constructor is related to the class because it is used to initialize the fields in the class."", ""Class""); (""Constructor"", ""The constructor is related to the fields because it is used to initialize them."", ""Fields"")"
Here is an example of a Java class with two constructors:,"(""Java"", ""Java is a programming language that has a class called Class"", ""Class""); (""Class"", ""A class in Java can have multiple constructors, which are special methods used to initialize objects"", ""Constructors"")"
"The constructors are the two methods that have the same name as the class, and which have no return type specified.","(""Constructors"", ""The constructors are related to the class because they have the same name as the class."", ""Class""); (""Methods"", ""The methods are related to the class because they are part of the class definition, and the constructors are a type of method."", ""Class"")"
"A Java method contains Java instructions that typically perform some operations on a field in the class, or on one of the parameters (also variables) values passed to the method when the method was called.",NULL
"Here is the Java class, Car example from the previous section with a method added:","(""Car"", ""The Car class is written in Java, indicating a relationship between the class and the package it belongs to"", ""Java"")"
In the class definition above I have added a setColor() method.,NULL
"As mentioned earlier, you can define a nested class inside another Java class.",NULL
Here is an example of defining a nested class inside a Java class:,NULL
"In the example above, the outer class is called MyClass and the nested class is called MyNestedClass .",NULL
"Neither of the classes in this example has any fields or methods, but both the outer and nested class could have as many fields and methods as you see fit.","(""Outer Class"", ""The outer class is related to methods because it could have as many methods as you see fit."", ""Methods""); (""Outer Class"", ""The outer class is related to fields because it could have as many fields as you see fit."", ""Fields""); (""Nested Class"", ""The nested class is related to methods because it could have as many methods as you see fit."", ""Methods""); (""Nested Class"", ""The nested class is related to fields because it could have as many fields as you see fit."", ""Fields""); (""Classes"", ""Classes are related to methods because neither of the classes in this example has any methods."", ""Methods""); (""Classes"", ""Classes are related to fields because neither of the classes in this example has any fields."", ""Fields""); (""Outer Class"", ""The outer class is related to the nested class because the nested class is inside the outer class."", ""Nested Class"")"
You can read more about nested classes in my tutorial about nested classes in Java,"(""Nested Classes"", ""Nested Classes are a concept in Java, indicating a relationship between the two entities"", ""Java""); (""Nested Classes"", ""The tutorial is about Nested Classes, indicating a relationship between the two entities"", ""Tutorial"")"
A Java class is a template for how objects of that class looks.,"(""Java"", ""Java is related to Class because Java is a programming language that uses classes"", ""Class""); (""Class"", ""Class is related to Object because a class is a template for how objects of that class look"", ""Object"")"
"In other words, the Car class in the previous section is a template for how Car objects look.",NULL
"To create objects of a certain class, you use the new keyword.",NULL
"This example creates 3 Car variables, and assign a new instance of the Car class to each variable.",NULL
"Thus, the fields of different objects (even of the same class) can vary independently of each other.","(""OBJECTS"", ""The fields are a part of the objects, and different objects can have varying fields."", ""FIELDS""); (""OBJECTS"", ""The objects are instances of the same class, and the class defines the structure of the objects."", ""CLASS"")"
"After creating the 3 Car objects, the setColor() method is called on each object.",NULL
"Creating an object of a certain class is also called ""instantiating"" an object.",NULL
"The object is thus also called an ""instance"" of the given class.","(""Object"", ""The object is an instance of the given class, indicating a relationship between the object and the class."", ""Class"")"
"For instance, each of the Car objects above are also called an instance of the Car class, or simply ""Car instances"".",NULL
What you have seen in this text only covers the very basics of Java classes.,NULL
"You need to learn about fields, constructors, methods nested classes, abstract classes, inheritance, access modifiers and interfaces too.","(""Fields"", ""Fields and constructors are related because fields are often initialized using constructors."", ""Constructors""); (""Methods"", ""Methods can access and modify fields, so they are related."", ""Fields""); (""Nested Classes"", ""Nested classes can be used to implement abstract classes, so they are related."", ""Abstract Classes""); (""Inheritance"", ""Inheritance is often used with abstract classes to create a hierarchy of classes."", ""Abstract Classes""); (""Access Modifiers"", ""Access modifiers are used to control access to fields, so they are related."", ""Fields"")"
"Here is a simple example that creates an object, which results in the class constructor being called:",NULL
The example shows a very simple Java class with a single constructor.,NULL
The second part of a Java constructor declaration is the name of the class the constructor belongs to.,"(""Constructor"", ""The constructor belongs to the Java class"", ""Java""); (""Constructor Declaration"", ""The constructor declaration is related to the constructor"", ""Constructor"")"
Using the class name for the constructor signals to the Java compiler that this is a constructor.,"(""Class"", ""The class name is used for the constructor, indicating a relationship between the class and the constructor."", ""Constructor""); (""Java Compiler"", ""The Java compiler uses the class name to identify the constructor, indicating a relationship between the Java compiler and the class."", ""Class"")"
The constructor parameters are declared inside the parentheses () after the class name part of the constructor .,"(""Constructor"", ""The constructor parameters are declared inside the parentheses () after the class name part of the constructor, indicating a relationship between the Constructor class and the Constructor Parameters method."", ""Constructor Parameters"")"
"A class can have multiple constructors, as long as their signature (the parameters they take) are not the same.",NULL
"When a Java class contains multiple constructors, we say that the constructor is overloaded (comes in multiple versions).",NULL
"This is what constructor overloading means, that a Java class contains multiple constructors.","(""Java"", ""Java is related to Constructor because it is the programming language in which the concept of constructor overloading is being discussed"", ""Constructor""); (""Constructor"", ""Constructor is related to Constructor Overloading because constructor overloading is a concept that applies to constructors"", ""Constructor Overloading"")"
The keyword this in front of the field name (this.number) is not necessary.,"(""This"", ""The keyword this is used in front of the field name, indicating a relationship between the keyword and the field."", ""Field""); (""This"", ""The keyword this is used in front of the field name, which includes the name, indicating a relationship between the keyword and the name."", ""Name"")"
"You don't have to define a constructor for a class, but if you don't define any constructor, the Java compiler will insert a default, no-argument constructor for you.","(""Class"", ""A class may have a constructor, and if not defined, a default constructor is provided by the Java compiler."", ""Constructor""); (""Java Compiler"", ""The Java compiler provides a default constructor for a class if none is defined."", ""Class"")"
"Thus, once the class is compiled it will always at least have a no-argument constructor.",NULL
"If you do define a constructor for your class, then the Java compiler will not insert the default no-argument constructor into your class.","(""Class"", ""A class can have a constructor, and if a constructor is defined, it affects the class."", ""Constructor""); (""Java Compiler"", ""The Java compiler interacts with a class by inserting a default no-argument constructor if one is not defined."", ""Class"")"
The parameters are passed to the constructor inside the parentheses after the class name on the right side of the equal sign.,"(""Parameters"", ""The parameters are related to the class because they are passed to the constructor inside the class"", ""Class""); (""Constructor"", ""The constructor is related to the class because it is inside the class and is used to initialize the class"", ""Class"")"
"By default, if a parameter (or local variable) has the same name as a field in the same class, the parameter (or local variable) ""shadows"" for the field.","(""Parameter"", ""The parameter is defined within the class and can shadow a field in the same class."", ""Class""); (""Local Variable"", ""The local variable is defined within the class and can shadow a field in the same class."", ""Class""); (""Field"", ""The field is a member of the class and can be shadowed by a parameter or local variable with the same name."", ""Class""); (""Parameter"", ""The parameter can shadow the field if they have the same name."", ""Field"")"
"Inside the constructor of the Employee class the firstName, lastName and birthYear identifiers now refer to the constructor parameters, not to the Employee fields with the same names.","(""Employee"", ""The Employee class has a constructor method."", ""constructor""); (""constructor"", ""The constructor method uses the firstName parameter."", ""firstName""); (""constructor"", ""The constructor method uses the lastName parameter."", ""lastName""); (""constructor"", ""The constructor method uses the birthYear parameter."", ""birthYear""); (""Employee"", ""The Employee class has a field named firstName."", ""firstName""); (""Employee"", ""The Employee class has a field named lastName."", ""lastName"")"
"To signal to the Java compiler that you mean the fields of the Employee class and not the parameters, put the this keyword and a dot in front of the field name.","(""Java compiler"", ""The Java compiler is related to the Employee class because it is used to compile the Employee class."", ""Employee""); (""Employee"", ""The Employee class is related to the field because the field is a part of the Employee class."", ""field"")"
You call a constructor when you create a new instance of the class containing the constructor.,NULL
"In case you want to pass parameters to the constructor, you include the parameters between the parentheses after the class name, like this:",NULL
The this keyword followed by parentheses and parameters means that another constructor in the same Java class is being called.,"(""Java"", ""The Java class has a constructor method, indicating a relationship between the class and the method."", ""Constructor""); (""This"", ""The 'this' keyword is used in the context of a Java class, indicating a relationship between 'this' and the Java class."", ""Java"")"
In this example it is the first constructor in the class that is being called.,NULL
"When a class extends another class it is also said to ""inherit"" from the class it extends.",NULL
"The class that extends is called the subclass, and the class being extended is called the superclass.","(""Subclass"", ""The subclass extends the superclass, indicating a clear inheritance relationship between the two classes."", ""Superclass""); (""Subclass"", ""The subclass is a type of class, specifically a class that extends another class, indicating a relationship of specialization."", ""Class"")"
A class that extends another class does not inherit its constructors.,NULL
"However, the subclass must call a constructor in the superclass inside of its the subclass constructors!","(""Subclass"", ""The subclass must call a constructor in the superclass, indicating a relationship between the two classes."", ""Superclass""); (""Subclass"", ""The subclass has its own constructors, which are methods, and must call a constructor in the superclass, indicating a relationship between the subclass and the constructor method."", ""Constructor"")"
"If a subclass calls another constructor within itself, then the called constructor must call the superclass constructor.","(""Subclass"", ""A subclass calls another constructor within itself, indicating a relationship between the subclass and the constructor."", ""Constructor""); (""Constructor"", ""The called constructor must call the superclass constructor, indicating a relationship between the constructor and the superclass."", ""Superclass"")"
It calls the constructor in the superclass using this Java statement:,"(""Constructor"", ""The constructor is called in the superclass, indicating a relationship between the two entities."", ""Superclass""); (""Java"", ""The constructor is defined using a Java statement, indicating a relationship between the Java package and the constructor entity."", ""Constructor"")"
Using the keyword super refers to the superclass of the class using the super keyword.,"(""Class"", ""The class uses the super keyword which is a method."", ""Super""); (""Class"", ""The class has a superclass which it refers to using the super keyword."", ""Superclass"")"
"When super keyword is followed by parentheses like it is here, it refers to a constructor in the superclass.","(""Super"", ""The source entity Super is related to the target entity Superclass because the Super keyword refers to a constructor in the Superclass."", ""Superclass""); (""Superclass"", ""The source entity Superclass is related to the target entity Constructor because a constructor is a method in the Superclass that is referred to by the Super keyword."", ""Constructor"")"
In this case it refers to the constructor in the Vehicle class.,NULL
The access modifier of a constructor determines what classes in your application that are allowed to call that constructor.,"(""Constructor"", ""The access modifier of a constructor determines what classes in your application that are allowed to call that constructor, indicating a relationship between the constructor and the access modifier."", ""Access Modifier""); (""Constructor"", ""The constructor is related to the application because the access modifier of the constructor determines what classes in the application are allowed to call it."", ""Application"")"
"For instance, if a constructor is declared protected then only classes in the same package, or subclasses of that class can call that constructor.","(""Constructor"", ""A constructor is declared in a class, therefore they are related."", ""Class""); (""Class"", ""Classes are part of a package, therefore they are related."", ""Package""); (""Subclasses"", ""Subclasses are related to their parent class, therefore they are related."", ""Class""); (""Constructor"", ""A constructor's accessibility is determined by its package, therefore they are related."", ""Package"")"
"A class can have multiple constructors, and each constructor can have its own access modifier.","(""Class"", ""A class can have multiple constructors, indicating that constructors are a part of a class."", ""Constructors""); (""Constructors"", ""Each constructor can have its own access modifier, indicating that access modifiers are related to constructors."", ""Access Modifier"")"
"Thus, some constructors may be available to all classes in your application, while other constructors are only available to classes in the same package, subclasses, or even only to the class itself (private constructors).","(""Constructors"", ""Constructors are available to classes in the application"", ""Classes""); (""Classes"", ""Classes can be in the same package"", ""Package""); (""Subclasses"", ""Subclasses are related to their parent classes"", ""Classes""); (""Constructors"", ""Constructors can be available to subclasses"", ""Subclasses"")"
Here is an example of a Java class with a constructor that can throw an exception:,NULL
Making a constructor throw an exception can be a good idea if you want to prevent an object of the given class to be created in an invalid state.,"(""Constructor"", ""The constructor is related to the exception because making a constructor throw an exception can prevent an object from being created in an invalid state."", ""Exception""); (""Constructor"", ""The constructor is related to the object because it is used to create an object of the given class."", ""Object"")"
"A class can have fields, constructors and methods (plus more, but that is not important now).","(""Class"", ""A class can have methods"", ""Methods""); (""Class"", ""A class can have fields"", ""Fields"")"
"When you create an object, that object is of a certain class.",NULL
The class is like a template (or blueprint) telling how objects of that class should look.,"(""Class"", ""The class is related to the template because the text states that the class is like a template."", ""Template""); (""Class"", ""The class is related to the blueprint because the text states that the class is like a blueprint."", ""Blueprint"")"
"When you create an object, you say ""give me an object of this class"".",NULL
"If you think of a factory producing lots and lots of the same items, then the class would be the blueprint / manual of how the finished product should look, and the objects would be each of the finished products.",NULL
"If the factory produced cars, then the blueprint / design manual of the cars to produce corresponds to a Java class, and the physical cars produced corresponds to Java objects.",NULL
Here is a simple diagram illustrating the principle of objects being of a certain class.,"(""Class"", ""The source entity 'Class' and the target entity 'Object' are related to each other because an object is an instance of a class."", ""Object"")"
The class determines what fields and methods the objects of that class have.,"(""Class"", ""The class determines what methods the objects of that class have, indicating a relationship between the class and its methods."", ""Methods"")"
"The Car class does not contain any fields, constructors or methods.",NULL
The example primarily serves to show you an example of how a class declaration looks in Java code.,NULL
A field is a variable that belongs to a class or an object.,"(""Field"", ""A field is a variable that belongs to a class, indicating a clear relationship between the two entities."", ""Class""); (""Field"", ""A field is a variable that belongs to a class or an object, indicating a clear relationship between the two entities."", ""Object"")"
"For instance, a Car class could define the field brand which all Car objects would have.",NULL
Here is the Car class declaration from above with a field name brand added:,NULL
Constructors are a special kind of method that is executed when an object of that class is created.,"(""Constructors"", ""Constructors are a special kind of method that is executed when an object of that class is created, indicating a relationship between constructors and classes."", ""Class""); (""Method"", ""Constructors are a special kind of method that is executed when an object of that class is created, indicating a relationship between methods and classes."", ""Class"")"
Here is the Car class from before with a constructor that initializes the brand field:,"(""Car"", ""The Car class has a constructor that initializes the brand field, indicating a relationship between the Car class and the constructor method."", ""constructor""); (""constructor"", ""The constructor method initializes the brand field, indicating a relationship between the constructor method and the brand field."", ""brand"")"
"Here is the Car class from before with a single, simple method named getBrand added:",NULL
"When a class implements an interface, the class has to implement all the methods described in the interface.","(""Class"", ""A class implements an interface, indicating a relationship between the two."", ""Interface""); (""Class"", ""A class has to implement all the methods described in the interface, showing a relationship between the class and the methods."", ""Methods"")"
"Packages provides a handy way of grouping related classes and interfaces, thus making modularization of your Java code easier.","(""Packages"", ""Packages provides a handy way of grouping related classes, thus making modularization of your Java code easier, indicating a clear relationship between Packages and classes."", ""classes""); (""Packages"", ""Packages provides a handy way of grouping related interfaces, thus making modularization of your Java code easier, indicating a clear relationship between Packages and interfaces."", ""interfaces""); (""Packages"", ""Packages provides a handy way of grouping related classes and interfaces, thus making modularization of your Java code easier, indicating a clear relationship between Packages and Java code."", ""Java code""); (""classes"", ""Both classes and interfaces are grouped together by Packages, indicating a relationship between classes and interfaces."", ""interfaces""); (""classes"", ""Classes are part of the Java code, indicating a relationship between classes and Java code."", ""Java code"")"
"That these are primitive data types means that they are not objects, nor references to objects (classes and objects are explained in later texts in this Java tutorial).","(""Java"", ""Java is related to Tutorial because the text mentions 'this Java tutorial', indicating that Java is the subject of the tutorial."", ""Tutorial""); (""Data Types"", ""Data Types are related to Java because the text mentions 'these are primitive data types' in the context of a Java tutorial, indicating that data types are a concept being explained in Java."", ""Java"")"
You can also create your own more complex data types by creating custom classes.,NULL
"More precisely, a Java enum type is a special kind of Java class.",NULL
Notice the enum keyword which is used in place of class or interface.,"(""Enum"", ""Enum is related to Class because the enum keyword is used in place of class."", ""Class"")"
Replace the ... with the code to execute if the level variable matches the given Level constant value.,NULL
You can obtain an array of all the possible values of a Java enum type by calling its static values() method.,"(""Enum"", ""The Enum class has a static method called Values, which returns an array of all the possible values of the enum type."", ""Values""); (""Java"", ""Java is an object-oriented programming language that has a concept called Enum, which is a special type of class."", ""Enum"")"
All enum types get a static values() method automatically by the Java compiler.,"(""Enum"", ""The Enum class has a relationship with the Values method because all enum types get a static values() method automatically."", ""Values""); (""Java Compiler"", ""The Java Compiler package has a relationship with the Enum class because it automatically provides the values() method for all enum types."", ""Enum"")"
An enum class automatically gets a toString() method in the class when compiled.,NULL
The toString() method returns a string value of the name of the given enum instance.,NULL
"Then the toString() method will get called behind the scenes, so the value that will be printed out is the textual name of the enum instance.",NULL
An enum class automatically gets a static valueOf() method in the class when compiled.,NULL
The valueOf() method can be used to obtain an instance of the enum class for a given String value.,NULL
The level variable will point to the Level.HIGH after executing this line.,"(""Level"", ""Level.HIGH is a member of the Level class, indicating a relationship between the two entities as Level.HIGH is a value within the Level class"", ""Level.HIGH""); (""level"", ""The level variable is related to the Level class as it will point to one of its values, specifically Level.HIGH, after executing the given line of code"", ""Level"")"
It is possible for a Java enum class to have abstract methods too.,"(""Java"", ""Java is related to Enum because Enum is a type of Java class"", ""Enum""); (""Enum"", ""Enum is related to Abstract Methods because an Enum class can have abstract methods"", ""Abstract Methods"")"
"If an enum class has an abstract method, then each instance of the enum class must implement it.","(""Enum Class"", ""An enum class can have an abstract method that needs to be implemented by its instances."", ""Abstract Method""); (""Abstract Method"", ""Each instance of the enum class must implement the abstract method."", ""Instance"")"
Notice the abstract method declaration at the bottom of the enum class.,NULL
It is the method getDescription() that comes from the interface MyInterface.,NULL
"Java enums extend the java.lang.Enum class implicitly, so your enum types cannot extend another class.","(""Java"", ""Java enums extend the Enum class implicitly, indicating a relationship between Java and Enum"", ""Enum""); (""Enum"", ""Enum is a part of the java.lang package, and java.lang.Enum is the full name of the Enum class, indicating a relationship between Enum and java.lang.Enum"", ""java.lang.Enum"")"
"The purpose of this exercise is to verify that you know how to create classes, how to create instance variables inside the classes, how to create an array of objects and how to iterate that array while referencing the objects in it.",NULL
"For instance, in a class representing an employee, the Employee class might contain the following fields:",NULL
The access modifier determines which object classes that can access the field.,"(""Access"", ""The access modifier determines the accessibility of the field, thus they are related."", ""Field""); (""Modifier"", ""The modifier determines which object classes that can access the field, thus they are related."", ""Field""); (""Object"", ""The object classes can access the field, thus they are related."", ""Field""); (""Access"", ""The access modifier determines the accessibility, thus access and modifier are related."", ""Modifier""); (""Access"", ""The access modifier determines which object classes, thus access and object are related."", ""Object"")"
"In Java, static fields belongs to the class, not instances of the class.","(""Java"", ""Java is an object-oriented programming language that utilizes the concept of classes"", ""Class""); (""Static Fields"", ""Static fields belong to the class, indicating a relationship between the two where the class is the owner of the static fields"", ""Class"")"
"Thus, all instances of any class will access the same static field variable.",NULL
A non-static field value can be different for every object (instance) of a class.,"(""Class"", ""A class has fields, and a field is a member of a class, which is why they are related to each other."", ""Field""); (""Class"", ""A class is a blueprint for creating objects, and an object is an instance of a class, which is why they are related to each other."", ""Object""); (""Class"", ""A class is a blueprint for creating instances, and an instance is a specific realization of a class, which is why they are related to each other."", ""Instance""); (""Object"", ""An object and an instance are often used interchangeably, with an instance being a specific object created from a class, which is why they are related to each other."", ""Instance""); (""Field"", ""A field is a member of a class, and its value can be different for every object of that class, which is why they are related to each other."", ""Object"")"
The Java field access modifier determines whether the field can be accessed by classes other than the the class owning the field.,"(""Java"", ""The Java field access modifier is related to the field because it determines the field's accessibility."", ""Field""); (""Java"", ""The Java field access modifier is related to Java because it is a part of the Java programming language."", ""Access Modifier"")"
The private access modifier means that only code inside the class itself can access this Java field.,"(""Class"", ""The Class entity is related to the Field entity because a field is a member of a class."", ""Field""); (""Java"", ""The Java entity is related to the Class entity because Java is a programming language that uses classes."", ""Class"")"
"The package access modifier means that only code inside the class itself, or other classes in the same package, can access the field.","(""Package"", ""The package and class are related because the class is located inside the package, and the package access modifier affects the accessibility of the class's fields."", ""Class"")"
"The protected access modifier is like the package modifier, except subclasses of the class can also access the field, even if the subclass is not located in the same package.","(""Protected Access Modifier"", ""The protected access modifier is compared to the package modifier, indicating a relationship between the two."", ""Package Modifier""); (""Subclass"", ""A subclass is a type of class, indicating a relationship between the two, with the subclass being a specialized version of the class."", ""Class""); (""Field"", ""A field is a member of a class, indicating a relationship between the two, with the field being accessed and modified through the class."", ""Class""); (""Subclass"", ""A subclass can access and modify a field, indicating a relationship between the two, with the subclass having the ability to interact with the field."", ""Field""); (""Protected Access Modifier"", ""The protected access modifier allows subclasses to access the field, indicating a relationship between the two, with the protected access modifier controlling the accessibility of the field to the subclass."", ""Subclass""); (""Package Modifier"", ""The package modifier is related to the class, as it determines the accessibility of the class and its members, including fields."", ""Class"")"
The public access modifier means that the field can be accessed by all classes in your application.,"(""Access"", ""The access modifier is related to the field because it determines the field's accessibility."", ""Field""); (""Field"", ""The field is related to the application because it can be accessed by all classes in the application."", ""Application"")"
You would probably not use all access modifiers in the same class.,NULL
"For simple, data carrying classes you may declare all fields public.",NULL
"Thus, no matter how many objects you create of that class, there will only exist one field located in the class, and the value of that field is the same, no matter from which object it is accessed.","(""Class"", ""The field is located in the class, indicating a relationship between the class and the field."", ""Field""); (""Class"", ""The class is used to create objects, indicating a relationship between the class and the object."", ""Object"")"
"Static fields are located in the class, so you don't need an instance of the class to access static fields.","(""CLASS"", ""The CLASS entity is related to the STATIC FIELDS entity because static fields are located in the class."", ""STATIC FIELDS"")"
"Non-static Java fields, on the other hand, are located in the instances of the class.","(""Java"", ""Java is related to Class because Java is a programming language that uses classes"", ""Class"")"
Each instance of the class can have its own values for these fields.,NULL
To access a non-static field you need an instance of the class (an object) on which you can access it.,"(""Class"", ""A field is accessed through an instance of the class, indicating a relationship between the class and the field."", ""Field""); (""Class"", ""An object is an instance of the class, indicating a relationship between the class and the object."", ""Object"")"
"That means, that even if the field belongs to objects (class instances), you cannot vary the value of the field from object to object.","(""Field"", ""The field belongs to objects, indicating a relationship between the two entities."", ""Objects""); (""Field"", ""The field is associated with instances, which are class instances, showing a connection between Field and Instances."", ""Instances"")"
"That way it only exists in the class, not in every object too.",NULL
"The first line creates a new Customer object (an instance of the Customer class), and stores it in a variable called customer.",NULL
A class is loaded the first time it is referenced in your program.,NULL
"Inside the parentheses () after the for keyword, are three statements separated by semicolon (;).","(""For"", ""The For keyword is related to the Parentheses because the Parentheses are used after the For keyword."", ""Parentheses""); (""For"", ""The For keyword is related to the Semicolon because the Semicolon is used to separate statements after the For keyword."", ""Semicolon"")"
"In this example, only the first System.out.println() statement is executed inside the for loop.","(""System"", ""System is a class that contains the out class"", ""out""); (""out"", ""out is a class that contains the println method"", ""println"")"
The second System.out.println() statement is not executed until after the for loop is finished.,"(""System"", ""System is related to out because out is a part of the System class"", ""out""); (""out"", ""out is related to println because println is a method of the out class"", ""println""); (""for loop"", ""The for loop is related to System because the System class is used within the for loop"", ""System""); (""for loop"", ""The for loop is related to out because out is used within the for loop to print output"", ""out"")"
"Second, inside the isValid() method the String.equals() method is used to test for equality to a certain string value.","(""IsValid"", ""The IsValid method uses the String.Equals method to test for equality"", ""String.Equals""); (""String"", ""The String.Equals method is a part of the String class"", ""String.Equals"")"
The isValid() method could actually have been written in a shorter way.,NULL
Now the isValid() method returns the value returned by the value.equals() method call.,"(""IsValid"", ""The IsValid method is related to the Equals method because it returns the value returned by the Equals method call."", ""Equals""); (""Value"", ""The Value class is related to the Equals method because the Equals method is called on an instance of the Value class."", ""Equals"")"
Java inheritance refers to the ability in Java for one class to inherit from another class.,NULL
One class can extend another class and thereby inherit from that class.,NULL
"When one class inherits from another class in Java, the two classes take on certain roles.",NULL
The class that extends (inherits from another class) is the subclass and the class that is being extended (the class being inherited from) is the superclass .,"(""Subclass"", ""The subclass extends or inherits from the superclass, indicating a clear inheritance relationship between the two classes."", ""Superclass"")"
"A subclass is a specialization of a superclass, and a superclass is a generalization of one or more subclasses.","(""Subclass"", ""A subclass is a specialization of a superclass, indicating a relationship between the two."", ""Superclass"")"
"Inheritance can be an effective method to share code between classes that have some traits in common, yet allowing the classes to have some parts that are different.","(""Inheritance"", ""Inheritance is related to Method as it is described as an effective method"", ""Method""); (""Inheritance"", ""Inheritance is related to Classes as it is used to share code between classes"", ""Classes"")"
"Here is diagram illustrating a class called Vehicle, which has two subclasses called Car and Truck.","(""Vehicle"", ""Vehicle is the superclass of Car, indicating a clear inheritance relationship between the two classes"", ""Car"")"
The Vehicle class can contain those fields and methods that all Vehicles need (e.g.,NULL
Note: Some people will claim that inheritance is a way to categorize your classes based on what they are.,"(""Note"", ""Note is related to inheritance because it is describing the concept of inheritance in the context of classes."", ""inheritance""); (""inheritance"", ""inheritance is related to people because people are claiming that inheritance is a way to categorize classes."", ""people"")"
"In practice, however, that is not how you determine which superclasses and subclasses your application needs to have.","(""Application"", ""An application may have multiple superclasses that it needs to have."", ""Superclasses""); (""Application"", ""An application may have multiple subclasses that it needs to have."", ""Subclasses"")"
Then it makes sense to have a common Vehicle superclass for the two classes.,NULL
"If you never process Car and Truck objects in the same way, there is no point in having a common superclass for them, except perhaps to share code between them (to avoid writing duplicate code).",NULL
Superclasses and subclasses form an inheritance structure which is also called a class hierarchy.,"(""Superclasses"", ""Superclasses and subclasses are related because they both participate in forming an inheritance structure, which is a fundamental concept in object-oriented programming."", ""Subclasses""); (""Superclasses"", ""Superclasses are related to Inheritance because they are a key component of the inheritance structure, which is also known as a class hierarchy."", ""Inheritance"")"
At the top of the class hierarchy you have the superclasses.,"(""Class"", ""The class is related to the hierarchy because it is at the top of it."", ""Hierarchy"")"
At the bottom of the class hierarchy you have the subclasses.,NULL
"A class hierarchy may have multiple levels, meaning multiple levels of superclasses and subclasses.","(""Class Hierarchy"", ""A class hierarchy may have multiple levels of superclasses, indicating a relationship between the class hierarchy and its superclasses."", ""Superclasses""); (""Class Hierarchy"", ""A class hierarchy may have multiple levels of subclasses, indicating a relationship between the class hierarchy and its subclasses."", ""Subclasses"")"
A subclass may itself be a superclass of other subclasses etc.,"(""Subclass"", ""A subclass is related to a superclass because it inherits properties from it"", ""Superclass""); (""Subclass"", ""A subclass is related to other subclasses because they can all inherit properties from a common superclass"", ""Subclasses"")"
"When a class inherits from a superclass, it inherits parts of the superclass methods and fields.","(""Class"", ""A class inherits from a superclass, indicating a clear relationship between the two."", ""Superclass""); (""Class"", ""A class inherits parts of the superclass methods, indicating that the class is related to the methods it inherits."", ""Methods""); (""Class"", ""A class inherits parts of the superclass fields, indicating that the class is related to the fields it inherits."", ""Fields""); (""Superclass"", ""The superclass has methods that are inherited by the class, indicating a relationship between the superclass and its methods."", ""Methods"")"
"When a subclass extends a superclass in Java, all protected and public fields and methods of the superclass are inherited by the subclass.","(""Subclass"", ""The Subclass is related to the Superclass because it extends it and inherits its fields and methods."", ""Superclass""); (""Superclass"", ""The Superclass is related to its Fields because it has protected and public fields that are inherited by the Subclass."", ""Fields""); (""Superclass"", ""The Superclass is related to its Methods because it has protected and public methods that are inherited by the Subclass."", ""Methods""); (""Subclass"", ""The Subclass is related to the Fields because it inherits the protected and public fields of the Superclass."", ""Fields"")"
"By inherited is meant that these fields and methods are part of of the subclass, as if the subclass had declared them itself.","(""SUBCLASS"", ""The subclass has inherited these fields, making them part of the subclass."", ""FIELDS"")"
protected and public fields can be called and referenced just like the methods declared directly in the subclass.,"(""Fields"", ""Fields and methods are related because they can both be called and referenced in a similar manner."", ""Methods""); (""Subclass"", ""A subclass is related to methods because it can declare methods directly."", ""Methods"")"
Fields and methods with default (package) access modifiers can be accessed by subclasses only if the subclass is located in the same package as the superclass.,"(""Subclass"", ""A subclass is related to a superclass because it can access the superclass's fields and methods with default access modifiers."", ""Superclass""); (""Subclass"", ""A subclass is related to a package because it must be located in the same package as the superclass to access its fields and methods with default access modifiers."", ""Package""); (""Superclass"", ""A superclass is related to a package because its fields and methods with default access modifiers can be accessed by subclasses in the same package."", ""Package""); (""Fields"", ""Fields with default access modifiers are related to a package because they can be accessed by subclasses in the same package."", ""Package"")"
Private fields and methods of the superclass can never be referenced directly by subclasses.,"(""Superclass"", ""The Superclass has Subclasses that cannot reference its private fields and methods directly"", ""Subclasses""); (""Superclass"", ""The Superclass has private fields that cannot be referenced directly by its Subclasses"", ""Fields""); (""Superclass"", ""The Superclass has private methods that cannot be referenced directly by its Subclasses"", ""Methods""); (""Subclasses"", ""The Subclasses cannot reference the private fields of the Superclass directly"", ""Fields"")"
"They can, however, be referenced indirectly via methods reachable from the subclass (e.g default (package), protected and public methods).","(""Subclass"", ""The subclass can reference methods, indicating a relationship between the two entities."", ""Methods""); (""Methods"", ""Methods can be referenced via the package, indicating a relationship between the two entities."", ""Package"")"
"Constructors are not inherited by subclasses, but a subclass constructor must call a constructor in the superclass.","(""Subclasses"", ""A subclass must call a constructor in the superclass, indicating a relationship between the two."", ""Superclass""); (""Constructors"", ""Subclasses do not inherit constructors, but their constructors must call a constructor in the superclass, indicating a relationship between constructors and subclasses."", ""Subclasses"")"
The Java inheritance mechanism only allows a Java class to inherit from a single superclass (singular inheritance).,"(""Java"", ""The Java inheritance mechanism is a part of the Java class, indicating a relationship between the two entities."", ""inheritance mechanism""); (""inheritance mechanism"", ""The inheritance mechanism allows a Java class to inherit from a single superclass, indicating a relationship between the two entities."", ""superclass"")"
"In some programming languages, like C++, it is possible for a subclass to inherit from multiple superclasses (multiple inheritance).","(""Subclass"", ""A subclass is related to superclasses because it can inherit from them, as described in the concept of multiple inheritance."", ""Superclasses""); (""C++"", ""C++ is related to subclass because it is a programming language that supports the concept of a subclass."", ""Subclass"")"
"the superclasses contain methods with the same names and parameters, multiple inheritance was left out in Java.","(""Superclasses"", ""The superclasses contain methods with the same names and parameters, indicating a relationship between the two entities."", ""Methods""); (""Java"", ""Java left out multiple inheritance, which is related to the concept of superclasses."", ""Superclasses"")"
You declare that one class extends another class by using the extends keyword in the class definition.,NULL
"The Car class in this example extends the Vehicle class, meaning the Car class inherits from the Vehicle class.",NULL
"Because the Car class extends the Vehicle class, the protected field licensePlate from the Vehicle class is inherited by the Car class.","(""Car"", ""The Car class extends the Vehicle class, indicating a clear inheritance relationship between the two classes."", ""Vehicle""); (""Car"", ""The Car class inherits the protected field licensePlate from the Vehicle class, indicating a relationship between the Car class and the licensePlate field."", ""licensePlate"")"
"The licensePlate field is not actually being referenced from the Car class in the code above, but it could if we wanted to.",NULL
In many cases it would have made sense to place the getLicensePlate() method in the Vehicle class where the licensePlate field is located.,"(""GetLicensePlate()"", ""The getLicensePlate() method is related to the Vehicle class because it would have made sense to place the method in the class where the licensePlate field is located."", ""Vehicle""); (""GetLicensePlate()"", ""The getLicensePlate() method is related to the LicensePlate field because the method is used to retrieve the license plate information."", ""LicensePlate"")"
I just placed the getLicensePlate() method in the Car class to show that it is possible.,NULL
It is possible to reference a subclass as an instance of one of its superclasses.,NULL
"For instance, using the class definitions from the example in the previous section it is possible to reference an instance of the Car class as an instance of the Vehicle class.",NULL
"Because the Car class extends (inherits from) the Vehicle class, it is also said to be a Vehicle.",NULL
Here is a Java code example: Car car = new Car(); Vehicle vehicle = car; First a Car instance is created.,"(""Car"", ""Car is the class of the car instance"", ""car""); (""Vehicle"", ""Vehicle is the class of the vehicle instance"", ""vehicle""); (""car"", ""car is assigned to vehicle, indicating that car is a subtype of vehicle or they are related through inheritance"", ""vehicle"")"
This is possible because the Car class inherits from the Vehicle class.,NULL
"As you can see, it is possible to use an instance of some subclass as if it were an instance of its superclass.","(""Subclass"", ""A subclass is related to its superclass because it inherits properties and methods from it, and can be used as an instance of the superclass."", ""Superclass""); (""Instance"", ""An instance is related to a subclass because it is an object created from the subclass."", ""Subclass"")"
"That way, you don't need to know exactly what subclass the object is an instance of.",NULL
The process of referencing an object of class as a different type than the class itself is called type casting.,"(""Class"", ""The class is related to the type because type casting involves referencing an object of a class as a different type."", ""Type""); (""Type"", ""The type is related to the class because type casting involves referencing an object of a class as a different type."", ""Class""); (""Type Casting"", ""Type casting is a process that involves a class, specifically referencing an object of the class as a different type."", ""Class"")"
Upcasting and Downcasting You can always cast an object of a subclass to one of its superclasses.,"(""Upcasting"", ""Upcasting and Downcasting are related as they are both mentioned together in the context of casting an object of a subclass to one of its superclasses."", ""Downcasting""); (""object"", ""An object is an instance of a subclass, and the text mentions casting an object of a subclass to one of its superclasses."", ""subclass""); (""subclass"", ""A subclass is related to its superclasses as it can be cast to one of them, according to the text."", ""superclasses"")"
This is referred to as upcasting (from a subclass type to a superclass type).,NULL
"It may also be possible to cast an object from a superclass type to a subclass type, but only if the object really is an instance of that subclass (or an instance of a subclass of that subclass).","(""Superclass"", ""A subclass is a specialized version of a superclass, and can inherit its properties and behavior."", ""Subclass""); (""Object"", ""An object can be an instance of a subclass, and can exhibit the properties and behavior defined by that subclass."", ""Subclass"")"
This is referred to as downcasting (from a superclass type to a subclass type).,"(""Superclass"", ""The superclass and subclass are related because downcasting is from a superclass type to a subclass type, indicating an inheritance relationship between the two."", ""Subclass""); (""Downcasting"", ""Downcasting is related to superclass because it involves casting from a superclass type to a subclass type, indicating that downcasting is a process applied to superclass entities."", ""Superclass"")"
"Thus, this example of downcasting is valid: Car car = new Car(); // upcast to Vehicle Vehicle vehicle = car; // downcast to car again Car car2 = (Car) vehicle; However, the following downcast example is not valid.","(""Car"", ""Car is a subclass of Vehicle, as indicated by the upcast and downcast operations"", ""Vehicle""); (""car"", ""car is an instance of the Car class"", ""Car""); (""vehicle"", ""vehicle is an instance of the Vehicle class"", ""Vehicle""); (""car2"", ""car2 is an instance of the Car class"", ""Car""); (""car"", ""car is upcast to vehicle, indicating a relationship between the two variables"", ""vehicle"")"
"Truck truck = new Truck(); // upcast to Vehicle Vehicle vehicle = truck; // downcast to car again Car car = (Car) vehicle; The Truck object can be upcast to a Vehicle object, but it cannot be downcast to a Car object later.","(""Truck"", ""Truck is related to Vehicle because a Truck object can be upcast to a Vehicle object"", ""Vehicle""); (""Vehicle"", ""Vehicle is related to Car because a Vehicle object is attempted to be downcast to a Car object"", ""Car"")"
Overriding Methods In a subclass you can override (redefine) methods defined in the superclass.,"(""Subclass"", ""The Subclass is related to the Superclass because it can override methods defined in the Superclass."", ""Superclass""); (""Subclass"", ""The Subclass is related to the Methods because it can override them."", ""Methods"")"
Here is a Java method override example: public class Vehicle { String licensePlate = null; public void setLicensePlate(String licensePlate) { this.licensePlate = licensePlate; } } public class Car extends Vehicle { public void setLicensePlate(String license) { this.licensePlate = license.toLowerCase(); } } Notice how both the Vehicle class and the Car class defines a method called setLicensePlate().,"(""Vehicle"", ""The Vehicle class contains a method called setLicensePlate, indicating a clear relationship between the class and the method."", ""setLicensePlate""); (""Car"", ""The Car class contains a method called setLicensePlate, indicating a clear relationship between the class and the method."", ""setLicensePlate"")"
"Now, whenever the setLicensePlate() method is called on a Car object, it is the method defined in the Car class that is called.","(""Car"", ""The setLicensePlate() method is defined in the Car class, indicating a clear relationship between the two entities."", ""setLicensePlate()"")"
To override a method the method signature in the subclass must be the same as in the superclass.,"(""Subclass"", ""The subclass and superclass are related because the subclass is overriding a method from the superclass, indicating an inheritance relationship."", ""Superclass""); (""Method"", ""The method is related to the subclass because it is being overridden in the subclass."", ""Subclass"")"
"That means that the method definition in the subclass must have exactly the same name and the same number and type of parameters, and the parameters must be listed in the exact same sequence as in the superclass.","(""Subclass"", ""The subclass is related to the superclass because it must have a method definition with the same name and parameters as the superclass."", ""Superclass""); (""Subclass"", ""The subclass is related to the method because it must have a method definition with the same name and parameters."", ""Method"")"
Otherwise the method in the subclass will be considered a separate method.,NULL
"If the superclass calls a private method internally from some other method, it will continue to call that method from the superclass, even if you create a private method in the subclass with the same signature.","(""Superclass"", ""The superclass calls a private method internally from some other method."", ""Private Method""); (""Subclass"", ""A private method in the subclass with the same signature is related to the private method in the superclass."", ""Private Method"")"
"It would be nice if the compiler could tell you that the method being overridden no longer overrides a method in the superclass, right?","(""Method"", ""The method is related to the superclass because it is being overridden from the superclass."", ""Superclass"")"
"You can call superclass implementations from any method in a subclass, like above.","(""Subclass"", ""A subclass can call superclass implementations, indicating a relationship between the two classes."", ""Superclass""); (""Method"", ""A method is part of a subclass, indicating a relationship between the method and the subclass."", ""Subclass"")"
"For instance, you could also have called super.setLicensePlate() from a method in the Car class called updateLicensePlate() which does not override the setLicensePlate() method.","(""Car"", ""The updateLicensePlate() method is part of the Car class."", ""updateLicensePlate()""); (""Car"", ""The setLicensePlate() method is part of the Car class or its superclass."", ""setLicensePlate()"")"
The instanceof instruction can determine whether a given object is an instance of some class.,"(""Instanceof"", ""The instanceof instruction can determine whether a given object is an instance of some class, indicating a relationship between the instruction and the object."", ""Object""); (""Instanceof"", ""The instanceof instruction can determine whether a given object is an instance of some class, indicating a relationship between the instruction and the class."", ""Class"")"
Here is a Java instanceof example: Car car = new Car(); boolean isCar = car instanceof Car; After this code has been executed the isCar variable will contain the value true.,"(""Car"", ""The Car class is related to the instanceof method because the instanceof method is used to check if an object is an instance of the Car class."", ""instanceof""); (""Car"", ""The Car class is related to the java package because the Car class is defined in the java programming language."", ""java"")"
A Car object is also a Vehicle object because Car is a subclass of Vehicle.,NULL
"Here is the same instanceof example, but using a Truck object instead of a Car object: Truck truck = new Truck(); Vehicle vehicle = truck; boolean isCar = vehicle instanceof Car; After executing this code the isCar will contain the value false.","(""Truck"", ""Truck is a subclass of Vehicle, as indicated by the assignment of a Truck object to a Vehicle variable."", ""Vehicle""); (""Truck"", ""Truck and Car are related in that they are both being compared using the instanceof operator, implying a possible inheritance relationship between the two classes."", ""Car"")"
"Fields and Inheritance As mentioned earlier, in Java fields cannot be overridden in a subclass.","(""Inheritance"", ""Inheritance is related to subclass because it is a mechanism in object-oriented programming where a subclass inherits properties and behavior from a superclass"", ""subclass""); (""Java"", ""Java is related to Inheritance because Java supports inheritance as a fundamental concept of object-oriented programming"", ""Inheritance""); (""Java"", ""Java is related to subclass because Java is the programming language in which the concept of a subclass is used"", ""subclass""); (""Fields"", ""Fields are related to Inheritance because fields in a superclass can be inherited by a subclass"", ""Inheritance"")"
"If the subclass tries to access the field, it will access the field in the subclass.",NULL
Both the Vehicle class and Car class has the methods setLicensePlate() and getLicensePlate().,"(""Vehicle"", ""The Vehicle class has the setLicensePlate method, indicating a clear relationship between the two entities."", ""setLicensePlate""); (""Vehicle"", ""The Vehicle class has the getLicensePlate method, indicating a clear relationship between the two entities."", ""getLicensePlate""); (""Car"", ""The Car class has the setLicensePlate method, indicating a clear relationship between the two entities."", ""setLicensePlate"")"
The instanceof instruction can also be used determine if an object is a instance of a superclass of its class.,"(""Instanceof"", ""The instanceof instruction can be used to determine if an object is an instance of a class"", ""Object""); (""Object"", ""An object can be an instance of a superclass of its class"", ""Superclass"")"
"Here is an instanceof example that checks if a Car object is an instance of Vehicle: Car car = new Car(); boolean isVehicle = car instanceof Vehicle; Assuming that the Car class extends (inherits from) the Vehicle class, the isVehicle variable will contain the value true after this code is executed.","(""Car"", ""The Car class extends or inherits from the Vehicle class, indicating a clear inheritance relationship between the two classes."", ""Vehicle""); (""Car"", ""The Car object is checked using the instanceof method to determine if it is an instance of Vehicle, indicating a usage relationship between the Car class and the instanceof method."", ""instanceof"")"
"Look at this instanceof example: Car car = new Car(); Vehicle vehicle = car; boolean isCar = vehicle instanceof Car; Even though the vehicle variable is of type Vehicle, the object it ends up pointing to in this example is a Car object.","(""Car"", ""Car is a subclass of Vehicle, as indicated by the fact that a Car object can be assigned to a variable of type Vehicle"", ""Vehicle""); (""Car"", ""The instanceof method is used to check if an object of type Car is an instance of the Car class"", ""instanceof"")"
"If you define a field in a subclass with the same name as a field in the superclass, the field in the subclass will hide (shadow) the field in the superclass.","(""Subclass"", ""The Subclass is related to the Superclass because it is a subclass of the Superclass, and they have a field with the same name."", ""Superclass""); (""Field"", ""The Field is related to the Subclass because it is defined in the Subclass."", ""Subclass"")"
"If, however, the subclass calls up into a method in the superclass, and that method accesses the field with the same name as in the subclass, it is the field in the superclass that is accessed.","(""Subclass"", ""The subclass calls up into a method in the superclass, indicating a relationship between the two classes."", ""Superclass""); (""Method"", ""The method accesses the field, indicating a relationship between the method and the field."", ""Field""); (""Subclass"", ""The subclass calls up into a method, indicating a relationship between the subclass and the method."", ""Method"")"
The methods in the Car class calls the corresponding methods in the Vehicle class.,NULL
"The result is, that eventually both set of methods access the licensePlate field in the Vehicle class.","(""Vehicle"", ""The Vehicle class contains the licensePlate field, indicating a clear relationship between the two entities."", ""licensePlate""); (""set of methods"", ""The set of methods accesses the licensePlate field, indicating a clear relationship between the two entities."", ""licensePlate"")"
"The updateLicensePlate() method in the Car class however, accesses the licensePlate field directly.","(""Car"", ""The updateLicensePlate() method is contained within the Car class, indicating a relationship between the two entities."", ""updateLicensePlate()"")"
"Therefore, you will not get the same result if you call setLicensePlate() as when you call the updateLicense() method.",NULL
"Look at the following lines of Java code: Car car = new Car(); car.setLicensePlate(""123""); car.updateLicensePlate(""abc""); System.out.println(""license plate: "" + car.getLicensePlate()); This Java code will print out the text 123.","(""Car"", ""The Car class has a method called setLicensePlate, which establishes a relationship between the two entities."", ""setLicensePlate""); (""Car"", ""The Car class has a method called updateLicensePlate, which establishes a relationship between the two entities."", ""updateLicensePlate""); (""Car"", ""The Car class has a method called getLicensePlate, which establishes a relationship between the two entities."", ""getLicensePlate""); (""System"", ""The System class has a method called out.println, which establishes a relationship between the two entities."", ""System.out.println"")"
The updateLicensePlate() method sets the license plate value on the licensePlate field in the Car class.,"(""UpdateLicensePlate"", ""The UpdateLicensePlate method is related to the Car class because it sets a value on a field in the Car class."", ""Car""); (""UpdateLicensePlate"", ""The UpdateLicensePlate method is related to the LicensePlate field because it sets the value of this field."", ""LicensePlate"")"
"The getLicensePlate() method, however, returns the value of the licensePlate field in the Vehicle class.","(""GetLicensePlate()"", ""The GetLicensePlate() method is related to the Vehicle class because it is used to return the value of a field in the Vehicle class."", ""Vehicle""); (""GetLicensePlate()"", ""The GetLicensePlate() method is related to the LicensePlate field because it returns the value of this field."", ""LicensePlate"")"
"Therefore, the value 123 which is set as value for the licensePlate field in the Vehicle class via the setLicensePlate() method, is what is printed out.","(""Vehicle"", ""The setLicensePlate() method is related to the Vehicle class because it is used to set the value of the licensePlate field in the Vehicle class."", ""setLicensePlate()"")"
"In other words, constructors of a superclass are not inherited by subclasses.","(""Superclass"", ""A superclass has subclasses, and the relationship is established through inheritance, where subclasses inherit properties and methods from the superclass but do not inherit its constructors."", ""Subclasses""); (""Constructors"", ""Constructors are a special type of method in a class, specifically in the superclass, used for initialization."", ""Superclass"")"
Subclasses can still call the constructors in the superclass using the super() contruct.,"(""Subclasses"", ""Subclasses are related to superclass because they can inherit from it and call its constructors"", ""superclass""); (""Subclasses"", ""Subclasses are related to super() because they can use it to call the constructors in the superclass"", ""super()"")"
"In fact, a subclass constructor is required to call one of the constructors in the superclass as the very first action inside the constructor body.","(""Subclass"", ""A subclass constructor is required to call one of the constructors in the superclass, indicating a relationship between the two classes."", ""Superclass""); (""Subclass"", ""The subclass has a constructor that is required to call one of the constructors in the superclass, indicating a relationship between the subclass and the constructor method."", ""Constructor"")"
Here is how that looks: public class Vehicle { public Vehicle() { } } public class Car extends Vehicle{ public Car() { super(); //perform other initialization here } } Notice the call to super() inside the Car constructor.,"(""Car"", ""Car is a subclass of Vehicle, indicating an inheritance relationship between the two classes"", ""Vehicle""); (""Car()"", ""The Car constructor calls the Vehicle constructor using the super() method, indicating a relationship between the two methods"", ""Vehicle()""); (""Car"", ""The Car class contains the Car constructor method, indicating a containment relationship between the class and the method"", ""Car()"")"
You may have seen Java classes where the subclass constructors did not seem to call the constructors in the superclass.,"(""subclass"", ""The subclass is related to the superclass because in Java, a subclass inherits properties and methods from its superclass, and the constructors of the subclass often need to call the constructors of the superclass."", ""superclass""); (""constructors"", ""The constructors are related to the subclass because they are a part of the subclass and are responsible for initializing its properties."", ""subclass"")"
"However, the subclass constructors have still called superclass constructors in those case.","(""Subclass"", ""The subclass is related to the superclass because it inherits from it and its constructors call the superclass constructors."", ""Superclass""); (""Subclass"", ""The subclass is related to the constructors because they are called in the subclass to initialize it."", ""Constructors"")"
"Let me explain why: If a class does not have any explicit constructor defined, the Java compiler inserts an implicit no-arg constructor.","(""Class"", ""A class may have a constructor, and in this case, the Java compiler inserts an implicit no-arg constructor if no explicit constructor is defined."", ""Constructor""); (""Java Compiler"", ""The Java compiler is responsible for inserting an implicit no-arg constructor into a class if no explicit constructor is defined."", ""Constructor"")"
"Therefore the following version of Vehicle is equivalent to the version shown just above: public class Vehicle { } Second, if a constructor does not explicitly call a constructor in the superclass, the Java compiler inserts an implicit call to the no-arg constructor in the superclass.","(""Vehicle"", ""The Vehicle class has a constructor, which is related to the concept of constructors in general."", ""constructor""); (""constructor"", ""A constructor in a subclass implicitly calls a constructor in its superclass, establishing a relationship between the two."", ""superclass""); (""Java compiler"", ""The Java compiler inserts an implicit call to a constructor in the superclass if it is not explicitly called, showing a relationship between the compiler and the constructor."", ""constructor"")"
"That means that the following version of the Car class is actually equivalent to the version shown earlier: public class Car extends Vehicle{ public Car() { } } In fact, since the constructor is now empty, we could leave it out and the Java compiler would insert it, and insert an implicit call to the no-arg constructor in the superclass.","(""Car"", ""The Car class extends the Vehicle class, indicating a clear inheritance relationship between the two."", ""Vehicle""); (""Car"", ""The Car class contains the Car() method, which is its constructor, indicating a composition relationship between the class and its constructor."", ""Car()"")"
"This is how the two classes would look then: public class Vehicle { } public class Car extends Vehicle{ } Even though no constructors are declared in these two classes, they both get a no-arg constructor, and the no-arg constructor in the Car class will call the no-arg constructor in the Vehicle class.","(""Car"", ""The Car class extends the Vehicle class, indicating a clear inheritance relationship between the two classes."", ""Vehicle""); (""Car"", ""The Car class has a no-arg constructor that calls the no-arg constructor in the Vehicle class, indicating a relationship between the Car class and the no-arg constructor method."", ""no-arg constructor"")"
"If the Vehicle class did not have a no-arg constructor, but had another constructor which takes parameters, the Java compiler would complain.","(""Vehicle"", ""The Vehicle class is related to the Java compiler because the Java compiler would complain if the Vehicle class did not have a no-arg constructor."", ""Java compiler""); (""Java"", ""The Java entity is related to the Vehicle class because the Vehicle class is written in Java."", ""Vehicle"")"
"The Car class would then be required to declare a constructor, and inside that constructor call the constructor in the Vehicle class.","(""Car"", ""The Car class is related to the Vehicle class because it is required to call the constructor in the Vehicle class, indicating an inheritance relationship."", ""Vehicle""); (""Car"", ""The Car class is related to the constructor method because it is required to declare a constructor, indicating a composition relationship."", ""constructor"")"
Nested Classes and Inheritance The same Java inheritance rules apply to nested classes.,NULL
Nested classes with the default (package) access modifier are only accessible to subclasses if the subclass is located in the same package as the superclass.,"(""Nested classes"", ""Nested classes have the default package access modifier"", ""package""); (""subclass"", ""a subclass is located in the same package as the superclass"", ""superclass""); (""subclass"", ""a subclass is located in the same package"", ""package""); (""superclass"", ""the superclass is located in the same package as the subclass"", ""package"")"
Nested classes with the protected or public access modifier are always inherited by subclasses.,NULL
Here is a nested class inheritance example: class MyClass { class MyNestedClass { } } public class MySubclass extends MyClass { public static void main(String[] args) { MySubclass subclass = new MySubclass(); MyNestedClass nested = subclass.new MyNestedClass(); } } Notice how it is possible to create an instance of the nested class MyNestedClass which is defined in the superclass (MyClass) via a reference to the subclass (MySubclass).,"(""MyClass"", ""MyNestedClass is a nested class of MyClass, indicating a containment relationship between the two classes"", ""MyNestedClass""); (""MySubclass"", ""MySubclass is a subclass of MyClass, indicating an inheritance relationship between the two classes"", ""MyClass""); (""MySubclass"", ""MySubclass has an instance of MyNestedClass, indicating an association relationship between the two classes"", ""MyNestedClass""); (""MyClass"", ""MyClass is a superclass of MySubclass, indicating an inheritance relationship between the two classes"", ""MySubclass""); (""main"", ""The main method is a part of the MySubclass class, indicating a membership relationship between the method and the class"", ""MySubclass"")"
Here is now that looks: public final class MyClass { } A final class cannot be extended.,NULL
"In other words, you cannot inherit from a final class in Java.",NULL
Abstract Classes and Inheritance In Java a class can be declared abstract.,"(""Abstract Classes"", ""Abstract Classes and Inheritance are related because they are both concepts in Java that are used together to create a class hierarchy."", ""Inheritance""); (""Java"", ""Java is related to Abstract Classes because Abstract Classes are a feature of the Java programming language."", ""Abstract Classes"")"
I have explained abstract classes in more detail in my Java abstract classes tutorial.,"(""Java"", ""Java is related to Abstract because Java is the programming language in which Abstract classes are used"", ""Abstract""); (""Abstract"", ""Abstract is related to Java Abstract Classes Tutorial because the tutorial is about Abstract classes"", ""Java Abstract Classes Tutorial"")"
An abstract class is a class that does not contain the full implementation of whatever the abstract class should do.,NULL
"In other words, you cannot create objects of an abstract class.",NULL
In Java abstract classes are intended to be extended to create a full implementation.,"(""Java"", ""Java is related to Abstract because Java is the programming language that utilizes abstract classes"", ""Abstract""); (""Abstract"", ""Abstract is related to Implementation because an abstract class is intended to be extended to create a full implementation"", ""Implementation"")"
The Java inheritance rules are the same for abstract classes as for non-abstract classes.,"(""Java"", ""Java has inheritance rules"", ""Inheritance""); (""Inheritance"", ""Inheritance applies to abstract classes"", ""Abstract""); (""Inheritance"", ""Inheritance also applies to non-abstract classes"", ""Non-Abstract"")"
You can always cast an object of a subclass to one of its superclasses.,"(""Subclass"", ""A subclass is related to its superclass because it can be cast to it, indicating an inheritance relationship."", ""Superclass""); (""Object"", ""An object is related to a subclass because it can be an instance of the subclass, and the text mentions casting an object of a subclass."", ""Subclass"")"
In a subclass you can override (redefine) methods defined in the superclass.,"(""Subclass"", ""A subclass is related to a superclass because it inherits properties and methods from it and can also override methods defined in the superclass."", ""Superclass""); (""Subclass"", ""A subclass is related to the override method because it can use this method to redefine methods defined in the superclass."", ""Override"")"
Notice how both the Vehicle class and the Car class defines a method called setLicensePlate().,"(""Vehicle"", ""The Vehicle class defines a method called setLicensePlate()."", ""setLicensePlate()"")"
"If you override a method in a subclass, and the method is all of a sudden removed or renamed or have its signature changed in the superclass, the method in the subclass no longer overrides the method in the superclass.","(""Subclass"", ""The subclass inherits from the superclass, and therefore any changes to the superclass can affect the subclass."", ""Superclass""); (""Method"", ""The method is overridden in the subclass, indicating a relationship between the method and the subclass."", ""Subclass"")"
"If you override a method in a subclass, but still need to call the method defined in the superclass, you can do so using the super reference, like this:","(""Subclass"", ""The subclass overrides a method defined in the superclass, indicating a relationship between the two classes."", ""Superclass""); (""Method"", ""The method is overridden in the subclass, indicating a relationship between the method and the subclass."", ""Subclass"")"
"In the above code example the method setLicensePlate() in the Car class, calls the setLicensePlate() method in the Vehicle class.","(""Car"", ""The Car class contains the setLicensePlate() method."", ""setLicensePlate()""); (""Vehicle"", ""The Vehicle class contains the setLicensePlate() method."", ""setLicensePlate()"")"
"Assuming that the Car class extends (inherits from) the Vehicle class, the isVehicle variable will contain the value true after this code is executed.","(""Car"", ""The Car class extends (inherits from) the Vehicle class, indicating a clear inheritance relationship between the two classes."", ""Vehicle""); (""Car"", ""The Car class is related to the isVehicle variable because the variable's value is determined by the code that checks if an object is a Vehicle, and Car is a subclass of Vehicle."", ""isVehicle"")"
"As mentioned earlier, in Java fields cannot be overridden in a subclass.","(""Java"", ""Java has fields which cannot be overridden in a subclass"", ""fields""); (""Java"", ""Java is related to subclass because a subclass is a type of class in Java"", ""subclass"")"
Here is Java inheritance example that illustrates how fields in subclasses shadow (hides) fields in superclasses:,"(""Java"", ""Java is related to Inheritance because Java is the programming language in which the concept of inheritance is being used"", ""Inheritance""); (""Inheritance"", ""Inheritance is related to Subclasses because Subclasses is a key concept in the process of inheritance"", ""Subclasses""); (""Inheritance"", ""Inheritance is related to Superclasses because Superclasses is a key concept in the process of inheritance"", ""Superclasses"")"
"If a class does not have any explicit constructor defined, the Java compiler inserts an implicit no-arg constructor.","(""Class"", ""A class may have a constructor, and if not explicitly defined, the Java compiler inserts an implicit no-arg constructor."", ""Constructor""); (""Java Compiler"", ""The Java compiler inserts an implicit no-arg constructor if a class does not have any explicit constructor defined."", ""Constructor"")"
"Second, if a constructor does not explicitly call a constructor in the superclass, the Java compiler inserts an implicit call to the no-arg constructor in the superclass.","(""Constructor"", ""A constructor is related to its superclass because it may explicitly or implicitly call a constructor in the superclass."", ""Superclass""); (""Constructor"", ""A constructor is related to the no-arg constructor because if it does not explicitly call another constructor, the Java compiler inserts an implicit call to the no-arg constructor."", ""No-arg Constructor""); (""Java Compiler"", ""The Java compiler is related to a constructor because it inserts an implicit call to the no-arg constructor if the constructor does not explicitly call a constructor in the superclass."", ""Constructor""); (""Java Compiler"", ""The Java compiler is related to the no-arg constructor because it inserts an implicit call to this constructor when necessary."", ""No-arg Constructor"")"
That means that the following version of the Car class is actually equivalent to the version shown earlier:,NULL
"In fact, since the constructor is now empty, we could leave it out and the Java compiler would insert it, and insert an implicit call to the no-arg constructor in the superclass.","(""Constructor"", ""The constructor is related to the superclass because it contains an implicit call to the no-arg constructor in the superclass."", ""Superclass""); (""Java Compiler"", ""The Java compiler is related to the constructor because it inserts an implicit call to the no-arg constructor in the superclass if the constructor is left out."", ""Constructor"")"
"Even though no constructors are declared in these two classes, they both get a no-arg constructor, and the no-arg constructor in the Car class will call the no-arg constructor in the Vehicle class.",NULL
Notice how it is possible to create an instance of the nested class MyNestedClass which is defined in the superclass (MyClass) via a reference to the subclass (MySubclass).,"(""MyClass"", ""MyNestedClass is defined in MyClass, indicating a containment relationship between the two classes"", ""MyNestedClass""); (""MyClass"", ""MySubclass is a subclass of MyClass, indicating an inheritance relationship between the two classes"", ""MySubclass"")"
"The Java instanceof operator can determine if a given Java object is an instance of a given class, superclass or interface.","(""Java"", ""The Java instanceof operator is a method in Java, indicating a relationship between the two."", ""instanceof""); (""instanceof"", ""The instanceof operator determines if a given Java object is an instance of a class, indicating a relationship between the instanceof operator and the object."", ""object""); (""instanceof"", ""The instanceof operator can determine if a given Java object is an instance of a given class, indicating a relationship between the instanceof operator and the class."", ""class""); (""instanceof"", ""The instanceof operator can determine if a given Java object is an instance of a given class, superclass or interface, indicating a relationship between the instanceof operator and the superclass."", ""superclass""); (""instanceof"", ""The instanceof operator can determine if a given Java object is an instance of a given class, superclass or interface, indicating a relationship between the instanceof operator and the interface."", ""interface""); (""Java"", ""Java is the programming language in which the object is used, indicating a relationship between Java and the object."", ""object""); (""Java"", ""Java is the programming language in which the class is used, indicating a relationship between Java and the class."", ""class""); (""Java"", ""Java is the programming language in which the superclass is used, indicating a relationship between Java and the superclass."", ""superclass""); (""Java"", ""Java is the programming language in which the interface is used, indicating a relationship between Java and the interface."", ""interface"")"
The Java instanceof operator is also referred to as a type comparison operator because it compares the type of a given instance (object) with a specific type (class or interface).,"(""Java"", ""Java is related to Instance because it is used as an example of a class that can have instances."", ""Instance""); (""Instance"", ""Instance is related to Instanceof because the instanceof operator is used to compare the type of an instance."", ""Instanceof""); (""Instanceof"", ""Instanceof is related to Operator because it is referred to as a type comparison operator."", ""Operator""); (""Operator"", ""Operator is related to Type because it compares the type of a given instance with a specific type."", ""Type""); (""Type"", ""Type is related to Comparison because it is used in the context of type comparison."", ""Comparison"")"
"The expression map instanceof Object will evaluate to true if the map variable references an object that is an instance of class Object, or any subclass of class Object.",NULL
"Since all classes in Java inherit from Object, this expression will evaluate to true.",NULL
"As mentioned earlier, the Java instanceof operator will evaluate to true if you compare an object to the exact class of that object.","(""Java"", ""The Java entity is related to the instanceof entity because the instanceof operator is a part of the Java programming language."", ""instanceof""); (""Java"", ""The Java entity is related to the operator entity because the operator is a part of the Java programming language."", ""operator"")"
Here is a Java instanceof example showing a comparison of an object to its exact class:,"(""String"", ""String is a subclass of Object"", ""Object""); (""String"", ""String is part of the Java.lang package"", ""Java.lang"")"
"As also mentioned earlier, the Java instanceof operator also evaluates to true when comparing an object against a superclass of the type of that object.","(""Java"", ""The Java language uses the instanceof operator to evaluate objects."", ""instanceof""); (""instanceof"", ""The instanceof operator is a part of the Java language and is used for evaluating objects."", ""operator""); (""object"", ""An object is an instance of its superclass according to the instanceof operator."", ""superclass""); (""Java"", ""Java is an object-oriented programming language that uses objects."", ""object""); (""Java"", ""Java is an object-oriented programming language that supports the concept of superclasses."", ""superclass""); (""instanceof"", ""The instanceof operator is used to compare an object against a class or interface."", ""object""); (""operator"", ""The operator is used to evaluate an object."", ""object"")"
"Since HashMap is a subclass of Object - even if not a direct subclass, the expression map instanceof Object evaluates to true.",NULL
"Note, that it does not matter how high up in the inheritance hierarchy the compared type is superclass of the type of the object.","(""Inheritance"", ""Inheritance is related to Superclass because it is mentioned that the compared type is a superclass of the type of the object in the context of inheritance hierarchy"", ""Superclass""); (""Superclass"", ""Superclass is related to Type because a superclass is a type that is higher up in the inheritance hierarchy"", ""Type""); (""Type"", ""Type is related to Object because the type of the object is being compared to its superclass"", ""Object""); (""Inheritance"", ""Inheritance is related to Type because it is the mechanism by which a type can have a superclass"", ""Type"")"
"As long as the type compared to is a superclass somewhere up the inheritance hierarchy, instanceof will evaluate to true.","(""Instanceof"", ""Instanceof is related to Inheritance Hierarchy because it evaluates to true as long as the type compared to is a superclass somewhere up the inheritance hierarchy"", ""Inheritance Hierarchy""); (""Inheritance Hierarchy"", ""Inheritance Hierarchy is related to Superclass because a superclass is somewhere up the inheritance hierarchy"", ""Superclass"")"
The Java instanceof operator also works when comparing an object against an interface instead of a class.,"(""Java"", ""The Java language uses the instanceof operator to compare objects."", ""instanceof""); (""Java"", ""The Java language uses the operator for comparisons."", ""operator""); (""instanceof"", ""The instanceof operator works when comparing an object against an interface or a class."", ""object""); (""operator"", ""The operator works when comparing an object against an interface or a class."", ""object""); (""interface"", ""An object can be compared against an interface."", ""object""); (""class"", ""An object can be an instance of a class."", ""object""); (""instanceof"", ""The instanceof operator works when comparing an object against an interface."", ""interface""); (""operator"", ""The operator works when comparing an object against an interface."", ""interface""); (""Java"", ""The Java language has interfaces."", ""interface""); (""Java"", ""The Java language has objects."", ""object"")"
"Notice, that even if the map variable is of type HashMap, the instanceof operator returns true for the expression map instanceof Map because the HashMap class implements the Map interface.","(""HashMap"", ""HashMap is related to Map because the HashMap class implements the Map interface."", ""Map""); (""HashMap"", ""HashMap is related to instanceof because the instanceof operator is used to check if an object of type HashMap is an instance of Map."", ""instanceof"")"
"The Java instanceof operator also evaluates to true when comparing an object against a superinterface which the class of the object, or a superclass of the object implements.","(""Java"", ""The Java language uses the instanceof operator to evaluate objects."", ""instanceof""); (""object"", ""An object is related to a superinterface because the class of the object implements the superinterface."", ""superinterface""); (""object"", ""An object is related to a superclass because the class of the object is a subclass of the superclass."", ""superclass""); (""superclass"", ""A superclass is related to a superinterface because the superclass implements the superinterface."", ""superinterface"")"
"The TreeMap class implements SortedMap, and thus also indirectly the Map interface.","(""TreeMap"", ""TreeMap implements SortedMap, indicating a direct relationship between the two entities."", ""SortedMap"")"
The Java instanceof operator always evaluates to false when a null variable is compared against any class or interface.,"(""Java"", ""The Java instanceof operator is a part of the Java language, which is a class, and the instanceof operator is a method."", ""instanceof""); (""instanceof"", ""The instanceof operator is related to the operator entity because it is a type of operator in Java."", ""operator""); (""variable"", ""A variable can be compared against an interface, as stated in the text, indicating a relationship between the two entities."", ""interface""); (""Java"", ""The Java language has variables, which are a type of class entity, indicating a relationship between the two entities."", ""variable""); (""instanceof"", ""The instanceof operator is used to compare a variable against a class or interface, indicating a relationship between the instanceof operator and the variable entity."", ""variable""); (""operator"", ""The operator is used with a variable to compare it against a class or interface, indicating a relationship between the operator and the variable entities."", ""variable""); (""Java"", ""The Java language has interfaces, which are a type of class entity, indicating a relationship between the Java entity and the interface entity."", ""interface""); (""instanceof"", ""The instanceof operator is used to compare a variable against an interface, indicating a relationship between the instanceof operator and the interface entity."", ""interface"")"
Here is a Java instanceof example illustrating the comparison of null against a class:,"(""Java"", ""Java is related to instanceof because it is an operator used in the Java programming language"", ""instanceof""); (""Instanceof"", ""Instanceof is related to Java because it is an operator used in the Java programming language"", ""Java""); (""Null"", ""Null is related to Instanceof because the example illustrates the comparison of null against a class using the instanceof operator"", ""Instanceof""); (""Class"", ""Class is related to Instanceof because the example illustrates the comparison of null against a class using the instanceof operator"", ""Instanceof"")"
"That is because it is not the reference type that is compared against the target class or interface, but the actual type of the referenced object.","(""Reference"", ""The reference type is compared against the target class or interface, indicating a relationship between the two."", ""Target""); (""Reference"", ""The reference type is compared against the interface, indicating a relationship between the two."", ""Interface"")"
"Since a Java String object can never be an instance of the Java Integer class, the Java compiler will catch this an give you an error.","(""String"", ""The String and Integer classes are related in the sense that they are both being compared in the context of Java objects and the Java compiler's error handling."", ""Integer""); (""Java"", ""The Java package is related to the String class because String is a part of the Java standard library."", ""String"")"
That means that the actual class of the referenced object could be pretty much any class (since all classes are subclasses of Object).,NULL
"In short, we can avoid the explicit downcast of an object when comparing it against a subclass.",NULL
Notice the str variable after the String class name in the instanceof expression inside the if-statement.,"(""String"", ""The String class is related to the instanceof method because it is used in the instanceof expression."", ""instanceof""); (""if-statement"", ""The if-statement is related to the instanceof method because the instanceof expression is inside the if-statement."", ""instanceof""); (""if-statement"", ""The if-statement is related to the str variable because the str variable is used in the if-statement."", ""str""); (""String"", ""The String class is related to the str variable because the str variable is compared to the String class in the instanceof expression."", ""str"")"
"Since the right hand side of the expression is only evaluated if the left hand side evaluates to true, this cannot result in startsWith() being called on a non-String object.",NULL
"A question I get a lot is what the difference is between Java interfaces and abstract classes, and when to use each.","(""Java"", ""Java is related to Interfaces because Java is the programming language that uses Interfaces."", ""Interfaces""); (""Java"", ""Java is related to Abstract Classes because Java is the programming language that uses Abstract Classes."", ""Abstract Classes"")"
"Having answered this question by email multiple times, I decided to write this tutorial about Java interfaces vs abstract classes.","(""Java"", ""Java is related to Interfaces because the text discusses Java interfaces"", ""Interfaces""); (""Java"", ""Java is related to Abstract because the text discusses Java abstract classes"", ""Abstract"")"
"In other words, to make the classes using the interface independent of the classes implementing the interface.",NULL
"Thus, you can exchange the implementation of the interface, without having to change the class using the interface.","(""Interface"", ""The interface and implementation are related because the implementation is an exchangeable part of the interface."", ""Implementation"")"
Abstract classes are typically used as base classes for extension by subclasses.,NULL
"Some programming languages use abstract classes to achieve polymorphism, and to separate interface from implementation, but in Java you use interfaces for that.","(""Java"", ""Java uses interfaces to achieve polymorphism and separate interface from implementation"", ""Interfaces"")"
"Remember, a Java class can only have 1 superclass, but it can implement multiple interfaces.","(""Java"", ""A Java class can only have 1 superclass, indicating a relationship between Java and superclass."", ""superclass""); (""Java"", ""A Java class can implement multiple interfaces, indicating a relationship between Java and interfaces."", ""interfaces"")"
"Thus, if a class already has a different superclass, it can implement an interface, but it cannot extend another abstract class.","(""Class"", ""A class can implement an interface, indicating a relationship between the two."", ""Interface""); (""Class"", ""A class can have a superclass, indicating a relationship between the two."", ""Superclass"")"
"If you also need to provide a base class or default implementation of the interface, add an abstract class (or normal class) that implements the interface.",NULL
"Here is an example showing a class referencing an interface, an abstract class implementing that interface, and a subclass extending the abstract class.",NULL
"Below are the code examples from the text on Java Abstract Classes, but with an interface added which is implemented by the abstract base class.","(""Java Abstract Classes"", ""The interface is implemented by the abstract base class in the Java Abstract Classes"", ""interface""); (""Abstract Classes"", ""The Abstract Classes use an interface which is implemented by the abstract base class"", ""interface""); (""Java"", ""Java is the programming language in which Java Abstract Classes are written"", ""Java Abstract Classes""); (""Java"", ""Java is the programming language in which Abstract Classes are used"", ""Abstract Classes""); (""Java"", ""Java is the programming language in which the interface is implemented"", ""interface"")"
"Fourth, how to use the interface URLProcessor as variable type, even though it is the subclass UrlProcessorImpl that is instantiated.",NULL
Using both an interface and an abstract base class makes your code more flexible.,NULL
It possible to implement simple URL processors simply by subclassing the abstract base class.,NULL
"A Java interface is a bit like a Java class, except a Java interface can only contain method signatures and fields.","(""Java Interface"", ""A Java interface is compared to a Java class, indicating a relationship between the two."", ""Java Class""); (""Java Interface"", ""A Java interface can only contain method signatures, indicating that method signatures are a part of a Java interface."", ""Method Signatures"")"
"However, it is possible to provide default implememntations of a method in a Java interface, to make the implementation of the interface easier for classes implementing the interface.","(""Interface"", ""An interface can provide default implementations of a method to make the implementation of the interface easier for classes implementing the interface."", ""Method""); (""Java"", ""Java is a programming language that supports interfaces, which can provide default implementations of methods."", ""Interface"")"
"Just like with classes, a Java interface can be declared public or package scope (no access modifier).","(""Java"", ""A Java interface is related to a Java class because it is compared to a class in the given text."", ""Interface""); (""Java Interface"", ""A Java interface is related to an interface because it is a type of interface."", ""Interface"")"
"As you can see, accessing a variable from an interface is very similar to accessing a static variable in a class.","(""Variable"", ""The variable is being accessed from the interface, indicating a relationship between the two."", ""Interface"")"
"The method, however, needs to be implemented by some class before you can access it.",NULL
"Before you can really use an interface, you must implement that interface in some Java class.",NULL
Here is a class that implements the MyInterface interface shown above:,NULL
This signals to the Java compiler that the MyInterfaceImpl class implements the MyInterface interface.,"(""MyInterfaceImpl"", ""MyInterfaceImpl implements MyInterface, indicating a clear relationship between the class and the interface"", ""MyInterface""); (""MyInterfaceImpl"", ""MyInterfaceImpl is compiled by the Java compiler, indicating a relationship between the class and the package"", ""Java"")"
A class that implements an interface must implement all the methods declared in the interface.,"(""Class"", ""A class that implements an interface must implement all the methods declared in the interface, indicating a clear relationship between the class and the interface."", ""Interface""); (""Class"", ""A class that implements an interface must implement all the methods declared in the interface, indicating a clear relationship between the class and the methods."", ""Methods"")"
The class does not need to implement (declare) the variables of an interface.,NULL
Once a Java class implements an Java interface you can use an instance of that class as an instance of that interface.,"(""Java"", ""A Java class implements a Java interface, establishing a relationship between the two."", ""Java interface""); (""Java"", ""An instance of a Java class can be used as an instance of an interface it implements, showing a relationship between the class and its instance."", ""instance"")"
Java allows this because the class MyInterfaceImpl implements the MyInterface interface.,NULL
You can then reference instances of the MyInterfaceImpl class as instances of the MyInterface interface.,NULL
"You must always create an instance of some class that implements the interface, and reference that instance as an instance of the interface.","(""Class"", ""A class implements an interface, so they are related through the implementation relationship."", ""Interface""); (""Instance"", ""An instance is created from a class, so they are related through the instantiation relationship."", ""Class"")"
In that case the class must implement all the methods declared in all the interfaces implemented.,"(""Class"", ""The class must implement all the methods, indicating a clear relationship between the class and its methods."", ""Methods""); (""Class"", ""The class implements all the interfaces, indicating a clear relationship between the class and the interfaces it implements."", ""Interfaces"")"
"If the interfaces are not located in the same packages as the implementing class, you will also need to import the interfaces.","(""Interfaces"", ""The interfaces are implemented by the implementing class, indicating a clear relationship between the two entities."", ""Implementing Class""); (""Interfaces"", ""The interfaces are located in packages, indicating a relationship between the interfaces and the packages they are located in."", ""Packages"")"
Java interfaces are imported using the import instruction just like Java classes.,"(""Java"", ""Java and Interfaces are related as Interfaces are a type of Java classes or are used in Java programming"", ""Interfaces""); (""Import"", ""Import is a method used in Java to import classes or interfaces"", ""Java"")"
Here are the two Java interfaces implemented by the class above:,NULL
"If a Java class implements multiple Java interfaces, there is a risk that some of these interfaces may contain methods with the same signature (name + parameters).","(""Java"", ""A Java class implements Java interfaces, indicating a relationship between the two."", ""Java interfaces""); (""Java interfaces"", ""Java interfaces contain methods, indicating a relationship between the two."", ""methods""); (""methods"", ""Methods have a signature, which is defined by their name and parameters, indicating a relationship between the two."", ""signature"")"
"Since a Java class can only implement at method with a given signature once, this could potentially lead to some problems.","(""Java"", ""A Java class can implement a method, indicating a relationship between the two entities."", ""Method""); (""Method"", ""A method has a signature, indicating a relationship between the two entities."", ""Signature"")"
"Especially if those constants are to be used by the classes implementing the interface, e.g.",NULL
It is up to the classes implementing the interface to specify an implementation.,NULL
"If the API just adds the method to the desired interface, all classes that implements the interface must implement that new method.","(""API"", ""The API adds a method to the interface, indicating a relationship between the two."", ""INTERFACE""); (""INTERFACE"", ""The interface requires implementing classes to implement the new method, showing a relationship between the interface and the method."", ""METHOD""); (""API"", ""The API is responsible for adding the method, demonstrating a relationship between the API and the method."", ""METHOD"")"
That is fine if all implementing classes are located within the API.,NULL
"But if some implementing classes are located in client code of the API (the code that uses the API), then that code breaks.","(""API"", ""The API is used by the code, indicating a relationship between the two entities."", ""CODE""); (""API"", ""The client code uses the API, establishing a clear relationship between the API and the client code."", ""CLIENT CODE"")"
Look at this interface and imagine that it is part of e.g.,NULL
"If the developer of the API wants to add one more method to the ResourceLoader interface, then the FileLoader class will be broken when that project upgrades to the new version of the API.",NULL
"A class can override the implementation of a default method simply by implementing that method explicitly, as is done normally when implementing a Java interface.","(""Class"", ""A class can override the implementation of a method, indicating a relationship between the two entities."", ""Method""); (""Class"", ""A class implements a Java interface, indicating a relationship between the two entities."", ""Java Interface"")"
Any implementation in a class takes precedence over interface default method implementations.,"(""Class"", ""A class contains or implements methods, thus they are related."", ""Method""); (""Interface"", ""An interface has default method implementations, thus they are related."", ""Method"")"
Calling a static method in an interface looks and works just like calling a static method in a class.,"(""CLASS"", ""A class contains a method, as indicated by the comparison of calling a static method in an interface to calling a static method in a class."", ""METHOD""); (""INTERFACE"", ""An interface contains a method, as indicated by the mention of calling a static method in an interface."", ""METHOD"")"
Here is an example of calling the static print() method from the above MyInterface interface:,NULL
"It is possible for a Java interface to inherit from another Java interface, just like classes can inherit from other classes.","(""Java Interface"", ""Java Interface and Classes are related because they both can inherit from other entities of the same type, as stated in the text."", ""Classes""); (""Java Interface"", ""Java Interface is related to itself because it can inherit from another Java interface, as mentioned in the text."", ""Java Interface"")"
"That then means, that if a class implements MySubInterface, that class has to implement all methods defined in both MySubInterface and MySuperInterface.",NULL
A class implementing an interface which inherits from multiple interfaces must implement all methods from the interface and its superinterfaces.,"(""Class"", ""A class implements an interface"", ""Interface""); (""Interface"", ""An interface inherits from multiple superinterfaces"", ""Superinterfaces""); (""Class"", ""A class must implement all methods from the interface and its superinterfaces"", ""Method""); (""Interface"", ""An interface has methods that must be implemented by a class"", ""Method"")"
"While it is normally possible for a class to implement multiple interfaces even if the interfaces contain methods with the same signature, this is not possible if one or more of these methods are default methods.","(""Class"", ""A class can implement multiple interfaces, indicating a relationship between the class and the interfaces it implements."", ""Interfaces""); (""Class"", ""A class can contain methods, indicating a relationship between the class and its methods."", ""Methods""); (""Interfaces"", ""Interfaces can contain methods, indicating a relationship between the interfaces and the methods they define."", ""Methods""); (""Methods"", ""Methods can be default methods, indicating a relationship between methods and default methods."", ""Default Methods"")"
"In other words, if two interfaces contain the same method signature (name + parameters) and one of the interfaces declare this method as a default method, a class cannot automatically implement both interfaces.","(""Class"", ""A class cannot automatically implement both interfaces, indicating a relationship between the class and the interfaces it implements."", ""Interface""); (""Class"", ""A class implements methods, indicating a relationship between the class and the methods it implements."", ""Method"")"
In both of the above situations the Java compiler requires that the class implementing the interface(s) explicitly implements the method which causes the problem.,"(""Java"", ""The Java compiler is related to the Compiler because it is the one requiring the class to implement the interface(s)."", ""Compiler""); (""Compiler"", ""The Compiler is related to the Method because it requires the class to explicitly implement the method."", ""Method""); (""Class"", ""The Class is related to the Interface because the class implements the interface(s)."", ""Interface""); (""Class"", ""The Class is related to the Method because the class implements the method."", ""Method"")"
That way there is no doubt about which implementation the class will have.,NULL
The implementation in the class takes precedence over any default implementations.,NULL
"Basically, polymorphism means that an instance of an class (an object) can be used as if it were of different types.","(""Polymorphism"", ""Polymorphism is a concept that is applied to classes, allowing an instance of a class to be used as if it were of different types."", ""Class""); (""Polymorphism"", ""Polymorphism is a concept that is applied to objects, allowing an instance of a class to be used as if it were of different types, and objects are instances of classes."", ""Object"")"
"The classes above are all parts of a model representing different types of vehicles and drivers, with fields and methods.","(""CLASSES"", ""The classes are part of a model"", ""MODEL""); (""FIELDS"", ""The fields are part of the classes"", ""CLASSES""); (""METHODS"", ""The methods are part of the classes"", ""CLASSES""); (""MODEL"", ""The model represents different types of vehicles"", ""VEHICLES"")"
That is the responsibility of these classes - to model these entities from real life.,NULL
"Please forget for a while, that implementing this functionality as methods directly on the objects may lead to a messy class hierarchy.","(""Functionality"", ""Functionality is implemented using methods"", ""Method""); (""Method"", ""Methods can lead to a messy class hierarchy"", ""Hierarchy""); (""Objects"", ""Objects are part of the class hierarchy"", ""Hierarchy""); (""Functionality"", ""Functionality is implemented on the objects"", ""Objects"")"
"Where in the above diagram would you put these three methods, so they are accessible on all classes?",NULL
"One way to solve this problem would be to create a common superclass for the Vehicle and Driver class, which has the storage and serialization methods.","(""Vehicle"", ""Both Vehicle and Driver are related as they are suggested to have a common superclass."", ""Driver""); (""Vehicle"", ""The Vehicle class is related to the storage method as it is implied that Vehicle will use this method."", ""storage""); (""Vehicle"", ""The Vehicle class is related to the serialization method as it is implied that Vehicle will use this method."", ""serialization""); (""Driver"", ""The Driver class is related to the storage method as it is implied that Driver will use this method."", ""storage""); (""Driver"", ""The Driver class is related to the serialization method as it is implied that Driver will use this method."", ""serialization"")"
"The class hierarchy would no longer model vehicles and drivers, but also be tied to the storage and serialization mechanisms used in your application.","(""Class"", ""The class is related to the hierarchy because the text mentions 'class hierarchy' as a single concept, indicating a close relationship between the two."", ""Hierarchy""); (""Class"", ""The class is related to vehicles because the text states that the class hierarchy would model vehicles, indicating that vehicles are an important aspect of the class."", ""Vehicles""); (""Class"", ""The class is related to drivers because the text states that the class hierarchy would model drivers, indicating that drivers are an important aspect of the class."", ""Drivers""); (""Class"", ""The class is related to storage because the text states that the class hierarchy would be tied to the storage mechanisms, indicating a connection between the class and storage."", ""Storage""); (""Class"", ""The class is related to serialization because the text states that the class hierarchy would be tied to the serialization mechanisms, indicating a connection between the class and serialization."", ""Serialization""); (""Class"", ""The class is related to mechanisms because the text states that the class hierarchy would be tied to the mechanisms used in the application, indicating a connection between the class and mechanisms."", ""Mechanisms""); (""Class"", ""The class is related to the application because the text states that the class hierarchy would be tied to the mechanisms used in the application, indicating a connection between the class and the application."", ""Application""); (""Hierarchy"", ""The hierarchy is related to vehicles because the text states that the hierarchy would model vehicles, indicating that vehicles are an important aspect of the hierarchy."", ""Vehicles""); (""Hierarchy"", ""The hierarchy is related to drivers because the text states that the hierarchy would model drivers, indicating that drivers are an important aspect of the hierarchy."", ""Drivers""); (""Hierarchy"", ""The hierarchy is related to storage because the text states that the hierarchy would be tied to the storage mechanisms, indicating a connection between the hierarchy and storage."", ""Storage""); (""Hierarchy"", ""The hierarchy is related to serialization because the text states that the hierarchy would be tied to the serialization mechanisms, indicating a connection between the hierarchy and serialization."", ""Serialization""); (""Hierarchy"", ""The hierarchy is related to mechanisms because the text states that the hierarchy would be tied to the mechanisms used in the application, indicating a connection between the hierarchy and mechanisms."", ""Mechanisms""); (""Hierarchy"", ""The hierarchy is related to the application because the text states that the hierarchy would be tied to the mechanisms used in the application, indicating a connection between the hierarchy and the application."", ""Application""); (""Vehicles"", ""The vehicles and drivers are related because they are both modeled by the class hierarchy, indicating a connection between the two."", ""Drivers""); (""Vehicles"", ""The vehicles are related to storage because the text states that the class hierarchy, which models vehicles, would be tied to the storage mechanisms, indicating a connection between vehicles and storage."", ""Storage""); (""Vehicles"", ""The vehicles are related to serialization because the text states that the class hierarchy, which models vehicles, would be tied to the serialization mechanisms, indicating a connection between vehicles and serialization."", ""Serialization""); (""Vehicles"", ""The vehicles are related to mechanisms because the text states that the class hierarchy, which models vehicles, would be tied to the mechanisms used in the application, indicating a connection between vehicles and mechanisms."", ""Mechanisms""); (""Vehicles"", ""The vehicles are related to the application because the text states that the class hierarchy, which models vehicles, would be tied to the mechanisms used in the application, indicating a connection between vehicles and the application."", ""Application""); (""Drivers"", ""The drivers are related to storage because the text states that the class hierarchy, which models drivers, would be tied to the storage mechanisms, indicating a connection between drivers and storage."", ""Storage""); (""Drivers"", ""The drivers are related to serialization because the text states that the class hierarchy, which models drivers, would be tied to the serialization mechanisms, indicating a connection between drivers and serialization."", ""Serialization""); (""Drivers"", ""The drivers are related to mechanisms because the text states that the class hierarchy, which models drivers, would be tied to the mechanisms used in the application, indicating a connection between drivers and mechanisms."", ""Mechanisms""); (""Drivers"", ""The drivers are related to the application because the text states that the class hierarchy, which models drivers, would be tied to the mechanisms used in the application, indicating a connection between drivers and the application."", ""Application""); (""Storage"", ""The storage and serialization are related because they are both mentioned as mechanisms that the class hierarchy would be tied to, indicating a connection between the two."", ""Serialization""); (""Storage"", ""The storage is related to mechanisms because the text states that the class hierarchy would be tied to the storage mechanisms, indicating a connection between storage and mechanisms."", ""Mechanisms""); (""Storage"", ""The storage is related to the application because the text states that the class hierarchy would be tied to the storage mechanisms used in the application, indicating a connection between storage and the application."", ""Application""); (""Serialization"", ""The serialization is related to mechanisms because the text states that the class hierarchy would be tied to the serialization mechanisms, indicating a connection between serialization and mechanisms."", ""Mechanisms""); (""Serialization"", ""The serialization is related to the application because the text states that the class hierarchy would be tied to the serialization mechanisms used in the application, indicating a connection between serialization and the application."", ""Application"")"
"A better solution would be to create some interfaces with the storage and serialization methods on, and let the classes implement these interfaces.","(""Interfaces"", ""Interfaces have the storage method on them, indicating a clear relationship between the two."", ""Storage""); (""Interfaces"", ""Interfaces have the serialization method on them, indicating a clear relationship between the two."", ""Serialization"")"
"When each class implements these two interfaces and their methods, you can access the methods of these interfaces by casting the objects to instances of the interface types.","(""Class"", ""A class implements interfaces, indicating a clear relationship between the class and the interfaces."", ""Interfaces""); (""Class"", ""A class implements methods, indicating a clear relationship between the class and the methods."", ""Methods""); (""Interfaces"", ""Interfaces have methods, indicating a clear relationship between the interfaces and the methods."", ""Methods""); (""Class"", ""A class has objects, indicating a clear relationship between the class and the objects."", ""Objects""); (""Objects"", ""Objects can be cast to instances of interface types, indicating a clear relationship between the objects and the interface types."", ""Interface Types"")"
"You don't need to know exactly what class a given object is of, as long as you know what interface it implements.","(""Object"", ""The object implements the interface, indicating a relationship between the two entities."", ""Interface""); (""Class"", ""A class implements an interface, establishing a clear relationship between the class and interface entities."", ""Interface"")"
"As you can probably imagine by now, interfaces provide a cleaner way of implementing cross cutting functionality in classes than inheritance.",NULL
A generic Java interface is an interface which can be typed - meaning it can be specialized to work with a specific type (e.g.,NULL
This interface represents an interface which contains a single method called produce() which can produce a single object.,NULL
"Since the return value of produce() is Object, it can return any Java object.","(""Produce"", ""The produce() method returns an Object, indicating a relationship between the two entities."", ""Object""); (""Object"", ""The Object class is part of the Java package, indicating a relationship between the two entities."", ""Java"")"
The implementation of the produce() method returns a new Car object every time it is called.,NULL
"Notice how the object returned from the carProducer.produce() method call has to be cast to a Car instance, because the produce() method return type is Object.","(""carProducer"", ""The carProducer class has a produce method, indicating a relationship between the class and the method."", ""produce""); (""produce"", ""The produce method returns an object that needs to be cast to a Car instance, indicating a relationship between the method and the class."", ""Car"")"
"Now when I implement the MyProducer interface in the CarProducer class, I have to include the generic type declaration too, like this:",NULL
"As you can see, since the generic type for the CarProducer instance is set to Car, it is no longer necessary to cast the object returned from the produce() method, since the original method declaration in the MyProducer interface states, that this method returns the same type as is specified in the generic type when used.","(""CarProducer"", ""The CarProducer class has a relationship with the produce method, as it is mentioned that the produce method is used in the context of the CarProducer instance."", ""produce""); (""MyProducer"", ""The MyProducer interface has a relationship with the produce method, as it is stated that the original method declaration is in the MyProducer interface."", ""produce""); (""CarProducer"", ""The CarProducer class has a relationship with the Car class, as the generic type for the CarProducer instance is set to Car."", ""Car"")"
But - now it is actually possible to specify another generic type for a CarProducer instance than the type it actually returns from it's produce() method implementation.,NULL
"If you scroll up, you can see that the CarProducer.produce() implementation returns a Car object no matter what generic type you specify for it when you create it.","(""CarProducer"", ""The CarProducer class has a method called produce, indicating a relationship between the class and the method."", ""produce""); (""CarProducer"", ""The CarProducer class produces a Car object, indicating a relationship between the class and the object it produces."", ""Car"")"
"Instead, you can lock down the generic type of the MyProducer interface already when you implement it, in the CarProducer class.",NULL
"As you can see, it is still not necessary to cast the object returned by produce(), as the CarProducer implementation declares that to be a Car instance.","(""CarProducer"", ""CarProducer is related to produce because it is mentioned that CarProducer implementation declares to be a Car instance returned by produce()"", ""produce""); (""CarProducer"", ""CarProducer is related to Car because CarProducer implementation declares that to be a Car instance"", ""Car"")"
A Java lambda expression is thus a function which can be created without belonging to any class.,"(""Java"", ""A Java lambda expression is thus a function which can be created without belonging to any class, indicating that Java is related to Lambda Expression as it is used to create lambda expressions"", ""Lambda Expression""); (""Lambda Expression"", ""A lambda expression is thus a function, indicating that Lambda Expression is related to Function as it is a type of function"", ""Function"")"
Imagine you have a class called StateOwner which can register state event listeners.,"(""StateOwner"", ""StateOwner has a method called register"", ""register""); (""StateOwner"", ""StateOwner can register state event listeners, implying a relationship between StateOwner and State"", ""State"")"
The lambda expression is matched against the parameter type of the addStateListener() method's parameter.,"(""Lambda Expression"", ""The lambda expression is matched against the parameter type of the addStateListener() method's parameter, indicating that the lambda expression is related to the addStateListener method."", ""AddStateListener""); (""AddStateListener"", ""The addStateListener method has a parameter, indicating that the addStateListener method is related to the parameter."", ""Parameter"")"
"For instance, the interface type of the parameter can be inferred from the method declaration of the addStateListener() method (the single method on the StateChangeListener interface).",NULL
"In the example above, the compiler can infer their type from the onStateChange() method declaration.",NULL
"Thus, the type of the parameters oldState and newState are inferred from the method declaration of the onStateChange() method.","(""OnStateChange"", ""The OnStateChange method takes OldState as a parameter, indicating a relationship between the two."", ""OldState"")"
"In this case, these parameters have to match the parameters of the onStateChange() method of the StateChangeListener interface:",NULL
Here is an example class that creates a lambda which references a static variable from inside the lambda body:,"(""Class"", ""The class creates a lambda, indicating a relationship between the class and the lambda."", ""Lambda""); (""Lambda"", ""The lambda references a static variable, indicating a relationship between the lambda and the static variable."", ""Static Variable"")"
The class primarily serves to show you that a lambda can access static variables.,NULL
"Since all the lambda body does is forward the string parameter to the System.out.println() method, we can replace the above lambda declaration with a method reference.","(""System.out.println()"", ""System.out.println() is a method of the System.out class"", ""System.out"")"
Whatever class or object that owns the referenced method comes before the double colons.,"(""Class"", ""The class is related to the method because the class owns the method, as indicated by the phrase 'owns the referenced method'."", ""Method"")"
"Since the parameters of the Finder.find() and MyClass.doFind() methods match, it is possible to create a lambda expression that implements Finder.find() and references the MyClass.doFind() method.","(""Finder.find"", ""The Finder.find() and MyClass.doFind() methods are related because they have matching parameters, allowing for the creation of a lambda expression that implements Finder.find() and references MyClass.doFind()."", ""MyClass.doFind""); (""Finder"", ""The Finder class is related to the Finder.find() method because the method is a part of the class."", ""Finder.find"")"
Here is an example of a Java lambda expression that calls String.indexOf() to search:,"(""String"", ""String is a class that has a method called indexOf"", ""indexOf""); (""Java"", ""Java is a package that contains the String class"", ""String"")"
The convertToInt() method has the same signature as the deserialize() method of the Deserializer deserialize() method.,"(""ConvertToInt"", ""The convertToInt() method has the same signature as the deserialize() method, indicating a clear relationship between the two methods."", ""Deserialize""); (""Deserialize"", ""The deserialize() method is part of the Deserializer class, indicating a clear relationship between the method and the class."", ""Deserializer"")"
"Because of that, we can create an instance of StringConverter and reference its convertToInt() method from a Java lambda expression, like this:","(""StringConverter"", ""StringConverter has a method called convertToInt(), indicating a clear relationship between the class and the method"", ""convertToInt()""); (""StringConverter"", ""StringConverter is used within a Java lambda expression, indicating a relationship between the class and the package"", ""Java"")"
Finally it is possible to reference a constructor of a class.,NULL
"You do that by writing the class name followed by ::new, like this:",NULL
The create() method of this interface matches the signature of one of the constructors in the String class.,NULL
"In Java, all instructions (code) have to be located inside a Java class.",NULL
A class is a way of grouping data and instructions that belong together.,"(""Class"", ""The class is related to the data because it is a way of grouping data and instructions that belong together."", ""Data""); (""Class"", ""The class is related to the data because it is a way of grouping data and instructions that belong together."", ""Data"")"
"Declaring a simple class without any variables, methods or any other instructions, looks like this in Java code:",NULL
This Java code needs to be located in a file with the same file name as the class and ending with the file suffix .java.,"(""Java"", ""The Java code is related to the File because the Java code needs to be located in a file."", ""File"")"
"Once the file is located in a file matching its class name and ending with .java, you can compile it with the Java compiler from the Java SDK, or from inside your Java IDE (which is much easier).","(""File"", ""The File is compiled with the Java Compiler"", ""Java Compiler""); (""Java Compiler"", ""The Java Compiler is part of the Java SDK"", ""Java SDK""); (""Java IDE"", ""The Java IDE uses the Java Compiler for compilation"", ""Java Compiler""); (""Java IDE"", ""The Java IDE is used to compile the File"", ""File"")"
It is recommended that you locate your class in a Java package.,NULL
"If you locate a Java class inside a Java package, you have to specify the package name at the top of the Java file.","(""Java class"", ""A Java class is located inside a Java package, indicating a containment relationship."", ""Java package""); (""Java class"", ""A Java class is defined inside a Java file, indicating a definition relationship."", ""Java file"")"
Here is how the class from earlier looks with a package declaration added:,NULL
Note: The file MyClass.java must now be located in the directory myjavacode and contain the package declaration package myjavacode; .,NULL
A Java program starts by executing the main method of some class.,"(""Java program"", ""A Java program starts by executing the main method of some class, indicating that the Java program is related to the main method."", ""Main method""); (""Main method"", ""The main method is a part of a Java program, indicating that the main method is related to the Java program."", ""Java program"")"
"You can choose the name of the class to execute, but not the name of the method.",NULL
Here is how the main method declaration looks when located inside the Java class declaration from earlier:,NULL
Just remember that a main() method declaration needs these three keywords.,NULL
"In the main() method example earlier I called the String array parameter args, and in the second example I called it stringArray.","(""Main"", ""The Main method uses the String class as a parameter type for the args variable."", ""String""); (""Main"", ""The Main method has a parameter named args."", ""Args""); (""Main"", ""The Main method has a parameter named stringArray which is a String array."", ""String Array""); (""String"", ""The args variable is of type String array."", ""Args"")"
"You call the java command that comes with the JRE, and tells it what Java class to execute, and what arguments to pass to the main() method.","(""Java"", ""The Java class is executed using the java command that comes with the JRE."", ""JRE""); (""Java"", ""The Java class contains the main() method that is executed."", ""main()"")"
The second and third arguments (-cp classes) tells the JVM in what directory the compiled Java classes are located (cp means class path).,"(""JVM"", ""The JVM is related to Java because it is used to run Java classes"", ""Java"")"
In this case the compiled Java classes are located in a directory named classes.,NULL
The fourth argument is the name of the Java class the JVM is to execute.,NULL
"Notice how the class name also contains the name of the package the class is located in (the ""fully qualified class name"").",NULL
You can pass arguments from the command line to the main() method.,NULL
"When the JVM executes the main() method of the myjavacode.MyClass, the String array passed as parameter to the main() method will contain two Strings: ""Hello"" and ""World"".","(""MyClass"", ""The main() method is a part of the MyClass, indicating a strong relationship between the two entities."", ""main()""); (""myjavacode"", ""The MyClass is contained within the myjavacode package, indicating a relationship of containment between the two entities."", ""MyClass""); (""JVM"", ""The JVM executes the main() method of the MyClass, indicating a relationship of execution between the two entities."", ""MyClass"")"
The main() method can access the arguments from the command line like this:,NULL
"If only a single Java class in your Java program contains a main() method, then the class containing the main() method is often referred to as the main class.","(""Java"", ""The Java class contains the main() method, indicating a relationship between the two entities."", ""main()""); (""Java program"", ""The main class is part of the Java program, indicating a relationship between the two entities."", ""main class""); (""Java"", ""The Java class is often referred to as the main class, indicating a relationship between the two entities."", ""main class"")"
You can have as many classes as you want in your project with a main() method in.,NULL
You can still call the other main() methods from inside the main() method the Java Virtual Machine executes (you haven't seen how yet) and you can also start up multiple virtual machines which each execute a single main() method.,"(""Main"", ""The Main method is executed by the Java Virtual Machine, indicating a relationship between the two entities."", ""Java Virtual Machine"")"
Therefore Java also contains the Java Math class which contains methods for performing more advanced math calculations in Java.,"(""Java"", ""Java contains the Java Math class"", ""Java Math"")"
This Java math tutorial will take a closer look at both Java's math operators as well as the Java Math class.,"(""Java Math Class"", ""The Java Math Class is part of the Java package, indicating a relationship between the two entities."", ""Java"")"
"The result of this division would be 12.5 , but since the two numbers are integers, the .5 fraction is cut off.",NULL
"Even though the result variable is now a floating point type (double), the final result is still just 12 instead of 12.5 .",NULL
Now the result variable would end up with the value 12.5.,NULL
"The first System.out.println() statement correctly prints the value 0.0 , which is the start value of the the resultDbl3 variable.","(""System"", ""System is a class that contains the out class"", ""out""); (""out"", ""out is a class that contains the println method"", ""println""); (""System"", ""System is a class that contains the out class which contains the println method"", ""println"")"
"Adding the value 0.01 to 0 a total of 100 times should result in the value 1.0, right?",NULL
The Java Math class provides more advanced mathematical calculations than what the basic Java math operators provide.,NULL
"The Math class contains methods for finding the maximum or minimum of two values, rounding values, logarithmic functions, square root, and trigonometric functions (sin, cos, tan etc.","(""Math"", ""The Math class contains the maximum method"", ""maximum""); (""Math"", ""The Math class contains the minimum method"", ""minimum""); (""Math"", ""The Math class contains the rounding method"", ""rounding""); (""Math"", ""The Math class contains the logarithmic method"", ""logarithmic""); (""Math"", ""The Math class contains the square root method"", ""square root""); (""Math"", ""The Math class contains the sin method"", ""sin""); (""Math"", ""The Math class contains the cos method"", ""cos"")"
"The Math is located in the java.lang package, and not in the java.math package.","(""Math"", ""The Math class is located in the java.lang package, indicating a containment relationship."", ""java.lang"")"
"Thus, the fully qualified class name of the Math class is java.lang.Math .","(""Math"", ""The Math class is contained within the java.lang package, as indicated by the fully qualified class name java.lang.Math."", ""java.lang""); (""java.lang.Math"", ""The fully qualified class name java.lang.Math indicates that the class java.lang.Math is part of the java.lang package."", ""java.lang"")"
"Since many of the functions of the Math class are independent from each other, each method will be explained in its own section below.",NULL
"The java.lang.Math contains a set of basic math functions for obtaining the absolute value, highest and lowest of two values, rounding of values, random values etc.","(""Java.Lang.Math"", ""Java.Lang.Math contains the Absolute Value method"", ""Absolute Value""); (""Java.Lang.Math"", ""Java.Lang.Math contains the Highest method"", ""Highest""); (""Java.Lang.Math"", ""Java.Lang.Math contains the Lowest method"", ""Lowest""); (""Java.Lang.Math"", ""Java.Lang.Math contains the Rounding method"", ""Rounding"")"
These basic math functions of the Java Math class will be covered in the following sections.,"(""Java Math Class"", ""The Java Math Class is related to the math functions because it is stated that the math functions are part of the Java Math Class"", ""Math functions""); (""Java Math Class"", ""The Java Math Class contains the math functions, indicating a relationship between the class and its methods"", ""Math functions"")"
The Math.abs() function returns the absolute value of the parameter passed to it.,NULL
Which of these methods are called depends on the type of the parameter passed to the Math.abs() method.,"(""Math"", ""Math.abs is a method of the Math class, indicating a clear relationship between the two entities."", ""Math.abs""); (""Math.abs"", ""The Math.abs method is a part of the Math class, showing a relationship where Math.abs belongs to Math."", ""Math""); (""Math.abs()"", ""The method Math.abs() is called on the class Math, establishing a relationship between the method and its class."", ""Math"")"
The Math.ceil() function rounds a floating point value up to the nearest integer value.,NULL
After executing this Java code the ceil variable will contain the value 8.0 .,"(""Java"", ""The Java code is being executed, indicating a relationship between the Java class and the code method."", ""code"")"
The Math.floor() function rounds a floating point value down to the nearest integer value.,NULL
After executing this Java code the floor variable will contain the value 7.0 .,NULL
"The Math.floorDiv() method divides one integer (int or long) by another, and rounds the result down to the nearest integer value.",NULL
"The floorDiv() method rounds down to the nearest negative integer, instead of the rounding up that would occur with fraction truncation.",NULL
This shows the difference between the / division operator and Math.floorDiv() .,"(""Math"", ""Math is a class that contains the floorDiv method, indicating a clear relationship between the two entities as the method is part of the class""}"", ""floorDiv"")"
The Math.min() method returns the smallest of two values passed to it as parameter.,NULL
The Math.max() method returns the largest of two values passed to it as parameter.,NULL
The Math.round() method rounds a float or double to the nearest integer using normal math round rules (either up or down).,NULL
"After executing these two Java statements the roundedDown variable will contain the value 23.0 , and the roundedUp variable will contain the value 24.0.",NULL
The Math.random() method returns a random floating point number between 0 and 1.,NULL
"100, multiply the value returned by Math.random() with the maximum number (e.g.",NULL
"If you need an integer value, use the round(), floor() or ceil() method.","(""ROUND"", ""Both ROUND and FLOOR are related as they are mentioned together as methods to obtain an integer value."", ""FLOOR""); (""ROUND"", ""Both ROUND and CEIL are related as they are mentioned together as methods to obtain an integer value."", ""CEIL"")"
The Java Math class also contains a set of functions intended for exponential and logarithmic calculations.,"(""Math"", ""The Java Math class indicates a relationship between the Math class and the Java package, as Math is part of the Java package."", ""Java"")"
The Math.exp() function returns e (Euler's number) raised to the power of the value provided as parameter.,NULL
The Math.log10 method works like the Math.log() method except is uses 10 as is base for calculating the logarithm instead of e (Euler's Number).,NULL
"In other words, the Math.pow() example calculate the values of 22 and 28 which are 4 and 256.",NULL
The Math.sqrt() method calculates the square root of the parameter given to it.,NULL
"If you are looking for a trigonometric function and you cannot find it here, check the JavaDoc for the Java Math class.",NULL
"The Math class just might have the function you are looking for, even if I have not described it here.",NULL
The Math.PI constant is a double with a value that is very close to the value of PI - the mathematical definition of PI.,NULL
You will often need the Math.PI field when making trigonometric calculations.,NULL
The Math.sin() method calculates the sine value of some angle value in radians.,NULL
The Math.cos() method calculates the cosine value of some angle value in radians.,NULL
The Math.tan() method calculates the tangens value of some angle value in radians.,NULL
The Math.asin() method calculates the arc sine value of a value between 1 and -1.,NULL
The Math.acos() method calculates the arc cosine value of a value between 1 and -1.,NULL
The Math.atan() method calculates the arc tangens value of a value between 1 and -1.,NULL
The Math.sinh() method calculates the hyperbolic sine value of a value between 1 and -1.,NULL
The Math.cosh() method calculates the hyperbolic cosine value of a value between 1 and -1.,NULL
The Math.tanh() method calculates the hyperbolic tangens value of a value between 1 and -1.,NULL
Java methods are similar to what is called functions or procedures in other programming languages (e.g.,"(""Java"", ""Java has methods"", ""Methods""); (""Methods"", ""Methods are similar to functions"", ""Functions"")"
The example above defines a method called writeText inside a class named MyClass.,NULL
You can use any primitive data type or built-in Java class as data type for parameters.,"(""Java"", ""Java is related to Parameters because Java is the programming language used to define the parameters."", ""Parameters""); (""Java"", ""Java is related to Data Type because Java has built-in data types that can be used as parameters."", ""Data Type"")"
"When the above Java code is executed, the writeText() method will get executed, and the parameters will contain the values ""Hello"" and ""World"".",NULL
"But, instead of returning to where the method was called from, the execution is resumed inside the first catch() { } clause surrounding the method, targeted at that exception.","(""Catch"", ""The catch class is related to the method because it surrounds the method and is targeted at the exception that occurs within it."", ""Method""); (""Method"", ""The method is related to the exception because the exception occurs within the method, causing the execution to be resumed inside the catch clause."", ""Exception"")"
"Notice how the method callSum() creates a variable called theSum, and assigns it the value returned by the add(1, 3) method call.","(""CallSum"", ""The CallSum method creates a variable called TheSum and assigns it the value returned by the Add method call."", ""TheSum""); (""CallSum"", ""The CallSum method calls the Add method to calculate the sum."", ""Add"")"
Before Java 9 and the Java Platform Module System you would have had to package all of the Java Platform APIs with your Java application because there was no official way of reliably checking what classes your Java application used.,"(""Java 9"", ""Java 9 is related to Java Platform Module System because they are both mentioned together as a significant change in the Java ecosystem"", ""Java Platform Module System""); (""Java Platform Module System"", ""Java Platform Module System is related to Java Platform APIs because the module system provides a way to package and manage the Java Platform APIs"", ""Java Platform APIs""); (""Java application"", ""Java application is related to Java Platform APIs because the application would have had to package all of the Java Platform APIs with it before Java 9"", ""Java Platform APIs""); (""Java 9"", ""Java 9 is related to Java application because Java 9 introduced a change that affects how Java applications are packaged and managed"", ""Java application"")"
"Since the Java Platform APIs have grown quite large over the years, your application would get a large amount of Java classes included in its distribution, many of which your application would probably not be using.","(""Java Platform APIs"", ""The Java Platform APIs include a large number of Java classes, indicating a relationship between the two entities."", ""Java classes""); (""Java classes"", ""The application includes Java classes in its distribution, indicating a relationship between the two entities."", ""application"")"
The unused classes makes your application distributable bigger than it needs to be.,NULL
from a missing JAR file) would not be detected until the application actually tried to use the missing class.,"(""JAR"", ""The JAR entity is related to the CLASS entity because a JAR file typically contains compiled classes."", ""CLASS""); (""APPLICATION"", ""The APPLICATION entity is related to the CLASS entity because an application uses classes."", ""CLASS"")"
This would happen sometime at runtime - depending on when the application tried to use the missing class.,NULL
Having missing modules reported at application startup time is a big advantage compared to at runtime when trying to use the missing module / JAR / class.,"(""MODULE"", ""The module is related to the application because it is used by the application at startup time."", ""APPLICATION""); (""JAR"", ""The JAR is related to the application because it is a type of module used by the application."", ""APPLICATION""); (""MODULE"", ""The module is related to the JAR because a JAR can contain a module."", ""JAR""); (""STARTUP"", ""The startup method is related to the application because it is the time when the application starts."", ""APPLICATION""); (""RUNTIME"", ""The runtime method is related to the application because it is the time when the application is running."", ""APPLICATION"")"
"However, you should not use underscores (_) in module names (or package names, class names, method names, variable names etc.)","(""Module"", ""Both module and package names should not use underscores"", ""Package""); (""Module"", ""Both module and class names should not use underscores"", ""Class""); (""Module"", ""Both module and method names should not use underscores"", ""Method""); (""Package"", ""Both package and class names should not use underscores"", ""Class""); (""Package"", ""Both package and method names should not use underscores"", ""Method"")"
"Before Java 9 all Java classes for an application or API were nested directly inside a root class directory (which was added to the classpath), or directly inside a JAR file.","(""Java"", ""Java 9 is a version of Java, indicating a relationship between the two entities as Java 9 is a subset of Java"", ""Java 9""); (""Java"", ""Java classes can be packaged in a JAR file, indicating a relationship between Java and JAR"", ""JAR""); (""Java"", ""Java classes are added to the classpath, indicating a relationship between Java and classpath"", ""classpath""); (""Java"", ""Java classes can be nested directly inside a root class directory, indicating a relationship between Java and root class directory"", ""root class directory""); (""Java"", ""Java classes can be part of an API, indicating a relationship between Java and API"", ""API""); (""Java"", ""Java classes can be part of an application, indicating a relationship between Java and application"", ""application""); (""JAR"", ""A JAR file is added to the classpath, indicating a relationship between JAR and classpath"", ""classpath""); (""root class directory"", ""The root class directory is added to the classpath, indicating a relationship between root class directory and classpath"", ""classpath""); (""API"", ""An API can be part of an application, indicating a relationship between API and application"", ""application"")"
The module root directory is used both for the source files and compiled classes of a Java module.,"(""Module"", ""The module uses the root directory for its files and classes, indicating a relationship between the two."", ""Root Directory""); (""Module"", ""The module is a part of the Java system, indicating a relationship between the two."", ""Java"")"
Each Java module needs a Java module descriptor named module-info.java which has to be located in the corresponding module root directory.,"(""Java"", ""Java is related to Java Module because Java is the programming language used for Java Module."", ""Java Module""); (""Java Module"", ""Java Module is related to Module because a Java module is an instance of a Module."", ""Module""); (""Module"", ""Module is related to Module Descriptor because a Module has a Module Descriptor."", ""Module Descriptor""); (""Module"", ""Module is related to Module Root Directory because a Module is located in a Module Root Directory."", ""Module Root Directory""); (""Module Descriptor"", ""Module Descriptor is related to Module-Info because Module-Info is an instance of a Module Descriptor."", ""Module-Info"")"
Notice also how the module descriptor is suffixed .java and yet it uses a hyphen in the file name (module-info.java).,"(""Module"", ""Module is related to Module-Info because Module-Info seems to be a part of the module."", ""Module-Info""); (""Module"", ""Module is related to Module-Descriptor because the module descriptor is a part of the module."", ""Module-Descriptor""); (""Module-Info"", ""Module-Info is related to File because module-info.java is a file."", ""File""); (""Module-Descriptor"", ""Module-Descriptor is related to File because the module descriptor is suffixed .java and is a file."", ""File""); (""Module-Info.Java"", ""Module-Info.Java is related to Module because module-info.java is part of the module."", ""Module"")"
"Hyphens are not normally allowed in Java class names, but in module descriptor file names they are required!","(""Java"", ""Java and Module Descriptor are related because they are both mentioned in the context of class names and module descriptor file names, indicating a connection between Java classes and module descriptors"", ""Module Descriptor""); (""Java"", ""Java is related to itself as it is mentioned as a programming language with specific rules for class names"", ""Java"")"
This example module descriptor declares that it requires the standard Java module named javafx.graphics.,"(""Example"", ""The Example module descriptor is related to the Module because it declares that it requires the standard Java module."", ""Module""); (""Module"", ""The Module is related to Java because it requires the standard Java module."", ""Java""); (""Java"", ""Java is related to JavaFX because JavaFX is a package of Java."", ""JavaFX""); (""JavaFX"", ""JavaFX is related to Graphics because Graphics is a package of JavaFX."", ""Graphics""); (""Example"", ""The Example module is related to the Descriptor because the Descriptor declares that it requires the standard Java module."", ""Descriptor"")"
By split package is meant that the total content (classes) of the package is split between multiple modules.,"(""Package"", ""The package contains classes, as indicated by the phrase 'total content (classes) of the package'"", ""Classes""); (""Package"", ""The package is split between multiple modules, indicating a relationship between the package and the modules"", ""Modules"")"
"Inside that directory you will find a directory with the name of the module, and inside that directory you will find the compiled classes plus a compiled version of the module-info.java module descriptor named module-info.class.","(""Module"", ""The Module and Module-Info.Class are related because Module-Info.Class is a compiled version of the module descriptor for the Module."", ""Module-Info.Class""); (""Module-Info.Java"", ""The Module-Info.Java and Module-Info.Class are related because Module-Info.Class is a compiled version of Module-Info.Java."", ""Module-Info.Class"")"
"In order to run the main class of a Java module you use the java command, like this:","(""Java"", ""The Java command is used to run the main class of a Java module"", ""Main""); (""Java"", ""The Java command is a part of the Java package"", ""Java"")"
The --module argument tells what module + main class to run.,NULL
Notice how the module name and main class name are separated by a slash (/) character.,NULL
You can still set the JAR main class when generating the module JAR file.,"(""JAR"", ""The JAR and Module are related because the text mentions generating the module JAR file, indicating a connection between the two."", ""Module"")"
Here is an example of setting the main class of a Java module JAR file:,"(""Java"", ""Java is related to JAR because JAR is a file type used in Java programming"", ""JAR""); (""Java module"", ""Java module is related to Java because a Java module is a part of the Java ecosystem"", ""Java"")"
You can now run the main class of this JAR file with a shortcut.,NULL
Here is how you run the main class from a Java module JAR file:,"(""Main"", ""The Main class is run from a Java module, indicating a relationship between the Main class and the Java package."", ""Java""); (""Main"", ""The Main class is run from a JAR file, indicating a relationship between the Main class and the JAR package."", ""JAR"")"
"If the Java module JAR file has a main class set (see a few sections earlier in this tutorial for how to do that), you can run the Java module main class with a little shorter command line.","(""Java"", ""The Java module is related to Java because it is a Java module, indicating a connection between the two entities."", ""Java module""); (""Java module"", ""The Java module is related to the main class because the main class is part of the Java module, indicating a connection between the two entities."", ""main class""); (""JAR"", ""The JAR file is related to the Java module because the Java module is packaged in the JAR file, indicating a connection between the two entities."", ""Java module""); (""Java"", ""Java is related to the main class because the main class is a Java class, indicating a connection between the two entities."", ""main class"")"
Here is an example of running a Java module from a JAR file with a main class set:,"(""Java"", ""Java is related to JAR because Java modules can be packaged into JAR files"", ""JAR""); (""Java"", ""Java is related to Main because the main class is the entry point for a Java application"", ""Main"")"
The --module argument specifies which module plus main class to run.,NULL
"From Java 9 and forward, all Java classes must be located in a module for the Java VM to use them.","(""Java"", ""Java classes are used by the Java VM"", ""Java VM""); (""Java 9"", ""Java 9 is a version of Java that requires classes to be in a module"", ""Java""); (""Java"", ""Java classes are used by the Java VM"", ""Java VM""); (""Java 9"", ""Java 9 is a version of Java that requires classes to be in a module"", ""Java""); (""Java VM"", ""The Java VM uses classes from Java 9 and forward"", ""Java 9"")"
"But what do you do with older Java libraries where you just have the compiled classes, or a JAR file?","(""Java"", ""Java is related to libraries because libraries are often written in Java"", ""libraries""); (""JAR"", ""JAR files are a type of package used to distribute Java libraries"", ""libraries"")"
In Java 9 you can still use the -classpath argument to the Java VM when running an application.,"(""Java"", ""Java is related to Java VM as it is the platform where Java VM is used"", ""Java VM""); (""Java"", ""Java is related to Java 9 as Java 9 is a version of Java"", ""Java 9""); (""Java VM"", ""Java VM is related to -classpath as -classpath is an argument to the Java VM"", ""-classpath""); (""Java"", ""Java is related to application as Java is used to run an application"", ""application""); (""Java 9"", ""Java 9 is related to application as Java 9 is used to run an application"", ""application"")"
"On the classpath you can include all your older Java classes, just like you have done before Java 9.","(""Classpath"", ""The classpath is related to Java because it is used to include Java classes."", ""Java""); (""Java"", ""Java and Java 9 are related because Java 9 is a version of Java."", ""Java 9"")"
All classes found on the classpath will be included in what Java calls the unnamed module.,"(""Classpath"", ""The Classpath and Java are related because Java uses the classpath to include classes in the unnamed module."", ""Java""); (""Java"", ""Java and the Unnamed Module are related because Java calls the collection of included classes the unnamed module."", ""Unnamed Module"")"
"However, the classes in the unnamed module are only readable by other classes in the unnamed module - or from automatic modules (see next section).","(""Classes"", ""The classes are part of the unnamed module and are only readable by other classes in the same module"", ""Unnamed Module""); (""Unnamed Module"", ""The unnamed module's classes are also readable from automatic modules, indicating a relationship between the unnamed module and automatic modules"", ""Automatic Modules"")"
No named module can read the classes of the unnamed module.,"(""Module"", ""The module is related to classes because it is mentioned that no named module can read the classes of the unnamed module, indicating a connection between modules and classes."", ""Classes""); (""Named Module"", ""The named module and the unnamed module are related because they are both types of modules, and the text contrasts the ability of named modules to read classes from the unnamed module."", ""Unnamed Module"")"
All classes in the unnamed module requires all modules found on the module path.,"(""Classes"", ""The classes are part of the unnamed module, indicating a relationship between the two."", ""Module""); (""Module"", ""The unnamed module requires all modules found on the module path, indicating a relationship between the module and the module path."", ""Module Path"")"
"That way, all classes in the unnamed module can read all classes exported by all the Java modules found on the module path.","(""Classes"", ""Classes are part of the unnamed module, which implies a relationship between them"", ""Module""); (""Classes"", ""Classes in the unnamed module can read classes exported by Java modules, indicating a relationship between them"", ""Java Modules""); (""Module"", ""The unnamed module and Java modules are related as they are both part of the module system"", ""Java Modules""); (""Java Modules"", ""Java modules are found on the module path, which establishes a relationship between them"", ""Module Path"")"
"While you can include the third party library on the classpath and thus include it in the unnamed module, your own named modules cannot use it, because named modules cannot read classes from the unnamed module.","(""Module"", ""The module is related to the classpath because named modules cannot read classes from the unnamed module, which is included in the classpath."", ""Classpath""); (""Module"", ""The module is related to the library because named modules cannot use the library when it is included in the unnamed module."", ""Library"")"
"An automatic module is made from a JAR file with Java classes that are not modularized, meaning the JAR file has no module descriptor.","(""JAR file"", ""The JAR file contains Java classes"", ""Java classes""); (""JAR file"", ""The JAR file has no module descriptor"", ""module descriptor"")"
When you place an ordinary JAR file on the module path (not the classpath) the Java VM will convert it to an automatic module at runtime.,"(""JAR"", ""The JAR file is converted to an automatic module by the Java VM at runtime, indicating a relationship between the two entities."", ""Java VM""); (""JAR"", ""The JAR file is placed on the module path, indicating a relationship between the JAR file and the module path."", ""module path""); (""JAR"", ""The JAR file is distinguished from being on the classpath, indicating a relationship between the JAR file and the classpath."", ""classpath""); (""Java VM"", ""The Java VM converts the JAR file to an automatic module when it is on the module path, indicating a relationship between the Java VM and the module path."", ""module path"")"
"If your application contains multiple automatic modules, each automatic module can read the classes of all other automatic modules.","(""Application"", ""The application contains multiple automatic modules, indicating a relationship between the two."", ""Automatic Module""); (""Automatic Module"", ""Each automatic module can read the classes of all other automatic modules, showing a relationship between automatic modules and classes."", ""Classes"")"
This is different from explicitly named modules (real Java modules) which cannot read classes in the unnamed module.,NULL
"An automatic module exports all its packages, so all named modules on the module path can use the classes of an automatic module.","(""Automatic Module"", ""An automatic module exports all its packages, so it has classes that can be used by other modules."", ""Classes""); (""Module Path"", ""Named modules are on the module path, which implies a relationship between the module path and the named modules."", ""Named Modules""); (""Automatic Module"", ""An automatic module is on the module path, so there is a relationship between the automatic module and the module path."", ""Module Path"")"
"If a JAR file contains versioning in its file name, e.g.",NULL
"The service interface is typically located in a service interface Java module which only contains the service interface, plus any classes and interfaces related to the service interface.","(""Service Interface"", ""The service interface is typically located in a service interface Java module, indicating a clear relationship between the two entities."", ""Service Interface Java Module""); (""Java Module"", ""The Java module is related to the Service Interface Java Module as it is mentioned in the context of containing the service interface, indicating a relationship between the two entities."", ""Service Interface Java Module"")"
The com folder at the root level of the JAR file contains the compiled Java classes for pre Java 9 versions.,"(""Com"", ""The com folder contains the compiled Java classes"", ""Java""); (""Com"", ""The com folder is at the root level of the JAR file"", ""Jar"")"
Earlier versions of Java do not understand multi Java version JAR files so they use the classes found here.,"(""Java"", ""Java uses JAR files to package its classes"", ""JAR""); (""Java"", ""Java has different versions that may or may not understand multi Java version JAR files"", ""Java version"")"
The META-INF directory contains the MANIFEST.MF file and a directory named versions.,"(""META-INF"", ""The META-INF directory contains the MANIFEST.MF file, indicating a relationship between the two as the MANIFEST.MF file is located within the META-INF directory."", ""MANIFEST.MF""); (""META-INF"", ""The META-INF directory contains a directory named versions, indicating a relationship between the two as the versions directory is located within the META-INF directory."", ""versions"")"
The MANIFEST.MF file needs a special entry that marks the JAR file as a multi version JAR file.,NULL
The versions directory which can contain the compiled classes for different versions of Java for your module.,"(""Versions"", ""The versions directory contains compiled classes for different versions of Java"", ""Java""); (""Versions"", ""The versions directory is for your module"", ""Module"")"
"Upgrading utility libraries first to automatic modules, and later to full modules, starting at the bottom of the dependency hierarchy should assure that your libraries can still read each other during upgrade, plus be readable by the main applications on the classpath in the unnamed module or as an automatic or named module.","(""Utility Libraries"", ""Utility libraries are part of the dependency hierarchy, which is used to determine the order of upgrade to assure compatibility."", ""Dependency Hierarchy""); (""Utility Libraries"", ""Utility libraries need to be readable by the main applications during and after the upgrade process."", ""Main Applications""); (""Main Applications"", ""Main applications are located on the classpath, which can contain unnamed, automatic, or named modules."", ""Classpath""); (""Utility Libraries"", ""Utility libraries are first upgraded to automatic modules to ensure compatibility and readability."", ""Automatic Modules""); (""Automatic Modules"", ""Automatic modules are later upgraded to full modules as part of the upgrade process."", ""Full Modules""); (""Unnamed Module"", ""The unnamed module is part of the classpath, which also contains automatic and named modules."", ""Classpath""); (""Named Module"", ""Named modules are part of the classpath, along with the unnamed module and automatic modules."", ""Classpath""); (""Full Modules"", ""Full modules can be considered a type of named module, as they are explicitly defined and named."", ""Named Module"")"
In Java nested classes are classes that are defined inside another class.,"(""Nested Classes"", ""Nested Classes are defined inside Another Class, indicating a containment relationship between the two classes"", ""Another Class""); (""Java"", ""Java is the programming language in which Nested Classes are used, indicating a usage relationship between Java and Nested Classes"", ""Nested Classes"")"
"The purpose of a nested class is to clearly group the nested class with its surrounding class, signaling that these two classes are to be used together.",NULL
Or perhaps that the nested class is only to be used from inside its enclosing (owning) class.,NULL
"Java developers often refer to nested classes as inner classes, but inner classes (non-static nested classes) are only one out of several different types of nested classes in Java.","(""Java"", ""Java has nested classes"", ""Nested Classes""); (""Nested Classes"", ""Nested classes include inner classes"", ""Inner Classes"")"
In Java nested classes are considered members of their enclosing class.,"(""Nested Classes"", ""Nested classes are considered members of their enclosing class, indicating a containment relationship between the two."", ""Enclosing Class""); (""Java"", ""Java supports the concept of nested classes, indicating a language-feature relationship between the two."", ""Nested Classes"")"
"Thus, a nested class can be declared public, package (no access modifier), protected and private (see access modifiers for more info).","(""Nested Class"", ""A nested class can be declared with access modifiers such as public, package, protected, and private."", ""Access Modifiers""); (""Public"", ""Public is an access modifier that can be used to declare a nested class."", ""Nested Class""); (""Package"", ""Package is an access modifier that can be used to declare a nested class, which means it has no access modifier."", ""Nested Class""); (""Protected"", ""Protected is an access modifier that can be used to declare a nested class."", ""Nested Class"")"
Therefore nested classes in Java can also be inherited by subclasses as explained in my tutorial about Java inheritance.,"(""Java"", ""Java has nested classes which can be inherited by subclasses"", ""Nested Classes""); (""Java"", ""Java subclasses can inherit nested classes"", ""Subclasses""); (""Nested Classes"", ""Nested classes in Java can be inherited by subclasses"", ""Subclasses""); (""Java Inheritance"", ""Java inheritance is explained in the tutorial about Java"", ""Java""); (""Java Inheritance"", ""The tutorial about Java inheritance explains how nested classes are inherited"", ""Nested Classes"")"
You can create several different types of nested classes in Java.,NULL
All these types of nested classes will be covered in the following sections.,"(""classes"", ""classes are related to sections because they are covered in the following sections"", ""sections""); (""types"", ""types are related to classes because types of nested classes are being discussed"", ""classes"")"
"In order to create an instance of the Nested class you must reference it by prefixing it with the Outer class name, like this:",NULL
In Java a static nested class is essentially a normal class that has just been nested inside another class.,"(""Java"", ""Java contains a Static Nested Class, which is a type of class"", ""Static Nested Class"")"
"Being static, a static nested class can only access instance variables of the enclosing class via a reference to an instance of the enclosing class.","(""Static Nested Class"", ""A static nested class is related to the enclosing class because it can only access instance variables of the enclosing class via a reference to an instance of the enclosing class."", ""Enclosing Class""); (""Static Nested Class"", ""A static nested class is related to instance variables because it can access them, but only via a reference to an instance of the enclosing class."", ""Instance Variables""); (""Enclosing Class"", ""An enclosing class is related to instance variables because they are part of the class."", ""Instance Variables""); (""Reference"", ""A reference is related to the enclosing class because it is used to access an instance of the enclosing class."", ""Enclosing Class""); (""Reference"", ""A reference is related to instance variables because it is used to access them."", ""Instance Variables"")"
Inner classes are associated with an instance of the enclosing class.,NULL
"Thus, you must first create an instance of the enclosing class to create an instance of an inner class.",NULL
Here is how you create an instance of the Inner class:,NULL
Notice how you put new after the reference to the outer class in order to create an instance of the inner class.,NULL
"Non-static nested classes (inner classes) have access to the fields of the enclosing class, even if they are declared private.","(""Non-static nested classes"", ""Non-static nested classes have access to the fields of the enclosing class, indicating a relationship between the two classes"", ""enclosing class""); (""Non-static nested classes"", ""Non-static nested classes have access to the fields, indicating a relationship between the classes and their fields"", ""fields"")"
Notice how the printText() method of the Inner class references the private text field of the Outer class.,"(""Inner"", ""The Inner class is related to the Outer class because it references the private text field of the Outer class."", ""Outer""); (""printText()"", ""The printText() method is related to the Inner class because it is a method of the Inner class."", ""Inner"")"
"If a Java inner class declares fields or methods with the same names as field or methods in its enclosing class, the inner fields or methods are said to shadow over the outer fields or methods.","(""Java"", ""Java is the programming language in which the inner class is defined"", ""Inner Class""); (""Inner Class"", ""An inner class is enclosed within another class, hence they are related"", ""Enclosing Class""); (""Inner Class"", ""The inner class declares fields, hence they are related"", ""Fields""); (""Inner Class"", ""The inner class declares methods, hence they are related"", ""Methods""); (""Enclosing Class"", ""The enclosing class has fields that can be shadowed by the inner class fields"", ""Fields"")"
In the above example both the Outer and Inner class contains a field named text.,"(""Outer"", ""Both Outer and Inner classes contain a field named text, indicating a relationship between the two classes."", ""Inner""); (""Outer"", ""The Outer class contains a field named text, indicating a relationship between the Outer class and the text field."", ""text""); (""Inner"", ""The Inner class contains a field named text, indicating a relationship between the Inner class and the text field."", ""text"")"
When the Inner class refers to text it refers to its own field.,NULL
"Java makes it possible though, for the Inner class to refer to the text field of the Outer class.","(""Inner class"", ""The Inner class is related to the Outer class because it can refer to the text field of the Outer class."", ""Outer class""); (""Inner class"", ""The Inner class is related to Java because Java makes it possible for the Inner class to refer to the text field of the Outer class."", ""Java"")"
To do so it has to prefix the text field reference with Outer.this.,NULL
Now the Inner.printText() method will print both the Inner.text and Outer.text fields.,"(""Inner"", ""The Inner class contains the printText method, indicating a relationship between the two."", ""printText""); (""printText"", ""The printText method is described as printing the Inner.text field, indicating a relationship between the two."", ""Inner.text""); (""printText"", ""The printText method is also described as printing the Outer.text field, indicating a relationship between the two."", ""Outer.text""); (""Inner"", ""The Inner class contains the Inner.text field, indicating a relationship between the two."", ""Inner.text"")"
Local classes in Java are like inner classes (non-static nested classes) that are defined inside a method or scope block ({ ... }) inside a method.,"(""Local"", ""Local classes are defined inside a method or scope block inside a method, indicating a clear relationship between Local classes and methods."", ""Method""); (""Inner"", ""Inner classes are defined inside a method or scope block inside a method, indicating a clear relationship between Inner classes and methods."", ""Method""); (""Local"", ""Local classes are compared to Inner classes, indicating a clear relationship between Local classes and Inner classes."", ""Inner""); (""Java"", ""Local classes are defined in Java, indicating a clear relationship between Java and Local classes."", ""Local"")"
Local classes can only be accessed from inside the method or scope block in which they are defined.,"(""Local classes"", ""Local classes are related to method because they can only be accessed from inside the method or scope block in which they are defined."", ""method"")"
Local classes can access members (fields and methods) of its enclosing class just like regular inner classes.,"(""Local classes"", ""Local classes can access members of its enclosing class, indicating a relationship between the two."", ""enclosing class""); (""Local classes"", ""Local classes can access members, indicating that Local classes have a relationship with members."", ""members""); (""Local classes"", ""Local classes can access fields, which are a type of member, indicating a relationship between Local classes and fields."", ""fields""); (""Local classes"", ""Local classes can access methods, which are a type of member, indicating a relationship between Local classes and methods."", ""methods""); (""regular inner classes"", ""Regular inner classes are compared to Local classes in terms of access to members of the enclosing class, indicating a relationship between regular inner classes and the enclosing class."", ""enclosing class""); (""members"", ""Members are accessed by Local classes from the enclosing class, indicating a relationship between members and the enclosing class."", ""enclosing class""); (""fields"", ""Fields are a type of member accessed by Local classes from the enclosing class, indicating a relationship between fields and the enclosing class."", ""enclosing class"")"
"Local classes can also access local variables inside the same method or scope block, provided these variables are declared final.","(""Local classes"", ""Local classes can access local variables inside the same method, indicating a relationship between local classes and methods."", ""Method""); (""Local classes"", ""Local classes can access local variables, indicating a relationship between local classes and local variables."", ""Local variables""); (""Local classes"", ""Local classes can access local variables inside the same scope block, indicating a relationship between local classes and scope blocks."", ""Scope block""); (""Method"", ""Local variables can be accessed inside a method, indicating a relationship between methods and local variables."", ""Local variables""); (""Scope block"", ""Local variables can be accessed inside a scope block, indicating a relationship between scope blocks and local variables."", ""Local variables"")"
From Java 8 local classes can also access local variables and parameters of the method the local class is declared in.,"(""Local Classes"", ""Local classes are declared inside a method and can access its local variables and parameters"", ""Method""); (""Local Classes"", ""Local classes can access local variables of the method they are declared in"", ""Local Variables""); (""Local Classes"", ""Local classes can access parameters of the method they are declared in"", ""Parameters""); (""Method"", ""A method has local variables that can be accessed by local classes"", ""Local Variables"")"
In that case the local class only has access to the static parts of the enclosing class.,NULL
"Local classes cannot contain all kinds of static declarations (constants are allowed - variables declared static final), because local classes are non-static in nature - even if declared inside a static method.","(""Local classes"", ""Local classes are related to static method because they are declared inside a static method"", ""static method""); (""Local classes"", ""Local classes are related to static declarations because they cannot contain all kinds of static declarations"", ""static declarations""); (""static declarations"", ""Static declarations are related to constants because constants are allowed in local classes"", ""constants"")"
The same shadowing rules apply for local classes as for inner classes.,NULL
Anonymous classes in Java are nested classes without a class name.,"(""Anonymous"", ""Anonymous classes are a type of Java class"", ""Java""); (""Anonymous"", ""Anonymous classes are a type of nested class"", ""nested classes"")"
"They are typically declared as either subclasses of an existing class, or as implementations of some interface.","(""Class"", ""Subclasses are a type of Class, indicating a clear inheritance relationship between the two entities."", ""Subclasses""); (""Class"", ""Classes can implement Interfaces, establishing a relationship where a Class is an implementation of an Interface."", ""Interface"")"
Here is an example that declares an anonymous subclass of a superclass called SuperClass:,NULL
Running this Java code would result in Anonymous class doIt() being printed to System.out.,"(""Anonymous Class"", ""Anonymous class contains the method doIt()"" "", ""DoIt""); (""Java"", ""Java is the programming language in which the Anonymous class is written"" "", ""Anonymous Class""); (""Java"", ""Java is the programming language that uses System.out for printing output"" "", ""System.out""); (""DoIt"", ""The method doIt() is being printed to System.out"" "", ""System.out"")"
The anonymous class subclasses (extends) SuperClass and overrides the doIt() method.,"(""SuperClass"", ""The doIt() method is overridden in the anonymous class that subclasses SuperClass, indicating a relationship between SuperClass and the doIt() method."", ""doIt()""); (""anonymous class"", ""The anonymous class subclasses (extends) SuperClass, indicating a relationship between the anonymous class and SuperClass."", ""SuperClass""); (""anonymous class"", ""The anonymous class overrides the doIt() method, indicating a relationship between the anonymous class and the doIt() method."", ""doIt()"")"
A Java anonymous class can also implement an interface instead of extending a class.,"(""Java"", ""An anonymous class is a type of Java class"", ""anonymous class""); (""anonymous class"", ""An anonymous class can implement an interface"", ""interface"")"
"As you can see, an anonymous class implementing an interface is pretty similar to an anonymous class extending another class.",NULL
"You can declare fields and methods inside an anonymous class, but you cannot declare a constructor.","(""Anonymous Class"", ""An anonymous class can declare fields inside it, indicating a containment relationship"", ""Fields""); (""Anonymous Class"", ""An anonymous class can declare methods inside it, indicating a containment relationship"", ""Methods"")"
"You can declare a static initializer for the anonymous class instead, though.",NULL
The same shadowing rules apply to anonymous classes as to inner classes.,NULL
The benefits of Java nested classes are that you can group classes together that belong together.,NULL
"You could do so already by putting them in the same package, but putting one class inside another makes an even stronger grouping.","(""Class"", ""A class can be put inside a package to create a grouping."", ""Package"")"
A nested class is typically only used by or with its enclosing class.,NULL
"Sometimes a nested class is only visible to the enclosing class, is only used internally, and is thus never visible outside the enclosing class.",NULL
"Other times the nested class is visible outside its enclosing class, but can only be used in conjunction with the enclosing class.",NULL
"Inside the Cache class you might declare a CacheEntry class which can contain information about a specific cache entry (cached value, time inserted, number of times accessed etc.).",NULL
"Users of the Cache class may never see the CacheEntry class, if they have no need to obtain information about the CacheEntry itself, but only the cached value.",NULL
"However, the Cache class may choose to make the CacheEntry class visible to the outside world, so they can access more than just the cached value (for instance information about when the value was last refreshed etc.",NULL
The first Cache class hides its CacheEntry nested class while the second Cache class exposes it.,"(""Cache"", ""The Cache class has a nested class called CacheEntry, indicating a containment relationship between the two."", ""CacheEntry"")"
"This example declares a variable of the MyClass class (custom data type), and then creates a new MyClass instance and assigns a reference to this instance to myClassInstance variable.",NULL
"Inside the parantheses () after the for keyword, are three statements separated by semicolon (;).","(""For"", ""The For keyword is related to the Parentheses because the Parentheses are used after the For keyword."", ""Parentheses""); (""For"", ""The For keyword is related to the Semicolon because the Semicolon is used to separate statements inside the For loop."", ""Semicolon""); (""For"", ""The For keyword is related to the Statements because the Statements are used inside the For loop."", ""Statements""); (""Parentheses"", ""The Parentheses are related to the Semicolon because the Semicolon is used to separate statements inside the Parentheses."", ""Semicolon""); (""Parentheses"", ""The Parentheses are related to the Statements because the Statements are used inside the Parentheses."", ""Statements"")"
"Notice how printBoth() calls the print() method two times, each time with a different of the parameters passed to the printBoth() method.",NULL
"When the print() method is finished executing, the program jumps back to after the line that called the print() method.","(""Print"", ""The print method is related to the program because when the print method is finished executing, the program jumps back to after the line that called the print method."", ""Program"")"
"When a Java project grows bigger, for instance an app or API, it is useful to split the code into multiple Java classes, and the classes into multiple Java packages.","(""Java"", ""Java is related to API because they are both mentioned in the context of a Java project"", ""API""); (""Java"", ""Java is related to App because they are both mentioned in the context of a Java project"", ""App""); (""Java"", ""Java classes are split into multiple Java packages, indicating a relationship between Java and its packages"", ""Java""); (""API"", ""API and App are related as they are both examples of a Java project"", ""App""); (""API"", ""API is related to Java because it is a Java project"", ""Java""); (""App"", ""App is related to Java because it is a Java project"", ""Java""); (""Java"", ""Java project is split into multiple Java classes, indicating a relationship between Java and its classes"", ""class"")"
"When you divide classes into multiple Java packages, it becomes easier to figure out where a certain class you are looking for is.",NULL
You instantiate an object of a certain class using the new keyword.,NULL
"Here is a simple example of a class that has two methods, where one method calls the other:",NULL
The print() method is thus a reusable block of code that can be called from anywhere.,NULL
"Java packages are a mechanism to group Java classes that are related to each other, into the same ""group"" (package).",NULL
All Java source and class files of classes belonging to the same package are located in the same directory.,"(""Java"", ""Java classes belong to a Package"", ""Package""); (""Package"", ""All classes in the same package are located in the same directory"", ""Directory"")"
"Its a tree of packages, subpackages and classes inside these classes.","(""Tree"", ""The Tree entity is related to the Packages entity because a tree is composed of packages."", ""Packages""); (""Packages"", ""The Packages entity is related to the Subpackages entity because packages can contain subpackages."", ""Subpackages""); (""Packages"", ""The Packages entity is related to the Classes entity because packages can contain classes."", ""Classes"")"
"I have expanded two of the sublevel Java packages, so you can see the classes inside.",NULL
"The classes are illustrated using a little blue circle with a C inside, in the screenshot above.",NULL
"Similarly, the fully qualified name of a Java class includes its package name.",NULL
"For instance, the full qualified name of the ""Page"" class, is:",NULL
"In order to put add Java classes to packages, you must do two things:","(""Java"", ""Java classes are put into packages"", ""Packages"")"
Put the class files into the directory matching the package you want to add it to.,NULL
"When you have put your Java source file into the correct directory (matching the package the class should belong to), you have to declare inside that class file, that it belongs to that Java package.","(""Java source file"", ""The Java source file is related to the directory because it needs to be put into the correct directory matching the package the class should belong to."", ""directory""); (""directory"", ""The directory is related to the package because the Java source file needs to be in a directory that matches the package the class belongs to."", ""package""); (""Java source file"", ""The Java source file is related to the package because it needs to declare that it belongs to that Java package."", ""package""); (""Java"", ""The Java source file is related to Java because it is a Java source file."", ""Java source file""); (""Java"", ""The Java package is related to Java because it is a Java package."", ""package""); (""Java"", ""The Java class is related to Java because it is a Java class."", ""class""); (""class"", ""The class is related to the package because it belongs to that package."", ""package"")"
"If the classes A and B are located in the same Java package, there is no problem with the code above.","(""A"", ""A is located in the Java package"", ""Java""); (""B"", ""B is located in the Java package"", ""Java"")"
"If you need to use a lot of classes from a certain Java package, importing them one at a time results in a lot of import statements.","(""Java"", ""Java is a package that contains many classes"", ""Classes""); (""Import"", ""The import method is used to import classes"", ""Classes"")"
It is possible to import all classes of a package using the * character instead of a class name.,NULL
"Not like Java classes, where the first letter is usually a capital letter.",NULL
It is possible to use a class from another package without importing it with an import statement.,"(""Class"", ""A class can be used from another package, indicating a relationship between the class and the package."", ""Package""); (""Package"", ""A package can be imported using an import statement, indicating a relationship between the package and the import statement."", ""Import Statement"")"
You can write the fully qualified class name instead of just the name of the class itself.,NULL
"The fully qualified class name consists of the full package path down to the subclass containing the class, and also including the class name itself.","(""Class"", ""The class is contained in the package, as indicated by the fully qualified class name consisting of the full package path."", ""Package""); (""Subclass"", ""The subclass contains the class, as mentioned in the text describing the fully qualified class name."", ""Class"")"
The fully qualified class name is also what you would write in an import statement.,"(""Class"", ""The class is related to the import because the fully qualified class name is used in an import statement."", ""Import""); (""Class"", ""The class is related to the package because a class is typically part of a package and the fully qualified class name includes the package name."", ""Package"")"
"You could use this fully qualified class name to reference the TimeUtil class inside another class, like this:","(""TimeUtil"", ""TimeUtil is part of the utility package."", ""utility""); (""TimeUtil"", ""TimeUtil has a method called getTime."", ""getTime""); (""CalendarApp"", ""CalendarApp uses the getTime method."", ""getTime"")"
"You might be wondering how you decide on what Java packages to create, and how to divide your classes into these packages.","(""Packages"", ""The text mentions dividing classes into packages, indicating a clear relationship between the two entities."", ""Classes""); (""Java"", ""The text mentions Java packages, indicating that Java is related to packages as the programming language being used."", ""Packages"")"
"The first method is to divide classes after what ""layer"" of the application they belong to.","(""Classes"", ""Classes are divided based on the layer of the application they belong to, indicating a relationship between the two."", ""Layer""); (""Method"", ""The method is used to divide classes, indicating a relationship between the method and classes."", ""Classes""); (""Application"", ""Classes belong to an application, indicating a relationship between the application and classes."", ""Classes"")"
All classes involved in communication with the database would then be located in the database package.,NULL
The second method is to divide your classes based on what part of the application functionality they belong to.,"(""Classes"", ""The text implies that classes are related to methods because it discusses dividing classes based on the part of the application functionality they belong to, which suggests that classes contain or are associated with methods."", ""Method""); (""Classes"", ""The text states that classes belong to a part of the application functionality, indicating a relationship between classes and the application."", ""Application""); (""Classes"", ""The text mentions dividing classes based on the part of the application functionality they belong to, which implies a relationship between classes and functionality."", ""Functionality""); (""Method"", ""The text discusses methods in the context of the application functionality, suggesting a relationship between methods and the application."", ""Application"")"
"All classes involved in one way or another in the pension calculations would go into that package (or subpackages, if the number of classes in pension grow large).",NULL
"The ""divide by application functionality"" method of dividing classes into Java packages tends to work better than ""divide by layer"", as your application grows in number of classes.","(""Classes"", ""Classes are divided into Java packages"", ""Java""); (""Method"", ""The method of dividing classes is used"", ""Classes""); (""Application"", ""As the application grows in number of classes"", ""Classes""); (""Method"", ""The method of dividing classes is used for the application"", ""Application"")"
"Instead of having a fixed number of layer packages which keep growing in number of classes, you get a growing number of application functionality packages with a smaller number of classes inside.","(""Layer"", ""The layer package contains a growing number of classes"", ""Classes""); (""Application"", ""The application functionality packages are related as they both provide functionality to the application"", ""Functionality""); (""Application"", ""The application functionality packages contain a smaller number of classes inside"", ""Classes"")"
"These packages contain classes for all kinds of purposes that programmers often need, like reading and writing files from the local hard disk, sending and receiving data over networks and the internet, connecting to databases, and many, many other things.","(""Packages"", ""Packages contain classes for various purposes"", ""Classes""); (""Classes"", ""Classes are contained within packages"", ""Packages""); (""Programmers"", ""Programmers often need and use the packages"", ""Packages""); (""Programmers"", ""Programmers often need and use the classes"", ""Classes""); (""Packages"", ""Packages are used by programmers for various purposes"", ""Programmers"")"
"When you compile all the source code in the source, the compiler produces one .class file for each .java file.","(""Compiler"", ""The compiler processes the source code to produce class files."", ""Source Code""); (""Compiler"", ""The compiler produces one .class file for each .java file."", ""Java File"")"
It is the .class files that the Java Virtual Machine can execute.,NULL
Therefore it is normal to separate the .java files from the .class files.,"(""Java"", ""Java is related to Files because Java files are typically compiled into class files"", ""Files""); (""Package"", ""Package is related to Java because Java classes are often organized into packages"", ""Java"")"
This is normally done by instructing the compiler to write the .class files into a separate directory.,"(""Compiler"", ""The compiler is related to the class because it is used to write the .class files."", ""Class""); (""Compiler"", ""The compiler is related to the directory because it writes the .class files into it."", ""Directory"")"
"This directory is often called classes, but again, it is not a requirement, and it depends on what build tool or IDE etc.","(""Directory"", ""The directory is often called classes, indicating a relationship between the two entities."", ""Classes""); (""Build"", ""The build tool is mentioned in the context of the directory and classes, indicating a relationship between the build and the tool."", ""Tool"")"
The *.java means the compiler should compile all files in the given directory.,"(""Compiler"", ""The Compiler uses the Compile method to compile files."", ""Compile""); (""Compiler"", ""The Compiler compiles files in a given Directory."", ""Directory"")"
"Once the compiler has done its job, the classes directory will contain the compiled .class files.",NULL
The package structure (directory structure) from the source directory will be preserved under the class directory.,"(""Package"", ""The package structure is preserved under the class directory, indicating a relationship between the package and the class."", ""Class""); (""Package"", ""The package structure is related to the directory structure, as it is preserved under the directory."", ""Directory"")"
You can run any one of these .class files which have a main() method in it.,NULL
"You can run the .class from inside your Java IDE, or from the command line.","(""Java IDE"", ""You can run the .class from inside your Java IDE, indicating a relationship between the Java IDE and the Class"", ""Class"")"
The -cp classes flag tells the Java Virtual Machine that all your classes are located under the directory called classes.,"(""Java Virtual Machine"", ""The Java Virtual Machine uses the classes directory to locate the classes."", ""classes""); (""-cp"", ""The -cp flag is related to the classes directory, as it tells the Java Virtual Machine where to find the classes."", ""classes"")"
The name of the class to run is the last argument in the above command - the myfirstapp.MyJavaApp part.,NULL
The JVM needs to know the fully qualified class name (all packages plus class name) to determine where the corresponding .class file is located.,"(""JVM"", ""The JVM needs to know the fully qualified class name to determine where the corresponding .class file is located, indicating a relationship between the JVM and the class."", ""CLASS""); (""JVM"", ""The JVM needs to know the fully qualified class name, which includes all packages, to determine where the corresponding .class file is located, indicating a relationship between the JVM and the package."", ""PACKAGE"")"
When you run the the class your command line will look similar to this (including the output from the Java app):,"(""Class"", ""The class is related to the command line because when you run the class, the command line will display the output from the Java app"", ""Command Line""); (""Command Line"", ""The command line is related to the Java app because it displays the output from the Java app"", ""Java App""); (""Class"", ""The class is related to the command line because when you run the class, the command line will display the output"", ""Command Line""); (""Command Line"", ""The command line is related to the Java app because it displays the output from the Java app"", ""Java App"")"
A Java Record consist of one or more data fields which corresponds to member variables in a regular Java class.,"(""Java Record"", ""A Java Record consists of one or more data fields, indicating a composition relationship between Java Record and data fields"", ""data fields""); (""Java Record"", ""A Java Record corresponds to a regular Java class, indicating an inheritance or specialization relationship between Java Record and Java class"", ""Java class"")"
"The Java compiler then generates the corresponding fields, getter methods and a hashCode() and equals() method.","(""Java"", ""The Java compiler is a part of the Java class, and is used to generate fields, getter methods, and other methods."", ""compiler""); (""compiler"", ""The compiler generates a hashCode method."", ""hashCode""); (""compiler"", ""The compiler generates an equals method."", ""equals""); (""compiler"", ""The compiler generates getter methods."", ""getter""); (""compiler"", ""The compiler generates the corresponding fields."", ""fields""); (""Java"", ""The Java class has a hashCode method."", ""hashCode""); (""Java"", ""The Java class has an equals method."", ""equals""); (""Java"", ""The Java class has getter methods."", ""getter"")"
A Java Record is a special kind of Java class which has a concise syntax for defining immutable data-only classes.,NULL
"The Java compiler auto generates getter methods, toString(), hashcode() and equals() methods for these data fields, so you don't have to write that boilerplate code yourself.","(""Java compiler"", ""The Java compiler auto generates getter methods, indicating a clear relationship between the two entities."", ""getter methods""); (""Java compiler"", ""The Java compiler auto generates toString() methods, indicating a clear relationship between the two entities."", ""toString()""); (""Java compiler"", ""The Java compiler auto generates hashcode() methods, indicating a clear relationship between the two entities."", ""hashcode()""); (""Java compiler"", ""The Java compiler auto generates equals() methods, indicating a clear relationship between the two entities."", ""equals()""); (""getter methods"", ""Both getter methods and toString() are auto-generated by the Java compiler for data fields, indicating a relationship between the two entities."", ""toString()""); (""getter methods"", ""Both getter methods and hashcode() are auto-generated by the Java compiler for data fields, indicating a relationship between the two entities."", ""hashcode()""); (""getter methods"", ""Both getter methods and equals() are auto-generated by the Java compiler for data fields, indicating a relationship between the two entities."", ""equals()""); (""toString()"", ""Both toString() and hashcode() are auto-generated by the Java compiler for data fields, indicating a relationship between the two entities."", ""hashcode()""); (""toString()"", ""Both toString() and equals() are auto-generated by the Java compiler for data fields, indicating a relationship between the two entities."", ""equals()"")"
You use a Java Record just like you use other Java classes - by creating instances of the record type using the Java new keyword.,"(""Java Record"", ""Java Record is a part of the Java package, as indicated by the use of Java Records in the context of Java classes"", ""Java""); (""Java Record"", ""The new method is used to create instances of the Java Record type"", ""new"")"
"Notice how the Java compiler has generated a brand() method, a licensePlate() method and a toString() method for us.","(""Java"", ""The Java compiler is a part of the Java class, indicating a relationship between the two entities."", ""compiler""); (""compiler"", ""The compiler has generated the brand() method, indicating that the compiler is related to the brand() method."", ""brand()""); (""compiler"", ""The compiler has generated the licensePlate() method, indicating that the compiler is related to the licensePlate() method."", ""licensePlate()""); (""compiler"", ""The compiler has generated the toString() method, indicating that the compiler is related to the toString() method."", ""toString()""); (""Java"", ""The brand() method is part of the Java class, indicating a relationship between Java and the brand() method."", ""brand()""); (""Java"", ""The licensePlate() method is part of the Java class, indicating a relationship between Java and the licensePlate() method."", ""licensePlate()"")"
"A Record type definition is final, meaning you cannot create subclasses (subrecords) of a Java Record type.","(""Record"", ""A Record type definition is related to Java Record because it is a type of Java Record."", ""Java Record""); (""Java Record"", ""Java Record is related to Java because it is a part of the Java language."", ""Java"")"
You can add instance methods to a Java Record definition - just like you can with a regular Java class.,"(""Java Record"", ""Java Record has instance methods added to its definition"", ""instance methods""); (""Java class"", ""Java class also has instance methods added to its definition, similar to Java Record"", ""instance methods""); (""Java"", ""Java is the package that Java Record belongs to"", ""Java Record"")"
Here is an example of the Vehicle Java Record definition from earlier sections with an instance method named brandAsLowerCase() added:,"(""Vehicle"", ""The Vehicle class has an instance method named brandAsLowerCase(), indicating a clear relationship between the two entities as the method is defined within the class."", ""brandAsLowerCase()""); (""Vehicle"", ""The Vehicle class is defined using Java, indicating a relationship between the class and the programming language/package it is written in."", ""Java"")"
Notice how the brandAsLowerCase() method calls the auto-generated brand() method internally.,NULL
"That means, that even classes from different projects compiled separately, but which are used in the same application may share constant String objects.","(""Classes"", ""Classes are compiled separately in different projects"", ""Projects""); (""Classes"", ""Classes from different projects are used in the same application"", ""Application""); (""Projects"", ""Projects are part of the same application"", ""Application""); (""String"", ""Classes may share constant String objects"", ""Classes"")"
"As you can see, a new StringBuilder is created, passing along the first String to its constructor, and the second String to its append() method, before finally calling the toString() method.","(""StringBuilder"", ""StringBuilder is related to String because it is created with a String and appends another String"", ""String""); (""StringBuilder"", ""StringBuilder is related to append() because append() is a method of StringBuilder"", ""append()""); (""StringBuilder"", ""StringBuilder is related to toString() because toString() is a method of StringBuilder"", ""toString()""); (""String"", ""String is related to append() because append() is a method that can be used with a String"", ""append()"")"
This code actually creates two objects: A StringBuilder instance and a new String instance returned from the toString() method.,"(""StringBuilder"", ""The StringBuilder instance is related to the toString() method because the method is called on the StringBuilder instance to return a new String instance."", ""toString()""); (""String"", ""The String instance is related to the toString() method because the method returns a new String instance."", ""toString()"")"
"The bigger the result String grows, the longer it takes to copy the characters from it into a new StringBuilder, and again copy the characters from the StringBuilder into the temporary String created by the toString() method.","(""String"", ""The String and StringBuilder are related because the characters from the String are copied into the StringBuilder."", ""StringBuilder""); (""StringBuilder"", ""The StringBuilder and String are related because the characters from the StringBuilder are copied into a temporary String created by the toString() method."", ""String""); (""String"", ""The String and toString() method are related because the toString() method is used to create a temporary String."", ""toString()"")"
You can obtain the length of a String using the length() method.,NULL
You do so using the substring() method of the String class.,NULL
The last character in the string has has the index String.length() - 1.,NULL
You can search for substrings in Strings using the indexOf() method.,NULL
The indexOf() method returns the index of where the first character in the first matching substring is found.,NULL
"If the substring is not found within the string, the indexOf() method returns -1;",NULL
There is a version of the indexOf() method that takes an index from which the search is to start.,NULL
The Java String class also has a lastIndexOf() method which finds the last occurrence of a substring.,NULL
"The Java String matches() method takes a regular expression as parameter, and returns true if the regular expression matches the string, and false if not.","(""String"", ""The String class has a method called matches(), indicating a clear relationship between the two entities as the method is a part of the class."", ""matches()"")"
The equals() method tests if two Strings are exactly equal to each other.,NULL
The String class also has a method called equalsIgnoreCase() which compares two strings but ignores the case of the characters.,NULL
The startsWith() and endsWith() methods check if the String starts with a certain substring.,"(""String"", ""The startsWith() method is related to the String class because it is used to check if the String starts with a certain substring."", ""startsWith()""); (""String"", ""The endsWith() method is related to the String class because it is used to check if the String ends with a certain substring."", ""endsWith()"")"
"The compareTo() method compares the String to another String and returns an int telling whether this String is smaller, equal to or larger than the other String.",NULL
"If the String is earlier in sorting order than the other String, compareTo() returns a negative number.",NULL
"If the String is equal in sorting order to the other String, compareTo() returns 0.","(""String"", ""The compareTo() method is a part of the String class, indicating a relationship between the two entities as the method is used to compare String objects."", ""compareTo()"")"
"If the String is after the other String in sorting order, the compareTo() metod returns a positive number.",NULL
You should be aware that the compareTo() method may not work correctly for Strings in different languages than English.,"(""CompareTo"", ""The compareTo method is used for Strings, indicating a relationship between the two."", ""Strings"")"
The Java String class contains a method called trim() which can trim a string object.,"(""String"", ""The String class contains the trim() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""trim()"")"
The trim() method can be very useful to trim text typed into input fields by a user.,NULL
The trim() method is an easy way to remove such extra white space characters.,NULL
The Java String class contains a method named replace() which can replace characters in a String.,NULL
The replace() method does not actually replace characters in the existing String.,NULL
"The replace() method will replace all character matching the character passed as first parameter to the method, with the second character passed as parameter to the replace() method.","(""Replace"", ""The replace() method is related to Character as it replaces characters, indicating an action-target relationship."", ""Character"")"
The Java String replaceFirst() method returns a new String with the first match of the regular expression passed as first parameter with the string value of the second parameter.,NULL
The Java String replaceAll() method returns a new String with all matches of the regular expression passed as first parameter with the string value of the second parameter.,NULL
The Java String class contains a split() method which can be used to split a String into an array of String objects.,"(""String"", ""The String class contains the split() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""split()""); (""String"", ""The String class is related to String objects as the split() method returns an array of String objects, indicating that the class is used to create these objects."", ""String"")"
The parameter passed to the split() method is actually a Java regular expression.,NULL
The String split() method exists in a version that takes a limit as a second parameter.,NULL
Here is a Java String split() example using the limit parameter:,"(""String"", ""The String class has a method called split(), indicating a clear relationship between the two entities as the method is a part of the class."", ""split()""); (""Java"", ""The Java package contains the String class, indicating a relationship between the package and the class as the class is part of the package."", ""String"")"
The Java String class contains a set of overloaded static methods named valueOf() which can be used to convert a number to a String.,NULL
"Since all Java classes extends (inherits from) the Object class, all objects have a toString() method.",NULL
"Note: For the toString() method to return a sane String representation of the given object, the class of the object must have overridden the toString() method.","(""ToString"", ""The toString method is related to the Class entity because it is a method that can be overridden by a class to return a sane String representation of an object."", ""Class""); (""ToString"", ""The toString method is related to the Object entity because it is used to return a String representation of a given object."", ""Object"")"
"If not, the default toString() method (inherited from the Object class) will get called.",NULL
The default toString() method does not provide that much useful information.,NULL
It is possible to get a character at a certain index in a String using the charAt() method.,NULL
You can also get the byte representation of the String method using the getBytes() method.,NULL
The first getBytes() call return a byte representation of the String using the default character set encoding on the machine.,"(""GETBYTES"", ""The getBytes() method is called on a String object, indicating a relationship between the two."", ""STRING"")"
The second getBytes() call return a UTF-8 byte representation of the String.,NULL
You can convert Strings to uppercase and lowercase using the methods toUpperCase() and toLowerCase().,"(""Strings"", ""The Strings class has a method called toUpperCase() to convert strings to uppercase"", ""toUpperCase()"")"
From Java 13 the Java String class got a new method named formatted() which can be used to return a formatted version of the String formatted() is called on.,"(""String"", ""The String class has a method named formatted(), indicating a clear relationship between the two entities as the method is part of the class."", ""formatted()""); (""Java"", ""The Java String class is a part of the Java language, indicating a relationship between Java and the String class as the class belongs to the language."", ""String"")"
"The formatted() method is only a preview feature that was added together with Java Text Blocks in Java 13, so we do not yet know if it will stay in.","(""Formatted"", ""The formatted() method is related to Java Text Blocks because they were both added in Java 13"", ""Java Text Blocks""); (""Formatted"", ""The formatted() method is related to Java 13 because it was added in this version"", ""Java 13"")"
Here is an example of using the Java String formatted() method:,"(""String"", ""The String class has a formatted() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""formatted()""); (""Java"", ""The Java package contains the String class, indicating a relationship between the package and the class as the class is part of the package."", ""String"")"
The parameter values passed to formatted() will be inserted into the returned String at the %s location of the input String.,"(""Formatted"", ""The formatted() method is related to the String class because it returns a String object."", ""String""); (""String"", ""The String class is related to the Input because the input is described as an input String."", ""Input"")"
"From Java 13 the Java String class got a new method named stripIndent() which can be used to strip out indentation, similarly to how indentation is stripped out of Java Text Blocks.","(""Java String class"", ""The Java String class has a method named stripIndent(), indicating a clear relationship between the two entities as the method is part of the class."", ""stripIndent()""); (""Java"", ""The Java String class is part of the Java package, indicating a clear relationship between the two entities as the class belongs to the package."", ""Java String class""); (""Java"", ""Java Text Blocks is a feature of the Java package, indicating a clear relationship between the two entities as the feature belongs to the package."", ""Java Text Blocks"")"
"The stripIndent() method is a preview feature, so we don't know if it will stay in Java yet.",NULL
Here is an example of using the new Java String stripIndent() method:,"(""String"", ""The String class contains the stripIndent() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""stripIndent()""); (""Java"", ""The Java package contains the String class, indicating a clear relationship between the two entities as the class is a part of the package."", ""String"")"
From Java 13 the Java String class got a new method called translateEscapes() which can translate escape codes that exist inside a String in the same way the Java compiler translates them.,"(""Java String class"", ""The Java String class has a method called translateEscapes(), indicating a clear relationship between the class and the method."", ""translateEscapes()""); (""Java"", ""The Java String class is part of the Java package, indicating a clear relationship between the package and the class."", ""Java String class"")"
"For now, the translateEscapes() is a preview feature, so it is not yet sure that it will stay in Java.",NULL
Here is an example of using the Java String translateEscapes() method:,"(""String"", ""The String class contains the translateEscapes() method, indicating a clear relationship between the two entities."", ""translateEscapes()""); (""Java"", ""The Java package contains the String class, indicating a clear relationship between the two entities."", ""String"")"
When calling the translateEscapes() method the \n part of the text will now be interpreted as a line break escape code.,NULL
The String class has several other useful methods than the ones described in this tutorial.,NULL
"The result of this is, that execution just ""falls through"" to the operation of the next case statement ( and the next etc.)","(""RESULT"", ""The result is related to the case statement because it is the outcome of the execution that falls through to the operation of the next case statement."", ""CASE STATEMENT"")"
All Java code must reside inside a file with the extension .java .,NULL
"Below is an example .java file that contains all of the above elements, so you can see the basic syntax of a .java file:","(""Java"", ""Java is related to File because a Java file is a type of file that contains Java code"", ""File""); (""Java"", ""Java is related to Example because an example is typically written in Java"", ""Example""); (""File"", ""File is related to Example because an example is often provided in a file"", ""Example"")"
The .java file should be located in a directory structure that matches the package name.,NULL
"Please note, that the code example does not actually use the Java HashMap class anywhere.",NULL
Of course you should not import classes you do not use in a real project.,NULL
"In Java a type is either a class, an abstract class an interface, an enum or an annotation.","(""Java"", ""Java is related to Type because it is the programming language being described, where Type is a fundamental concept."", ""Type""); (""Type"", ""Type is related to Class because a Class is one of the types in Java."", ""Class""); (""Type"", ""Type is related to Abstract Class because an Abstract Class is one of the types in Java."", ""Abstract Class""); (""Type"", ""Type is related to Interface because an Interface is one of the types in Java."", ""Interface""); (""Type"", ""Type is related to Enum because an Enum is one of the types in Java."", ""Enum"")"
A type (class / interface / enum) can have more than one field.,NULL
The fifth line (or block of lines) is a class initializer block.,NULL
Inside this block you can put initialization code that is to be executed a instance of the class is created.,"(""CLASS"", ""The class is related to the instance because an instance is created from a class."", ""INSTANCE""); (""INSTANCE"", ""The instance is related to the class because the instance is an example of the class."", ""CLASS""); (""BLOCK"", ""The block is related to the class because the block contains initialization code for the class."", ""CLASS""); (""BLOCK"", ""The block is related to the instance because the block contains code that is executed when an instance is created."", ""INSTANCE""); (""INITIALIZATION CODE"", ""The initialization code is related to the class because the initialization code is executed when an instance of the class is created."", ""CLASS"")"
"Then they are executed already when the class is loaded, and only once because the class is only loaded in the Java Virtual Machine once.",NULL
"Constructors are similar to class initializers, except they can take parameters.","(""Constructors"", ""Constructors are similar to class initializers, indicating a relationship between the two entities as they serve similar purposes."", ""Class Initializers"")"
"A class can have more than one constructor, although this example just shows one.",NULL
When you create an instance of a class (an object) the object can have methods you can execute.,"(""Class"", ""An object is an instance of a class, indicating a clear relationship between the two entities."", ""Object""); (""Object"", ""The object can have methods, indicating that the object and methods are related as the methods belong to or are executed by the object."", ""Methods"")"
"A static method belongs to the class, not objects of the class.",NULL
That means that you can call a static method without having an object of the class the static method belongs to.,"(""Method"", ""A method belongs to a class, as indicated by the phrase 'the static method belongs to' in the text, which establishes a clear relationship between the two entities."", ""Class""); (""Object"", ""An object is an instance of a class, and the text mentions 'an object of the class', which clearly relates the two entities."", ""Class"")"
"In the example above, if case.equals(""uppercase"") evaluates to true then the ternary operator expression as a whole returns the String value JOHN.","(""String"", ""The String class has a method called equals, which is used for comparing two strings."", ""equals""); (""case"", ""The variable case seems to be of type String, as it is being compared using the equals method, which is a method of the String class."", ""String""); (""ternary operator"", ""The ternary operator is used to return a String value, which indicates that it is related to the String class."", ""String""); (""case"", ""The variable case is used in the ternary operator expression, which indicates that they are related."", ""ternary operator"")"
"If case.equals(""uppercase"") evaluates to false then the ternary operator expression as a whole returns the String value john.","(""Case"", ""The Case class has a method called Equals, indicating a relationship between the two entities."", ""Equals"")"
"That means, that the String variable name will end up having the value JOHN or john depending on whether the expression case.equals(""uppercase"") evaluates to true or false.","(""String"", ""The String class is related to the name variable because the name variable is declared as a String type."", ""name""); (""case"", ""The case variable is related to the equals method because the equals method is called on the case variable."", ""equals"")"
"As you can see, both of these code examples avoid calling object.getValue() if the object reference is null, but the first code example is a bit shorter and more elegant.",NULL
You can achieve the same functionality as the Java Math max() function using a Java ternary operator.,"(""Java Math"", ""Java Math is a class that contains the method Math max()"", ""Math max()""); (""Java"", ""Java is a package that contains the class Java Math"", ""Java Math""); (""Java"", ""Java is a package that can use the method Java ternary operator"", ""Java ternary operator"")"
Here is an example of achieving the Math.max() functionality using a Java ternary operator:,"(""Math"", ""Math is a class that contains the max method"", ""max""); (""Math"", ""Math is a class in the Java package"", ""Java"")"
The Java ternary operator can also be used to achieve the same effect as the Java Math min() function.,"(""Java"", ""The Java class is related to the Math class because the Math class is part of the Java standard library."", ""Math""); (""Math"", ""The Math class is related to the min method because the min method is a part of the Math class."", ""min""); (""Java ternary operator"", ""The Java ternary operator is related to the Math class because it can be used to achieve the same effect as the Math min function."", ""Math"")"
Here is an example of achieving the Math.min() functionality using a Java ternary operator:,"(""Math"", ""Math and min are related because min is a method of the Math class"", ""min""); (""Math"", ""Math is related to Java because it is a part of the Java standard library"", ""Java"")"
The Java ternary operator can also be used to achieve the same effect as the Java Math abs() function.,"(""Math"", ""The Math class contains the abs method, indicating a clear relationship between the two entities."", ""abs""); (""Java"", ""The Java class is related to the Math class, as the Math class is part of the Java package, indicating a clear relationship between the two entities."", ""Math""); (""Java"", ""The Java class is related to the abs method, as the abs method is part of the Java Math class, indicating a clear relationship between the two entities."", ""abs""); (""Java ternary operator"", ""The Java ternary operator can be used to achieve the same effect as the Java Math class, indicating a clear relationship between the two entities."", ""Math"")"
Here is an example of achieving the Math.abs() functionality using a Java ternary operator:,"(""Math"", ""Math is a class that contains the abs method, indicating a clear relationship between the two as the abs method is part of the Math class"", ""abs"")"
"If the input String is not equal to the empty String, the second ternary operator returns the value of Integer.parseInt(input) .","(""String"", ""The String class is related to the parseInt method because the method is called on the value of the String input."", ""parseInt""); (""Integer"", ""The Integer class is related to the parseInt method because the method is a part of the Integer class and is used to parse a String into an Integer."", ""parseInt"")"
"This can be any kind of information ranging from texts, codes (e.g.","(""TEXT"", ""TEXT is a type of INFORMATION"", ""INFORMATION"")"
"In the code example below, the main() method contains the declaration of a single integer variable named number.",NULL
"Non-static fields are also called instance variables, because they belong to instances (objects) of a class.","(""Non-static fields"", ""Non-static fields belong to instances of a class, indicating a relationship between the two entities."", ""Class""); (""Instance variables"", ""Instance variables are another term for non-static fields, which belong to instances of a class, indicating a relationship between the two entities."", ""Class"")"
A static field is a variable that belongs to a class.,"(""Static Field"", ""A static field belongs to a class, indicating a relationship between the two entities."", ""Class"")"
The second line assigns the floating point value 199.99 to the floating point variable named myFloat.,"(""MyFloat"", ""MyFloat is an instance of the Floating Point class"", ""Floating Point""); (""Assign"", ""The Assign method is used to assign a value to the MyFloat variable"", ""MyFloat"")"
"In this example, only the first System.out.println() statement is executed inside the while loop.","(""System"", ""System is related to out because out is a static member of the System class"", ""out""); (""out"", ""out is related to println because println is a method of the out class"", ""println""); (""System"", ""System is related to println because println is a method that can be used with System"", ""println""); (""while"", ""while loop is related to System because the System.out.println statement is executed inside the while loop"", ""System""); (""while"", ""while loop is related to out because the out.println statement is executed inside the while loop"", ""out"")"
The second System.out.println() statement is not executed until after the while loop is finished.,"(""System"", ""System is related to out because out is a part of the System class"", ""out""); (""out"", ""out is related to println because println is a method of the out class"", ""println""); (""System"", ""System is not directly related to while, however, the while loop is using System's out.println method, thus there is an indirect relationship"", ""while"")"
"This is typically done via a command line interface (CLI), like e.g.",NULL
On the command line you tell the JVM what Java class (bytecode) to execute.,"(""JVM"", ""The JVM is related to Java because it executes Java bytecode"", ""Java"")"
Only the full Java SDK contains the Java compiler which turns your .java source files into byte code .class files.,"(""Java SDK"", ""The Java SDK contains the Java compiler, indicating a relationship between the two entities."", ""Java compiler""); (""Java compiler"", ""The Java compiler turns .java source files into byte code, indicating a relationship between the Java compiler and .java files."", "".java""); (""Java compiler"", ""The Java compiler turns .java source files into .class files, indicating a relationship between the Java compiler and .class files."", "".class""); (""Java SDK"", ""The Java SDK contains the Java compiler which produces .class files, indicating an indirect relationship between the Java SDK and .class files."", "".class"")"
"Additionally, some Java servers may need some of the tools in the JDK to e.g.","(""Java"", ""Java servers may need some of the tools in the JDK"", ""JDK""); (""JDK"", ""the JDK contains some of the tools"", ""tools"")"
"The Java Code Conventions are a set of conventions for how to format your Java code, and how to name classes, variables, files etc.","(""Java"", ""Java Code Conventions are a set of conventions for Java code, indicating a relationship between the Java package and the Java Code Conventions class"", ""Java Code Conventions"")"
JavaFX was inspired by Flex (Flash) and Silverlight for .NET (Microsoft).,"(""JavaFX"", ""JavaFX was inspired by Flex"", ""Flex""); (""JavaFX"", ""JavaFX was inspired by Silverlight"", ""Silverlight""); (""Flex"", ""Flex is related to Flash"", ""Flash"")"
In this tutorial I will show you how to make your first Java app with IntelliJ IDEA community edition (free) version 2019.3.3.,"(""Java"", ""Java is related to IntelliJ IDEA because IntelliJ IDEA is an integrated development environment used for Java development"", ""IntelliJ IDEA""); (""IntelliJ IDEA community edition"", ""IntelliJ IDEA community edition is related to Java because it is a package used for Java development"", ""Java"")"
"How you do that depends on what operating system you are running (Windows, Mac, Linux etc.)","(""WINDOWS"", ""Both are operating systems mentioned in the text"", ""MAC""); (""WINDOWS"", ""Both are operating systems mentioned in the text"", ""LINUX"")"
"A Java package is just a directory inside which you can put one or more Java files (class, interface, annotation, enum etc.","(""Java"", ""A Java package contains one or more Java files"", ""Java files""); (""Java files"", ""Java files include classes"", ""class""); (""Java files"", ""Java files include interfaces"", ""interface""); (""Java files"", ""Java files include annotations"", ""annotation""); (""Java files"", ""Java files include enums"", ""enum""); (""package"", ""A package can contain classes"", ""class""); (""package"", ""A package can contain interfaces"", ""interface""); (""package"", ""A package can contain annotations"", ""annotation"")"
Now you must create a new class inside your newly created package.,NULL
"In the dialog that opens, type in a name for your new Java class.","(""Java"", ""Java is related to Class because Java is a programming language that uses classes."", ""Class"")"
"It is custom to have class names start with an uppercase character followed by lowercase characters, and a new uppercase character for each new word in the class name.",NULL
"When you have typed in a name for your new Java class, click the ""OK"" button.",NULL
"Once you have created the new class, it will be empty.",NULL
The part inside the /* ... */ are comments and are not part of the executed Java code.,NULL
Before you can run your Java app you need to insert a main() method into the class.,"(""Main()"", ""The Main() method is related to the Java class because it is inserted into the class to run the Java app."", ""Java""); (""Java"", ""The Java class is related to the app because the app is a Java app and needs a Java class to run."", ""App"")"
Now your are ready to run your newly created Java class.,NULL
"You do so by right clicking the class source code in the editor, and choose ""Run..."", like this:","(""Class"", ""The source is a part of the class source code, which indicates a relationship between the two entities."", ""Source""); (""Class"", ""The class source code is located in the editor, indicating a relationship between the class and the editor."", ""Editor""); (""Class"", ""The class is related to the Run method, as the Run method is chosen from the class source code."", ""Run""); (""Source"", ""The source is located in the editor, which indicates a relationship between the source and the editor."", ""Editor""); (""Source"", ""The source is related to the Run method, as the Run method is chosen from the source code."", ""Run"")"
"When you click the ""Run..."" option, IntelliJ IDEA will first compile your Java class, and then run it.","(""IntelliJ IDEA"", ""IntelliJ IDEA compiles and runs Java classes"", ""Java""); (""IntelliJ IDEA"", ""IntelliJ IDEA provides the Run... option to compile and run Java classes"", ""Run...""); (""IntelliJ IDEA"", ""IntelliJ IDEA compiles and runs Java classes"", ""Java""); (""IntelliJ IDEA"", ""IntelliJ IDEA provides the Run... option to compile and run Java classes"", ""Run..."")"
"After you have executed the Java class main method, you will see an output at the bottom of the IntelliJ IDEA window similar to this:","(""Java"", ""The Java class contains the Main method, indicating a relationship between the two entities."", ""Main""); (""IntelliJ IDEA"", ""The Java class is executed within the IntelliJ IDEA environment, suggesting a relationship between the two entities."", ""Java"")"
"Don't worry if you don't yet understand what a main() method is, or classes, or packages.","(""Main"", ""The Main method is often a part of a class, thus they are related."", ""Class""); (""Class"", ""A class is often organized within a package, thus they are related."", ""Package"")"
The most common way of using the Java Logging API is to create a Logger in each class that needs to log.,"(""Logger"", ""The Logger is part of the Java Logging API, indicating a relationship between the two entities as the Logger is used within the context of the Java Logging API"", ""Java Logging API"")"
"This instance is typically made static and final, meaning all instances of that class use the same Logger instance.",NULL
"As you can see from this example, it is common practice to use the class name including package name as name for the Logger.","(""Class"", ""The class is related to the Logger because the Logger is an example of a class."", ""Logger""); (""Package"", ""The package is related to the class because the class name often includes the package name."", ""Class"")"
The name of the Logger to create is passed as string parameter to the Logger.getLogger() method.,"(""Logger"", ""The Logger class contains the Logger.getLogger method, indicating a relationship between the two."", ""Logger.getLogger""); (""Logger"", ""The Logger class contains the Logger.getLogger() method, indicating a relationship between the two."", ""Logger.getLogger()"")"
"For instance, ordinary debug trace logging calls to entering() and exiting() would be called at the beginning and end of a method call.","(""Entering"", ""Entering is related to Method because it is called at the beginning of a method call."", ""Method"")"
The initialization of the configuration is taken care of by the java.util.logging.LogManager class.,NULL
You can use a Java class to configure the Java Logging API.,"(""Java"", ""The Java class is used to configure the Java Logging API, indicating a relationship between the class and the package."", ""Java Logging API""); (""configure"", ""The configure method is used in relation to the Java Logging API, indicating a relationship between the method and the package."", ""Java Logging API"")"
You do so by specifying the name of the class in the JVM parameter java.util.logging.config.class.,"(""Java"", ""The Java package is related to the Java.Util.Logging.Config.Class because Java.Util.Logging.Config.Class is a class within the Java package."", ""Java.Util.Logging.Config.Class"")"
It is the constructor of that class that should load the configuration and apply it to the Logger's in the hierarchy.,"(""Constructor"", ""The constructor is related to the configuration because it loads the configuration."", ""Configuration""); (""Constructor"", ""The constructor is related to the Logger because it applies the configuration to the Logger's in the hierarchy."", ""Logger"")"
"If no configuration class is specified, you can instead specify a configuration file (but no configuration class can be specified then!",NULL
"The Java Logging API has a default logging configuration file located at ""lib/logging.properties"", inside the JRE directory.",NULL
You do so by setting the JVM property java.util.logging.config.file to point to this file.,"(""JVM"", ""The JVM is related to java.util.logging.config.file because the JVM property is being set to point to this file, indicating a configuration relationship."", ""java.util.logging.config.file""); (""set"", ""The set method is related to the JVM because it is being used to set a JVM property, indicating a usage relationship."", ""JVM"")"
You should double check the JavaDoc over time to see if any of this changes (e.g.,NULL
"If the isLoggable() method returns false, the LogRecord is not logged.",NULL
The Handler's in the Java Logging API use a java.util.logging.Formatter to format the LogRecord's before writing it to an external system.,"(""Handler"", ""The Handler uses a java.util.logging.Formatter to format the LogRecord's"", ""java.util.logging.Formatter""); (""Handler"", ""The Handler's use a java.util.logging.Formatter to format the LogRecord's before writing it to an external system"", ""LogRecord""); (""Java Logging API"", ""The Handler's are part of the Java Logging API"", ""Handler""); (""Java Logging API"", ""The java.util.logging.Formatter is part of the Java Logging API"", ""java.util.logging.Formatter"")"
"The various Handler's in the Java Logging API use either of these two Formatter's by default, but you can also set your own custom Formatter subclass on a Handler.","(""Handler"", ""The Handler uses the Formatter by default"", ""Formatter""); (""Handler"", ""The Handler is part of the Java Logging API"", ""Java Logging API"")"
You can create your own Formatter by subclassing the java.util.logging.Formatter class.,NULL
The subclass must override the abstract format() method in the Formatter class.,"(""Formatter"", ""The format() method is part of the Formatter class, indicating a strong relationship between the two entities as the method is defined within the class."", ""format()""); (""format()"", ""The format() method is overridden in a subclass, implying it is originally defined in the Formatter class, thus establishing a relationship between the method and the class."")
{completion_delimiter}ศจHere is the revised output with the correct tuples and delimiters:


(""entity"",""Formatter"",""class"", ""Formatter"")"
The String returned by the format() is what is forwarded to the external system by the Handler.,"(""String"", ""The String class has a method called format(), indicating a clear relationship between the two."", ""format()""); (""format()"", ""The format() method is related to the Handler class, as the String returned by format() is forwarded to the external system by the Handler."", ""Handler"")"
The Formatter class also contains the convenience method formatMessage() which can be used to format the message using the ResourceBundle of the LogRecord.,"(""Formatter"", ""The Formatter class contains the formatMessage() method, indicating a clear relationship between the two."", ""formatMessage()""); (""formatMessage()"", ""The formatMessage() method uses the ResourceBundle, indicating a relationship between the method and the ResourceBundle class."", ""ResourceBundle""); (""formatMessage()"", ""The formatMessage() method is used to format the message using the ResourceBundle of the LogRecord, indicating a relationship between the method and the LogRecord class."", ""LogRecord""); (""Formatter"", ""The Formatter class's method formatMessage() uses the ResourceBundle, indicating an indirect relationship between the Formatter class and the ResourceBundle class."", ""ResourceBundle"")"
By default the ConsoleHandler uses a SimpleFormatter to format the messages before writing them to System.err.,"(""ConsoleHandler"", ""The ConsoleHandler uses a SimpleFormatter to format the messages."", ""SimpleFormatter"")"
"If no %g code has been specified and the file count of the FileHandler is greater than 1, then the generation number (file sequence number) will be appended to the end of the file name, after a dot (.)","(""FileHandler"", ""The FileHandler has a file sequence number which will be appended to the end of the file name."", ""file sequence number"")"
You must set one using the method setOutputStream() before using the handler.,NULL
You can also call the push() method to force the LogRecord's in the buffer to be flushed to the target Handler.,"(""LogRecord"", ""The LogRecord's are flushed to the target Handler, indicating a relationship between LogRecord and Handler."", ""Handler""); (""push"", ""The push() method is used to force the LogRecord's to be flushed, indicating a relationship between the push method and LogRecord."", ""LogRecord"")"
This class contains a constant for each of the above log levels.,NULL
When you create a Logger you pass a name to the Logger.getLogger() method.,"(""Logger"", ""The Logger class has a getLogger method, indicating a relationship between the two."", ""Logger""); (""Logger"", ""The Logger class uses the getLogger method, indicating a relationship between the class and the method."", ""Logger.getLogger()"")"
(Note: These levels are different from the log levels of the messages logged.).,NULL
If you call getParent() on that Logger you will get the Logger with the name com.,"(""Logger"", ""The Logger class has a method called getParent, indicating a relationship between the Logger class and the getParent method."", ""getParent""); (""getParent"", ""The getParent method is called on a Logger object, indicating a relationship between the getParent method and the Logger class."", ""Logger"")"
"... and call getParent() method, you will get the Logger with the name """".",NULL
"The third message is being logged three times: Once by the 1.2 Logger, once by the 1 Logger, and once by the root Logger.","(""LOGGER"", ""The 1.2 Logger is an instance of the Logger class"", ""1.2 LOGGER""); (""LOGGER"", ""The 1 Logger is an instance of the Logger class"", ""1 LOGGER""); (""LOGGER"", ""The root Logger is an instance of the Logger class"")
{completion_delimiter}


The final answer is:
(""entity"",""LOGGER"",""class"", ""ROOT LOGGER"")"
"Notice though, that the message propagated up the hierarchy from the Logger named 1.2 is still logged by the middle Logger, and still forwarded up to the root Logger.","(""Logger"", ""The Logger class has an instance named 1.2, indicating a relationship between the class and its instance."", ""1.2""); (""Logger"", ""The Logger class has a specific instance referred to as the root Logger, indicating a relationship between the class and its specialized instance."", ""root Logger""); (""Logger"", ""The Logger class has a specific instance referred to as the middle Logger, indicating a relationship between the class and its specialized instance."", ""middle Logger""); (""1.2"", ""The message from the Logger instance named 1.2 is logged by the middle Logger, indicating a relationship between the two instances."", ""middle Logger""); (""middle Logger"", ""The middle Logger forwards the message up to the root Logger, indicating a relationship between the two instances."", ""root Logger"")"
"Another peculiar result of the above code is, that the INFO message passed to the bottom Logger (named 1.2) is also ignored, and not propagated.","(""Logger"", ""The Logger class has a method INFO, which is used to pass messages."", ""INFO"")"
"In order to enable all INFO messages to be logged from the bottom Logger (named 1.2), even if the middle Logger has a log level of WARNING, we add the following to the code (in bold):",NULL
"The result of this code is that the INFO message logged on the bottom Logger (named 1.2) is now logged, but it is still not propagated up the hierarchy.","(""INFO"", ""The INFO message is logged on the Logger, indicating a relationship between the logging method and the Logger class or package""}"", ""Logger"")"
The java.util.Logger class is the main access point to the Java logging API.,"(""java.util.Logger"", ""java.util.Logger is a part of the java.util package"", ""java.util""); (""java.util.Logger"", ""java.util.Logger is the main access point to the Java logging API"", ""Java logging API"")"
The string passed as parameter to the getLogger() factory method is the name of the Logger to create.,NULL
"The two names ""myApp.user"" and ""myApp.admin"" are children of the ""myApp"" name.","(""Myapp"", ""Myapp.User is a child of Myapp"", ""Myapp.User"")"
"The name ""myApp.admin.import.user"" is a branch of the name ""myApp.admin.import"", which is again a branch of the ""myApp.admin"" name.","(""Myapp.Admin.Import.User"", ""Myapp.Admin.Import.User is a branch of Myapp.Admin.Import, indicating a hierarchical relationship"", ""Myapp.Admin.Import""); (""Myapp.Admin.Import"", ""Myapp.Admin.Import is a branch of Myapp.Admin, indicating a hierarchical relationship"", ""Myapp.Admin"")"
"You can obtain the name of a Logger using the getName() method, in case you need it.",NULL
"It is convention to use the class name of the class creating the Logger, including package name, as name for the Logger.","(""Logger"", ""The Logger is related to the class because it is created by the class and its name is based on the class name."", ""class""); (""class"", ""The class is related to the package because the package name is included in the class name used for the Logger."", ""package"")"
The log() group of methods will log a message at a certain log level.,NULL
"As mentioned earlier, the number inside the token refers to the index of the object parameter to insert, in the object parameter array passed to the log() message.","(""LOG"", ""The LOG method is related to the TOKEN class because the log() message is mentioned in the context of the token."", ""TOKEN""); (""TOKEN"", ""The TOKEN class is related to the OBJECT class because the token refers to the index of the object parameter."", ""OBJECT""); (""OBJECT"", ""The OBJECT class is related to the PARAMETER class because the object is a parameter passed to the log() message."", ""PARAMETER""); (""PARAMETER"", ""The PARAMETER class is related to the ARRAY class because the object parameter is stored in an array."", ""ARRAY""); (""INDEX"", ""The INDEX class is related to the OBJECT class because the number inside the token refers to the index of the object parameter."", ""OBJECT"")"
"The logp() methods work like the log() methods, except each method take an extra two parameters: The sourceClass and sourceMethod parameter.","(""Logp"", ""The logp() method is related to the log() method, as it works similarly to it, with the addition of extra parameters."", ""Log""); (""Logp"", ""The logp() method is related to the sourceClass parameter, as it takes this parameter as an extra argument."", ""Sourceclass"")"
These two parameters are intended to tell from what class and method the log message originated.,NULL
"In other words, which class and method was the ""source"" of the log message.",NULL
"The logrb() methods work like the log() methods too, except they can obtain the log messages from a resource bundle.","(""Logrb"", ""The logrb() methods work like the log() methods, indicating a relationship between the two methods"", ""Log"")"
This example looks up a message in the resource bundle named resources.myresources by the key key1.,"(""Resources"", ""Resources is related to Myresources because it is described as containing the resource bundle named resources.myresources"", ""Myresources""); (""Myresources"", ""Myresources is related to Key1 because it is the resource bundle being looked up by the key key1"", ""Key1"")"
"For instance, finest(), finer(), fine(), info(), warning() and severe() each corresponds to one of the log levels.","(""Finest"", ""Finest and Finer are related as they are both log level methods"", ""Finer""); (""Finer"", ""Finer and Fine are related as they are both log level methods"", ""Fine""); (""Fine"", ""Fine and Info are related as they are both log level methods"", ""Info""); (""Info"", ""Info and Warning are related as they are both log level methods"", ""Warning""); (""Warning"", ""Warning and Severe are related as they are both log level methods"", ""Severe""); (""Finest"", ""Finest and Fine are related as they are both log level methods"", ""Fine""); (""Finest"", ""Finest and Info are related as they are both log level methods"", ""Info""); (""Finest"", ""Finest and Warning are related as they are both log level methods"", ""Warning""); (""Finest"", ""Finest and Severe are related as they are both log level methods"", ""Severe""); (""Finer"", ""Finer and Info are related as they are both log level methods"", ""Info""); (""Finer"", ""Finer and Warning are related as they are both log level methods"", ""Warning""); (""Finer"", ""Finer and Severe are related as they are both log level methods"", ""Severe""); (""Fine"", ""Fine and Warning are related as they are both log level methods"", ""Warning""); (""Fine"", ""Fine and Severe are related as they are both log level methods"", ""Severe""); (""Info"", ""Info and Severe are related as they are both log level methods"", ""Severe"")"
Logging message using one of these methods corresponds to calling the log() method,"(""Logging"", ""Logging message using one of these methods corresponds to calling the log() method, indicating a relationship between Logging and Log"", ""Log"")"
You can add Handler's to the Logger using the addHandler() method.,"(""Handler"", ""The Handler is added to the Logger, indicating a relationship between the two classes"", ""Logger""); (""addHandler()"", ""The addHandler() method is used with the Logger, indicating that the method is a part of or closely related to the Logger class"", ""Logger"")"
"You can obtain all Handler's of a Logger using the getHandlers() method, like this:","(""Logger"", ""The getHandlers method is used in the context of a Logger, indicating a relationship between the two."", ""getHandlers""); (""Logger"", ""A Logger has multiple Handlers, as indicated by the getHandlers method, which returns all Handlers of a Logger."", ""Handler"")"
"You set the Filter on a Logger using the setFilter() method, like this:","(""Filter"", ""The Filter is set on a Logger using the setFilter() method, indicating a relationship between the Filter and the Logger."", ""Logger""); (""setFilter()"", ""The setFilter() method is used to set the Filter on a Logger, indicating a relationship between the setFilter() method and the Logger."", ""Logger"")"
The class MyFilterImpl should be your own implementation of the Filter interface.,NULL
"You can obtain the Filter in use by calling the getFilter() method, like this:",NULL
"This example sets the minimum log level of messages to be forwarded, to Level.INFO.","(""Example"", ""The Example is related to Level because it sets the minimum log level of messages to be forwarded to Level.INFO, indicating a connection between the class Example and the class Level."", ""Level""); (""Example"", ""The Example is related to INFO because it sets the minimum log level of messages to be forwarded to Level.INFO, indicating a connection between the class Example and the method INFO."", ""INFO""); (""Example"", ""The Example is related to set because it is the entity on which the set method is called, indicating a connection between the class Example and the method set."", ""set""); (""Level"", ""The Level is related to INFO because INFO is a method or attribute of the Level class, indicating a connection between the class Level and the method INFO."", ""INFO""); (""Level"", ""The Level is related to set because the set method is used to set the minimum log level to Level.INFO, indicating a connection between the class Level and the method set."", ""set"")"
You can obtain the log level of a Logger using the getLevel() method:,NULL
You can obtain the parent Logger of a given Logger using the getParent() method.,"(""Logger"", ""The getParent() method is used in the context of a Logger, indicating a relationship between the Logger class and the getParent() method."", ""getParent()"")"
You can check if a Logger forwards log messages to its parent Logger using the method getUseParentHandlers().,NULL
The Logger class has a few more methods that I haven't covered here.,NULL
"The java.util.logging.LogManager manages the internal Logger hierarchy, and initiates the configuration of the Logger's, either through the configuration class or configuration file.","(""LogManager"", ""The LogManager manages the internal Logger hierarchy, indicating a clear relationship between the two entities."", ""Logger""); (""LogManager"", ""The LogManager is part of the java.util.logging package, indicating a relationship between the class and the package."", ""java.util.logging"")"
"The first method on the LogManager simply re-reads the configuration from file (or class), in case these has changed.","(""LogManager"", ""The LogManager has a method that re-reads the configuration from file or class."", ""method""); (""method"", ""The method re-reads the configuration, indicating a relationship between the method and the configuration."", ""configuration""); (""method"", ""The method re-reads the configuration from a file, indicating a relationship between the method and the file."", ""file""); (""LogManager"", ""The LogManager has a method that re-reads the configuration, indicating a relationship between the LogManager and the configuration."", ""configuration"")"
You can also get access to an MXBean (Java Management Extensions) from the LogManager using the method getLoggingMXBean().,"(""LogManager"", ""The LogManager uses the getLoggingMXBean() method to provide access to an MXBean."", ""getLoggingMXBean()""); (""getLoggingMXBean()"", ""The getLoggingMXBean() method returns an MXBean, indicating that the method is related to the MXBean class."", ""MXBean"")"
"The LogRecord contains the following getter methods, which can be used in e.g.",NULL
The getLevel() method returns the log level the message represented by this LogRecord was logged with.,"(""GetLevel"", ""The getLevel() method is related to LogRecord because it is used to retrieve the log level of a message represented by a LogRecord object."", ""LogRecord""); (""LogRecord"", ""The LogRecord class is related to the getLevel() method because the method operates on a LogRecord object to retrieve the log level."", ""GetLevel"")"
The getLoggerName() method returns the name of the Logger that logged this LogRecord.,NULL
The getMillis() method returns the time in milliseconds this LogRecord was recorded.,NULL
The getParameters() method returns the parameters to be inserted into the message of this LogRecord.,"(""Getparameters"", ""The getParameters() method returns the parameters to be inserted into the message of this LogRecord, indicating a relationship between the getParameters method and the LogRecord class."", ""Logrecord""); (""Getparameters"", ""The getParameters() method returns the parameters to be inserted into the message, indicating a relationship between the getParameters method and the message."", ""Message"")"
The getResourceBundle() method returns the ResourceBundle (if any) used to localize the message of this LogRecord.,"(""getResourceBundle()"", ""The getResourceBundle() method is related to LogRecord because it is used to retrieve a resource bundle for localizing the message of this LogRecord."", ""LogRecord""); (""getResourceBundle()"", ""The getResourceBundle() method is related to ResourceBundle because it returns an instance of ResourceBundle."", ""ResourceBundle"")"
The getResourceBundleName() method returns the name of the ResourceBundle (if any) used to localize the message of this LogRecord.,"(""getResourceBundleName()"", ""The getResourceBundleName() method is used in the context of LogRecord, indicating a relationship between the two entities."", ""LogRecord""); (""getResourceBundleName()"", ""The getResourceBundleName() method returns the name of the ResourceBundle, indicating a direct relationship between the method and the ResourceBundle class."", ""ResourceBundle"")"
The getSequenceNumber() method returns a sequence number generated internally in the LogRecord constructor when the LogRecord is created.,"(""GetSequenceNumber()"", ""The getSequenceNumber() method is related to the LogRecord class because it is used to generate a sequence number when a LogRecord is created."", ""LogRecord"")"
The getSourceClassName() returns the class name of the class logging the message represented by this LogRecord.,"(""GETSOURCECLASSNAME()"", ""The getSourceClassName() method returns the class name of the LogRecord class, indicating a clear relationship between the two entities as the method is used to retrieve information about the LogRecord class."", ""LOGRECORD""); (""GETSOURCECLASSNAME()"", ""The getSourceClassName() method returns the class name of the class logging the message, indicating a relationship between the method and the class entity as the method is used to retrieve class information."", ""CLASS"")"
The getSourceMethodName() returns the method name of the method logging the message represented by this LogRecord.,"(""getSourceMethodName"", ""The getSourceMethodName() method is related to the LogRecord class because it is described as returning the method name of the method logging the message represented by this LogRecord, indicating a connection between the two."", ""LogRecord"")"
The getThreadID() method returns the ID of the thread logging the message represented by this LogRecord.,NULL
The getThrown() method returns the Throwable that was marked thrown when logging the message represented by this LogRecord.,"(""LogRecord"", ""The getThrown() method is a part of the LogRecord class, indicating a relationship between the two."", ""getThrown()""); (""getThrown()"", ""The getThrown() method returns a Throwable object, indicating a relationship between the method and the class."", ""Throwable"")"
In this text I will try to give you an overview of the java.util.logging API.,"(""Java"", ""Java is a package that contains the Util package"", ""Util""); (""Util"", ""Util is a package that contains the Logging package"", ""Logging""); (""Java"", ""Java is a package that contains the Java.Util.Logging package"", ""Java.Util.Logging"")"
This tutorial is about Javas built-in logging API in the java.util.logging package.,NULL
"Note: This tutorial does not cover the other popular Java logging API's (Log4J, SLF4J, Apache Commons Logging, LogBack etc.).","(""Java"", ""Java is related to Log4J as Log4J is a Java logging API"", ""Log4J""); (""Java"", ""Java is related to SLF4J as SLF4J is a Java logging API"", ""SLF4J""); (""Java"", ""Java is related to Apache Commons Logging as Apache Commons Logging is a Java logging API"", ""Apache Commons Logging""); (""Java"", ""Java is related to LogBack as LogBack is a Java logging API"", ""LogBack""); (""Log4J"", ""Log4J and SLF4J are related as they are both popular Java logging APIs"", ""SLF4J""); (""Log4J"", ""Log4J and Apache Commons Logging are related as they are both popular Java logging APIs"", ""Apache Commons Logging""); (""Log4J"", ""Log4J and LogBack are related as they are both popular Java logging APIs"", ""LogBack""); (""SLF4J"", ""SLF4J and Apache Commons Logging are related as they are both popular Java logging APIs"", ""Apache Commons Logging""); (""SLF4J"", ""SLF4J and LogBack are related as they are both popular Java logging APIs"", ""LogBack"")"
"If you can choose your own logging API freely, you may choose one of these other, popular logging API's instead of java.util.logging.","(""Java.Util.Logging"", ""Java.Util.Logging is an implementation of the Api"", ""Api"")"
"However, if you are running your web applications on Google App Engine, like I do, then you have to use the java.util.logging API.","(""Java"", ""Java is used for developing applications that run on Google App Engine"", ""Google App Engine""); (""java.util.logging"", ""java.util.logging is a package in Java"", ""Java""); (""java.util.logging API"", ""java.util.logging API is part of the java.util.logging package"", ""java.util.logging"")"
Instances of this class are used together with UDP DatagramSockets and normal Socket's and ServerSocket's.,"(""Class"", ""They are used together, indicating a relationship between the Class entity and the UDP DatagramSockets entity."", ""UDP DatagramSockets""); (""Class"", ""They are used together, indicating a relationship between the Class entity and the Socket entity."", ""Socket"")"
The InetAddress class has a lot of additional methods you can use.,NULL
"For instance, you can obtain the IP address as a byte array by calling getAddress() etc.",NULL
"To learn more about these methods, it is easier to read the JavaDoc for the InetAddress class though.",NULL
Java's JarURLConnection class is used to connect to a Java Jar file.,NULL
"Of course, sometimes this protocol is already have been decided for you, e.g.",NULL
Sending the header in a separate roundtrip (the first) can be smart if the server can do some initial pre-validation of e.g.,NULL
"In order to implement a Java server that listens for incoming connections from clients via TCP/IP, you need to use a java.net.ServerSocket .","(""ServerSocket"", ""ServerSocket is a part of the java.net package"", ""java.net""); (""Java"", ""Java uses ServerSocket to implement a server that listens for incoming connections"", ""ServerSocket"")"
"In case you prefer to use Java NIO instead of Java Networking (standard API), then you can also use a ServerSocketChannel instead of the java.net.ServerSocket.","(""ServerSocketChannel"", ""ServerSocketChannel is a part of Java NIO, which is an alternative to Java Networking"", ""Java NIO""); (""ServerSocket"", ""ServerSocket is a part of Java Networking, which is the standard API"", ""Java Networking""); (""ServerSocket"", ""ServerSocket is a class within the java.net package"", ""java.net"")"
In order to accept incoming connections you must call the ServerSocket.accept() method.,NULL
The accept() method returns a Socket which behaves like an ordinary Java Socket.,"(""Accept"", ""The accept() method returns a Socket, indicating a clear relationship between the Accept method and the Socket class."", ""Socket""); (""Socket"", ""The text mentions that the returned Socket behaves like an ordinary Java Socket, indicating a clear relationship between the Socket class and the Java Socket class."", ""Java Socket"")"
Only one incoming connection is opened for each call to the accept() method.,NULL
"Additionally, incoming connections can only be accepted while the thread running the server has called accept().",NULL
"In order to connect to a server over the internet (via TCP/IP) in Java, you need to create a java.net.Socket and connect it to the server.","(""java.net.Socket"", ""java.net.Socket is related to connect because it needs to be connected to the server using the connect method"", ""connect""); (""java.net"", ""java.net is related to java.net.Socket because java.net.Socket is a class within the java.net package"", ""java.net.Socket""); (""Java"", ""Java is related to java.net because java.net is a package in Java used for networking"", ""java.net""); (""Java"", ""Java is related to java.net.Socket because java.net.Socket is a class in Java used for creating sockets"", ""java.net.Socket"")"
This code example connects to the server with IP address 78.46.84.171 on port 80.,"(""Server"", ""The Server class is related to the Connect method because the code example connects to the server."", ""Connect""); (""Connect"", ""The Connect method is related to the Network package because it is used to establish a network connection to the server."", ""Network"")"
"Don't forget to call flush() when you really, really want the data sent across the internet to the server.",NULL
The getByName() method returns an InetAddress instance with the IP address matching the given host name.,NULL
Receiving data via a DatagramSocket is done by first creating a DatagramPacket and then receiving data into it via the DatagramSocket's receive() method.,"(""DatagramSocket"", ""The DatagramSocket and receive() are related because receive() is a method of the DatagramSocket class, indicating that the DatagramSocket uses the receive() method to receive data."", ""receive()""); (""DatagramSocket"", ""The DatagramSocket and DatagramPacket are related because a DatagramPacket is used in conjunction with a DatagramSocket to receive data, indicating a collaborative relationship between the two."", ""DatagramPacket"")"
"A real server program would probably call the receive() method in a loop, and pass all received DatagramPacket's to a pool of worker threads, just like a TCP server does with incoming connections (see Java Multithreaded Servers for more details).","(""Receive"", ""The receive() method is clearly related to DatagramPacket because it is used to receive DatagramPacket's""}"", ""DatagramPacket""); (""DatagramPacket"", ""DatagramPacket and Tcp are related because they are both used in the context of network programming and are compared in the text""}"", ""Tcp""); (""Receive"", ""The receive() method is related to Java Multithreaded Servers because the text mentions that a real server program would probably call the receive() method in a loop, similar to how a TCP server does with incoming connections, and refers to Java Multithreaded Servers for more details""}"", ""Java Multithreaded Servers""); (""DatagramPacket"", ""DatagramPacket is related to Java Multithreaded Servers because the text mentions passing all received DatagramPacket's to a pool of worker threads, which is a concept discussed in Java Multithreaded Servers""}"", ""Java Multithreaded Servers"")"
The java.net package contains two interesting classes: The URL class and the URLConnection class.,NULL
These classes can be used to create client connections to web servers (HTTP servers).,"(""Classes"", ""Classes are used to create client connections"", ""Client""); (""Classes"", ""Classes are used to create connections"", ""Connections""); (""Classes"", ""Classes can be used to create connections to web servers"", ""Web Servers""); (""Classes"", ""Classes can be used to create connections to HTTP servers"", ""HTTP Servers""); (""Client"", ""Client connections are created"", ""Connections""); (""Client"", ""Client connections are made to web servers"", ""Web Servers""); (""Client"", ""Client connections are made to HTTP servers"", ""HTTP Servers""); (""Connections"", ""Connections are made to web servers"", ""Web Servers""); (""Connections"", ""Connections are made to HTTP servers"", ""HTTP Servers"")"
"If you want to send an HTTP POST request instead, call the URLConnection.setDoOutput(true) method, like this:",NULL
The URL class can also be used to access files in the local file system.,NULL
"Thus the URL class can be a handy way to open a file, if you need your code to not know whether the file came from the network or local file system.","(""URL"", ""The URL class is related to the file because it can be used to open a file."", ""file""); (""URL"", ""The URL class is related to the network because it can open files from the network."", ""network""); (""URL"", ""The URL class is related to the local file system because it can open files from the local file system."", ""local file system""); (""file"", ""The file is related to the network because files can come from the network."", ""network""); (""file"", ""The file is related to the local file system because files can come from the local file system."", ""local file system"")"
Here is an example of how to open a file in the local file system using the URL class:,"(""Url"", ""The Url class is used to open a file, indicating a relationship between the Url class and the file"", ""File""); (""File"", ""The file is opened using the Url class, indicating a relationship between the file and the Url class"", ""Url""); (""Url"", ""The Url class is used in the context of the local file system, indicating a relationship between the Url class and the local file system"", ""Local File System"")"
"Notice how the only difference from accessing a file on a web server via HTTP is the the URL: ""file:/c:/data/test.txt"".","(""FILE"", ""The FILE and URL entities are related as the URL provides the location of the file."", ""URL"")"
"Even though the Java Networking APIs enable you to open and close network connections via sockets, all communication happens via the Java IO classes InputStream and OutputStream.","(""Java Networking APIs"", ""The Java Networking APIs enable communication via the Java IO classes, including InputStream."", ""InputStream""); (""Java Networking APIs"", ""The Java Networking APIs enable communication via the Java IO classes, including OutputStream."", ""OutputStream""); (""Java IO"", ""InputStream is a part of the Java IO package."", ""InputStream"")"
Alternatively you can use the networking classes in the Java NIO API.,NULL
"These classes are similar to the classes found in the Java Networking API, except the Java NIO API can work in non-blocking mode.","(""Java Networking API"", ""The Java NIO API is compared to the Java Networking API, indicating a relationship between the two packages."", ""Java NIO API""); (""classes"", ""The classes are found in the Java Networking API, indicating a relationship between the classes and the package."", ""Java Networking API"")"
The first parameter to the open() method is a Path instance pointing to the file the AsynchronousFileChannel is to be associated with.,"(""open"", ""The open method takes a Path instance as its first parameter, indicating a relationship between the open method and the Path class."", ""Path"")"
In this example we used the StandardOpenOption.READ which means that the file will be opened for reading.,"(""StandardOpenOption"", ""StandardOpenOption has a method READ which means that the file will be opened for reading."", ""READ""); (""java.nio.file"", ""StandardOpenOption belongs to the java.nio.file package."", ""StandardOpenOption"")"
Each way to read data call one of the read() methods of the AsynchronousFileChannel.,NULL
The first way to read data from an AsynchronousFileChannel is to call the read() method that returns a Future.,"(""AsynchronousFileChannel"", ""The AsynchronousFileChannel class has a read() method, indicating a relationship between the two."", ""read()""); (""read()"", ""The read() method returns a Future, indicating a relationship between the two."", ""Future"")"
This version of the read() method takes ByteBuffer as first parameter.,NULL
"The read() method return immediately, even if the read operation has not finished.",NULL
You can check the when the read operation is finished by calling the isDone() method of the Future instance returned by the read() method.,"(""Future"", ""The Future instance has an isDone() method, indicating a relationship between the two entities."", ""isDone()""); (""Future"", ""The Future instance is returned by the read() method, indicating a relationship between the two entities."", ""read()"")"
Here is a longer example showing how to use this version of the read() method:,NULL
"This example creates an AsynchronousFileChannel and then creates a ByteBuffer which is passed to the read() method as parameter, along with a position of 0.","(""AsynchronousFileChannel"", ""AsynchronousFileChannel uses the read() method to perform a read operation"", ""read()""); (""ByteBuffer"", ""ByteBuffer is passed as a parameter to the read() method"", ""read()"")"
After calling read() the example loops until the isDone() method of the returned Future returns true.,NULL
Once the read operation has completed the data read into the ByteBuffer and then into a String and printed to System.out .,"(""ByteBuffer"", ""The ByteBuffer is related to the String because the data read into the ByteBuffer is then converted into a String."", ""String""); (""String"", ""The String is related to System.out because the String is printed to System.out."", ""System.out"")"
The second method of reading data from an AsynchronousFileChannel is to call the read() method version that takes a CompletionHandler as a parameter.,"(""AsynchronousFileChannel"", ""The AsynchronousFileChannel class has a method called read(), indicating a relationship between the two."", ""read()""); (""read()"", ""The read() method takes a CompletionHandler as a parameter, showing a clear relationship between the read() method and the CompletionHandler class."", ""CompletionHandler"")"
Once the read operation finishes the CompletionHandler's completed() method will be called.,NULL
"As parameters to the completed() method are passed an Integer telling how many bytes were read, and the ""attachment"" which was passed to the read() method.","(""Completed"", ""The Completed method is related to the Read method because it is called as a result of the Read method, passing the attachment and the number of bytes read as parameters."", ""Read""); (""Completed"", ""The Completed method is related to the Integer class because an Integer object is passed to it, indicating the number of bytes read."", ""Integer""); (""Completed"", ""The Completed method is related to the Attachment class because the attachment object is passed to it, which was also passed to the Read method."", ""Attachment""); (""Read"", ""The Read method is related to the Integer class because the number of bytes read is returned as an Integer."", ""Integer"")"
"If the read operation fails, the failed() method of the CompletionHandler will get called instead.",NULL
Each way to write data call one of the write() methods of the AsynchronousFileChannel.,NULL
If the file does not exist the write() method will throw a java.nio.file.NoSuchFileException .,"(""Write"", ""The Write method will throw a NoSuchFileException if the file does not exist, indicating a clear relationship between the two entities."", ""NoSuchFileException""); (""Java.Nio.File"", ""The NoSuchFileException is part of the java.nio.file package, indicating a clear relationship between the two entities."", ""NoSuchFileException"")"
The CompletionHandler's completed() method will get called when the write operation completes.,NULL
"If the write fails for some reason, the failed() method will get called instead.",NULL
"Once you need to read the data, you need to switch the buffer from writing mode into reading mode using the flip() method call.",NULL
You can do this in two ways: By calling clear() or by calling compact().,NULL
The compact() method only clears the data which you have already read.,NULL
Here is an example that writes data into a Buffer via the put() method:,NULL
"There are many other versions of the put() method, allowing you to write data into the Buffer in many different ways.",NULL
The flip() method switches a Buffer from writing mode to reading mode.,NULL
"Calling flip() sets the position back to 0, and sets the limit to where position just was.","(""FLIP"", ""FLIP is related to POSITION because calling FLIP sets the position back to 0"", ""POSITION""); (""FLIP"", ""FLIP is related to LIMIT because calling FLIP sets the limit to where position just was"", ""LIMIT"")"
Here is an example that reads data from a Buffer using the get() method:,NULL
"There are many other versions of the get() method, allowing you to read data from the Buffer in many different ways.",NULL
"The Buffer.rewind() sets the position back to 0, so you can reread all the data in the buffer.",NULL
"The limit remains untouched, thus still marking how many elements (bytes, chars etc.)","(""Limit"", ""Limit is related to Elements because it marks how many elements are present"", ""Elements""); (""Elements"", ""Elements is related to Bytes because bytes are a type of element"", ""Bytes""); (""Elements"", ""Elements is related to Chars because chars are a type of element"", ""Chars""); (""Limit"", ""Limit is related to Bytes because it marks how many bytes are present"", ""Bytes"")"
You can do so either by calling clear() or by calling compact().,NULL
If you call clear() the position is set back to 0 and the limit to capacity.,"(""CLEAR"", ""The CLEAR method is related to the POSITION variable because calling CLEAR sets the position back to 0."", ""POSITION""); (""CLEAR"", ""The CLEAR method is related to the LIMIT variable because calling CLEAR sets the limit to capacity."", ""LIMIT"")"
"If there is any unread data in the Buffer when you call clear() that data will be ""forgotten"", meaning you no longer have any markers telling what data has been read, and what has not been read.",NULL
"If there is still unread data in the Buffer, and you want to read it later, but you need to do some writing first, call compact() instead of clear().","(""Buffer"", ""The Buffer class has a method called compact, indicating a relationship between the two."", ""compact""); (""Buffer"", ""The Buffer class has a method called clear, indicating a relationship between the two."", ""clear"")"
compact() copies all unread data to the beginning of the Buffer.,NULL
"The limit property is still set to capacity, just like clear() does.","(""Limit"", ""Limit and Clear are related because the limit property is still set to capacity, just like Clear does, indicating a functional relationship between the two"", ""Clear""); (""Limit"", ""Limit and Capacity are related because the limit property is set to capacity, indicating a direct relationship between the two properties"", ""Capacity"")"
You can mark a given position in a Buffer by calling the Buffer.mark() method.,"(""Buffer"", ""The Buffer class has a method called mark, indicating a relationship between the Buffer class and the mark method."", ""mark"")"
You can then later reset the position back to the marked position by calling the Buffer.reset() method.,"(""Buffer"", ""The Buffer class has a relationship with the Buffer.reset method because the method is called on the Buffer class."", ""Buffer.reset"")"
It is possible to compare two buffers using equals() and compareTo().,NULL
The FileChannel class has a transferTo() and a transferFrom() method which does this for you.,"(""FileChannel"", ""The FileChannel class has a transferTo() method, indicating a relationship between the class and the method."", ""transferTo()"")"
The FileChannel.transferFrom() method transfers data from a source channel into the FileChannel.,NULL
The transferTo() method transfer from a FileChannel into some other channel.,NULL
The issue with SocketChannel is also present with the transferTo() method.,NULL
"You receive data from a DatagramChannel by calling its receive() method, like this:",NULL
The receive() method will copy the content of a received packet of data into the given Buffer.,NULL
"You can send data via a DatagramChannel by calling its send() method, like this:",NULL
"When connected you can also use the read() and write() method, as if you were using a traditional channel.",NULL
The Java NIO FileChannel class is NIO's an alternative to reading files with the standard Java IO API.,"(""Java NIO FileChannel"", ""The Java NIO FileChannel class is an alternative to the standard Java IO API, indicating a relationship between the two."", ""Java IO"")"
To read data from a FileChannel you call one of the read() methods.,NULL
The int returned by the read() method tells how many bytes were written into the Buffer.,NULL
"Writing data to a FileChannel is done using the FileChannel.write() method, which takes a Buffer as parameter.","(""FileChannel"", ""The FileChannel class contains the write() method, indicating a strong relationship between the two entities as the write() method is used for writing data to a FileChannel."", ""write()""); (""write()"", ""The write() method takes a Buffer as a parameter, showing a clear relationship between the write() method and the Buffer class, as the Buffer is used as input for the write() operation."", ""Buffer"")"
There is no guarantee of how many bytes the write() method writes to the FileChannel.,NULL
Therefore we repeat the write() call until the Buffer has no further bytes to write.,NULL
You can obtain the current position of the FileChannel object by calling the position() method.,NULL
The size() method of the FileChannel object returns the file size of the file the channel is connected to.,NULL
The FileChannel.force() method flushes all unwritten data from the channel to the disk.,NULL
"An operating system may cache data in memory for performance reasons, so you are not guaranteed that data written to the channel is actually written to disk, until you call the force() method.","(""Operating System"", ""The operating system uses memory for caching data for performance reasons."", ""Memory""); (""Operating System"", ""The operating system writes data to the channel."", ""Channel""); (""Channel"", ""The force() method is called on the channel to guarantee data is written to disk."", ""Force()"")"
"The force() method takes a boolean as parameter, telling whether the file meta data (permission etc.)",NULL
The Java NIO Files class (java.nio.file.Files) provides several methods for manipulating files in the file system.,"(""Java NIO Files"", ""Java NIO Files is another name for the Files class"", ""Files""); (""Java NIO Files"", ""Java NIO Files is the same as the java.nio.file.Files class"", ""java.nio.file.Files""); (""Files"", ""Files is the same as the java.nio.file.Files class"", ""java.nio.file.Files""); (""Java NIO Files"", ""The Java NIO Files class provides methods for manipulating files"", ""manipulating files""); (""Files"", ""The Files class provides methods for manipulating files"", ""manipulating files"")"
"The Files class contains many methods, so check the JavaDoc too, if you need a method that is not described here.",NULL
The Files class just might have a method for it still.,NULL
"The java.nio.file.Files class works with java.nio.file.Path instances, so you need to understand the Path class before you can work with the Files class.","(""Java.Nio.File.Files"", ""The java.nio.file.Files class works with java.nio.file.Path instances"", ""Java.Nio.File.Path"")"
The Files.exists() method checks if a given Path exists in the file system.,"(""Files"", ""The exists() method is part of the Files class, indicating a strong relationship between the two entities."", ""exists()""); (""exists()"", ""The exists() method checks if a given Path exists, suggesting that the method operates on or is related to the Path entity."", ""Path"")"
"Since Path instances may or may not point to paths that exist in the file system, you can use the Files.exists() method to determine if they do (in case you need to check that).","(""Path"", ""Path instances can use the Files.exists() method to determine if a path exists in the file system"", ""Files.exists()""); (""Files"", ""Files exists as a class that contains the exists() method"", ""Files.exists()"")"
"Second, the example calls the Files.exists() method with the Path instance as the first parameter.","(""Files"", ""Files is the class that contains the exists() method"", ""exists()""); (""exists()"", ""The exists() method takes an instance of Path as its first parameter, indicating a relationship between the method and the class"", ""Path"")"
This parameter is an array of options that influence how the Files.exists() determines if the path exists or not.,NULL
In this example above the array contains the LinkOption.NOFOLLOW_LINKS which means that the Files.exists() method should not follow symbolic links in the file system to determine if the path exists.,"(""LinkOption"", ""NOFOLLOW_LINKS is a static field of the LinkOption class, indicating a relationship between them"", ""NOFOLLOW_LINKS""); (""Files"", ""The exists method is a part of the Files class, indicating a relationship between them"", ""exists"")"
The Files.createDirectory() method creates a new directory from a Path instance.,"(""Files"", ""The Files class contains the createDirectory() method, indicating a relationship between the two."", ""createDirectory()"")"
Inside the try-catch block the Files.createDirectory() method is called with the path as parameter.,"(""Files"", ""The Files class contains the createDirectory method, indicating a clear relationship between the two entities as the method is part of the class."", ""createDirectory""); (""try-catch"", ""The try-catch block is related to the Files class because it is used to handle potential exceptions when calling a method of the Files class, such as createDirectory."", ""Files"")"
The Files.copy() method copies a file from one path to another.,NULL
"Then the example calls Files.copy(), passing the two Path instances as parameters.","(""Files"", ""Files is the class that contains the copy method"", ""copy""); (""copy"", ""The copy method is passing Path instances as parameters, indicating a relationship between the method and the class"", ""Path"")"
It is possible to force the Files.copy() to overwrite an existing file.,NULL
Here an example showing how to overwrite an existing file using Files.copy():,NULL
This parameter instructs the copy() method to overwrite an existing file if the destination file already exists.,"(""Copy"", ""The Copy method is related to the Parameter because the parameter instructs the Copy method to perform a specific action."", ""Parameter""); (""Copy"", ""The Copy method is related to the Destination because the method overwrites the destination file if it already exists."", ""Destination"")"
The Java NIO Files class also contains a function for moving files from one path to another.,"(""Java NIO Files"", ""Java NIO Files contains or is related to the Files class"", ""Files""); (""Files"", ""The Files class contains a function for moving files from one path to another"", ""function"")"
"Yes, the java.io.File class could also do that with its renameTo() method, but now you have the file move functionality in the java.nio.file.Files class too.",NULL
This parameter tells the Files.move() method to overwrite any existing file at the destination path.,NULL
The Files.move() method may throw an IOException if moving the file fails.,"(""FILES"", ""The Files class contains the move method"", ""MOVE"")"
"For instance, if a file already exists at the destination path, and you have left out the StandardCopyOption.REPLACE_EXISTING option, or if the file to move does not exist etc.",NULL
If the Files.delete() fails to delete the file for some reason (e.g.,NULL
The Files.walkFileTree() method contains functionality for traversing a directory tree recursively.,NULL
The walkFileTree() method takes a Path instance and a FileVisitor as parameters.,"(""WalkFileTree"", ""The WalkFileTree method takes a Path instance as a parameter, indicating a relationship between them"", ""Path"")"
"You have to implement the FileVisitor interface yourself, and pass an instance of your implementation to the walkFileTree() method.",NULL
"If you do not need to hook into all of these methods, you can extend the SimpleFileVisitor class, which contains default implementations of all methods in the FileVisitor interface.",NULL
The visitFile() mehtod is called for every file visited during the file walk.,NULL
The visitFileFailed() method is called in case visiting a file fails.,NULL
Here is a walkFileTree() that extends SimpleFileVisitor to look for a file named README.txt :,"(""WalkFileTree"", ""WalkFileTree extends SimpleFileVisitor, indicating a clear inheritance relationship between the two classes"", ""SimpleFileVisitor""); (""WalkFileTree"", ""WalkFileTree is designed to look for a file named Readme.txt, indicating a clear association between the class and the file"", ""Readme.txt"")"
The Files.walkFileTree() can also be used to delete a directory with all files and subdirectories inside it.,NULL
The Files.delete() method will only delete a directory if it is empty.,NULL
"By walking through all directories and deleting all files (inside visitFile()) in each directory, and afterwards delete the directory itself (inside postVisitDirectory()) you can delete a directory with all subdirectories and files.",NULL
"The java.nio.file.Files class contains many other useful functions, like functions for creating symbolic links, determining the file size, setting file permissions etc.","(""Java.Nio.File.Files"", ""Java.Nio.File.Files is a class contained within the Java.Nio.File package"", ""Java.Nio.File""); (""Java.Nio.File.Files"", ""Java.Nio.File.Files contains the method Creating_Symbolic_Links"", ""Creating_Symbolic_Links""); (""Java.Nio.File.Files"", ""Java.Nio.File.Files contains the method Determining_File_Size"", ""Determining_File_Size"")"
Check out the JavaDoc for the java.nio.file.Files class for more information about these methods.,NULL
And that is before the server has used any memory for processing the incoming messages (e.g.,NULL
"To keep the number of threads down, many servers use a design where the server keeps a pool of threads (e.g.",NULL
When you call select() or selectNow() on the Selector it gives you only the SelectableChannel instances that actually has data to read.,"(""Selector"", ""The Selector class has a method called select, indicating a relationship between the two."", ""select""); (""Selector"", ""The Selector class has a method called selectNow, indicating a relationship between the two."", ""selectNow""); (""Selector"", ""The Selector class returns SelectableChannel instances, indicating a relationship between the two."", ""SelectableChannel""); (""select"", ""The select method returns SelectableChannel instances, indicating a relationship between the two."", ""SelectableChannel"")"
"A data block could potentially contain a partial message (less than a message), a full message, or more than a message, for instance 1.5 or 2.5 messsages.","(""DATA BLOCK"", ""A data block could potentially contain a partial message, a full message, or more than a message, which implies a relationship between the two."", ""MESSAGE"")"
The first way to implement a resizable buffer is to start with a small buffer of e.g.,NULL
"If a message cannot fit into the 4KB buffer, a larger buffer of e.g.",NULL
For 1.000.000 concurrent connections that results in 1.000.000 x 4KB = 4GB which is possible in most servers today (2015).,NULL
Another workaround is to time out messages which have not been received within e.g.,NULL
The fact that TLV encodings makes memory management easier is one of the reasons why HTTP 1.1 is such a terrible protocol.,NULL
That is one of the problems they are trying to fix in HTTP 2.0 where data is transported in LTV encoded frames.,"(""HTTP"", ""HTTP 2.0 is a version of the HTTP protocol, indicating a relationship between the two entities"", ""HTTP 2.0"")"
This is also why we have designed our own network protocol for our VStack.co project that uses a TLV encoding.,"(""VStack.co"", ""VStack.co uses a network protocol"", ""network protocol"")"
Imagine if you have 1.000.000 connections which are mostly idle and all 1.000.000 connections were registered with the Selector.,"(""Selector"", ""The Selector is related to connections because it is used to manage and register a large number of connections."", ""connections""); (""register"", ""The register method is related to connections because it is used to add connections to the Selector for management."", ""connections"")"
"Then, when you call select() most of these Channel instances would be write-ready (they are mostly idle, remember?).",NULL
"Java NIO has more classes and components than these, but the Channel, Buffer and Selector forms the core of the API, in my opinion.","(""Channel"", ""Channel is part of the Java NIO package"", ""Java NIO""); (""Buffer"", ""Buffer is part of the Java NIO package"", ""Java NIO""); (""Selector"", ""Selector is part of the Java NIO package"", ""Java NIO""); (""Channel"", ""Channel and Buffer are related as they are both core components of the Java NIO API"", ""Buffer""); (""Channel"", ""Channel and Selector are related as they are both core components of the Java NIO API"", ""Selector"")"
"The rest of the components, like Pipe and FileLock are merely utility classes to be used in conjunction with the three core components.",NULL
"There are a few interesting interfaces accompanying these classes too, but I'll keep them out of this Java NIO overview for simplicity's sake.","(""Java NIO"", ""Java NIO is related to classes because it is mentioned as being accompanied by these classes in the provided text"", ""classes""); (""Java NIO"", ""Java NIO is related to interfaces because it is mentioned as being accompanied by these interfaces in the provided text"", ""interfaces"")"
"The Path interface is located in the java.nio.file package, so the fully qualified name of the Java Path interface is java.nio.file.Path.",NULL
The java.nio.file.Path interface has nothing to do with the path environment variable.,NULL
"In many ways the java.nio.file.Path interface is similar to the java.io.File class, but there are some minor differences.",NULL
"In many cases though, you can replace the use of the File class with use of the Path interface.",NULL
In order to use a java.nio.file.Path instance you must create a Path instance.,NULL
You create a Path instance using a static method in the Paths class (java.nio.file.Paths) named Paths.get().,"(""PATHS"", ""PATHS is the class that contains the static method PATHS.GET"", ""PATHS.GET""); (""PATHS"", ""PATHS is a part of the JAVA.NIO.FILE package"", ""JAVA.NIO.FILE"")"
To use the Path interface and the Paths class we must first import them.,"(""Path"", ""Both Path and Paths are related as they are used together in the same context, with Paths being a class and Path being an interface, and are imported at the same time."", ""Paths"")"
It is the call to the Paths.get() method that creates the Path instance.,"(""Paths"", ""The Paths class contains the get method"", ""get"")"
"The Paths.get() method is a factory method for Path instances, in other words.","(""Paths"", ""The get() method is a part of the Paths class, indicating a relationship between the two entities."", ""get()""); (""Paths"", ""The Paths class has a factory method get() that returns Path instances, establishing a relationship between the Paths class and the Path class."", ""Path"")"
Creating an absolute path is done by calling the Paths.get() factory method with the absolute file as parameter.,NULL
The Java NIO Path class can also be used to work with relative paths.,"(""Java NIO Path"", ""The Java NIO Path class is part of the Java NIO package, indicating a relationship between the Java NIO Path class and the Java NIO package"", ""Java NIO"")"
The second example creates a Path instance which points to the path (file) d:\data\projects\a-project\myfile.txt .,"(""Path"", ""The Path class is related to the instance because an instance of the Path class is created."", ""instance""); (""Path"", ""The Path class is related to the file d:\data\projects\a-project\myfile.txt because the Path instance points to this file."", ""d:\data\projects\a-project\myfile.txt"")"
If you use the .. code in the middle of a path string it will correspond to changing one directory up at that point in the path string.,NULL
The .. code after the a-project directory changes directory up the the parent directory projects and then the path references down into the another-project directory from there.,NULL
and .. codes also work in combination with the two-string Paths.get() method.,NULL
Here are two Java Paths.get() examples showing simple examples of that:,"(""Paths"", ""The Paths class contains the get method, indicating a clear relationship between the two entities as the get method is a part of the Paths class."", ""get""); (""Java"", ""The Java package is likely related to the Paths class, as Java is the programming language in which the Paths class is used."", ""Paths"")"
There are more ways that the Java NIO Path class can be used to work with relative paths.,"(""Java"", ""Java is related to NIO because NIO is a package in Java"", ""NIO""); (""NIO"", ""NIO is related to Path because Path is a class in the NIO package"", ""Path"")"
The Java Path method relativize() can create a new Path which represents the second Path relative to the first Path.,"(""Java"", ""The Java package contains the Path class"", ""Path""); (""Path"", ""The Path class contains the relativize() method"", ""relativize()"")"
"For instance, with the path /data and /data/subdata/subsubdata/myfile.txt"", the second path can be expressed as /subdata/subsubdata/myfile.txt relative to the first path.","(""PATH"", ""PATH is related to /DATA because it contains the path /data"", ""/DATA""); (""/DATA"", ""/DATA is related to /SUBDATA because /SUBDATA is a subdirectory of /DATA"", ""/SUBDATA""); (""/SUBDATA"", ""/SUBDATA is related to /SUBSUBDATA because /SUBSUBDATA is a subdirectory of /SUBDATA"", ""/SUBSUBDATA""); (""/SUBSUBDATA"", ""/SUBSUBDATA is related to MYFILE.TXT because MYFILE.TXT is a file in the /SUBSUBDATA directory"", ""MYFILE.TXT""); (""PATH"", ""PATH is related to /SUBDATA because it contains the path /data/subdata"", ""/SUBDATA""); (""PATH"", ""PATH is related to /SUBSUBDATA because it contains the path /data/subdata/subsubdata"", ""/SUBSUBDATA"")"
"If you add the relative path subdata/subsubdata/myfile.txt to the directory path /data, you get the full path /data/subdata/subsubdata/myfile.txt.","(""SUBDATA"", ""SUBSUBDATA is a subdirectory of SUBDATA"")
{completion_delimiter}

The final answer is:
(""entity"",""SUBDATA"",""package"", ""SUBSUBDATA"")"
If you you add the relative path ../../.. to the full file path /data/subdata/subsubdata/myfile.txt then you get /data,"(""Relative Path"", ""The relative path is added to the full file path to get the new path"", ""Full File Path""); (""File Path"", ""The file path is part of the full file path"", ""Full File Path"")"
The normalize() method of the Path interface can normalize a path.,"(""Path"", ""The normalize() method is a part of the Path interface, indicating a clear relationship between the two."", ""normalize()""); (""Path interface"", ""The Path interface contains or is related to the Path class, indicating a relationship between the package and the class."", ""Path"")"
"and .. codes in the middle of the path string, and resolves what path the path string refers to.",NULL
This Path example first creates a path string with a .. code in the middle.,"(""Path"", ""The Path class is related to the example because the example is an instance of the Path class."", ""example"")"
"Then the example creates a Path instance from this path string, and prints that Path instance out (actually it prints Path.toString()).","(""Path"", ""The Path class has a toString method, so they are related as the method belongs to the class."", ""toString"")"
"The example then calls normalize() on the created Path instance, which returns a new Path instance.","(""Path"", ""The Path class has a method called normalize(), which establishes a relationship between the two."", ""normalize()""); (""Path"", ""The Path class is related to the instance entity because an instance of the Path class is created, indicating a connection between the class and its instance."", ""instance"")"
"As you can see, the normalized path does not contain the a-project\.. part, as this is redundant.",NULL
"You write to a SinkChannel by calling it's write() method, like this:",NULL
To read from the source channel you call its read() method like this:,NULL
The int returned by the read() method tells how many bytes were read into the buffer.,NULL
"Notice how the buffers are first inserted into an array, then the array passed as parameter to the channel.read() method.","(""Buffers"", ""The buffers are first inserted into an array, indicating a relationship between the Buffers and the Array."", ""Array""); (""Array"", ""The array is passed as a parameter to the channel, indicating a relationship between the Array and the Channel."", ""Channel""); (""Channel"", ""The channel has a method called read, indicating a relationship between the Channel and its method Channel.Read."", ""Channel.Read"")"
The read() method then writes data from the channel in the sequence the buffers occur in the array.,"(""Read"", ""The read() method writes data from the channel, indicating a relationship between the two."", ""Channel""); (""Channel"", ""The buffers occur in the array in the sequence, and data is written from the channel, indicating a relationship between the channel and the sequence of buffers."", ""Buffers"")"
"In other words, if you have a header and a body, and the header is fixed size (e.g.",NULL
"The array of buffers are passed into the write() method, which writes the content of the buffers in the sequence they are encountered in the array.","(""Array"", ""The array contains buffers, indicating a relationship between the two entities."", ""Buffers""); (""Array"", ""The array of buffers is passed into the write method, indicating that the array is the source and the write method is the target."", ""Write"")"
"The Java NIO Selector is a component which can examine one or more Java NIO Channel instances, and determine which channels are ready for e.g.","(""Java NIO Selector"", ""The Java NIO Selector can examine one or more Java NIO Channel instances, indicating a relationship between the two entities"", ""Java NIO Channel""); (""Java NIO"", ""The Java NIO Selector is a part of the Java NIO package, indicating a relationship between the two entities"", ""Java NIO Selector"")"
"You create a Selector by calling the Selector.open() method, like this:","(""Selector"", ""The Selector class has a relationship with the Selector.open() method because the method is called on the Selector class to create a new Selector."", ""Selector.open()"")"
"As you saw in the previous section, when you register a Channel with a Selector the register() method returns a SelectionKey objects.","(""Channel"", ""A Channel is registered with a Selector, indicating a relationship between the two classes."", ""Selector""); (""Channel"", ""The register method of a Selector returns a SelectionKey object when a Channel is registered, establishing a connection between the Channel and SelectionKey classes."", ""SelectionKey""); (""Selector"", ""The register method of a Selector returns a SelectionKey object, indicating a relationship between the Selector and SelectionKey classes."", ""SelectionKey""); (""register"", ""The register method is used to register a Channel with a Selector, showing a relationship between the register method and the Channel class."", ""Channel""); (""register"", ""The register method is a part of the Selector, showing a relationship between the register method and the Selector class."", ""Selector"")"
"You can also attach an object already while registering the Channel with the Selector, in the register() method.","(""Channel"", ""The Channel is related to the Selector because it is registered with the Selector using the register() method."", ""Selector""); (""Channel"", ""The Channel is related to the register() method because the Channel is registered using this method."", ""register"")"
Once you have register one or more channels with a Selector you can call one of the select() methods.,"(""Selector"", ""The Selector class has a select() method that can be called"", ""select()""); ("" channels"", ""Channels are registered with a Selector"", ""Selector""); (""register"", ""The register method is used to register one or more channels"", ""channels"")"
"In other words, if you are interested in channels that are ready for reading, you will receive the channels that are ready for reading from the select() methods.",NULL
select() blocks until at least one channel is ready for the events you registered for.,NULL
select(long timeout) does the same as select() except it blocks for a maximum of timeout milliseconds (the parameter).,"(""SELECT"", ""SELECT method is related to TIMEOUT variable because it uses the TIMEOUT variable as a parameter to specify the maximum time to block"", ""TIMEOUT"")"
The int returned by the select() methods tells how many channels are ready.,NULL
"That is, how many channels that became ready since last time you called select().",NULL
"If you call select() and it returns 1 because one channel has become ready, and you call select() one more time, and one more channel has become ready, it will return 1 again.",NULL
"If you have done nothing with the first channel that was ready, you now have 2 ready channels, but only one channel had become ready between each select() call.",NULL
"Once you have called one of the select() methods and its return value has indicated that one or more channels are ready, you can access the ready channels via the ""selected key set"", by calling the selectors selectedKeys() method.","(""SELECTORS"", ""The source entity SELECTORS and the target entity SELECT are related because the text mentions calling one of the select() methods, which implies that SELECT is a part of or associated with SELECTORS."", ""SELECT""); (""SELECTORS"", ""The source entity SELECTORS and the target entity SELECTEDKEYS are related because the text mentions calling the selectors selectedKeys() method, which implies that SELECTEDKEYS is a method of SELECTORS."", ""SELECTEDKEYS"")"
When you register a channel with a Selector the Channel.register() method returns a SelectionKey object.,"(""Channel"", ""The Channel is registered with the Selector, indicating a relationship between the two classes."", ""Selector""); (""Channel.register()"", ""The Channel.register() method returns a SelectionKey object, indicating that the method is related to the SelectionKey class."", ""SelectionKey""); (""Channel"", ""The Channel class has a register() method, indicating a relationship between the class and the method."", ""Channel.register()"")"
It is these keys you can access via the selectedKeySet() method.,NULL
"The channel returned by the SelectionKey.channel() method should be cast to the channel you need to work with, e.g a ServerSocketChannel or SocketChannel etc.","(""SelectionKey"", ""The SelectionKey class has a method called SelectionKey.channel()"", ""SelectionKey.channel()""); (""SelectionKey.channel()"", ""The SelectionKey.channel() method returns a channel that can be cast to a ServerSocketChannel"", ""ServerSocketChannel"")"
"A thread that has called the select() method which is blocked, can be made to leave the select() method, even if no channels are yet ready.",NULL
This is done by having a different thread call the Selector.wakeup() method on the Selector which the first thread has called select() on.,"(""Selector"", ""The Selector class has a method called Selector.wakeup(), indicating a relationship between the class and the method."", ""Selector.wakeup()""); (""Selector"", ""The Selector class has a method called select(), indicating a relationship between the class and the method."", ""select()"")"
"If a different thread calls wakeup() and no thread is currently blocked inside select(), the next thread that calls select() will ""wake up"" immediately.",NULL
When you are finished with the Selector you call its close() method.,NULL
Listening for incoming connections is done by calling the ServerSocketChannel.accept() method.,NULL
"When the accept() method returns, it returns a SocketChannel with an incoming connection.",NULL
"Since you are typically not interested in listening just for a single connection, you call the accept() inside a while-loop.",NULL
"In non-blocking mode the accept() method returns immediately, and may thus return null, if no incoming connection had arrived.",NULL
You close a SocketChannel after use by calling the SocketChannel.close() method.,"(""SocketChannel"", ""The SocketChannel class has a method called SocketChannel.close(), indicating a relationship between the class and the method."", ""SocketChannel.close()"")"
To read data from a SocketChannel you call one of the read() methods.,NULL
The int returned by the read() method tells how many bytes were witten into the Buffer.,NULL
"Writing data to a SocketChannel is done using the SocketChannel.write() method, which takes a Buffer as parameter.","(""SocketChannel"", ""The SocketChannel class has a SocketChannel.write() method, indicating a clear relationship between the class and the method."", ""SocketChannel.write()""); (""SocketChannel.write()"", ""The SocketChannel.write() method takes a Buffer as a parameter, indicating a clear relationship between the method and the Buffer class."", ""Buffer"")"
There is no guarantee of how many bytes the write() method writes to the SocketChannel.,NULL
"When you do so, you can call connect(), read() and write() in asynchronous mode.","(""Connect"", ""These methods are related as they are all mentioned together as being callable in asynchronous mode."", ""Read""); (""Connect"", ""These methods are related as they are all mentioned together as being callable in asynchronous mode."", ""Write"")"
"If the SocketChannel is in non-blocking mode, and you call connect(), the method may return before a connection is established.","(""SocketChannel"", ""The SocketChannel class has a method called connect, which is used to establish a connection."", ""connect""); (""connect"", ""The connect method behaves differently when the SocketChannel is in non-blocking mode, it may return before a connection is established."", ""non-blocking mode"")"
"To determine whether the connection is established, you can call the finishConnect() method, like this:",NULL
In non-blocking mode the write() method may return without having written anything.,NULL
Therefore you need to call the write() method in a loop.,NULL
In non-blocking mode the read() method may return without having read any data at all.,NULL
"Also, parts of the NIO APIs are actually blocking - e.g.",NULL
"A selector is an object that can monitor multiple channels for events (like: connection opened, data arrived etc.).","(""Selector"", ""A selector can monitor multiple channels for events, indicating a relationship between the two entities."", ""Channel""); (""Selector"", ""A selector can monitor multiple channels for events, indicating that the selector is related to the events that occur on those channels."", ""Events""); (""Channel"", ""Channels have events such as connection opened, data arrived, indicating a relationship between channels and events."", ""Events"")"
"That means, that when a thread invokes a read() or write(), that thread is blocked until there is some data to read, or the data is fully written.","(""THREAD"", ""A thread invokes a read() method, which means the thread and the read method are related as the thread is the one performing the invocation."", ""READ"")"
Rather than just read the data byte for byte from e.g.,NULL
"In other words, once the first reader.readLine() method returns, you know for sure that a full line of text has been read.",NULL
"The readLine() blocks until a full line is read, that's why.",NULL
"Similarly, when the second readLine() call returns, you know that this line contains the age etc.",NULL
"The bufferFull() method has to keep track of how much data is read into the buffer, and return either true or false, depending on whether the buffer is full.",NULL
"The bufferFull() method scans through the buffer, but must leave the buffer in the same state as before the bufferFull() method was called.",NULL
"Similarly, if you need to keep a lot of open connections to other computers, e.g.",NULL
"If you have fewer connections with very high bandwidth, sending a lot of data at a time, perhaps a classic IO server implementation might be the best fit.","(""IO"", ""The IO and Server entities are related because an IO server implementation is mentioned in the text, indicating a connection between the two entities."", ""Server""); (""Server"", ""The Server and Implementation entities are related because the text mentions a classic IO server implementation, suggesting that the server is being implemented in some way."", ""Implementation"")"
Using Java Reflection you can access the annotations attached to Java classes at runtime.,"(""Java Reflection"", ""Java Reflection is a part of the Java package, and thus they are related as Java Reflection is utilizing Java"", ""Java""); (""Java Reflection"", ""Java Reflection is used to access the annotations attached to Java classes at runtime, so they are related as Java Reflection is used to access annotations"", ""annotations"")"
"You can also specify METHOD or FIELD, or you can leave the target out alltogether so the annotation can be used for both classes, methods and fields.",NULL
"You can access the annotations of a class, method or field at runtime.","(""Class"", ""Both are accessible at runtime, which suggests they have a related functionality"", ""Method""); (""Class"", ""Both are accessible at runtime, which suggests they have a related functionality"", ""Field"")"
"Notice how the Method.getParameterAnnotations() method returns a two-dimensional Annotation array, containing an array of annotations for each method parameter.","(""Method"", ""The Method entity is related to the getParameterAnnotations entity because getParameterAnnotations is a method of the Method class."", ""getParameterAnnotations""); (""getParameterAnnotations"", ""The getParameterAnnotations entity is related to the Annotation entity because getParameterAnnotations returns a two-dimensional array of Annotation."", ""Annotation"")"
This text will discuss how to both create arrays and get their class objects via Java Reflection.,"(""Java Reflection"", ""Java Reflection is related to Arrays because Java Reflection can be used to get the class objects of Arrays"", ""Arrays""); (""create arrays"", ""create arrays is related to Arrays because it is a method that can be used to create Arrays"", ""Arrays""); (""get their class objects"", ""get their class objects is related to Arrays because it is a method that can be used to get the class objects of Arrays"", ""Arrays""); (""Java Reflection"", ""Java Reflection is related to create arrays because Java Reflection can be used to get information about the arrays created by this method"", ""create arrays"")"
Working with arrays via Java Reflection is done using the java.lang.reflect.Array class.,"(""java.lang.reflect.Array"", ""java.lang.reflect.Array is part of the java.lang.reflect package"", ""java.lang.reflect""); (""Java"", ""Java is the language that java.lang.reflect.Array is a part of"", ""java.lang.reflect.Array""); (""Java"", ""Java is the language that java.lang.reflect is a part of"", ""java.lang.reflect"")"
"Do not confuse this class with the java.util.Arrays class in the Java Collections suite, which contains utility methods for sorting arrays, converting them to collections etc.","(""java.util.Arrays"", ""java.util.Arrays is part of the Java Collections suite"", ""Java Collections""); (""java.util.Arrays"", ""java.util.Arrays contains utility methods for sorting arrays"", ""sorting arrays""); (""java.util.Arrays"", ""java.util.Arrays contains utility methods for converting arrays to collections"", ""converting them to collections"")"
Creating arrays via Java Reflection is done using the java.lang.reflect.Array class.,"(""Java Reflection"", ""Java Reflection is related to java.lang.reflect.Array because it uses this class for creating arrays"", ""java.lang.reflect.Array""); (""java.lang.reflect.Array"", ""java.lang.reflect.Array is related to java.lang.reflect because it is a part of this package"", ""java.lang.reflect"")"
The first parameter int.class given to the Array.newInstance() method tells what type each element in the array should be of.,NULL
"For instance, you can access the primitive int array class object like this:","(""Int"", ""The Int class is related to the array because it is used to access the primitive int array class object"", ""array"")"
The [ on the left means it is the class of an int array I am interested in.,NULL
"Notice the [L to the left of the class name, and the ; to the right.",NULL
"As a side note, you cannot obtain the class object of primitives using Class.forName().",NULL
I usually do something like this to obtain the class name for primitives as well as objects:,"(""Class"", ""A class can contain one or more methods, thus they are related."", ""Method""); (""Class"", ""A class is often part of a package, thus they are related."", ""Package"")"
"The solution, or workaround as you might call it, is to create an empty array of the desired type and obtain the class object from that empty array.","(""Solution"", ""The solution uses an array to achieve the desired outcome"", ""Array""); (""Array"", ""The array is part of the workaround to create an empty array of the desired type"", ""Workaround"")"
"This presents a single, uniform method to access the array class of arrays of any type.",NULL
"To make sure that the Class object really is an array, you can call the Class.isArray() method to check:",NULL
Once you have obtained the Class object for an array you can access its component type via the Class.getComponentType() method.,NULL
"For instance, the component type of an int[] array is the int.class Class object.","(""Int[]"", ""The Int[] array has a component type of Int, indicating a relationship between the two."", ""Int""); (""Int[]"", ""The Int[] array has a class type that is represented by the Class object, indicating a relationship between the two."", ""Class"")"
The component type of a String[] array is the java.lang.String Class object.,"(""java.lang"", ""java.lang is the package of java.lang.String as indicated by the package name prefix"", ""java.lang.String""); (""String"", ""String is related to java.lang.String because String is a shorthand for the fully qualified class name java.lang.String"", ""java.lang.String"")"
"This example will print out the text ""java.lang.String"" which is the component type of the String array.","(""java.lang"", ""java.lang is the package that contains the java.lang.String class"", ""java.lang.String"")"
Inspecting classes is often the first thing you do when using Reflection.,"(""Inspecting"", ""Inspecting is related to classes because it is an action performed on classes"", ""classes""); (""classes"", ""classes are related to Reflection because Reflection is used to inspect classes"", ""Reflection"")"
For a full list you should consult the JavaDoc for java.lang.Class.,"(""java.lang.Class"", ""java.lang.Class is related to JavaDoc because the JavaDoc is consulted for information about java.lang.Class"", ""JavaDoc"")"
Before you can do any inspection on a class you need to obtain its java.lang.Class object.,NULL
"All types in Java including the primitive types (int, long, float etc.)","(""Java"", ""Java includes the primitive types"", ""primitive types""); (""Java"", ""Java includes the int type"", ""int""); (""Java"", ""Java includes the long type"", ""long""); (""Java"", ""Java includes the float type"", ""float""); (""primitive types"", ""primitive types include the int type"", ""int""); (""primitive types"", ""primitive types include the long type"", ""long"")"
If you know the name of the class at compile time you can obtain a Class object like this:,"(""Class"", ""The source entity Class and target entity getName are related because getName is a method of the Class class."", ""getName"")"
"If you don't know the name at compile time, but have the class name as a string at runtime, you can do like this:","(""Class"", ""Class is related to Compile because Compile is a time when the Class name is being referenced"", ""Compile""); (""Class"", ""Class is related to String because the class name is being stored as a String at runtime"", ""String""); (""Class"", ""Class is related to Runtime because the class name is being used at Runtime"", ""Runtime""); (""Compile"", ""Compile is related to Runtime because Compile time is contrasted with Runtime"", ""Runtime"")"
String className = ... //obtain class name as string at runtime Class class = Class.forName(className);,"(""String"", ""String is related to Class because String is used to obtain the class name as a string, which is then used to create a Class object using the forName method."", ""Class""); (""Class"", ""Class is related to Class.forName because Class.forName is a static method of the Class class, used to create a Class object."", ""Class.forName"")"
When using the Class.forName() method you must supply the fully qualified class name.,NULL
The Class.forName() method may throw a ClassNotFoundException if the class cannot be found on the classpath at runtime.,"(""Class"", ""The Class.forName() method is a part of the Class entity, indicating a strong relationship between the two."", ""forName""); (""Class"", ""The Class entity is related to the ClassNotFoundException entity because the Class.forName() method may throw a ClassNotFoundException."", ""ClassNotFoundException"")"
The fully qualified class name (including package name) is obtained using the getName() method like this:,"(""Class"", ""A class is typically part of a package, and the fully qualified class name includes the package name."", ""Package""); (""Class"", ""The getName() method is used to obtain the fully qualified class name."", ""getName()"")"
"If you want the class name without the pacakge name you can obtain it using the getSimpleName() method, like this:","(""Class"", ""The class name can be obtained without the package name using the getSimpleName() method, indicating a relationship between the class and the getSimpleName() method."", ""GetSimpleName""); (""Class"", ""The class is related to the package as it can be identified with or without the package name, showing a relationship between the class and the package."", ""Package"")"
You can access the modifiers of a class via the Class object.,"(""Class"", ""The Class and the Class object are related because they are referred to together as a means to access the modifiers of a class."", ""Class object""); (""Class"", ""The Class and the modifiers are related because the modifiers are accessed via the Class object."", ""modifiers"")"
You can check the modifiers using these methods in the class java.lang.reflect.Modifier:,"(""Modifier"", ""Modifier is a part of the java.lang.reflect.Modifier class"", ""java.lang.reflect.Modifier""); (""java.lang.reflect"", ""java.lang.reflect.Modifier is a class within the java.lang.reflect package"", ""java.lang.reflect.Modifier"")"
You can also access information specified for this package in the Manifest file of the JAR file this package is located in on the classpath.,"(""Package"", ""The package is related to the Manifest because the Manifest file contains information about the package."", ""Manifest""); (""Package"", ""The package is related to the Jar because the package is located in the Jar file."", ""Jar""); (""Package"", ""The package is related to the Classpath because the Jar file that contains the package is located on the classpath."", ""Classpath""); (""Manifest"", ""The Manifest is related to the Jar because the Manifest file is part of the Jar file."", ""Jar"")"
From the Class object you can access the superclass of the class.,NULL
"The superclass class object is a Class object like any other, so you can continue doing class reflection on that too.","(""Class"", ""The superclass class object is a Class object like any other, indicating a relationship between Class and Object"", ""Object"")"
It is possible to get a list of the interfaces implemented by a given class.,NULL
NOTE: Only the interfaces specifically declared implemented by a given class is returned.,NULL
"If a superclass of the class implements an interface, but the class doesn't specifically state that it also implements that interface, that interface will not be returned in the array.","(""Class"", ""The class has a superclass, indicating a clear inheritance relationship between the two."", ""Superclass""); (""Superclass"", ""The superclass implements the interface, indicating a clear implementation relationship between the two."", ""Interface""); (""Class"", ""The class does not specifically state that it implements the interface, but its superclass does, indicating a potential indirect relationship between the class and the interface."", ""Interface""); (""Class"", ""The class's interfaces are returned in an array, indicating a relationship between the class and the array."", ""Array"")"
"Even if the class in practice implements that interface, because the superclass does.","(""Class"", ""The class implements the interface."", ""Interface"")"
To get a complete list of the interfaces implemented by a given class you will have to consult both the class and its superclasses recursively.,"(""Class"", ""A class is related to its superclasses because it inherits properties and methods from them, and to get a complete list of interfaces, one has to consult both the class and its superclasses recursively."", ""Superclasses""); (""Class"", ""A class is related to the interfaces it implements, as the text mentions getting a complete list of the interfaces implemented by a given class."", ""Interfaces"")"
You can access the fields (member variables) of a class like this:,"(""Class"", ""The class has fields, which are also known as member variables, indicating a clear relationship between the class and its fields."", ""Fields""); (""Class"", ""The class has member variables, which are another term for fields, indicating a clear relationship between the class and its member variables."", ""Member Variables"")"
You can access the class annotations of a class like this:,"(""Class"", ""The class has annotations, indicating a relationship between the class entity and the annotations entity, however since 'annotations' is not one of the entity types, this relationship cannot be formed, but the class is clearly related to accessing its own annotations"", ""Annotations"")"
Using Java Reflection you can inspect the constructors of classes and instantiate objects at runtime.,"(""Java Reflection"", ""Java Reflection can inspect the constructors of classes at runtime, thus they are related."", ""constructors""); (""Java Reflection"", ""Java Reflection can inspect the constructors of classes and instantiate objects at runtime, thus they are related."", ""classes""); (""Java Reflection"", ""Java Reflection can instantiate objects at runtime, thus they are related."", ""objects""); (""constructors"", ""constructors are a part of classes, thus they are related."", ""classes""); (""classes"", ""objects are instances of classes, thus they are related."", ""objects"")"
The Constructor[] array will have one Constructor instance for each public constructor declared in the class.,"(""Constructor"", ""The Constructor[] array is related to the Constructor class because it contains one Constructor instance for each public constructor declared in the class."", ""Constructor[]""); (""Constructor"", ""The Constructor class is related to the Constructor instance because the instance is an example of the class."", ""Constructor instance"")"
This example returns the public constructor of the given class which takes a String as parameter:,"(""Class"", ""The class has a constructor which is a method that is clearly related to it"", ""Constructor""); (""Constructor"", ""The constructor takes a String as a parameter, which shows a clear relationship between the constructor and the String class"", ""String"")"
"If no constructor matches the given constructor arguments, in this case String.class, a NoSuchMethodException is thrown.",NULL
"The Constructor.newInstance() method takes an optional amount of parameters, but you must supply exactly one parameter per argument in the constructor you are invoking.",NULL
"It is possible to load and reload classes at runtime in Java, though it is not as straightforward as one might have hoped.",NULL
This text will explain when and how you can load and reload classes in Java.,"(""Java"", ""Java is a package that contains classes, and classes in Java are loaded and reloaded."", ""Classes"")"
"You can argue whether Java's dynamic class loading features are really part of Java Reflection, or a part of the core Java platform.","(""Java"", ""Java has a feature called Java Reflection, which suggests a relationship between the two entities as Java Reflection is a part of the Java ecosystem."", ""Java Reflection""); (""Java"", ""The text mentions that Java's dynamic class loading features can be considered part of either Java Reflection or the core Java platform, indicating a relationship between Java and the core Java platform."", ""core Java platform"")"
All classes in a Java application are loaded using some subclass of java.lang.ClassLoader.,"(""java.lang"", ""java.lang.ClassLoader is a part of the java.lang package"", ""java.lang.ClassLoader""); (""Java"", ""java.lang.ClassLoader is a class in Java used for loading other classes"", ""java.lang.ClassLoader"")"
Loading classes dynamically must therefore also be done using a java.lang.ClassLoader subclass.,NULL
"When a class is loaded, all classes it references are loaded too.",NULL
"This class loading pattern happens recursively, until all classes needed are loaded.",NULL
Unreferenced classes are not loaded until the time they are referenced.,NULL
"If a ClassLoader is asked to load a class, it will ask its parent class loader to load it.","(""ClassLoader"", ""The ClassLoader is related to its parent class loader because it asks its parent to load a class when requested."", ""parent class loader""); (""ClassLoader"", ""The ClassLoader is related to the class because it is asked to load the class."", ""class"")"
"If the parent class loader can't find the class, the child class loader then tries to load it itself.","(""Parent Class Loader"", ""The parent class loader is related to the class because it tries to load the class if it can't be found."", ""Class""); (""Child Class Loader"", ""The child class loader is related to the class because it tries to load the class itself if the parent class loader can't find it."", ""Class"")"
The steps a given class loader uses when loading classes are:,NULL
When you implement a class loader that is capable of reloading classes you will need to deviate a bit from this sequence.,NULL
The classes to reload should not be requested loaded by the parent class loader.,NULL
All you need to do is to obtain a ClassLoader and call its loadClass() method.,NULL
Java's builtin Class loaders always checks if a class is already loaded before loading it.,"(""Class"", ""Class loaders is a type of Class in Java, which checks if a class is already loaded before loading it."", ""Class loaders""); (""Java"", ""Java has a builtin Class, which is loaded by the Class loaders."", ""Class"")"
Reloading the class is therefore not possible using Java's builtin class loaders.,NULL
To reload a class you will have to implement your own ClassLoader subclass.,NULL
Even with a custom subclass of ClassLoader you have a challenge.,NULL
"This method is final, and thus cannot be overridden in your ClassLoader subclass.",NULL
The resolve() method will not allow any given ClassLoader instance to link the same class twice.,"(""Resolve"", ""The resolve() method is related to the ClassLoader class because it mentions that the resolve() method will not allow any given ClassLoader instance to link the same class twice, indicating that the resolve() method interacts with the ClassLoader class."", ""ClassLoader"")"
"Therefore, everytime you want to reload a class you must use a new instance of your ClassLoader subclass.","(""Class Loader"", ""The Class Loader is related to ClassLoader because a Class Loader is an instance of a ClassLoader subclass, indicating a clear hierarchical relationship between the two entities."", ""ClassLoader"")"
"This is not impossible, but necessary to know when designing for class reloading.",NULL
As stated earlier you cannot reload a class using a ClassLoader that has already loaded that class once.,NULL
Therefore you will have to reload the class using a different ClassLoader instance.,NULL
"Every class loaded in a Java application is identified by its fully qualified name (package name + class name), and the ClassLoader instance that loaded it.","(""Class"", ""A class is identified by its fully qualified name which includes the package name, indicating a relationship between Class and Package"", ""Package""); (""Class"", ""Every class loaded in a Java application is identified by the ClassLoader instance that loaded it, indicating a relationship between Class and ClassLoader"", ""ClassLoader"")"
"That means, that a class MyObject loaded by class loader A, is not the same class as the MyObject class loaded with class loader B.",NULL
"Notice how the MyObject class is referenced in the code, as the type of the object variable.",NULL
This causes the MyObject class to be loaded by the same class loader that loaded the class this code is residing in.,"(""MyObject"", ""MyObject is loaded by the class loader"", ""class loader"")"
"If the myClassReloadingFactory object factory reloads the MyObject class using a different class loader than the class the above code resides in, you cannot cast the instance of the reloaded MyObject class to the MyObject type of the object variable.","(""myClassReloadingFactory"", ""The myClassReloadingFactory object factory reloads the MyObject class, indicating a relationship between the two classes."", ""MyObject""); (""MyObject"", ""The instance of the reloaded MyObject class is related to the object variable, as it cannot be cast to the MyObject type of the object variable."", ""object"")"
"Since the two MyObject classes were loaded with different class loaders, the are regarded as different classes, even if they have the same fully qualified class name.","(""MyObject"", ""MyObject is loaded by a class loader, which affects how it is regarded in terms of class identity, therefore they are related."", ""class loader"")"
Trying to cast an object of the one class to a reference of the other will result in a ClassCastException.,NULL
"Either of these two methods will work if the type of the variable, the interface or superclass, is not reloaded when the implementing class or subclass is reloaded.","(""CLASS"", ""The variable is likely an instance of the class, relating them together."", ""VARIABLE""); (""INTERFACE"", ""The class implements the interface, creating a relationship between the two entities."", ""CLASS""); (""SUPERCLASS"", ""The class is a subclass of the superclass, indicating a relationship between the two entities."", ""CLASS""); (""METHOD"", ""The method is part of the class, establishing a clear relationship between them."", ""CLASS""); (""VARIABLE"", ""The method can operate on the variable, showing a relationship between the two entities."", ""METHOD""); (""INTERFACE"", ""The variable's type is an interface, creating a relationship between the variable and the interface."", ""VARIABLE""); (""SUPERCLASS"", ""The variable's type is a superclass, indicating a relationship between the variable and the superclass."", ""VARIABLE""); (""INTERFACE"", ""The method is used to implement the interface, showing a relationship between the two entities."", ""METHOD"")"
To make this work you will of course need to implement your class loader to let the interface or superclass be loaded by its parent.,"(""Class Loader"", ""The class loader is related to the interface because it needs to load the interface."", ""Interface""); (""Class Loader"", ""The class loader is related to the superclass because it needs to load the superclass."", ""Superclass"")"
"When your class loader is asked to load the MyObject class, it will also be asked to load the MyObjectInterface class, or the MyObjectSuperclass class, since these are referenced from within the MyObject class.","(""MyObject"", ""MyObject is related to MyObjectInterface because MyObjectInterface is referenced from within the MyObject class"", ""MyObjectInterface"")"
Your class loader must delegate the loading of those classes to the same class loader that loaded the class containing the interface or superclass typed variables.,"(""CLASS LOADER"", ""The class loader is related to the class because it loads the class."", ""CLASS""); (""CLASS LOADER"", ""The class loader is related to the interface because it loads the interface."", ""INTERFACE""); (""CLASS LOADER"", ""The class loader is related to the superclass because it loads the superclass."", ""SUPERCLASS""); (""CLASS"", ""The class is related to the interface because the class implements or contains the interface."", ""INTERFACE""); (""CLASS"", ""The class is related to the superclass because the class extends or inherits from the superclass."", ""SUPERCLASS"")"
Notice how it delegates class loading to its parent except for the one class it is intended to be able to reload.,NULL
"If the loading of this class is delegated to the parent class loader, it cannot be reloaded later.",NULL
"Remember, a class can only be loaded once by the same ClassLoader instance.",NULL
It is not a production ready template for your own class loaders.,"(""Class Loader"", ""The Class Loader is related to the Template because the text mentions a template for class loaders, indicating that class loaders use or are associated with templates."", ""Template""); (""Class"", ""The Class is related to the Class Loader because class loaders are used to load classes, indicating a direct relationship between the two entities."", ""Class Loader"")"
"Your own class loaders should probably not be limited to a single class, but a collection of classes that you know you will need to reload.","(""Class Loader"", ""A class loader is related to a class because it loads classes."", ""Class""); (""Class Loader"", ""A class loader is related to a collection of classes because it can load multiple classes."", ""Collection"")"
"In addition, you should probably not hardcode the class paths either.",NULL
Here is the reflection.MyObject class that is loaded using the class loader.,NULL
Notice how it both extends a superclass and implements an interface.,NULL
The name of this class is why I refer to these dynamic interface implementations as dynamic proxies.,NULL
As mentioned earlier you must pass an InvocationHandler implementation to the Proxy.newProxyInstance() method.,"(""InvocationHandler"", ""InvocationHandler is passed to the Proxy's newProxyInstance method"", ""Proxy""); (""Proxy"", ""Proxy has a method called newProxyInstance"", ""newProxyInstance"")"
The proxy parameter passed to the invoke() method is the dynamic proxy object implementing the interface.,NULL
The Method object passed into the invoke() method represents the method called on the interface the dynamic proxy implements.,"(""Method"", ""The Method object is passed into the invoke() method, indicating a relationship between the two."", ""invoke""); (""Method"", ""The Method object represents the method called on the interface, indicating a relationship between the Method and the interface."", ""interface""); (""interface"", ""The dynamic proxy implements the interface, indicating a relationship between the dynamic proxy and the interface."", ""dynamic proxy"")"
"But now you can check via the mock if the DAO uses the connection properly, for instance if the connection.close() is called (or NOT called), if you expected that.","(""DAO"", ""The DAO uses the Connection, as indicated by the possibility of checking if the connection.close() is called."", ""Connection""); (""DAO"", ""The DAO is related to Connection.Close because it is expected to call connection.close() properly."", ""Connection.Close"")"
Thus the factory interface and your class could look something like this:,NULL
"When the MyAction class calls methods on the IMyFactory instance injected into its constructor by the container, the method calls are translated into calls to the IContainer.instance() method, which is the method you use to obtain instances from the container.","(""MyAction"", ""MyAction class calls methods on the IMyFactory instance"", ""IMyFactory""); (""IMyFactory"", ""IMyFactory instance is obtained from the IContainer instance"", ""IContainer""); (""MyAction"", ""MyAction class uses the IContainer instance to obtain instances from the container"", ""IContainer"")"
Using Java Reflection you can inspect the fields (member variables) of classes and get / set them at runtime.,"(""Java Reflection"", ""Java Reflection can inspect the fields of classes at runtime"", ""classes"")"
The Field[] array will have one Field instance for each public field declared in the class.,"(""Field[]"", ""The Field[] array is related to Field because it contains one Field instance for each public field declared in the class."", ""Field"")"
"If no field exists with the name given as parameter to the getField() method, a NoSuchFieldException is thrown.",NULL
"Once you have obtained a Field instance, you can get its field name using the Field.getName() method, like this:","(""Field"", ""The Field class has a method called getName, indicating a relationship between the Field class and the getName method."", ""getName""); (""Field instance"", ""A Field instance is an object of the Field class, indicating a relationship between the Field instance and the Field class."", ""Field""); (""Field"", ""The Field class has a method called getName, indicating a relationship between the Field class and the getName method."", ""getName""); (""Field instance"", ""A Field instance is an object of the Field class, indicating a relationship between the Field instance and the Field class."", ""Field"")"
"Once you have obtained a Field reference you can get and set its values using the Field.get() and Field.set()methods, like this:","(""FIELD"", ""FIELD.GET is a method of the FIELD class"", ""FIELD.GET"")"
The objectInstance parameter passed to the get and set method should be an instance of the class that owns the field.,"(""ObjectInstance"", ""The objectInstance parameter is passed to the get method, indicating a relationship between the two."", ""Get""); (""ObjectInstance"", ""The objectInstance parameter is passed to the set method, indicating a relationship between the two."", ""Set""); (""Get"", ""Both get and set methods receive the objectInstance parameter, suggesting a shared relationship between them."", ""Set""); (""Field"", ""The objectInstance parameter is an instance of the class that owns the field, establishing a connection between the field and the objectInstance."", ""ObjectInstance""); (""Get"", ""The get method is used in relation to the field, as it retrieves the field's value from the objectInstance."", ""Field"")"
"In the above example an instance of MyObject is used, because the someField is an instance member of the MyObject class.",NULL
"It the field is a static field (public static ...) pass null as parameter to the get and set methods, instead of the objectInstance parameter passed above.","(""Field"", ""The Field entity is related to the Get entity because the get method is used to access the field."", ""Get""); (""Field"", ""The Field entity is related to the Set entity because the set method is used to modify the field."", ""Set""); (""Get"", ""The Get entity is related to the ObjectInstance entity because the get method takes the objectInstance as a parameter."", ""ObjectInstance"")"
When you write a class or interface you can specify that it should be paramerizable.,NULL
"Rather than create a list of Object you can parameterize java.util.List to create a list of say String, like this:","(""java.util.List"", ""java.util.List is parameterized to create a list of String"", ""String"")"
"When inspecting a parameterizable type itself at runtime via reflection, like java.util.List, there is no way of knowing what type is has been parameterized to.","(""Java"", ""Java is related to Util because Util is a package in Java."", ""Util""); (""Java"", ""Java is related to List because List is a class in Java."", ""List""); (""Java"", ""Java is related to Reflection because Java uses Reflection for inspecting parameters at runtime."", ""Reflection""); (""Util"", ""Util is related to List because List is a class in the Util package."", ""List""); (""Util"", ""Util is related to Reflection because the Util package likely contains classes that use Reflection for inspecting parameters."", ""Reflection"")"
If you have obtained a java.lang.reflect.Method object it is possible to obtain information about its generic return type.,"(""JAVA.LANG.REFLECT.METHOD"", ""The JAVA.LANG.REFLECT.METHOD entity is related to the JAVA.LANG.REFLECT entity because it is a part of the JAVA.LANG.REFLECT package."", ""JAVA.LANG.REFLECT""); (""JAVA.LANG.REFLECT"", ""The JAVA.LANG.REFLECT entity is related to the JAVA.LANG entity because it is a sub-package of the JAVA.LANG package."", ""JAVA.LANG"")"
Here is an example class with a method having a parameterized return type:,NULL
In this class it is possible to obtain the generic return type of the getStringList() method.,NULL
"In other words, it is possible to detect that getStringList() returns a List<String> and not just a List.","(""GetStringList"", ""The method getStringList() returns a List, indicating a relationship between the two entities."", ""List""); (""List"", ""The List is specified to be a List of String, indicating a relationship between the two entities."", ""String"")"
"This piece of code will print out the text ""typeArgClass = java.lang.String"".",NULL
The Type[] array typeArguments array will contain one item - a Class instance representing the class java.lang.String.,"(""Type[]"", ""Type[] array typeArguments array will contain one item - a Class instance"", ""Class""); (""Type[]"", ""Type[] array typeArguments array will contain one item - a Class instance representing the class java.lang.String"", ""java.lang.String"")"
Here is an example class with a method taking a parameterized List as parameter:,"(""Example"", ""The Example class contains the Method, indicating a containment relationship between the two entities."", ""Method""); (""Method"", ""The Method takes a parameterized List as a parameter, indicating a usage relationship between the Method and the List."", ""List"")"
The Type[] array parameterArgTypes array will contain one item - a Class instance representing the class java.lang.String.,"(""Type"", ""Type is related to Class because Type is described as a Class instance"", ""Class""); (""Class"", ""Class is related to java.lang.String because java.lang.String is an instance of Class"", ""java.lang.String"")"
Fields are class member variables - either static or instance variables.,"(""Fields"", ""Fields are described as class member variables, indicating a relationship between the two"", ""class""); (""class"", ""class and member are related as member variables are part of a class"", ""member""); (""class"", ""class and variables are related as variables are a type of class member"", ""variables"")"
The Type[] array fieldArgTypes array will contain one item - a Class instance representing the class java.lang.String.,"(""Type[]"", ""Type[] array fieldArgTypes is related to Class because it contains a Class instance"", ""Class""); (""Type[]"", ""Type[] array fieldArgTypes is related to java.lang.String because it contains a Class instance representing the class java.lang.String"", ""java.lang.String"")"
Using Java Reflection you can inspect the methods of classes and invoke them at runtime.,"(""Java Reflection"", ""Java Reflection can inspect the methods of classes"", ""Methods""); (""Java Reflection"", ""Java Reflection can inspect the methods of classes"", ""Classes"")"
This can be used to detect what getters and setters a given class has.,"(""Class"", ""A class has getters, indicating that the class is the source that contains or utilizes the getters method."", ""Getters""); (""Class"", ""A class has setters, indicating that the class is the source that contains or utilizes the setters method."", ""Setters"")"
"You cannot ask for getters and setters explicitly, so you will have to scan through all the methods of a class and check if each method is a getter or setter.","(""Class"", ""A class contains multiple methods"", ""Method""); (""Method"", ""Getters are a type of method"", ""Getters""); (""Method"", ""Setters are a type of method"", ""Setters""); (""Class"", ""A class has getters as part of its methods"", ""Getters"")"
Here is a code example that finds getter and setters of a class:,"(""Class"", ""The Class has a Getter method, as it is a common practice for a class to have getter methods to access its properties."", ""Getter""); (""Class"", ""The Class has a Setter method, as it is a common practice for a class to have setter methods to modify its properties."", ""Setter"")"
The Method[] array will have one Method instance for each public method declared in the class.,"(""Method"", ""The Method instance is related to the class because it is declared in the class."", ""class""); (""Method[]"", ""The Method[] array is related to the Method instance because it contains one Method instance for each public method."", ""Method"")"
"This example returns the public method named ""doSomething"", in the given class which takes a String as parameter:","(""DoSomething"", ""The method DoSomething takes a String as parameter, so they are related."", ""String"")"
"If no method matches the given method name and arguments, in this case String.class, a NoSuchMethodException is thrown.",NULL
"In this example, if doSomething(String.class) is not static, you need to supply a valid MyObject instance instead of null;","(""DoSomething"", ""DoSomething method is related to MyObject class because it requires a valid MyObject instance to be called when it's not static"", ""MyObject"")"
"The Method.invoke(Object target, Object ... parameters) method takes an optional amount of parameters, but you must supply exactly one parameter per argument in the method you are invoking.","(""Method.Invoke"", ""The Method.Invoke method is related to the Method class because it is a part of the method invocation process."", ""Method""); (""Method.Invoke"", ""The Method.Invoke method is related to the Object class because it takes an Object target as a parameter."", ""Object"")"
This Java module reflection tutorial will explain how to access the Java Module a Java class belongs to via Java reflection.,"(""Java class"", ""The Java class belongs to the Java Module, indicating a relationship between the two entities."", ""Java Module""); (""Java"", ""The Java class is part of the Java package, indicating a relationship between the two entities."", ""Java class""); (""Java reflection"", ""Java reflection is used to access the Java class, indicating a relationship between the two entities."", ""Java class""); (""Java"", ""Java reflection is a part of the Java package, indicating a relationship between the two entities."", ""Java reflection"")"
"Thus, each Java class belongs to a package, and the package belongs to a module.","(""JavaClass"", ""JavaClass belongs to Package"")
{completion_delimiter}

The final answer is:
(""entity"",""JavaClass"",""class"", ""Package"")"
A Java module is represented by the Java reflection class java.lang.Module in the Java module java.base.,"(""java.lang.Module"", ""java.lang.Module is a class in the java.base package"", ""java.base""); (""Java reflection"", ""Java reflection is represented by the java.lang.Module class"", ""java.lang.Module""); (""Java"", ""Java has a module java.base"", ""java.base"")"
"Via this class you can interact with the Java Platform Module System to obtain information about a given module, or modify a module.","(""Class"", ""The Class entity is related to the Java Platform Module System entity because it interacts with the system to obtain or modify module information."", ""Java Platform Module System"")"
"You can obtain an instance of the Module class via a Class instance, like this:",NULL
You can check if a Module instance a represents a named module by calling the Module isNamed() method.,NULL
You can check if a Module is a named module via the Module isOpen() method.,NULL
Once you have access to a Module instance you can access its ModuleDescriptor via the getDescriptor() method.,"(""Module"", ""ModuleDescriptor is accessed via the Module instance"", ""ModuleDescriptor""); (""Module"", ""getDescriptor is a method of the Module instance"", ""getDescriptor"")"
Here is an example of accessing a Java Module's ModuleDescriptor via getDescriptor() :,"(""ModuleDescriptor"", ""ModuleDescriptor is accessed via the getDescriptor() method"", ""getDescriptor""); (""Java Module"", ""The Java Module contains a ModuleDescriptor"", ""ModuleDescriptor"")"
You can get the name of a named module from its module descriptor via the ModuleDescriptor name() method.,"(""ModuleDescriptor"", ""The ModuleDescriptor class has a name() method, indicating a relationship between the two entities."", ""name()""); (""module descriptor"", ""The module descriptor is related to the ModuleDescriptor class, as it is described as a ModuleDescriptor."", ""ModuleDescriptor"")"
"You can read the list of packages exported by a Java module via Java reflection, via the ModuleDescriptor exports() method.","(""MODULEDESCRIPTOR"", ""The ModuleDescriptor class has an exports() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""EXPORTS()""); (""JAVA"", ""The Java package is related to the ModuleDescriptor class because ModuleDescriptor is used in the context of Java reflection, which is a part of the Java package."", ""MODULEDESCRIPTOR""); (""MODULEDESCRIPTOR"", ""The ModuleDescriptor class has an exports() method, indicating a containment relationship as the method is a member of the class, used to retrieve the list of packages exported by a Java module."", ""EXPORTS()""); (""JAVA"", ""The Java package is related to the ModuleDescriptor class because ModuleDescriptor is a part of the Java Reflection API, which is used to inspect and dynamically load classes, indicating a utilization relationship."", ""MODULEDESCRIPTOR"")"
You can check if a Java module is an automatic module or not via the ModuleDescriptor isAutomatic() method.,NULL
You can check if a Java module is an open module or not via the ModuleDescriptor isOpen() method.,"(""ModuleDescriptor"", ""The ModuleDescriptor class contains the isOpen() method, indicating a clear relationship between the two entities."", ""isOpen()""); (""Java"", ""The Java package is related to the ModuleDescriptor class, as ModuleDescriptor is used in the context of Java modules."", ""ModuleDescriptor"")"
You can read the module service dependencies via the ModuleDescriptor uses() method.,"(""ModuleDescriptor"", ""The ModuleDescriptor class has a uses() method, indicating that uses() is a method of ModuleDescriptor"", ""uses()""); (""ModuleDescriptor"", ""The ModuleDescriptor class is related to module service dependencies because it provides a way to read the dependencies via its uses() method"", ""module service dependencies"")"
Despite the common belief it is actually possible to access private fields and methods of other classes via Java Reflection.,"(""Java Reflection"", ""Java Reflection is related to private fields because it can be used to access them"", ""private fields""); (""Java Reflection"", ""Java Reflection is related to private methods because it can be used to access them"", ""private methods""); (""Java"", ""Java is related to Java Reflection because Java Reflection is a part of the Java programming language"", ""Java Reflection""); (""Java"", ""Java is related to private fields because private fields are a part of the Java programming language"", ""private fields"")"
To access a private field you will need to call the Class.getDeclaredField(String name) or Class.getDeclaredFields() method.,"(""Class"", ""The Class entity is related to the getDeclaredField entity because getDeclaredField is a method of the Class entity."", ""getDeclaredField"")"
"The methods Class.getField(String name) and Class.getFields() methods only return public fields, so they won't work.","(""Class"", ""The Class class has a method called getField, indicating a relationship between the two."", ""getField""); (""Class"", ""The Class class has a method called getFields, indicating a relationship between the two."", ""getFields""); (""getField"", ""The getField method takes a String parameter, indicating a relationship between the two."", ""String""); (""getField"", ""The getField method takes a name parameter, indicating a relationship between the two."", ""name"")"
"Here is a simple example of a class with a private field, and below that the code to access that field via Java Reflection:",NULL
"This method only returns fields declared in that particular class, not fields declared in any superclasses.","(""Method"", ""The method is related to the class because it returns fields declared in that particular class."", ""Class""); (""Class"", ""The class is related to its superclasses because the method does not return fields declared in any superclasses, implying a hierarchical relationship."", ""Superclasses"")"
"By calling Field.setAcessible(true) you turn off the access checks for this particular Field instance, for reflection only.",NULL
"To access a private method you will need to call the Class.getDeclaredMethod(String name, Class[] parameterTypes) or Class.getDeclaredMethods() method.","(""Class"", ""The Class entity is related to the getDeclaredMethod entity because getDeclaredMethod is a method of the Class entity."", ""getDeclaredMethod"")"
"The methods Class.getMethod(String name, Class[] parameterTypes) and Class.getMethods() methods only return public methods, so they won't work.","(""Class"", ""Class has a method called getMethod"", ""getMethod""); (""Class"", ""Class has a method called getMethods"", ""getMethods""); (""getMethod"", ""getMethod takes a String parameter called name"", ""String"")"
"Here is a simple example of a class with a private method, and below that the code to access that method via Java Reflection:","(""Class"", ""The Class has a Private Method, indicating a clear relationship between the two as the method is a component of the class."", ""Private Method""); (""Private Method"", ""The Private Method is accessed via Java Reflection, showing a relationship between the method and the Java Reflection package."", ""Java Reflection"")"
"This code example will print out the text ""returnValue = The Private Value"", which is the value returned by the method getPrivateString() when invoked on the PrivateObject instance created at the beginning of the code sample.",NULL
"This method only returns methods declared in that particular class, not methods declared in any superclasses.","(""Method"", ""The method is related to the class because it returns methods declared in that particular class."", ""Class"")"
"By calling Method.setAcessible(true) you turn off the access checks for this particular Method instance, for reflection only.",NULL
"Java Reflection makes it possible to inspect classes, interfaces, fields and methods at runtime, without knowing the names of the classes, methods etc.","(""Java Reflection"", ""Java Reflection makes it possible to inspect classes at runtime"", ""Classes""); (""Java Reflection"", ""Java Reflection makes it possible to inspect interfaces at runtime"", ""Interfaces""); (""Java Reflection"", ""Java Reflection makes it possible to inspect fields at runtime"", ""Fields"")"
"It will explain the basics of Java Reflection including how to work with arrays, annotations, generics and dynamic proxies, and do dynamic class loading and reloading.","(""Java Reflection"", ""Java Reflection is related to Arrays because it explains how to work with arrays"", ""Arrays""); (""Java Reflection"", ""Java Reflection is related to Annotations because it explains how to work with annotations"", ""Annotations""); (""Java Reflection"", ""Java Reflection is related to Generics because it explains how to work with generics"", ""Generics""); (""Java Reflection"", ""Java Reflection is related to Dynamic Proxies because it explains how to work with dynamic proxies"", ""Dynamic Proxies"")"
"It will also show you how to do more specific Java Reflection tasks, like reading all getter methods of a class, or accessing private fields and methods of a class.","(""Java Reflection"", ""Java Reflection is related to getter methods because it can be used to read all getter methods of a class."", ""getter methods""); (""Java Reflection"", ""Java Reflection is related to private fields because it can be used to access private fields of a class."", ""private fields""); (""Java Reflection"", ""Java Reflection is related to private methods because it can be used to access private methods of a class."", ""private methods""); (""getter methods"", ""getter methods and private fields are related because both can be accessed or read using Java Reflection in the context of a class."", ""private fields""); (""getter methods"", ""getter methods and private methods are related because both are types of methods that can be accessed or read using Java Reflection in the context of a class."", ""private methods"")"
This example obtains the Class object from the class called MyObject.,NULL
"Using the class object the example gets a list of the methods in that class, iterates the methods and print out their names.","(""Class"", ""The class has a list of methods, indicating a relationship between the class and its methods."", ""Methods""); (""Object"", ""The object is an instance of the class, indicating a relationship between the object and the class."", ""Class"")"
When using Java reflection the starting point is often a Class object representing some Java class you want to inspect via reflection.,"(""Class"", ""The Class object is often used in the context of Java reflection, indicating a relationship between the Class entity and the Java entity."", ""Java""); (""Java"", ""Java provides a reflection mechanism, which is a method, indicating a relationship between the Java entity and the reflection entity."", ""reflection"")"
"For instance, to obtain the Class object for a class named MyObject you could write:","(""Class"", ""Class is related to MyObject because MyObject is an instance of Class"", ""MyObject""); (""Class"", ""Class is related to Object because Object is a parent class of Class"", ""Object"")"
Now you have a reference to the Class object for the MyObject class.,NULL
"Once you have a reference to the Class object representing some class, you can see what fields that class contains.","(""Class"", ""The Class object is an instance of a class, thus they are related."", ""Object""); (""Class"", ""The Class object contains fields, thus they are related."", ""fields"")"
Here is an example of accessing fields of a Java class:,"(""accessing"", ""accessing is a method that is used to access fields of a Java class"", ""class""); (""Java"", ""Java is a language that has classes, so they are related"", ""class""); (""class"", ""A class has fields, so they are related"", ""fields"")"
Using Java Reflection it is possible find out what constructors a given Java class contains and what parameters they take etc.,"(""Java Reflection"", ""Java Reflection is a part of the Java package"", ""Java""); (""Java Reflection"", ""Java Reflection can be used to find out information about a Java class"", ""Class""); (""Java Reflection"", ""Java Reflection can be used to find out information about the constructors of a Java class"", ""constructors""); (""Class"", ""A class has constructors"", ""constructors""); (""Java"", ""Class is a part of the Java package"", ""Class"")"
You can also see what methods a given class has from its Class object.,"(""Class"", ""A class has methods, as indicated by the phrase 'what methods a given class has'"", ""methods""); (""Class"", ""A Class object represents a class, as implied by the phrase 'from its Class object'"", ""Class object"")"
Here is an example of accessing the methods a given class via Java reflection:,"(""Java"", ""Java is related to Reflection because Java is the language in which reflection is being used"", ""Reflection""); (""Java"", ""Java is related to Methods because Java is the language that has these methods"", ""Methods""); (""Reflection"", ""Reflection is related to Methods because reflection is used to access these methods"", ""Methods""); (""Accessing"", ""Accessing is related to Methods because accessing is an action being performed on these methods"", ""Methods"")"
You can also use Java reflection to find out what getter and setter methods a class has.,NULL
You can even access private fields and methods via Java reflection - even from outside the class that owns the private field or method.,"(""Java"", ""Java uses Reflection to access private fields and methods"", ""Reflection""); (""Reflection"", ""Reflection can access private fields"", ""Field""); (""Reflection"", ""Reflection can access private methods"", ""Method""); (""Java"", ""Java has fields that can be accessed via Reflection"", ""Field"")"
"In case a Java class has annotations which are available at runtime, you can access them via Java reflection too.","(""Java"", ""Java has annotations which are available at runtime"", ""annotations""); (""Java"", ""Java can access annotations via Java reflection"", ""Java reflection"")"
"For instance, you can determine what type of class the array is an array of.",NULL
"For instance, if you are introspecting a String array, you can detect that the element type is String by inspecting the array class.",NULL
"Java reflection has a special Proxy class that can implement a Java Interface dynamically at runtime, rather than at compile time.","(""Proxy"", ""Proxy class can implement a Java Interface dynamically at runtime"", ""Java Interface""); (""Proxy"", ""Proxy is a part of Java reflection"", ""Java"")"
In Java it is possible to dynamically load and also reload classes using a Java ClassLoader.,"(""Java"", ""Java uses a ClassLoader to dynamically load and reload classes"", ""ClassLoader"")"
"The ClassLoader class is actually not part of the Java Reflection API, but since Java Reflection is often used to achieve ""dynamic"" behaviour (behavioral changes at runtime), and dynamic class loading and reloading kind of fits into this theme, I have decided to include that tutorial in my Java Reflection tutorial.","(""ClassLoader"", ""The ClassLoader class is often used in conjunction with Java Reflection to achieve dynamic behaviour."", ""Java Reflection""); (""ClassLoader"", ""The ClassLoader class is actually not part of the Java Reflection API, but is related to it through its use in dynamic class loading and reloading."", ""Java Reflection API"")"
Dynamic class loading and reloading is explained in my Java Reflection - Dynamic Class Loading and Reloading tutorial.,"(""Java Reflection"", ""The entity Java Reflection is related to Dynamic Class Loading and Reloading as it is mentioned as the main topic of the tutorial where Dynamic Class Loading and Reloading is explained."", ""Dynamic Class Loading and Reloading"")"
The Java regex API is located in the java.util.regex package which has been part of standard Java (JSE) since Java 1.4.,"(""Java Regex API"", ""The Java regex API is located in the java.util.regex package, indicating a clear relationship between the two as the Java regex API is part of the java.util.regex package."", ""java.util.regex"")"
"Although Java regex has been part of standard Java since Java 1.4, this Java regex tutorial covers the Java regex API released with Java 8.",NULL
But first I will introduce the core classes of the Java regex API in the following section.,"(""Java"", ""Java is related to Regex because Java is the language in which the Regex class is used"", ""Regex""); (""Java"", ""Java is related to API because the Java language has an API that includes the regex functionality"", ""API"")"
The Matcher class is used to match a given regular expression (Pattern instance) against a text multiple times.,NULL
Both the Pattern and Matcher classes are covered in detail in their own texts.,NULL
The third line uses the Pattern.matches() static method to check if the regular expression (pattern) matches the text.,NULL
"If the regular expression matches the text, then Pattern.matches() returns true.","(""Pattern"", ""Pattern is a class that contains the matches method"", ""matches""); (""Pattern"", ""Pattern is part of the java.util.regex package"", ""java.util.regex"")"
If the regular expression does not match the text Pattern.matches() returns false.,"(""Pattern"", ""Pattern is a class that contains the matches method, indicating that matches is a part of Pattern"", ""matches""); (""Pattern"", ""The Pattern class is part of the java.util.regex package, indicating that Pattern belongs to java.util.regex"", ""java.util.regex"")"
"The example does not actually check if the found http:// string is part of a valid URL, with domain name and suffix (.com, .net etc.).","(""EXAMPLE"", ""The example uses the http string to check for a valid URL, which is related to the HTTP package."", ""HTTP""); (""EXAMPLE"", ""The example checks if the found http string is part of a valid URL, which is related to the URL class."", ""URL""); (""URL"", ""A valid URL consists of a domain name, which is related to the domain class."", ""DOMAIN"")"
"Here is another Java regex example which uses the Matcher class to locate multiple occurrences of the substring ""is"" inside a text:",NULL
The special metacharacter meaning of an escaped metacharacter is ignored - only its actual literal value (e.g.,NULL
Java regular expressions support matching any of a specified set of characters using what is referred to as character classes.,"(""Java"", ""Java supports Regular Expressions"", ""Regular Expressions"")"
"The character class (set of characters to match) is enclosed in the square brackets - the [ae] part of the regular expression, in other words.",NULL
"The character class will match one of the enclosed characters regardless of which, but no mor than one.",NULL
"For instance, the character class [a-z] will match all characters between a lowercase a and a lowercase z, both a and z included.",NULL
You can have more than one character range within a character class.,"(""Character"", ""A character is an element of a character class, and the statement mentions having more than one character range within it."", ""Character Class"")"
"For instance, the character class [a-zA-Z] will match all letters between a and z or between A and Z .","(""Character"", ""The character class is related to the letter A because it includes all letters between a and z or between A and Z."", ""A""); (""Character"", ""The character class is related to the letter Z because it includes all letters between a and z or between A and Z."", ""Z""); (""Character"", ""The character class is related to the letter a because it includes all letters between a and z or between A and Z."", ""a""); (""Character"", ""The character class is related to the letter z because it includes all letters between a and z or between A and Z."", ""z""); (""A"", ""The letters A and Z are related because they both represent the range of uppercase letters that the character class matches."", ""Z""); (""a"", ""The letters a and z are related because they both represent the range of lowercase letters that the character class matches."", ""z""); (""A"", ""The letters A and a are related because they are both the starting point of the range of letters that the character class matches, with A being uppercase and a being lowercase."", ""a"")"
"For instance, the character class [0-9] will match the characters between 0 and 9, both included.",NULL
"If you want to match the square brackets inside a character class, here is how that looks:","(""Character"", ""The Character is related to the Class because it is mentioned in the context of a character class."", ""Class""); (""Match"", ""The Match method is related to the Character because it is used to match characters inside a character class."", ""Character"")"
The character class contains the two square brackets escaped (\\[ and \\]).,NULL
You can match digits of a number with the predefined character class with the code \d.,"(""Number"", ""The Number entity is related to the Character entity because the text mentions matching digits of a number with a predefined character class."", ""Character""); (""Code"", ""The Code entity is related to the Match entity because the text mentions using code to match digits of a number."", ""Match"")"
Matching non-digits can be done with the predefined character class [\D] (uppercase D).,NULL
You can match word characters with the predefined character class with the code \w .,"(""Character"", ""Character is related to Code because they are both used in the context of matching word characters"", ""Code""); (""Word"", ""Word is related to Character because word characters are a type of character class"", ""Character"")"
You can match non-word characters with the predefined character class [\W] (uppercase W).,"(""CLASS"", ""The class is related to W because W is a predefined character class"")
{completion_delimiter}
######################

Note: Since the text does not explicitly mention any packages or methods, no entities of those types were identified. Also, the relationship between CLASS and W is based on the fact that W is a predefined character class, which can be considered as a subclass or a specific instance of a character class.

Please let me replace the tuple_delimiter and record_delimiter with "", "" and **, respectively, for better understanding:
(""entity"", ""CLASS"", ""class"")
**
(""entity"", ""W"", ""class"")
**
(""relationship"", ""CLASS"", ""W"", ""The class is related to W because W is a predefined character class"")
######################

And let me replace the completion_delimiter with ""End of Output"" for clarity:
(""entity"", ""CLASS"", ""class"")
**
(""entity"", ""W"", ""class"")
**
(""relationship"", ""CLASS"", ""W"", ""The class is related to W because W is a predefined character class"")
End of Output
######################

However, the original format is as follows:
(""entity"",""CLASS"",""class"", ""W"")"
Here is a regular expression example using the non-word character class:,NULL
The Java String class has a few regular expression methods too.,NULL
The Java String split() method splits the string into N substrings and returns a String array with these substrings.,"(""String"", ""The String class contains the split() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""split()""); (""Java"", ""The Java package contains the String class, indicating a clear relationship between the two entities as the class is part of the package."", ""String"")"
The split() method takes a regular expression as parameter and splits the string at all positions in the string where the regular expression matches a part of the string.,NULL
The Java Matcher class (java.util.regex.Matcher) is used to search through a text for multiple occurrences of a regular expression.,NULL
I will cover the core methods of the Java Matcher class in this tutorial.,"(""Java"", ""The Java package contains the Matcher class"", ""Matcher""); (""Matcher"", ""The Matcher class has core methods"", ""core methods""); (""Java"", ""The Java package contains the Matcher class"", ""Matcher"")"
"For a full list, see the official JavaDoc for the Matcher class.",NULL
Here is a quick Java Matcher example so you can get an idea of how the Matcher class works:,"(""Matcher"", ""The Matcher class is related to Java because it is used in a Java example to demonstrate how it works."")
{completion_delimiter}
######################

Note: Since the entity type ""method"" and ""package"" are not found in the given text, only the entity ""Matcher"" of type ""class"" is identified. The relationship between ""Matcher"" and ""Java"" is identified because ""Matcher"" is used in a Java example.

However, to fully address the prompt and include the tuple_delimiter and record_delimiter as per the instructions, the revised response should use specific delimiters. Assuming the tuple_delimiter is "","" and the record_delimiter is ""**"", the output should be:

(""entity"",Matcher,class)
**
(""relationship"",Matcher,Java,The Matcher class is related to Java because it is used in a Java example to demonstrate how it works.)
######################

But since Java is not explicitly defined as an entity in the given text, a more accurate response that adheres strictly to the given instructions and the provided text would focus only on the explicitly mentioned entities and their types, which in this case are limited.

Given the entity types are class, method, and package, and the provided text, the accurate extraction based on the text given is only about the ""Matcher"" class. Since there's no clear method or package mentioned in relation to it within the provided text, the relationship extraction is also limited.

Therefore, the corrected output based on the given instructions and provided text would be:

(""entity"",Matcher,class)
**
{completion_delimiter}
######################

This response follows the format and the details provided in the prompt, focusing on the extraction of entities and their relationships as per the given entity types and text. However, please note the original response's assumption and clarification about the relation to Java, which is not directly derived from the given text but inferred from the context of the example provided.

To strictly adhere to the provided format and instructions without adding inferred relationships not directly supported by the text:

(""entity"",Matcher,class"", ""Java"")"
"The matches() returns true if the regular expression matches the text, and false if not.",NULL
You can do a whole lot more with the Matcher class.,NULL
The Pattern class is covered separately in my Java Regex Pattern tutorial.,NULL
Creating a Matcher is done via the matcher() method in the Pattern class.,NULL
"The matches() method in the Matcher class matches the regular expression against the whole text passed to the Pattern.matcher() method, when the Matcher was created.",NULL
"If the regular expression matches the whole text, then the matches() method returns true.",NULL
You cannot use the matches() method to search for multiple occurrences of a regular expression in a text.,NULL
"For that, you need to use the find(), start() and end() methods.","(""FIND"", ""They are related because they are all mentioned together as methods to be used for the same purpose."", ""START""); (""FIND"", ""They are related because they are all mentioned together as methods to be used for the same purpose."", ""END"")"
The Matcher lookingAt() method works like the matches() method with one major difference.,"(""Matcher"", ""The lookingAt() method is part of the Matcher class, indicating a relationship between them"", ""lookingAt()""); (""Matcher"", ""The matches() method is also part of the Matcher class, indicating a relationship between them"", ""matches()"")"
"The lookingAt() method only matches the regular expression against the beginning of the text, whereas matches() matches the regular expression against the whole text.","(""LookingAt"", ""The lookingAt() method is related to the Text class because it is used to match a regular expression against the beginning of the text."", ""Text""); (""Matches"", ""The matches() method is related to the Text class because it is used to match a regular expression against the whole text."", ""Text"")"
"In other words, if the regular expression matches the beginning of a text but not the whole text, lookingAt() will return true, whereas matches() will return false.",NULL
Matching the regular expression against the beginning of the text (lookingAt()) will return true.,NULL
"Matching the regular expression against the whole text (matches()) will return false, because the text has more characters than the regular expression.",NULL
"The Matcher find() method searches for occurrences of the regular expressions in the text passed to the Pattern.matcher(text) method, when the Matcher was created.","(""Matcher"", ""The Matcher class has a find() method, indicating a relationship between the two entities."", ""find()""); (""Pattern"", ""The Pattern class has a matcher(text) method, indicating a relationship between the two entities."", ""matcher(text)""); (""Matcher"", ""The Matcher was created using the Pattern.matcher(text) method, indicating a relationship between the two entities."", ""Pattern"")"
"If multiple matches can be found in the text, the find() method will find the first, and then for each subsequent call to find() it will move to the next match.",NULL
The methods start() and end() will give the indexes into the text where the found match starts and ends.,NULL
Actually end() returns the index of the character just after the end of the matching section.,NULL
"Thus, you can use the return values of start() and end() inside a String.substring() call.","(""String"", ""String is the class that contains the start method"", ""start""); (""String"", ""String is the class that contains the end method"", ""end""); (""String"", ""String is the class that contains the substring method"", ""substring""); (""start"", ""The return value of start can be used inside a substring call"", ""substring"")"
The Matcher reset() method resets the matching state internally in the Matcher.,NULL
"In case you have started matching occurrences in a string via the find() method, the Matcher will internally keep a state about how far it has searched through the input text.","(""Matcher"", ""The Matcher is related to the find() method because the find() method is used in conjunction with the Matcher to search for occurrences in a string."", ""find()""); (""Matcher"", ""The Matcher is related to the input text because it keeps a state about how far it has searched through the input text."", ""input text"")"
By calling reset() the matching will start from the beginning of the text again.,NULL
"Of course you could do this with the start() and end() methods, but it is easier to do so with the group functions.","(""Start"", ""They are related as they are both mentioned together as methods that can be used for a certain purpose."", ""End""); (""Start"", ""They are related as Group is mentioned as an easier alternative to using Start."", ""Group"")"
The Matcher replaceAll() and replaceFirst() methods can be used to replace parts of the string the Matcher is searching through.,"(""Matcher"", ""The Matcher class has a replaceAll() method, indicating a relationship between the two."", ""replaceAll()""); (""Matcher"", ""The Matcher class has a replaceFirst() method, indicating a relationship between the two."", ""replaceFirst()"")"
"The Matcher appendReplacement() and appendTail() methods are used to replace string tokens in an input text, and append the resulting string to a StringBuffer.","(""Matcher"", ""The Matcher class contains the appendReplacement() method, which indicates a relationship between the two entities."", ""appendReplacement()""); (""Matcher"", ""The Matcher class contains the appendTail() method, which indicates a relationship between the two entities."", ""appendTail()""); (""appendReplacement()"", ""The appendReplacement() method is used to append the resulting string to a StringBuffer, indicating a relationship between the two entities."", ""StringBuffer"")"
"When you have found a match using the find() method, you can call the appendReplacement().",NULL
"The appendReplacement() method keeps track of what has been copied into the StringBuffer, so you can continue searching for matches using find() until no more matches are found in the input text.","(""AppendReplacement()"", ""The appendReplacement() method and the find() method are related because find() is used in conjunction with appendReplacement() to continue searching for matches in the input text."", ""Find()""); (""AppendReplacement()"", ""The appendReplacement() method and the StringBuffer class are related because appendReplacement() keeps track of what has been copied into the StringBuffer."", ""StringBuffer"")"
By calling appendTail() you can append these last characters to the StringBuffer too.,NULL
"Notice how appendReplacement() is called inside the while(matcher.find()) loop, and appendTail() is called just after the loop.","(""Appendreplacement"", ""Appendreplacement() is called inside the while(matcher.find()) loop, indicating that Appendreplacement is related to Matcher through the find method"", ""Matcher""); (""Appendtail"", ""Appendtail() is called just after the loop that contains matcher.find(), suggesting a relationship between Appendtail and Matcher"", ""Matcher""); (""Find"", ""Find is a method of the Matcher class, indicating a strong relationship between the two"", ""Matcher""); (""Appendreplacement"", ""Appendreplacement() is called inside the while loop that contains the Find method, indicating that Appendreplacement and Find are related through the loop"", ""Find"")"
"The Java Pattern class (java.util.regex.Pattern), is the main access point of the Java regular expression API.",NULL
"Whenever you need to work with regular expressions in Java, you start with Java's Pattern class.",NULL
A regular expression is also sometimes referred to as a pattern (hence the name of the Java Pattern class).,NULL
You can use the Pattern.matches() method to quickly check if a text (String) matches a given regular expression.,"(""Pattern"", ""The Pattern class contains the matches() method, which establishes a relationship between the two entities."", ""matches()""); (""String"", ""The String entity is related to the matches() method because the method is used to check if a text (String) matches a given regular expression."", ""matches()"")"
Or you can compile a Pattern instance using Pattern.compile() which can be used multiple times to match the regular expression against multiple texts.,"(""Pattern"", ""Pattern is a class that has a method called compile(), which suggests a strong relationship between the two."", ""Pattern.compile()""); (""Pattern"", ""Pattern is likely part of the java.util.regex package, which contains classes for working with regular expressions, indicating a relationship between the class and the package."", ""java.util.regex"")"
The easiest way to check if a regular expression pattern matches a text is to use the static Pattern.matches() method.,"(""Pattern"", ""The Pattern class contains the matches method, indicating a relationship between the class and the method."", ""matches"")"
"This Pattern.matches() example searches the string referenced by the text variable for an occurrence of the word ""is"", allowing zero or more characters to be present before and after the word (the two .","(""Pattern"", ""The source entity Pattern is related to the target entity matches() because matches() is a method of the Pattern class."", ""matches()""); (""Pattern"", ""The source entity Pattern is related to the target entity text because the Pattern class is used to search the string referenced by the text variable."", ""text"")"
"The Pattern.matches() method is fine if you just need to check a pattern against a text a single time, and the default settings of the Pattern class are appropriate.","(""Pattern"", ""The Pattern class contains the Pattern.matches() method, indicating a relationship between the two entities."", ""Pattern.matches()""); (""Pattern"", ""The text mentions the default settings of the Pattern class, suggesting that the Pattern class is related to itself in the context of its own settings."", ""Pattern"")"
"If you need to match for multiple occurrences, and even access the various matches, or just need non-default settings, you need to compile a Pattern instance using the Pattern.compile() method.","(""Pattern"", ""The Pattern class has a method called Pattern.compile(), which indicates a clear relationship between the class and the method."", ""Pattern.compile()"")"
"If you need to match a text against a regular expression pattern more than one time, you need to create a Pattern instance using the Pattern.compile() method.",NULL
You can also use the Pattern.compile() method to compile a Pattern using special flags.,NULL
The Java Pattern class contains a list of flags (int constants) that you can use to make the Pattern matching behave in certain ways.,"(""Pattern"", ""The Pattern class is part of the Java package, as indicated by the context of the sentence"", ""Java"")"
"For more information of the flags you can use with the Java Pattern class, see the JavaDoc for Pattern .","(""Pattern"", ""Pattern is a part of the Java package"", ""Java""); (""JavaDoc"", ""JavaDoc provides documentation for the Pattern class"", ""Pattern"")"
The Matcher class has a matches() method that tests whether the pattern matches the text.,NULL
"Too keep this text short, the Matcher covered in more detail in the text about the Java Matcher class.","(""Java"", ""The Java package is related to the Java Matcher class because the class is a part of the Java package."", ""Java Matcher"")"
"The split() method in the Pattern class can split a text into an array of String's, using the regular expression (the pattern) as delimiter.","(""SPLIT"", ""The SPLIT method is in the PATTERN class, indicating a relationship between the two entities."", ""PATTERN"")"
This Pattern.split() example splits the text in the text variable into 5 separate strings.,"(""Pattern"", ""The source entity Pattern and the target entity split are related to each other because split is a method of the Pattern class."", ""split""); (""Pattern"", ""The source entity Pattern and the target entity text are related to each other because text is the variable being split by the Pattern class."", ""text"")"
Each of these strings are included in the String array returned by the split() method.,NULL
The pattern() method of the Pattern class simply returns the pattern string (regular expression) that the Pattern instance was compiled from.,"(""Pattern"", ""The pattern() method is a part of the Pattern class, indicating a clear relationship between the two entities as the method is a member of the class."", ""pattern()"")"
Character classes are constructst that enable you to specify a match against multiple characters instead of just one.,NULL
"In other words, a character class matches a single character in the input text against multiple allowed characters in the character class.","(""Character Class"", ""The character class matches a single character in the input text, indicating a relationship between the character class and the character."", ""Character"")"
Character classes are nested inside a pair of square brackets [].,NULL
"The character class [Jj] will match either a J or a j, and the rest of the expression will match the characters ohn in that exact sequence.",NULL
The Java regular expression syntax has a few predefined character classes you can use.,"(""Java"", ""Java is related to Regular Expression because Java has a regular expression syntax"", ""Regular Expression""); (""Regular Expression"", ""Regular Expression is related to Syntax because Regular Expression has a syntax"", ""Syntax""); (""Syntax"", ""Syntax is related to Character because the syntax has predefined character classes"", ""Character""); (""Java"", ""Java is related to Syntax because Java has a regular expression syntax"", ""Syntax""); (""Java"", ""Java is related to Character because Java regular expression syntax has predefined character classes"", ""Character"")"
"For instance, the \d character class matches any digit, the \s character class matches any white space character, and the \w character matches any word character.","(""D"", ""D and S are related as they are both character classes"", ""S""); (""D"", ""D and W are related as they are both character classes"", ""W""); (""D"", ""D and S are related as they are both character classes"", ""S""); (""D"", ""D and W are related as they are both character classes"", ""W"")"
"The predefined character classes do not have to be enclosed in square brackets, but you can if you want to combine them.","(""Character"", ""Character is a type of Classes, as indicated by the text 'The predefined character classes'"", ""Classes""); (""Character"", ""Character classes can be enclosed in Square Brackets, as mentioned in the text 'do not have to be enclosed in square brackets'"", ""Square Brackets"")"
The predefined character classes are listed in a table later in this text.,"(""Character"", ""Character and Classes are related as they are both types of character classes"", ""Classes""); (""Classes"", ""Classes are listed in a Table, indicating a relationship between the two"", ""Table"")"
"The Java GZIPInputStream class (java.util.zip.GZIPInputStream) can be used to decompress files that are compressed with the GZIP compression algorithm, for instance via the GZIPOutputStream class.","(""GZIPInputStream"", ""GZIPInputStream and GZIPOutputStream are related as they are both used for GZIP compression and decompression"", ""GZIPOutputStream""); (""GZIPInputStream"", ""GZIPInputStream is part of the java.util.zip package"", ""java.util.zip"")"
In the example above I passed it a FileInputStream connected to a file named myfile.zip.,NULL
When you are finished reading data from the GZIPInputStream you should close it using its close() method.,"(""GZIPInputStream"", ""The GZIPInputStream and the close() method are related to each other because the close() method is used to close the GZIPInputStream after reading data from it."", ""close()"")"
The Java GZIPOutputStream class (java.util.zip.GZIPOutStream) can be used to GZIP compress data and write it to an OutputStream.,"(""GZIPOutputStream"", ""GZIPOutputStream is used to write compressed data to an OutputStream"", ""OutputStream""); (""java.util.zip.GZIPOutStream"", ""java.util.zip.GZIPOutStream is part of the java.util.zip package"", ""java.util.zip""); (""GZIPOutputStream"", ""GZIPOutputStream and java.util.zip.GZIPOutStream refer to the same class"", ""java.util.zip.GZIPOutStream""); (""java.util.zip"", ""GZIPOutputStream is part of the java.util.zip package"", ""GZIPOutputStream""); (""java.util.zip"", ""java.util.zip.GZIPOutStream is part of the java.util.zip package"", ""java.util.zip.GZIPOutStream""); (""OutputStream"", ""OutputStream is used by GZIPOutputStream to write compressed data"", ""GZIPOutputStream"")"
This Java ZIP tutorial explains how the core classes of the Java ZIP API works.,"(""Java ZIP API"", ""The Java ZIP tutorial is related to the Java ZIP API because it explains how the core classes of the Java ZIP API works."", ""Java ZIP tutorial"")"
The Java ZipFile class is used to work with ZIP files containing multiple files.,NULL
The Java GZIPInputStream and GZIPOutputStream classes are used to ZIP compress a single file.,NULL
The above classes will be covered in detail their own tutorials (see the side menu for links).,"(""Classes"", ""The classes are related to tutorials because they will be covered in detail in their own tutorials."", ""Tutorials""); (""Tutorials"", ""The tutorials are related to the side menu because links to them can be found in the side menu."", ""Side Menu""); (""Side Menu"", ""The side menu is related to links because it contains links to the tutorials."", ""Links""); (""Classes"", ""The classes are related to the side menu because their tutorials, which are linked to in the side menu, cover them in detail."", ""Side Menu""); (""Classes"", ""The classes are related to links because their tutorials, which are linked to, cover them in detail."", ""Links"")"
The Java ZipFile class (java.util.zip.ZipFile) can be used to read files from a ZIP file.,NULL
This tutorial will show you how to use the ZipFile class.,NULL
In order to use the Java ZipFile class you must first create a ZipFile instance.,NULL
"As you can see, the ZipFile class takes a single parameter in its constructor.",NULL
Each file in the ZIP file is represented by a ZipEntry (java.util.zip.ZipEntry).,NULL
To extract a file from the ZIP file you can call the method getEntry() method on the ZipFile class.,NULL
This example gets a ZipEntry representing the file file1.txt which is contained in the ZIP file.,"(""ZipEntry"", ""ZipEntry is related to file1.txt because it represents the file file1.txt"", ""file1.txt""); (""ZipEntry"", ""ZipEntry is related to ZIP because it is contained in the ZIP file"", ""ZIP""); (""ZipEntry"", ""ZipEntry is related to file1.txt because it represents the file file1.txt"", ""file1.txt""); (""ZipEntry"", ""ZipEntry is related to ZIP because it is contained in the ZIP file"", ""ZIP""); (""gets"", ""gets is related to ZipEntry because gets is used to get a ZipEntry"", ""ZipEntry""); (""ZipEntry"", ""ZipEntry is related to file1.txt because it represents the file file1.txt"", ""file1.txt""); (""ZipEntry"", ""ZipEntry is related to ZIP because it is contained in the ZIP file"", ""ZIP""); (""file1.txt"", ""file1.txt is related to ZIP because it is contained in the ZIP file"", ""ZIP""); (""gets"", ""gets is related to file1.txt because gets is used to get a ZipEntry representing the file file1.txt"", ""file1.txt"")"
The InputStream obtained from the getInputStream() of the ZipFile class can be read like any other Java InputStream.,"(""ZipFile"", ""The getInputStream method is a part of the ZipFile class, indicating a relationship between the two entities."", ""getInputStream""); (""getInputStream"", ""The getInputStream method returns an InputStream, showing a clear relationship between the method and the class."", ""InputStream"")"
You can list all entries contained in a ZipFile using the entries() method.,NULL
You can iterate the Enumeration returned by the entries() method like this:,NULL
The Zip Slip attack consists of adding entries to a ZipFile that contains relative file paths with one or more /.. sections in the path.,NULL
An entry in the ZipFile has the relative path ../../../../etc/hosts .,"(""ZipFile"", ""An entry is a component of a ZipFile, indicating a relationship between the two."", ""entry""); (""entry"", ""The entry has a relative path, establishing a connection between the entry and its path."", ""relative path"")"
The final path of that entry becomes: /apps/myapp/data/unzipped-file/../../../../etc/hosts which is equivalent of /etc/hosts .,"(""Apps"", ""Apps is a package that contains Myapp, indicating a hierarchical relationship."", ""Myapp""); (""Myapp"", ""Myapp contains Data, suggesting a relationship where Myapp is a parent package of Data."", ""Data"")"
"Unzipping this file could potentially overwrite hour hosts file (on a Linux OS), enabling the attacker to point e.g.","(""File"", ""The File is related to Linux OS because the text mentions that unzipping the file could potentially overwrite the hour hosts file on a Linux OS"", ""Linux OS""); (""File"", ""The File is related to Hour Hosts because the text mentions that unzipping the file could potentially overwrite the hour hosts file"", ""Hour Hosts"")"
"The Java examples in this tutorial were created with Java 8, and Acme4J Client v. 2.1 and Acme4J Utils v. 0.3.","(""Java"", ""The Java examples were created with Acme4J Client, which indicates that Java is related to Acme4J Client as it utilizes the package."", ""Acme4J Client""); (""Java"", ""The Java examples were created with Acme4J Utils, which indicates that Java is related to Acme4J Utils as it utilizes the package."", ""Acme4J Utils"")"
Here is a Java class capable of creating a private key for use with Acme4J:,NULL
Here is a class that can create a Let's Encrypt account:,NULL
It is the execute() method that starts the account creation process.,NULL
The fully qualified name for the Order class is org.shredzone.acme4j.Order .,NULL
Calling create() results in a request being sent to Let's Encrypt.,NULL
Once you have called the order.create() method a request is sent to Let's Encrypt.,"(""Order"", ""The Order entity is related to the Create entity because the Create method is called on the Order entity."", ""Create""); (""Create"", ""The Create entity is related to the Let's Encrypt entity because the request sent after calling the Create method is sent to Let's Encrypt."", ""Let's Encrypt"")"
"The above example specifically looks for an HTTP authorization object, which is then triggered by calling challenge.trigger().","(""Challenge"", ""The Challenge class has a method called trigger(), indicating a relationship between the two."", ""Trigger"")"
"Before the challenge is triggered, you must read the value from challenge.getAuthorization() and upload it in a file to your web server.","(""Challenge"", ""The Challenge class has a method called getAuthorization, indicating a relationship between the two."", ""Getauthorization""); (""Challenge"", ""The Challenge is related to the Web Server because the value from challenge.getAuthorization() is uploaded to the Web Server, indicating an interaction between the two."", ""Web Server"")"
"... where ${domain} is the domain for which you are requesting the domain for (returned by challenge.getDomain() ), and ${token} is the value returned by challenge.getToken().",NULL
"If your code cannot access your web server to upload the challenge file before calling challenge.trigger(), you can run the code in your debugger, set a breakpoint before calling challenge.trigger(), pause the code at that breakpoint, read the token (file name) and authorization (file content) out of the challenge object, upload that to your web server, and then continue the code in the debugger.","(""Code"", ""The code is run in the debugger, indicating a relationship between the two entities."", ""Debugger""); (""Code"", ""The code cannot access the web server before calling challenge.trigger(), indicating a relationship between the code and the challenge entity."", ""Challenge""); (""Debugger"", ""The debugger is used to pause the code and read the token and authorization out of the challenge object, indicating a relationship between the debugger and the challenge entity."", ""Challenge""); (""Web Server"", ""The challenge file is uploaded to the web server, indicating a relationship between the web server and the challenge entity."", ""Challenge""); (""Code"", ""The code cannot access the web server to upload the challenge file, indicating a relationship between the code and the web server entity."", ""Web Server"")"
That is what happens in the last part of the processAuth() method.,"(""Employee"", ""The Employee class has a method called processAuth."", ""Processauth""); (""Processauth"", ""The processAuth method handles user authentication in the auth package."", ""Auth"")"
"First, the code above waits until the Order object has status Status.VALID.","(""Order"", ""The Order object has a status which is of type Status, indicating a relationship between the two classes."", ""Status"")"
The value of that Ant property will be inserted at the place of the ${...} code.,NULL
This example first defines a property named dir.build which has its value set to build.,NULL
"Second, this example defines a property named dir.build.classes which has its value set to ${dir.build}/classes .","(""Dir.Build"", ""Dir.Build is related to Dir.Build.Classes because Dir.Build.Classes seems to be a subset or a part of the Dir.Build package, as indicated by the dot notation""}"", ""Dir.Build.Classes""); (""Dir.Build"", ""Dir.Build is related to Dir.Build.Classes because Dir.Build.Classes is a property that seems to be defined within or related to the Dir.Build package""}"", ""Dir.Build.Classes"")"
"When Ant defines this property it will resolve the value of the referenced property dir.build, and insert its value where the property is reference.","(""Ant"", ""Ant is related to dir.build because Ant defines the property and resolves the value of the referenced property dir.build"", ""dir.build""); (""Ant"", ""Ant is related to property because Ant defines this property and inserts its value where the property is referenced"", ""property"")"
"Thus, the second Ant property defined will have its final value set to build/classes because build is the value of the dir.build property referenced.","(""Ant"", ""Ant has a Property, which is used to define its attributes"", ""Property""); (""Property"", ""The Property's value is set based on the dir.build property"", ""dir.build""); (""dir.build"", ""The dir.build property's value is build, which determines the final value of the Property"", ""build"")"
"The echo task as defined here will print out the message ""This is version 1.2.3"" to the console.","(""Echo"", ""The echo task is defined, indicating a relationship between the Echo class and the Task class, possibly with Echo being a subclass or implementation of Task"", ""Task""); (""Task"", ""The task will print out a message, indicating that the Task class has a method or uses the Print method to perform its operation"", ""Print"")"
"Just to recap, a ""Java build tool"" is a tool which can compile Java code, run the unit tests for it, package the compiled classes into a JAR file and many, many other things.","(""Java"", ""Java is used by the Java build tool to compile Java code"", ""Java build tool""); (""Java build tool"", ""The Java build tool packages the compiled classes into a JAR file"", ""JAR"")"
This Ant tutorial is based on Ant version 1.9.6 which is the newest version of Ant at the time of writing (august 2015).,"(""Ant"", ""Ant version 1.9.6 is a version of Ant, so they are related"", ""Ant version 1.9.6""); (""Ant"", ""The Ant tutorial is based on Ant, so they are related"", ""Ant tutorial""); (""Ant version 1.9.6"", ""The Ant tutorial is based on Ant version 1.9.6, so they are related"", ""Ant tutorial""); (""August"", ""August is the time when Ant version 1.9.6 was the newest version of Ant, so they are related"", ""Ant""); (""August"", ""August is the time when Ant version 1.9.6 was the newest version, so they are related"", ""Ant version 1.9.6"")"
"Inside the project directory you have just created, create an empty file named build.xml.",NULL
"By default Ant looks for a build script named build.xml in your project root directory, so you might as well call your Ant build script build.xml.","(""Ant"", ""Ant looks for a build script named build.xml, indicating a relationship between Ant and build.xml"", ""build.xml""); (""Ant"", ""Ant looks for a build script in the project root directory, indicating a relationship between Ant and the project root directory"", ""project root directory""); (""build.xml"", ""build.xml is located in the project root directory, indicating a relationship between build.xml and the project root directory"", ""project root directory""); (""Ant build script"", ""An Ant build script can be named build.xml, indicating a relationship between the Ant build script and build.xml"", ""build.xml"")"
"You could use another name, but using build.xml makes your Ant commands shorter, and it makes it easier for other developers to find the Ant build script.","(""Ant"", ""Ant is related to Ant build script because Ant build script is a script used for Ant."", ""Ant build script""); (""Ant"", ""Ant is related to Ant commands because Ant commands are used in Ant."", ""Ant commands""); (""Ant build script"", ""Ant build script is related to build.xml because build.xml is a file name that can be used for the Ant build script."", ""build.xml""); (""developers"", ""developers are related to Ant because developers use Ant."", ""Ant""); (""developers"", ""developers are related to Ant build script because developers use the Ant build script."", ""Ant build script""); (""developers"", ""developers are related to build.xml because developers use build.xml for the Ant build script."", ""build.xml""); (""Ant commands"", ""Ant commands are related to Ant build script because Ant commands are used to run the Ant build script."", ""Ant build script"")"
Open the build.xml file and insert the following text (XML) into it:,NULL
You can test this build file by opening a command prompt and change directory into the directory that contains the build.xml file and execute this command:,"(""Build"", ""The Build entity is related to the Build.Xml entity because the build.xml file is likely a configuration file for the Build class."", ""Build.Xml""); (""Test"", ""The Test entity is related to the Build entity because testing is often a part of the build process."", ""Build""); (""Execute"", ""The Execute entity is related to the Build entity because the execute command is used to run the build process."", ""Build"")"
"This test was performed using Java 5, Butterfly Container 1.9.11-beta, and Guice 1.0.",NULL
"The test performs 10.000.000 instantiations of a TestProduct class using a no-arg constructor, for each DI mechanism.",NULL
Java is a statically typed language meaning that types (primtives and classes) cannot change at runtime.,"(""Java"", ""Java is related to classes because Java is an object-oriented programming language that uses classes to define objects."", ""classes"")"
"It is not like you can all of a sudden let your Java class members, method parameters and variables be untyped.","(""Java"", ""Java is related to Class Members because Class Members are a part of a Java class"", ""Class Members""); (""Java"", ""Java is related to Method Parameters because Method Parameters are often used within Java methods"", ""Method Parameters""); (""Java"", ""Java is related to Variables because Variables are often declared and used in Java"", ""Variables""); (""Class Members"", ""Class Members and Method Parameters are related as they can both be considered as part of a class's structure and functionality"", ""Method Parameters""); (""Class Members"", ""Class Members are related to Variables because Variables can be part of a class's member variables"", ""Variables"")"
"This is done at the beginning, by the method call BO.setDao(dao).","(""BO"", ""BO is a class that contains the method setDao"", ""setDao""); (""setDao"", ""The method setDao is related to dao as it is setting the dao object"", ""dao"")"
"But, notice how no DI is used inside the BO.checkPersonIsValid() or the DAO.readPerson() methods.","(""BO"", ""BO is a class that contains the method checkPersonIsValid, indicating that checkPersonIsValid is a part of BO""}"", ""checkPersonIsValid""); (""DAO"", ""DAO is a class that contains the method readPerson, indicating that readPerson is a part of DAO""}"", ""readPerson"")"
I most likely never have to change implementation of the Person class.,NULL
In Java this will result in a class cast exception at runtime (or some similar type error exception).,"(""Java"", ""Java is related to Class Cast Exception because it is the programming language in which the exception occurs"", ""Class Cast Exception""); (""Java"", ""Java is related to Runtime because it is the environment in which the exception is thrown"", ""Runtime""); (""Java"", ""Java is related to Type Error Exception because it is the programming language in which the exception is defined"", ""Type Error Exception""); (""Class Cast Exception"", ""Class Cast Exception is related to Runtime because the exception is thrown at runtime"", ""Runtime""); (""Type Error Exception"", ""Type Error Exception is related to Runtime because the exception is similar to the one thrown at runtime"", ""Runtime"")"
"Each factory definition states how a given instance is to be created and configured, when calling the container.instance() method.","(""Factory"", ""A factory definition is related to the instance method as it states how a given instance is to be created and configured when calling this method"", ""Instance()""); (""Container"", ""The container class is related to the instance method as it is the class that this method is called on"", ""Instance()"")"
"The input parameters .hashcode() and .equals() methods determine if an input parameter has an instance associated with it already, or a new one needs to be created and associated with the input parameter for succeeding calls.","(""Hashcode"", ""The hashcode method is used to determine if an input parameter has an instance associated with it already, indicating a relationship between the hashcode method and the input parameter."", ""Input Parameter""); (""Equals"", ""The equals method is used to determine if an input parameter has an instance associated with it already, indicating a relationship between the equals method and the input parameter."", ""Input Parameter"")"
As you can see the constructor call was chained with a call to the setValue() method.,NULL
"Notice how the length() method is called on the ""value"" parameter.",NULL
"If the setValue() method in the example above returns void, the factory will return the SomeObject instance the method was called on.","(""SetValue"", ""The SetValue method is called on an instance of the SomeObject class, indicating a relationship between the two."", ""SomeObject""); (""Factory"", ""The factory returns an instance of the SomeObject class, indicating a relationship between the factory and the SomeObject class."", ""SomeObject"")"
The factory defined by this script will return a SomeObject instance that has had the two methods setValue() and setValue2() invoked on it.,"(""SomeObject"", ""SomeObject is related to setValue() because it has had the method setValue() invoked on it"", ""setValue()"")"
"Here is a list of classes and primitives that parameters can be converted to, automatically:","(""Classes"", ""Classes can be converted to parameters automatically"", ""Parameters""); (""Primitives"", ""Primitives can be converted to parameters automatically"", ""Parameters"")"
Sometimes a constructor or method call in a factory definition matches more than one constructor or method in the owning class.,"(""Constructor"", ""A constructor is related to a factory because a constructor or method call in a factory definition can match more than one constructor in the owning class."", ""Factory""); (""Method"", ""A method is related to a factory because a constructor or method call in a factory definition can match more than one method in the owning class."", ""Factory""); (""Constructor"", ""A constructor is related to the owning class because it is a part of the class and can be matched by a factory definition."", ""Owning Class""); (""Method"", ""A method is related to the owning class because it is a part of the class and can be matched by a factory definition."", ""Owning Class""); (""Constructor"", ""A constructor is related to a factory because a constructor or method call in a factory definition can match more than one constructor in the owning class."", ""Factory""); (""Method"", ""A method is related to a factory because a constructor or method call in a factory definition can match more than one method in the owning class."", ""Factory""); (""Constructor"", ""A constructor is related to the owning class because it is a part of the class and can be matched by a factory definition."", ""Owning Class""); (""Method"", ""A method is related to the owning class because it is a part of the class and can be matched by a factory definition."", ""Owning Class"")"
You can cast to any type or class available on the classpath.,NULL
"To call a static method instead of a constructor when creating an instance of some class, simply write as you would in Java:","(""Class"", ""A class can have multiple methods, and methods are used to define the behavior of a class"", ""Method""); (""Method"", ""A method is a part of a class, and it can be used to perform operations on instances of that class"", ""Class""); (""Java"", ""Java is a programming language that supports the concept of classes, and classes are a fundamental part of Java programming"", ""Class"")"
Note: The container uses java.util.ArrayList and java.util.HashSet as the List and Set implementations.,"(""ArrayList"", ""ArrayList is part of the java.util package, as indicated by its fully qualified name java.util.ArrayList"", ""java.util"")"
From version 2.5.9 Butterfly Container Script provides a shortcut to configuring Map instances.,"(""Butterfly Container Script"", ""Butterfly Container Script provides a shortcut to configuring Map instances, indicating a relationship between the two classes"", ""Map"")"
First an instance of SomeObject is created and then the setValue() method is called on it.,NULL
Below is an example that register the newly created instance with a static method in the MyClass class.,NULL
You can inject instances of classes created locally in a factory definition.,"(""Classes"", ""Classes are related to Instances because instances are created from classes."", ""Instances""); (""Factory"", ""Factory is related to Classes because factory definition can inject instances of classes."", ""Classes""); (""Factory Definition"", ""Factory Definition is related to Classes because factory definition can inject instances of classes created locally."", ""Classes"")"
"Notice how the setNewValue() method is called on the instance obtained from the bean1 factory, before it is injected into OtherObject's constructor.","(""Setnewvalue"", ""The setNewValue() method is called on the instance obtained from the bean1 factory, indicating a relationship between the method and the class."", ""Bean1""); (""Bean1"", ""The instance obtained from the bean1 factory is injected into OtherObject's constructor, indicating a relationship between the two classes."", ""Otherobject"")"
"Thus, the setFurtherValue() method of the someObject singleton is called for each instance of bean2 created, even if the method call is redundant.","(""Someobject"", ""The setFurtherValue() method is a part of the someObject singleton, indicating a relationship between the two."", ""Setfurthervalue()""); (""Bean2"", ""The someObject singleton is related to bean2 as its setFurtherValue() method is called for each instance of bean2 created, establishing a connection between the two entities."", ""Someobject"")"
"Notice how the bean2 definition obtains an instance from the bean1 factory, and calls the setValue() method on it before returning it.","(""Bean2"", ""Bean2 obtains an instance from Bean1, indicating a relationship between the two classes"", ""Bean1""); (""Bean2"", ""Bean2 calls the SetValue() method, indicating that Bean2 is using or interacting with the SetValue() method"", ""SetValue()"")"
"Input parameters can be given to the container.instance() method, like this:","(""Container"", ""The Container class has a method called instance(), indicating a relationship between the Container class and the instance method."", ""Instance""); (""Input Parameters"", ""The Input Parameters are given to the Container, indicating a relationship between the Input Parameters and the Container class."", ""Container"")"
"The container cannot determine the type of input parameters until runtime, when the container.instance() method is called.","(""Container"", ""The Container class has an instance method"", ""Instance"")"
Therefore it is only possible to call methods that exists in java.lang.Object on input parameters.,"(""Java"", ""Java is related to Lang as it is part of the java.lang package"", ""Lang""); (""Lang"", ""Lang is related to Object as it is a class within the java.lang package"", ""Object""); (""Java"", ""Java is related to Object as it is the class from which all other classes in Java inherit"", ""Object""); (""Java.Lang.Object"", ""Java.Lang.Object package is related to Java as it is a part of the Java language"", ""Java""); (""Java.Lang.Object"", ""Java.Lang.Object package is related to Lang as it is a part of the package"", ""Lang"")"
"Your application will ask the container for an object, and the container will make sure that all dependencies (config parameters, collaborating objects, texts etc.)","(""Application"", ""The application will ask the container for an object, indicating a relationship between the two."", ""Container""); (""Container"", ""The container will make sure that all dependencies are provided to the object, indicating a relationship between the container and the object."", ""Object""); (""Container"", ""The container will make sure that all dependencies are provided, indicating a relationship between the container and the dependencies."", ""Dependencies"")"
"Rather than having to design integration mechanisms yourself, and decide on configuration formats etc., you can have the dependency injection container do all that for you.","(""Dependency Injection Container"", ""The Dependency Injection Container is related to Integration because it handles integration mechanisms for the user."", ""Integration"")"
"The ""connectionTimeout"" factory is defined as a singleton returning whatever value the CONNECTION_TIMEOUT constant is set to in the Constants class.",NULL
The simplest way to add a function is to create a static method in a Java class that performs the logic for the function.,"(""Java"", ""A static method is created in a Java class, indicating a relationship between the Java class and the static method."", ""Static Method""); (""Function"", ""The function is implemented using a static method, showing a relationship between the function and the static method."", ""Static Method"")"
Sometimes you may need to create an instance of some class and call a method on that instance.,"(""Class"", ""An instance is created from a class, therefore they are related."", ""Instance""); (""Instance"", ""A method is called on an instance, therefore they are related."", ""Method"")"
The beanB factory will call the beanA factory with the parameter returned from the static default() method.,"(""BeanB"", ""The beanB factory will call the beanA factory, indicating a relationship between the two classes."", ""BeanA""); (""Default"", ""The Default method is related to the BeanB factory as it returns a parameter used by the BeanB factory."", ""BeanB"")"
"If input parameter 0 passed to the beanB factory is null, then the default() method will return the default value ""default value"".",NULL
"If you need to call the default() method more than once you can simplify the script a bit by mapping the default method to a factory, and then call this factory whenever the function is needed.","(""Default"", ""The default method is mapped to a factory, indicating a relationship between the two, where the factory is used to call the default method whenever needed."", ""Factory""); (""Factory"", ""The factory is used in the script to simplify it, indicating a relationship between the factory and the script, where the factory is a part of the script."", ""Script"")"
"The default() method has been mapped to a factory called ""default"".",NULL
This default factory is then called from the beanB factory instead of calling the static default() method directly.,"(""Default Factory"", ""The default factory is called from the beanB factory, indicating a relationship between the two."", ""BeanB Factory""); (""BeanB Factory"", ""The beanB factory calls the default method instead of calling it directly, indicating a relationship between the beanB factory and the default method."", ""Default"")"
"There is no package and class name to disturb you when reading the script, and whenever you need the default function all you need to write is ""default(a, b)"", instead of ""com.myapp.util.Util.default(a, b)"".","(""Util"", ""The Util class contains the default method, indicating a relationship between the two entities."", ""default""); (""com.myapp.util"", ""The Util class is part of the com.myapp.util package, indicating a containment relationship between the two entities."", ""Util"")"
Defining the static max() method as a factory (and thereby a function) is done like this:,NULL
"This little script defines the ""max"" factory as a call to the static max() method with input parameter 0 and 1 passed to the max() method.","(""Max"", ""The Max factory is related to the max() method because it is defined as a call to the static max() method."", ""max()"")"
"The max factory will call the max() method and return the value that is largest of either the input parameter 0 passed to the beanA factory, or the hard coded value 1.","(""Max Factory"", ""The max factory will call the max() method, indicating a relationship between the Max Factory class and the Max method."", ""Max"")"
"This example uses the java.text.SimpleDateFormat class and defines its instance method parse() as a function called ""toDate"".","(""SimpleDateFormat"", ""The SimpleDateFormat class is part of the java.text package, indicating a relationship between the class and the package."", ""java.text""); (""parse"", ""The parse method is defined as an instance method of the SimpleDateFormat class, indicating a relationship between the method and the class."", ""SimpleDateFormat""); (""toDate"", ""ThetoDate function is defined as the parse method, indicating a relationship between thetoDate function and the parse method."", ""parse""); (""toDate"", ""The toDate function is related to the SimpleDateFormat class through its definition as the parse method of the class."", ""SimpleDateFormat"")"
Second the toDate factory is defined as a call to the toDateFactory and then a call to the parse() method on the instance returned from the toDateFactory.,"(""TO_DATE"", ""TO_DATE is defined as a call to TO_DATE_FACTORY, indicating a relationship between the two entities where TO_DATE_FACTORY is used to create an instance for TO_DATE"", ""TO_DATE_FACTORY""); (""TO_DATE"", ""TO_DATE is related to PARSE because TO_DATE involves a call to the PARSE method, indicating that the TO_DATE entity utilizes the PARSE method for its functionality"", ""PARSE"")"
The toDate factory takes a single parameter which is the string to parse into a java.util.Date instance.,NULL
"It is possible to extend Butterfly Container Script (BCS) with custom instantiation modes, if the standard modes (new instance, singleton etc.)","(""Butterfly Container Script"", ""Butterfly Container Script can be extended with custom instantiation modes"", ""custom instantiation modes""); (""Butterfly Container Script"", ""Butterfly Container Script has standard modes such as new instance and singleton"", ""standard modes""); (""BCS"", ""BCS can be extended with custom instantiation modes"", ""custom instantiation modes"")"
"By calling the set() method with the current request as parameter, the request is associated with the thread calling the set() method.","(""Set"", ""The set() method is related to the Request because it takes the current request as a parameter."", ""Request""); (""Set"", ""The set() method is related to the Thread because it is called by the thread."", ""Thread"")"
By calling the get() method the request object associated with the calling thread can be obtained.,"(""Get"", ""The get() method is used to obtain the request object associated with the calling thread, indicating a relationship between the get method and the request object."", ""Request""); (""Thread"", ""The request object is associated with the calling thread, indicating a relationship between the thread and the request object."", ""Request"")"
"The ""request"" factory is defined as a call to the get() method on the product returned from the ""requestCache"" factory.","(""Request"", ""The request factory is related to the get method because the get method is called on the product returned from the request cache factory to define the request factory."", ""Get""); (""Requestcache"", ""The request cache factory is related to the request factory because the request factory is defined as a call to the get method on the product returned from the request cache factory."", ""Request"")"
"In other words, as a call to the get() method on the HttpRequestCache singleton.",NULL
"The ""session"" factory is defined as a call to the getSession() method of the product returned by the ""request"" factory.","(""Session"", ""The Session factory is defined as a call to the GetSession method, indicating a relationship between the Session entity and the GetSession method."", ""GetSession""); (""GetSession"", ""The GetSession method is called on the product returned by the Request factory, indicating a relationship between the GetSession method and the Request entity."", ""Request"")"
"In other words, as a call to the getSession() method on the request object obtained from the HttpRequestCache singleton, which is the request object associated with the calling thread.","(""HttpRequestCache"", ""The HttpRequestCache is associated with the request object, which implies a relationship between the two entities."", ""request""); (""request"", ""The getSession() method is called on the request object, which indicates a relationship between the request object and the getSession() method."", ""getSession()"")"
In order to make the the request and session factories return the correct objects you must first call the HttpRequestCache's set() method.,NULL
"Another disadvantage is that all instantiation modes (singleton, thread singleton, flyweight etc.)","(""Instantiation"", ""Instantiation is related to Modes because Modes is a type of instantiation mode."", ""Modes""); (""Instantiation"", ""Instantiation is related to Singleton because Singleton is a type of instantiation mode."", ""Singleton""); (""Instantiation"", ""Instantiation is related to Thread Singleton because Thread Singleton is a type of instantiation mode."", ""Thread Singleton""); (""Instantiation"", ""Instantiation is related to Flyweight because Flyweight is a type of instantiation mode."", ""Flyweight""); (""Modes"", ""Modes is related to Singleton because Singleton is a type of mode."", ""Singleton""); (""Modes"", ""Modes is related to Thread Singleton because Thread Singleton is a type of mode."", ""Thread Singleton""); (""Modes"", ""Modes is related to Flyweight because Flyweight is a type of mode."", ""Flyweight""); (""Singleton"", ""Singleton is related to Thread Singleton because both are instantiation modes."", ""Thread Singleton""); (""Singleton"", ""Singleton is related to Flyweight because both are instantiation modes."", ""Flyweight"")"
"If you use an anonymous subclass of JavaFactory, inserted instead of ""new MyFactory()"", the JavaFactoryBuilder cannot access the ""otherFactory"" field, even if it is public.","(""JavaFactory"", ""JavaFactoryBuilder is related to JavaFactory because it cannot access the otherFactory field of an anonymous subclass of JavaFactory"", ""JavaFactoryBuilder""); (""JavaFactoryBuilder"", ""JavaFactoryBuilder cannot access the otherFactory field, indicating a relationship between the two"", ""otherFactory""); (""JavaFactory"", ""The otherFactory field is part of an anonymous subclass of JavaFactory, indicating a relationship between JavaFactory and otherFactory"", ""otherFactory"")"
"Inner classes will do just fine too, as long as they are declared ""public static"".",NULL
"This method takes 3 parameters: The name of the factory, the return type of the factory, and a subclass of JavaFactory which implements the factory.","(""Method"", ""The method takes a subclass of JavaFactory as a parameter, indicating a relationship between the method and JavaFactory."", ""JavaFactory""); (""Method"", ""The method is related to the factory as it takes the name of the factory as a parameter."", ""Factory"")"
"The name is used when calling the container.instance(""name"") method to obtain an instance from the factory.","(""Container"", ""The Container class is related to the Instance class because the container.instance method is used to obtain an instance from the factory."", ""Instance""); (""Container"", ""The Container class is related to the Factory class because the container.instance method is used to obtain an instance from the factory."", ""Factory"")"
JavaFactoryBuilder has a method that omits the return type and instead extracts that information from the return type of the JavaFactory subclass's instance method.,"(""JavaFactoryBuilder"", ""JavaFactoryBuilder has a method related to the JavaFactory subclass, indicating a relationship between the two classes"", ""JavaFactory""); (""JavaFactoryBuilder"", ""JavaFactoryBuilder has a method that interacts with the instance method of the JavaFactory subclass, indicating a relationship between the class and the method"", ""instance method"")"
Notice how no return type is passed in the addFactory() call.,NULL
Also notice how the return type of the instance() method is now MyObject.,NULL
By declaring a field of type IGlobalFactory in the JavaFactory subclass the JavaFactoryBuilder knows that the factory depends on another factory.,"(""JavaFactory"", ""JavaFactory depends on IGlobalFactory because it declares a field of this type"", ""IGlobalFactory""); (""JavaFactoryBuilder"", ""JavaFactoryBuilder knows about JavaFactory because it is responsible for creating it"", ""JavaFactory"")"
"You can add as many factories as you want, using the addFactory() method.",NULL
The ScriptFactoryBuilder has a addFactories() method that takes an InputStream as parameter instead of a String.,"(""ScriptFactoryBuilder"", ""The ScriptFactoryBuilder has a method called addFactories(), indicating a clear relationship between the class and the method."", ""addFactories()""); (""addFactories()"", ""The addFactories() method takes an InputStream as a parameter, indicating a clear relationship between the method and the InputStream class."", ""InputStream"")"
"Using this method you can load a container script from disk, over a network, from the classpath and also from inside a Jar file.","(""Load"", ""The Load method is related to the Container class because it is used to load a container script."", ""Container""); (""Load"", ""The Load method is related to the Script class because it is used to load a container script."", ""Script""); (""Load"", ""The Load method is related to the Disk class because it can load a script from disk."", ""Disk""); (""Load"", ""The Load method is related to the Network class because it can load a script over a network."", ""Network""); (""Load"", ""The Load method is related to the Classpath class because it can load a script from the classpath."", ""Classpath"")"
"To configure the container using a script contained in a file located on the classpath (including inside a Jar file), you can do like this:",NULL
"The init() method creates all singletons, starts services and other stuff that need to be done before the instances in the container can be used.",NULL
The instance() method needs the name of the object factory to get an instance from.,"(""Instance"", ""The instance() method needs the name of the object factory to get an instance from, indicating that Instance method is related to Object Factory class."", ""Object Factory""); (""Instance"", ""The instance() method needs the name of the object factory, indicating that Instance method is related to Name package as it requires the name to function."", ""Name"")"
You can put as many input parameters into the instance() call as you like.,"(""Instance"", ""Instance is related to Input because Input parameters are passed into the instance() call"", ""Input"")"
The input parameters are defined as an optional parameter (Object ... parameters).,"(""Input Parameters"", ""The input parameters are defined as an optional parameter, indicating a relationship between the two entities."", ""Optional Parameter""); (""Input Parameters"", ""The input parameters are defined as an optional parameter of type Object, indicating a relationship between the two entities."", ""Object""); (""Input Parameters"", ""The input parameters are defined with parameters, indicating a relationship between the two entities."", ""Parameters""); (""Optional Parameter"", ""The optional parameter is of type Object, indicating a relationship between the two entities."", ""Object""); (""Optional Parameter"", ""The optional parameter is defined with parameters, indicating a relationship between the two entities."", ""Parameters"")"
"When the dispose() method is called, the dispose life cycle phase is executed for all factories in the container, before the method call returns.","(""Dispose"", ""The dispose method is related to the dispose life cycle phase because the method call triggers the execution of the dispose life cycle phase."", ""Dispose""); (""Dispose"", ""The dispose method is related to factories because it executes the dispose life cycle phase for all factories in the container."", ""Factories""); (""Dispose"", ""The dispose method is related to the container because it executes the dispose life cycle phase for all factories in the container."", ""Container"")"
A thread calling get() will only get the object it had set itself by calling set().,"(""Thread"", ""A thread is related to get() because it calls this method to retrieve an object."", ""Get""); (""Thread"", ""A thread is related to set() because it calls this method to store an object that can later be retrieved by get()."", ""Set"")"
"Then the value obtained from the container.instance(""myThreadLocal"") call will be the value the calling thread associated with itself, by calling MyClass.threadLocal.set().","(""MyClass"", ""MyClass has a method called threadLocal, indicating a relationship between the class and the method."", ""threadLocal""); (""threadLocal"", ""threadLocal is being used in the context of myThreadLocal, suggesting a relationship between the method and the class."", ""myThreadLocal""); (""container.instance"", ""container.instance is being called with myThreadLocal as an argument, indicating a relationship between the method and the class."", ""myThreadLocal"")"
ThreadLocal's can be used to associate a java.util.Locale with the calling thread.,NULL
"Basically what you will do is call a ThreadLocal.set() method with the Locale to associate with the calling thread, before calling container.instance().",NULL
"Notice how the Locale is not obtained by the ThreadLocal.get() method, but via the static method getLocale().","(""Locale"", ""Locale is related to getLocale() because getLocale() is a method that is used to obtain the Locale."", ""getLocale()""); (""ThreadLocal"", ""ThreadLocal is related to get() because get() is a method of the ThreadLocal class."", ""get()"")"
"The getLocale() method functions as a cast from Object to its return value Locale, enabling the container to determine the type of the returned object (Locale).","(""getLocale()"", ""The getLocale() method returns an object of type Locale, indicating a clear relationship between the method and the class."", ""Locale""); (""getLocale()"", ""The getLocale() method is described as functioning as a cast from Object, indicating a relationship between the method and the Object class."", ""Object""); (""getLocale()"", ""The getLocale() method enables the container to determine the type of the returned object, indicating a relationship between the method and the container."", ""container""); (""Locale"", ""Locale is implicitly a subclass of Object, as all classes in Java are subclasses of Object, indicating a relationship between the two classes."", ""Object""); (""container"", ""The container is likely an instance of a class, and all classes in Java are subclasses of Object, indicating a possible relationship between the container and the Object class."", ""Object"")"
"Notice how the HttpServletRequest and HttpServletResponse are not obtained by the ThreadLocal.get() method, but via the static methods getRequest() and getResponse().","(""HttpServletRequest"", ""HttpServletRequest is related to getRequest because getRequest is a method that obtains the HttpServletRequest"", ""getRequest""); (""HttpServletResponse"", ""HttpServletResponse is related to getResponse because getResponse is a method that obtains the HttpServletResponse"", ""getResponse""); (""ThreadLocal"", ""ThreadLocal is related to get because get is a method of ThreadLocal"", ""get""); (""ThreadLocal"", ""ThreadLocal is related to getRequest because getRequest is a static method that uses ThreadLocal internally"", ""getRequest""); (""ThreadLocal"", ""ThreadLocal is related to getResponse because getResponse is a static method that uses ThreadLocal internally"", ""getResponse""); (""HttpServletRequest"", ""HttpServletRequest is related to ThreadLocal because ThreadLocal is used to manage the HttpServletRequest instance"", ""ThreadLocal"")"
"The getRequest() method functions as a cast from Object to its return value HttpServletRequest, enabling the container to determine the type of the returned object (HttpServletRequest).","(""GETREQUEST()"", ""The getRequest() method returns an object of type HttpServletRequest, indicating a relationship between the two."", ""HTTPSERVLETREQUEST"")"
"Instantiation time localization means that you inject localized dependencies (texts, paths, number and date formatters etc.)","(""Instantiation"", ""Instantiation is related to Localization because it is mentioned as 'Instantiation time localization' in the text, suggesting a connection between the two concepts."", ""Localization""); (""Localization"", ""Localization is related to Dependencies because the text mentions 'inject localized dependencies', indicating that localization involves dependencies."", ""Dependencies""); (""Dependencies"", ""Dependencies is related to Texts because the text mentions 'localized dependencies (texts, ...)', suggesting that texts are a type of dependency."", ""Texts""); (""Dependencies"", ""Dependencies is related to Paths because the text mentions 'localized dependencies (... , paths, ...)', suggesting that paths are a type of dependency."", ""Paths""); (""Dependencies"", ""Dependencies is related to Number because the text mentions 'localized dependencies (... , number ...)', suggesting that number is a type of dependency."", ""Number""); (""Dependencies"", ""Dependencies is related to Date because the text mentions 'localized dependencies (... , date ...)', suggesting that date is a type of dependency."", ""Date"")"
"As you can imagine, the more resources the MyComponent needs, the larger both the class and the configuration grows.",NULL
"As you can imagine, only the execute() method will grow as the number of localized dependencies grow.",NULL
"Assuming that the MyService class implements an interface called IService, you can create a mock implementation of the IService interface using this code:",NULL
This mockService factory returns a dynamic implementation of the IService interface based on Java's java.lang.reflect.Proxy class.,"(""MockService"", ""MockService is related to IService because it returns a dynamic implementation of the IService interface"", ""IService""); (""MockService"", ""MockService is related to java.lang.reflect.Proxy because it uses Java's java.lang.reflect.Proxy class to return a dynamic implementation"", ""java.lang.reflect.Proxy""); (""IService"", ""IService is related to java.lang.reflect.Proxy because the dynamic implementation of IService is based on Java's java.lang.reflect.Proxy class"", ""java.lang.reflect.Proxy""); (""Java"", ""Java is related to java.lang.reflect.Proxy because java.lang.reflect.Proxy is a part of Java's language"", ""java.lang.reflect.Proxy"")"
"The serviceMock instance passed to the getMock() method should be the mock object obtained from the mockService factory, using the container.instance(""mockService"") method call.","(""ServiceMock"", ""The serviceMock instance is passed to the getMock method, indicating a clear relationship between the two entities."", ""GetMock""); (""MockService"", ""The getMock method is used in conjunction with the mockService factory, suggesting a relationship between the MockService class and the getMock method."", ""GetMock""); (""Container"", ""The container is used to obtain an instance of the mockService, indicating a relationship between the Container class and the MockService class."", ""MockService"")"
"In other words, the instance returned from the MockFactory.createProxy() method call.",NULL
This way it is possible to detect if close() is called on the database connection after some method call that uses the connection has completed.,"(""Close"", ""Close is called on the database connection"", ""Database Connection""); (""Method Call"", ""Method call uses the database connection"", ""Database Connection"")"
"A suggestion would be to have a PersonDao.getConnection() method, even though you'd probably mostly use it during testing.",NULL
From version 2.1.9 it is possible to replace factories at runtime.,"(""Version"", ""The source entity Version and the target entity Factories are related because the text mentions replacing factories at a specific version, implying a connection between the two."", ""Factories""); (""Factories"", ""The source entity Factories and the target entity Runtime are related because the text states that factories can be replaced at runtime, establishing a relationship between factories and the runtime environment."", ""Runtime"")"
"It is also possible to replace several script factories at a time, by using the ScriptFactoryBuilder.replaceFactories(InputStream) method.","(""ScriptFactoryBuilder"", ""ScriptFactoryBuilder has a method called replaceFactories"", ""replaceFactories""); (""replaceFactories"", ""replaceFactories method takes an InputStream as a parameter"", ""InputStream"")"
Rather than configuring the PersonDao by hand with dependencies (and their dependencies recursively) you just reuse the configuration of the PersonDao from the application container configuration (the file containerConfig.bcs).,"(""PersonDao"", ""PersonDao is configured using the configuration from containerConfig.bcs"", ""containerConfig.bcs"")"
"When designing Butterfly we considered using an XML format for configuration like several alternative DI containers do (Spring, Nano etc.).","(""Butterfly"", ""Butterfly is related to Spring as they are both considered as alternative DI containers"", ""Spring""); (""Butterfly"", ""Butterfly is related to Nano as they are both considered as alternative DI containers"", ""Nano""); (""Butterfly"", ""Butterfly is related to XML as XML was considered as a format for configuration"", ""XML""); (""Spring"", ""Spring is related to XML as Spring uses XML format for configuration"", ""XML"")"
In this example a java.util.ArrayList() instance is created inside the call to setSomeList().,"(""java.util.ArrayList"", ""java.util.ArrayList is used inside the call to setSomeList(), indicating that setSomeList() is a method that utilizes or relies on java.util.ArrayList"", ""setSomeList()""); (""ArrayList"", ""ArrayList is used inside the call to setSomeList(), indicating that setSomeList() is a method that utilizes or relies on ArrayList"", ""setSomeList()"")"
As you can see the List.add() method is called twice to add the string and myDataSource factory product to the list.,"(""List"", ""The List class has an add method"", ""add""); (""add"", ""The add method is used to add a string to the list"", ""string""); (""add"", ""The add method is used to add myDataSource factory product to the list"", ""myDataSource"")"
The fact One of the advantages you get when designing your own language is the freedom to e.g make methods that return void chainable.,"(""Language"", ""Language has methods, and the ability to design a language allows for the creation of methods that return void and are chainable"", ""Methods"")"
"The [] around the values in the setSomeList() call signals that the values are to be put inside a List or array, depending on the setSomeList() parameter type.","(""SetSomeList"", ""The setSomeList() method is related to the List class because it can accept a List as a parameter."", ""List"")"
It is possible to map classes to tables and columns using annotations.,"(""Classes"", ""Classes are mapped to tables"", ""Tables""); (""Classes"", ""Classes are indirectly related to columns through tables"", ""Columns""); (""Classes"", ""Classes use annotations for mapping"", ""Annotations""); (""Tables"", ""Tables have columns"", ""Columns""); (""Tables"", ""Annotations are used in the context of tables for mapping purposes"", ""Annotations"")"
You cannot have more than one mapping for the same class using annotation based mapping alone.,"(""Class"", ""A class is related to a mapping because a mapping is created for a class using annotation based mapping."", ""Mapping""); (""Annotation"", ""An annotation is related to a mapping because annotation based mapping is used to create a mapping for a class."", ""Mapping"")"
Each annotation is only allowed once in the code for a given class by the Java compiler.,"(""Annotation"", ""The Java compiler enforces the rule that each annotation is only allowed once in the code for a given class, indicating a relationship between the annotation and the Java compiler."", ""Java Compiler""); (""Annotation"", ""The annotation is used in the code, establishing a relationship between the annotation and the code."", ""Code"")"
There are two types of annotations available: A class annotation Annotations for getters and setters.,"(""Annotations"", ""Annotations is related to getters because it provides annotations for getters"", ""getters""); (""Annotations"", ""Annotations is related to setters because it provides annotations for setters"", ""setters"")"
AClassMapping The class annotation (AClassMapping) is used ontop of your class name for your POJO classes.,NULL
"If you set the mappingMode to ""modify"" then Butterfly Persistence will first use automatic mapping to guess as much as it can, and then look at the annotations and modify the class mapping accordingly.","(""Butterfly Persistence"", ""Butterfly Persistence uses mappingMode to determine the mapping approach"", ""mappingMode""); (""Butterfly Persistence"", ""Butterfly Persistence modifies the class mapping accordingly"", ""class mapping""); (""mappingMode"", ""mappingMode affects the class mapping"", ""class mapping"")"
"The tableName element can be set to the name of the table the class is to be mapped to, if it cannot be guessed by the automatic mapping mechanism.","(""TableName"", ""The tableName element is related to the table because it is set to the name of the table the class is to be mapped to""}"", ""Table""); (""Table"", ""The table is related to the automatic mapping mechanism because the mechanism is used to guess the table name if it cannot be set""}"", ""Automatic Mapping Mechanism"")"
"If you have a database generated (e.g auto-incremented) primary key that is mapped to a getter method, you will have to mark the getter method as database generated, to avoid having Butterly Persistence try to set that value in the database.","(""Butterly Persistence"", ""Butterly Persistence uses Getter Method to avoid setting a value in the database."", ""Getter Method""); (""Getter Method"", ""Getter Method is mapped to a database generated primary key."", ""Primary Key""); (""Butterly Persistence"", ""Butterly Persistence tries to set a value in the Database."", ""Database"")"
The class annotation (AClassMapping) is used ontop of your class name for your POJO classes.,NULL
"Notice how the second class definition uses manual mapping, so the getter and setter must be fully mapped to columns in the database.","(""Class"", ""The class definition uses manual mapping to columns in the database, indicating a relationship between the class and the database."", ""Database""); (""Class"", ""The class definition requires the getter to be fully mapped to columns, indicating a relationship between the class and the getter."", ""Getter""); (""Class"", ""The class definition requires the setter to be fully mapped to columns, indicating a relationship between the class and the setter."", ""Setter""); (""Getter"", ""The getter must be fully mapped to columns in the database, indicating a relationship between the getter and the database."", ""Database""); (""Setter"", ""The setter must be fully mapped to columns in the database, indicating a relationship between the setter and the database."", ""Database""); (""Getter"", ""The getter is mapped to columns, indicating a relationship between the getter and the columns."", ""Columns""); (""Setter"", ""The setter is mapped to columns, indicating a relationship between the setter and the columns."", ""Columns""); (""Class"", ""The class definition uses manual mapping to columns, indicating a relationship between the class and the columns."", ""Columns"")"
The ASetterMapping annotation is used to map setters of classes to columns in database tables or SQL queries.,"(""ASetterMapping"", ""The ASetterMapping annotation is used to map setters of classes, indicating a relationship between the ASetterMapping class and the setters method."", ""Setters""); (""ASetterMapping"", ""The ASetterMapping annotation is used to map setters to columns, indicating a relationship between the ASetterMapping class and the columns class."", ""Columns""); (""ASetterMapping"", ""The ASetterMapping annotation is used to map setters to columns in database tables, indicating a relationship between the ASetterMapping class and the database tables class."", ""DatabaseTables""); (""ASetterMapping"", ""The ASetterMapping annotation is used to map setters to columns in SQL queries, indicating a relationship between the ASetterMapping class and the SQL queries class."", ""SQLQueries""); (""Setters"", ""The setters method is used to map to columns, indicating a relationship between the setters method and the columns class."", ""Columns""); (""Setters"", ""The setters method is used to map to columns in database tables, indicating a relationship between the setters method and the database tables class."", ""DatabaseTables""); (""Setters"", ""The setters method is used to map to columns in SQL queries, indicating a relationship between the setters method and the SQL queries class."", ""SQLQueries""); (""Columns"", ""The columns class is related to the database tables class, as columns are part of database tables."", ""DatabaseTables""); (""Columns"", ""The columns class is related to the SQL queries class, as columns are part of SQL queries."", ""SQLQueries"")"
In this example the Employee.class object is the object mapping key.,NULL
"However, if you want Butterfly Persistence to be able to auto-map the target class to the database, the object mapping key should be either a Class object, or an IObjectMappingKey instance.","(""Butterfly Persistence"", ""Butterfly Persistence uses IObjectMappingKey for auto-mapping the target class to the database"", ""IObjectMappingKey""); (""Butterfly Persistence"", ""Butterfly Persistence uses Class object for auto-mapping the target class to the database"", ""Class""); (""IObjectMappingKey"", ""IObjectMappingKey is an alternative to Class object for auto-mapping the target class to the database"", ""Class""); (""Butterfly Persistence"", ""Butterfly Persistence uses object mapping key for auto-mapping the target class to the database"", ""object mapping key""); (""IObjectMappingKey"", ""IObjectMappingKey is an instance that can be used as an object mapping key"", ""object mapping key"")"
"The IObjectMappingKey instance can contain more information about the class to be mapped, than a Class object can.",NULL
"An IObjectMappingKey instance has a getObjectClass() method that returns the Class object of the class to map, so automatic mapping is possible in either case.","(""IObjectMappingKey"", ""The IObjectMappingKey instance has a getObjectClass() method, indicating a relationship between the two entities as the method is a part of the class."", ""getObjectClass()""); (""getObjectClass()"", ""The getObjectClass() method returns the Class object, establishing a clear relationship between the method and the Class entity as the method's return type is Class."", ""Class"")"
When checking for tables with similar names to the class to map only the class name itself is used.,"(""Class"", ""The class is related to the table because the text mentions checking for tables with similar names to the class."", ""Table"")"
The ObjectMapper generates various textual combinations based on the class name and checks the database meta data to see if any of these match.,NULL
"The ObjectMapper mapper breaks the class name into words, based on the uppercase letters and numbers in the class name.","(""ObjectMapper"", ""The ObjectMapper is a class that breaks the class name into words, based on the uppercase letters and numbers in the class name, indicating a relationship between the ObjectMapper class and the class name it processes."", ""class"")"
Based on these combinations the PersistentObject class name would be similar to the table names PersistentObject persistentObject persistentobject PERSISTENTOBJECT Persistent_Object persistent_object PERSISTENT_OBJECT PersistentObjects persistentObjects persistentobjects PERSISTENTOBJECTS PERSISTENTOBJECTs Persistent_Objects persistent_objects PERSISTENT_OBJECTS PERSISTENT_OBJECTs As you can see there is a reasonable chance that the table name will be guessed if it is similar to the class name.,NULL
"The Object Mapper uses reflection to iterate the methods of the class to be mapped, and filters out all other methods than getters and setters.","(""Object Mapper"", ""The Object Mapper uses reflection to iterate the methods of the class to be mapped"", ""reflection""); (""Object Mapper"", ""The Object Mapper uses reflection to iterate the methods of the class to be mapped"", ""class""); (""Object Mapper"", ""The Object Mapper uses reflection to iterate the methods of the class to be mapped"", ""methods""); (""class"", ""The Object Mapper uses reflection to iterate the methods of the class to be mapped"", ""methods""); (""methods"", ""The Object Mapper filters out all other methods than getters and setters"", ""getters"")"
If your custom mapper implementation returns an object mapping from the getObjectMapping() method then automatic and annotation based mapping are not applied.,NULL
"If a table name is returned from the getTableName() method, then Butterfly Persistence will not try to guess a table name, nor look at the class annotation for table name.","(""GetTableName"", ""The GetTableName method is used by Butterfly Persistence to determine the table name, indicating a relationship between the two entities."", ""Butterfly Persistence""); (""Butterfly Persistence"", ""Butterfly Persistence uses the table name, either by guessing or looking at the class annotation, indicating a relationship between the two entities."", ""Table Name"")"
If null is returned Butterfly Persistence will look at the class annotation to see if a table name is set there.,"(""Butterfly Persistence"", ""Butterfly Persistence looks at the class annotation to check for a table name, indicating a relationship between the two entities."", ""class annotation""); (""class annotation"", ""The class annotation and table name are related as the annotation is used to set the table name, indicating a direct relationship between the two entities."", ""table name"")"
If the getObjectMapping() method returned null Butterfly Persistence will call the modify() method to allow your custom object mapper to modify the automatically generated mapping.,"(""Butterfly Persistence"", ""Butterfly Persistence uses the getObjectMapping() method to determine the next course of action"", ""Getobjectmapping()""); (""Butterfly Persistence"", ""Butterfly Persistence calls the modify() method to allow custom object mapping modifications"", ""Modify()"")"
Before doing so Butterfly Persistence will have applied the annotations in the class to the mapping.,"(""Butterfly Persistence"", ""Butterfly Persistence applies the annotations in the class to the mapping, indicating a relationship between them"", ""annotations""); (""Butterfly Persistence"", ""Butterfly Persistence applies the annotations to the mapping, indicating that Butterfly Persistence is related to the mapping"", ""mapping"")"
"If you want Butterfly Persistence to manage the opening of connections, pass a javax.sql.DataSource implementation into the constructor of the PersistenceManager.","(""Butterfly Persistence"", ""Butterfly Persistence is related to PersistenceManager because PersistenceManager is a part of it, managing the opening of connections."", ""PersistenceManager""); (""PersistenceManager"", ""PersistenceManager is related to javax.sql.DataSource because a javax.sql.DataSource implementation is passed into the constructor of the PersistenceManager."", ""javax.sql.DataSource"")"
The readLong() method comes in another version too which takes an optional list of parameters.,NULL
They will be inserted in the sequence they are passed to the readLong() method.,"(""They"", ""They will be inserted in the sequence they are passed to the readLong() method, indicating a relationship between They and Readlong as the method is acting on them."", ""Readlong""); (""Readlong"", ""The readLong() method is related to the sequence as it is the method being used to insert into the sequence."", ""Sequence"")"
"The string (4,5,6,7) is an id string which could be returned by the readIdString() method.",NULL
The readIdString() method comes in a variant that takes an optional list of parameters.,NULL
The IJdbcDao has a few read() methods that allows you to decide what to do with each record in the ResultSet resulting from some SQL query.,"(""IJdbcDao"", ""The IJdbcDao has a few read() methods, indicating that read() is a method of the IJdbcDao class."", ""read()""); (""read()"", ""The read() method allows you to decide what to do with each record in the ResultSet, indicating a relationship between the read() method and the ResultSet class."", ""ResultSet""); (""IJdbcDao"", ""The IJdbcDao has a few read() methods that allows you to decide what to do with each record in the ResultSet, indicating a relationship between the IJdbcDao class and the ResultSet class."", ""ResultSet""); (""read()"", ""The read() method is used in conjunction with some SQL query, indicating a relationship between the read() method and the SQL class."", ""SQL"")"
To do so you must provide the read() method with an implementation of the IResultSetProcessor interface.,NULL
The init() method is called before the iteration of the ResultSet begins.,NULL
The process() method is called for each record in the ResultSet The read() method returns an object.,"(""Process"", ""The process() method is called for each record in the ResultSet, indicating a relationship between the Process method and the ResultSet class"", ""ResultSet"")"
This is the object is obtained from the getResult() method of the IResultSetProcessor.,NULL
Here is an example of how to use a IResultSetProcessor with the read() methods:,NULL
It may be a good idea to create a base class for your IResultSetProcessor implementations with empty method implementations for init() and perhaps a default behaviour for getResult().,"(""IResultSetProcessor"", ""IResultSetProcessor has an init method"", ""Init"")"
The read() method comes in a version that takes an optional number of parameters.,NULL
Notice how the number 1975 is passed into the read() method at the end.,NULL
The execute() method should execute the PreparedStatement and return the result of the execution.,"(""Execute"", ""The execute method is related to the PreparedStatement because it should execute the PreparedStatement."", ""PreparedStatement"")"
The postProcess() method is normally used to call methods on the PreparedStatement after execution.,NULL
"To read the ids of X records returned from a query into a string of the format (id1, id2, id3, ...) you will do like this:",NULL
"From version 5.3.9 you no longer need to cast the returned object, if you use a Class object as object mapping key.","(""Class"", ""Class is related to object as it is used as an object mapping key"", ""object""); (""version 5.3.9"", ""version 5.3.9 is related to Class as it specifies the version from which the casting is no longer needed for Class objects"", ""Class"")"
You can also parameterize the SQL statement and pass the parameters to the readList() method.,NULL
"This text contains a few examples of how to use the object DAO, IObjectDao, so you can get an idea about how to use the IObjectDao class:",NULL
In addition the Person class and persons table are defined like this:,NULL
"Thus, it doesn't matter how many fields in a class are mapped to columns in the ""items"" table.","(""Class"", ""A class contains fields, which is a fundamental relationship in object-oriented programming."", ""Fields""); (""Class"", ""A class can be mapped to a table in a database, which is a common relationship in data modeling."", ""Table""); (""Class"", ""The class is related to the items table, as stated in the given text, where fields in a class are mapped to columns in the items table."", ""Items""); (""Fields"", ""Fields in a class are mapped to columns in a table, which is a direct relationship."", ""Columns""); (""Table"", ""The table and items are related as the items is the name of the table."", ""Items""); (""Table"", ""A table contains columns, which is a basic relationship in database design."", ""Columns"")"
"Therefore you need to create a special object mapping for the given class, that only maps the fields you want to write to columns in the database.","(""Class"", ""The class is related to the object because the text mentions creating a special object mapping for the given class."", ""Object""); (""Object"", ""The object is related to the database because the text mentions mapping fields to columns in the database."", ""Database""); (""Class"", ""The class is related to the database because the text mentions mapping fields of the class to columns in the database."", ""Database""); (""Fields"", ""The fields are related to the columns because the text mentions mapping fields to columns in the database."", ""Columns""); (""Object"", ""The object is related to the fields because the text mentions creating a special object mapping for the given class that only maps the fields."", ""Fields"")"
"The object mapping key could be any object you choose, but if you want help from Butterfly Persistence to map a class to the database, the object mapping key should be either a java.lang.Class object, or an ObjectMappingKey instance.","(""Butterfly Persistence"", ""Butterfly Persistence provides help to map a class to the database using ObjectMappingKey"", ""ObjectMappingKey""); (""Butterfly Persistence"", ""Butterfly Persistence provides help to map a class to the database, with java.lang.Class being a type of object mapping key"", ""java.lang.Class"")"
"For instance, Employee.class is the object mapping key in the method call below:",NULL
"To enable easy, always-in-time custom object mapping Butterfly Persistence provides the ObjectMappingKey class for advanced object mapping keys.",NULL
Creating an ObjectMappingKey instance is done using the ObjectMappingKey class factory methods.,NULL
"That is because the ObjectMappingKey's factory methods gives each ObjectMappingKey instance a unique id, an int, which is used by its equals() and hashCode() methods.","(""ObjectMappingKey"", ""The factory methods are related to ObjectMappingKey because they are responsible for creating instances of ObjectMappingKey."", ""factory methods""); (""ObjectMappingKey"", ""The equals method is related to ObjectMappingKey because it is used by ObjectMappingKey instances to compare with other objects."", ""equals""); (""ObjectMappingKey"", ""The hashCode method is related to ObjectMappingKey because it is used by ObjectMappingKey instances to generate a hash code."", ""hashCode""); (""factory methods"", ""The factory methods are related to the equals method because the unique id generated by the factory methods is used by the equals method to compare ObjectMappingKey instances."", ""equals"")"
"This speeds up object mapping cache lookups because the hashCode() method returns this int id, and because equals() also only compares int id's, instead of Class objects, table names etc.","(""HashCode"", ""Both HashCode and Equals methods are related as they are used for object mapping cache lookups and comparisons, with HashCode returning an int id and Equals comparing these int ids."", ""Equals""); (""Class"", ""The Class entity is related to the HashCode method because the method is used in the context of Class objects, specifically for returning an int id."", ""HashCode"")"
Instead of the class MyCustomObjectMapper you should use your own class.,"(""MyCustomObjectMapper"", ""The class MyCustomObjectMapper is related to the concept of a class because it is explicitly mentioned as a class in the text."", ""class"")"
The extended class CustomObjectMapperBase is an empty implementation of the ICustomObjectMapper interface.,NULL
Just call the IObjectMapping.removeGetterMapping(String name) or IObjectMapping.removeSetterMapping(String name) method to do so.,"(""IObjectMapping"", ""IObjectMapping is a class that has a method called removeGetterMapping, which indicates a clear relationship between the two entities as the method is part of the class's interface."", ""removeGetterMapping"")"
The ObjectMappingKey class has some static shortcut factory methods to create object mapping keys that has custom object mappers for auto-generated columns.,"(""ObjectMappingKey"", ""The ObjectMappingKey class has some static factory methods to create object mapping keys"", ""factory methods""); (""factory methods"", ""The factory methods are used to create object mapping keys"", ""object mapping keys""); (""object mapping keys"", ""The object mapping keys have custom object mappers for auto-generated columns"", ""custom object mappers"")"
The only thing required to use Butterfly Persistence is that you add the JAR file to the classpath of your application.,"(""Butterfly Persistence"", ""Butterfly Persistence is related to JAR because the JAR file is required to use Butterfly Persistence"", ""JAR""); (""JAR"", ""JAR is related to classpath because the JAR file needs to be added to the classpath"", ""classpath""); (""Butterfly Persistence"", ""Butterfly Persistence is related to classpath because it requires the JAR file to be added to the classpath of the application"", ""classpath""); (""Butterfly Persistence"", ""Butterfly Persistence is related to application because it is used in the application"", ""application""); (""JAR"", ""JAR is related to application because the JAR file is added to the application's classpath"", ""application"")"
"A lot of things are cached internally in the PersistenceManager instance, like object mappings, sql etc., so you should not create a new instance everytime you need it.","(""PersistenceManager"", ""The PersistenceManager is related to the instance because the text mentions that a new instance of the PersistenceManager should not be created every time it is needed."", ""instance""); (""PersistenceManager"", ""The PersistenceManager is related to object mappings because the text states that object mappings are cached internally in the PersistenceManager instance."", ""object mappings"")"
Version control systems typically also makes it easier for multiple people to collaborate - e.g.,"(""Version control systems"", ""Version control systems makes it easier for people to collaborate, so they are related as Version control systems is a class that has a method collaborate"", ""collaborate""); (""people"", ""people and multiple are related as multiple is a package that contains people, implying a grouping relationship"", ""multiple""); (""Version control systems"", ""Version control systems are used by people, establishing a relationship between the class Version control systems and the package people"", ""people"")"
"The Docker base image you are using may itself consist of multiple layers, and can itself be based on another base image etc., until you get down to the most basic Docker image you can create - a raw Linux container image with no special settings applied.","(""Docker"", ""Docker is using the base image"", ""Base Image""); (""Base Image"", ""Base image is based on a raw Linux container image"", ""Linux""); (""Base Image"", ""Base image consists of multiple layers and can be based on another base image until it gets down to a raw Linux container image"", ""Container""); (""Docker"", ""Docker image is based on a raw Linux container image"", ""Linux"")"
This example copies a single file from the Docker host at /myapp/target/myapp.jar to the Docker image at /myapp/myapp.jar .,"(""Docker"", ""Docker is related to /myapp/target/myapp.jar because it is the source of the file."", ""/myapp/target/myapp.jar""); (""Docker"", ""Docker is related to /myapp/myapp.jar because it is the destination of the file."", ""/myapp/myapp.jar""); (""Docker"", ""Docker is related to /myapp/target/myapp.jar because it is the source of the file."", ""/myapp/target/myapp.jar""); (""Docker"", ""Docker is related to /myapp/myapp.jar because it is the destination of the file."", ""/myapp/myapp.jar"")"
This example copies the two files /myapp/config/prod/conf1.cfg and /myapp/conig/prod/conf2.cfg into the Docker image directory /myapp/config/ .,"(""MYAPP"", ""MYAPP is the package that contains the config file /myapp/config/prod/conf1.cfg"", ""/MYAPP/CONFIG/PROD/CONF1.CFG""); (""MYAPP"", ""MYAPP is the package that contains the config file /myapp/conig/prod/conf2.cfg"", ""/MYAPP/CONIG/PROD/CONF2.CFG""); (""MYAPP"", ""MYAPP is the package that contains the directory /myapp/config/"", ""/MYAPP/CONFIG/""); (""/MYAPP/CONFIG/PROD/CONF1.CFG"", ""/myapp/config/prod/conf1.cfg and /myapp/conig/prod/conf2.cfg are both config files being copied into the Docker image directory /myapp/config/"", ""/MYAPP/CONIG/PROD/CONF2.CFG""); (""/MYAPP/CONFIG/PROD/CONF1.CFG"", ""/myapp/config/prod/conf1.cfg is being copied into the directory /myapp/config/"", ""/MYAPP/CONFIG/"")"
"In other words, you can create a directory inside the docker image, e.g.","(""DIRECTORY"", ""A directory can be created inside a docker image"", ""DOCKER""); (""DOCKER"", ""The docker image can contain a directory"", ""IMAGE"")"
"called /data which can later be mounted to a directory, e.g.",NULL
In a Maven repository a JAR file is identified by its group name (e.g.,"(""Maven"", ""Maven repository contains JAR files, thus they are related"", ""JAR""); (""group name"", ""a JAR file is identified by its group name, thus they are related"", ""JAR"")"
"the organization that made it), its artifact name (the name of the project / software / tool / API), and a version number (e.g.","(""Organization"", ""The organization is related to the artifact as it is the one that made it"", ""Artifact""); (""Artifact"", ""The artifact can be a project, indicating a relationship between the two entities"", ""Project""); (""Artifact"", ""The artifact can be a software, indicating a relationship between the two entities"", ""Software""); (""Artifact"", ""The artifact can be a tool, indicating a relationship between the two entities"", ""Tool""); (""Artifact"", ""The artifact can be an API, indicating a relationship between the two entities"", ""API""); (""Artifact"", ""The artifact has a version number, indicating a relationship between the two entities"", ""Version""); (""Project"", ""The project has a version number, indicating a relationship between the two entities"", ""Version""); (""Software"", ""The software has a version number, indicating a relationship between the two entities"", ""Version""); (""Tool"", ""The tool has a version number, indicating a relationship between the two entities"", ""Version"")"
"This example declares a dependency on Log4J using the group name log4j, the artifact name log4j and the version 1.2.17 .","(""Log4J"", ""Log4J is related to log4j as it is the group name for the dependency declaration"", ""log4j""); (""Log4J"", ""Log4J is related to 1.2.17 as it is the version used for the Log4J dependency"", ""1.2.17""); (""log4j"", ""log4j is related to 1.2.17 as it is the version used for the log4j artifact"", ""1.2.17"")"
By default the testCompile dependency configuration also includes the compiled classes and the dependencies from the compile dependency configuration.,"(""TestCompile"", ""TestCompile is related to Compile because it includes the compiled classes and the dependencies from the compile dependency configuration."", ""Compile""); (""TestCompile"", ""TestCompile is related to Dependency because it includes the dependencies from the compile dependency configuration."", ""Dependency"")"
The build task will compile all your Java classes and create a JAR file with them in.,"(""Build"", ""The build task is a class that will perform the compilation of Java classes and creation of a JAR file, thus they are related as the build task is an instance of the class"", ""Task""); (""Task"", ""The task will compile all your Java classes, thus the task is related to Java as it operates on Java classes"", ""Java""); (""Task"", ""The task will create a JAR file, thus the task is related to JAR as it produces a JAR file"", ""JAR"")"
Gradle outputs classes and JAR file to the directory named build inside your project root directory.,"(""Gradle"", ""Gradle outputs classes and JAR file to the directory named build, so Gradle and build are related as the output location"", ""build""); (""Gradle"", ""Gradle outputs classes and JAR file to the directory named build inside the project root directory, so Gradle and project root directory are related as the location of the build directory"", ""project root directory""); (""build"", ""build directory is located inside the project root directory, so build and project root directory are related as a subdirectory"", ""project root directory""); (""JAR"", ""JAR is output by Gradle as part of its output, so JAR and Gradle are related as the output and the producer of the output"", ""Gradle""); (""JAR"", ""JAR is output to the build directory, so JAR and build are related as the output and the location of the output"", ""build"")"
The compiled classes are written to build/classes and the JAR file to build/libs .,"(""BUILD"", ""The compiled classes are written to build/classes, indicating that BUILD is related to CLASSES as it is the location where classes are written"", ""CLASSES""); (""BUILD"", ""The JAR file is written to build/libs, indicating that BUILD is related to JAR as it is the location where the JAR file is written"", ""JAR"")"
"This is because the classes, jar and assemble tasks are now all UP-TO-DATE from the last run.","(""CLASSES"", ""CLASSES and JAR are related because they are both mentioned as being UP-TO-DATE from the last run, indicating a shared state or status."", ""JAR""); (""CLASSES"", ""CLASSES and ASSEMBLE are related because they are both mentioned as being UP-TO-DATE from the last run, indicating a shared state or status."", ""ASSEMBLE"")"
"Running the clean task removes the build directory, and thus all compiled classes and created JAR files.","(""Clean"", ""The clean task is related to the build directory because running the clean task removes the build directory."", ""Build""); (""Clean"", ""The clean task is related to compiled classes because running the clean task removes all compiled classes."", ""Compiled Classes""); (""Clean"", ""The clean task is related to JAR files because running the clean task removes all created JAR files."", ""Jar""); (""Build"", ""The build directory is related to compiled classes because it contains all compiled classes."", ""Compiled Classes"")"
"Second, this example calls the myTask doFirst() method, passing along a closure as parameter.",NULL
"Third, this example calls the myTask doLast() method, passing along another closure as parameter.",NULL
"When the task myTask is executed Gradle will first execute all closures passed as parameters the doFirst() method, and then all closures passed as parameters the doLast() method.","(""MyTask"", ""MyTask is executed by Gradle"", ""Gradle""); (""Gradle"", ""Gradle will first execute all closures passed as parameters the doFirst() method"", ""DoFirst""); (""Gradle"", ""Gradle will then execute all closures passed as parameters the doLast() method"", ""DoLast""); (""MyTask"", ""MyTask execution involves the doFirst() method"", ""DoFirst"")"
"First of all you do not need the semicolon ; after the doFirst() and doLast() method calls, if the code line with the method calls ends with a new line.",NULL
"Second, you do not need the parentheses around the closure when calling doFirst() or doLast().",NULL
With these two syntax optimizations you can write the doFirst() and doLast() method calls like this:,NULL
Often you will not need to pass closures to both doFirst() and doLast() .,NULL
It is quite common to pass just a single closure to the doLast() method.,NULL
"Because this is such a common use case, Gradle has a shortcut for passing a closure to the doLast() method.","(""Gradle"", ""Gradle has a shortcut for passing a closure to the doLast() method, indicating that Gradle is related to doLast() as it provides a shortcut for passing a closure to this method"", ""doLast()""); (""doLast()"", ""The doLast() method is related to the closure because the closure is being passed to the doLast() method"", ""closure"")"
The two characters << corresponds to calling the doLast() method like this:,NULL
You can even define the task on the same line as you pass the closure to the doLast() method.,"(""Task"", ""The task is defined and passed to the doLast() method, indicating a relationship between the task and the doLast() method."", ""DoLast""); (""Closure"", ""The closure is passed to the doLast() method, indicating a relationship between the closure and the doLast() method."", ""DoLast"")"
You can also add multiple closures using the doLast() shortcut notation.,"(""Java.Lang"", ""Java.Lang package contains the Math class."", ""Math"")"
"A task could be compiling the source code, generating JavaDoc, zipping the compiled classes into a JAR file etc.","(""Task"", ""A task is related to the source code because it involves compiling the source code."", ""Source Code""); (""Task"", ""A task is related to JavaDoc because it involves generating JavaDoc."", ""JavaDoc"")"
The build script is typically called build.gradle and is normally located in the root directory of the project you are building.,"(""Build Script"", ""The build script is typically used to build a project"", ""Project""); (""Project"", ""The project is normally located in the root directory"", ""Root Directory""); (""Build Script"", ""The build script is normally located in the root directory of the project"", ""Root Directory"")"
When you specify another build script Gradle does not use its settings.gradle file.,"(""Gradle"", ""Gradle uses settings.gradle file by default, but this is changed when a build script is specified, thus Gradle is related to Settings.Gradle file."", ""Settings.Gradle""); (""Gradle"", ""When a build script is specified, Gradle's default behavior is altered, so Gradle is related to build script."", ""Build Script"")"
Gradle will use the build.gradle file found in the project directory (subproject-dir) and will execute the build task in that build script.,"(""Gradle"", ""Gradle uses the build.gradle file to execute the build task"", ""build.gradle""); (""Gradle"", ""Gradle executes the build task in the build script"", ""build task""); (""build.gradle"", ""The build.gradle file contains the build task"", ""build task""); (""project directory"", ""The build.gradle file is found in the project directory"", ""build.gradle""); (""subproject-dir"", ""The build.gradle file is found in the subproject-dir"", ""build.gradle""); (""build script"", ""The build task is executed in the build script"", ""build task""); (""Gradle"", ""Gradle uses the project directory to find the build.gradle file"", ""project directory""); (""Gradle"", ""Gradle uses the build.gradle file to execute tasks"", ""build.gradle""); (""Gradle"", ""Gradle executes the build task"", ""build task""); (""Gradle"", ""Gradle searches for the build.gradle file in the project directory"", ""project directory""); (""build.gradle"", ""The build.gradle file contains the build task"", ""build task""); (""build.gradle"", ""The build.gradle file is a build script"", ""build script"")"
"Note, that the Predicate interface contains a single unimplemented method named test() which returns a boolean.",NULL
"After creating the two basic functions, a third Predicate is composed, which calls the test() methods of the two first functions.","(""Predicate"", ""The Predicate class is related to the test() method because it calls the test() methods of the two first functions."", ""test()"")"
The Predicate interface (java.util.function.Predicate) contains a few methods that help you compose new Predicate instances from other Predicate instances.,NULL
The and() method is used to combine two other Predicate functions in the same way I showed in the beginning of this Java functional composition tutorial.,"(""And"", ""The And method is used in combination with Predicate functions, indicating a relationship between the two."", ""Predicate""); (""And"", ""The And method is used in the context of a Java functional composition tutorial, indicating a relationship between the method and the Java package."", ""Java"")"
Here is an example of functional composition with the Predicate and() method:,NULL
This Predicate composition example composes a new Predicate from two other Predicate instances using the and() method of one of the basic Predicate instances.,"(""Predicate"", ""The Predicate class has a relationship with the and() method because the and() method is used by the Predicate class to compose a new Predicate."", ""and()""); (""Predicate composition"", ""The Predicate composition class has a relationship with the Predicate class because the Predicate composition is an example of composing a new Predicate."", ""Predicate"")"
The composed Predicate will return true from it's test() method if both of the Predicate instances it was composed from also return true.,"(""Predicate"", ""The Predicate class has a test() method, indicating that test() is a method of the Predicate class."", ""test()"")"
"The Predicate or() method is used to combine a Predicate instance with another, to compose a third Predicate instance.","(""Predicate"", ""The Predicate class has an or method"", ""or"")"
"The composed Predicate will return true if either of the Predicate instances it is composed from return true, when their test() methods are called with same input parameter as the composed Predicate.","(""Predicate"", ""The Predicate class has a test method, indicating a relationship between the class and its method."", ""test"")"
This Predicate or() functional composition example first creates two basic Predicate instances.,"(""or"", ""The or method is related to the Predicate class because it is used as a functional composition example with Predicate instances."", ""Predicate"")"
"Second, the example creates a third Predicate composed from the first two, by calling the or() method on the first Predicate and passing the second Predicate as parameter to the or() method.","(""Predicate"", ""The Predicate class has a relationship with the or() method because the or() method is called on an instance of the Predicate class."", ""or()"")"
The Java Function interface (java.util.function.Function) also contains a few methods that can be used to compose new Function instances from existing ones.,"(""Java Function"", ""The Java Function interface is contained in the java.util.function package, which establishes a clear relationship between the two entities."", ""java.util.function.Function""); (""Function"", ""The Function entity is related to the Java Function entity as they both seem to refer to the same concept, with 'Java Function' being a more specific term and 'Function' being a more general term."", ""Java Function"")"
"The Java Function compose() method composes a new Function instance from the Function instance it is called on, and the Function instance passed as parameter to the compose() method.","(""Compose"", ""The Compose method is a part of the Function class and is used to compose a new Function instance."", ""Function"")"
"The Function returned by compose() will first call the Function passed as parameter to compose(), and then it will call the Function which compose() was called on.","(""Compose"", ""Compose is a method that is called on a Function, indicating a relationship between the two."", ""Function"")"
"This is easier to understand with an example, so here is a Java Function compose() example:",NULL
The Java Function andThen() method works opposite of the compose() method.,"(""andThen"", ""The andThen() method works opposite of the compose() method, indicating a relationship between the two methods."", ""compose""); (""Java"", ""The Java Function class is related to the Java language, and the Function class is a part of Java."", ""Function""); (""Java"", ""The Java language is related to the andThen() method, as it is a part of the Java standard library."", ""andThen""); (""Java"", ""The Java language is related to the compose() method, as it is a part of the Java standard library."", ""compose""); (""Function"", ""The Function class is related to the andThen() method, as it is a method of the Function class."", ""andThen"")"
"A Function composed with andThen() will first call the Function that andThen() was called on, and then it will call the Function passed as parameter to the andThen() method.","(""Function"", ""The Function class has a relationship with the andThen() method because andThen() is called on a Function object."", ""andThen()"")"
"Then the andThen() method is called on the multiply Function to compose a new Function, passing the add Function as parameter to andThen().","(""Andthen"", ""The andThen() method is called on the multiply Function to compose a new Function"", ""Function""); (""Andthen"", ""The andThen() method is called on the multiply Function, passing the add Function as parameter to andThen()"", ""Add""); (""Multiply"", ""The andThen() method is called on the multiply Function to compose a new Function"", ""Function"")"
Calling the Function composed by andThen() with the value 3 will result in the following calculation 3 * 2 + 3 and the result will be 9.,NULL
"Note: As mentioned in the beginning, andThen() works opposite of compose().",NULL
"Therefore, calling a.andThen(b) is actually the same as calling b.compose(a) .","(""A"", ""A has a method called ANDTHEN"", ""ANDTHEN""); (""B"", ""B has a method called COMPOSE"", ""COMPOSE""); (""ANDTHEN"", ""ANDTHEN and COMPOSE are related as they are functionally equivalent in this context"", ""COMPOSE"")"
The Java Function interface (java.util.function.Function) interface is one of the most central functional interfaces in Java.,"(""Java"", ""Java is related to Function because it is mentioned that the Function interface is one of the most central functional interfaces in Java, implying a connection between the Java class and the Function interface"", ""Function""); (""Java"", ""Java is related to java.util.function.Function because java.util.function.Function is a package in Java, indicating that Java is the broader category that contains the package java.util.function.Function"", ""java.util.function.Function"")"
The only method you have to implement to implement the Function interface is the apply() method.,NULL
"This Function implementation implements the apply() method so it takes a Long as parameter, and returns a Long.","(""Function"", ""The Function class implements the apply() method, indicating a clear relationship between the two."", ""apply()""); (""apply()"", ""The apply() method takes a Long as a parameter and returns a Long, indicating a clear relationship between the method and the Long class."", ""Long"")"
"Second, the example calls the apply() method on the AddThree instance.",NULL
"As you can see, the Function interface implementation is now inlined in the declaration of the adderLambda variable, rather than in a separate class.","(""Function"", ""The Function interface is implemented in a class, as indicated by the fact that its implementation is now inlined in the declaration of the adderLambda variable, rather than in a separate class."", ""class""); (""adderLambda"", ""The adderLambda variable is declared in a class, and its implementation is related to the class where it is declared."", ""class"")"
"The Java Predicate interface, java.util.function.Predicate, represents a simple function that takes a single value as parameter, and returns true or false.","(""Java Predicate"", ""The Java Predicate interface is located in the java.util.function.Predicate package, indicating a clear relationship between the two entities."", ""java.util.function.Predicate""); (""java.util.function.Predicate"", ""The predicate interface is a part of the java.util.function.Predicate package, showing a relationship between the package and the interface."", ""Predicate"")"
"The Predicate interface contains more methods than the test() method, but the rest of the methods are default or static methods which you don't have to implement.",NULL
"You can implement the Predicate interface using a class, like this:",NULL
This lambda implementation of the Predicate interface effectively does the same as the implementation above that uses a class.,NULL
This Java Consumer implementation prints the value passed as parameter to it out to System.out.,"(""Consumer"", ""The Consumer class is part of the Java package, as it is a Java Consumer implementation."", ""Java"")"
"Especially the idea of ""no side effects"" makes it hard to e.g.",NULL
"In the functional programming paradigm, functions are first class objects in the language.","(""Functions"", ""Functions are first class objects in the Language, indicating a relationship between the two entities."", ""Language""); (""Functional Programming Paradigm"", ""The Functional Programming Paradigm is related to Functions because it is described as treating functions as first class objects."", ""Functions"")"
Notice how the return value of the sum() function only depends on the input parameters.,NULL
"Notice also that the sum() has no side effects, meaning it does not modify any state (variables) outside the function anywhere.",NULL
"Notice how the method add() uses a member variable to calculate its return value, and it also modifies the state of the value member variable, so it has a side effect.",NULL
Notice how the createFactory() method returns a lambda expression as result.,NULL
Notice also that the createFactory() method takes two instances as parameters which are both implementations of interfaces (IProducer and IConfigurator).,"(""Createfactory"", ""The Createfactory method takes an instance of Iproducer as a parameter, indicating a relationship between the two."", ""Iproducer"")"
Therefore they can be implemented by Java lambda expressions - and therefore the createFactory() method is a higher order function.,NULL
"A function may have local variables containing temporary state internally, but the function cannot reference any member variables of the class or object the function belongs to.","(""Function"", ""The function may have local variables, indicating that the function is related to the variables it contains."", ""Variables""); (""Function"", ""The function belongs to the class, indicating that the function is related to the class it belongs to."", ""Class""); (""Function"", ""The function belongs to the object, indicating that the function is related to the object it belongs to."", ""Object"")"
"State outside of a function refers both to member variables in the class or object the function, and member variables inside parameters to the functions, or state in external systems like file systems or databases.",NULL
"This is still a functional interface, because only run() is not implemented (abstract).",NULL
The first example of a higher order function is the Collections.sort() method which takes a Comparator as parameter.,"(""Collections"", ""The Collections class contains the sort method"", ""sort"")"
The lambda parameter is what makes Collections.sort() a higher order function.,"(""Collections"", ""Collections is a class that contains the sort method, indicating a clear relationship between the two entities."", ""sort""); (""Collections"", ""The lambda parameter is used in the context of the Collections class, suggesting a connection between the lambda function and the Collections class."", ""lambda"")"
"Second, the example calls the reversed() method on the Comparator lambda.",NULL
"The reversed() method returns a new Comparator lambda, which reverse the result returned by the first Comparator implementation.",NULL
"By ""reversing"" I mean that it simply returns -1 * comparator.compare(a,b)",NULL
"Because the reversed() method returns a lambda (function), the reversed() method is considered a higher order function.",NULL
"Third, the example sorts the List of Strings using the Collections.sort() method.","(""List"", ""The List class is related to the Collections.sort() method because the method is used to sort the List of Strings."", ""Collections.sort()""); (""Strings"", ""The Strings class is related to the List class because the List is defined as a List of Strings."", ""List""); (""Collections"", ""The Collections class is related to the Collections.sort() method because the method is a part of the Collections class."", ""Collections.sort()""); (""Collections"", ""The Collections class is related to the List class because the Collections.sort() method is used to sort the List of Strings."", ""List"")"
"In contrast, when you are using the Java Collections iteration features (e.g a Java Iterator or the Java for-each loop used with a Java Iterable) you have to implement the iteration of the elements yourself.","(""Java Collections"", ""Java Iterator is part of the Java Collections framework"", ""Java Iterator""); (""Java Collections"", ""Java Iterable is part of the Java Collections framework"", ""Java Iterable"")"
"Finally, the example calls the stream() method to obtain a Stream instance.",NULL
The call to the map() method of the Stream interface is a non-terminal operation.,NULL
The map() method will be covered in more detail later on.,NULL
Notice how the second call to Stream map() is called on the Stream returned by the first map() call.,"(""Stream"", ""The Stream class has a method called Map, and in the given text, it is mentioned that the second call to Stream map() is called on the Stream returned by the first map() call, indicating a clear relationship between the Stream class and the Map method."", ""Map"")"
The Java Stream filter() can be used to filter out elements from a Java Stream.,NULL
Here is an example of calling the Java Stream filter() method:,"(""Java"", ""The Java class contains the Stream class"", ""Stream""); (""Stream"", ""The Stream class has the filter() method"", ""filter()"")"
The Java Stream map() method converts (maps) an element to another object.,"(""Java Stream"", ""The Java Stream uses the Map method to convert elements"", ""Map""); (""Java"", ""Java Stream is a part of the Java package"", ""Java Stream"")"
The Java Stream flatMap() methods maps a single element into multiple elements.,"(""Java"", ""Java contains the Stream class, which is a part of the Java package"", ""Stream""); (""Stream"", ""The flatMap() method is a part of the Stream class, which uses it to map a single element into multiple elements"", ""flatMap()"")"
This example should give you an idea about how flatMap() can be used to map a single element into multiple elements.,NULL
This Java Stream flatMap() example first creates a List with 3 strings containing book titles.,"(""Java Stream"", ""Java Stream uses the flatMap() method"", ""flatMap()"")"
"Then a Stream for the List is obtained, and flatMap() called.","(""Stream"", ""Stream is related to List because a Stream is obtained for the List"", ""List""); (""Stream"", ""Stream is related to flatMap because the flatMap method is called on the Stream"", ""flatMap"")"
The flatMap() operation called on the Stream has to return another Stream representing the flat mapped elements.,NULL
Note that this example finishes with a call to forEach() which is a terminal operation.,NULL
The Java Stream distinct() method is a non-terminal operation that returns a new Stream which will only contain the distinct elements from the original stream.,"(""Java Stream"", ""The distinct() method is a part of the Java Stream, indicating a relationship between the two as the method is used to manipulate the stream."", ""distinct()""); (""Java Stream"", ""Java Stream is an instance of the Stream class, indicating a relationship between the two as one is a specific implementation of the other."", ""Stream"")"
Only the first occurrence of this element will be included in the Stream returned by distinct().,NULL
"Thus, the resulting List (from calling collect()) will only contain one, two and three.",NULL
The Java Stream limit() method can limit the number of elements in a stream to a number given to the limit() method as parameter.,"(""Java"", ""Java Stream seems to be a part of Java package which indicates that Java package has a class called Java Stream."", ""Java Stream"")"
The limit() method returns a new Stream which will at most contain the given number of elements.,NULL
"This example first creates a Stream, then calls limit() on it, and then calls forEach() with a lambda that prints out the elements in the stream.","(""Stream"", ""The Stream class has a method called limit(), indicating that limit() is a method of the Stream class."", ""limit()""); (""Stream"", ""The Stream class has a method called forEach(), indicating that forEach() is a method of the Stream class."", ""forEach()"")"
The Java Stream peek() method is a non-terminal operation that takes a Consumer (java.util.function.Consumer) as parameter.,"(""Java Stream"", ""The Java Stream has a method called peek(), indicating a relationship between the two."", ""peek()""); (""peek()"", ""The peek() method takes a Consumer as a parameter, indicating a relationship between the two."", ""Consumer"")"
The peek() method returns a new Stream which contains all the elements in the original stream.,NULL
"The purpose of the peek() method is, as the method says, to peek at the elements in the stream, not to transform them.",NULL
It is the call to count() at the end of the example that is the terminal operation.,NULL
"Since count() returns a long, the Stream chain of non-terminal operations (the map() calls) is ended.","(""Stream"", ""The Stream class uses the Count method to end the chain of non-terminal operations"", ""Count""); (""Stream"", ""The Stream class uses the Map method as part of its chain of non-terminal operations"", ""Map"")"
"The Java Stream anyMatch() method is a terminal operation that takes a single Predicate as parameter, starts the internal iteration of the Stream, and applies the Predicate parameter to each element.","(""Java Stream"", ""The Java Stream has an anyMatch() method, indicating a relationship between the class and the method."", ""anyMatch()""); (""anyMatch()"", ""The anyMatch() method takes a Predicate as a parameter, indicating a relationship between the method and the class."", ""Predicate""); (""Java Stream"", ""The text mentions 'The Java Stream', indicating that Java Stream is related to the Stream class."", ""Stream"")"
"If the Predicate returns true for any of the elements, the anyMatch() method returns true.",NULL
"In the example above, the anyMatch() method call will return true, because the first string element in the stream starts with ""One"".",NULL
"The Java Stream allMatch() method is a terminal operation that takes a single Predicate as parameter, starts the internal iteration of elements in the Stream, and applies the Predicate parameter to each element.","(""Java Stream"", ""The Java Stream has an allMatch() method, indicating a relationship between the two."", ""allMatch()""); (""allMatch()"", ""The allMatch() method takes a Predicate as a parameter, indicating a relationship between the two."", ""Predicate""); (""Java Stream"", ""Java Stream and Stream seem to be related as they are mentioned together in the context of the allMatch() method."", ""Stream"")"
"If the Predicate returns true for all elements in the Stream, the allMatch() will return true.","(""Predicate"", ""Predicate is used in the allMatch() method as a condition to check all elements in the Stream"", ""allMatch()""); (""Stream"", ""allMatch() is a method that operates on the Stream to check if all elements match a certain condition"", ""allMatch()"")"
"If not all elements match the Predicate, the allMatch() method returns false.",NULL
"In the example above, the allMatch() method will return false, because only one of the strings in the Stream starts with ""One"".",NULL
"The Java Stream noneMatch() method is a terminal operation that will iterate the elements in the stream and return true or false, depending on whether no elements in the stream matches the Predicate passed to noneMatch() as parameter.","(""Java Stream"", ""The Java Stream has a method called noneMatch(), indicating a relationship between the class Java Stream and the method noneMatch()."", ""noneMatch()""); (""noneMatch()"", ""The noneMatch() method takes a Predicate as a parameter, indicating a relationship between the method noneMatch() and the class Predicate."", ""Predicate"")"
"The noneMatch() method will return true if no elements are matched by the Predicate, and false if one or more elements are matched.",NULL
"The Java Stream collect() method is a terminal operation that starts the internal iteration of elements, and collects the elements in the stream in a collection or object of some kind.",NULL
"Luckily, the Java class java.util.stream.Collectors contains a set of pre-implemented Collector implementations you can use, for the most common operations.",NULL
"In the example above, it was the Collector implementation returned by Collectors.toList() that was used.","(""Collectors"", ""Collectors is a class that has a method toList, indicating a relationship between the class and the method"", ""toList"")"
"The Java Stream count() method is a terminal operation which starts the internal iteration of the elements in the Stream, and counts the elements.","(""Java Stream"", ""The count() method is a part of the Java Stream class, indicating a relationship between the two."", ""count()"")"
"This example first creates a List of strings, then obtain the Stream for that List, adds a flatMap() operation for it, and then finishes with a call to count().","(""List"", ""The List is used to obtain the Stream in the example"", ""Stream""); (""Stream"", ""The Stream is the target of the flatMap() operation"", ""flatMap()""); (""Stream"", ""The Stream is the source for the count() operation"", ""count()""); (""List"", ""The List is indirectly related to the flatMap() operation through the Stream"", ""flatMap()"")"
"The count() method will start the iteration of the elements in the Stream which will result in the string elements being split up into words in the flatMap() operation, and then counted.",NULL
The Java Stream findAny() method can find a single element from the Stream.,"(""Java Stream"", ""The Java Stream uses the findAny() method to find an element."", ""findAny()"")"
You can check if an element was found via the Optional isPresent() method.,NULL
"The Java Stream findFirst() method finds the first element in the Stream, if any elements are present in the Stream.","(""Java Stream"", ""The Java Stream has a method called findFirst(), indicating a relationship between the two."", ""findFirst()"")"
"The findFirst() method returns an Optional from which you can obtain the element, if present.",NULL
You can check if the Optional returned contains an element via its isPresent() method.,NULL
"The Java Stream forEach() method is a terminal operation which starts the internal iteration of the elements in the Stream, and applies a Consumer (java.util.function.Consumer) to each element in the Stream.","(""Java Stream"", ""The forEach() method is a part of the Java Stream class, indicating a relationship between the two entities as the method is used to operate on the stream."", ""forEach()""); (""forEach()"", ""The forEach() method applies a Consumer to each element in the Stream, indicating a relationship between the two entities as the method utilizes the Consumer interface."", ""java.util.function.Consumer"")"
The Java Stream min() method is a terminal operation that returns the smallest element in the Stream.,NULL
Which element is the smallest is determined by the Comparator implementation you pass to the min() method.,NULL
Notice how the min() method returns an Optional which may or may not contain a result.,NULL
"If the Stream is empty, the Optional get() method will throw a NoSuchElementException.","(""Stream"", ""The Stream class has a relationship with the get() method, as the get() method is called on a Stream object."", ""get()""); (""get()"", ""The get() method has a relationship with the Optional class, as it returns an Optional object."", ""Optional""); (""get()"", ""The get() method has a relationship with the NoSuchElementException class, as it throws a NoSuchElementException if the Stream is empty."", ""NoSuchElementException""); (""Stream"", ""The Stream class has a relationship with the Optional class, as the get() method of the Stream class returns an Optional object."", ""Optional"")"
The Java Stream max() method is a terminal operation that returns the largest element in the Stream.,"(""Java Stream"", ""The Java Stream has a method called Max, indicating a relationship between the two"", ""Max"")"
Which element is the largest is determined by the Comparator implementation you pass to the max() method.,NULL
Notice how the max() method returns an Optional which may or may not contain a result.,NULL
The Java Stream reduce() method is a terminal operation that can reduce all elements in the stream to a single element.,"(""Java Stream"", ""The Java Stream has a reduce() method"", ""reduce()""); (""reduce()"", ""The reduce() method is a type of terminal operation"", ""terminal operation"")"
This Optional contains the value (if any) returned by the lambda expression passed to the reduce() method.,"(""Optional"", ""The Optional entity contains the value returned by the lambda expression passed to the reduce() method, indicating a relationship between the Optional class and the reduce() method."", ""reduce()""); (""reduce()"", ""The reduce() method takes a lambda expression as an argument, establishing a relationship between the reduce() method and the lambda expression."", ""lambda expression"")"
"The Java Stream toArray() method is a terminal operation that starts the internal iteration of the elements in the stream, and returns an array of Object containing all the elements.","(""Java Stream"", ""The Java Stream has a method called toArray(), which establishes a relationship between the two entities."", ""toArray()""); (""toArray()"", ""The toArray() method returns an array of Object, indicating a relationship between the method and the Object class."", ""Object"")"
The Java Stream interface contains a static method called concat() which can concatenate two streams into one.,"(""Java Stream"", ""The Java Stream interface contains a static method called concat(), which indicates that concat() is a method of the Java Stream class."", ""concat()""); (""java"", ""The Java Stream interface is part of the java package, which indicates that Java Stream is a class within the java package."", ""Java Stream"")"
Here is an example of using the Java Stream concat() method:,"(""Java"", ""Java is a package that contains the Stream class"", ""Stream"")"
The Java Stream interface contains a static method called of() which can be used to create a Stream from one or more objects.,"(""Java Stream"", ""The Java Stream interface contains a static method called of(), indicating that of() is a method belonging to the Java Stream interface."", ""of()""); (""Stream"", ""The of() method is used to create a Stream, indicating that of() is related to the Stream class."", ""of()"")"
Here is an example of using the Java Stream of() metho:,"(""Java Stream"", ""The Java Stream class has a method called of(), which establishes a relationship between the two entities."", ""of()""); (""Java"", ""The Java Stream class is part of the Java package, which establishes a relationship between the two entities."", ""Java Stream"")"
"A graph based stream processing API could instead support a ""sample"" operation where each node in the stream processing graph is asked for any value it may hold internally (e.g.","(""Graph"", ""A graph contains nodes, indicating a clear relationship between the two entities."", ""Node""); (""Stream"", ""A stream is processed using a graph, showing a relationship between the stream and the graph."", ""Graph""); (""Node"", ""Each node in the stream processing graph is asked for any value it may hold internally, establishing a relationship between nodes and streams."", ""Stream""); (""Sample"", ""The sample operation is applied to each node, demonstrating a relationship between the sample method and nodes."", ""Node""); (""Stream Processing"", ""The stream processing graph is part of the stream processing package, indicating a relationship between the package and the graph."", ""Graph""); (""Stream Processing"", ""The stream is part of the stream processing package, showing a relationship between the package and the stream."", ""Stream""); (""Stream Processing"", ""The nodes are part of the stream processing package, establishing a relationship between the package and the nodes."", ""Node"")"
Some graph based stream processing APIs are also designed to kind of hide the iteration of the elements from the user of the API (e.g.,NULL
The full code for the command line argument parsers is listed at the end of this tutorial (it's just one class).,NULL
The interpretation of these command line arguments could be that the copy program should copy file.txt to a file named file2.txt and overwrite file2.txt if it already exists.,NULL
These command line arguments consists of one switch (-overwrite) and two targets (file.txt and file.2.txt).,"(""COMMAND LINE ARGUMENTS"", ""A command line argument consists of a switch"", ""SWITCH""); (""COMMAND LINE ARGUMENTS"", ""A command line argument consists of a target"", ""TARGET""); (""SWITCH"", ""The switch is -overwrite"", ""-OVERWRITE""); (""TARGET"", ""One of the targets is file.txt"", ""FILE.TXT""); (""TARGET"", ""One of the targets is file.2.txt"", ""FILE.2.TXT""); (""COMMAND LINE ARGUMENTS"", ""Command line arguments include a switch"", ""SWITCH""); (""COMMAND LINE ARGUMENTS"", ""Command line arguments include targets"", ""TARGET""); (""SWITCH"", ""The switch is identified as -overwrite"", ""-OVERWRITE""); (""TARGET"", ""One target is file.txt"", ""FILE.TXT""); (""TARGET"", ""Another target is file.2.txt"", ""FILE.2.TXT""); (""COMMAND LINE ARGUMENTS"", ""Command line arguments include a switch"", ""SWITCH""); (""COMMAND LINE ARGUMENTS"", ""Command line arguments include targets"", ""TARGET""); (""SWITCH"", ""The switch is identified as -overwrite"", ""-OVERWRITE""); (""TARGET"", ""One target is file.txt"", ""FILE.TXT""); (""TARGET"", ""Another target is file.2.txt"", ""FILE.2.TXT""); ("" "", "" "", "" ""); ("" "", "" "", "" ""); ("" "", "" "", "" ""); ("" "", "" "", "" "")"
"When the switch -overwrite is removed, the two arguments file.txt and file2.txt remain.",NULL
The command line argument parser consists of a single Java class named CliArgs.,NULL
The CliArgs class takes an array of String as argument to its constructor.,"(""CliArgs"", ""The CliArgs class takes an array of String as argument to its constructor, indicating that CliArgs is related to String as it uses String in its constructor."", ""String"")"
The CliArgs class contains the following methods you can use to obtain switch information and values:,NULL
The switchPresent() method can be used to ask if a given switch is present or not.,NULL
"If the command line arguments contains the -overwrite switch anywhere, the switchPresent() method will return true.",NULL
The switchValue() method can be use to obtain the value of a switch.,NULL
Here is a code example showing how to use switchValue() to read the value of the -port switch:,NULL
If you want the value of a switch parsed into a long or double you can use the switchLongValue() and switchDoubleValue() methods.,NULL
The switchValues() method is used to obtain multiple values for a switch.,NULL
The switchValues() method will return all values after the switch and until the next switch is met (next argument starting with a - character).,NULL
The values of the -from switch will be file1.txt and file2.txt.,"(""FROM"", ""FROM is related to FILE1.TXT because FROM is a switch that takes FILE1.TXT as one of its values"", ""FILE1.TXT"")"
The values of the -to switch will be copy1.txt and copy2.txt.,NULL
Instead you can create a swith POJO (Plain Old Java Object) class to hold all the switches.,NULL
"You can now read all the switches from the command line directly into an instance of the CliSwitches class, using the switchPojo() method.",NULL
The CliArgs switchPojo() method will use the property names inside the class to match against switches in the command line.,"(""CliArgs"", ""The CliArgs class contains the switchPojo() method, indicating a relationship between the two entities as the method is part of the class."", ""switchPojo()""); (""switchPojo()"", ""The switchPojo() method will use the property names, indicating that the method is related to the properties as it uses them for matching against switches in the command line."", ""property"")"
The targets() method returns all the arguments which are not switches or switch values.,"(""Targets"", ""The targets() method returns all the arguments which are not switches or switch values, indicating that Targets is related to Arguments as its return type."", ""Arguments""); (""Targets"", ""The targets() method returns all the arguments which are not switches or switch values, indicating that Targets is related to Switches as it excludes them from its return."", ""Switches""); (""Targets"", ""The targets() method returns all the arguments which are not switches or switch values, indicating that Targets is related to Switch Values as it excludes them from its return."", ""Switch Values""); (""Arguments"", ""Arguments and Switches are related in the context of the targets() method, which differentiates between them."", ""Switches""); (""Arguments"", ""Arguments and Switch Values are related in the context of the targets() method, which differentiates between them."", ""Switch Values"")"
"The CliArgs class distinguishes between switch values and targets by assuming, that all arguments which have not been ""taken"" already as switch values must be targets.","(""CliArgs"", ""The CliArgs class is related to switch values because it distinguishes between switch values and targets."", ""switch values""); (""CliArgs"", ""The CliArgs class is related to targets because it distinguishes between switch values and targets."", ""targets""); (""CliArgs"", ""The CliArgs class is related to Switch Values because it distinguishes between switch values and targets."", ""Switch Values""); (""CliArgs"", ""The CliArgs class is related to Targets because it distinguishes between switch values and targets."", ""Targets""); (""CliArgs"", ""The CliArgs class is related to switch values because it distinguishes between switch values and targets."", ""switch values""); (""CliArgs"", ""The CliArgs class is related to targets because it distinguishes between switch values and targets."", ""targets""); (""CliArgs"", ""The CliArgs class is related to switch values because it distinguishes between switch values and targets."", ""switch values""); (""CliArgs"", ""The CliArgs class is related to switch values because it distinguishes between switch values and targets."", ""switch values""); (""CliArgs"", ""The CliArgs class is related to Switch Values because it distinguishes between switch values and targets."", ""Switch Values""); (""CliArgs"", ""The CliArgs class is related to Targets because it distinguishes between switch values and targets."", ""Targets"")"
"will the method targets() as executed in the code above, return the String",NULL
"Therefore the targets() method call will return the argument web-root , because web-root is the only argument that has not been ""taken"" yet, even if it is located in the middle of the argument list.",NULL
You may need to have at least N next bytes (e.g.,NULL
"To be able to move forth and back in the stream data, you may need to keep the next e.g.",NULL
To solve this problem I will develop a RollingBufferInputStream class which keeps at least N bytes available in a buffer.,"(""RollingBufferInputStream"", ""The RollingBufferInputStream class is being developed to solve the problem, indicating a relationship between the class and the problem it is trying to address."", ""problem"")"
"The RollingBufferInputStream class which I have developed, can be used to iterate an InputStream while at the same time making sure there is always block size bytes available in the buffer.",NULL
"Note: Even if the class is called RollingBufferInputStream, it is not an InputStream subclass.",NULL
"First you ask if the buffer has N available bytes, by calling hasAvailableBytes().",NULL
This outline mostly serves to show you the interface of the RollingBufferInputStream class.,NULL
"If the call to hasAvailableBytes() detects that there is not enough bytes available in the buffer, it will attempt to fill the buffer.","(""Hasavailablebytes"", ""The Hasavailablebytes method is related to the Buffer class because it checks the availability of bytes in the buffer."", ""Buffer"")"
"Here is the full hasAvailableBytes() method implementation, so you can see how it works:",NULL
"Filling data into the buffer is done by the method fillDataFromStreamIntoBuffer(), which is shown here:",NULL
"You could use the String.replace() method, but for large amounts of data, and high number of replacements, this performs badly.","(""String"", ""String is the class that contains the String.replace method"", ""String.replace""); (""String"", ""String is the class that contains the replace method"", ""replace"")"
The String.replace() method creates a new String instance - which is a copy of the original String with the replacements applied.,"(""String"", ""The String.replace() method is a member of the String class, indicating a relationship between the two entities."", ""String.replace()"")"
"If you have to perform 5 replacements, you have to call replace() 5 times, each time on the string returned by the last replace() call, like this:",NULL
"... where N = the size of the string, and M = the number of replacements to perform.","(""N"", ""N is related to string because it represents the size of the string."", ""string""); (""M"", ""M is related to string because it represents the number of replacements to perform on the string."", ""string"")"
"Instead of using the String.replace() method I will here present a different, more scalable solution called a TokenReplacingReader.","(""TokenReplacingReader"", ""TokenReplacingReader is presented as an alternative to the String class"", ""String""); (""TokenReplacingReader"", ""TokenReplacingReader is a different solution to the String.replace method"", ""String.replace"")"
The token name (without the enclosing ${} ) is passed to the ITokenResolver.resolveToken(String tokenName) method.,"(""ITokenResolver"", ""ITokenResolver is a class that contains the resolveToken method, indicating a containment relationship between the class and the method""}"", ""resolveToken""); (""resolveToken"", ""The resolveToken method takes a String parameter, indicating a usage relationship between the method and the class""}"", ""String"")"
"The TokenReplacingReader is itself a subclass of java.io.Reader, so any class that can use a Reader, can use a TokenReplacingReader.","(""TokenReplacingReader"", ""TokenReplacingReader is a subclass of Reader, indicating a clear inheritance relationship between the two classes"", ""Reader""); (""TokenReplacingReader"", ""TokenReplacingReader is a part of the java.io package, indicating a package-class relationship"", ""java.io"")"
The TokenReplacingReader does not use as much memory as the String.replace() method.,"(""String"", ""The String class has a replace method, indicating a relationship between the two entities."", ""replace"")"
"... where N is the size of the data to replace tokens in, and M is the number of replacements.","(""N"", ""N is the size of the data"", ""data""); (""M"", ""M is the number of replacements"", ""replacements""); (""data"", ""data contains tokens to replace"", ""tokens""); (""replacements"", ""replacements are made for tokens"", ""tokens""); (""size"", ""size refers to the data"", ""data""); (""number"", ""number refers to the replacements"", ""replacements"")"
This is faster than the O(N * M) of the String.replace() method.,"(""String"", ""The String class has a replace method"", ""replace"")"
You could create a variant of the TokenReplacingReader which can replace XML entities (e.g.,NULL
"Additionally, since TokenReplacingReader is a java.io.Reader, and it gets its characters from a Reader itself, you can chain it with other java.io.Reader's or InputStreams which does other things (like unzipping, decrypting, converting from UTF-8, UTF-16 etc.)","(""TokenReplacingReader"", ""TokenReplacingReader is a subclass of Reader, indicating a clear inheritance relationship between the two classes"", ""Reader""); (""Reader"", ""Reader and InputStream are related in that they can be used together in a chain to perform various operations such as unzipping, decrypting, and converting between different character encodings"", ""InputStream"")"
Implementing a Java web crawler is a fun and challenging task often given in university programming classes.,"(""Java"", ""Java is used to implement a Java web crawler"", ""Java Web Crawler""); (""Java Web Crawler"", ""Java web crawler is often given as a task in university programming classes"", ""University Programming Classes"")"
That way the thread listening for incoming requests spends as much time as possible in the serverSocket.accept() call.,"(""ServerSocket"", ""ServerSocket is related to Accept because Accept is a method called on ServerSocket"", ""Accept""); (""Thread"", ""Thread is related to ServerSocket because the thread is listening for incoming requests on the server socket"", ""ServerSocket"")"
That way the risk is minimized for clients being denied access to the server because the listening thread is not inside the accept() call.,"(""Thread"", ""The thread is related to the server because it is responsible for listening and handling incoming connections to the server."", ""Server""); (""Accept"", ""The accept method is related to the thread because it is called by the thread to accept incoming connections."", ""Thread""); (""Clients"", ""The clients are related to the server because they are trying to access the server and the server is responsible for providing service to them."", ""Server""); (""Thread"", ""The thread is related to the accept method because the thread is not inside the accept call, which implies that the thread is doing something else while the accept method is being executed or is waiting for the accept method to finish."", ""Accept"")"
"Here is the code for the WorkerRunnable class, which is passed to the worker thread constructor:",NULL
"As mentioned earlier the more time the thread calling serverSocket.accept() spends inside this method call, the more responsive the server will be.","(""ServerSocket"", ""ServerSocket is related to Accept because Accept is a method called on ServerSocket"", ""Accept""); (""Server"", ""Server is related to ServerSocket because ServerSocket is used by the Server to accept connections"", ""ServerSocket"")"
Only when the listening thread is inside the accept() call can clients connect to the server.,"(""Listening Thread"", ""The listening thread is related to the accept() method because it is stated that the listening thread must be inside the accept() call."", ""Accept()""); (""Client"", ""The client is related to the server because clients can connect to the server when the listening thread is inside the accept() call."", ""Server""); (""Listening Thread"", ""The listening thread is related to the server because it is responsible for accepting connections to the server."", ""Server"")"
Clients can only connect to the server while the server is inside the serverSocket.accept() method call.,"(""Server"", ""The Server is related to the ServerSocket because the server is inside the serverSocket.accept() method call, indicating that ServerSocket is the class that contains the method accepting the server."", ""ServerSocket""); (""Client"", ""The Client is related to the Server because clients can only connect to the server, indicating a connection or communication between the two."", ""Server""); (""Client"", ""The Client is related to the ServerSocket because the client connection is accepted by the serverSocket.accept() method, indicating that the client interacts with the server through the ServerSocket."", ""ServerSocket""); (""Accept"", ""The Accept method is related to the ServerSocket because it is a method call of ServerSocket, as indicated by serverSocket.accept()."", ""ServerSocket""); (""Accept"", ""The Accept method is related to the Server because the server is inside the serverSocket.accept() method call, indicating that the Accept method is responsible for accepting the server."", ""Server"")"
"The longer time the listening thread spends outside the serverSocket.accept() call, the higher the probability that the client will be denied access to the server.","(""ServerSocket"", ""The ServerSocket is related to the Client because it is used to accept or deny access to the server, which is where the client is trying to connect."", ""Client""); (""Server"", ""The Server is related to the Client because the client is trying to access the server, and the server is responsible for granting or denying access."", ""Client""); (""ServerSocket"", ""The ServerSocket is related to the Server because it is part of the server's functionality, specifically used for accepting or denying access to the server."", ""Server"")"
That way the listening thread spends as little time as possible outside the serverSocket.accept() call.,NULL
"For instance, if you process 1.000 requests concurrently and each request takes 1 second, then all requests will take 1.000 seconds to complete.",NULL
"To use IText PDF API for Java you must first download the IText JAR file from the IText website, and include it on your application class path.","(""IText PDF API"", ""IText PDF API is related to IText JAR because the JAR file is required to use the IText PDF API"", ""IText JAR""); (""IText PDF API"", ""IText PDF API is related to Java because it is a Java API"", ""Java""); (""IText JAR"", ""IText JAR is related to IText website because the JAR file can be downloaded from the IText website"", ""IText website""); (""IText JAR"", ""IText JAR is related to application class path because it needs to be included in the class path"", ""application class path""); (""IText website"", ""IText website is related to IText PDF API because the website provides the necessary resources to use the API"", ""IText PDF API""); (""Java"", ""Java is related to application class path because Java applications use class paths"", ""application class path"")"
"The com.itextpdf.text.Anchor class in IText represents an link, either to an external website, or internally in the document.","(""Anchor"", ""The Anchor class is part of the IText package, indicating a relationship between the two entities."", ""IText""); (""Anchor"", ""The Anchor class is located in the com.itextpdf.text package, indicating a relationship between the two entities."", ""com.itextpdf.text"")"
"The com.itextpdf.text.Chunk class in IText represents the smallest possible ""chunk"" of text.","(""Chunk"", ""The Chunk class is located in the com.itextpdf.text package, indicating a relationship between the two entities."", ""com.itextpdf.text""); (""Chunk"", ""The Chunk class is part of the IText library, suggesting a relationship between the class and the library."", ""IText"")"
"If you need to generate a PDF document from scratch, you will use the Document class.",NULL
"You can specify fonts for most text objects (Chunk, Phrase, Paragraph etc.)","(""Chunk"", ""Both Chunk and Paragraph are text objects that can have fonts specified for them"", ""Paragraph""); (""Phrase"", ""Both Phrase and Paragraph are text objects that can have fonts specified for them"", ""Paragraph"")"
The com.itextpdf.text.Image is used to add images to IText PDF documents.,NULL
You set the absolute position of an image using the setAbsolutePosition() method.,NULL
"If you already have a finished PDF, and just want to add a header, footer or watermark to it, IText provides the com.itextpdf.pdf.PdfStamper class.",NULL
You can set the alignment of the paragraph using the setAlignment() method.,NULL
"You can write text as superscript or subscript using the Chunk class, and it's setTextRise() method.",NULL
You can add tables to a PDF document using the com.itextpdf.text.PdfPTable class in IText.,"(""IText"", ""IText is related to com.itextpdf.text because com.itextpdf.text is a package within the IText package or library."", ""com.itextpdf.text""); (""com.itextpdf.text"", ""com.itextpdf.text is related to PdfPTable because PdfPTable is a class within the com.itextpdf.text package."", ""PdfPTable""); (""com.itextpdf.text"", ""com.itextpdf.text is related to com.itextpdf.text.PdfPTable because com.itextpdf.text.PdfPTable is a fully qualified name of the PdfPTable class within the com.itextpdf.text package."", ""com.itextpdf.text.PdfPTable""); (""IText"", ""IText is related to PdfPTable because PdfPTable is a class used in the IText library or package."", ""PdfPTable"")"
"To add cells to the table you call the addCell() method, passing PdfPCell instances, or other IText objects like Paragraph etc.","(""TableCell"", ""The TableCell class has a method called AddCell, indicating a relationship between the two."", ""AddCell""); (""AddCell"", ""The AddCell method accepts PdfPCell instances as parameters, showing a relationship between the method and the class."", ""PdfPCell""); (""AddCell"", ""The AddCell method also accepts Paragraph objects, which are part of the IText package, showing a relationship between the method and the class."", ""Paragraph""); (""PdfPCell"", ""The PdfPCell class is part of the IText package, indicating a relationship between the class and the package."", ""IText""); (""Paragraph"", ""The Paragraph class is also part of the IText package, showing a relationship between the class and the package."", ""IText""); (""TableCell"", ""The TableCell class uses PdfPCell instances, indicating a relationship between the two classes."", ""PdfPCell"")"
"You can set the column widths using the setWidths() method, like this:",NULL
"If you need a cell to span multiple columns you can do so using the setColspan() method, like this:",NULL
"In text mode the settings of the added element (Phrase, Paragraph etc.)","(""TEXT"", ""The TEXT mode has settings for the added element."", ""SETTINGS""); (""TEXT"", ""The TEXT mode has settings for the added element."", ""ELEMENT""); (""TEXT"", ""The TEXT mode includes PHRASE as an added element."", ""PHRASE""); (""TEXT"", ""The TEXT mode includes PARAGRAPH as an added element."", ""PARAGRAPH""); (""ELEMENT"", ""The added ELEMENT has SETTINGS in TEXT mode."", ""SETTINGS""); (""ELEMENT"", ""PHRASE is a type of added ELEMENT."", ""PHRASE""); (""ELEMENT"", ""PARAGRAPH is a type of added ELEMENT."", ""PARAGRAPH""); (""SETTINGS"", ""The SETTINGS apply to the added PHRASE element."", ""PHRASE"")"
Content added via the PdfCell.addElement() method is considered composite mode content.,NULL
"You can set the default cell settings of new cells added, using the table.addCell() methods, like this:",NULL
The method setIndent() sets the indentation of the first paragraph in the cell.,"(""Setindent"", ""The method setIndent() is related to the paragraph because it sets the indentation of the first paragraph in the cell."", ""Paragraph""); (""Cell"", ""The cell is related to the paragraph because the paragraph is in the cell."", ""Paragraph"")"
The method setFollowingIndent() sets the indentation of the following paragraphs in the cell.,"(""SetFollowingIndent"", ""The method setFollowingIndent() is related to the following paragraphs because it sets the indentation of these paragraphs."", ""Following Paragraphs""); (""SetFollowingIndent"", ""The method setFollowingIndent() is related to the cell because it sets the indentation of the following paragraphs in the cell."", ""Cell"")"
The method setRightIndent() sets the right indentation of the cell content.,"(""SetRightIndent"", ""The method setRightIndent() is related to the Cell class because it operates on the cell content, indicating that setRightIndent() is a method of the Cell class."", ""Cell"")"
"If the cell is in composite mode, just set the leading on the element added, e.g.",NULL
The second method call sets the leading to 0 points + 1.5 x font height.,NULL
"You can set the rotation of the cell content using the setRotation() method, like this:",NULL
"You can add underline and strikethrough text using the Chunk class, and its setUnderline() method.",NULL
Quite often Java applications keep objects in data structures that contain java.util.ArrayList instances.,"(""Java"", ""Java applications often use ArrayList, indicating a relationship between the two."", ""ArrayList""); (""ArrayList"", ""ArrayList is part of the java.util package, indicating a containment relationship."", ""java.util"")"
This tutorial will also look at the performance of the OpenArrayList class - a class that mimics the java.util.ArrayList but designed with performance in mind.,"(""OpenArrayList"", ""The OpenArrayList class mimics the ArrayList class, indicating a relationship between the two classes."", ""ArrayList""); (""OpenArrayList"", ""The OpenArrayList class is compared to the java.util.ArrayList, indicating a relationship between the OpenArrayList class and the java.util package."", ""java.util"")"
Each element is obtained from the ArrayList instance using the get() method.,NULL
The third way to iterate an ArrayList is to use an java.util.Iterator obtained from the ArrayList.,"(""ArrayList"", ""The ArrayList class is related to the java.util.Iterator class because an Iterator can be obtained from the ArrayList."", ""java.util.Iterator""); (""java.util.Iterator"", ""The java.util.Iterator class is related to the java.util package because it is contained within this package."", ""java.util"")"
The benchmarks were executed using JDK 1.8.0_u60 on a Intel Core i7-4770 Haswell server which was doing nothing but the benchmarks.,"(""benchmarks"", ""The benchmarks were executed using JDK, showing a clear relationship between the benchmarks and the JDK package."", ""JDK""); (""benchmarks"", ""The benchmarks were executed on a server, indicating a relationship between the benchmarks and the server."", ""server"")"
"You can also see that iterating an ArrayList using a standard Java for loop with a counter, and obtaining each element by calling the ArrayList get() method is about 10% faster for an ArrayList with 10 elements, and around 12,5% faster when the ArrayList contains 100 elements.","(""ArrayList"", ""The ArrayList class has a relationship with the get() method because the get() method is called on an ArrayList object to obtain each element."", ""get()""); (""Java"", ""The Java package has a relationship with the ArrayList class because ArrayList is a part of the Java package."", ""ArrayList"")"
The OpenArrayList class is a very simple imitation of the ArrayList which I have implemented to see if it could iterate a collection of elements faster than an ArrayList .,NULL
"This should be a tiny bit faster than calling the ArrayList get() method, although the JVM could optimize the get() method call away.",NULL
Another advantage of making the elements array public is that you can write to it or copy from it using System.arraycopy() which is very fast.,"(""System"", ""System is a class that contains the method Arraycopy"", ""Arraycopy""); (""Elements"", ""Elements can be manipulated using System's method Arraycopy"", ""System"")"
The fact that the performance is so close is probably a sign that the JVM has optimized the get() call away.,"(""JVM"", ""The JVM has optimized the get() call, indicating a relationship between the JVM and the get() method."", ""get()""); (""JVM"", ""The JVM's optimization affects the performance, indicating a relationship between the JVM and the performance."", ""performance"")"
"As you can see, the readMyData() method returns a MyData object.",NULL
What is worth noting about this read pattern is that every time you call the readMyData() method a new MyData object is returned.,NULL
If the readMyData() method is called frequently that will lead to a lot of MyData objects being created.,NULL
Here is how the earlier readMyData() method would look using the read-into-existing pattern:,NULL
"It is now up to the caller of the readMyData() method to decide if an existing MyData instance should be reused, or if a new instance should be created.",NULL
Reusing an object also means that the chance the object is located in the CPU cache is much higher than when you create a new object for each call to the readMyData() method.,"(""Object"", ""The object is related to the readMyData() method because the method is called on the object, implying a connection between the two entities."", ""ReadMyData""); (""Object"", ""The object is related to the CPU Cache because the chance of the object being located in the CPU cache is higher when it is reused, indicating a connection between object location and CPU cache."", ""CPU Cache"")"
To change the previous example code to read data directly from the underlying source we need to change the implementation of the MyData class:,NULL
"To use the MyData class in its new variation, you will use code like this:",NULL
Just call setSource() when you need to read data out of a new byte array.,NULL
"Third, only if you actually call both getVal1() and getVal2() will the corresponding data be read out of the underlying byte array.","(""GetVal1"", ""GetVal1 is related to Byte Array because it reads data out of the underlying byte array when called"", ""Byte Array"")"
"Assuming that each MyData object consists of 2 bytes from the underlying source, here is how the MyData class would look with a navigation method added:","(""MyData"", ""The MyData class has a relationship with itself as it is being described and having a method added to it"", ""MyData"")"
The first change is the that the setSource() method now takes an extra parameter called offset.,NULL
The second change is that the getVal1() and getVal2() methods now use the value of the internal offset variable as index into the source array when reading values out.,NULL
"The next() method increments the internal offset variable by 2, so that the offset variable points to the next record in the array.","(""Next"", ""The next() method increments the internal offset variable, indicating a clear relationship between the two entities as the method directly modifies the variable."", ""Offset""); (""Next"", ""The next() method is used in the context of the array, as it increments the offset to point to the next record in the array, establishing a clear connection between the method and the array."", ""Array""); (""Offset"", ""The offset variable points to a record in the array, showing a relationship between the offset and the array as the offset is used to track the position within the array."", ""Array""); (""Internal"", ""The internal offset variable indicates that there is an offset that is internal to the context, and this internal offset is directly related to the offset variable, suggesting they are the same entity or closely related."", ""Offset""); (""Internal"", ""Given the internal offset variable points to a record in the array, there is a clear connection between the internal offset and the array, as the internal offset serves to track the position within the array."", ""Array"")"
The fourth change is the addition of the hasNext() method which returns true if the source byte array has more records (bytes) in it.,NULL
"As you can see, using the MyData class in the navigator pattern implementation is pretty straightforward.","(""MyData"", ""MyData class is part of the com.example package"", ""com.example""); (""MyData"", ""MyData class is used in the navigator pattern implementation"", ""navigator pattern"")"
"Additionally, if your server works on many tasks at the same time (e.g incoming HTTP requests), the other CPUs in your server may already be busy working on their own tasks.","(""Server"", ""The server has multiple CPUs, indicating a relationship between the server and its CPUs."", ""CPUs""); (""Server"", ""The server works on many tasks, indicating a relationship between the server and tasks."", ""Tasks""); (""Server"", ""The server works on incoming HTTP requests, indicating a relationship between the server and HTTP requests."", ""HTTP Requests"")"
"My own experiences come from from a mix of Java performance experiments, as well as the design and development of VStack.co - a fully hosted application backend which I have cofounded with WorpCloud Ltd.","(""VStack.co"", ""VStack.co is developed using Java, indicating a relationship between the application backend and the programming language"", ""Java"")"
"The Java ArrayList class only works for objects - not for primitive types (byte, int, long etc).","(""ArrayList"", ""ArrayList is a part of the Java class library"", ""Java"")"
The code consist of 3 Java classes and 2 unit tests.,"(""Code"", ""The code is written in Java, indicating a relationship between the code and the Java class."", ""Java"")"
100.000 x 1MB = 100GB (approximately - not precisely - but you get the picture).,NULL
"Note, that in languages with built-in garbage collection (like Java, C# etc.)",NULL
Even at 4GB (1.000.000 x 4KB) modern servers should be able to handle it.,NULL
"Additionally, if you use a small block size, you may have to expand blocks more often than if you use e.g.","(""ADDITIONALLY"", ""ADDITIONALLY is related to BLOCK because it is discussing the effect of block size"", ""BLOCK""); (""BLOCK"", ""BLOCK is related to SIZE because the size of the block is being discussed"", ""SIZE"")"
"To obtain a ResizableArray instance, call the ResizableArrayBuffer's getArray() method, like this:","(""ResizableArrayBuffer"", ""The ResizableArrayBuffer and getArray are related because getArray is a method of ResizableArrayBuffer"", ""getArray""); (""ResizableArray"", ""The ResizableArray and getArray are related because getArray returns an instance of ResizableArray"", ""getArray"")"
The ResizableArray class in the GitHub repository only contains a single write() method which takes a ByteBuffer as parameter.,NULL
"It should be pretty easy to add more write() methods yourself, though.",NULL
The value returned by write() is the number of bytes copied from the ByteBuffer.,NULL
"If the ResizableArray cannot contain all the data in the ByteBuffer after expanding itself to the max size, the write() method will return -1 and no data will have been copied at all!","(""ResizableArray"", ""The ResizableArray uses the write() method to copy data from the ByteBuffer, indicating a relationship between the two entities."", ""write()""); (""ByteBuffer"", ""The write() method operates on the data in the ByteBuffer, indicating a relationship between the two entities."", ""write()"")"
"You do so simply by calling the free() method on the ResizableArray, like this:",NULL
"Calling free() takes care of returning the used block to the correct block queue, regardless of the size of the block allocated to the ResizableArray.","(""ResizableArray"", ""The free method is being called on a block allocated to the ResizableArray, indicating a relationship between the ResizableArray class and the free method."", ""free""); (""free"", ""The free method is used to return the used block to the correct block queue, indicating a relationship between the free method and the block."", ""block"")"
I have implemented batch mode put() and take() operations for both ring buffer implementations.,"(""Batch"", ""The Batch entity is related to the Put entity because batch mode put() operation is implemented for ring buffer implementations."", ""Put""); (""Batch"", ""The Batch entity is related to the Take entity because batch mode take() operation is implemented for ring buffer implementations."", ""Take""); (""Put"", ""The Put entity is related to the Ring Buffer entity because put() operation is implemented for ring buffer implementations."", ""Ring Buffer"")"
My benchmarks showed that batch put() and take() operations provides up to 4 times the throughput of putting and taking a single element at a time.,"(""Batch"", ""Batch and Put are related because batch put operations are mentioned in the text as providing increased throughput"", ""Put""); (""Batch"", ""Batch and Take are related because batch take operations are mentioned in the text as providing increased throughput"", ""Take"")"
Here is an implementation of the ring buffer that uses a fill count including the batch put() and take() operations.,"(""Ring Buffer"", ""The Ring Buffer class uses the Put method for batch put operations."", ""Put""); (""Ring Buffer"", ""The Ring Buffer class uses the Take method for batch take operations."", ""Take"")"
"Here is an implementation of the ring buffer that uses a read position and flip marker, including the batch put() and take() operations.","(""Ring Buffer"", ""The Ring Buffer uses a Read Position, indicating a relationship between the two entities."", ""Read Position""); (""Ring Buffer"", ""The Ring Buffer uses a Flip Marker, indicating a relationship between the two entities."", ""Flip Marker""); (""Ring Buffer"", ""The Ring Buffer includes the Put operation, indicating a relationship between the two entities."", ""Put""); (""Ring Buffer"", ""The Ring Buffer includes the Take operation, indicating a relationship between the two entities."", ""Take""); (""Put"", ""The Put operation is mentioned alongside batch, indicating a relationship between the two entities."", ""Batch"")"
"The JMH Maven archetype will generate a new Java project with a single, example benchmark Java class, and a Maven pom.xml file.","(""JMH Maven Archetype"", ""JMH Maven archetype is related to Maven because it is used to generate a new Java project with a Maven pom.xml file."", ""Maven""); (""JMH Maven Archetype"", ""JMH Maven archetype is related to Java because it generates a new Java project with a single, example benchmark Java class."", ""Java""); (""Maven"", ""Maven is related to Java because it is used to manage Java projects and generate pom.xml files for them."", ""Java""); (""Benchmark Java Class"", ""Benchmark Java Class is related to Java because it is a Java class."", ""Java"")"
The Maven pom.xml file contains the correct dependencies to compile and build your JMH microbenchmark suite.,"(""Maven"", ""Maven is related to pom.xml because pom.xml is a file used in Maven projects to manage dependencies and build configurations"", ""pom.xml""); (""Maven"", ""Maven is related to JMH because JMH microbenchmark suite is built and compiled using Maven"", ""JMH""); (""pom.xml"", ""pom.xml is related to JMH because pom.xml contains the correct dependencies to compile and build JMH microbenchmark suite"", ""JMH""); (""JMH"", ""JMH is related to microbenchmark because microbenchmark is a type of benchmark that JMH is used for"", ""microbenchmark"")"
"It is time to write your first JMH benchmark class, or at least see how it is done.",NULL
The generated MyBenchmark class is a JMH class template which you can use to implement your JMH benchmarks.,NULL
"You can either implement your benchmarks directly in the generated MyBenchmark class, or create a new class in the same Java package.",NULL
To make it easy for you to write your first JMH benchmark I will just use the generated class in this example.,NULL
You can put the code you want to measure inside the testMethod() method body.,NULL
"For now, just imagine that the testMethod() body actually contained a good benchmark implementation.",NULL
"When you build your JMH benchmarks, Maven will always generate a JAR file named benchmarks.jar in the target directory (Maven's standard output directory).","(""Maven"", ""Maven generates a JAR file named benchmarks.jar"", ""benchmarks.jar""); (""Maven"", ""Maven is used to build JMH benchmarks"", ""JMH"")"
It contains your compiled benchmark classes as well as all JMH classes needed to run the benchmark.,"(""JMH"", ""JMH and Benchmark are related as they are both mentioned in the context of running a benchmark, suggesting a connection between the two classes""}"", ""Benchmark""); (""It"", ""It contains JMH classes, indicating that It is related to JMH, likely as a container or holder of JMH classes""}"", ""JMH"")"
"If your benchmarks has any external dependencies (JAR files from other projects needed to run your benchmarks), declare these dependencies inside the Maven pom.xml, and they will be included in the benchmarks.jar too.","(""Maven"", ""Maven is related to pom.xml because pom.xml is a configuration file used by Maven to manage dependencies and build projects."", ""pom.xml""); (""pom.xml"", ""pom.xml is related to benchmarks.jar because the dependencies declared in pom.xml are included in the benchmarks.jar file."", ""benchmarks.jar""); (""Maven"", ""Maven is related to benchmarks.jar because Maven is used to build and package the benchmarks.jar file."", ""benchmarks.jar""); (""JAR"", ""JAR is related to benchmarks.jar because benchmarks.jar is a type of JAR file."", ""benchmarks.jar"")"
"Since benchmarks.jar is fully self contained, you can copy that JAR file to another computer to run your JMH benchmarks on that computer.","(""Benchmarks"", ""Benchmarks is related to JMH because JMH is used to run benchmarks"", ""JMH""); (""JMH"", ""JMH is related to Jar because the JMH benchmarks are packaged in a Jar file"", ""Jar"")"
This means that you want the output shown using the time unit minutes (e.g.,NULL
"State variables are declared in special state classes, and an instance of that state class can then be provided as parameter to the benchmark method.","(""State Class"", ""The state class is related to the benchmark method because an instance of the state class is provided as a parameter to the benchmark method."", ""Benchmark Method""); (""State Variables"", ""The state variables are related to the state class because they are declared in the state class."", ""State Class"")"
In this example I have added a nested static class named MyState.,NULL
Notice that the testMethod() benchmark method now takes an instance of MyState as parameter.,NULL
Notice also that the testMethod() body has now been changed to use the MyState object when performing its sum calculation.,NULL
Notice the two new methods in the MyState class named doSetup() and doTearDown().,"(""MyState"", ""MyState class contains the doSetup() method"", ""doSetup()"")"
"If you have any doubts about when a setup or tear down method is called, try inserting a System.out.println() statement in the method.","(""Setup"", ""The setup method is related to System.out because System.out.println() can be used within the setup method to print output."", ""System.out""); (""Tear Down"", ""The tear down method is related to System.out because System.out.println() can be used within the tear down method to print output."", ""System.out"")"
"If your benchmark method is calculating multiple values that might end up being eliminated as dead code, you can either combine the two values into a single, and return that value (e.g.","(""Benchmark"", ""The benchmark method is a part of the benchmark class, indicating a relationship between the two entities."")
{completion_delimiter}
#####################!"", ""Method"")"
Notice how the testMethod() benchmark method now takes a Blackhole object as parameter.,NULL
Notice also how the calculated sum in the sum variable is now passed to the consume() method of the Blackhole instance.,"(""Sum"", ""The sum variable is passed to the consume() method, indicating a relationship between the sum variable and the consume() method."", ""Consume""); (""Blackhole"", ""The consume() method is called on the Blackhole instance, indicating a relationship between the Blackhole class and the consume() method."", ""Consume"")"
"If your benchmark method produces multiple results you can pass each of these results to a black hole, meaning calling consume() on the Blackhole instance for each value.",NULL
"The JVM could even continue and never call the testMethod() because it knows it always returns 3, and just inline the constant 3 wherever the testMethod() was to be called.",NULL
Sometimes a lot of time is even spent just allocating and freeing memory (e.g.,"(""MEMORY"", ""Memory is related to allocating as it is being allocated"", ""ALLOCATING""); (""ALLOCATING"", ""Allocating is related to memory as it is the process of assigning memory"", ""MEMORY"")"
"When you control object allocation, deallocation and reallocation you can make limits like e.g.","(""Object"", ""The Object entity is related to the allocation entity as it is being controlled for allocation"", ""allocation""); (""Object"", ""The Object entity is related to the deallocation entity as it is being controlled for deallocation"", ""deallocation"")"
having a maximum of 10.000 messages in memory at a time.,"(""Message"", ""Message is handled by MessageHandler"", ""MessageHandler""); (""MessageHandler"", ""MessageHandler uses handleMessage method"", ""handleMessage""); (""MessagingPackage"", ""MessagingPackage contains Message class"", ""Message""); (""MessagingPackage"", ""MessagingPackage contains MessageHandler class"", ""MessageHandler"")"
"The batch size can thus vary from 1 to a maximum upper limit set by the system, e.g.",NULL
"To achieve lower latency, yet allowing for micro batching to happen, you can loop over the input channels (inbound network connections, directories etc.)","(""Input"", ""Input is related to Channels because it is mentioned that the input channels are being looped over"", ""Channels""); (""Loop"", ""Loop is related to Input because it is being used to loop over the input channels"", ""Input"")"
Therefore it can be beneficial to batch up data sent outside a process to minimize the overhead per data block (e.g.,NULL
"Instead of traversing the whole data structure to serve just one ""request"" (task, message etc.)",NULL
Notice how two different DAO's were called from inside the control's execute() method.,"(""DAO"", ""The DAO class is related to the Control class because it is called from inside the Control's execute() method."", ""Control""); (""Execute"", ""The Execute method is related to the Control class because it is a method of the Control class."", ""Control"")"
"To make this happen you need to obtain a database connection (or equivalent object) inside the Control.execute() method, and pass this connection (or other object) to each DAO.","(""Control"", ""The Control class has a method called execute, indicating a relationship between the Control class and the execute method."", ""execute""); (""execute"", ""The execute method requires a database connection to be obtained, indicating a relationship between the execute method and the database connection."", ""database connection"")"
"Well, you could if you call a setConnection() method on them afterwards.",NULL
The DaoManager is a class that you put in between the Control and the DAO's.,"(""DaoManager"", ""The DaoManager is a class that you put in between the Control and the DAO's, indicating that DaoManager acts as an intermediary for Control."", ""Control"")"
Once the DaoManager.executeAndClose() method finishes the database connection inside the DaoManager is closed.,"(""DaoManager"", ""The executeAndClose() method is a part of the DaoManager class, indicating a relationship between the two."", ""executeAndClose()""); (""DaoManager"", ""The DaoManager class is related to the database connection as it is responsible for closing the connection after the executeAndClose() method finishes."", ""database connection"")"
"As you can see from the code example in the previous section, the scope of the connection when managed by the DaoManager.executeAndClose() is the boundaries of the executeAndClose() method.",NULL
This could be the case in a desktop application if each control is registered independently as listeners on e.g.,NULL
It is the DaoManager's executeAndClose() method that demarcates the life span of the underlying connection.,NULL
"If you call this method from each control's execute() method (or whatever the central execution method in your controls is called), each control will open and close a connection separately.","(""Control"", ""The Control class has a method called Execute, indicating a relationship between the two."", ""Execute""); (""Control"", ""The Control class opens and closes a Connection, indicating a relationship between the two."", ""Connection"")"
The ScopingDataSource will be moved to Butterfly Persistence from around version 5.2.0 or 5.4.0 which will be released in 2009.,NULL
The ScopingDataSource is an implementation of the standard Java interface javax.sql.DataSource.,NULL
"Once this method is called, whenever the tread that called this method calls the ScopingDataSource.getConnection() method, the same connection instance is returned.","(""ScopingDataSource"", ""ScopingDataSource and getConnection are related because getConnection is a method of the ScopingDataSource class"", ""getConnection""); (""getConnection"", ""getConnection and connection are related because getConnection returns a connection instance"", ""connection"")"
"This ScopingConnection ignores all calls to the close() method, so the underlying connection can be reused.","(""ScopingConnection"", ""ScopingConnection ignores all calls to the close() method, so they are related as the class has the method"", ""close"")"
"When you are ready to close the connection your control calls the ScopingDataSource.endConnectionScope(), and the currently open connection (if any) is closed.",NULL
"From here on the ScopingDataSource behaves just like a regular DataSource, returning a new Connection for every call to getConnection().","(""ScopingDataSource"", ""ScopingDataSource behaves just like a regular DataSource, indicating a possible inheritance or implementation relationship"", ""DataSource""); (""ScopingDataSource"", ""ScopingDataSource returns a new Connection for every call to getConnection, indicating that ScopingDataSource has a method named getConnection"", ""getConnection""); (""DataSource"", ""DataSource has a method named getConnection, which returns a new Connection"", ""getConnection""); (""getConnection"", ""getConnection returns a new Connection, indicating that getConnection is related to Connection"", ""Connection""); (""ScopingDataSource"", ""ScopingDataSource returns a new Connection for every call to getConnection, indicating that ScopingDataSource is related to Connection"", ""Connection"")"
"The calls to beginConnectionScope() and endConnectionScope() do not have to be located within the same method, nor within the same class.","(""BeginConnectionScope"", ""BeginConnectionScope is a method that can be located within a class"", ""Class""); (""EndConnectionScope"", ""EndConnectionScope is a method that can be located within a class"", ""Class""); (""BeginConnectionScope"", ""BeginConnectionScope is a method"", ""Method""); (""EndConnectionScope"", ""EndConnectionScope is a method"", ""Method"")"
"You can just extend the DBControlBase and override the doExecute() method, then all connection scoping is done for you.",NULL
"They can be called outside the Control.execute() method too, or inside a parent control.","(""Control"", ""The Control class has an execute method, indicating a relationship between the two."", ""execute"")"
"If your Control class implements an interface, you can implement a Dynamic Proxy which implements the same interface.","(""Control"", ""The Control class implements the interface, indicating a relationship between the two entities."", ""interface"")"
"When the execute() method is called on the control interface, this dynamic proxy will call the beginConnectionScope(), then call your controls execute() method, and finally the endConnectionScope().","(""Control"", ""The Control class has an execute() method"", ""Execute""); (""Execute"", ""The execute() method calls the beginConnectionScope() method"", ""BeginConnectionScope""); (""Execute"", ""The execute() method calls the endConnectionScope() method"", ""EndConnectionScope""); (""Control"", ""The Control class uses the beginConnectionScope() method"", ""BeginConnectionScope"")"
The only difference is that you call beginTransactionScope() and endTransactionScope() instead.,NULL
"When a connection is obtained from the ScopingDataSource while inside a transaction scope, connection.setAutoCommit(false) is called.","(""ScopingDataSource"", ""The ScopingDataSource is related to the connection because it is the source from which the connection is obtained."", ""connection""); (""connection"", ""The connection is related to the setAutoCommit method because the method is called on the connection object."", ""setAutoCommit""); (""transaction scope"", ""The transaction scope is related to the ScopingDataSource because the connection is obtained from the ScopingDataSource while inside a transaction scope."", ""ScopingDataSource"")"
"If an exception is thrown before the endTransactionScope() method is called, you should catch that exception and call abortTransactionScope(Exception) with that exception.",NULL
The first problem you run into when designing DAO classes is connection scoping.,NULL
A naive implementation of a DAO class using JDBC to target a relational database might look like below (at least I have designed DAO's like this in the past).,NULL
Notice how the readPerson() method opens its own connection and closes it again once it is done.,"(""Readperson"", ""The readPerson method is related to the Connection because it opens and closes the connection."", ""Connection"")"
You might also be able to hide connection closing from the domain logic by adding a close() method to the DAO.,"(""DAO"", ""The DAO class has a close() method, indicating a clear relationship between the two entities as the method is part of the class."", ""close()""); (""DAO"", ""The DAO is used in conjunction with the domain logic to hide connection closing, showing a relationship between the DAO class and the domain logic package."", ""domain logic"")"
But somewhere in the domain logic you would have to call that close() method.,NULL
The method call daoFactory.beginConnectionScope() marks the beginning of a connection scope.,NULL
The method call daoFactory.endConnectionScope() ends the current connection scope and closes the connection associated with the scope.,NULL
This way neither of the DAO's need to have close() methods.,NULL
The methods beginTransaction() and endTransaction() mark the beginning and end of the transaction.,NULL
The beginTransaction() method will call connection.setAutoCommit(false) for the connection associated with the transaction scope.,"(""beginTransaction()"", ""The beginTransaction() method will call connection.setAutoCommit(false) for the connection associated with the transaction scope, indicating a relationship between the beginTransaction() method and the connection class."", ""connection""); (""beginTransaction()"", ""The beginTransaction() method is associated with the transaction scope, indicating a relationship between the beginTransaction() method and the transaction scope class."", ""transaction scope""); (""connection"", ""The connection is associated with the transaction scope, indicating a relationship between the connection class and the transaction scope class."", ""transaction scope""); (""connection"", ""The connection has a method called setAutoCommit(false), indicating a relationship between the connection class and the setAutoCommit(false) method."", ""setAutoCommit(false)"")"
The endTransaction() method will attempt to commit the transaction and call setAutoCommit(false) again.,NULL
Notice the new method call in the catch-block of the transaction scope: daoFactory.abortTransaction(e).,NULL
This method call rolls the transaction back if an exception is thrown from any of the dao methods or from endTransaction().,"(""Method"", ""The method is related to Dao because it mentions 'dao methods' which implies a connection between the method and the Dao class."", ""Dao"")"
"The DAO layer usually consists of a smaller set of classes, than the number of domain logic classes that uses it.",NULL
"It is also a somewhat more controlled operation, since you can search for all DAO classes, and make sure they are changed to use the new persistence mechanism.",NULL
"To solve the problems mentioned earlier, you can move some of the code to a DaoManager class.",NULL
Notice that the getPersonDao() method isn't synchronized even though it returns a kind of singleton.,NULL
"Rather than implementing a close() method in the DaoManager class, a template method will be added called executeAndClose().","(""DaoManager"", ""The DaoManager class contains the close() method."", ""close()""); (""DaoManager"", ""The DaoManager class will have the executeAndClose() method added to it."", ""executeAndClose()"")"
This instance then has it's execute() method invoked with the DaoManager itself as parameter.,NULL
Now the scope of the connection is marked by the scope of the method call executeAndClose().,NULL
"Any exception handling related to the connection.close() call can be hidden away inside the executeAndClose() method, and reused throughout the application.","(""ExecuteAndClose"", ""The ExecuteAndClose method is related to the Connection class because it handles exception handling related to the connection.close() call."", ""Connection""); (""ExecuteAndClose"", ""The ExecuteAndClose method is related to the Application package because it can be reused throughout the application."", ""Application"")"
You can add a transaction() method similar to the executeAndClose() method which takes care of transaction management.,"(""Transaction()"", ""The Transaction() method is related to the ExecuteAndClose() method because they are both used for managing transactions."", ""ExecuteAndClose!""); (""Transaction"", ""The Transaction class is related to the Transaction() method because the method is likely a part of the class."", ""Transaction()"")"
"For instance, if both commit() and rollback() throws exceptions, both of these exception are not properly preserved or handled.",NULL
Using the transaction() method is analogous to using the executeAndClose() method:,NULL
This could be done by wrapping the call to transaction() inside the call to executeAndClose().,NULL
"As you can see a DaoManager class can solve the problems of marking both connection life span and transaction boundaries, and automatically open and close connections and commit / rollback transactions.","(""DaoManager"", ""The DaoManager class is related to connection because it can automatically open and close connections."", ""connection"")"
"If you implement a base event listener class that all event listeners (or actions, or whatever your framework calls them) extend, you can put the DaoManager code in that class (or a subclass of the base class).","(""Base Event Listener Class"", ""The DaoManager code can be put in the base event listener class, indicating a relationship between the two."", ""DaoManager""); (""Base Event Listener Class"", ""Event listeners extend the base event listener class, indicating a relationship between the two."", ""Event Listeners""); (""Base Event Listener Class"", ""A subclass of the base class can also contain the DaoManager code, indicating a relationship between the base class and its subclass."", ""Subclass""); (""DaoManager"", ""The DaoManager code can be put in a subclass of the base class, indicating a relationship between the DaoManager and the subclass."", ""Subclass"")"
Here is an example of a subclass that executes the persistence code marked in bold in the first code box in this section:,NULL
Now your domain logic class only contains the persistence code that is actually interesting.,NULL
It may not always be possible or feasible to implement such a persistence action base class.,NULL
It would be tempting to put that validation code inside the doPersistenceAction() method.,NULL
"But remember, a connection has been opened already when the DaoManager is instantiated, which happens before the doPersistenceAction() method is called.",NULL
"Furthermore, if the validation fails and aborts the doPersistenceAction() method call, you have opened a connection without ever using it.",NULL
"If you are using a persistence API you will inject whatever class you obtain connections or their equivalents from (sessions in Hibernate, IDaos in Butterfly Persistence).","(""Persistence API"", ""Persistence API is related to Hibernate because Hibernate is mentioned as an example of a persistence API."", ""Hibernate""); (""Persistence API"", ""Persistence API is related to Butterfly Persistence because Butterfly Persistence is mentioned as another example of a persistence API."", ""Butterfly Persistence""); (""Persistence API"", ""Persistence API is related to Sessions because Sessions are obtained from a persistence API like Hibernate."", ""Sessions""); (""Persistence API"", ""Persistence API is related to IDaos because IDaos are obtained from a persistence API like Butterfly Persistence."", ""IDaos""); (""Hibernate"", ""Hibernate is related to Sessions because Sessions are used in Hibernate to obtain connections."", ""Sessions"")"
"This is done to avoid obtaining the connection before the DaoCommand.execute() method is called, to postpone obtaining the connection as much as possible.",NULL
"Inside the DaoCommand.execute() method the getPersonDaoTx() will be called, and then getConnectionTx() will be called, and then connection.setAutoCommit(false) will be called at that time.","(""DaoCommand"", ""The DaoCommand class has an execute() method, indicating a relationship between the class and the method."", ""execute()""); (""execute()"", ""The execute() method calls the getPersonDaoTx() method, indicating a relationship between the two methods."", ""getPersonDaoTx()""); (""getPersonDaoTx()"", ""The getPersonDaoTx() method calls the getConnectionTx() method, indicating a relationship between the two methods."", ""getConnectionTx()""); (""getConnectionTx()"", ""The getConnectionTx() method is related to the connection class, as it is likely used to obtain a connection object."", ""connection"")"
"After this code is executed, you can now access the cookies in the cookieMap using the cookie names as keys (cookieMap.get(""cookieName"")).","(""CookieMap"", ""Get is a method of CookieMap, as shown by the invocation cookieMap.get(cookieName)"")
{completion_delimiter}
######################
(Note: Assuming tuple_delimiter is a comma, record_delimiter is a new line, and completion_delimiter is the specified delimiter at the end)

The final answer is:
(""entity"", ""CookieMap"", ""class"", ""Get"")"
"Second, it sets the expiration to 24 hours using the setMaxAge() method.",NULL
"Cookies are most often used to store user specific information, like e.g.",NULL
The browser includes the Accept-Encoding HTTP header in requests sent to an HTTP server (e.g.,"(""HTTP"", ""HTTP includes Accept-Encoding header"", ""Accept-Encoding"")"
That class is mapped to a set of URL's in the web.xml file.,NULL
"It does so by using a GZIPOutputStream internally, which is a standard Java class.",NULL
Remember to replace the class name with the fully qualified name of your own GZip Servlet filter class.,NULL
"In general, If no header exists with the name passed to getHeader(), null is returned.",NULL
"NOTE: You will have to call this method before calling any getParameter() method, because calling the getParameter() method on an HTTP POST request will cause the servlet engine to parse the HTTP request body for parameters.","(""NOTE"", ""The NOTE entity is related to the getParameter entity because the getParameter method is mentioned in the NOTE."", ""getParameter""); (""getParameter"", ""The getParameter entity is related to the HTTP POST entity because the getParameter method is called on an HTTP POST request."", ""HTTP POST""); (""HTTP POST"", ""The HTTP POST entity is related to the servlet engine entity because the servlet engine parses the HTTP request body for parameters when the getParameter method is called on an HTTP POST request."", ""servlet engine""); (""NOTE"", ""The NOTE entity is related to the HTTP POST entity because the NOTE mentions calling a method before calling any getParameter method on an HTTP POST request."", ""HTTP POST""); (""NOTE"", ""The NOTE entity is related to the servlet engine entity because the NOTE mentions the servlet engine parsing the HTTP request body for parameters."", ""servlet engine"")"
"For instance, you can access context parameters set in the web.xml file, you can forward the request to other servlets, and you can store application wide parameters in the ServletContext too.","(""ServletContext"", ""The ServletContext is related to the ServletRequest because it can be used to forward the request to other servlets."", ""ServletRequest""); (""ServletContext"", ""The ServletContext is related to the Servlet because it can be used to store application wide parameters in the ServletContext."", ""Servlet""); (""ServletRequest"", ""The ServletRequest is related to the Servlet because it can be forwarded to other servlets."", ""Servlet"")"
In order to write binary data back to the browser you cannot use the Writer obtained from response.getWriter().,"(""response"", ""The response entity is related to the getWriter entity because getWriter is a method of the response object."", ""getWriter"")"
Instead you have to use the OutputStream obtained from the response.getOutputStream() method.,"(""response"", ""The response entity is related to the getOutputStream method because the method is called on the response object to obtain an OutputStream."", ""getOutputStream"")"
The javax.servlet.http.HttpServlet class is a slightly more advanced base class than the GenericServlet shown in the Simple Servlet example.,"(""HttpServlet"", ""The HttpServlet class is a slightly more advanced base class than the GenericServlet, indicating a relationship of inheritance or extension."", ""GenericServlet""); (""HttpServlet"", ""The HttpServlet class belongs to the javax.servlet.http package, indicating a relationship of containment or membership."", ""javax.servlet.http"")"
"The HttpServlet class reads the HTTP request, and determines if the request is an HTTP GET, POST, PUT, DELETE, HEAD etc.","(""HttpServlet"", ""The HttpServlet class reads the HTTP request, indicating a relationship between the HttpServlet class and the HTTP protocol"", ""HTTP""); (""HttpServlet"", ""The HttpServlet class determines if the request is an HTTP GET, indicating a relationship between the HttpServlet class and the GET method"", ""GET""); (""HttpServlet"", ""The HttpServlet class determines if the request is an HTTP POST, indicating a relationship between the HttpServlet class and the POST method"", ""POST""); (""HttpServlet"", ""The HttpServlet class determines if the request is an HTTP PUT, indicating a relationship between the HttpServlet class and the PUT method"", ""PUT""); (""HttpServlet"", ""The HttpServlet class determines if the request is an HTTP DELETE, indicating a relationship between the HttpServlet class and the DELETE method"", ""DELETE"")"
"HTTP GET requests only, you will extend the HttpServlet class, and override the doGet() method only.","(""HttpServlet"", ""The HttpServlet class has a doGet() method that can be overridden."", ""doGet()""); (""HTTP"", ""The HTTP package is related to the HttpServlet class, which handles HTTP requests."", ""HttpServlet"")"
"The HttpServlet class has methods you can override for each HTTP method (GET, POST etc.).","(""HttpServlet"", ""The HttpServlet class has methods you can override for each HTTP method, including GET, indicating a relationship between the class and the method."", ""GET"")"
A Java Servlet is just an ordinary Java class which implements the interface,"(""Java Servlet"", ""A Java Servlet is just an ordinary Java class, indicating they are related by the fact that a Java Servlet is a type of Java class"", ""Java class""); (""Java Servlet"", ""A Java Servlet implements the interface, indicating they are related by the implementation relationship"", ""interface"")"
The easiest way to implement this interface is to extend either the class GenericServlet or HttpServlet.,"(""GenericServlet"", ""Both GenericServlet and HttpServlet are classes that can be extended to implement an interface, as stated in the text."", ""HttpServlet""); (""GenericServlet"", ""The text implies that GenericServlet is a class used to implement an interface."", ""interface"")"
"When an HTTP request arrives at the web server, targeted for your Servlet, the web server calls your Servlet's service() method.","(""Servlet"", ""The Servlet class has a service() method, indicating a relationship between the two entities as the method is part of the class."", ""service()""); (""web server"", ""The web server calls the Servlet, indicating a relationship between the two entities as the web server is interacting with the Servlet."", ""Servlet"")"
"The service() method then reads the request, and generates a response which is sent back to the client (e.g.","(""Service"", ""The Service method reads the request, indicating a relationship between the Service and the Request."", ""Request""); (""Service"", ""The Service method generates a response, indicating a relationship between the Service and the Response."", ""Response"")"
"You will need to run your Java Servlets inside a Servlet compatible ""Servlet Container"" (e.g.","(""Java Servlets"", ""Java Servlets are run inside a Servlet Container, indicating a container-contained relationship"", ""Servlet Container""); (""Servlet"", ""A Servlet is typically run inside a Servlet Container, indicating a container-contained relationship"", ""Servlet Container"")"
"The RequestDispatcher class enables your servlet to ""call"" another servlet from inside another servlet.",NULL
The above code obtains a RequestDispatcher targeted at whatever Servlet (or JSP) that is mapped to the URL /anotherUrl.simple.,"(""RequestDispatcher"", ""The RequestDispatcher is targeted at a Servlet, indicating a relationship between the two entities."", ""Servlet"")"
You can call the RequestDispatcher using either its include() or forward() method:,"(""RequestDispatcher"", ""The RequestDispatcher is related to the include() method because it can be called using this method."", ""include()"")"
By calling either the include() or forward() method the servlet container activates whatever Servlet is mapped to the URL the RequestDispatcher.,"(""Include"", ""The include() method is related to the Servlet because it activates the Servlet mapped to the URL of the RequestDispatcher."", ""Servlet""); (""Forward"", ""The forward() method is related to the Servlet because it activates the Servlet mapped to the URL of the RequestDispatcher."", ""Servlet""); (""Servlet"", ""The Servlet is related to the RequestDispatcher because the RequestDispatcher is used to map the URL to the Servlet."", ""RequestDispatcher""); (""Servlet Container"", ""The Servlet Container is related to the Servlet because it activates the Servlet mapped to the URL of the RequestDispatcher."", ""Servlet""); (""Servlet Container"", ""The Servlet Container is related to the RequestDispatcher because it uses the RequestDispatcher to map the URL to the Servlet."", ""RequestDispatcher""); (""Include"", ""The include() method is related to the RequestDispatcher because it uses the RequestDispatcher to map the URL to the Servlet."", ""RequestDispatcher"")"
There is a little difference between calling the forward() and include() method.,NULL
"The forward() method intended for use in forwarding the request, meaning after the response of the calling servlet has been committed.","(""Forward"", ""The forward method is intended for use in forwarding the request, meaning after the response of the calling servlet has been committed, indicating a relationship between the forward method and the servlet."", ""Servlet""); (""Request"", ""The request is being forwarded by the servlet, indicating a relationship between the request and the servlet."", ""Servlet""); (""Response"", ""The response of the servlet has been committed, indicating a relationship between the response and the servlet."", ""Servlet""); (""Forward"", ""The forward method is used for forwarding the request, indicating a relationship between the forward method and the request."", ""Request"")"
"The include() method merges the response written by the calling servlet, and the activated servlet.","(""Include"", ""The include() method merges the response written by the calling servlet, indicating a relationship between the include method and the calling servlet."", ""Calling Servlet"")"
"This way you can achieve ""server side includes"" using the include().",NULL
The red boxes represent state (variables) that your servlet's service() method should be careful about accessing.,NULL
"Of course it is not only the member variables and static variables inside the servlet class itself, that you need to be careful about accessing.","(""Servlet Class"", ""The servlet class contains member variables, so they are related as container and contained."", ""Member Variables""); (""Servlet Class"", ""The servlet class contains static variables, so they are related as container and contained."", ""Static Variables"")"
"Static variables in any other class which are accessed by your servlet, must also be thread safe.",NULL
In order to create a servlet filter you must implement the javax.servlet.Filter interface.,NULL
"When the servlet filter is loaded the first time, its init() method is called, just like with servlets.","(""Servlet Filter"", ""The servlet filter has an init method, indicating a relationship between the servlet filter class and the init method."", ""Init""); (""Servlets"", ""The init method is also called for servlets, indicating a relationship between the servlets class and the init method."", ""Init"")"
"Notice how the doFilter() method checks a request parameter, myParam, to see if it equals the string ""blockTheRequest"".",NULL
"If not, the request is forwarded to the target of the request, by calling the filterChain.doFilter() method.",NULL
"You need to configure the servlet filter in the web.xml file of your web application, before it works.","(""Servlet Filter"", ""The Servlet Filter needs to be configured in the web.xml file, indicating a relationship between the two."", ""Web.xml""); (""Servlet Filter"", ""The Servlet Filter is part of the web application, indicating a relationship between the two."", ""Web Application"")"
With this configuration all requests with URL's ending in .simple will be intercepted by the servlet filter.,"(""Configuration"", ""The configuration is related to the servlet because it is used to intercept requests."", ""Servlet""); (""Servlet"", ""The servlet is related to the filter because the filter is used to intercept requests."", ""Filter""); (""Filter"", ""The filter is related to the URL because it intercepts requests based on URL endings."", ""URL""); (""Configuration"", ""The configuration is related to the URL because it specifies the URL endings that will be intercepted."", ""URL""); (""Requests"", ""The requests are related to the URL because they are made to specific URLs."", ""URL""); (""Servlet"", ""The servlet is related to the requests because it intercepts them."", ""Requests"")"
Before a servlet can be invoked the servlet container must first load its class definition.,NULL
"When the servlet class is loaded, the servlet container creates an instance of the servlet.",NULL
"When a servlet instance is created, its init() method is invoked.",NULL
The init() method allows a servlet to initialize itself before the first request is processed.,NULL
You can specify init parameters to the servlet in the web.xml file.,"(""Web.Xml"", ""The web.xml file is related to the servlet because it is used to specify init parameters to the servlet."", ""Servlet""); (""Servlet"", ""The servlet is related to the init parameters because the init parameters are specified for the servlet in the web.xml file."", ""Init"")"
"For every request received to the servlet, the servlets service() method is called.",NULL
"As long as the servlet is active in the servlet container, the service() method can be called.","(""Servlet"", ""The servlet is active in the servlet container, indicating a relationship between the two."", ""Servlet Container""); (""Servlet"", ""The service() method can be called as long as the servlet is active, indicating a relationship between the servlet and the service() method."", ""Service()"")"
"When a servlet is unloaded by the servlet container, its destroy() method is called.","(""Servlet"", ""The servlet is unloaded by the servlet container, indicating a relationship between the two."", ""Servlet Container"")"
"Once the servlet has been activated via the service() method, the servlet processes the request, and generates a response.","(""Servlet"", ""The Servlet uses the Service() method to process the request and generate a response."", ""Service()""); (""Servlet"", ""The Servlet processes the Request to generate a response."", ""Request""); (""Servlet"", ""The Servlet generates a Response after processing the request."", ""Response""); (""Service()"", ""The Service() method is used to process the Request."", ""Request"")"
This is done in the web.xml file of your Java web application.,NULL
"To configure a servlet in the web.xml file, you write this:",NULL
"Here you give the servlet a name, and writes the class name of the servlet.",NULL
"In the above example, all URL's ending in .html are sent to the servlet.",NULL
You can pass parameters to a servlet from the web.xml file.,"(""Servlet"", ""Servlet can receive parameters"", ""Parameters""); (""Servlet"", ""Servlet can be configured using web.xml file"", ""Web.xml"")"
Here is how you read the init parameters from inside your servlet - in the servlets init() method:,NULL
A servlets init() method is called when the servlet container loads the servlet for the first time.,"(""Servlet"", ""The servlet container loads the servlet for the first time, indicating a relationship between the two."", ""Servlet Container""); (""Init"", ""The init() method is called when the servlet container loads the servlet, indicating a relationship between the init() method and the servlet."", ""Servlet"")"
"No one can access the servlet until the servlet has been loaded, and the init() method has been called successfully.",NULL
"Remember, the servlets init() method is called when the servlet is loaded.",NULL
Here is how you access the parameter from inside an HttpServlet subclass:,"(""HttpServlet"", ""The HttpServlet class is related to the parameter because it is a subclass that can access the parameter"", ""parameter"")"
In this text I will show you a simple unit test implemented using JUnit 4.8.1.,NULL
First I will show you the class I want to test:,NULL
I have kept the class very simple to make it eaiser to understand what is going on.,NULL
To test this class I need a unit test that test each of its public methods.,"(""Class"", ""The class has public methods that need to be tested"", ""Public Methods""); (""Unit Test"", ""The unit test is used to test the class"", ""Class"")"
"The class only has one public method, concatenate(), so all I need to test is this method.",NULL
Each test method usually tests a single method of the target class.,"(""Test"", ""The test class contains the test method."", ""Method""); (""Method"", ""The test method is used to test a single method of the target class."", ""Target"")"
"Sometimes, a test method can test more than one method in the target class, and sometimes, if the method to test is big, you split the test into multiple test methods.","(""Test Method"", ""A test method is related to the method it tests, as it is designed to verify the functionality of the method."", ""Method""); (""Test Method"", ""A test method is related to the target class, as it is testing the methods within that class."", ""Target Class"")"
Here is the JUnit unit test that test that the concatenate() method:,NULL
"The unit test class is an ordinary class, with one method, testConcatenate().",NULL
In this method we compare the output of the called method (concatenate()) with the expected output.,NULL
"In other words, we compare ""onetwo"" (expected output) with the value returned by the concatenate() method, which is kept in the variable result.",NULL
"The assertEquals() method is a statically imported method, which normally resides in the org.junit.Assert class.","(""Assertequlas"", ""The assertEquals() method resides in the org.junit.Assert package, indicating a relationship between the method and the package."", ""Org.Junit.Assert""); (""Assert"", ""The Assert class is part of the org.junit.Assert package, indicating a relationship between the class and the package."", ""Org.Junit.Assert"")"
Notice the static import of this class at the top of MyUnitTest.,NULL
Using the static import of the method is shorter than writing Assert.assertEquals().,"(""Assert"", ""Assert is a class that contains the method Assert.assertEquals"", ""Assert.assertEquals"")"
You can have as many test methods in a unit test class as you want.,NULL
This is how simple a unit test can be with JUnit 4.8.2 .,NULL
"As you may have figured out from the simple test, most of the secret of implementing JUnit unit tests, is in the use of the assert methods in the class org.junit.Assert.","(""Assert"", ""Assert is a part of the org.junit.Assert class"", ""org.junit.Assert""); (""assert"", ""the assert method is used in the org.junit.Assert class"", ""org.junit.Assert""); (""JUnit"", ""org.junit.Assert is a part of the JUnit package"", ""org.junit.Assert"")"
In this text I will take a closer look at what assert methods are available in this class.,NULL
"The code for this class is not shown, but you don't really need the code in order to understand how to test it.",NULL
The assertArrayEquals() method will test whether two arrays are equal to each other.,NULL
"To check for element equality, the elements in the array are compared using their equals() method.","(""Array"", ""The Array class uses the equals method to compare elements"", ""Equals"")"
"More specifically, the elements of each array are compared one by one using their equals() method.",NULL
"Second the myUnit.getTheStringArray() method is called, which is the method we want to test.",NULL
"Third, the result of the myUnit.getTheStringArray() method call is compared to the expected array.",NULL
"If the arrays are equal, the assertArrayEquals() will proceed without errors.","(""ArrayList"", ""The ArrayList class has a method called Add."", ""Add""); (""LinkedList"", ""The LinkedList class also has a method called Add."", ""Add""); (""ArrayList"", ""The ArrayList class is in the Java.Util package."", ""Java.Util"")"
"The assertEquals() method compares two objects for equality, using their equals() method.",NULL
"First the myUnit.concatenate() method is called, and the result is stored in the variable result.","(""Myunit"", ""The Myunit class contains the Concatenate method, indicating a relationship between the class and the method."", ""Concatenate""); (""Concatenate"", ""The Concatenate method is used to store a result in the variable Result, indicating a relationship between the method and the variable."", ""Result"")"
"Second, the result value is compared to the expected value ""onetwo"", using the assertEquals() method.","(""Assertequals"", ""The assertEquals method is used to compare the result value"", ""Result""); (""Assertequals"", ""The assertEquals method is used to compare the expected value 'onetwo'"", ""Expected Value"")"
"If the two objects are equal according to their implementation of their equals() method, the assertEquals() method will return normally.",NULL
"Otherwise the assertEquals() method will throw an exception, and the test will stop there.",NULL
"This example compared to String objects, but the assertEquals() method can compare any two objects to each other.","(""assertEquals()"", ""The assertEquals() method is related to String because it can compare String objects."", ""String"")"
The assertEquals() method also come in versions which compare primitive types like int and float to each other.,"(""Assertequals"", ""The assertEquals method is related to Int because it compares primitive types like int to each other."", ""Int"")"
"The assertTrue() and assertFalse() methods tests a single variable to see if its value is either true, or false.",NULL
"As you can see, the method call to myUnit.getTheBollean() is inlined inside the assertTrue() assertFalse() calls.","(""Myunit"", ""Myunit is related to Getthebollean because Getthebollean is a method called on Myunit"", ""Getthebollean""); (""Myunit"", ""Myunit is related to Asserttrue because the result of Myunit's Getthebollean method is used in the Asserttrue call"", ""Asserttrue""); (""Myunit"", ""Myunit is related to Assertfalse because the result of Myunit's Getthebollean method is used in the Assertfalse call"", ""Assertfalse""); (""Getthebollean"", ""Getthebollean is related to Asserttrue because the result of Getthebollean is used in the Asserttrue call"", ""Asserttrue""); (""Getthebollean"", ""Getthebollean is related to Assertfalse because the result of Getthebollean is used in the Assertfalse call"", ""Assertfalse"")"
"If the getTheBoolean() method returns true, the assertTrue() method will return normally.","(""GETTHEBOOLEAN"", ""The getTheBoolean() method's return value determines the behavior of the assertTrue() method."")
{completion_delimiter}

Given the constraints of the format, the answer, with the assumption that the question implies using the specified format directly, is:

(""entity"",""GETTHEBOOLEAN"",""method"", ""ASSERTTRUE"")"
"If the getTheBoolean() method returns false, the assertFalse() method will return normally.",NULL
"Of course the above test will fail in either the assertTrue() or assertFalse() call, if the getTheBoolean() method returns the same value in both calls.","(""Test"", ""The Test class contains the getTheBoolean method"", ""Gettheboolean""); (""Test"", ""The Test class uses the assertTrue method"", ""Asserttrue""); (""Test"", ""The Test class uses the assertFalse method"", ""Assertfalse""); (""Gettheboolean"", ""The getTheBoolean method return value is used in the assertTrue method"", ""Asserttrue"")"
The assertNull() and assertNotNull() methods test a single variable to see if it is null or not null.,NULL
The call to myUnit.getTheObject() is inlined in the assertNull() and assertNotNull() calls.,"(""Myunit"", ""Myunit uses Gettheobject as one of its methods"", ""Gettheobject""); (""Myunit"", ""Myunit is used in the Assertnull call"", ""Assertnull""); (""Myunit"", ""Myunit is used in the Assertnotnull call"", ""Assertnotnull""); (""Gettheobject"", ""Gettheobject is inlined in the Assertnull call"", ""Assertnull"")"
"If the myUnit.getTheObject() returns null, the assertNull() method will return normally.","(""Myunit"", ""Myunit uses Gettheobject method to retrieve an object"", ""Gettheobject""); (""Gettheobject"", ""The result of Gettheobject is checked by Assertnull method"", ""Assertnull"")"
"If a non-null value is returned, the assertNull() method will throw an exception, and the test will be aborted here.",NULL
"The assertNotNull() method works oppositely of the assertNull() method, throwing an exception if a null value is passed to it, and returning normally if a non-null value is passed to it.",NULL
The assertSame() and assertNotSame() methods tests if two object references point to the same object or not.,NULL
It is not enough that the two objects pointed to are equals according to their equals() methods.,NULL
The calls to myUnit.getTheSameObject() are inlined into the assertSame() and assertNotSame() method calls.,"(""Myunit"", ""Myunit is a class that has a method called Getthesameobject"", ""Getthesameobject""); (""Getthesameobject"", ""Getthesameobject method calls are inlined into Assertsame method calls"", ""Assertsame""); (""Getthesameobject"", ""Getthesameobject method calls are inlined into Assertnotsame method calls"", ""Assertnotsame""); (""Myunit"", ""Myunit has method calls inlined into Assertsame method calls through Getthesameobject"", ""Assertsame"")"
"If the two references points to the same object, the assertSame() method will return normally.",NULL
"If the two objects do not poin to the same object, the assertNotSame() method will return normally.",NULL
The assertThat() method compares an object to an org.hamcrest.Matcher to see if the given object matches whatever the Matcher requires it to match.,"(""AssertThat"", ""The assertThat() method uses an org.hamcrest.Matcher to compare an object."", ""Org.Hamcrest.Matcher""); (""AssertThat"", ""The assertThat() method compares an object to an org.hamcrest.Matcher."", ""Object"")"
"If you are testing a component that uses a database, e.g.",NULL
"a DAO class, you may want to test that the component really inserts data into the database, updates it etc.","(""DAO"", ""The DAO class is related to the database because it is used to interact with the database, such as inserting and updating data."", ""database""); (""component"", ""The component is related to the DAO class because it uses the DAO class to interact with the database."", ""DAO"")"
It is just a standard Java class - nothing secret about it.,NULL
"Exactly what methods you will put in your own TestData class, depends on the data used by your application.",NULL
"Also, you may want some of the methods to take parameters, rather than e.g.",NULL
"Once you have such a TestData class, you can use and reuse it in your unit tests.",NULL
"The TestData class can contain all kinds of business wise complex test data setups, which are then easy to setup in the database, once they have been programmed once.",NULL
"Below is a diagram illustrating a unit test, a unit (which is being tested), and a dependency which is some class used by the unit.","(""Unit"", ""The unit is being tested and has a dependency which is some class used by the unit, indicating a relationship between the unit and the dependency."", ""Dependency""); (""Unit Test"", ""The unit test is testing the unit, indicating a relationship between the unit test and the unit."", ""Unit"")"
"If a method or field is private, only instances of that class can access that method or field.","(""Class"", ""A class can contain a method, and the method's accessibility is determined by the class."", ""Method""); (""Class"", ""A class can contain a field, and the field's accessibility is determined by the class."", ""Field""); (""Method"", ""A method is a member of a class and can be accessed by instances of that class."", ""Class"")"
"A protected method or field, on the other hand, is also accessible to other classes in the same package, and for subclasses of the unit too.","(""Method"", ""A method is related to a package because it can be accessible to other classes in the same package"", ""Package""); (""Field"", ""A field is related to a package because it can be accessible to other classes in the same package"", ""Package""); (""Class"", ""A class is related to a package because it can be in the same package and access other classes and subclasses in the package"", ""Package""); (""Subclasses"", ""Subclasses are related to a class because they are subclasses of the unit and can access its methods and fields"", ""Class""); (""Method"", ""A method is related to a class because it can be a method of the class and accessible to other classes in the same package and subclasses"", ""Class""); (""Field"", ""A field is related to a class because it can be a field of the class and accessible to other classes in the same package and subclasses"", ""Class"")"
"By encapsulating calls to external dependencies (components) in protected methods, you can create a subclass mock of the unit to test, and override these protected methods, to make them record information about whether they were called or not.","(""Subclass"", ""The subclass is a type of unit to test, indicating a relationship between the two entities."", ""Unit""); (""Mock"", ""The mock is related to the subclass as it is a way to create a subclass mock of the unit to test."", ""Subclass""); (""Method"", ""The protected methods are part of the subclass, indicating a relationship between the two entities."", ""Subclass"")"
"By ""boundary class"" I mean classes that plug into some framework.",NULL
You may need the whole framework running in order to test your boundary class.,NULL
"Examples of boundary classes are Servlets, Struts actions, custom Swing components, EJB's etc.","(""Servlets"", ""Servlets and Struts are related as Struts is a framework that uses Servlets to handle HTTP requests"", ""Struts""); (""Struts"", ""Struts and EJB are related as Struts can be used with EJB to provide a web interface for EJB-based applications"", ""EJB""); (""Servlets"", ""Servlets and EJB are related as Servlets can be used to access EJBs, providing a web interface for EJB-based applications"", ""EJB""); (""Swing"", ""Swing and Servlets are related as custom Swing components can be used in Servlets-based web applications to provide a user interface"", ""Servlets""); (""Struts"", ""Struts and Swing are related as Struts can be used with Swing to provide a web interface for desktop applications"", ""Swing"")"
Each of these boundary classes need a larger framework or server running in order to test them.,"(""Boundary Classes"", ""Boundary classes need a larger framework to test them, indicating a dependency relationship between the two entities."", ""Framework"")"
"A way to get around that is to move the business logic out of the boundary class, and into it's own component.","(""Boundary Class"", ""The Boundary Class contains the Business Logic, which is being moved out of it."", ""Business Logic""); (""Business Logic"", ""The Business Logic is being moved into its own Component, indicating a relationship between the two."", ""Component"")"
Make sure that the business logic component does not know anything about the boundary classes.,NULL
"For instance, if your boundary class is a servlet, your business logic class should not know anything about the HttpRequest or HttpResponse interfaces.","(""Boundary Class"", ""The boundary class is compared to a servlet, indicating a relationship between the two classes."", ""Servlet""); (""Business Logic Class"", ""The business logic class is related to the boundary class, as the boundary class is used to interact with the business logic class."", ""Boundary Class""); (""Business Logic Class"", ""The business logic class should not know anything about the HttpRequest interface, indicating a relationship between the two."", ""HttpRequest""); (""Business Logic Class"", ""The business logic class should not know anything about the HttpResponse interface, indicating a relationship between the two."", ""HttpResponse""); (""Boundary Class"", ""The boundary class, which is compared to a servlet, is related to the HttpRequest interface, as a servlet typically handles HttpRequest objects."", ""HttpRequest"")"
"Preferably, the business logic class only takes the parameters it needs, as the types it needs.","(""Business Logic Class"", ""The business logic class takes the parameters it needs, indicating a relationship between the two."", ""Parameters""); (""Business Logic Class"", ""The business logic class also requires certain types, indicating a relationship between the class and the types."", ""Types"")"
"When your business logic class is separated from the boundary class, you can test the business logic class separately.",NULL
"When the boundary classes are minimized to dispatch logic, the risk of errors in them are a lot smaller, in case you choose not to unit test them.","(""Boundary Classes"", ""Boundary classes are related to errors because minimizing them reduces the risk of errors"", ""Errors""); (""Boundary Classes"", ""Boundary classes are related to logic because they are minimized to dispatch logic"", ""Logic""); (""Boundary Classes"", ""Boundary classes are related to errors because minimizing them reduces the risk of errors"", ""Errors""); (""Boundary Classes"", ""Boundary classes are related to logic because they are minimized to dispatch logic"", ""Logic"")"
"For an example of this, see the Servlet Unit Testing text, in which I show how to unit test the business logic of a servlet, by moving the business logic to a separate class.","(""Servlet"", ""The Servlet and business logic are related because the business logic is being moved out of the Servlet, indicating that they are connected in terms of functionality."", ""business logic""); (""Servlet Unit Testing"", ""The Servlet Unit Testing and Servlet are related because the Servlet Unit Testing is being used as an example to demonstrate how to unit test the business logic of a servlet."", ""Servlet""); (""Servlet"", ""The Servlet and business logic are related because the business logic is being moved out of the Servlet, indicating that they are connected in terms of functionality."", ""business logic""); (""Servlet Unit Testing"", ""The Servlet Unit Testing and Servlet are related because the Servlet Unit Testing is being used as an example to demonstrate how to unit test the business logic of a servlet."", ""Servlet"")"
In this text I will give a few suggestions to how you can test such classes.,NULL
Let's look at how to write a unit test for this class.,NULL
The ByteArrayInputStream is then used as input into the MyIOUnitTest.read() method.,"(""ByteArrayInputStream"", ""The ByteArrayInputStream is used as input into the MyIOUnitTest.read() method, indicating a relationship between the ByteArrayInputStream class and the MyIOUnitTest class"", ""MyIOUnitTest""); (""MyIOUnitTest"", ""The MyIOUnitTest class contains the read method, indicating a relationship between the MyIOUnitTest class and the read method"", ""read"")"
Here is the unit test which uses a ByteArrayOutputStream to collect the data written to the OutputStream passed to the MyIOUnit.write() method:,"(""MyIOUnit"", ""MyIOUnit is a class that has a method named write, so they are clearly related as the method belongs to the class"", ""write""); (""OutputStream"", ""OutputStream is a parent class of ByteArrayOutputStream, so they are clearly related as ByteArrayOutputStream is a subclass of OutputStream"", ""ByteArrayOutputStream""); (""MyIOUnit"", ""MyIOUnit has a method write that takes an OutputStream as a parameter, so they are clearly related as the method uses the OutputStream"", ""OutputStream""); (""write"", ""The write method uses an OutputStream as a parameter, so they are clearly related as the method operates on the OutputStream"", ""OutputStream""); (""MyIOUnit"", ""MyIOUnit has a method write that can use a ByteArrayOutputStream as the OutputStream parameter, so they are clearly related as the class can work with the ByteArrayOutputStream"", ""ByteArrayOutputStream"")"
"Notice how the output.toByteArray() method is called, and passed into a String.","(""Output"", ""The Output class has a method called ToByteArray, indicating a clear relationship between the two entities."", ""ToByteArray""); (""ToByteArray"", ""The ToByteArray method is passed into a String, indicating that the ToByteArray method is related to the String class."", ""String"")"
"If your input or output component uses a Reader or Writer instead of an InputStream or OutputStream, you can use the classes CharArrayReader and CharArrayWriter instead of ByteArrayInputStream and ByteArrayOutputStream.","(""CharArrayReader"", ""CharArrayReader is a type of Reader"", ""Reader""); (""CharArrayWriter"", ""CharArrayWriter is a type of Writer"", ""Writer""); (""ByteArrayInputStream"", ""ByteArrayInputStream is a type of InputStream"", ""InputStream""); (""ByteArrayOutputStream"", ""ByteArrayOutputStream is a type of OutputStream"", ""OutputStream""); (""CharArrayReader"", ""Both CharArrayReader and CharArrayWriter are used as alternatives to ByteArrayInputStream and ByteArrayOutputStream when using Reader or Writer"", ""CharArrayWriter""); (""ByteArrayInputStream"", ""Both ByteArrayInputStream and ByteArrayOutputStream are used for input and output operations, and have alternatives in CharArrayReader and CharArrayWriter"", ""ByteArrayOutputStream""); (""Reader"", ""Reader and Writer are related as they are both used for input and output operations, with Reader being used for input and Writer being used for output"", ""Writer"")"
You may also be able to use the StringReader and StringWriter classes in your unit tests.,NULL
"Unit testing means testing the smaller units of your application, like classes and methods.","(""Unit"", ""Unit is a part of Testing as it is a smaller unit being tested"", ""Testing""); (""Testing"", ""Testing is a method used on an Application"", ""Application"")"
"JUnit 4.8.2 ships with Hamcrest internally, so you don't have to download it, and add it yourself.","(""JUnit"", ""JUnit ships with Hamcrest internally, indicating a dependency relationship between the two entities"")
#################################
(Note: Since the text does not explicitly mention any methods, no method entities are identified. Also, JUnit is considered as a class in this context, although in a real-world scenario, it could be a package or a framework."", ""Hamcrest"")"
"Matchers are used with the org.junit.Assert.assertThat() method, which looks like this:","(""Matchers"", ""Matchers are used with the assertThat() method"", ""assertThat()""); (""org.junit.Assert"", ""The assertThat() method is part of the org.junit.Assert package"", ""assertThat()"")"
"The assertThat() method just takes care of the ""plumming"" - meaning calling the Matcher with the given object.",NULL
"In the example above, the org.hamcrest.CoreMatchers.is() method is used to create a Matcher.","(""Org ハンケット CoreMatchers"", ""The Is method is part of the Org ハンケット CoreMatchers class"", ""Is"")"
"The Matcher returned by is() returns true, if the two values compared are equal, and false if not.",NULL
"The is() method returns one matcher, and the not() method returns another.",NULL
The matcher returned by not() negates the matcher output of the matcher given as input.,"(""Matcher"", ""The Matcher class has a method Not, indicating a relationship between the two entities, with Not being a method of the Matcher class."", ""Not""); (""Not"", ""The Not method returns the negation of the matcher output, showing a clear relationship between the Not method and the Output class, as the output is being negated."", ""Output"")"
"In this case, it is the output of the matcher returned by the is() method, that is negated.","(""Matcher"", ""The Matcher class has a method called Is, indicating a relationship between the two entities."", ""Is""); (""Is"", ""The Is method returns an output, which is then negated, showing a relationship between the Is method and the Output entity."", ""Output"")"
You can write your own matchers and plug into the assertThat() method.,NULL
The static method matches() creates a new matcher and returns it.,NULL
You just embed the call to the static method matches() inside the assertThat() method.,NULL
In several situations mock testing is easier than testing with the real collaborators of a class.,"(""Mock"", ""Mock is related to Class because mock testing is easier than testing with the real collaborators of a class, implying that mock and class are connected through the testing process."", ""Class"")"
When testing a DAO you may use a mock java.sql.Connection and java.sql.ResultSet object with the DAO to check that the DAO makes the correct JDBC calls.,"(""DAO"", ""The DAO is related to java.sql.Connection because the DAO makes JDBC calls using a java.sql.Connection object."", ""java.sql.Connection""); (""DAO"", ""The DAO is related to java.sql.ResultSet because the DAO makes JDBC calls that return a java.sql.ResultSet object."", ""java.sql.ResultSet""); (""DAO"", ""The DAO is related to JDBC because the DAO makes JDBC calls."", ""JDBC""); (""java.sql.Connection"", ""java.sql.Connection is related to JDBC because it is used to make JDBC calls."", ""JDBC"")"
It is not visible from the value returned by the DAO if it remembered to call ResultSet.close() and Connection.close() before returning.,"(""DAO"", ""The DAO uses ResultSet, as indicated by the fact that it needs to call ResultSet.close()."", ""ResultSet""); (""DAO"", ""The DAO uses Connection, as indicated by the fact that it needs to call Connection.close()."", ""Connection"")"
The above situation was exactly the case for the GenericDao class in Mr. Persister.,NULL
Ideally the JDBC driver would detect that when calling the PreparedStatement.executeUpdate() method.,"(""JDBC"", ""JDBC is related to PreparedStatement because the JDBC driver is likely to interact with the PreparedStatement class"", ""PreparedStatement""); (""PreparedStatement"", ""PreparedStatement is related to executeUpdate because the executeUpdate method is called on an instance of the PreparedStatement class"", ""executeUpdate"")"
Therefore we decided to compare the PreparedStatement.getParameterMetaData().getParameterCount() with parameters.length before calling PreparedStatement.executeUpdate().,"(""PreparedStatement"", ""PreparedStatement is related to getParameterMetaData because getParameterMetaData is a method called on the PreparedStatement object."", ""getParameterMetaData""); (""getParameterMetaData"", ""getParameterMetaData is related to getParameterCount because getParameterCount is a method called on the object returned by getParameterMetaData."", ""getParameterCount""); (""PreparedStatement"", ""PreparedStatement is related to executeUpdate because executeUpdate is a method called on the PreparedStatement object."", ""executeUpdate"")"
"This works with the HSQLDB driver, but the MySQL driver haven't implemented the PreparedStatement.getParameterMetaData() method.","(""HSQLDB"", ""HSQLDB is related to PreparedStatement because it is mentioned as working with the HSQLDB driver in the context of using the PreparedStatement."", ""PreparedStatement""); (""MySQL"", ""MySQL is related to PreparedStatement because it is mentioned as having a driver that hasn't implemented the PreparedStatement.getParameterMetaData() method."", ""PreparedStatement"")"
Fortunately the MySQL driver does throw an exception if the ?-signs and the parameters set doesn't match when calling PreparedStatement.executeUpdate().,"(""PreparedStatement"", ""PreparedStatement has a method called executeUpdate"", ""executeUpdate"")"
"In the classpath element I add the output locations of my project code, and test code.","(""Classpath"", ""The classpath is related to the project because it includes the output locations of the project code."", ""Project""); (""Classpath"", ""The classpath is related to the code because it includes the output locations of the project code and test code."", ""Code"")"
In the test element I declare which unit test class to execute.,NULL
The classpath stuff is the same as in the first example.,NULL
"In this example I execute all files that has the text ""Test"" and "".java"" in their file name, regardless of what directory they are located in, recursively.","(""Example"", ""The Example is related to File because it executes files"", ""File""); (""File"", ""The File is related to Directory because files are located in directories"", ""Directory""); (""Example"", ""The Example is related to Directory because it searches for files recursively in directories"", ""Directory"")"
"What I usually do instead, is to ""move the code out of the boundary class"", as I have described in the text Design for Testability.",NULL
"Basically, I would try to push the main business logic in the servlet into a separate class which has no dependencies on the Servlet API's, if possible.","(""Main Business Logic"", ""The main business logic is currently in the servlet, indicating a relationship between the two."", ""Servlet""); (""Servlet"", ""The servlet has dependencies on the Servlet API, indicating a relationship between the two."", ""Servlet API"")"
"So, I will take the concatenation logic and move into a separate class, which can be tested independent from the MyServlet class.",NULL
Notice how the concatenation logic has been moved to a class called MyConcatenator.,NULL
Notice how the concatenate() method only refers to a string array.,NULL
Notice again how it was not necessary to reference any servlet classes or interfaces in this unit test.,NULL
By real objects I mean the objects the tested unit (class) will be using in the real application.,"(""Class"", ""The class is related to the unit because the unit is being tested and the class is the type of object the unit will be using in the real application."", ""Unit"")"
"If you have a class Calculator, that needs a dao (Data Access Object) object to load the data it needs from a database, then the dao object is a ""real object"".",NULL
In order to test the Calculator class you will have to provide it with a dao object that has a valid connection to the database.,"(""Calculator"", ""The Calculator class requires a dao object to function, indicating a relationship between the two."", ""dao""); (""dao"", ""The dao object needs a valid connection to the database, showing a relationship between the dao and the database."", ""database"")"
Instead you can provide the Calculator instance with a fake dao class which just returns the data you need for the test.,NULL
The fake dao class will not actually read the data from the database.,NULL
A replacement for a real object which makes it easier to test the Calculator class.,NULL
Nor can you see if the connection.close() method was called before returning the value.,NULL
"If you add a String ""myReturnValue"" as return value to the stub and then call connection.prepareStatement(""select * from houses"") which returns a PreparedStatement, you will get an exception.","(""connection"", ""The connection object has a prepareStatement method, indicating a clear relationship between the two."", ""prepareStatement""); (""prepareStatement"", ""The prepareStatement method returns a PreparedStatement object, establishing a relationship between the method and the class it returns."", ""PreparedStatement""); (""String"", ""Adding a String as a return value can lead to an exception being thrown, showing a relationship between the input (String) and the resulting exception."", ""Exception""); (""connection"", ""The connection object, when used to call prepareStatement with certain parameters (like a String return value), results in an exception, relating the connection to the exception thrown."", ""Exception"")"
"The String return value cannot be returned from the connection.prepareStatement(""...""); You will have to make sure yourself that the return values and called methods on the stub match.","(""connection"", ""The connection class has a method called prepareStatement, which establishes a relationship between the two entities."", ""prepareStatement"")"
If the connection.close() method has not been called a java.lang.AssertionError is thrown.,"(""Connection"", ""The Connection class has a Close method, indicating a relationship between the two."", ""Close""); (""Connection"", ""If the Connection close method is not called, a Java.Lang.AssertionError is thrown, indicating a relationship between the Connection class and the Java.Lang.AssertionError class."", ""Java.Lang.AssertionError"")"
You just provide the real collaborator to the MockFactory instead of an interface (class object).,NULL
You can even turn the proxyConnection into a stub temporarily by adding a return value to the proxy via the mock.addReturnValue(...).,"(""ProxyConnection"", ""The ProxyConnection is related to Mock because Mock is used to add a return value to the ProxyConnection via the addReturnValue method."", ""Mock"")"
"Subclass mock objects is a mock object that is created by subclassing the class you want to test, and overriding some of its methods.","(""Subclass Mock Objects"", ""Subclass mock objects is a mock object that is created by subclassing the class you want to test, which shows that Subclass Mock Objects and Class are related as Subclass Mock Objects is a subclass of Class"", ""Class""); (""Subclass Mock Objects"", ""Subclass mock objects are created by overriding some of the methods of the class, which shows that Subclass Mock Objects and Methods are related as Subclass Mock Objects override Methods"", ""Methods"")"
The class MyUnit is the class I am trying to unit test.,NULL
"In this unit test, I want to check if the MyUnit class calls the MyDependency class correctly.",NULL
"The first thing to do is to refactory the MyUnit class, so that all calls to the MyDependency class are encapsulated in their own methods.",NULL
"Notice how the two calls to MyDependency.callOne() and MyDependency.callTwo() are now encapsulated in two protected methods, callOne() and callTwo().","(""MyDependency"", ""MyDependency and callOne are related because callOne is a method that is part of the MyDependency class."", ""callOne"")"
The second step is to create a subclass mock of the MyUnit class.,NULL
Here is a unit test method that uses the MyUnitMock class:,NULL
"Third, assertions are made about whether the callOne() and callTwo() method were invoked.",NULL
"As you can see, it is possible to test almost all of a class by using subclass mocks, as described above.","(""Class"", ""The source entity Class and the target entity subclass are related because a subclass is a type of class, and the text describes using subclass mocks to test a class."", ""subclass"")"
"There are, however, situations where it works better to use a completely separate mock dependency object with the original class instead.",NULL
"If the throwIllegalArgumentException() method returns normall, then this fail() call is executed, causing the test to fail.",NULL
"Correspondingly, if the throwIllegalArgumentException() method throws the expected IllegalArgumentException, it is caught in the catch-clause, and ignored.",NULL
"Instead you want users trying to access your web app to see a nice ""This web app is down for maintenance..."" page.","(""Users"", ""Users are trying to access the Web App"", ""Web App""); (""Web App"", ""The Web App displays a Page to the users"", ""Page"")"
"A ""This web app is down for maintenance..."" page lets them know that the down time is controlled and expected.",NULL
Here is how the web.xml configuration looks for such a setup:,NULL
"For instance, imagine that a user sends a request that takes 1 minute to process (e.g.",NULL
"I've posted the full solution including the servlet filter Java code, the web.xml configuration, the maintenance message page and the maintenance GUI page, for your convenience below.","(""Servlet Filter"", ""The Servlet Filter is written in Java, indicating a relationship between the two."", ""Java""); (""Servlet Filter"", ""The Servlet Filter is configured in the web.xml file, indicating a relationship between the two."", ""Web.xml""); (""Maintenance Message Page"", ""The Maintenance Message Page and Maintenance GUI Page are related as they are both part of the maintenance functionality."", ""Maintenance GUI Page""); (""Java"", ""The Maintenance Message Page is likely built using Java, indicating a relationship between the two."", ""Maintenance Message Page""); (""Java"", ""The Maintenance GUI Page is likely built using Java, indicating a relationship between the two."", ""Maintenance GUI Page""); (""Web.xml"", ""The Maintenance Message Page is configured in the web.xml file, indicating a relationship between the two."", ""Maintenance Message Page"")"
"Apparently the field name ""comment"" caused the text (""Comment..."") in the textarea not to show up in Firefox... weird, right...?!","(""FIELD NAME"", ""The field name is related to the textarea because the field name 'comment' caused the text in the textarea not to show up."", ""TEXTAREA""); (""TEXTAREA"", ""The textarea is related to Firefox because the text in the textarea did not show up in Firefox."", ""FIREFOX"")"
"In order to get a Java web server or servlet container to run your Java web application, you need to package the resources inside it (servlets, JSP's etc.)","(""Java Web Application"", ""The Java web application needs to be run on a web server or servlet container, indicating a relationship between the two."", ""Web Server""); (""Java Web Application"", ""The Java web application contains servlets, indicating a relationship between the two."", ""Servlet""); (""Java Web Application"", ""The Java web application contains JSP's, indicating a relationship between the two."", ""JSP""); (""Web Server"", ""The web server or servlet container runs the servlets, indicating a relationship between the two."", ""Servlet"")"
... then the index.jsp page will be accessible at the URL,NULL
"For instance, if you create a subdirectory called layout, and put a file inside it called theLayout.jsp, then you could access that file from the outside, via this URL:","(""Layout"", ""Layout is related to TheLayout because TheLayout seems to be an instance or a subclass of Layout"", ""TheLayout""); (""TheLayout"", ""TheLayout is related to Jsp because TheLayout.jsp seems to be a Jsp file that belongs to or is related to TheLayout"", ""Jsp"")"
"Inside the WEB-INF directory there are two important directories (classes and lib, and one important file (web.xml).","(""WEB-INF"", ""WEB-INF directory contains the classes directory"", ""classes""); (""WEB-INF"", ""WEB-INF directory contains the lib directory"", ""lib"")"
"The web.xml file contains information about the web application, which is used by the Java web server / servlet container in order to properly deploy and execute the web application.","(""Web.Xml"", ""The web.xml file contains information about the web application, indicating a relationship between the two as the file provides necessary information for the application."", ""Web Application""); (""Java Web Server"", ""The Java web server is related to the web application as it is responsible for deploying and executing the application."", ""Web Application""); (""Servlet Container"", ""The servlet container is related to the web application as it is used in conjunction with the Java web server to properly deploy and execute the web application."", ""Web Application"")"
"For instance, the web.xml contains information about which servlets a web application should deploy, and what URL's they should be mapped to.","(""Web.Xml"", ""The web.xml contains information about which servlets a web application should deploy, indicating a relationship between web.xml and servlets."", ""Servlets""); (""Web.Application"", ""The text mentions that a web application should deploy servlets, indicating a relationship between web application and servlets."", ""Servlets"")"
I will not get into more detail about the web.xml file here.,"(""Web"", ""Web and Xml are related as they are parts of the web.xml file mentioned in the text"", ""Xml""); (""Web.Xml"", ""Web.Xml is related to Web as it is a part of the web.xml file"", ""Web"")"
The classes directory contains all compiled Java classes that are part of your web application.,"(""Classes"", ""The classes are contained within the directory, indicating a relationship between the two entities."", ""Directory""); (""Java"", ""Java is related to classes because the text mentions 'Java classes', indicating that Java is the programming language used for the classes."", ""Classes"")"
"The classes should be located in a directory structure matching their package structure, just like if you were to run them directly from the commandline, or package them in a JAR file.","(""Classes"", ""The classes are located in a directory structure matching their package structure"", ""Package""); (""Package"", ""The classes can be packaged in a JAR file, indicating a relationship between the package and the JAR file"", ""Jar"")"
"You could, however, also put your own classes into a JAR file, and locate it here, rather than putting those classes in the classes directory.","(""JAR"", ""The JAR file and the classes are related because they are both containers for classes, and the text implies that the JAR file could be used as an alternative to the classes directory."", ""classes""); (""classes"", ""The classes and the classes directory are related because the classes directory is a location where classes are stored."", ""classes directory"")"
Perl or C. A Servlet is an ordinary Java class that implements a special Servlet interface.,"(""Servlet"", ""Servlet is an ordinary Java class"", ""Java"")"
"Here is a small servlet and JSP example to better illustrate the difference: public void service(ServletRequest request, ServletResponse response){ PrintWriter writer = ((HttpServletResponse) response)).getWriter(); writer.write(""<html>""); writer.write(""<body>""); writer.write(""<table>""); for(int i=0; i<10; i++){ writer.write(""<tr><td>""); writer.write("""" + i); writer.write(""</td></tr>""); } writer.write(""</table>""); writer.write(""</body>""); writer.write(""</html>""); } <html> <body> <table> <% for(int i=0; i<10; i++){ %><tr><td><%=i%></td></tr><% } %> </table> </body> </html> As you can see, the JSP example is much shorter than the Servlet example, and it is much easier to get an overview of the HTML.","(""ServletRequest"", ""Both are used as parameters in the service method, indicating a relationship between the request and response objects"", ""ServletResponse""); (""ServletResponse"", ""HttpServletResponse is a subclass of HttpServletResponse, indicating an inheritance relationship"", ""HttpServletResponse""); (""service"", ""The service method takes a ServletRequest object as a parameter, indicating that the service method operates on the ServletRequest object"", ""ServletRequest""); (""service"", ""The service method takes a ServletResponse object as a parameter, indicating that the service method operates on the ServletResponse object"", ""ServletResponse""); (""getWriter"", ""The getWriter method returns a PrintWriter object, indicating a relationship between the HttpServletResponse and PrintWriter objects"", ""PrintWriter"")"
This is illustrated below: component.control --> component.control --> component.control --> component.control --> component.control component.view --> component.view --> component.view --> component.view --> component.view First all components in the hierarchy executes their control logic (domain logic).,NULL
A Servlet is an ordinary Java class that implements a special Servlet interface.,NULL
JCTools is an open source toolkit and is released under the Apache License 2.0.,NULL
"A Fat JAR is a single JAR file that contains all the compiled Java classes from your project, and all compiled Java classes from all JAR files your project depends on (see Maven Dependencies).","(""Fat Jar"", ""A Fat JAR contains all the compiled Java classes from your project"", ""Java""); (""Fat Jar"", ""A Fat JAR is a single JAR file that contains all the compiled Java classes"", ""JAR""); (""Fat Jar"", ""A Fat JAR contains all compiled Java classes from all JAR files your project depends on, which are described in Maven Dependencies"", ""Maven Dependencies""); (""Java"", ""Java classes are compiled into JAR files"", ""JAR"")"
"Fat JARs are handy when you need to build an executable JAR file, e.g.","(""Fat JARs"", ""Fat JARs are a type of JAR, indicating a relationship between the two entities as one being a subset of the other."", ""JAR""); (""Fat JARs"", ""The entity Fat JARs is related to the build method as Fat JARs are used when you need to build an executable JAR file."", ""build""); (""JAR"", ""The entity JAR is related to the build method as a JAR file is the result of the build process."", ""build""); (""executable JAR file"", ""The entity executable JAR file is related to the build method as an executable JAR file is the product of the build process."", ""build""); (""Fat JARs"", ""Fat JARs are used to create an executable JAR file, thus establishing a relationship between the two entities."", ""executable JAR file"")"
"This makes execution much easier, because you don't have to list all the JAR files your microservice depends on, on the classpath.","(""JAR"", ""The JAR and microservice are related because the microservice depends on the JAR files."", ""microservice""); (""microservice"", ""The microservice and classpath are related because the classpath is used to list the JAR files the microservice depends on."", ""classpath"")"
"When you execute Maven package phase with the maven-assembly-plugin configuration shown earlier, Maven will output a Fat JAR in the target directory, into which Maven outputs all of its other build products (e.g.","(""Maven"", ""Maven uses maven-assembly-plugin for configuration"", ""maven-assembly-plugin""); (""Maven"", ""Maven outputs a Fat JAR"", ""Fat JAR""); (""Maven"", ""Maven outputs its build products into the target directory"", ""target""); (""maven-assembly-plugin"", ""maven-assembly-plugin helps to create a Fat JAR"", ""Fat JAR"")"
"The list contains more than 1.300 Maven archetypes, so it is not really that easy to find the archetype you need.","(""Maven"", ""Maven is related to Archetype because Archetype is a part of the Maven ecosystem and is used to generate projects."", ""Archetype""); (""List"", ""List is related to Maven because the list contains Maven archetypes."", ""Maven"")"
"Too look at the list of available Maven archetypes, you can pipe the output into a file, and open that file in e.g.",NULL
"Keep in mind, that when you execute the clean goal of Maven, the target directory is removed, meaning you lose all compiled classes from previous builds.","(""Maven"", ""Maven has a method called clean"", ""clean""); (""clean"", ""The clean method affects the target directory"", ""target"")"
"That means, that Maven will have to build all of your project again from scratch, rather than being able to just compile the classes that were changed since last build.","(""Maven"", ""Maven is related to Project because it is used to build the project."", ""Project""); (""Maven"", ""Maven is related to Build because it performs the build operation."", ""Build"")"
"However, sometimes it can be nice to have a clean, fresh build, e.g.",NULL
The pom.xml file is the Maven POM file (Project Object Model).,"(""Maven"", ""Maven is related to Pom.xml because Pom.xml is the Maven POM file"", ""Pom.xml""); (""Maven"", ""Maven is related to Project Object Model because Project Object Model is a part of the Maven project structure"", ""Project Object Model"")"
The .mvn directory is a directory where you can put some Maven configuration files.,NULL
One of these Maven configuration files is the jvm.config file which can be used to configure the Java VM that is used by Maven to build your project.,"(""Maven"", ""Maven uses Java VM to build the project"", ""Java VM""); (""Maven"", ""Maven configuration uses the jvm.config file"", ""jvm.config"")"
The resource files will be available for loading via the classpath.,NULL
The default Java compiler version used by Maven is Java 1.5 .,"(""Maven"", ""Maven uses Java 1.5 as its default compiler version"", ""Java 1.5""); (""Java"", ""Java 1.5 is a version of the Java class"", ""Java 1.5"")"
"To make Maven compile your Java code with a newer version of the Java compiler, you need to specify the Java compiler explicitly in your project's POM file (pom.xml).","(""Maven"", ""Maven is related to Java because it is used to compile Java code"", ""Java""); (""Maven"", ""Maven is related to POM because POM files are used to configure Maven projects"", ""POM""); (""Maven"", ""Maven is related to the Java compiler because it needs to specify the Java compiler explicitly to compile Java code"", ""Java compiler""); (""Java"", ""Java is related to the Java compiler because the Java compiler is used to compile Java code"", ""Java compiler""); (""POM"", ""POM is related to pom.xml because pom.xml is the file extension for POM files"", ""pom.xml""); (""Maven"", ""Maven is related to pom.xml because Maven uses pom.xml files to configure projects"", ""pom.xml""); (""Java"", ""Java is related to pom.xml because Java code is compiled using the configuration specified in pom.xml files"", ""pom.xml"")"
Notice also that the version of the Maven Java compiler plugin has changed from 3.6.1 to 3.8.0 .,"(""Maven Java Compiler Plugin"", ""The Maven Java Compiler Plugin has a version 3.6.1"", ""3.6.1"")"
The first version of this Maven tutorial is based on Maven 3.6.3.,NULL
The POM file is named pom.xml and should be located in the root directory of your project.,"(""POM"", ""The POM file is named pom.xml, indicating a relationship between the POM entity and the pom.xml entity."", ""pom.xml""); (""pom.xml"", ""The pom.xml file should be located in the root directory, indicating a relationship between the pom.xml entity and the root directory entity."", ""root directory"")"
"This command first executes the clean build life cycle, which removes compiled classes from the Maven output directory, and then it executes the install build phase.","(""Maven"", ""Maven is related to Clean because it executes the clean build life cycle"", ""Clean""); (""Maven"", ""Maven is related to Install because it executes the install build phase"", ""Install""); (""Maven"", ""Maven is related to Build because it is part of the build life cycle"", ""Build""); (""Clean"", ""Clean is related to Build because clean is a part of the build life cycle"", ""Build"")"
These JAR files are needed on the classpath when you compile your project code.,"(""Classpath"", ""The Classpath and JAR are related because JAR files are needed on the classpath."", ""JAR""); (""JAR"", ""The JAR and Project are related because JAR files are needed when you compile your project code."", ""Project"")"
"The example above needs the org.jsoup group's jsoup artifact in version 1.7.1, and the junit group's junit artifact in version 4.8.1.","(""Org.Jsoup"", ""Org.Jsoup is a package that contains the class Jsoup"", ""Jsoup"")"
"Thus Maven only needs to download the dependencies once, even if multiple projects depends on them (e.g.","(""Maven"", ""Maven manages dependencies, so they are related as Maven is the tool that handles the dependencies."", ""dependencies""); (""Maven"", ""Maven is a build tool for projects, so they are related as projects use Maven."", ""projects"")"
Your Maven settings file is also located in your user-home/.m2 directory and is called settings.xml.,"(""Maven"", ""Maven uses settings.xml for configuration"", ""settings.xml""); (""Maven"", ""Maven settings file is located in the user-home/.m2 directory"", ""user-home/.m2"")"
"The clean life cycle handles everything related to removing temporary files from the output directory, including generated source files, compiled classes, previous JAR files etc.","(""Clean Life Cycle"", ""The clean life cycle handles everything related to removing temporary files from the output directory, indicating a relationship between the clean life cycle and the output directory."", ""Output Directory""); (""Clean Life Cycle"", ""The clean life cycle handles removal of temporary files, indicating a relationship between the clean life cycle and temporary files."", ""Temporary Files""); (""Clean Life Cycle"", ""The clean life cycle handles removal of generated source files, indicating a relationship between the clean life cycle and generated source files."", ""Generated Source Files""); (""Clean Life Cycle"", ""The clean life cycle handles removal of compiled classes, indicating a relationship between the clean life cycle and compiled classes."", ""Compiled Classes"")"
One way to choose what profile is being executed is in the settings.xml file.,"(""Settings.Xml"", ""Settings.Xml is a part of the settings file, indicating a containing relationship between the two entities"", ""Settings"")"
"You do so by creating a simple Java class that extends a special Maven class, and then create a POM for the project.","(""Java"", ""The Java class extends a special Maven class, indicating a clear inheritance relationship between the two."", ""Maven""); (""Java"", ""The Java class and the POM are related as they are both part of the project setup, with the POM being a project management file and the Java class being part of the project's codebase."", ""POM"")"
It is the argument -Dmaven.test.skip=true that makes Maven skip the tests completely.,"(""Maven"", ""Maven uses the argument -Dmaven.test.skip=true to skip tests, indicating a relationship between the Maven entity and the -Dmaven.test.skip=true entity"", ""-Dmaven.test.skip=true"")"
To configure the Maven Surefire plugin to enable Java preview features you need the following configuration in your Maven POM file - in the <build><plugins>...</plugins></build> section:,"(""Maven"", ""Maven Surefire is a plugin for Maven, indicating a relationship between the two"", ""Maven Surefire""); (""Maven Surefire"", ""The Maven Surefire plugin is used to enable Java preview features, indicating a relationship between the plugin and Java"", ""Java""); (""Maven"", ""The Maven POM file is a configuration file for Maven, indicating a relationship between Maven and POM"", ""POM""); (""Maven"", ""The Maven POM file is a configuration file for Maven, indicating a relationship between Maven and Maven POM"", ""Maven POM"")"
To publish a JAR file with compiled Java classes to the Maven central repository you need to go through set of steps.,"(""JAR"", ""JAR file contains compiled Java classes"", ""Java""); (""JAR"", ""JAR file is published to the Maven central repository"", ""Maven"")"
You can find more information about creating and publishing a public key / priate key pair from the Sonatype producers page: https://central.sonatype.org/pages/producers.html.,"(""Sonatype"", ""Sonatype is related to public key because it provides information on creating and publishing a public key / private key pair."", ""public key""); (""Sonatype"", ""Sonatype is related to private key because it provides information on creating and publishing a public key / private key pair."", ""priate key""); (""Sonatype"", ""Sonatype is related to the provided URL because the URL is a page from the Sonatype website."", ""https://central.sonatype.org/pages/producers.html""); (""public key"", ""public key and private key are related because they are both part of a key pair."", ""priate key""); (""create"", ""create is related to public key because creating is an action that can be performed on a public key."", ""public key""); (""publish"", ""publish is related to public key because publishing is an action that can be performed on a public key."", ""public key""); (""create"", ""create is related to private key because creating is an action that can be performed on a private key."", ""priate key""); (""publish"", ""publish is related to private key because publishing is not typically performed on a private key, however, the text does mention publishing a public key / private key pair, so there is a relationship."", ""priate key""); (""create"", ""create is related to Sonatype because Sonatype provides information on creating a public key / private key pair."", ""Sonatype""); (""publish"", ""publish is related to Sonatype because Sonatype provides information on publishing a public key / private key pair."", ""Sonatype""); (""https://central.sonatype.org/pages/producers.html"", ""The provided URL is related to create because the URL contains information on creating a public key / private key pair."", ""create""); (""https://central.sonatype.org/pages/producers.html"", ""The provided URL is related to publish because the URL contains information on publishing a public key / private key pair."", ""publish""); (""https://central.sonatype.org/pages/producers.html"", ""The provided URL is related to public key because the URL contains information on a public key / private key pair."", ""public key"")"
"For a full POM file, check out the pom.xml in this github repository: RION Ops for Java GitHub Repository","(""RION Ops"", ""RION Ops is related to pom.xml because pom.xml is mentioned in the context of the RION Ops GitHub repository"", ""pom.xml""); (""RION Ops"", ""RION Ops is related to GitHub Repository because RION Ops is a part of the GitHub Repository"", ""GitHub Repository""); (""RION Ops"", ""RION Ops is related to Java because RION Ops is for Java"", ""Java""); (""pom.xml"", ""pom.xml is related to POM because pom.xml is a type of POM file"", ""POM""); (""Java"", ""Java is related to GitHub Repository because the GitHub Repository is for Java"", ""GitHub Repository"")"
From Maven 3.3 and forward you can set the memory limits in a file called jvm.config located in the .mvn directory inside your project directory.,NULL
Inside the jvm.config file you need the following settings to be able to control the memory limits of Maven during a Maven build:,"(""JVM"", ""JVM is related to Maven because Maven is a build tool that runs inside the JVM, and the JVM's settings can affect Maven's performance."", ""MAVEN""); (""JVM"", ""The JVM is related to the jvm.config file because the file contains settings that control the JVM's memory limits."", ""jvm.config"")"
"Once you have created the project root directory, create a file called pom.xml inside the directory.","(""Project"", ""The project is related to the directory because the project root directory is where the pom.xml file is created."", ""Directory""); (""Directory"", ""The directory is related to the file because the file called pom.xml is created inside the directory."", ""File""); (""Project"", ""The project is related to the file because the file pom.xml is part of the project."", ""File""); (""Create"", ""The create method is related to the file because the file is created using this method."", ""File""); (""Create"", ""The create method is related to the directory because the directory is where the file is created."", ""Directory"")"
"When you have created the pom.xml file inside the project root directory it is a good idea to just test that Maven works, and that Maven understands the pom.xml file.","(""Maven"", ""Maven understands the pom.xml file, indicating a relationship between the two."", ""Pom.Xml""); (""Project"", ""The pom.xml file is located inside the project root directory, indicating a relationship between the project and the pom.xml file."", ""Pom.Xml"")"
"To test the pom.xml file, open a command prompt and change directory (cd) into the project root directory.",NULL
Inside the helloworld directory (java package) insert a file named HelloWorld.java.,NULL
Maven will compile the Java source file and create a JAR file containing the compiled Java class.,"(""Maven"", ""Maven is related to Java because it compiles the Java source file"", ""Java""); (""Maven"", ""Maven is related to JAR because it creates a JAR file containing the compiled Java class"", ""JAR"")"
"Inside the target directory you will find the finished JAR file, as well as lots of temporary files (e.g.",NULL
The Mem Ops Bytes class represents a sequence of bytes from a byte array.,NULL
"To avoid fragmenting the Java heap with Bytes instances, the Bytes class is designed to be obtained from an ObjectPool .","(""Bytes"", ""The Bytes class is designed to be obtained from an ObjectPool, indicating a relationship between the two classes."", ""ObjectPool""); (""Bytes"", ""The Bytes class is part of the Java programming language, which suggests that it belongs to the Java package."", ""Java"")"
"To use the Bytes class effectively you should create a BytesAllocatorAutoDefrag, a BytesFactory and an ObjectPool .","(""Bytes"", ""Bytes is related to BytesAllocatorAutoDefrag because BytesAllocatorAutoDefrag seems to be a class used in conjunction with the Bytes class to manage memory allocation efficiently."", ""BytesAllocatorAutoDefrag""); (""Bytes"", ""Bytes is related to BytesFactory because BytesFactory seems to be a class used to create instances of Bytes, suggesting a factory-method relationship."", ""BytesFactory"")"
To obtain a Bytes instance from the ObjectPool you simply call the ObjectPool instance() method.,"(""ObjectPool"", ""The ObjectPool class has an instance method, indicating a relationship between the class and the method."", ""instance""); (""ObjectPool"", ""The ObjectPool class is used to obtain a Bytes instance, indicating a relationship between the two classes."", ""Bytes"")"
Calling free() will free the Bytes instance back to the ObjectPool and the allocated bytes back to the BytesAllocatorAutoDefrag.,"(""Bytes"", ""The Bytes instance is returned to the ObjectPool when free() is called, indicating a relationship between the two entities"", ""ObjectPool""); (""Bytes"", ""The allocated bytes of the Bytes instance are returned to the BytesAllocatorAutoDefrag when free() is called, indicating a relationship between the two entities"", ""BytesAllocatorAutoDefrag""); (""free"", ""The free() method is called on the Bytes instance, indicating a relationship between the method and the class"", ""Bytes""); (""free"", ""The free() method returns the Bytes instance to the ObjectPool, indicating a relationship between the method and the class"", ""ObjectPool"")"
"In this section I will try to give you a few visual use case examples that shows how to use the Bytes class, and its fields.",NULL
"The use cases are actually quite similar in how they use the Bytes class, even if they are doing different things.",NULL
The Mem Ops BytesAllocatorAutoDefrag class is capable of allocating smaller sections (blocks) of a bigger byte array.,NULL
"When you free a byte array section, the BytesAllocatorAutoDefrag class will automatically defragment its internal big byte array so the freed section is joined with adjacent free sections to form a larger free section from which future sections can be allocated.",NULL
To use the BytesAllocatorAutoDefrag class you must first create an instance of it.,NULL
"In order to allocate a block (section) of bytes from the underlying byte array, you call the allocate() method.",NULL
"Once allocated, no other allocate() call can allocate the same block until it has been freed.","(""Allocate"", ""The allocate method is related to the block class because it is used to allocate a block."", ""Block""); (""Free"", ""The free method is related to the block class because it is used to free a block."", ""Block"")"
"The allocate() method returns the offset into the big, underlying byte array where the allocated block starts.",NULL
You can get a reference to the underlying byte array via the getData() method.,NULL
"Once you have allocated a block of bytes from the BytesAllocatorAutoDefrag you can access it via the data array, from the offset returned by allocate() and until offset + length - 1.","(""BytesAllocatorAutoDefrag"", ""BytesAllocatorAutoDefrag has a method called allocate, which returns an offset."", ""allocate""); (""BytesAllocatorAutoDefrag"", ""BytesAllocatorAutoDefrag provides access to a data array, after a block of bytes has been allocated."", ""data"")"
The free() method takes the start and end offset of the block to free.,NULL
The Mem Ops BytesAllocatorManualDefrag class is capable of allocating smaller sections (blocks) of a bigger byte array.,"(""Mem Ops BytesAllocatorManualDefrag"", ""The Mem Ops BytesAllocatorManualDefrag class is capable of allocating smaller sections of a bigger byte array, but since 'byte array' is not in the entity types, we will ignore it."", ""byte array""); (""BytesAllocatorManualDefrag"", ""The BytesAllocatorManualDefrag class is capable of allocating smaller sections of a bigger byte array, but since 'byte array' is not in the entity types, we will ignore it."", ""byte array"")"
"When you free a byte array section, the ByteArrayAllocatorAutoDefrag class will mark it as free, but will not defragment the underlying byte array until you explicitly to tell it to.",NULL
To use the BytesAllocatorManualDefrag class you must first create an instance of it.,NULL
"Once you have allocated a block of bytes from the BytesAllocatorManualDefrag you can access it via the data array, from the offset returned by allocate() and until offset + length - 1.","(""BytesAllocatorManualDefrag"", ""BytesAllocatorManualDefrag contains the method allocate, indicating a relationship between the class and the method."", ""allocate""); (""BytesAllocatorManualDefrag"", ""BytesAllocatorManualDefrag provides access to the data array, showing a relationship between the class and the array."", ""data""); (""allocate"", ""The allocate method returns the offset, establishing a relationship between the method and the variable."", ""offset""); (""allocate"", ""The allocate method is related to the length variable, as the length is used in conjunction with the offset returned by allocate."", ""length""); (""offset"", ""The offset is used to access the data array, indicating a relationship between the variable and the array."", ""data"")"
To defragment the free blocks you call the defragment() method of the BytesAllocatorManualDefrag .,NULL
It is during such idle times you should call defragment() .,NULL
"If your system is constantly very busy, there may never be an idle period during which to call defragment().",NULL
Calling defragment() will most likely result in a longer pause than if you immediately defragment free blocks like the ByteArrayAllocatorAutoDefrag does.,NULL
"Systems that need to create high numbers of objects at a rapid pace, but do not need all of these objects at the same time, can benefit from using object pools rather than instantiating the objects using the Java new XYZObject() .","(""Systems"", ""Systems can benefit from using object pools rather than instantiating the objects using the Java new XYZObject() so Systems and XYZObject are related in the context of object creation"", ""XYZObject""); (""Java"", ""Java is the programming language and environment in which XYZObject is being instantiated so Java and XYZObject are related in the context of object instantiation"", ""XYZObject""); (""Java"", ""Java is the programming language and environment in which Systems operate so Java and Systems are related in the context of system implementation"", ""Systems""); (""XYZObject"", ""XYZObject is being instantiated using the new method so XYZObject and new are related in the context of object creation"", ""new""); (""Systems"", ""Systems can benefit from using object pools rather than instantiating the objects using the new method so Systems and new are related in the context of object creation"", ""new"")"
The Bytes class represents a byte sequence allocated from a shared byte array.,NULL
The Mem Ops ObjectPool class is capable of pooling instances of objects which can be reused.,NULL
To use the Mem Ops ObjectPool you must first create an instance of the com.nanosai.memops.objects.ObjectPool class.,NULL
Notice that the ObjectPool class constructor takes two parameters: The capacity and an IObjectFactory implementation.,"(""ObjectPool"", ""The ObjectPool class has a constructor method named ObjectPool class constructor."", ""ObjectPool class constructor""); (""ObjectPool class constructor"", ""The ObjectPool class constructor takes an IObjectFactory implementation as a parameter."", ""IObjectFactory""); (""ObjectPool class constructor"", ""The ObjectPool class constructor takes capacity as a parameter."", ""capacity"")"
"As you can see, the IObjectFactory only contains a single method named instance().",NULL
The type returned from the instance() method is decided by you when you implement the IObjectFactory interface.,NULL
You free an object instance for reuse by calling the ObjectPool free() method.,"(""ObjectPool"", ""The ObjectPool class contains the free() method, indicating a strong relationship between the two entities."", ""free()""); (""Object"", ""The Object class is related to the ObjectPool class because an instance of the Object class is being freed for reuse by the ObjectPool class."", ""ObjectPool"")"
"You just tell what module that contains the main class to run, and ModRun resolves and loads all its dependencies too.","(""ModRun"", ""ModRun contains and runs the main class"", ""main""); (""main"", ""the main class is located in the module"", ""module"")"
"By loading the classes of a module with its own ClassLoader, ModRun can control what classes are visible to each module.","(""ModRun"", ""ModRun uses ClassLoader to control the visibility of classes to each module."", ""ClassLoader""); (""ModRun"", ""ModRun controls what classes are visible to each module."", ""module"")"
A module can only see the classes from itself or from its dependencies (modules) and transitive dependencies.,"(""MODULE"", ""A module can see the classes from itself, indicating a relationship between the module and its classes."", ""CLASSES""); (""MODULE"", ""A module can see the classes from its dependencies, indicating a relationship between the module and its dependencies."", ""DEPENDENCIES"")"
"A module cannot see classes from modules ""above"" itself in the dependency graph.","(""Module"", ""A module is related to the dependency because it cannot see classes from modules above itself in the dependency graph."", ""Dependency""); (""Dependency"", ""The dependency is related to the graph because modules above itself are defined within the dependency graph."", ""Graph"")"
The JVM will consider classes loaded from the two different versions of the API as different classes because they are loaded with different ClassLoader instances.,"(""JVM"", ""The JVM will consider classes loaded from the two different versions of the API, indicating a relationship between the JVM and the API."", ""API""); (""JVM"", ""The JVM uses different ClassLoader instances, indicating a relationship between the JVM and the ClassLoader."", ""ClassLoader"")"
Each instance of the module have the classes loaded from its dependency graph isolated from the other instances of the same module (at least it can - if you want to).,"(""Module"", ""The text states that each instance of the module has classes loaded, indicating a relationship between the module and its instance."", ""Instance""); (""Module"", ""The text mentions the module's dependency graph, suggesting a relationship between the module and its dependency."", ""Dependency""); (""Dependency"", ""The text explicitly mentions the dependency graph, indicating a relationship between the dependency and the graph."", ""Graph"")"
Loading the classes from each module with its own ClassLoader makes application multi tenancy easier.,"(""ClassLoader"", ""ClassLoader is related to Class because it is used to load classes"", ""Class""); (""ClassLoader"", ""ClassLoader is related to module because it loads classes from each module"", ""module"")"
"ModRun can load multiple applications into the same JVM at the same time, and have their classes be completely isolated from each other, so one application cannot access the classes of another application.","(""ModRun"", ""ModRun can load multiple applications into the same JVM at the same time"", ""JVM""); (""JVM"", ""JVM can have multiple applications loaded into it at the same time"", ""Application""); (""Application"", ""each application has its own classes that are completely isolated from each other"", ""Class""); (""ModRun"", ""ModRun can load multiple applications into the same JVM at the same time"", ""Application"")"
"Here is an example that creates a module from a Maven repository, loads a class from the module, creates an instance of the class and calls a method on the instance via reflection:",NULL
Installing Netty in your Java project only requires that you download the Netty JAR files and include them on the classpath.,NULL
"A Netty EventLoop is a loop that keeps looking for new events, e.g.",NULL
"Third, the NioServerSocketChannel class instance is set on the ServerBootstrap instance.",NULL
Its method initChannel() is called whenever a new incoming TCP connection is accepted by the TCP server.,NULL
"As you can see, the ChannelInitializer is added to the ServerBootstrap using the childHandler() method.","(""ChannelInitializer"", ""The ChannelInitializer is added to the ServerBootstrap, indicating a relationship between the two classes."", ""ServerBootstrap""); (""ServerBootstrap"", ""The childHandler() method is used with the ServerBootstrap, indicating a relationship between the class and the method."", ""childHandler()"")"
The serverBootstrap.bind() method returns a ChannelFuture which can be used to know when the binding of the server (binding to local address and TCP port) is done.,"(""ServerBootstrap"", ""The ServerBootstrap class has a method called bind(), indicating a relationship between the class and the method."", ""bind()""); (""bind()"", ""The bind() method returns a ChannelFuture, indicating a relationship between the method and the class."", ""ChannelFuture"")"
"By calling sync() on the ChannelFuture the main thread that creates the server waits until the server has started, before continuing.","(""ChannelFuture"", ""The ChannelFuture has a method called sync, which establishes a relationship between the two entities as the method is called on the class."", ""sync""); (""main thread"", ""The main thread waits on the ChannelFuture, which establishes a relationship between the two entities as the main thread is dependent on the ChannelFuture."", ""ChannelFuture"")"
The channelRead() method is called whenever data is received from the SocketChannel the HelloServerHandler instance is attached to.,"(""HelloServerHandler"", ""The HelloServerHandler instance is attached to the SocketChannel, indicating a relationship between the two entities."", ""SocketChannel""); (""ChannelRead"", ""The channelRead() method is called whenever data is received from the SocketChannel, indicating that the channelRead() method is related to the SocketChannel."", ""SocketChannel"")"
"As you can see, the channelRead() responds with ""Hello "" + whatever the client sent to the server.","(""ChannelRead"", ""The channelRead method responds to the client, indicating a relationship between the two."", ""Client"")"
The channelReadComplete() method is called when there is no more data to read from the SocketChannel.,NULL
The exceptionCaught() method is called if an exception is thrown while receiving or sending data from the SocketChannel.,NULL
That means that you create a Java application with a class with a main() method and inside that application you create one of the Netty servers.,"(""Java application"", ""The Java application is related to the main() method because the main() method is inside the Java application"", ""main()""); (""Java application"", ""The Java application is related to the Netty servers because the Java application creates one of the Netty servers"", ""Netty servers"")"
The RION Ops RionObjectReader class can read a RION Object field into a Java object.,"(""RION Ops RionObjectReader"", ""The RION Ops RionObjectReader class can read a RION Object field into a Java object, indicating that RION Ops RionObjectReader is related to RION Object as it operates on it."", ""RION Object""); (""RION Ops RionObjectReader"", ""The RION Ops RionObjectReader class can read a RION Object field into a Java object, indicating that RION Ops RionObjectReader is related to Java as it outputs to a Java object."", ""Java"")"
The easiest way to create an instance of the RionObjectReader is via the RionObjectReaderBuilder class.,NULL
This class makes it easier to configure and create a RionObjectReader instance.,NULL
Here is an example of creating a RionObjectReader via the RionObjectReaderBuilder class:,NULL
The RionObjectReader readCyclic() method reads a cyclic object graph stored as RION in a byte array.,"(""RionObjectReader"", ""The RionObjectReader class contains the readCyclic() method, which indicates a clear relationship between the two entities as the method is a part of the class."", ""readCyclic()""); (""RionObjectReader"", ""The RionObjectReader class is related to RION because it reads a cyclic object graph stored as RION, indicating that RION is a format or structure that the class works with."", ""RION"")"
The RION Ops RionObjectWriter class makes it easy to write Java objects as a RION field to a byte array.,"(""RION Ops RionObjectWriter"", ""The RION Ops RionObjectWriter class uses the write method to write Java objects as a RION field to a byte array."", ""write""); (""RION Ops RionObjectWriter"", ""The RION Ops RionObjectWriter class is part of the RION package and writes Java objects as a RION field."", ""RION""); (""RION Ops RionObjectWriter"", ""The RION Ops RionObjectWriter class writes Java objects as a RION field to a byte array, indicating a relationship between the RION Ops RionObjectWriter class and Java."", ""Java""); (""write"", ""The write method is used to write Java objects, indicating a relationship between the write method and Java."", ""Java"")"
"To use the RionObjectWriter you must first create an instance of the RionObjectWriter class, com.nanosai.rionops.rion.object.RionObjectWriter.",NULL
The easiest way to create a RionObjectWriter instance is via the RionObjectWriterBuilder class.,NULL
"These examples build a RionObjectWriter which will serialize all fields (private, protected, default and public) found in the Pojo class to RION.",NULL
"Once created, the RionObjectWriter instance then only serialize objects of the given class.",NULL
To serialize objects of multiple classes you will have to create a RionObjectWriter for each class.,NULL
Note: You only need one RionObjectWriter per root class you want to serialize.,NULL
"If a given class represents an object graph consisting of other classes referenced from within the root class (or any of its field's classes recursively), all of these classes will be serialized too.","(""Class"", ""The source entity Class is related to the target entity Object because a class represents an object graph consisting of other classes."", ""Object""); (""Class"", ""The source entity Class is related to the target entity Field because the field's classes are referenced from within the root class or any of its field's classes recursively."", ""Field""); (""Object"", ""The source entity Object is related to the target entity Class because an object graph consists of other classes."", ""Class"")"
"To elaborate, in the example above, if the Pojo class contained fields of class Pojo2 and Pojo3 internally, these would be serialized too because they are part of an object graph rooted by a Pojo object.","(""Pojo"", ""Pojo2 is related to Pojo because it is a field of the Pojo class and is part of the object graph rooted by a Pojo object."", ""Pojo2"")"
The RionObjectWriter contains an writeAcyclic() and writeCyclic() method for these purposes.,"(""RionObjectWriter"", ""RionObjectWriter contains the writeAcyclic() method"", ""writeAcyclic()"")"
The RionObjectWriter writeAcyclic() can write an acyclic object graph as RION into a byte array.,"(""RionObjectWriter"", ""RionObjectWriter has a method called writeAcyclic()"", ""writeAcyclic()""); (""writeAcyclic()"", ""writeAcyclic() method can write an acyclic object graph as RION"", ""RION"")"
"If the object is part of a cyclic (not acyclic) object graph, the writeAcyclic() method will enter an infinite recursion and eventually crash.",NULL
Here is an example of writing an object using the RionObjectWriter writeAcyclic() method:,NULL
The RionObjectWriter writeCyclic() method can write a cyclic object graph as RION to a byte array.,NULL
Here is an example of writing a cyclic object graph to RION using the RionObjectWriter writeCyclic() method.,"(""RionObjectWriter"", ""The RionObjectWriter class contains the writeCyclic() method, which establishes a clear relationship between the two entities as the method is part of the class."", ""writeCyclic()""); (""RionObjectWriter"", ""The RionObjectWriter class is related to the RION package, as it is used to write to RION, indicating a connection between the class and the package."", ""RION"")"
"The RION Ops RionReader class, com.nanosai.rionops.rion.read.RionReader makes it easy to write RION fields from a Java byte array.",NULL
Setting a source byte array is done via the method setSource().,"(""Setting"", ""The source entity 'Setting' is related to the target entity 'SetSource' because 'SetSource' is a method used to set a source byte array in the 'Setting' class."", ""SetSource"")"
Here is an example of setting the source byte array on a RionReader via its setSource() method:,NULL
"Third, the example loops as long as hasNext() returns true, and iterates through all the RION fields in the source byte array, one by one.",NULL
You can read a RION Bytes field using the RionReader readBytes() method.,"(""RionReader"", ""The RionReader class contains the readBytes() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""readBytes()""); (""RION"", ""The RION class and the RionReader class are related as RionReader is likely a class used to read RION bytes, thus they have a contextual relationship."", ""RionReader"")"
The readBytes() method will read the bytes of the RION Bytes field into this byte array.,"(""Readbytes()"", ""The Readbytes() method is related to Rion Bytes because it reads the bytes of the Rion Bytes field into a byte array."", ""Rion Bytes"")"
Here is an example of reading a RION Bytes field with the readBytes() method:,NULL
The value returned by the readBytes() method is the number of bytes read into the destination byte array.,NULL
"The readBytes() method also comes in a version where you can specify the offset into the destination byte array to start writing the Bytes field value, and a maximal length (number of bytes) to read.","(""ReadBytes"", ""The ReadBytes method reads the Bytes field value"", ""Bytes""); (""ReadBytes"", ""The ReadBytes method writes to the destination byte array"", ""Destination""); (""ReadBytes"", ""The ReadBytes method takes an offset parameter to specify where to start writing in the destination byte array"", ""Offset"")"
Here is an example of reading a RION Bytes field using that readBytes() method:,"(""ReadBytes"", ""The ReadBytes method is used to read a RION Bytes field, indicating a relationship between the two."", ""RION Bytes""); (""Read"", ""The Read method is mentioned in the context of reading a RION Bytes field, suggesting a relationship between the Read method and the RION Bytes class."", ""RION Bytes"")"
"This example tells the readBytes() method to start writing the Bytes field value into the destination array from offset 2, and to maximally read 10 bytes.","(""Readbytes"", ""The Readbytes method is related to the Bytes class because it is used to read the Bytes field value into the destination array."", ""Bytes""); (""Readbytes"", ""The Readbytes method is related to the Destination class because it writes the Bytes field value into the destination array."", ""Destination"")"
To read a RION Boolean field you can use the RionReader readBoolean() method.,"(""RionReader"", ""The RionReader class contains the readBoolean() method, indicating a clear relationship between the two entities as the method is part of the class."", ""readBoolean()""); (""RION"", ""The RION class is related to the RionReader class, as the reader is likely used to read RION fields, thus establishing a connection between the two entities."", ""RionReader"")"
Here is an example of reading RION Boolean field using the RionReader readBoolean() method:,"(""RionReader"", ""RionReader uses the readBoolean() method to read RION Boolean fields, indicating a clear relationship between the class and the method""}"", ""readBoolean()""); (""RION"", ""RION is related to RionReader, as RionReader is used to read RION fields, indicating a clear relationship between the two classes""}"", ""RionReader"")"
Here is an example of reading a Java Boolean object using the RionReader readBooleanObj() method:,"(""RionReader"", ""RionReader contains the readBooleanObj() method, indicating a relationship between the class and the method"", ""readBooleanObj()""); (""Java"", ""RionReader is likely a Java class, indicating a relationship between the Java package and the RionReader class"", ""RionReader"")"
To read a RION Int64 field you can use the RionReader readInt64() method.,"(""RionReader"", ""RionReader has a method called readInt64{} which is used to read a RION Int64 field, indicating a relationship between the RionReader class and the readInt64{} method"", ""readInt64{}"")"
Here is an example of reading a RION Int64 field using the RionReader readInt64() method:,"(""RionReader"", ""The RionReader class contains the readInt64() method, indicating a clear relationship between the two entities as the method is part of the class's functionality."", ""readInt64()""); (""RION"", ""The RION package is related to the RionReader class because the class is likely part of the package, given the naming convention and the context in which the class is being used to read a RION Int64 field."", ""RionReader"")"
Here is an example of reading a RION Int64 field into a Java Long object using the RionReader readInt64Obj() method:,"(""RionReader"", ""RionReader is related to readInt64Obj() because readInt64Obj() is a method of the RionReader class""}"", ""readInt64Obj()""); (""readInt64Obj()"", ""readInt64Obj() is related to Long because it is used to read a RION Int64 field into a Java Long object""}"", ""Long""); (""RionReader"", ""RionReader is related to Long because RionReader has a method readInt64Obj() that reads into a Java Long object""}"", ""Long""); (""Java"", ""Java is related to Long because Long is a class in the Java package""}"", ""Long""); (""RION"", ""RION is related to RionReader because RionReader is used to read RION fields""}"", ""RionReader"")"
These methods are named readFloat32() and readFloat64() Here are two examples of reading a RION Float field into a Java float and double variable:,"(""ReadFloat32"", ""ReadFloat32 method is used to read a RION Float field"", ""RION Float""); (""ReadFloat64"", ""ReadFloat64 method is used to read a RION Float field"", ""RION Float""); (""ReadFloat32"", ""ReadFloat32 method is used in Java to read a float variable"", ""Java"")"
Use the readFloat32Obj() or readFloat64Obj() methods if the RION Float field can be set to null in your concrete use case.,"(""Readfloat32obj"", ""The Readfloat32obj method is related to the Rion Float class because it is used to read the Rion Float field."", ""Rion Float"")"
The RionReader class has a method named readUtf8String() which can read a RION UTF-8 field into a Java String.,"(""RionReader"", ""The RionReader class has a method named readUtf8String(), indicating that readUtf8String() is a method of the RionReader class"", ""readUtf8String()""); (""readUtf8String()"", ""The readUtf8String() method can read a RION UTF-8 field, indicating that readUtf8String() is related to RION"", ""RION""); (""readUtf8String()"", ""The readUtf8String() method can read a RION UTF-8 field into a Java String, indicating that readUtf8String() is related to Java"", ""Java""); (""RionReader"", ""The RionReader class has a method that can read a RION UTF-8 field, indicating that RionReader is related to RION"", ""RION"")"
Here is an example of reading a RION UTF-8 field into a Java String with readUtf8String() :,"(""ReadUtf8String"", ""ReadUtf8String is related to String because it reads a RION UTF-8 field into a Java String"", ""String"")"
The readUtcCalendar() method of the RionReader class can read a RION UTC field as a Java Calendar instance.,"(""RionReader"", ""The readUtcCalendar() method is a part of the RionReader class, indicating a clear relationship between the two entities as the method is a member of the class."", ""readUtcCalendar()""); (""readUtcCalendar()"", ""The readUtcCalendar() method can read a RION UTC field, indicating a clear relationship between the two entities as the method operates on RION data."", ""RION""); (""readUtcCalendar()"", ""The readUtcCalendar() method can read a RION UTC field as a Java Calendar instance, indicating a clear relationship between the two entities as the method returns a Calendar instance."", ""Calendar""); (""readUtcCalendar()"", ""The readUtcCalendar() method can read a RION UTC field as a Java Calendar instance, indicating a clear relationship between the two entities as the method is implemented in Java."", ""Java""); (""RionReader"", ""The RionReader class has a method that can read a RION UTC field, indicating a clear relationship between the two entities as the class operates on RION data."", ""RION""); (""RionReader"", ""The RionReader class has a method that can read a RION UTC field as a Java Calendar instance, indicating a clear relationship between the two entities as the class is implemented in Java."", ""Java""); (""RionReader"", ""The RionReader class has a method that can read a RION UTC field as a Java Calendar instance, indicating a clear relationship between the two entities as the class returns a Calendar instance."", ""Calendar""); (""Java"", ""Java has a Calendar class, indicating a clear relationship between the two entities as Calendar is a part of Java."", ""Calendar""); (""RION"", ""RION data can be read as a Java Calendar instance, indicating a clear relationship between the two entities as RION data is processed in Java."", ""Java"")"
When reading a composite RION field you need to use the RionReader moveInto() and moveOutOf() methods.,"(""RionReader"", ""RionReader is related to moveInto() because moveInto() is a method of RionReader"", ""moveInto()"")"
"The moveInto() method will move the RionReader's internal state ""into"" the given RION field.","(""MoveInto"", ""The MoveInto method is related to the RionReader class because it is described as moving the RionReader's internal state.""}"", ""RionReader"")"
"That means, that the hasNext() method now returns true as long as the RION field you moved into has more nested fields.",NULL
"The moveOutOf() method moves the RionReader's internal state ""out of"" the given RION field.","(""RionReader"", ""The moveOutOf() method is a part of the RionReader class, indicating a clear relationship between the two entities as the method belongs to the class."", ""moveOutOf()""); (""moveOutOf()"", ""The moveOutOf() method operates on the RION field, establishing a relationship between the method and the class as the method is used in conjunction with the class."", ""RION"")"
Now the hasNext() method will return true if the parent scope (parent RION field or the total source byte array for the RionReader) has more RION fields.,"(""HasNext()"", ""The hasNext() method is related to the RionReader class because it is used to check if the parent scope of the RionReader has more RION fields."", ""RionReader""); (""RionReader"", ""The RionReader class is related to the RION class because it is used to read RION fields."", ""RION"")"
"At the outer nesting level (top level) of the above RION field sequence, the RionReader hasNext() will return true, as long as there are RION fields at this nesting level.","(""RionReader"", ""RionReader has a method called hasNext(), indicating a relationship between the class RionReader and its method hasNext()."", ""hasNext()"")"
"Now the RionReader hasNext() method returns true 2 times, because there are 2 nested RION fields inside the RION Object field.","(""RionReader"", ""The RionReader class contains the hasNext() method, indicating a relationship between the two."", ""hasNext()""); (""RionReader"", ""The RionReader class is related to the RION class, as it is used to read RION fields and objects."", ""RION"")"
"Once the hasNext() method returns false, you ""move out of"" the composite RION field again.",NULL
You can improve on the above code in various ways - e.g.,NULL
"To read a RION Table field, you have to ""move into"" it with moveInto(), then read the first field which is an Int64 RION field representing the row count, and then 1 to N Key or Key Short fields representing the column headers (column names / keys) of the table, and then finally 1 to N fields per row.","(""RION Table"", ""The RION Table is related to the moveInto method because moveInto is used to access the RION Table field."", ""moveInto""); (""moveInto"", ""The moveInto method is related to the Int64 RION field because after moving into the RION Table, the first field read is an Int64 RION field representing the row count."", ""Int64 RION""); (""RION Table"", ""The RION Table is related to the Int64 RION field because the Int64 RION field is part of the RION Table structure, representing the row count."", ""Int64 RION""); (""RION Table"", ""The RION Table is related to the Key field because the Key fields represent the column headers of the RION Table."", ""Key""); (""RION Table"", ""The RION Table is related to the Key Short field because the Key Short fields also represent the column headers of the RION Table."", ""Key Short""); (""moveInto"", ""The moveInto method is related to the Key field because after moving into the RION Table with moveInto, the Key fields can be read."", ""Key"")"
The RionReader class contains a method named isNull() which will tell you if the current RION field pointed to by the RionReader has the field value null.,"(""RionReader"", ""The RionReader class contains a method named isNull(), indicating that isNull() is a part of RionReader."", ""isNull()""); (""RionReader"", ""The RionReader class is clearly related to RION because it reads RION fields."", ""RION"")"
Here is an example of checking if a given RION field is null via the RionReader isNull() method:,"(""RionReader"", ""The RionReader class contains the isNull() method, indicating a relationship between the two entities."", ""isNull()""); (""RionReader"", ""The RionReader class is used to read RION fields, indicating a relationship between the two entities."", ""RION"")"
"The RION Ops RionWriter class, com.nanosai.rionops.rion.write.RionWriter, enables you to write RION fields easily and efficiently.","(""RION Ops RionWriter"", ""The RION Ops RionWriter class is related to RION because it is used to write RION fields."", ""RION""); (""RION Ops RionWriter"", ""The RION Ops RionWriter class is related to com.nanosai.rionops.rion.write.RionWriter because they are the same entity, with the latter being the fully qualified name of the former."", ""com.nanosai.rionops.rion.write.RionWriter"")"
You set the destination byte array of the RionWriter using the setDestination() method.,NULL
The RionWriter contains a method named writeBytes() which can be used to write a RION Bytes field to the destination byte array.,"(""RionWriter"", ""The RionWriter contains a method named writeBytes(), indicating that writeBytes() is a method of the RionWriter class."", ""writeBytes()""); (""writeBytes()"", ""The writeBytes() method is used to write a RION Bytes field, indicating that writeBytes() is related to the RION class."", ""RION""); (""writeBytes()"", ""The writeBytes() method is used to write a RION Bytes field, indicating that writeBytes() is related to the Bytes class."", ""Bytes""); (""RionWriter"", ""The RionWriter contains a method named writeBytes() which can be used to write a RION Bytes field, indicating that RionWriter is related to the RION class."", ""RION"")"
Here is a Java example of writing a RION Bytes field from a byte array using the RionWriter writeBytes() method:,"(""RionWriter"", ""RionWriter is a class that contains the writeBytes() method, indicating a clear relationship between the two."", ""writeBytes()""); (""RION"", ""RION is a class that is related to RionWriter, as RionWriter is used to write RION Bytes fields."", ""RionWriter""); (""Java"", ""Java is a package that contains the RionWriter class, indicating a relationship between the two."", ""RionWriter""); (""Java"", ""Java is a package that is related to RION, as RION is a class used in Java."", ""RION"")"
The writeBytes() method also exists in a version that takes a source offset and source length which specifies from what offset and how many bytes forward in the source byte array to write to the RION Bytes field in the destination byte array.,"(""WriteBytes()"", ""The WriteBytes() method takes a source offset and source length which specifies from what offset and how many bytes forward in the source byte array to write"", ""Source Byte Array""); (""WriteBytes()"", ""The WriteBytes() method writes to the RION Bytes field in the destination byte array"", ""Destination Byte Array"")"
The RionWriter method writeBoolean() writes a boolean value (true / false) as a RION Boolean field to the destination byte array.,"(""RionWriter"", ""The RionWriter method writeBoolean() is a part of the RionWriter class, indicating a clear relationship between the two entities as the method is a member of the class."", ""writeBoolean()""); (""writeBoolean()"", ""The writeBoolean() method writes a boolean value, which is of type Boolean, indicating a relationship between the method and the data type it handles."", ""Boolean"")"
Here is a Java example of writing a RION Boolean field using the RionWriter writeBoolean() method:,"(""RionWriter"", ""RionWriter has a method called writeBoolean() which is used to write a RION Boolean field"", ""writeBoolean()""); (""RION"", ""RION is related to RionWriter as RionWriter is used to write RION fields"", ""RionWriter""); (""Java"", ""RionWriter is a Java class"", ""RionWriter"")"
The RionWriter method writeInt64() will write a 64 bit integer as a RION IntPos or IntNeg field to the destination byte array.,"(""RionWriter"", ""The RionWriter class contains the writeInt64() method, indicating a relationship between the class and the method."", ""writeInt64()""); (""writeInt64()"", ""The writeInt64() method writes to a RION field, indicating a relationship between the method and the RION class."", ""RION""); (""writeInt64()"", ""The writeInt64() method writes a 64 bit integer as a RION IntPos field, indicating a relationship between the method and the IntPos class."", ""IntPos"")"
"Here are two examples of writing int64 values (long values) as RION IntPos and IntNeg fields to the destination byte array, using the RionWriter writeInt64() method:","(""RionWriter"", ""RionWriter uses the writeInt64() method to write int64 values"", ""writeInt64()""); (""RION"", ""RionWriter is a part of the RION package"", ""RionWriter"")"
The RionWriter methods writeFloat32() and writeFloat64() writes a 32 bit and 64 bit floating point number as a RION Float field to the destination byte array.,"(""RionWriter"", ""RionWriter contains the method writeFloat32()"", ""writeFloat32()""); (""RionWriter"", ""RionWriter contains the method writeFloat64()"", ""writeFloat64()""); (""writeFloat32()"", ""The writeFloat32() method writes a 32 bit floating point number as a RION Float field"", ""RION Float"")"
"Here are two examples of writing a 32 bit and 64 bit floating point number as RION Float fields to the destination byte array, using the RionWriter writeFloat32() and writeFloat64() methods:","(""RionWriter"", ""RionWriter has a method called writeFloat32() which is used to write a 32 bit floating point number to the destination byte array"", ""writeFloat32()""); (""RionWriter"", ""RionWriter has a method called writeFloat64() which is used to write a 64 bit floating point number to the destination byte array"", ""writeFloat64()""); (""writeFloat32()"", ""writeFloat32() method writes a 32 bit floating point number as RION Float field to the destination byte array"", ""RION Float""); (""writeFloat64()"", ""writeFloat64() method writes a 64 bit floating point number as RION Float field to the destination byte array"", ""RION Float"")"
The RionWriter method writeUtf8() writes a Java String as a RION UTF-8 or UTF-8-Short field to the destination byte array.,"(""RionWriter"", ""The RionWriter method writeUtf8() indicates that RionWriter is a class that contains the writeUtf8() method, thus they are related."", ""writeUtf8()""); (""writeUtf8()"", ""The writeUtf8() method writes a Java String, so writeUtf8() and String are related as the method operates on the String type."", ""String""); (""RionWriter"", ""RionWriter writes a RION UTF-8 or UTF-8-Short field, which implies a relationship between RionWriter and the RION package."", ""RION"")"
Here is an example of writing a RION UTF-8 field to a byte array using the RionWriter writeUtf8() method:,"(""RionWriter"", ""RionWriter has a method called writeUtf8, so RionWriter and writeUtf8 are related as a class and its method"", ""writeUtf8""); (""RionWriter"", ""RionWriter writes to a byte array, so RionWriter and byte array are related as a writer and its target"", ""byte array""); (""writeUtf8"", ""writeUtf8 method writes to a byte array, so writeUtf8 and byte array are related as a method and its target"", ""byte array"")"
The RionWriter method writeUtc() method writes a date and time in the shape of a Java Calendar as a RION UTC field (UTC date-time) to the destination byte array.,"(""RionWriter"", ""The RionWriter class contains the writeUtc() method, indicating a clear relationship between the two entities as the method is part of the class."", ""writeUtc()""); (""writeUtc()"", ""The writeUtc() method writes a date and time in the shape of a Java Calendar, indicating that the method operates on or utilizes the Java Calendar entity."", ""Java Calendar""); (""writeUtc()"", ""The writeUtc() method writes to a RION UTC field, indicating a relationship between the method and the field as the method is responsible for populating the field."", ""RION UTC field""); (""RionWriter"", ""The RionWriter class, through its writeUtc() method, interacts with a Java Calendar, establishing a connection between the class and the calendar entity."", ""Java Calendar"")"
Here is an example of writing a Java Calendar as a RION UTC field to the destination byte array using the RionWriter writeUtc() method:,"(""Java Calendar"", ""The Java Calendar is being written to the destination byte array using the RionWriter"", ""RionWriter""); (""RionWriter"", ""The RionWriter uses the writeUtc() method to write the Java Calendar to the destination byte array"", ""writeUtc()""); (""RION UTC"", ""The Java Calendar is being written as a RION UTC field"", ""Java Calendar""); (""RION UTC"", ""The RionWriter writes the Java Calendar as a RION UTC field to the destination byte array"", ""RionWriter""); (""writeUtc()"", ""The writeUtc() method is used to write the Java Calendar to the destination byte array"", ""Java Calendar"")"
The RionWriter class has functionality that helps you reserve length bytes for composite RION fields and jump back up and fill them in correctly later.,NULL
One of the mechanisms in the RionWriter class that helps you reserve length bytes and set their value correctly later requires an internal stack to keep track of where the reserved length bytes are located.,NULL
Here is an example of setting the nested field stack for a RionWriter via its setNestedFieldStack() method:,NULL
"However, it is possible for all RION fields to take the value null, so it is possible to include e.g.",NULL
"The writeObjectBeginPush() method writes the beginning of the RION Object field, and reserves and reserve as many length bytes as you pass to it as parameter (2 in the example above).",NULL
"The writeObjectEndPop() method pops the RION Object field start index off the nested field stack, calculates the total length of the Object field and writes the total Object field length into its reserved length bytes.","(""WriteObjectEndPop"", ""The WriteObjectEndPop method operates on the RION Object, indicating a relationship between the two."", ""RION Object"")"
There are also versions of the writeObjectBegin() and writeObjectEnd() method that does not use the internal nested field stack.,NULL
The String arguments passed to the main() method are the command line arguments passed to the application when it is executed.,NULL
The Main argument is the name of the object to run the main() method of.,NULL
"The arguments ""arg1"" and ""arg2"" are passed in the String array to the main() method.","(""Main"", ""The main() method is related to the String class because the arguments are passed in a String array."", ""String""); (""Main"", ""The main() method is related to the Array class because the arguments are passed in an array."", ""Array"")"
The until keyword makes sure to only iterate until myArray.length - 1.,"(""Until"", ""The until keyword is used in relation to myArray to control the iteration."", ""Myarray""); (""Myarray"", ""Myarray is related to Length as it is a property of myArray."", ""Length"")"
"If you had needed i to also take the value of myArray.length in the final iteration, you could have used the to keyword instead of the until keyword.",NULL
"This means that you can define classes in Scala, and instantiate objects of these classes.","(""Classes"", ""Classes are defined in Scala"", ""Scala""); (""Objects"", ""Objects are instances of classes"", ""Classes"")"
"That means, that a class defines what information objects of that class holds, and what behaviour (methods) it exposes.","(""Class"", ""A class defines what behavior it exposes through its methods."", ""Methods"")"
The other aspects of Scala classes will be covered in separate texts.,NULL
Here I have just shown you how to declare a method inside a class.,NULL
"Notice how this addToMyField() method does not have the equals sign, and no return type specified.",NULL
"When an exception is thrown from inside the throwsException() method, the execution is interrupted and the execution jumps to the catch clause surrounding the code that threw the exception.",NULL
"In the example above, when the throwsException() method is called, and it throws an exception, the statement below the throwsException() method call is never executed.",NULL
"In the example above, only one exception is caught, Exception which is the superclass of most exceptions.",NULL
"Rather than compute the .toUpperCase() value twice, by nesting them inside each if-statement, the uppercase version of aString is computed just once, and assigned to the variable aStringUC.","(""Astring"", ""Astring is related to ToUpperCase because the ToUpperCase method is called on the Astring variable to compute its uppercase version"", ""ToUpperCase""); (""Astring"", ""Astring is related to Astringuc because Astringuc is assigned the uppercase version of Astring"", ""Astringuc"")"
"You can thus use all the classes of the Java SDK's in Scala, and also your own, custom Java classes, or your favourite Java open source projects.","(""Java SDK"", ""The Java SDK is related to Scala because Scala can use all the classes of the Java SDK."", ""Scala""); (""Java"", ""Java is related to Scala because Scala can use custom Java classes and Java open source projects."", ""Scala"")"
"Instead a Scala class can have what is called a singleton object, or sometime a companion object.","(""Scala"", ""A Scala class can have a singleton object, indicating a relationship between the two."", ""Singleton object""); (""Scala"", ""A Scala class can also have a companion object, which establishes a relationship between the class and the companion object."", ""Companion object"")"
"When a singleton object is named the same as a class, it is called a companion object.",NULL
A companion object must be defined inside the same source file as the class.,"(""Companion Object"", ""A companion object is defined inside the same source file as the class, indicating a relationship between the two."", ""Source File""); (""Class"", ""A companion object must be defined inside the same source file as the class, indicating a relationship between the class and its companion object."", ""Companion Object"")"
"In this class you can both instantiate Main and call sayHelloWorld() or call the sayHi() method on the companion object directly, like this:","(""Main"", ""Main class has a method called sayHelloWorld()"" "", ""sayHelloWorld()""); (""Main"", ""Main class has a companion object with a method called sayHi()"" "", ""sayHi()"")"
This also means that you can use all Java classes in your Scala code.,NULL
The Scala version used in the examples in this tutorial is Scala 2.8.0 .,NULL
"The Stream Ops StreamOps class, com.nanosai.streamops.StreamOps, provides a convenient facade for the Stream Ops API.","(""StreamOps"", ""The StreamOps class is related to the com.nanosai.streamops.StreamOps package because it is the fully qualified name of the class."", ""com.nanosai.streamops.StreamOps"")"
The StreamOps class can create the most commonly used components of the Stream Ops API.,NULL
"Thus, the StreamOps class is a good place to start, both when using Stream Ops, but also when exploring what you can do with Stream Ops and how it works.",NULL
In this tutorial we will only go over the components the StreamOps and related factory classes can create.,NULL
"You can create instances of these classes via the new operator, or you can use a StreamStorageFactory.",NULL
You can create a StreamStorageFS instance via the StreamStorageFactory createStreamStorageFS() method.,"(""StreamStorageFactory"", ""StreamStorageFactory contains the createStreamStorageFS() method, which is used to create a StreamStorageFS instance"", ""createStreamStorageFS()"")"
Here is an example of creating a StreamStorageFS instance via the createStreamStorageFS() method:,NULL
You can create a StreamStorageRootFS instance via the StreamStorageFactory createStreamStorageRootFS() method.,"(""StreamStorageFactory"", ""The StreamStorageFactory class has a method called createStreamStorageRootFS(), which establishes a relationship between the class and the method."", ""createStreamStorageRootFS()""); (""createStreamStorageRootFS()"", ""The createStreamStorageRootFS() method is used to create an instance of the StreamStorageRootFS class, indicating a relationship between the method and the class."", ""StreamStorageRootFS"")"
"The Stream Ops StreamStorageFS class, com.nanosai.streamops.storage.file.StreamStorageFS, provides disk storage for a data stream.","(""StreamStorageFS"", ""The StreamStorageFS class is located in the com.nanosai.streamops.storage.file package"", ""com.nanosai.streamops.storage.file""); (""Stream Ops StreamStorageFS"", ""The Stream Ops StreamStorageFS is another name for the StreamStorageFS class"", ""StreamStorageFS"")"
"More specifically, the StreamStorageFS class can write an ordered sequence of records to disk, and later read the records from disk again in the exact same order.","(""StreamStorageFS"", ""StreamStorageFS class can write an ordered sequence of records to disk, and later read the records from disk again in the exact same order, indicating a relationship between the class and the records"", ""records"")"
The StreamStorageFS class is one of the core classes of the Stream Ops data storage engine.,NULL
Many of the other classes in the Stream Ops data storage engine revolve around this class.,NULL
To use the StreamStorageFS class you must first create a StreamStorageFS instance.,NULL
"Once a StreamStorageFS instance is open for appending records, you can append a record to the stream via the append() method.",NULL
You can obtain a list of StreamStorageBlockFS instances from a StreamStorageFS by calling getStorageBlocks().,"(""StreamStorageFS"", ""StreamStorageFS is related to getStorageBlocks() because getStorageBlocks() is a method that can be called on a StreamStorageFS instance"", ""getStorageBlocks()""); (""StreamStorageFS"", ""StreamStorageFS is related to StreamStorageBlockFS because a list of StreamStorageBlockFS instances can be obtained from a StreamStorageFS by calling getStorageBlocks()"", ""StreamStorageBlockFS"")"
The StreamStorageFS class contains a method to read bytes from a stream block file.,NULL
"The readBytes() method reads bytes from the file represented by the given StreamStorageBlockFS instance, into the byte[] array passed as parameter.","(""Readbytes()"", ""The readBytes() method is related to the StreamStorageBlockFS class because it reads bytes from the file represented by the given StreamStorageBlockFS instance""}"", ""Streamstorageblockfs"")"
The readBytes() method will start fromByte bytes into the block file.,"(""ReadBytes"", ""The ReadBytes method is related to the Block class because it operates on a block file."", ""Block"")"
The Stream Ops for Java class named StreamStorageRootFS (com.nanosai.streamops.engine.storage.file.StreamStorageRootFS) class represents the root of a file based stream storage system.,"(""StreamStorageRootFS"", ""StreamStorageRootFS is part of the com.nanosai.streamops.engine.storage.file package"", ""com.nanosai.streamops.engine.storage.file""); (""Stream Ops for Java"", ""StreamStorageRootFS is a class named in the context of Stream Ops for Java"", ""StreamStorageRootFS"")"
You can always obtain the root directory path a StreamStorageRootFS was created with via its getRootDirPath() method.,NULL
Here is an example of obtaining the root directory path of a StreamStorageRootFS via its getRootDirPath() method:,NULL
"When you write records to a stream via the StreamStorageFS instance, the StreamStorageFS class will divide the records into multiple files.","(""StreamStorageFS"", ""The StreamStorageFS class is related to records because it divides the records into multiple files."", ""records""); (""StreamStorageFS"", ""The StreamStorageFS class is related to stream because it is used to write records to a stream."", ""stream""); (""StreamStorageFS"", ""The StreamStorageFS class is related to files because it divides the records into multiple files."", ""files""); (""records"", ""The records are related to stream because they are written to a stream."", ""stream""); (""records"", ""The records are related to files because they are divided into multiple files."", ""files"")"
Creating a Buffer is done using the static buffer() method in the Buffer interface.,"(""Buffer"", ""The Buffer class is related to the buffer method because the buffer method is used to create a Buffer."", ""buffer"")"
If you want the bytes stored in the Buffer to be encoded using a special encoding (e.g.,NULL
"you can specify the encoding as the second parameter to the buffer() method, like this:","(""Buffer()"", ""The buffer() method is related to the Encoding class because it accepts an encoding parameter, indicating a connection between the method's functionality and the encoding type."", ""Encoding"")"
You can read the length of a Buffer using its length() method.,NULL
You can write to a specific position inside a buffer using one of the set...() methods.,NULL
You can also write data to a Buffer using one of the append...() methods.,NULL
You can read the data stored in a Buffer using the many get...() methods.,NULL
After the vertx run part of the command you must write the fully qualified class name of the verticle to deploy.,NULL
To deploy a verticle class you must run the vertx run classname command from the root directory of the compiled classes for the verticle to deploy.,"(""Verticle"", ""The Verticle class is related to the Vertx class because the Vertx class is used to deploy the Verticle class."", ""Vertx""); (""Verticle"", ""The Verticle class is related to the Root package because the Verticle class is deployed from the root directory of the compiled classes."", ""Root"")"
"Thus, the root directory of your classes becomes the classpath for deploying the verticle.","(""ROOT DIRECTORY"", ""The root directory is related to the classpath because the root directory of your classes becomes the classpath for deploying the verticle."", ""CLASSPATH""); (""CLASSPATH"", ""The classpath is related to the verticle because the classpath is used for deploying the verticle."", ""VERTICLE"")"
Whatever directory you run the vertx run command from is automatically added to the classpath when looking for the verticle class.,NULL
You can also run a Java verticle class which is located inside a JAR file.,NULL
Sometimes you need a classpath which contains more than one directory or JAR file.,"(""Classpath"", ""The classpath is related to the directory because it can contain more than one directory."", ""Directory""); (""Classpath"", ""The classpath is related to the JAR file because it can contain more than one JAR file."", ""JAR file"")"
In those situations you can provide a normal classpath string as the -cp argument value.,NULL
Each entry (directory or JAR file) in the classpath string must be separated by either a semicolon (on Windows) or a colon (on Unix / Linux).,"(""Classpath"", ""Classpath is related to Directory because Directory is an entry in the classpath string."", ""Directory""); (""Classpath"", ""Classpath is related to Jar because Jar is an entry in the classpath string."", ""Jar""); (""Classpath"", ""Classpath is related to Windows because Windows uses a semicolon to separate entries in the classpath string."", ""Windows""); (""Classpath"", ""Classpath is related to Unix because Unix uses a colon to separate entries in the classpath string."", ""Unix""); (""Classpath"", ""Classpath is related to Linux because Linux uses a colon to separate entries in the classpath string."", ""Linux""); (""Windows"", ""Windows is related to Semicolon because Windows uses a semicolon to separate entries in the classpath string."", ""Semicolon""); (""Unix"", ""Unix is related to Colon because Unix uses a colon to separate entries in the classpath string."", ""Colon"")"
This example contains two JAR files in the classpath separated by a semicolon.,NULL
"If you have a very long classpath your command line may get very long, and thus be hard to read in a text editor.","(""Classpath"", ""The classpath is related to the command because a long classpath can make the command line very long and hard to read."", ""Command""); (""Command"", ""The command is related to the text because the command line is being read in a text editor."", ""Text""); (""Text"", ""The text is related to the editor because the text is being read in the editor."", ""Editor""); (""Classpath"", ""The classpath is related to the text because the length of the classpath can affect the readability of the text in the editor."", ""Text""); (""Classpath"", ""The classpath is related to the editor because the classpath's length can impact the usability of the editor."", ""Editor"")"
"Instead you can build the classpath up as an environment variable, one entry per line, and use that environment variable in the command line.","(""Classpath"", ""The classpath is related to the environment variable because it is built up as an environment variable."", ""Environment Variable""); (""Environment Variable"", ""The environment variable is related to the command line because it is used in the command line."", ""Command Line"")"
run.cmd and you can execute it from a Windows command line.,NULL
Notice the use of / as directory separator and the use of : as classpath entry separator.,"(""Directory"", ""Directory uses Separator as its directory separator"", ""Separator"")"
That might be useful if you deploy a class file that is written in Groovy or Scala (but which are compiled into Java classes).,"(""Groovy"", ""Groovy is related to Java because Groovy code is compiled into Java classes"", ""Java""); (""Scala"", ""Scala is related to Java because Scala code is compiled into Java classes"", ""Java"")"
The first parameter to the getNow() method is the TCP port to connect to the remote HTTP server on.,"(""GetNow()"", ""The getNow() method is related to TCP because it is used to connect to the remote HTTP server on a specific TCP port."", ""TCP""); (""GetNow()"", ""The getNow() method is related to HTTP because it is used to connect to a remote HTTP server."", ""HTTP"")"
The getNow() method exists in a version where you can leave the port out.,NULL
The second parameter to the getNow() method is the domain name of the remote HTTP server to connect to.,NULL
The third parameter to the getNow() method is the URI to the resource to retrieve.,NULL
The Handler implementation passed to the getNow() method is called when the headers of the HTTP response are received.,"(""Handler"", ""The Handler implementation is passed to the getNow() method, indicating a relationship between the Handler class and the getNow() method."", ""getNow()""); (""getNow()"", ""The getNow() method is related to the HTTP response, indicating a relationship between the getNow() method and the HTTP class."", ""HTTP"")"
"However, if you do need to access the body of the HTTP response, you need to register another handler on the HttpClientResponse that is passed as parameter to the first Handler's handle() method.","(""Handler"", ""The Handler class has a method called handle, indicating a relationship between the two entities."", ""handle"")"
The Handler implementation passed to the bodyHandler() method of the HttpClientResponse is called when the full HTTP response body is received.,"(""Handler"", ""The Handler implementation is passed to the bodyHandler() method, indicating a clear relationship between the two entities."", ""bodyHandler""); (""bodyHandler"", ""The bodyHandler() method is a part of the HttpClientResponse, indicating a clear relationship between the two entities."", ""HttpClientResponse"")"
"Once you have created the HTTP server, you can start it using its listen() method.","(""HTTP server"", ""The HTTP server and the listen() method are related because the listen() method is used to start the HTTP server."", ""listen()""); (""HTTP"", ""The HTTP package and the HTTP server are related because the HTTP server is likely part of the HTTP package."", ""HTTP server"")"
"The HttpServer class has more versions of the listen() method too, which gives you different options for starting the HTTP server.",NULL
"Every time an HTTP request arrives at the HTTP server, the handle() method of the Handler object is called.",NULL
Inside the handle() method you can execute the code needed to handle the HTTP request.,NULL
You can access HTTP headers and parameters from the HttpServerRequest object passed as parameter to the handle() method.,NULL
"After writing the headers back you can write the response body back via the write() method, like this:","(""Write"", ""The Write method is used in conjunction with the Response class to send data back."", ""Response"")"
You can call write() multiple times to add more data to the response body.,"(""Write"", ""The write() method is used to add data to the response body, indicating a relationship between the two."", ""Response Body""); (""Response"", ""The response body is a part of the response, indicating a relationship between the two."", ""Response Body"")"
The write() method is asynchronous and returns immediately after queuing up the string or buffer.,"(""Write()"", ""The Write() method is related to string because it queues up the string or buffer."", ""string""); (""Write()"", ""The Write() method is related to string because it queues up the string or buffer, but string is not a defined entity type."", ""string"")"
This is done by calling the end() method as shown in the previous example.,NULL
The end() method can take either a String or Buffer as parameter.,"(""End"", ""The End method can take a String as a parameter, indicating a clear relationship between the two."", ""String"")"
To close an HTTP server you simply call its close() method like this:,NULL
"The close() method executes asynchronously, so the HTTP server may not be fully closed by the time the close() method returns.","(""Close"", ""The close() method is related to the HTTP server because it is used to close the HTTP server."", ""Http Server"")"
"You can pass a close handler as parameter to the close() method, to be notified when the HTTP server is fully closed.","(""Close"", ""The close() method is related to the HTTP Server as it is used to close the server."", ""HTTP Server""); (""Close Handler"", ""The close handler is related to the HTTP Server as it is notified when the server is fully closed."", ""HTTP Server"")"
"You can just unzip the zip file and add these JAR files to the classpath of your Java application, and you are good to go.","(""JAR"", ""JAR files are added to the classpath"", ""classpath""); (""Java"", ""Java application uses the classpath"", ""classpath""); (""Java"", ""Java is used to create the application"", ""application""); (""zip file"", ""JAR files are contained in the zip file"", ""JAR"")"
As long as the JAR files are available on the classpath of your application.,"(""JAR"", ""The JAR files are related to the CLASSPATH because they need to be available on it."", ""CLASSPATH""); (""CLASSPATH"", ""The CLASSPATH is related to the APPLICATION because it is a part of the application's configuration."", ""APPLICATION"")"
You connect to a remote server by calling the connect() method.,NULL
You obtain a reference to the NetSocket connected to the remote server via the AsyncResult instance passed to the handler's handle() method.,NULL
You can write data to the TCP connection via the NetSocket write() method.,"(""NetSocket"", ""The NetSocket class has a relationship with the write() method because it is stated that you can write data to the TCP connection via the NetSocket write() method, indicating that write() is a method of the NetSocket class."", ""write()""); (""NetSocket"", ""The NetSocket class has a relationship with the TCP package because it is stated that you can write data to the TCP connection via the NetSocket write() method, indicating that NetSocket is used in the context of TCP connections."", ""TCP"")"
The data may not be sent by the time the write() method returns.,NULL
The Handler's handle() method will get called when data is received from the remote server.,NULL
You close the TCP client by calling the close() method of the NetClient instance.,"(""NetClient"", ""The close() method is called on the NetClient instance, indicating a relationship between the NetClient class and the close() method."", ""close()"")"
"Again, the NetClient's close() method is asynchronous, so the underlying TCP connection may not yet be closed by the time the close() method returns.",NULL
"Once you have created the TCP server, you can start it using its listen() method.",NULL
This example starts the server and instructs it to listen on TCP port 10.000 .,"(""Server"", ""The Server is related to TCP because it is instructed to listen on a TCP port."", ""TCP""); (""Server"", ""The Server is related to Port because it is instructed to listen on a specific port."", ""Port"")"
The NetServer class contains more versions of the listen() method which gives you different options for starting the TCP server.,"(""NetServer"", ""The NetServer class contains the listen() method, indicating a clear containment relationship between the two entities."", ""listen()""); (""listen()"", ""The listen() method is used for starting the TCP server, indicating a clear causal relationship between the two entities."", ""TCP server"")"
The handle() method of the connect handler is called whenever a new TCP connection is created by a client of the TCP server.,"(""Handle()"", ""The handle() method is part of the connect handler, indicating a relationship between the two."", ""Connect Handler""); (""Connect Handler"", ""The connect handler is associated with the TCP server, as it handles new TCP connections created by clients of the server."", ""TCP Server""); (""TCP"", ""The TCP package is related to the TCP server, as the server creates new TCP connections."", ""TCP Server""); (""TCP"", ""The TCP package is also related to the connect handler, as the handler is involved in creating new TCP connections."", ""Connect Handler""); (""Handle()"", ""The handle() method is related to the TCP server, as it is called when the server creates a new TCP connection."", ""TCP Server"")"
The NetSocket object passed as parameter to the handle() method gives access to the incoming connection (socket etc.,NULL
You can do so via the NetSocket instance passed to the connect handler's handle() method.,NULL
The NetSocket class contains more versions of the write() method which enables you to write e.g.,NULL
When you are finished with the TCP server you can close it using its close() method.,NULL
"Closing the TCP server is an asynchronous actions, so the close() method may exit before the TCP server is actually closed.",NULL
"If you need to be notified of when the TCP server has shut down, you can pass a Handler to the close() method.","(""Handler"", ""The Handler is passed to the close() method, indicating a relationship between the two, where the Handler is used as an argument for the close() method."", ""close()""); (""TCP server"", ""The TCP server has a close() method, indicating that the close() method belongs to or is associated with the TCP server, showing a relationship between the two."", ""close()"")"
"The setTimer() method takes a time interval in milliseconds as first parameter, and a Handler implementation as second parameter.",NULL
The Handler's handle() method is called when the time interval has elapsed.,NULL
This timer ID is also passed as parameter to the Handler's handle() method.,"(""Handler"", ""The Handler class has a method called Handle, indicating a strong relationship between the two."", ""Handle"")"
"The setPeriodic() method takes a time interval in milliseconds as first parameter, and a Handler implementation as second parameter.",NULL
The Handler's handle() method is called every time the time interval has elapsed.,NULL
This timer ID is also passed to the Handler's handle() method whenever it is called.,"(""Handler"", ""The Handler class has a method called Handle, indicating a relationship between the two entities."", ""Handle"")"
Support for Scala and Clojure should be arriving soon (it was originally planned for v. 3.0 but I am not sure if they got it in).,NULL
You don't have to learn both a language and a new platform (e.g.,NULL
You will see later in this tutorial how to use both versions of the start() method.,NULL
Here is an example of overriding the stop() method in your own verticle:,NULL
Sending messages via the event bus can be done via either the send() or publish() method on the event bus.,"(""Event Bus"", ""The Event Bus and Send are related because Send is a method on the Event Bus."", ""Send""); (""Event Bus"", ""The Event Bus and Publish are related because Publish is a method on the Event Bus."", ""Publish"")"
The send() method sends the message to just one of the listening verticles.,NULL
This is useful for distributing work load over multiple verticles (e.g.,NULL
"The first message is sent via the publish() method, so both consumers receive the message.",NULL
"The second message is sent via the send() method, so only one of the consumers will receive the message.",NULL
A verticle has a start() and a stop() method which are called when the verticle is deployed and when it is undeployed.,"(""Verticle"", ""The Verticle class has a Start method which is called when the verticle is deployed."", ""Start"")"
"You should perform any necessary initialization work inside the start() method, and any necessary cleanup work inside the stop() method.",NULL
"For instance, you can specify how many verticle instances of a given verticle class to deploy.",NULL
The startsWith() and endsWith() methods check if the String starts with a certain substring,"(""String"", ""The startsWith() method is related to the String class because it is used to check if the String starts with a certain substring"", ""startsWith()""); (""String"", ""The endsWith() method is related to the String class because it is used to check if the String ends with a certain substring"", ""endsWith()"")"
In the above example the two methods getTime() and setTime() can access the time member variable,"(""GetTime()"", ""GetTime() method can access the time member variable"", ""Time"")"
The convertToInt() method has the same signature as the deserialize() method of the Deserializer deserialize() method,"(""ConvertToInt"", ""The convertToInt() method has the same signature as the deserialize() method, indicating a clear relationship between the two methods"", ""Deserialize""); (""Deserialize"", ""The deserialize() method is part of the Deserializer class, indicating a clear relationship between the method and the class"", ""Deserializer"")"
Deque.removeLast() is different from pollLast() which returns null if the Deque is empty,"(""Deque"", ""Deque has a method called removeLast()"", ""removeLast""); (""Deque"", ""Deque has a method called pollLast()"", ""pollLast"")"
The floor() method does the opposite of the ceiling() method meaning it returns the greatest element that is less than or equal to the given parameter value,NULL
You can also specify METHOD or FIELD or you can leave the target out alltogether so the annotation can be used for both classes methods and fields,"(""METHOD"", ""Both METHOD and FIELD are related as they are alternatives for specifying the target of an annotation."", ""FIELD""); (""CLASSES"", ""CLASSES and METHOD are related because the annotation can be used for both classes and methods."", ""METHOD""); (""CLASSES"", ""CLASSES and FIELD are related because the annotation can be used for both classes and fields."", ""FIELD""); (""ANNOTATION"", ""ANNOTATION is related to METHOD because the annotation can be used to specify the target as a method."", ""METHOD""); (""ANNOTATION"", ""ANNOTATION is related to FIELD because the annotation can be used to specify the target as a field."", ""FIELD"")"
For instance finest() finer() fine() info() warning() and severe() each corresponds to one of the log levels,"(""Finest"", ""Finest and Finer are related as they are both log levels and are mentioned together in the text"", ""Finer""); (""Finer"", ""Finer and Fine are related as they are both log levels and are mentioned together in the text"", ""Fine""); (""Fine"", ""Fine and Info are related as they are both log levels and are mentioned together in the text"", ""Info""); (""Info"", ""Info and Warning are related as they are both log levels and are mentioned together in the text"", ""Warning""); (""Warning"", ""Warning and Severe are related as they are both log levels and are mentioned together in the text"", ""Severe""); (""Finest"", ""Finest and Fine are related as they are both log levels and are mentioned together in the text"", ""Fine""); (""Finest"", ""Finest and Info are related as they are both log levels and are mentioned together in the text"", ""Info""); (""Finest"", ""Finest and Warning are related as they are both log levels and are mentioned together in the text"", ""Warning""); (""Finest"", ""Finest and Severe are related as they are both log levels and are mentioned together in the text"", ""Severe""); (""Finer"", ""Finer and Info are related as they are both log levels and are mentioned together in the text"", ""Info""); (""Finer"", ""Finer and Warning are related as they are both log levels and are mentioned together in the text"", ""Warning""); (""Finer"", ""Finer and Severe are related as they are both log levels and are mentioned together in the text"", ""Severe""); (""Fine"", ""Fine and Warning are related as they are both log levels and are mentioned together in the text"", ""Warning""); (""Fine"", ""Fine and Severe are related as they are both log levels and are mentioned together in the text"", ""Severe""); (""Info"", ""Info and Severe are related as they are both log levels and are mentioned together in the text"", ""Severe"")"
You can encrypt or decrypt data into an existing byte array by passing the destination byte array as parameter to the update() and or doFinal() method,NULL
Second if the lock is locked the threads are blocked in the wait() call inside the while(isLocked) loop in the lock() method,"(""Lock"", ""The Lock class has a method Wait, and the threads are blocked in the wait() call inside the while(isLocked) loop in the lock() method, indicating a clear relationship between the Lock class and the Wait method."", ""Wait"")"
Deque.removeFirst() is different from pollFirst() which returns null if the Deque is empty,NULL
The peek() works like the element() method except it does not throw an exception if the Queue is empty,"(""Peek"", ""The peek() method is related to the Queue class because it operates on the Queue."", ""Queue""); (""Element"", ""The element() method is related to the Queue class because it operates on the Queue."", ""Queue"")"
The addAll() method takes a Collection as parameter so you can pass either a List or Java Set as parameter,"(""addAll()"", ""The addAll() method takes a Collection as parameter, indicating that addAll() is related to Collection as it operates on it"", ""Collection""); (""addAll()"", ""The addAll() method can take a List as parameter, indicating that addAll() is related to List as it can operate on it"", ""List"")"
The Java Properties class java.util.Properties is like a Java Map of Java String key and value pairs,"(""Java Properties"", ""Java Properties is compared to Java Map, indicating a relationship between the two classes"", ""Java Map""); (""Java Properties"", ""Java Properties uses Java String for key and value pairs, indicating a relationship between the two classes"", ""Java String""); (""Java Properties"", ""java.util.Properties is another name for Java Properties, indicating an identity relationship between the two"", ""java.util.Properties""); (""Java Map"", ""Java Map can have Java String as key and value pairs, indicating a possible relationship between the two classes"", ""Java String"")"
java.io.InputStream means that you use the Java FileInputStream as an InputStream (FileInputStream behaves like an InputStream),"(""FileInputStream"", ""FileInputStream behaves like an InputStream, indicating a clear inheritance relationship between the two classes"", ""InputStream""); (""InputStream"", ""InputStream is part of the java.io package, indicating a containment relationship between the package and the class"", ""java.io"")"
Since PipedInputStream is a subclass of InputStream PipedInputStream has the same basic methods and use patterns as an InputStream,NULL
Choice.select(int pos) is done by having a different thread call the Selector.wakeup() method on the Selector which the first thread has called select() on,"(""Choice"", ""Choice has a method called select"", ""select""); (""Selector"", ""Selector has a method called wakeup"", ""wakeup"")"
While isLocked is true the thread calling lock() is parked waiting in the wait() call,NULL
The AtomicInteger class is located in the java.util.concurrent.atomic package so the full class name is java.util.concurrent.atomic.AtomicInteger,"(""AtomicInteger"", ""The AtomicInteger class is located in the java.util.concurrent.atomic package, indicating that AtomicInteger is part of the java.util.concurrent.atomic package"", ""java.util.concurrent.atomic""); (""java.util.concurrent.atomic.AtomicInteger"", ""java.util.concurrent.atomic.AtomicInteger is the full class name, showing it belongs to the java.util.concurrent.atomic package"", ""java.util.concurrent.atomic"")"
But no thread can actually execute unlock() until the thread waiting in lock() leaves the outer synchronized block,"(""Thread"", ""A thread executes a lock, indicating a relationship between the two entities as the thread is waiting in the lock"", ""Lock""); (""Thread"", ""A thread can execute unlock, showing that the thread is related to the unlock method as it is the one performing the unlock action"", ""Unlock"")"
The System class also has a getProperty() and setProperty() method which are shortcuts to the Properties getProperty() and setProperty() methods of the System Properties instance.,"(""System"", ""The System class has a getProperty() method which is a shortcut to the Properties getProperty() method, indicating a relationship between the System class and the getProperty() method."", ""getProperty()""); (""System"", ""The System class has a setProperty() method which is a shortcut to the Properties setProperty() method, indicating a relationship between the System class and the setProperty() method."", ""setProperty()""); (""Properties"", ""The getProperty() method is a part of the Properties class, indicating a relationship between the Properties class and the getProperty() method."", ""getProperty()""); (""Properties"", ""The setProperty() method is a part of the Properties class, indicating a relationship between the Properties class and the setProperty() method."", ""setProperty()"")"
Closeable.close() closes the Selector and invalidates all SelectionKey instances registered with this Selector,"(""Closeable"", ""The Closeable class has a method close() that closes the Selector, indicating a relationship between the two entities"", ""Selector""); (""close()"", ""The method close() closes the Selector, indicating a direct relationship between the method and the Selector entity"", ""Selector""); (""Selector"", ""The Selector has registered instances of SelectionKey, indicating a relationship between the two entities"", ""SelectionKey"")"
Any.stream() is similar to how you obtain an Iterator by calling the items.iterator() method but a Stream is a different animal than an Iterator,"(""Stream"", ""Stream and Iterator are related because they are both used for iteration purposes, but they are different in their functionality and properties"", ""Iterator""); (""Stream"", ""Stream is related to stream() because stream() is a method used to obtain a Stream"", ""stream()"")"
An interesting aspect to note about the BufferedInputStream is that is supports the mark() and reset() methods inherited from the InputStream,"(""BufferedInputStream"", ""The BufferedInputStream is related to the mark() method because it supports and inherits this method."", ""mark()""); (""BufferedInputStream"", ""The BufferedInputStream is related to the reset() method because it supports and inherits this method."", ""reset()""); (""BufferedInputStream"", ""The BufferedInputStream is related to the InputStream because it inherits methods from the InputStream."", ""InputStream""); (""mark()"", ""The mark() method is related to the InputStream because it is inherited from the InputStream."", ""InputStream"")"
"You can search for an object on the stack to get it's index, using the search() method. The object's equals() method is called on every object on the Stack to determine if the searched-for object is present on the Stack.","(""Stack"", ""The search() method is used in relation to the Stack class to find an object on it."", ""search()""); (""Stack"", ""The equals() method is used in relation to the Stack class to determine if a searched-for object is present on it."", ""equals()"")"
Actually java.sql.Timestamp extends java.util.Date so anything you can do with a java.util.Date you can also do with a java.sql.Timestamp,NULL
"If the Deque is empty, removeFirst() will throw an exception. This is different from pollFirst() which returns null if the Deque is empty.","(""Deque"", ""The Deque class has a method called removeFirst, indicating a relationship between the two."", ""removeFirst""); (""Deque"", ""The Deque class has a method called pollFirst, indicating a relationship between the two."", ""pollFirst"")"
You read bytes from a Java ByteArrayInputStream just like you would from a regular InputStream via its read() method,"(""ByteArrayInputStream"", ""ByteArrayInputStream is a type of InputStream, indicating a subclass relationship between the two classes"", ""InputStream""); (""ByteArrayInputStream"", ""ByteArrayInputStream has a read() method, indicating that the read() method is a part of the ByteArrayInputStream class"", ""read()"")"
You create a DateFormat using the getDateInstance() and getTimeInstance() method of the DateFormat class,"(""DateFormat"", ""The DateFormat class has a getDateInstance() method, indicating a clear relationship between the two."", ""getDateInstance()""); (""DateFormat"", ""The DateFormat class has a getTimeInstance() method, indicating a clear relationship between the two."", ""getTimeInstance()"")"
You can use addBatch() and executeBatch() methods to execute batch updates.,NULL
The Java FileOutputStream class is a subclass of Java OutputStream meaning you can use a FileOutputStream as an OutputStream,"(""FileOutputStream"", ""The Java FileOutputStream class is a subclass of Java OutputStream, indicating an inheritance relationship between the two classes."", ""OutputStream"")"
In the example above I passed it a FileInputStream connected to a file named myfile.zip,NULL
java.util.logging.LogRecord Throwable is either passed as parameter to a Logger log method or set directly on a LogRecord which is then passed to a Logger,"(""Logger"", ""The Logger class has a method called log, which establishes a relationship between the two entities."", ""log""); (""LogRecord"", ""A Throwable is set directly on a LogRecord, indicating a relationship between the LogRecord and the Throwable entities."", ""Throwable""); (""Logger"", ""A LogRecord is passed to a Logger, establishing a relationship between the two entities."", ""LogRecord"")"
As you can see a new StringBuilder is created passing along the first String to its constructor and the second String to its append() method before finally calling the toString() method,"(""StringBuilder"", ""The StringBuilder class is related to the String class because a new StringBuilder is created passing along a String to its constructor and the append() method is called with a String."", ""String""); (""StringBuilder"", ""The StringBuilder class is related to the append() method because the append() method is called on a StringBuilder object."", ""append()""); (""StringBuilder"", ""The StringBuilder class is related to the toString() method because the toString() method is called on a StringBuilder object."", ""toString()""); (""StringBuilder"", ""The StringBuilder class is related to its constructor because a new StringBuilder is created using its constructor."", ""constructor""); (""String"", ""The String class is related to the append() method because the append() method is called with a String."", ""append()""); (""String"", ""The String class is related to the toString() method because the result of the toString() method is a String."", ""toString()"")"
A thread cannot call wait() notify() or notifyAll() without holding the lock on the object the method is called on,"(""Thread"", ""A thread cannot call wait() without holding the lock on the object the method is called on, indicating a relationship between the Thread class and the Wait method"", ""Wait""); (""Thread"", ""A thread cannot call notify() without holding the lock on the object the method is called on, indicating a relationship between the Thread class and the Notify method"", ""Notify"")"
The AtomicReferenceArray in the java.util.concurrent.atomic package is an array of object references which can be updated atomically,NULL
Spin locks and the methods wait() and notify() are covered in more detail in the text Thread Signaling,"(""Wait"", ""The source entity Wait and the target entity Spin Locks are related because they are both mentioned together in the context of Thread Signaling, suggesting that Wait is a method that can be used with Spin Locks."", ""Spin Locks""); (""Notify"", ""The source entity Notify and the target entity Spin Locks are related because they are both mentioned together in the context of Thread Signaling, suggesting that Notify is a method that can be used with Spin Locks."", ""Spin Locks""); (""Wait"", ""The source entity Wait and the target entity Thread Signaling are related because Wait is a method covered in more detail in the text Thread Signaling."", ""Thread Signaling""); (""Notify"", ""The source entity Notify and the target entity Thread Signaling are related because Notify is a method covered in more detail in the text Thread Signaling."", ""Thread Signaling"")"
The AtomicLong class is located in the java.util.concurrent.atomic package so the full class name is java.util.concurrent.atomic.AtomicLong,NULL
"The Arrays class contains a set of methods called binarySearch(). This method helps you perform a binary search in an array. The array must first be sorted. You can do so yourself, or via the Arrays.sort() method covered earlier in this text.","(""Arrays"", ""The Arrays class contains the binarySearch() method, indicating a relationship between the two entities as the method is part of the class."", ""binarySearch()""); (""Arrays"", ""The Arrays class contains the Arrays.sort() method, indicating a relationship between the two entities as the method is part of the class."", ""Arrays.sort()"")"
The Java Reader (java.io.Reader) and Java Writer class (java.io.Writer) in Java IO work much like the InputStream and OutputStream with the exception that Reader and Writer are character based,"(""Java Reader"", ""Java Reader is a class in the java.io.Reader package"", ""java.io.Reader""); (""Java Writer"", ""Java Writer is a class in the java.io.Writer package"", ""java.io.Writer""); (""Java Reader"", ""Java Reader and InputStream are compared in terms of their functionality"", ""InputStream""); (""Java Writer"", ""Java Writer and OutputStream are compared in terms of their functionality"", ""OutputStream""); (""java.io.Reader"", ""java.io.Reader is a package in the java.io package"", ""java.io""); (""java.io.Writer"", ""java.io.Writer is a package in the java.io package"", ""java.io"")"
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicInteger,"(""GetAndIncrement"", ""GetAndIncrement method works with AtomicInteger class, utilizing its value"", ""AtomicInteger""); (""IncrementAndGet"", ""IncrementAndGet method works with AtomicInteger class, utilizing its value"", ""AtomicInteger""); (""GetAndAdd"", ""GetAndAdd method works with AtomicInteger class, utilizing its value"", ""AtomicInteger""); (""AddAndGet"", ""AddAndGet method works with AtomicInteger class, utilizing its value"", ""AtomicInteger""); (""GetAndIncrement"", ""GetAndIncrement and GetAndAdd methods are similar in functionality, but GetAndIncrement adds 1"", ""GetAndAdd"")"
"The tailSet() method works the same way as the headSet() method, except it returns all elements that are equal to or higher than the given parameter element",NULL
If a different thread calls wakeup() and no thread is currently blocked inside select() the next thread that calls select() will wake up immediately,NULL
HashMap maps a key and a value. It does not guarantee any order of the elements stored internally in the map.TreeMap also maps a key and a value. Furthermore it guarantees the order in which keys or values are iterated - which is the sort order of the keys or values.,"(""HashMap"", ""Both HashMap and TreeMap are related as they are both map classes that store key-value pairs, but TreeMap provides an additional guarantee of order."", ""TreeMap""); (""HashMap"", ""HashMap is related to the concept of a map as it implements a mapping of keys to values."", ""map"")"
It is worth noting that both unlockRead() and unlockWrite() calls notifyAll() rather than notify(),"(""UnlockRead"", ""UnlockRead calls NotifyAll, indicating a relationship between the two methods"", ""NotifyAll"")"
Notice the call to update() and then doFinal() for these two blocks of data,NULL
You simply pass an offset and length to the update() and or doFinal() method,NULL
The Java Collections addAll() method can add a variable number of elements to a Collection (typically either a List or a Set,"(""Java Collections"", ""The Java Collections package contains the addAll() method"", ""addAll()""); (""addAll()"", ""The addAll() method can add elements to a Collection"", ""Collection""); (""Collection"", ""A Collection can be either a List or other types of collections"", ""List""); (""Collection"", ""A Collection can be either a Set or other types of collections"", ""Set""); (""Java Collections"", ""Java Collections is a package that contains the Collection class"", ""Collection""); (""Java Collections"", ""Java Collections is a package that contains the List class"", ""List"")"
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block,"(""Thread"", ""A thread is awakened and then calls wait(), indicating a relationship between the thread and the wait() call"", ""Wait""); (""Thread"", ""The thread calling notify() affects the thread that is waiting, indicating a relationship between the two threads"", ""Notify""); ("" Notify"", ""The thread calling notify() has to leave its synchronized block, indicating a relationship between the notify() call and the synchronized block"", ""Synchronized"")"
java.lang.ThreadLocal is possible to set an initial value for a Java ThreadLocal which will get used the first time get() is called before set() has been called with a new value,"(""Java ThreadLocal"", ""Java ThreadLocal is related to get because get is a method that can be called on a Java ThreadLocal object"", ""get""); (""Java ThreadLocal"", ""Java ThreadLocal is related to set because set is a method that can be called on a Java ThreadLocal object to set a new value"", ""set""); (""ThreadLocal"", ""ThreadLocal is related to java.lang because ThreadLocal is a class in the java.lang package"", ""java.lang""); (""java.lang"", ""java.lang is related to ThreadLocal because java.lang is the package where ThreadLocal is defined"", ""ThreadLocal""); (""get"", ""get is related to Java ThreadLocal because get is a method that is used to retrieve the value of a Java ThreadLocal object"", ""Java ThreadLocal"")"
The Reader and Writer classes are stream oriented classes that enable a Java application to read and write streams of characters,"(""Reader"", ""The Reader class is used in a Java application"", ""Java""); (""Writer"", ""The Writer class is used in a Java application"", ""Java"")"
If the doNotify() method had called notifyAll() instead of notify() all waiting threads had been awakened and checked for signals in turn,NULL
The run() method is what is executed by the thread after you call start(),NULL
You can convert Strings to uppercase and lowercase using the methods toUpperCase() and toLowerCase(),"(""Strings"", ""The Strings class has a method called toUpperCase() which can be used to convert strings to uppercase"", ""toUpperCase()""); (""Strings"", ""The Strings class has a method called toLowerCase() which can be used to convert strings to lowercase"", ""toLowerCase()"")"
To make the Calculator class thread safe you could have declared the getValue() setValue() and add() methods synchronized,"(""Calculator"", ""The Calculator class contains the getValue() method, indicating a relationship between the two."", ""getValue()""); (""Calculator"", ""The Calculator class contains the setValue() method, indicating a relationship between the two."", ""setValue()"")"
"If the call to take() happens before the call to release() the thread calling release() will still know that take() was called, because the signal is stored internally in the signal variable.","(""Take"", ""The Take method is related to the Signal class because it uses the signal variable to store information internally."", ""Signal""); (""Release"", ""The Release method is related to the Signal class because it checks the signal variable to know if Take was called."", ""Signal"")"
The getAndAdd() method does the same as the addAndGet() method except the getAndAdd() method returns the value of the element before a value is added to it,NULL
Adding and getting elements to a generic Map is done using the put() and get() methods just like you have always done,"(""Map"", ""The Map class uses the put() method to add elements"", ""put()""); (""Map"", ""The Map class uses the get() method to retrieve elements"", ""get()"")"
When guarding a critical section with a ReadWriteLock and the critical section may throw exceptions it is important to call the readUnlock() and writeUnlock() methods from inside a finallyclause,"(""ReadWriteLock"", ""readUnlock() is a method related to the ReadWriteLock class as it is used to unlock read operations in the lock"", ""readUnlock()""); (""ReadWriteLock"", ""writeUnlock() is a method related to the ReadWriteLock class as it is used to unlock write operations in the lock"", ""writeUnlock()"")"
The FileChannel class has a transferTo() and a transferFrom() method which does this for you,"(""FileChannel"", ""The FileChannel class has a transferTo() method, indicating a containment relationship where transferTo() is a method of the FileChannel class"", ""transferTo()"")"
To generate a KeyPair with a KeyPairGenerator you call the generateKeyPair() method,"(""KeyPairGenerator"", ""The KeyPairGenerator uses the generateKeyPair method to generate a KeyPair"", ""generateKeyPair""); (""KeyPair"", ""The KeyPair is generated by the KeyPairGenerator"", ""KeyPairGenerator"")"
You can convert a OutputStream to a character based Writer using the Java OutputStreamWriter class,"(""OutputStream"", ""OutputStream is converted to a character based Writer using the Java OutputStreamWriter class"", ""OutputStreamWriter"")"
If you created your SortedSet with a Comparator you can obtain that Comparator via the SortedSet comparator() method,"(""SortedSet"", ""The SortedSet class has a method called comparator() that is related to it, as it is used to obtain the Comparator used by the SortedSet"", ""comparator()""); (""comparator()"", ""The comparator() method is related to the Comparator class, as it returns the Comparator used by the SortedSet"", ""Comparator"")"
"In order to update the database you need to use a Statement. But, instead of calling the executeQuery() method, you call the executeUpdate() method.","(""Statement"", ""The Statement class has a method called executeQuery(), indicating a relationship between the two."", ""executeQuery()""); (""Statement"", ""The Statement class has a method called executeUpdate(), indicating a relationship between the two."", ""executeUpdate()"")"
Instances of this class are used together with UDP DatagramSockets and normal Socket and ServerSocket,"(""Class"", ""They are used together, suggesting a relationship where instances of the class are utilized in conjunction with UDP DatagramSockets"", ""UDP DatagramSockets""); (""Class"", ""They are used together, suggesting a relationship where instances of the class are utilized in conjunction with normal Sockets"", ""Socket"")"
The Java InputStreamReader class java.io.InputStreamReader wraps a Java InputStream thereby turning the byte based InputStream into a character based Reader,"(""InputStreamReader"", ""InputStreamReader wraps a Java InputStream, thereby establishing a relationship between the two classes"", ""InputStream""); (""InputStreamReader"", ""InputStreamReader turns the byte based InputStream into a character based Reader, indicating a relationship between the InputStreamReader class and the Reader class"", ""Reader""); (""InputStreamReader"", ""InputStreamReader is part of the java.io package, establishing a relationship between the InputStreamReader class and the package"", ""java.io""); (""InputStream"", ""InputStream is part of the java.io package, establishing a relationship between the InputStream class and the package"", ""java.io"")"
The Math is located in the java.lang package and not in the java.math package,"(""Math"", ""The Math class is located in the java.lang package"", ""java.lang"")"
The Java StringReader class enables you to turn an ordinary String into a Reader,"(""StringReader"", ""The StringReader class is related to the String class because it uses an ordinary String as input to create a Reader."", ""String"")"
All elements inserted into the PriorityBlockingQueue must implement the java.lang.Comparable interface,NULL
As mentioned earlier the DataInputStream class is often used together with a DataOutputStream,NULL
java.io.FileReader works much like the FileInputStream except the FileInputStream reads bytes whereas the FileReader reads characters,"(""FileReader"", ""FileReader and FileInputStream are related because they are both used for reading data, but they differ in the type of data they read, with FileReader reading characters and FileInputStream reading bytes"", ""FileInputStream""); (""FileReader"", ""FileReader is part of the java.io package, indicating a relationship between the class and the package"", ""java.io"")"
Deque.pollLast() is different than removeLast() which throws an exception if the Deque is empty,"(""Deque"", ""Deque has a method called pollLast"", ""pollLast""); (""Deque"", ""Deque has a method called removeLast"", ""removeLast"")"
The java.util.concurrent.locks package has the following implementations of the Lock interface,NULL
The methods start() and end() will give the indexes into the text where the found match starts and ends,NULL
The tailSet() method works the same way as the headSet() method except it returns all elements that are equal to or higher than the given parameter element,NULL
A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object,"(""Thread"", ""A thread calls wait() on an object, indicating a relationship between the thread and the object it is waiting on"", ""Object""); (""Thread"", ""A thread calls wait() on an object, indicating a relationship between the thread and the wait method"", ""Wait""); (""Thread"", ""Another thread calls notify() on an object to activate a waiting thread, indicating a relationship between the thread and the notify method"", ""Notify""); (""Object"", ""Wait is called on an object, indicating a relationship between the object and the wait method"", ""Wait"")"
Here is an example of listing all files in a directory via the Java File list() and listFiles() methods,"(""File"", ""The File class has a method called list(), indicating a relationship between the two."", ""list()""); (""File"", ""The File class has a method called listFiles(), indicating a relationship between the two."", ""listFiles()"")"
You can peek at the element at the head of a Queue without taking the element out of the Queue. This is done via the Queue element() or peek() methods.,"(""Queue"", ""The Queue class has an element() method to peek at the element at the head of the Queue without taking the element out of the Queue."", ""element()"")"
The methods Class.getField(String name) and Class.getFields() methods only return public fields so they wont work,"(""Class"", ""The getField method is a part of the Class, indicating a clear relationship between the two entities."", ""getField""); (""Class"", ""The getFields method is a part of the Class, indicating a clear relationship between the two entities."", ""getFields"")"
When you do so you can call connect() read() and write() in asynchronous mode,"(""Connect"", ""These two methods are related because they are both mentioned as methods that can be called in asynchronous mode."", ""Read""); (""Connect"", ""These two methods are related because they are both mentioned as methods that can be called in asynchronous mode."", ""Write"")"
"if you are writing a component that needs to read input from a stream, try to make our component depend on an InputStream, rather than any of it's subclasses (e.g. FileInputStream).","(""component"", ""the component depends on an InputStream to read input from a stream"", ""InputStream""); (""InputStream"", ""FileInputStream is a subclass of InputStream"", ""FileInputStream"")"
For inexplicable reasons it is possible for threads to wake up even if notify() and notifyAll() has not been called,"(""Threads"", ""Threads can be woken up by the notify method, suggesting a relationship between the two entities"", ""Notify"")"
The applyLocalizedPattern() does the same as applyPattern() except it interpretes the characters in the pattern according to the Locale the DecimalFormat was created with,NULL
"You can access these two parts of the duration using the Duration methods:getNano(),getSeconds()","(""Duration"", ""Duration is related to getNano() because getNano() is a method of the Duration class"", ""getNano()"")"
If you look back at the doSynchronized() method you will notice that the comment between lock() and unlock() states that the code in between these two calls take a long time to execute,"(""DoSynchronized"", ""The DoSynchronized method contains a call to the Lock method, indicating a relationship between the two."", ""Lock""); (""DoSynchronized"", ""The DoSynchronized method contains a call to the Unlock method, indicating a relationship between the two."", ""Unlock"")"
When the thread calling lock() right after calls queueObject.wait() it will remain blocked until some other thread calls unlock() which may never happen,"(""Lock"", ""The Lock class is related to the QueueObject class because the lock() method is called right before the wait() method on QueueObject, indicating a synchronization relationship between the two."", ""QueueObject""); (""Lock"", ""The Lock class is related to the Wait method because the lock() method is called right before the wait() method, indicating that the lock is acquired before waiting."", ""Wait""); (""Unlock"", ""The Unlock method is related to the Lock method because the unlock() method is called to release the lock acquired by the lock() method, indicating a complementary relationship between the two."", ""Lock"")"
Creating a pipe using Java IO is done via the PipedOutputStream and PipedInputStream classes. A PipedInputStream should be connected to a PipedOutputStream. The data written to the PipedOutputStream by one thread can be read from the connected PipedInputStream by another thread.,"(""PipedOutputStream"", ""A PipedInputStream should be connected to a PipedOutputStream, indicating a relationship between the two classes"", ""PipedInputStream"")"
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block.,"(""Thread"", ""A thread is related to the wait() call as it is the entity that is waiting."", ""Wait""); (""Thread"", ""A thread is related to the notify() call as it is the entity that is being notified."", ""Notify""); (""Thread"", ""A thread is related to a synchronized block as it is the entity that is executing the block."", ""Synchronized""); (""Wait"", ""The wait() call is related to the notify() call as the thread calling notify() affects the thread waiting in the wait() call."", ""Notify""); (""Wait"", ""The wait() call is related to a synchronized block as the thread waiting in the wait() call is blocked until the thread calling notify() has left its synchronized block."", ""Synchronized"")"
"TreeSet also guarantees the order of the elements when iterated, but the order is the sorting order of the elements. In other words, the order in which the elements whould be sorted if you used a Collections.sort() on a List or array containing these elements. This order is determined either by their natural order (if they implement Comparable), or by a specific Comparator implementation","(""TreeSet"", ""TreeSet is related to Collections because it uses the Collections.sort() method to determine the order of elements"", ""Collections""); (""TreeSet"", ""TreeSet is related to Comparable because it uses the natural order of elements if they implement Comparable"", ""Comparable""); (""TreeSet"", ""TreeSet is related to Comparator because it uses a specific Comparator implementation to determine the order of elements"", ""Comparator""); (""Collections"", ""Collections is related to Comparable because the sort method uses the natural order of elements if they implement Comparable"", ""Comparable"")"
"You can also obtain an Iterator from many of the Java Collection data structures, e.g. a List, Set, Map, Queue, Deque or Map.","(""Iterator"", ""Iterator is obtained from many of the Java Collection data structures"", ""Collection""); (""Iterator"", ""Iterator can be obtained from a List"", ""List""); (""Iterator"", ""Iterator can be obtained from a Set"", ""Set""); (""Iterator"", ""Iterator can be obtained from a Map"", ""Map""); (""Iterator"", ""Iterator can be obtained from a Queue"", ""Queue""); (""Iterator"", ""Iterator can be obtained from a Deque"", ""Deque""); (""List"", ""List is one of the Java Collection data structures"", ""Collection""); (""Set"", ""Set is one of the Java Collection data structures"", ""Collection""); (""Map"", ""Map is one of the Java Collection data structures"", ""Collection""); (""Queue"", ""Queue is one of the Java Collection data structures"", ""Collection"")"
Instead the critical section is guarded by the lock.lock() and lock.unlock() calls,NULL
The methods mark() and reset() methods are typically used when implementing parsers,"(""Mark"", ""The Mark method is related to Parsers because it is typically used when implementing parsers"", ""Parsers"")"
Once you have obtained a Field reference you can get and set its values using the Field.get() and Field.set()methods like this,"(""Field"", ""Field and Field.get() are related because Field.get() is a method of the Field class"", ""Field.get()""); (""Field"", ""Field and Field.set() are related because Field.set() is a method of the Field class"", ""Field.set()"")"
The poll() and remove() both removes the first element in the Queue,"(""Poll"", ""The poll() method is related to the Queue class because it removes the first element from the Queue"", ""Queue""); (""Remove"", ""The remove() method is related to the Queue class because it also removes the first element from the Queue"", ""Queue"")"
Any other thread calling lock() will be blocked until the thread that locked the lock calls unlock(),NULL
The java.text.DateFormat class is used to format dates as strings according to a specific Locale,"(""DateFormat"", ""The DateFormat class is used to format dates according to a specific Locale, indicating a relationship between the two classes"", ""Locale""); (""java.text"", ""The DateFormat class is located in the java.text package, indicating a containment relationship between the package and the class"", ""DateFormat"")"
The InputStream class has two methods called mark() and reset() which subclasses of InputStream may or may not support,"(""InputStream"", ""InputStream has a method called mark() which subclasses of InputStream may or may not support"", ""mark()""); (""InputStream"", ""InputStream has a method called reset() which subclasses of InputStream may or may not support"", ""reset()""); (""InputStream"", ""subclasses of InputStream are related to InputStream as they may or may not support its methods"", ""subclasses of InputStream""); (""mark()"", ""subclasses of InputStream may or may not support the mark() method"", ""subclasses of InputStream"")"
java.nio.channels.Selector is not the Channel that pushes the data into the Selector and from there into the component even if that is what the above diagram suggests,"(""Selector"", ""The Selector and Channel are related because the text mentions that the Channel pushes data into the Selector, indicating a interaction between the two."", ""Channel""); (""java.nio.channels"", ""The package java.nio.channels and the class Selector are related because Selector is part of the java.nio.channels package, as indicated by the fully qualified name java.nio.channels.Selector."", ""Selector"")"
When connected you can also use the read() and write() method as if you were using a traditional channel,NULL
"The mark() sets a mark internally in the InputStream which marks the point in the stream to which data has been read so far. The code using the InputStream can then continue reading data from it. If the code using the InputStream wants to go back to the point in the stream where the mark was set, the code calls reset() on the InputStream.","(""InputStream"", ""The mark() method is related to the InputStream class because it is called on an instance of InputStream to set a mark internally in the stream."", ""mark()""); (""InputStream"", ""The reset() method is related to the InputStream class because it is called on an instance of InputStream to go back to the point in the stream where the mark was set."", ""reset()"")"
These two types of tasks are represented by the RecursiveAction and RecursiveTask classes,NULL
The java.util.concurrent package has the following implementations of the BlockingQueue interface,NULL
If the objects in the Java List do not implement the Comparable interface or if you want to sort the objects in another order than their compare() implementation then you need to use a Comparator implementation (java.util.Comparator),NULL
The Java SimpleDateFormat class is also capable of formatting a Date object into a StringBuffer instead of returning an individual String with the date formatted,"(""SimpleDateFormat"", ""The SimpleDateFormat class is capable of formatting a Date object"", ""Date""); (""SimpleDateFormat"", ""The SimpleDateFormat class is capable of formatting a Date object into a String"", ""String""); (""SimpleDateFormat"", ""The SimpleDateFormat class is capable of formatting a Date object into a StringBuffer"", ""StringBuffer""); (""Date"", ""A Date object can be formatted into a String"", ""String""); (""Date"", ""A Date object can be formatted into a StringBuffer"", ""StringBuffer"")"
If the markSupported() method returns false then mark() and reset() are not supported,"(""MarkSupported"", ""The MarkSupported method is related to the Mark method because MarkSupported determines whether the Mark method is supported."", ""Mark""); (""MarkSupported"", ""The MarkSupported method is related to the Reset method because MarkSupported determines whether the Reset method is supported."", ""Reset"")"
The Matcher replaceAll() and replaceFirst() methods can be used to replace parts of the string the Matcher is searching through,"(""Matcher"", ""The Matcher class has the replaceAll() method, indicating a clear relationship between the two entities as the method is a part of the class"", ""replaceAll()""); (""Matcher"", ""The Matcher class has the replaceFirst() method, indicating a clear relationship between the two entities as the method is a part of the class"", ""replaceFirst()"")"
In that way the PrintWriter is a bit different from other Writer subclasses which tend to have mostly constructors that can take other Writer instances as parameters (except for a few like OutputStreamWriter),"(""PrintWriter"", ""PrintWriter is a subclass of Writer"", ""Writer""); (""OutputStreamWriter"", ""OutputStreamWriter is a subclass of Writer"", ""Writer"")"
The reduce() method can be combined with the filter() method too,NULL
In case you prefer to use Java NIO instead of Java Networking (standard API) then you can also use a ServerSocketChannel instead of the java.net.ServerSocket,"(""ServerSocketChannel"", ""ServerSocketChannel is related to java.net because it is an alternative to the java.net ServerSocket class, suggesting that ServerSocketChannel is part of or has a similar functionality to the java.net package"", ""java.net"")"
The problem is that since the doNotify() call only calls notify() and not notifyAll() only one thread is awakened even if 4 threads are waiting on the same string instance (the empty string),"(""DoNotify"", ""DoNotify calls Notify, indicating a relationship between the two methods"", ""Notify""); (""Notify"", ""Notify is called on a string instance, indicating a relationship between the method and the class"", ""String""); (""NotifyAll"", ""NotifyAll is an alternative to Notify and is also called on a string instance, indicating a relationship between the method and the class"", ""String"")"
You can convert a FileOutputStream to a character based Writer using the Java OutputStreamWriter class,"(""FileOutputStream"", ""FileOutputStream can be converted to a character based Writer using the Java OutputStreamWriter class"", ""OutputStreamWriter""); (""OutputStreamWriter"", ""OutputStreamWriter is used to create a character based Writer"", ""Writer"")"
The channel returned by the SelectionKey.channel() method should be cast to the channel you need to work with a ServerSocketChannel or SocketChannel etc,"(""SelectionKey"", ""The SelectionKey class has a method called channel()"", ""SelectionKey.channel()""); (""SelectionKey.channel()"", ""The channel() method of SelectionKey returns a channel that can be cast to ServerSocketChannel"", ""ServerSocketChannel"")"
java.io.Writer works just like combining the Reader with InputStream or the Writer with OutputStream,"(""Writer"", ""Writer works just like combining the Reader with InputStream or the Writer with OutputStream, indicating a relationship between Writer and Reader"", ""Reader""); (""Writer"", ""Writer works just like combining the Reader with InputStream or the Writer with OutputStream, indicating a relationship between Writer and InputStream"", ""InputStream""); (""Writer"", ""Writer works just like combining the Reader with InputStream or the Writer with OutputStream, indicating a relationship between Writer and OutputStream"", ""OutputStream""); (""Reader"", ""Writer works just like combining the Reader with InputStream or the Writer with OutputStream, indicating a relationship between Reader and InputStream"", ""InputStream""); (""Writer"", ""Java Io is the package where the Writer class is located"", ""Java Io""); (""Reader"", ""Java Io is the package where the Reader class is located"", ""Java Io""); (""InputStream"", ""Java Io is the package where the InputStream class is located"", ""Java Io"")"
Object.wait(long timeout) means that the majority of the time waited to be able to lock the lock and enter the critical section is spent waiting in the wait() call inside the lock() method not being blocked trying to enter the lock() method,"(""Object"", ""The wait method is a part of the Object class"", ""wait""); (""Object"", ""The lock method is a part of the Object class and is related to the wait method in the context of waiting to enter a critical section"", ""lock"")"
Remember that even if the 4 threads call wait() and notify() on the same shared string instance the signals from the doWait() and doNotify() calls are stored individually in the two MyWaitNotify instances,"(""MyWaitNotify"", ""MyWaitNotify is related to wait because the signals from the wait calls are stored individually in the MyWaitNotify instances"", ""wait""); (""MyWaitNotify"", ""MyWaitNotify is related to notify because the signals from the notify calls are stored individually in the MyWaitNotify instances"", ""notify""); (""MyWaitNotify"", ""MyWaitNotify is related to doWait because doWait calls are stored individually in the MyWaitNotify instances"", ""doWait""); (""MyWaitNotify"", ""MyWaitNotify is related to doNotify because doNotify calls are stored individually in the MyWaitNotify instances"", ""doNotify""); (""wait"", ""wait and notify are related because they are both used on the same shared string instance and their signals are stored individually in the MyWaitNotify instances"", ""notify"")"
The rest of the components like Pipe and FileLock are merely utility classes to be used in conjunction with the three core components,"(""Pipe"", ""Both Pipe and FileLock are mentioned as utility classes, indicating a relationship between them as they are used together in conjunction with the core components."", ""FileLock""); (""Pipe"", ""Pipe is related to the core components as it is a utility class used in conjunction with them."", ""core components"")"
java.io.PrintStream example first creates a PrintStream which is connected to an OutputStream,"(""PrintStream"", ""PrintStream is part of the java.io package"", ""java.io""); (""PrintStream"", ""a PrintStream is connected to an OutputStream"", ""OutputStream"")"
"If the Deque is empty, pollLast() returns null. This is different than removeLast() which throws an exception if the Deque is empty.","(""Deque"", ""pollLast is a method of the Deque class"", ""pollLast""); (""Deque"", ""removeLast is a method of the Deque class"", ""removeLast"")"
The Map computeIfAbsent() method works similarly to the compute() method but the lambda expression is only called if no entry exists already for the given key,"(""Map"", ""The computeIfAbsent() method is a part of the Map class"", ""computeIfAbsent()""); (""Map"", ""The compute() method is a part of the Map class"", ""compute()"")"
You can get and set the nanoseconds using the getNanos() and setNanos(),NULL
This OutputStream write() example first creates a FileOutputStream to which the data will be written. Then the example enters a while loop. The condition to exit the while loop is the return value of the method hasMoreData().,"(""FileOutputStream"", ""The FileOutputStream is related to the write() method because the write() method is used to write data to the FileOutputStream."", ""write()""); (""OutputStream"", ""The OutputStream is related to the write() method because the write() method is a part of the OutputStream class."", ""write()""); (""FileOutputStream"", ""The FileOutputStream is related to the hasMoreData() method because the example uses the return value of hasMoreData() to determine when to stop writing to the FileOutputStream."", ""hasMoreData()"")"
Since the BufferedWriter collects the characters written internally in a buffer before writing them to the underlying Writer the speedup is not as noticeable as with other Writer classes (that do not use buffering),NULL
The Java compiler then generates the corresponding fields getter methods and a hashCode() and equals() method,"(""Java"", ""The Java compiler is a part of the Java class, indicating a relationship between the two entities."", ""compiler""); (""compiler"", ""The compiler generates the hashCode() method, indicating a relationship between the two entities."", ""hashCode()""); (""compiler"", ""The compiler generates the equals() method, indicating a relationship between the two entities."", ""equals()""); (""compiler"", ""The compiler generates the getter methods, indicating a relationship between the two entities."", ""getter methods""); (""Java"", ""The hashCode() method is a part of the Java class, indicating a relationship between the two entities."", ""hashCode()""); (""Java"", ""The equals() method is a part of the Java class, indicating a relationship between the two entities."", ""equals()"")"
The bigger the result String grows the longer it takes to copy the characters from it into a new StringBuilder and again copy the characters from the StringBuilder into the temporary String created by the toString() method,"(""String"", ""The String and StringBuilder are related because the characters from the String are copied into the StringBuilder."", ""StringBuilder""); (""String"", ""The String and toString() method are related because the toString() method is called on the temporary String created."", ""toString()"")"
"Instead of calling the stop() method you will have to implement your thread code so it can be stopped, you can implements Runnable which contains an extra method called doStop() which signals to the Runnable to stop.","(""Runnable"", ""Runnable contains an extra method called DoStop which signals to the Runnable to stop"", ""DoStop"")"
The logp() methods work like the log() methods except each method take an extra two parameters The sourceClass and sourceMethod parameter,"(""Logp"", ""The logp() methods work like the log() methods, indicating a clear relationship between the two methods"", ""Log""); (""Logp"", ""The logp() method takes an extra parameter sourceClass, indicating a relationship between the logp() method and the sourceClass"", ""Sourceclass"")"
But since the thread waiting in lock() has not yet called queueObject.wait() the call to queueObject.notify() passes into oblivion,"(""Thread"", ""The thread is waiting in the lock, indicating a relationship between the Thread class and the Lock class or method"", ""Lock""); (""Thread"", ""The thread is waiting for the QueueObject to be notified, indicating a relationship between the Thread class and the QueueObject class"", ""QueueObject""); (""QueueObject"", ""The QueueObject has a wait method, indicating a relationship between the QueueObject class and the Wait method"", ""Wait""); (""QueueObject"", ""The QueueObject has a notify method, indicating a relationship between the QueueObject class and the Notify method"", ""Notify"")"
It is possible to compare two buffers using equals() and compareTo(),NULL
The names take() and release() may seem a bit odd when using a semaphore for signaling,"(""Take"", ""The take() method is related to the Semaphore class because it is used for signaling, implying a connection between the method and the class."", ""Semaphore""); (""Release"", ""The release() method is related to the Semaphore class because it is used for signaling, implying a connection between the method and the class."", ""Semaphore"")"
If you need to read and write the date and time to a database use the java.sql.Date and java.sql.Timestamp classes,"(""Java.Sql.Date"", ""Both are used for reading and writing date and time to a database"", ""Java.Sql.Timestamp""); (""Java.Sql"", ""Java.Sql.Date is a class within the Java.Sql package"", ""Java.Sql.Date""); (""Java.Sql"", ""Java.Sql.Timestamp is a class within the Java.Sql package"", ""Java.Sql.Timestamp"")"
Since PipedOutputStream is a subclass of OutputStream PipedOutputStream has the same basic methods and use patterns as an OutputStream,NULL
In the following sections I will explain how to use the ReentrantLock class as a Lock,NULL
In contrast to the signaling use case the methods take() and release() are now called by the same thread,NULL
The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called,"(""Notify"", ""Both Notify and Notifyall are related as they are both methods that do not save method calls when no threads are waiting"", ""Notifyall""); (""Notify"", ""Notify is related to Threads as it is a method that is called when threads are waiting"", ""Threads"")"
The Matcher appendReplacement() and appendTail() methods are used to replace string tokens in an input text and append the resulting string to a StringBuffer,"(""Matcher"", ""The Matcher class has an appendReplacement() method, indicating a clear relationship between the two entities as the method is part of the class."", ""appendReplacement()""); (""Matcher"", ""The Matcher class has an appendTail() method, indicating a clear relationship between the two entities as the method is part of the class."", ""appendTail()""); (""appendReplacement()"", ""The appendReplacement() method is used to append the resulting string to a StringBuffer, indicating a clear relationship between the method and the class as the method operates on the class."", ""StringBuffer""); (""appendTail()"", ""The appendTail() method is used to append the resulting string to a StringBuffer, indicating a clear relationship between the method and the class as the method operates on the class."", ""StringBuffer"")"
The Java BufferedReader class is a subclass of the Java Reader class so you can use a BufferedReader anywhere a Reader is required,"(""BufferedReader"", ""The Java BufferedReader class is a subclass of the Java Reader class, indicating an inheritance relationship between the two classes"", ""Reader"")"
You can convert a Java Set to a Java List by creating a List and calling its addAll() method passing the Set as parameter to the addAll() method,"(""Set"", ""The Set is converted to a List by calling the addAll() method and passing the Set as a parameter"", ""List""); (""List"", ""The List has an addAll() method that is used to convert a Set to a List"", ""addAll()"")"
The add() and offer() methods differ in how the behave if the Queue is full so no more elements can be added,"(""Add"", ""The Add method is related to the Queue class because it is used to add elements to the Queue."", ""Queue""); (""Offer"", ""The Offer method is related to the Queue class because it is used to offer elements to the Queue."", ""Queue"")"
The Collections binarySearch() method can search a Java List for an element using a binary search algorithm. The List must be sorted in ascending order before you search it using binarySearch() .,"(""binarySearch()"", ""The binarySearch() method is part of the Collections class."", ""Collections""); (""binarySearch()"", ""The binarySearch() method can search a Java List for an element."", ""List""); (""List"", ""The List is part of the Java package."", ""Java"")"
If unlockWrite() was not called from inside a finallyclause and an exception was thrown from the critical section the ReadWriteLock would remain write locked forever causing all threads calling lockRead() or lockWrite() on that ReadWriteLock instance to halt indefinately,"(""UnlockWrite"", ""UnlockWrite is a method that is used in conjunction with ReadWriteLock to prevent it from remaining write locked forever"", ""ReadWriteLock""); (""LockRead"", ""LockRead is a method that is called on a ReadWriteLock instance and its functionality can be affected if the ReadWriteLock remains write locked"", ""ReadWriteLock""); (""LockWrite"", ""LockWrite is a method that is called on a ReadWriteLock instance and its functionality can be affected if the ReadWriteLock remains write locked"", ""ReadWriteLock"")"
Third the characters written to the StringWriter are obtained via the two methods toString() and getBuffer(),"(""StringWriter"", ""The toString() method is related to the StringWriter class because it is used to obtain the characters written to it"", ""toString()"")"
The decrementAndGet() subtracts 1 from the AtomicInteger value and returns its value after the subtraction. The getAndDecrement() also subtracts 1 from the AtomicInteger value but returns the value the AtomicInteger had before the subtraction.,"(""DecrementAndGet"", ""The decrementAndGet() method is related to the AtomicInteger class because it operates on the AtomicInteger value, subtracting 1 from it and returning its value after the subtraction."", ""AtomicInteger"")"
"If the Deque is empty, removeLast() will throw an exception. This is different from pollLast() which returns null if the Deque is empty.","(""Deque"", ""The Deque class has a method called removeLast, indicating a relationship between the class and the method."", ""removeLast""); (""Deque"", ""The Deque class has a method called pollLast, indicating a relationship between the class and the method."", ""pollLast"")"
You may be familiar with these two wellknown PrintStream instances in Java System.out and System.err,"(""System.out"", ""System.out is an instance of the PrintStream class"", ""PrintStream""); (""System.err"", ""System.err is an instance of the PrintStream class"", ""PrintStream""); (""System"", ""System.out is a member of the System class"", ""System.out"")"
"If adding the element fails, for instance if the Deque is full, the push() method will throw an exception. This is similar to how the addFirst() method works.","(""Deque"", ""The Deque class has a push() method that can be used to add elements to it, indicating a clear relationship between the Deque class and the push() method."", ""push()""); (""Deque"", ""The Deque class has an addFirst() method that can be used to add elements to it, indicating a clear relationship between the Deque class and the addFirst() method."", ""addFirst()"")"
Finally you can access the localized values in the ResourceBundle via its different getString() and getObject() etc,NULL
"The tailMap() method is similar to the headMap() method, except that tailMap() returns all elements that are equal to or higher than the given parameter element.",NULL
That you would not call wait() and notify() on an internal monitor object but rather on the This is probably true,NULL
You can parse a String into a java.util.Date instance using the parse() method of the SimpleDateFormat instance,"(""String"", ""The String entity is related to the parse() entity because the parse() method is used to parse a String into a java.util.Date instance"", ""parse()""); (""parse()"", ""The parse() entity is related to the SimpleDateFormat entity because the parse() method is a part of the SimpleDateFormat instance"", ""SimpleDateFormat""); (""SimpleDateFormat"", ""The SimpleDateFormat entity is related to the java.util.Date entity because the SimpleDateFormat instance is used to parse a String into a java.util.Date instance"", ""java.util.Date"")"
"If the Deque is empty, peekFirst() returns null. This is similar to how peek() works","(""Deque"", ""The Deque class has a method called peekFirst(), indicating a relationship between the two."", ""peekFirst()""); (""peekFirst()"", ""The method peekFirst() is compared to the method peek(), suggesting a relationship between the two methods."", ""peek()"")"
When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start() like this,"(""Thread"", ""The Thread class has a method called run(), indicating a relationship between the two."", ""run()""); (""Thread"", ""The Thread class has a method called start(), indicating a relationship between the two."", ""start()"")"
java.util.logging.Handler is not a Filter even though it has the same effect,NULL
The Java PrintStream class contains the powerful format() and printf() methods (they do exactly the same but the name printf is more familiar to Cprogrammers),"(""PrintStream"", ""The PrintStream class contains the format() method, indicating a relationship between the class and the method"", ""format()""); (""PrintStream"", ""The PrintStream class contains the printf() method, indicating a relationship between the class and the method"", ""printf()"")"
java.util.TreeSet Comparator will then decide the ordering of the elements in the TreeSet,"(""TreeSet"", ""The TreeSet class uses the Comparator class to decide the ordering of elements"", ""Comparator""); (""TreeSet"", ""The TreeSet class is part of the java.util package"", ""java.util"")"
Exactly how to handle the calls to commit() and or rollback() is covered in the JDBC Transactions Tutorial,"(""JDBC"", ""The JDBC package is related to the commit method because it is often used in conjunction with commit to manage database transactions."", ""commit""); (""JDBC"", ""The JDBC package is related to the rollback method because it is often used in conjunction with rollback to manage database transactions."", ""rollback""); (""JDBC"", ""The JDBC package is related to the JDBC Transactions Tutorial class because the tutorial covers how to handle calls to commit and rollback in the context of JDBC transactions."", ""JDBC Transactions Tutorial""); (""commit"", ""The commit and rollback methods are related because they are both used to manage database transactions, with commit saving changes and rollback reverting them."", ""rollback""); (""commit"", ""The commit method is related to the JDBC Transactions Tutorial class because the tutorial covers how to handle calls to commit in the context of JDBC transactions."", ""JDBC Transactions Tutorial"")"
You may be tempted then to always call notifyAll() instead notify() but this is a bad idea performance wise,NULL
The File class contains the method mkdir() and mkdirs() for that purpose,"(""FILE"", ""The File class contains the method mkdir() for that purpose"", ""MKDIR"")"
The lock() method locks the Lock instance so that all threads calling lock() are blocked until unlock() is executed,"(""Lock"", ""The lock() method is related to the Lock class because it is used to lock the Lock instance."", ""lock()""); (""Lock"", ""The unlock() method is related to the Lock class because it is used to unlock the Lock instance that was previously locked by lock()."", ""unlock()"")"
The call to read() reads a character from the PushbackReader just like from any other Reader,"(""PushbackReader"", ""The call to read() is related to PushbackReader because it is a method that can be called on an instance of PushbackReader to read a character."", ""read()""); (""Reader"", ""The call to read() is related to Reader because it is a method that can be called on any Reader object, including PushbackReader, to read a character."", ""read()"")"
java.io.BufferedInputStream is typically much faster than reading a single byte at a time from an InputStream especially for disk access and larger data amounts,NULL
Even though the Java Networking APIs enable you to open and close network connections via sockets all communication happens via the Java IO classes InputStream and OutputStream,"(""Java Networking APIs"", ""The Java Networking APIs are related to the InputStream class because they enable network communication via InputStream"", ""InputStream""); (""Java Networking APIs"", ""The Java Networking APIs are related to the OutputStream class because they enable network communication via OutputStream"", ""OutputStream""); (""Java Networking APIs"", ""The Java Networking APIs are related to the Java IO package because Java IO contains the classes used for communication"", ""Java IO""); (""InputStream"", ""The InputStream and OutputStream classes are related to each other because they are both used for communication and are part of the Java IO package"", ""OutputStream""); (""InputStream"", ""The InputStream class is related to the Java IO package because it is part of the package"", ""Java IO"")"
The tailMap() method is similar to the headMap() method except that tailMap() returns all elements that are equal to or higher than the given parameter element,NULL
Again here the first() and next() methods return the unicode index of the found word boundary,NULL
"The `getAndIncrement()` method does the same as the `incrementAndGet()` method, except the `getAndIncrement()` method returns the value of the element *before* it is incremented.",NULL
When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start(),"(""Thread"", ""The Thread class has a run() method, which is a common mistake to call when starting a thread"", ""run()""); (""Thread"", ""The Thread class has a start() method, which is the correct method to call when starting a thread"", ""start()"")"
Obviously if the input parameter to contains() is null the contains() method will not use the equals() method to compare against each element but rather use the == operator,"(""Contains"", ""The contains() method will use the equals() method to compare against each element if the input parameter is not null"", ""Equals"")"
Thus you can use the return values of start() and end() inside a String.substring() call,"(""String"", ""String is related to start because start is a method that can be called on a String object"", ""start""); (""String"", ""String is related to end because end is a method that can be called on a String object"", ""end""); (""String"", ""String is related to substring because substring is a method that can be called on a String object"", ""substring""); (""start"", ""start is related to substring because the return value of start can be used inside a substring call"", ""substring"")"
The PrintWriter class has all the same methods as the PrintStream except for the methods to write raw bytes,"(""PrintWriter"", ""The PrintWriter class has all the same methods as the PrintStream except for the methods to write raw bytes, indicating a relationship between the two classes"", ""PrintStream""); (""PrintWriter"", ""The PrintWriter class has methods, indicating a relationship between the class and its methods"", ""methods"")"
"The Java SortedMap interface, java.util.SortedMap, is a subtype of the java.util.Map interface, with the addition that the elements stored in a Java SortedMap map are sorted internally. This means you can iterate the elements stored in a SortedMap in the sort order.","(""Java SortedMap"", ""Java SortedMap is a subtype of java.util.Map, indicating an inheritance relationship between the two classes"", ""java.util.Map""); (""java.util.SortedMap"", ""java.util.SortedMap is the package where the Java SortedMap interface is located, indicating a containment relationship between the package and the class"", ""Java SortedMap"")"
Similarly the compareTo() method should throw a ClassCastException if the input parameter is not of the same class as the class of the object compareTo() is called on,"(""CompareTo()"", ""The compareTo() method is related to the Class because it is called on an object of a specific class and requires the input parameter to be of the same class"", ""Class"")"
The class java.lang.Object defines three methods wait() notify() and notifyAll() to facilitate this,"(""Java.Lang.Object"", ""Java.Lang.Object defines the method Wait() to facilitate synchronization"", ""Wait()""); (""Java.Lang.Object"", ""Java.Lang.Object defines the method Notify() to facilitate synchronization"", ""Notify()"")"
Both Java File and FileChannel works but in case you want a pure Java NIO solution use the Java NIO FileChannel class,"(""Java File"", ""Both Java File and FileChannel are related as they are mentioned as alternatives for achieving the same goal"", ""FileChannel""); (""Java NIO"", ""Java NIO is related to FileChannel because FileChannel is part of the Java NIO solution"", ""FileChannel"")"
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicLong,"(""GetAndIncrement"", ""GetAndIncrement method is related to AtomicLong class because it operates on its value""}"", ""AtomicLong""); (""IncrementAndGet"", ""IncrementAndGet method is related to AtomicLong class because it operates on its value""}"", ""AtomicLong""); (""GetAndAdd"", ""GetAndAdd method is related to AtomicLong class because it operates on its value""}"", ""AtomicLong""); (""AddAndGet"", ""AddAndGet method is related to AtomicLong class because it operates on its value""}"", ""AtomicLong""); (""GetAndIncrement"", ""GetAndIncrement and GetAndAdd methods are related because they have similar functionality""}"", ""GetAndAdd""); (""IncrementAndGet"", ""IncrementAndGet and AddAndGet methods are related because they have similar functionality""}"", ""AddAndGet""); (""GetAndIncrement"", ""GetAndIncrement and IncrementAndGet methods are related because they work similarly but with a difference in the order of operations""}"", ""IncrementAndGet"")"
"celingEntry(), floorEntry(), higherEntry(), lowerEntry(),The NavigableMap also has methods to get the entry for a given key, rather than the key itself. These methods behave like the ceilingKey() etc. methods, except they return a Map.Entry instead of the key object itself.","(""NavigableMap"", ""The NavigableMap has a method called CelingEntry()"", ""CelingEntry""); (""NavigableMap"", ""The NavigableMap has a method called FloorEntry()"", ""FloorEntry""); (""NavigableMap"", ""The NavigableMap has a method called HigherEntry()"", ""HigherEntry""); (""NavigableMap"", ""The NavigableMap has a method called LowerEntry()"", ""LowerEntry"")"
The Java GZIPOutputStream class (java.util.zip.GZIPOutStream) can be used to GZIP compress data and write it to an OutputStream,"(""GZIPOutputStream"", ""The GZIPOutputStream class is related to the OutputStream class because it writes compressed data to an OutputStream"", ""OutputStream""); (""GZIPOutputStream"", ""The GZIPOutputStream class is related to the java.util.zip package because it is contained within this package"", ""java.util.zip""); (""java.util.zip.GZIPOutStream"", ""The java.util.zip.GZIPOutStream class is related to the java.util.zip package because it is contained within this package"", ""java.util.zip"")"
Object.wait(long timeout) allows other threads to call wait() or notify() too since these methods must be called from inside a synchronized block,"(""Object"", ""Object is related to wait because wait is a method of the Object class"", ""wait""); (""Object"", ""Object is related to notify because notify is a method of the Object class"", ""notify""); (""Object"", ""Object is related to synchronized because wait and notify methods must be called from inside a synchronized block, which is associated with the Object class"", ""synchronized""); (""wait"", ""wait and notify are related because both methods must be called from inside a synchronized block, and both are methods associated with the Object class"", ""notify""); (""wait"", ""wait is related to synchronized because wait must be called from inside a synchronized block"", ""synchronized"")"
The java.util.TimeZone class is used in conjunction with the java.util.Calendar class,NULL
You do so by calling the Cipher update() or doFinal() methods,"(""Cipher"", ""The Cipher class has a relationship with the update() method because the method is called on the Cipher class."", ""update()""); (""Cipher"", ""The Cipher class has a relationship with the doFinal() method because the method is called on the Cipher class."", ""doFinal()"")"
The BlockingDeque interface in the java.util.concurrent class represents a deque which is thread safe to put into and take instances from,NULL
Here are two examples of taking an element from a Java Queue using its poll() and remove() methods,"(""Queue"", ""The Queue class has a poll method"", ""poll""); (""Queue"", ""The Queue class has a remove method"", ""remove"")"
If you need an integer value use the round() floor() or ceil() method,NULL
Notice how it is possible to change that reference through both the setValue() and add() methods,"(""Setvalue"", ""Both Setvalue and Add are methods that can be used to change a reference, indicating a relationship between them as they serve similar purposes"")
{completion_delimiter}

Given the exact method names from the text (""setValue"" and ""add""), and assuming ""tuple_delimiter"" is a comma (,), ""record_delimiter"" is a line break, and ""completion_delimiter"" is ""######"", the final corrected output should be:

(""entity"", ""Setvalue"", ""method"", ""Add"")"
a given date is or convert dates and times between time zones use the java.util.Calendar and java.util.GregorianCalendar classes,"(""Java.Util.Calendar"", ""Java.Util.GregorianCalendar is a subclass of Java.Util.Calendar, as indicated by the shared package and functional context"", ""Java.Util.GregorianCalendar""); (""Java.Util"", ""Java.Util.Calendar is part of the Java.Util package, as indicated by the package name"", ""Java.Util.Calendar"")"
If the call to take() happens before the call to release() the thread calling release() will still know that take() was called because the signal is stored internally in the signal variable,"(""Take"", ""Take and Release are related because they are both methods that are called by a thread, and the call to Take affects the behavior of the call to Release"", ""Release""); (""Signal"", ""Signal is related to Take because the signal is stored internally in the signal variable when Take is called"", ""Take""); (""Signal"", ""Signal is related to Release because the signal stored internally in the signal variable is used by Release to determine its behavior"", ""Release""); (""Thread"", ""Thread is related to Take because a thread calls the Take method"", ""Take""); (""Thread"", ""Thread is related to Release because a thread calls the Release method"", ""Release"")"
The compareAndSet() method can compare the reference stored in the AtomicReference instance with an expected reference and if they two references are the same (not equal as in equals() but same as in ==) then a new reference can be set on the AtomicReference instance,"(""CompareAndSet"", ""The CompareAndSet method is used in conjunction with the AtomicReference instance to compare and set references."", ""AtomicReference""); (""CompareAndSet"", ""The CompareAndSet method is related to the Equals method in that it compares references, whereas Equals compares values using the equals() method."", ""Equals"")"
Anders Hejlsberg on checked vs. unchecked exceptions httpwww.artima.comintvhandcuffs.html James Gosling on checked exceptions httpwww.artima.comintvsolid.html Bill Venners on Exceptions httpwww.artima.cominterfacedesignexceptions.html Bruce Eckel on checked exceptions httpwww.artima.comintvtypingP.html Designing with Exceptions (Bill Venners www.artima.com) httpwww.artima.comdesigntechniquesdesexcept.html Effective Java (Joshua Bloch Addison Wesley 2001) Daniel Pietraru in favor of checked exceptions Exceptional Java Checked exceptions are priceless茂驴�?For everything else there is the RuntimeException,"(""Anders Hejlsberg"", ""Anders Hejlsberg discusses checked vs. unchecked exceptions"", ""Exceptions""); (""James Gosling"", ""James Gosling discusses checked exceptions"", ""Exceptions""); (""Bill Venners"", ""Bill Venners discusses exceptions in design and interface design"", ""Exceptions""); (""Bruce Eckel"", ""Bruce Eckel discusses checked exceptions"", ""Exceptions"")"
But the thread waiting in the lock() method will not leave that block until the isLocked is set to false and a monitorObject.notify() is executed as it happens in unlock(),"(""LOCK"", ""The lock method is related to the isLocked variable because the thread waiting in the lock method will not leave that block until the isLocked is set to false""}"", ""ISLOCKED""); (""LOCK"", ""The lock method is related to the monitorObject class because a monitorObject.notify() is executed as it happens in unlock""}"", ""MONITOROBJECT""); (""UNLOCK"", ""The unlock method is related to the isLocked variable because the isLocked is set to false in the unlock method""}"", ""ISLOCKED"")"
As you saw in the previous section when you register a Channel with a Selector the register() method returns a SelectionKey objects,"(""Channel"", ""The Channel is related to the Selector because it is registered with the Selector."", ""Selector""); (""Selector"", ""The Selector is related to the register method because the register method is used with the Selector."", ""register""); (""Channel"", ""The Channel is related to the register method because the Channel is registered using the register method."", ""register"")"
By walking through all directories and deleting all files (inside visitFile()) in each directory and afterwards delete the directory itself (inside postVisitDirectory()) you can delete a directory with all subdirectories and files,"(""VisitFile"", ""VisitFile is a method that is used to delete files inside a directory, indicating a relationship between the method and the directory class"", ""Directory"")"
The lower() method does the opposite of the higher() method meaning it returns the highest element that is less than (not equal to) the given parameter,NULL
In many cases though you can replace the use of the File class with use of the Path interface,NULL
Once the Mac instance is initialized you can calculate a MAC from data by calling the update() and doFinal() method,"(""Mac"", ""The Mac class has a method called update(), indicating a relationship between the two."", ""update()""); (""Mac"", ""The Mac class has a method called doFinal(), indicating a relationship between the two."", ""doFinal()"")"
Deque.offerFirst(E e) is different from the addFirst() method which will throw an exception is adding an element to the beginning of the Deque fails,"(""Deque"", ""Deque has a method called offerFirst, which suggests a relationship between the Deque class and the offerFirst method"", ""offerFirst""); (""Deque"", ""Deque has a method called addFirst, which suggests a relationship between the Deque class and the addFirst method"", ""addFirst"")"
The main difference between the Runnable run() method and the Callable call() method is that the call() method can return an Object from the method call,"(""Runnable"", ""The Runnable class has a run() method"", ""run()""); (""Callable"", ""The Callable class has a call() method"", ""call()"")"
The toNanos() is different from the getNano() in that the getNano() only returns the part of the Duration which is less than one second,"(""ToNanos"", ""The ToNanos() method is related to the Duration class because it is used to convert the duration to nanoseconds"", ""Duration""); (""GetNano"", ""The GetNano() method is related to the Duration class because it is used to get the nano part of the duration"", ""Duration"")"
Collection.add(E e) is different from the offer() method which will return false if it cannot insert the element,"(""Collection"", ""The Collection class has an add method, indicating a relationship between the class and the method"", ""add""); (""Collection"", ""The Collection class has an offer method, indicating a relationship between the class and the method"", ""offer"")"
To take an element from a Java Queue you can call either its poll() or remove() method,"(""Queue"", ""The Queue class has a method called poll(), which establishes a relationship between the two."", ""poll()""); (""Queue"", ""The Queue class has a method called remove(), which establishes a relationship between the two."", ""remove()""); (""Java"", ""The Queue class is part of the Java package, which establishes a relationship between the two."", ""Queue""); (""Java"", ""The poll() method is part of the Java package, which establishes a relationship between the two, as poll() is a method of a class in the Java package."", ""poll()"")"
java.util.TreeMap Comparator will then be used to sort the keys of the key value pairs stored in the SortedMap,"(""TreeMap"", ""TreeMap uses Comparator to sort the keys of the key value pairs stored in it"", ""Comparator""); (""TreeMap"", ""TreeMap is a type of SortedMap"", ""SortedMap"")"
If a thread calls lock() twice without calling unlock() in between the second call to lock() will block,"(""THREAD"", ""A thread calls the lock method, establishing a relationship between the thread and the lock method."", ""LOCK""); (""THREAD"", ""A thread calls the unlock method, establishing a relationship between the thread and the unlock method."", ""UNLOCK"")"
The start() call will return as soon as the thread is started. It will not wait until the run() method is done.,"(""Thread"", ""The start() method is related to the Thread class because it is used to start a thread."", ""Start""); (""Thread"", ""The run() method is related to the Thread class because it contains the code that is executed by the thread."", ""Run"")"
"If the Deque is empty, peekFirst() returns null. This is similar to how peek() works, but the method name peekFirst() is a bit more saying about which end of the Deque you peek at.","(""Deque"", ""The Deque class has a method named peekFirst(), indicating a relationship between the class and the method."", ""peekFirst()""); (""Deque"", ""The Deque class has a method named peek(), indicating a relationship between the class and the method."", ""peek()"")"
If isLocked is true however the thread calling lock() is parked waiting in the monitorObject.wait() call,NULL
The remove() method will use the o.equals() to decide if the object o passed as parameter matches a given element in the BlockingQueue.,"(""Remove"", ""The Remove method will use the Equals method to decide if the object o passed as parameter matches a given element in the BlockingQueue, thus they are related through their functionality."", ""Equals""); (""Remove"", ""The Remove method is related to the BlockingQueue because it is used to remove an element from the BlockingQueue."", ""Blockingqueue""); (""Equals"", ""The Equals method is related to the object O because it is used to compare the object O with other elements in the BlockingQueue."", ""O"")"
"In general you can call the?markSupported()?method to find out if?mark()?and?reset()are supported on a given?InputStream?or not, but the?BufferedInputStream?supports them.","(""MarkSupported"", ""MarkSupported method is related to Mark method as it checks if mark is supported"", ""Mark""); (""MarkSupported"", ""MarkSupported method is related to Reset method as it checks if reset is supported"", ""Reset""); (""InputStream"", ""InputStream class has a Mark method"", ""Mark""); (""InputStream"", ""InputStream class has a Reset method"", ""Reset""); (""InputStream"", ""InputStream class has a MarkSupported method"", ""MarkSupported""); (""BufferedInputStream"", ""BufferedInputStream class supports the Mark method"", ""Mark""); (""BufferedInputStream"", ""BufferedInputStream class supports the Reset method"", ""Reset""); (""BufferedInputStream"", ""BufferedInputStream class supports the MarkSupported method"", ""MarkSupported"")"
If you compare the Lock and FairLock classes you will notice that there is somewhat more going on inside the lock() and unlock() in the FairLock class,"(""Lock"", ""The Lock class has a relationship with the lock() method as it is mentioned together in the comparison with FairLock class"", ""lock()""); (""Lock"", ""The Lock class has a relationship with the unlock() method as it is mentioned together in the comparison with FairLock class"", ""unlock()""); (""FairLock"", ""The FairLock class has a relationship with the lock() method as it is mentioned together in the comparison with Lock class, with more functionality going on inside the lock() method"", ""lock()""); (""FairLock"", ""The FairLock class has a relationship with the unlock() method as it is mentioned together in the comparison with Lock class, with more functionality going on inside the unlock() method"", ""unlock()"")"
The third variant of getConnection() takes a database URL and a Properties object as parameter,NULL
"You can get the current line number from the?LineNumberReader?by calling the?getLineNumber()method. You can also set the current line number, should you need to, by calling the?setLineNumber()?method","(""LineNumberReader"", ""The LineNumberReader class has a getLineNumber() method, which indicates a relationship between the two entities, as the method is called on the class."", ""getLineNumber()""); (""LineNumberReader"", ""The LineNumberReader class has a setLineNumber() method, which indicates a relationship between the two entities, as the method is called on the class."", ""setLineNumber()"")"
Executing unlock() sets isLocked back to false and notifies (awakens) one of the threads waiting in the wait() call in the lock() method if any,"(""Unlock"", ""Executing unlock() sets isLocked back to false"", ""Islocked""); (""Unlock"", ""notifies (awakens) one of the threads waiting in the wait() call in the lock() method if any, indicating a relationship between unlock and wait"", ""Wait""); (""Lock"", ""wait() call is in the lock() method, indicating a relationship between lock and wait"", ""Wait"")"
The SimpleDateFormat class does this via a version of the format() method that takes the Date StringBuffer and a FieldPosition instance as parameters,"(""SimpleDateFormat"", ""The SimpleDateFormat class uses the format() method to perform its functionality"", ""format()""); (""format()"", ""The format() method takes a Date as one of its parameters"", ""Date""); (""format()"", ""The format() method takes a StringBuffer as one of its parameters"", ""StringBuffer""); (""format()"", ""The format() method takes a FieldPosition instance as one of its parameters"", ""FieldPosition""); (""SimpleDateFormat"", ""The SimpleDateFormat class uses a Date as a parameter in its format() method"", ""Date""); (""SimpleDateFormat"", ""The SimpleDateFormat class uses a StringBuffer as a parameter in its format() method"", ""StringBuffer"")"
The getAndIncrement() method does the same as the incrementAndGet() method except the getAndIncrement() method returns the value of the element before it is incremented,NULL
java.util.TreeMap Comparator will then be used to sort the keys of the key value pairs stored in the NavigableMap,"(""TreeMap"", ""TreeMap uses Comparator to sort the keys of the key value pairs stored in it"", ""Comparator""); (""TreeMap"", ""TreeMap is a type of NavigableMap"", ""NavigableMap""); (""Comparator"", ""Comparator is used to sort the keys of the key value pairs stored in NavigableMap"", ""NavigableMap""); (""java.util"", ""TreeMap is part of the java.util package"", ""TreeMap"")"
In other words the calling thread must call wait() or notify() from inside a synchronized block,"(""THREAD"", ""The THREAD class is related to the WAIT method because the calling thread must call wait() from inside a synchronized block"", ""WAIT"")"
As you can see both the waiting and notifying thread calls wait() and notify() from within a synchronized block,"(""Thread"", ""The Thread class is related to the Wait method because threads call the wait() method from within a synchronized block"", ""Wait""); (""Thread"", ""The Thread class is related to the Notify method because threads call the notify() method from within a synchronized block"", ""Notify"")"
However unless you need to specify all these parameters explicitly for your ThreadPoolExecutor it is often easier to use one of the factory methods in the java.util.concurrent.Executors class as shown in the ExecutorService text,"(""ThreadPoolExecutor"", ""ThreadPoolExecutor is related to Executors because Executors has factory methods that can be used to create a ThreadPoolExecutor"", ""Executors""); (""Executors"", ""Executors is related to java.util.concurrent because Executors is a class within the java.util.concurrent package"", ""java.util.concurrent""); (""ExecutorService"", ""ExecutorService is related to java.util.concurrent because ExecutorService is a class within the java.util.concurrent package"", ""java.util.concurrent"")"
"You can choose between the following Deque implementations in the Java Collections API:java.util.LinkedList,java.util.ArrayDeque","(""LinkedList"", ""LinkedList is part of the java.util package"", ""java.util"")"
Put shortly the thread waiting in lock() needs an unlock() call to execute successfully for it to exit lock() and the synchronized blocks inside it,"(""Lock"", ""The thread is waiting in lock, which means the lock class is related to the thread class as it is responsible for blocking the thread's execution until it is unlocked""}"", ""Thread""); (""Unlock"", ""The unlock method is related to the lock class because it is necessary to call unlock for a thread to exit the lock, indicating a relationship between the unlock method and the lock class""}"", ""Lock"")"
Java NIO has more classes and components than these but the Channel Buffer and Selector forms the core of the API in my opinion,NULL
The DateTimeFormatter is located in the java.time.format package so the fully qualified class name is java.time.format.DateTimeFormatter,"(""DateTimeFormatter"", ""The DateTimeFormatter is located in the java.time.format package, indicating a relationship between the class and the package it belongs to."", ""java.time.format"")"
The ceilingEntry() is thus similar to the ceilingKey() method except the ceilingKey() method only returns the key and ceilingKey() returns a Map.Entry object containing both the key and value,"(""CeilingEntry"", ""CeilingEntry is similar to CeilingKey, with the key difference being that CeilingEntry returns a Map.Entry object, while CeilingKey returns only the key"", ""CeilingKey""); (""CeilingEntry"", ""CeilingEntry returns a Map.Entry object, indicating a relationship between the CeilingEntry method and the Map.Entry class"", ""Map.Entry"")"
"unless you need to specify all these parameters explicitly for your ThreadPoolExecutor, it is often easier to use one of the factory methods in the java.util.concurrent.Executors class","(""ThreadPoolExecutor"", ""ThreadPoolExecutor is related to Executors because Executors provides factory methods to create ThreadPoolExecutor instances"", ""Executors""); (""Executors"", ""Executors is a part of the java.util.concurrent package, indicating a containment relationship"", ""java.util.concurrent"")"
Once the read operation has completed the data read into the ByteBuffer and then into a String and printed to System.out,"(""ByteBuffer"", ""The ByteBuffer is the target of the read operation, indicating a relationship between the ByteBuffer class and the read method"", ""read""); (""String"", ""The data read into the ByteBuffer is then put into a String, indicating a relationship between the String class and the read method"", ""read"")"
javax.lang.model.util.Elements is possible to specify generic types for most (if not all) of the components in the Java Collections API,"(""Elements"", ""Elements is a utility class that can be used to specify generic types for components in the Java Collections API, thus they are related"", ""Java Collections""); (""Elements"", ""Elements is part of the javax.lang.model.util package, thus they are related"", ""javax.lang.model.util"")"
The Java PrintWriter class contains the powerful format() and printf() methods,"(""PrintWriter"", ""The PrintWriter class contains the format() method, indicating a relationship between the class and the method"", ""format()"")"
If an InputStream subclass supports the mark() and reset() methods then that subclass should override the markSupported() to return true,"(""InputStream"", ""InputStream is related to mark() because mark() is a method that can be supported by InputStream subclasses"", ""mark()""); (""InputStream"", ""InputStream is related to reset() because reset() is a method that can be supported by InputStream subclasses"", ""reset()""); (""InputStream"", ""InputStream is related to markSupported() because markSupported() is a method that should be overridden by InputStream subclasses to indicate support for mark() and reset() methods"", ""markSupported()""); (""mark()"", ""mark() is related to markSupported() because markSupported() indicates whether the mark() method is supported"", ""markSupported()"")"
Not until a thread has called release() will the thread calling take() be allowed to deliver its signal,"(""Thread"", ""A thread calls the release() method, indicating a relationship between the Thread class and the Release method"", ""Release""); (""Thread"", ""A thread calls the take() method, indicating a relationship between the Thread class and the Take method"", ""Take"")"
The poll() and remove() both removes the first element in the Queue. They differ in how they behave if the Queue is empty. The poll() method returns null if the Queue is empty. The remove() method throws an exception if the Queue is empty.,"(""Poll"", ""The poll() method is related to the Queue class because it operates on the Queue, removing the first element."", ""Queue""); (""Remove"", ""The remove() method is related to the Queue class because it operates on the Queue, removing the first element."", ""Queue"")"
Notice how the execute() method will throw an IllegalStateException if execute() is called after stop() has been called,"(""Execute"", ""The execute method is related to the stop method because execute will throw an exception if stop has been called previously"", ""Stop""); (""Execute"", ""The execute method is related to the IllegalStateException because it will throw this exception if stop has been called"", ""IllegalStateException"")"
The methods hashCode() and equals() play a distinct role in the objects you insert into Java collections,"(""Hashcode"", ""Hashcode method is used in Java Collections"", ""Java Collections""); (""Equals"", ""Equals method is used in Java Collections"", ""Java Collections"")"
Notice the two synchronized blocks inside the set() and get() method,NULL
Therefore if a thread calls notify() before the thread to signal has called wait() the signal will be missed by the waiting thread,"(""Thread"", ""The thread calls the notify method, indicating a relationship between the Thread class and the Notify method."", ""Notify""); (""Thread"", ""The thread calls the wait method, indicating a relationship between the Thread class and the Wait method."", ""Wait"")"
"celingEntry(), floorEntry(), higherEntry(), lowerEntry(),These methods behave like the ceilingKey() etc. methods, except they return a Map.Entry instead of the key object itself.","(""CelingEntry"", ""CelingEntry and CeilingKey are related because they behave similarly, with the main difference being the return type, where CelingEntry returns a Map.Entry and CeilingKey returns the key object itself."", ""CeilingKey""); (""FloorEntry"", ""FloorEntry and CelingEntry are related because they are both methods that return a Map.Entry and are mentioned together in the provided text as having similar behavior."", ""CelingEntry""); (""HigherEntry"", ""HigherEntry and FloorEntry are related because they are both methods that return a Map.Entry and are mentioned together in the provided text as having similar behavior."", ""FloorEntry"")"
By default the ConsoleHandler uses a SimpleFormatter to format the messages before writing them to System.err,"(""ConsoleHandler"", ""ConsoleHandler uses SimpleFormatter to format messages"", ""SimpleFormatter""); (""ConsoleHandler"", ""ConsoleHandler writes messages to System.err"", ""System.err""); (""ConsoleHandler"", ""ConsoleHandler uses SimpleFormatter to format messages"", ""SimpleFormatter""); (""ConsoleHandler"", ""ConsoleHandler writes messages to System.err"", ""System.err"")"
The hashCode() method of objects is used when you insert them into a HashTable HashMap or HashSet,"(""hashCode()"", ""The hashCode() method is related to HashTable because it is used when inserting objects into a HashTable."", ""HashTable""); (""hashCode()"", ""The hashCode() method is related to HashMap because it is used when inserting objects into a HashMap."", ""HashMap"")"
So as you can see a combination of the hashCode() and equals() methods are used when storing and when looking up objects in a hashtable,NULL
Here is a modified version of MySignal called MyWaitNotify that uses wait() and notify(),"(""MyWaitNotify"", ""MyWaitNotify is a modified version of MySignal, indicating an inheritance or modification relationship between the two classes"", ""MySignal""); (""MyWaitNotify"", ""MyWaitNotify uses the wait() method, indicating a usage or invocation relationship between the class MyWaitNotify and the method wait()"", ""wait"")"
To set a new System stream use one of th emethods System.setIn() System.setOut() or System.setErr(),"(""System"", ""System is the class that has the method setIn()"", ""setIn""); (""System"", ""System is the class that has the method setOut()"", ""setOut"")"
"The add() and offer() methods differ in how the behave if the Queue is full, so no more elements can be added. The add() method throws an exception in that case, whereas the offer() method just returns false.","(""Add"", ""The Add method is related to the Queue because it is used to add elements to the Queue and throws an exception when the Queue is full."", ""Queue""); (""Offer"", ""The Offer method is related to the Queue because it is used to add elements to the Queue and returns false when the Queue is full."", ""Queue"")"
Both the Pattern and Matcher classes are covered in detail in their own texts,NULL
The Java Set interface as a method called removeAll() which removes all elements in the Set which are also present in another Collection,"(""Set"", ""The Set interface has a method called removeAll(), which suggests a relationship between the Set class and the removeAll() method."", ""removeAll()""); (""removeAll()"", ""The removeAll() method removes elements from the Set that are also present in a Collection, indicating a relationship between the removeAll() method and the Collection class."", ""Collection"")"
The Map compute() method takes a key object and a lambda expression as parameters. The lambda expression must implement the java.util.function.BiFunction interface.,"(""Map"", ""The compute() method is related to the Map class because it is described as a method that belongs to Map."", ""compute()""); (""compute()"", ""The compute() method is related to the BiFunction interface because the lambda expression passed to compute() must implement BiFunction."", ""BiFunction"")"
java.text.CollationKey is faster than the stringwise comparison the RuleBasedCollator uses normally,NULL
The ForkJoinPool located in the java.util.concurrent package so the full class name is java.util.concurrent.ForkJoinPool,NULL
Notice how notifyAll() is only called from enqueue() and dequeue() if the queue size is equal to the size bounds (0 or limit),"(""NotifyAll"", ""NotifyAll is called from Enqueue when the queue size is at its bounds"", ""Enqueue""); (""NotifyAll"", ""NotifyAll is called from Dequeue when the queue size is at its bounds"", ""Dequeue"")"
In other words you can add all elements from a List or Set into a List with addAll(),"(""List"", ""The List class has a method called addAll(), which suggests a relationship between List and addAll()."", ""addAll()""); (""Set"", ""The Set class can be used in conjunction with the addAll() method to add its elements to a List, indicating a relationship between Set and addAll()."", ""addAll()"")"
Since only one thread is allowed to take the semaphore all other threads calling take() will be blocked until release() is called,"(""Semaphore"", ""The Semaphore class has a method called Take, indicating a relationship between the two entities as the method is used to acquire the semaphore."", ""Take""); (""Semaphore"", ""The Semaphore class has a method called Release, indicating a relationship between the two entities as the method is used to release the semaphore."", ""Release"")"
The format() and printf() methods allow you to mix text and data in very advanced ways using a formatting string,NULL
The Collections replaceAll() method uses the equals() method of each element to determine if the element is equal to the element to replace or not,"(""Collections"", ""The Collections class contains the replaceAll() method"", ""replaceAll()"")"
The call to unread() pushes a character back into the PushbackReader. The next time read() is called the pushed back characters will be read first.,"(""Unread"", ""The unread() method is related to PushbackReader because it pushes a character back into the PushbackReader."", ""PushbackReader""); (""Read"", ""The read() method is related to PushbackReader because the next time read() is called, the pushed back characters will be read first from the PushbackReader."", ""PushbackReader"")"
java.sql.ResultSet ResultSet has 3 different columns (Name Age Gender) and 3 records with different values for each column,"(""ResultSet"", ""ResultSet is a part of the java.sql package"", ""java.sql"")"
First the ResourceBundle class will look for a ListResourceBundle and then for a PropertyResourceBundle,"(""ResourceBundle"", ""ResourceBundle is related to ListResourceBundle because it looks for a ListResourceBundle"", ""ListResourceBundle"")"
The returned long value can be used to initialize java.util.Date java.sql.Date java.sql.Timestamp and java.util.GregorianCalendar objects,"(""Java.Util.Date"", ""Both are used to represent date and can be initialized with a long value, indicating a relationship between the two classes"", ""Java.Sql.Date""); (""Java.Util.Date"", ""Both are used to represent date and time and can be initialized with a long value, indicating a relationship between the two classes"", ""Java.Sql.Timestamp""); (""Java.Sql.Date"", ""Both are part of the java.sql package and are used to represent date and timestamp, indicating a relationship between the two classes"", ""Java.Sql.Timestamp""); (""Java.Util.Date"", ""Both are used to represent date and can be used together to perform date-related operations, indicating a relationship between the two classes"", ""Java.Util.GregorianCalendar""); (""Java.Sql.Date"", ""Both can be used to represent date, but Java.Util.GregorianCalendar provides more functionality, indicating a relationship between the two classes"", ""Java.Util.GregorianCalendar"")"
In fact the implementation of the ExecutorService interface present in the java.util.concurrent package is a thread pool implementation,NULL
Notice how the Collections.sort() method now takes a java.util.Comparator as parameter in addition to the List,"(""Collections"", ""The Collections class contains the sort method, indicating a relationship between the two."", ""sort""); (""sort"", ""The sort method takes a java.util.Comparator as a parameter, indicating a relationship between the two."", ""java.util.Comparator"")"
For instance ordinary debug trace logging calls to entering() and exiting() would be called at the beginning and end of a method call,NULL
Each of the methods ceilingEntry() floorEntry() higherEntry() and lowerEntry() will be covered in the following sections,NULL
java.text.SimpleDateFormat is not exactly clear how the FieldPosition instance is used,"(""SimpleDateFormat"", ""SimpleDateFormat uses FieldPosition instance"", ""FieldPosition""); (""SimpleDateFormat"", ""SimpleDateFormat is part of the java.text package"", ""java.text"")"
The LocalDate Java class is located in the java.time package so its fully qualified class name is java.time.LocalDate,NULL
If there is no more data to read from the underlying Reader then the BufferedReader readLine() method will return null,"(""BufferedReader"", ""The BufferedReader class has a readLine() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""readLine()"")"
java.util.List is different from a Java Set where each element can occur only once,"(""java.util.List"", ""java.util.List is different from a Java Set where each element can occur only once, indicating a comparison relationship between the two classes"", ""Set""); (""Java"", ""Java is related to List as List is a part of the Java ecosystem and utilizes Java's features"", ""List"")"
Deque.addLast(E e) is different from the offerLast() method which will return false if the element cannot be added to the Deque,"(""Deque"", ""Deque has a method called addLast"", ""addLast""); (""Deque"", ""Deque has a method called offerLast"", ""offerLast"")"
Do not confuse this class with the java.util.Arrays class in the Java Collections suite which contains utility methods for sorting arrays converting them to collections etc,"(""java.util.Arrays"", ""java.util.Arrays is a part of the Java Collections package"", ""Java Collections"")"
You obtain a Collection of the values stored in a Map via the values() method,"(""Collection"", ""Collection is related to Map because it is obtained from Map via the values() method"", ""Map""); (""values()"", ""values() method is related to Map because it is used to obtain a Collection of the values stored in a Map"", ""Map"")"
Unfortunately if an exception is thrown during the write() call in the example above that exception will cause the program flow to break before the close() method is called,"(""Exception"", ""The exception is thrown during the write() call, indicating a relationship between the Exception class and the Write method."", ""Write""); (""Write"", ""The close() method is called after the write() call, indicating a relationship between the Write method and the Close method."", ""Close"")"
Being a subclass of Hashtable you can actually use the get() and put() method of the Hashtable class which allow the use of nonstring keys and values,"(""Hashtable"", ""The get() method is related to the Hashtable class because it is a method that can be used with the Hashtable class."", ""get()""); (""Hashtable"", ""The get() method is related to the Hashtable class because it is a method that can be used with the Hashtable class."", ""get()""); (""Hashtable"", ""The put() method is related to the Hashtable class because it is a method that can be used with the Hashtable class."", ""put()"")"
"A Java Properties instance clearly is as Hashtable, but it should not share the Hashtable interface. So - the ""Is a"" part of this rule should be interpreted as ""Should be usable as a"" instead. Using that formulation, Properties would not have been made a subclass of Hashtable, because Properties should not be usable as a Hashtable .","(""Properties"", ""Properties is related to Hashtable because Properties is compared to Hashtable in terms of usability, implying a clear relationship between the two classes."", ""Hashtable"")"
"I mean, only the same, single thread is ever allowed to call inc(). Multiple threads can call count().",NULL
"If the Deque is empty, poll() returns null. This is different than remove() which throws an exception if the Deque is empty.","(""Deque"", ""poll() is a method of the Deque class"", ""poll()""); (""Deque"", ""remove() is a method of the Deque class"", ""remove()"")"
The peek() works like the element() method except it does not throw an exception if the Queue is empty. Instead it just returns null.,"(""Peek"", ""Peek and Element are related because they are both methods that can be used to retrieve an element from a Queue, but they differ in their behavior when the Queue is empty."", ""Element""); (""Peek"", ""Peek is related to Queue because it is a method that operates on a Queue, allowing you to retrieve an element without removing it."", ""Queue"")"
Notice the doStop() and keepRunning() methods. The doStop() is intended to be called from another thread than the thread executing the MyRunnable's run() method. The keepRunning() method is called internally by the thread executing the MyRunnable's run() method. As long as doStop() has not been called the keepRunning() method will return true - meaning the thread executing the run() method will keep running.,"(""MyRunnable"", ""MyRunnable class has a method called DoStop()"", ""DoStop()""); (""MyRunnable"", ""MyRunnable class has a method called KeepRunning()"", ""KeepRunning()""); (""MyRunnable"", ""MyRunnable class has a method called Run()"", ""Run()""); (""DoStop()"", ""DoStop() and KeepRunning() are related as the call to DoStop() affects the return value of KeepRunning()"", ""KeepRunning()""); (""Run()"", ""KeepRunning() method is called internally by the thread executing the Run() method"", ""KeepRunning()"")"
System.err works like System.out except it is normally only used to output error texts,NULL
To do so set the upper bound to 1 and have the call to take() and release() guard the critical section,"(""Take"", ""The Take method is related to the Critical Section because it is used to guard the critical section."", ""Critical Section""); (""Release"", ""The Release method is related to the Critical Section because it is used to guard the critical section."", ""Critical Section"")"
java.io.InputStream method is useful if you need to read all bytes from a file via a FileInputStream into a byte array,"(""InputStream"", ""InputStream is related to FileInputStream because FileInputStream is used to read bytes from a file into an InputStream"", ""FileInputStream""); (""InputStream"", ""InputStream is related to java.io because it is part of the java.io package"", ""java.io"")"
Notice how the getMonth() and getDayOfWeek() methods return an enum instead of an int,NULL
java.io.InputStreamReader example first creates a FileInputStream and then wraps it in an InputStreamReader,"(""FileInputStream"", ""InputStreamReader is related to FileInputStream because InputStreamReader wraps FileInputStream in the given example"", ""InputStreamReader""); (""java.io"", ""FileInputStream is related to java.io because FileInputStream is part of the java.io package"", ""FileInputStream"")"
Deque.offerLast(E e) is different from the addLast() method which will throw an exception is adding an element to the end of the Deque fails,"(""Deque"", ""Deque contains the offerLast method, indicating a relationship between the class Deque and the method offerLast"", ""offerLast""); (""Deque"", ""Deque contains the addLast method, indicating a relationship between the class Deque and the method addLast"", ""addLast"")"
Java has 3 streams called System.in System.out and System.err which are commonly used to provide input to and output from Java applications,"(""Java"", ""Java has System.in which is used to provide input to Java applications"", ""System.in""); (""Java"", ""Java has System.out which is used to provide output from Java applications"", ""System.out""); (""Java"", ""Java has System.err which is used to provide output from Java applications"", ""System.err""); (""System.in"", ""System.in and System.out are both used in Java applications for input and output respectively"", ""System.out""); (""System.in"", ""System.in and System.err are both part of Java's System package used for input and error output respectively"", ""System.err"")"
To access a private field you will need to call the Class.getDeclaredField(String name) or Class.getDeclaredFields() method,"(""Class"", ""The Class entity is related to the GetDeclaredField entity because GetDeclaredField is a method of the Class entity."", ""GetDeclaredField"")"
"If the Deque is empty, pollFirst() returns null. This is different than removeFirst() which throws an exception if the Deque is empty.","(""Deque"", ""The Deque class has a method called pollFirst(), which suggests that pollFirst() is a part of the Deque class and operates on its elements."", ""pollFirst()""); (""Deque"", ""The Deque class has a method called removeFirst(), which implies that removeFirst() is associated with the Deque class, performing an operation related to removing elements from it."", ""removeFirst()"")"
Once you have opened a socket (network connection) though you read and write data to and from it via Java IO InputStream and OutputStream classes,"(""Socket"", ""Socket is related to InputStream because you can read data from a socket using an InputStream"", ""InputStream""); (""Socket"", ""Socket is related to OutputStream because you can write data to a socket using an OutputStream"", ""OutputStream""); (""InputStream"", ""InputStream is part of the Java IO package"", ""Java IO""); (""OutputStream"", ""OutputStream is part of the Java IO package"", ""Java IO"")"
java.util.Set is different from a Java List where each element can occur more than once,"(""java.util.Set"", ""java.util.Set is a package that contains the Set class"", ""Set""); (""Java"", ""Java is a language that has a List class"", ""List""); (""Java"", ""Java is a language that has a Set class"", ""Set"")"
Keep in mind that if some of the operations in the transaction fail you would most likely want to call the rollback() method instead of commit(),NULL
The min() and max() methods return an Optional instance which has a get() method on which you use to obtain the value,"(""Min"", ""The min() method returns an Optional instance"", ""Optional""); (""Max"", ""The max() method returns an Optional instance"", ""Optional"")"
Only one thread can execute inside any of the two add() and subtract() methods at any given time,NULL
A Java Callable is different from a Runnable in that the Runnable interface run() method does not return a value and it cannot throw checked exceptions (only RuntimeExceptions),"(""Java Callable"", ""Java Callable is different from a Runnable, indicating a comparative relationship between the two classes"", ""Runnable""); (""Runnable"", ""The Runnable interface has a run() method, indicating a containment relationship between the class and the method"", ""run()"")"
The ConcurrentHashMap is very similar to the java.util.HashTable class except that ConcurrentHashMap offers better concurrency than HashTable does,"(""ConcurrentHashMap"", ""ConcurrentHashMap is very similar to HashTable, suggesting a relationship between the two classes"", ""HashTable""); (""HashTable"", ""HashTable is part of the java.util package, indicating a package-class relationship"", ""java.util"")"
You shut down a ScheduledExecutorService using the shutdown() or shutdownNow() methods which are inherited from the ExecutorService interface,"(""ScheduledExecutorService"", ""ScheduledExecutorService uses the shutdown method to shut down the service"", ""shutdown""); (""ScheduledExecutorService"", ""ScheduledExecutorService uses the shutdownNow method to shut down the service immediately"", ""shutdownNow"")"
It is the last line of this example that calls the List stream() method to obtain the Stream representing the elements in the List.Once you have obtained a Stream from a List you can iterate the Stream by calling its forEach() method.,"(""List"", ""The List class is related to the Stream class because the stream() method is called on a List to obtain a Stream."", ""Stream""); (""Stream"", ""The Stream class is related to the forEach() method because the forEach() method is called on a Stream to iterate over its elements."", ""forEach()""); (""List"", ""The List class is related to the stream() method because the stream() method is used to obtain a Stream from a List."", ""stream()""); (""Stream"", ""The Stream class is related to the stream() method because the stream() method returns a Stream."", ""stream()""); (""Stream"", ""The Stream class is related to the List class because a Stream can be obtained from a List."", ""List"")"
Using that formulation Properties would not have been made a subclass of Hashtable because Properties should not be usable as a Hashtable,"(""Properties"", ""Properties is a subclass of Hashtable, indicating a clear inheritance relationship between the two classes"", ""Hashtable"")"
Many of the core components in the Java Collection API rely on the correct implementation of the `hashCode()` and `equals()` methods.,"(""Java Collection API"", ""The Java Collection API relies on the correct implementation of the hashCode() method."", ""hashCode()"")"
System.in System.out and System.err are initialized by the Java runtime when a Java VM starts up so you dont have to instantiate any streams yourself (although you can exchange them at runtime),"(""System.in"", ""System.in is initialized by the Java VM when it starts up"", ""Java VM""); (""System.out"", ""System.out is initialized by the Java VM when it starts up"", ""Java VM""); (""System.err"", ""System.err is initialized by the Java VM when it starts up"", ""Java VM""); (""Java VM"", ""The Java VM is part of the Java runtime environment, which is included in the Java package"", ""Java"")"
"In case the write() method throws an exception, the close() method will never get called.",NULL
You create a Path instance using a static method in the Paths class (java.nio.file.Paths) named Paths.get(),"(""Paths"", ""The Paths class contains the static method Paths.get()"", ""Paths.get()""); (""java.nio.file"", ""The Paths class is part of the java.nio.file package"", ""Paths"")"
"If no permits are available, the acquire() call will block until a permit is released by another thread. Similarly, a release() calls is blocked if no more permits can be released into this semaphore.","(""Acquire"", ""The acquire() method is related to the Semaphore class because it is used to acquire a permit from the semaphore."", ""Semaphore""); (""Release"", ""The release() method is related to the Semaphore class because it is used to release a permit into the semaphore."", ""Semaphore"")"
The submaps are the maps returned by various methods like headMap() subMap() and tailMap(),"(""Submaps"", ""Submaps are returned by the headMap() method"", ""Headmap()""); (""Submaps"", ""Submaps are returned by the subMap() method"", ""Submap()"")"
If your Java SortedMap was created using a Comparator you can obtain the Comparator used via the SortedMap comparator() method,"(""SortedMap"", ""The SortedMap class uses a Comparator to determine the order of its elements, and the comparator() method is used to obtain the Comparator used by the SortedMap."", ""Comparator""); (""SortedMap"", ""The SortedMap class has a method called comparator() that returns the Comparator used by the SortedMap."", ""comparator()"")"
You can change this pattern later using the applyPattern() or applyLocalizedPattern() method,NULL
The AtomicBoolean class is located in the java.util.concurrent.atomic package so the full class name is java.util.concurrent.atomic.AtomicBoolean,"(""AtomicBoolean"", ""The AtomicBoolean class is located in the java.util.concurrent.atomic package, indicating a containment relationship between the class and the package"", ""java.util.concurrent.atomic"")"
java.io.InputStreamReader example creates a FileInputStream and wraps it in a InputStreamReader,NULL
When the process() method of the subclass is called the full process is executed including the stepBefore() and stepAfter() of the abstract superclass and the action() method of the subclass,"(""Subclass"", ""The process() method is part of the Subclass"", ""Process""); (""Abstract Superclass"", ""The stepBefore() method is part of the abstract superclass"", ""Stepbefore""); (""Abstract Superclass"", ""The stepAfter() method is part of the abstract superclass"", ""Stepafter""); (""Subclass"", ""The action() method is part of the Subclass"", ""Action""); (""Subclass"", ""The Subclass is a subclass of the abstract superclass"", ""Abstract Superclass""); (""Process"", ""The process() method includes the stepBefore() method"", ""Stepbefore""); (""Process"", ""The process() method includes the stepAfter() method"", ""Stepafter"")"
If you want to set a different offset for the dest byte array there is a version of update() and doFinal() which takes an offset parameter extra,NULL
java.security.cert.X509Certificate class represents an X.509 certificate which is used as identity certificate in HTTPS and TLS,"(""X509Certificate"", ""The X509Certificate class is part of the java.security.cert package, indicating a containment relationship between the class and the package."", ""java.security.cert"")"
java.io.PrintWriter example first creates a PrintWriter instance which is connected to a FileWriter,"(""PrintWriter"", ""PrintWriter is connected to a FileWriter, indicating a relationship between the two classes"", ""FileWriter""); (""PrintWriter"", ""PrintWriter is part of the java.io package, indicating a containment relationship between the class and the package"", ""java.io"")"
The Java CharArrayReader is handy when you have data in a char array but need to pass that data to some component which can only read from a Reader (or a Reader subclass),"(""CharArrayReader"", ""CharArrayReader is a subclass of Reader, as indicated by the term 'Reader subclass' in the text, establishing a clear inheritance relationship between the two"", ""Reader"")"
The compareAndSet() method can compare the reference stored in the AtomicStampedReference instance with an expected reference and the stored stamp with an expected stamp and if they two references and stamps are the same (not equal as in equals() but same as in ==) then a new reference can be set on the AtomicStampedReference instance,NULL
The BoundedSemaphore class shown below has two testandset methods take() and release(),"(""BoundedSemaphore"", ""The BoundedSemaphore class has a method called take, indicating a relationship between the class and the method."", ""take"")"
For a 100% precise description of how to implement equals() and hashCode() you should check out the official JavaDoc,"(""equals()"", ""These two methods are related because they are often overridden together in Java classes to ensure proper functioning of the equals() method and to maintain consistency with the hashCode() contract."", ""hashCode()""); (""JavaDoc"", ""The JavaDoc is related to the equals() method because it provides a precise description of how to implement this method."", ""equals()"")"
You could view the LocalDateTime as a combination of the LocalDate and LocalTime classes of the Java 8 date time API,"(""LocalDateTime"", ""LocalDateTime is a combination of LocalDate and LocalTime, indicating a compositional relationship between LocalDateTime and LocalDate"", ""LocalDate""); (""LocalDateTime"", ""LocalDateTime is a combination of LocalDate and LocalTime, indicating a compositional relationship between LocalDateTime and LocalTime"", ""LocalTime""); (""LocalDate"", ""LocalDate is part of the Java 8 date time API, indicating a membership relationship between LocalDate and the Java 8 date time API"", ""Java 8 date time API""); (""LocalTime"", ""LocalTime is part of the Java 8 date time API, indicating a membership relationship between LocalTime and the Java 8 date time API"", ""Java 8 date time API"")"
InputStream.read() example creates an AsynchronousFileChannel and then creates a ByteBuffer which is passed to the read() method as parameter along with a position of 0,"(""InputStream"", ""The InputStream and read() method are related because the read() method is called on the InputStream."", ""read()""); (""AsynchronousFileChannel"", ""The AsynchronousFileChannel and InputStream are related because an AsynchronousFileChannel is used to create an InputStream."", ""InputStream""); (""ByteBuffer"", ""The ByteBuffer and read() method are related because the ByteBuffer is passed as a parameter to the read() method."", ""read()""); (""InputStream"", ""The InputStream and AsynchronousFileChannel are related because the AsynchronousFileChannel is used to create the InputStream."", ""AsynchronousFileChannel"")"
When the thread that locked the Lock in the first place tries to unlock it by calling unlock() it will be blocked trying to enter the synchronized(this) block in the unlock() method,"(""Lock"", ""The Lock class has an unlock() method, indicating a relationship between the two entities as the method is used to unlock the Lock."", ""unlock()""); (""thread"", ""The thread is related to the Lock as it tries to unlock it, indicating that the thread interacts with the Lock entity."", ""Lock"")"
Of course you could do this with the start() and end() methods but it is easier to do so with the group functions,NULL
java.lang.StringBuffer text explains how to use the SimpleDateFormat class to format dates,"(""java.lang"", ""java.lang is the package where SimpleDateFormat is located"", ""SimpleDateFormat""); (""java.lang"", ""java.lang is the package where StringBuffer is located"", ""StringBuffer""); (""SimpleDateFormat"", ""The text explains how to use SimpleDateFormat in relation to a StringBuffer named text to format dates"")
{completion_delimiter}


The final answer is:
(""entity"",""StringBuffer"",""class"", ""StringBuffer"")"
The Java?ExecutorService?submit(Callable)?method is similar to the?submit(Runnable)?method except it takes a?Java Callable?instead of a?Runnable.?,NULL
Just to make it clear You should NOT use the put() and get() method of the Properties class!,"(""Properties"", ""The put() method is related to the Properties class because it is mentioned as a method that should not be used with the Properties class."", ""put()"")"
The Java compiler auto generates getter methods toString() hashcode() and equals() methods for these data fields so you dont have to write that boilerplate code yourself,"(""Java"", ""The Java compiler is a part of the Java class, it is used to compile Java code."", ""compiler""); (""compiler"", ""The compiler auto-generates getter methods."", ""getter""); (""compiler"", ""The compiler auto-generates toString() method."", ""toString()""); (""compiler"", ""The compiler auto-generates hashcode() method."", ""hashcode()""); (""compiler"", ""The compiler auto-generates equals() method."", ""equals()""); (""Java"", ""Java has getter methods."", ""getter""); (""Java"", ""Java has toString() method."", ""toString()""); (""Java"", ""Java has hashcode() method."", ""hashcode()"")"
java.nio.channels.Selector means that you cannot use FileChannel with a Selector since FileChannel cannot be switched into nonblocking mode,"(""Selector"", ""Selector is related to FileChannel because the text states that you cannot use FileChannel with a Selector"", ""FileChannel""); (""java.nio.channels"", ""java.nio.channels is related to Selector because Selector is part of the java.nio.channels package"", ""Selector"")"
Just set a new InputStream for System.in or a new OutputStream for System.out or System.err and all further data will be read written to the new stream,NULL
Creating a pipe using Java IO is done via the PipedOutputStream and PipedInputStream classes,"(""PipedOutputStream"", ""PipedOutputStream and PipedInputStream are related as they are both used together to create a pipe in Java IO"", ""PipedInputStream""); (""Java IO"", ""Java IO is related to PipedOutputStream as it is a part of the Java IO package"", ""PipedOutputStream"")"
The biggest difference between java.sql.Date and java.sql.Timestamp is that the java.sql.Date only keeps the date not the time of the date it represents,NULL
Since the parameters of the Finder.find() and MyClass.doFind() methods match it is possible to create a lambda expression that implements Finder.find() and references the MyClass.doFind() method,"(""Finder.find()"", ""The Finder.find() and MyClass.doFind() methods are related because they have matching parameters, making it possible to create a lambda expression that implements Finder.find() and references MyClass.doFind()."", ""MyClass.doFind()""); (""Finder"", ""The Finder class is related to the Finder.find() method because the method is part of the class."", ""Finder.find()"")"
Here is an example of obtaining the Comparator used by a SortedMap via its comparator() method,NULL
"The getAndDecrement() method does the same as the decrementAndGet() method, except the getAndDecrement() method returns the value of the element before it is decremented.",NULL
The Matcher lookingAt() method works like the matches() method with one major difference,"(""Matcher"", ""The lookingAt() method is part of the Matcher class"", ""lookingAt()"")"
In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not but the BufferedInputStream supports them,NULL
Lock.lock() result is that any thread calling either lock() or unlock() will become blocked indefinately,"(""Lock"", ""Lock is related to lock() because lock() is a method that belongs to the Lock class"", ""lock()""); (""Lock"", ""Lock is related to unlock() because unlock() is a method that belongs to the Lock class"", ""unlock()"")"
The getAndDecrement() method does the same as the decrementAndGet() method except the getAndDecrement() method returns the value of the element before it is decremented,NULL
The Collection interface has two methods to check if a Collection contains one or more certain elements. These are the contains() and containsAll() methods.,"(""Collection"", ""The Collection interface has a method called contains() to check if a Collection contains one or more certain elements."", ""contains()"")"
"The newLine() method which can write a new-line character to the underlying Writer. In addition, you may need to call flush() if you need to be absolutely sure that the characters written until now is flushed out of the buffer and onto the network or disk.","(""Newline()"", ""The newLine() method writes a new-line character to the underlying Writer, indicating a relationship between the Newline() method and the Writer class"", ""Writer""); (""Flush()"", ""The flush() method is used to ensure that characters written to the Writer are flushed out of the buffer, indicating a relationship between the Flush() method and the Writer class"", ""Writer"")"
To calculate a MAC value you call the Mac update() or doFinal() method,"(""Mac"", ""The Mac class has an update() method, indicating a relationship between the two."", ""update()""); (""Mac"", ""The Mac class has a doFinal() method, indicating a relationship between the two."", ""doFinal()"")"
The java.util.concurrent package has the following implementations of the BlockingDeque interface,NULL
Notice how the calculate() method both locks the Calculator instance Lock before performing any calculations and also call the add() and subtract() methods which also locks the lock,"(""calculate()"", ""The calculate() method calls the add() method, indicating a relationship between the two."", ""add()""); (""calculate()"", ""The calculate() method calls the subtract() method, indicating a relationship between the two."", ""subtract()""); (""Calculator"", ""The calculate() method is a part of the Calculator class, indicating a relationship between the class and the method."", ""calculate()""); (""Calculator"", ""The add() method is likely a part of the Calculator class, given the context of the calculate() method, indicating a relationship between the class and the method."", ""add()"")"
After calling read() the example loops until the isDone() method of the returned Future returns true,"(""Read"", ""The Read method returns a Future object, establishing a relationship between the two entities."", ""Future""); (""Read"", ""The Read method returns a Future object, establishing a relationship between the two entities."", ""Future"")"
Deque.pollFirst() is different than removeFirst() which throws an exception if the Deque is empty,"(""Deque"", ""Deque has a method called pollFirst()"", ""pollFirst""); (""Deque"", ""Deque has a method called removeFirst()"", ""removeFirst"")"
Adding and getting elements to a generic Map is done using the put() and get() methods,"(""Map"", ""The Map class uses the put() method to add elements to it"", ""put()""); (""Map"", ""The Map class uses the get() method to retrieve elements from it"", ""get()"")"
Java IO contains many subclasses of the InputStream OutputStream Reader and Writer classes,"(""Java IO"", ""Java IO contains InputStream as one of its subclasses"", ""InputStream""); (""Java IO"", ""Java IO contains OutputStream as one of its subclasses"", ""OutputStream""); (""Java IO"", ""Java IO contains Reader as one of its subclasses"", ""Reader"")"
Even if you can get get() and put() to work I would recommend that you do not use these methods,NULL
Lock.unlock() will remain blocked until the thread waiting in lock() leaves the synchronized(this) block,"(""Lock"", ""Lock is a class that contains the method unlock"", ""unlock""); (""Lock"", ""Lock is a class that contains the method lock"", ""lock"")"
The Path interface is located in the java.nio.file package so the fully qualified name of the Java Path interface is java.nio.file.Path,NULL
Here are two examples of adding elements to a Java Queue via its add() and offer() methods,"(""Queue"", ""The Queue class has an add() method, indicating a clear relationship between the two entities."", ""add()""); (""Queue"", ""The Queue class has an offer() method, indicating a clear relationship between the two entities."", ""offer()"")"
The methods Class.getMethod(String name Class[] parameterTypes) and Class.getMethods() methods only return public methods so they wont work,"(""Class"", ""Class has a method called getMethod which suggests a relationship between the Class entity and the getMethod entity"", ""getMethod""); (""Class"", ""Class has a method called getMethods which suggests a relationship between the Class entity and the getMethods entity"", ""getMethods""); (""getMethod"", ""getMethod takes a String parameter which suggests a relationship between the getMethod entity and the String entity"", ""String""); (""getMethod"", ""getMethod takes a Class[] parameter which suggests a relationship between the getMethod entity and the Class[] entity"", ""Class[]"")"
"BlockingQueue.offer(E e, long timeout, TimeUnit unit) is different from the add() method which will throw an exception is adding an element to the end of the Deque fails","(""BlockingQueue"", ""The offer method is a part of the BlockingQueue class, indicating a strong relationship between the two entities."", ""offer""); (""BlockingQueue"", ""The BlockingQueue class contains the add method, which is related to BlockingQueue as one of its methods."", ""add""); (""BlockingQueue"", ""The BlockingQueue and Deque are related in the context that they both have methods for adding elements and are compared in the given text."", ""Deque""); (""offer"", ""The offer and add methods are related as they both serve the purpose of adding elements, but they differ in their handling of exceptions and timeouts."", ""add""); (""add"", ""The add method is related to Deque as it throws an exception when adding an element to the end of Deque fails, indicating Deque's role in the method's operation."", ""Deque""); (""BlockingQueue"", ""The offer method is a part of the BlockingQueue class, indicating a strong relationship between the two entities."", ""offer""); (""BlockingQueue"", ""The BlockingQueue class contains the add method, which is related to BlockingQueue as one of its methods."", ""add""); (""BlockingQueue"", ""The BlockingQueue and Deque are related in the context that they both have methods for adding elements and are compared in the given text."", ""Deque""); (""offer"", ""The offer and add methods are related as they both serve the purpose of adding elements, but they differ in their handling of exceptions and timeouts."", ""add""); (""add"", ""The add method is related to Deque as it throws an exception when adding an element to the end of Deque fails, indicating Deque's role in the method's operation."", ""Deque"")"
The ByteArrayInputStream class is a subclass of the InputStream class so you can use a ByteArrayInputStream as an InputStream,"(""ByteArrayInputStream"", ""The ByteArrayInputStream class is a subclass of the InputStream class"", ""InputStream"")"
If you need to set a date on a java.sql.PreparedStatement or get a date from a java.sql.ResultSet you will interact with java.sql.Date,"(""Java.sql.PreparedStatement"", ""Java.sql.PreparedStatement is related to Java.sql.Date because you can set a date on a PreparedStatement"", ""Java.sql.Date""); (""Java.sql.ResultSet"", ""Java.sql.ResultSet is related to Java.sql.Date because you can get a date from a ResultSet"", ""Java.sql.Date"")"
The java.nio.file.Files class works with java.nio.file.Path instances so you need to understand the Path class before you can work with the Files class,"(""Files"", ""The Files class works with Path instances, indicating a relationship between the two classes"", ""Path""); (""Files"", ""The Files class is part of the java.nio.file package, indicating a relationship between the class and the package"", ""java.nio.file"")"
Both PipedInputStream and PipedOutputStream has a connect() method that can connect one to the other,"(""PipedInputStream"", ""Both PipedInputStream and PipedOutputStream are related to each other through the connect() method, which connects one to the other"", ""PipedOutputStream""); (""PipedInputStream"", ""PipedInputStream has a connect() method that can be used to connect it to PipedOutputStream"", ""connect()"")"
java.awt.List is the last line of this example that calls the List stream() method to obtain the Stream representing the elements in the List,"(""Java.Awt.List"", ""Java.Awt.List is a class within the Java.Awt package"", ""Java.Awt""); (""Java.Awt.List"", ""Java.Awt.List calls the Stream() method to obtain the Stream representing the elements in the List"", ""Stream()""); (""Java.Awt.List"", ""Java.Awt.List is a subclass of List"", ""List""); (""Stream"", ""Stream is the return type of the Stream() method called by Java.Awt.List"", ""Java.Awt.List""); (""Stream"", ""Stream has a method named Stream()"", ""Stream()"")"
Queue.poll() is different than remove() which throws an exception if the Deque is empty,"(""Queue"", ""Queue has a method called poll"", ""poll""); (""Queue"", ""Queue has a method called remove"", ""remove""); (""Queue"", ""Queue is compared to Deque in terms of its methods"", ""Deque""); (""poll"", ""poll and remove are both methods of Queue and are being compared"", ""remove"")"
java.util.Collection represents an ordered sequence of objects just like a Java List but its intended use is slightly different,"(""java.util Collection"", ""java.util.Collection is part of the java.util package"", ""java.util"")"
Another difference between call() and run() is that call() can throw an exception whereas run() cannot (except for unchecked exceptions subclasses of RuntimeException),"(""Call"", ""Call can throw an exception which is a subclass of RuntimeException"", ""RuntimeException""); (""Run"", ""Run cannot throw checked exceptions but can throw unchecked exceptions which are subclasses of RuntimeException"", ""RuntimeException"")"
As you can see the key Iterator returns every key stored in a Java Map one by one (one for each call to next()),NULL
The awaitTermination() method is typically called after calling shutdown() or shutdownNow(),"(""AwaitTermination"", ""The awaitTermination() method is typically called after calling shutdown() or shutdownNow(), indicating a sequence of method calls where awaitTermination() is dependent on the prior execution of shutdown()."", ""Shutdown"")"
Collection.remove(Object o) is different from poll() which returns null if the Deque is empty,"(""Collection"", ""Collection has a method called remove"", ""remove""); (""Collection"", ""Collection has a method called poll"", ""poll""); (""Collection"", ""Collection is related to Deque as Deque is a type of Collection"", ""Deque""); (""remove"", ""The remove method takes an Object as a parameter"", ""Object"")"
The Java GZIPInputStream and GZIPOutputStream classes are used to ZIP compress a single file,NULL
The java.util.concurrent package contains the following implementations of the ConcurrentMap interface,NULL
Receiving data via a DatagramSocket is done by first creating a DatagramPacket and then receiving data into it via the DatagramSocket receive() method,"(""DatagramSocket"", ""DatagramSocket uses DatagramPacket to receive data"", ""DatagramPacket""); (""DatagramSocket"", ""DatagramSocket has a receive() method to receive data"", ""receive()"")"
"Notice how the while loop continues until a -1 value is read from the ByteArrayInputStream read() method. After that, the while loop exits, and the ByteArrayInputStream close() method is called.","(""ByteArrayInputStream"", ""The ByteArrayInputStream class has a read() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""read()""); (""ByteArrayInputStream"", ""The ByteArrayInputStream class has a close() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""close()"")"
Notice how we can call the addAndReturn() method using both String and Integer and their corresponding collections,"(""String"", ""String is related to addAndReturn because it is used as an argument to call the addAndReturn method"", ""addAndReturn"")"
"As you can see, the DecimalFormat is created with a formatting pattern. You can change this pattern later using the applyPattern() or applyLocalizedPattern() method.","(""DecimalFormat"", ""The DecimalFormat class has an applyPattern() method, indicating a clear relationship between the two entities as the method is used to change the formatting pattern of the DecimalFormat class."", ""applyPattern()""); (""DecimalFormat"", ""The DecimalFormat class has an applyLocalizedPattern() method, indicating a clear relationship between the two entities as the method is used to change the formatting pattern of the DecimalFormat class."", ""applyLocalizedPattern()"")"
For that you need to use the find() start() and end() methods,"(""FIND"", ""FIND and START are related because they are both mentioned as needed methods in the same context"", ""START""); (""FIND"", ""FIND and END are related because they are both mentioned as needed methods in the same context"", ""END"")"
The Java Stack class actually implements the Java List interface but you rarely use a Stack as a List except perhaps if you need to inspect all elements currently stored on the stack,NULL
In Java 6 to 13 there is only one implementation of the NavigableSet interface in the java.util package The java.util.TreeSet class,"(""NavigableSet"", ""The TreeSet class is an implementation of the NavigableSet interface"", ""TreeSet""); (""java.util"", ""The TreeSet class is located in the java.util package"", ""TreeSet"")"
In many ways the java.nio.file.Path interface is similar to the java.io.File class but there are some minor differences,NULL
java.io.CharArrayReader is also possible to write data to an ByteArrayOutputStream or CharArrayWriter,"(""Java.IO.CharArrayReader"", ""Java.IO.CharArrayReader is related to ByteArrayOutputStream because it is possible to write data to an ByteArrayOutputStream"", ""ByteArrayOutputStream""); (""Java.IO.CharArrayReader"", ""Java.IO.CharArrayReader is related to CharArrayWriter because it is also possible to write data to a CharArrayWriter"", ""CharArrayWriter"")"
"The first method, addAndGet() adds a number to the AtomicInteger and returns its value after the addition. The second method, getAndAdd() also adds a number to the AtomicInteger but returns the value the AtomicInteger had before the value was added.","(""AddAndGet"", ""AddAndGet is a method of the AtomicInteger class, as it operates on the AtomicInteger object to add a number and return its updated value."", ""AtomicInteger"")"
Here is an example of obtaining the Comparator used by a SortedSet via the comparator() method,"(""SortedSet"", ""The comparator() method is used by the SortedSet class, indicating a relationship between the two entities."", ""comparator()""); (""comparator()"", ""The comparator() method is used to obtain the Comparator, indicating that the Comparator is the target entity related to the comparator() method."", ""Comparator"")"
You will call take() instead of notify() and release() instead of wait(),"(""TAKE"", ""TAKE and NOTIFY are related as they are being replaced by each other in the given context"", ""NOTIFY"")"
The problem with calling wait() and notify() on the empty string or any other constant string is that the JVMCompiler internally translates constant strings into the same object,"(""JVMCompiler"", ""The JVMCompiler internally translates constant strings into the same object, indicating a relationship between the JVMCompiler class and the String class"", ""String""); (""wait"", ""The problem with calling wait() on the empty string or any other constant string implies a relationship between the wait method and the String class"", ""String"")"
"if the Deque is full, the offerFirst() method returns false. This is different from the addFirst() method which will throw an exception is adding an element to the beginning of the Deque fails.","(""Deque"", ""The Deque class has a method called offerFirst(), indicating a relationship between the two entities."", ""offerFirst()""); (""Deque"", ""The Deque class has a method called addFirst(), indicating a relationship between the two entities."", ""addFirst()"")"
You read characters from a Java PushbackReader just like you do from a Java Reader because PushbackReader is a Java Reader subclass,NULL
Since the Map does not contain any object stored by the key E the given default value will be returned which is the String default value passed as the last parameter to the getOrDefault() method,"(""Map"", ""The Map class contains the getOrDefault() method, which is used to retrieve a value from the map."", ""getOrDefault()""); (""getOrDefault()"", ""The getOrDefault() method returns a default value of type String if the key is not found in the map."", ""String"")"
When you call select() or selectNow() on the Selector it gives you only the SelectableChannel instances that actually has data to read,"(""Selector"", ""The Selector class has a method called select() that is used to retrieve SelectableChannel instances"", ""select()""); (""Selector"", ""The Selector class has a method called selectNow() that is used to retrieve SelectableChannel instances"", ""selectNow()""); (""select()"", ""The select() method returns SelectableChannel instances that have data to read"", ""SelectableChannel""); (""selectNow()"", ""The selectNow() method returns SelectableChannel instances that have data to read"", ""SelectableChannel"")"
"For the SortedSet to be able to determine the natural order of the elements, the elements must implement the java.lang.Comparable interface.",NULL
For the SortedSet to be able to determine the natural order of the elements the elements must implement the java.lang.Comparable interface,NULL
java.util.concurrent.RecursiveTask example is similar to the RecursiveAction example except it returns a result,"(""RecursiveTask"", ""They are related because the text states that RecursiveTask example is similar to the RecursiveAction example."", ""RecursiveAction""); (""RecursiveTask"", ""They are related because RecursiveTask is part of the java.util.concurrent package."", ""java.util.concurrent"")"
Notice the two synchronized blocks inside the set() and get() method. Notice how the blocks are placed last and first in the two methods.,NULL
This Keytool delete command will remove the KeyStore entry with the alias testkey from the KeyStore stored in the file keystore.jks,"(""Keytool"", ""The Keytool is related to the KeyStore because it is used to manage the KeyStore, specifically to delete an entry with a given alias."", ""KeyStore""); (""Keytool"", ""The Keytool is related to the delete method because it uses this method to remove a KeyStore entry."", ""delete""); (""KeyStore"", ""The KeyStore is related to the keystore.jks because it is stored in this file."", ""keystore.jks"")"
Deque.addFirst(E e) is different from the offerFirst() method which will return false if an element cannot be inserted in the beginning of the Deque,"(""Deque"", ""Deque has a method called addFirst"", ""addFirst""); (""Deque"", ""Deque has a method called offerFirst"", ""offerFirst"")"
To access a private method you will need to call the Class.getDeclaredMethod(String name Class[] parameterTypes) or Class.getDeclaredMethods() method,"(""Class"", ""The Class entity is related to the getDeclaredMethod entity because getDeclaredMethod is a method of the Class entity."", ""getDeclaredMethod"")"
There are several overridden versions of both update() and doFinal() which takes different parameters,NULL
If you look at the example in the previous section imagine what happens if an exception is thrown between the call to lock.lock() and lock.unlock(),"(""Lock"", ""The Lock class has a method called lock(), indicating a relationship between the Lock class and its method lock()"", ""lock()""); (""Lock"", ""The Lock class has a method called unlock(), indicating a relationship between the Lock class and its method unlock()"", ""unlock()""); (""Lock"", ""The Lock class has a method called lock(), indicating a relationship between the Lock class and its method lock()"", ""lock()""); (""Lock"", ""The Lock class has a method, indicating a relationship between the Lock class and its own method lock()"", ""Lock""); (""Lock"", ""The Lock class has a method called lock, indicating a relationship between the Lock class and its method lock""}"", ""lock"")"
"The replace() method will only insert the new value if there is already an existing value mapped to the key. If no existing value is mapped to the given key, no value is inserted. This is different from how put() works, which always insert the value no matter what.","(""Replace"", ""The replace() method is related to Key because it is used to insert a new value mapped to the Key."", ""Key""); (""Put"", ""The put() method is related to Key because it always inserts the value no matter what, implying a relationship with the Key."", ""Key"")"
The logrb() methods work like the log() methods too except they can obtain the log messages from a resource bundle,NULL
a stop() or pause() method too) then you can no longer create your Runnable implementation with a Java lambda expression,"(""Stop"", ""The Stop method is related to the Runnable class because it is mentioned in the context of implementing a Runnable interface."", ""Runnable""); (""Pause"", ""The Pause method is related to the Runnable class because it is mentioned in the context of implementing a Runnable interface."", ""Runnable""); (""Java"", ""The Java package is related to the Runnable class because the Runnable class is part of the Java ecosystem and is used with Java lambda expressions."", ""Runnable""); (""Java"", ""The Java package is related to the Stop method because the Stop method is used in the context of Java programming, possibly as part of a Java library or framework."", ""Stop"")"
java.security.KeyStore example loads the KeyStore file located in the keystore.ks file,"(""KEYSTORE"", ""The KEYSTORE class has a method called LOADS to load the KeyStore file."", ""LOADS""); (""KEYSTORE"", ""The KEYSTORE package contains the KEYSTORE FILE class."", ""KEYSTORE FILE"")"
The queueObject.doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout so another thread can actually call unlock() when no thread is executing inside the synchronized(this) block in lock() method,"(""QueueObject"", ""QueueObject is related to DoWait because DoWait is a method called on QueueObject"", ""DoWait""); (""QueueObject"", ""QueueObject is related to Lock because Lock is a method that contains the synchronized block where QueueObject's DoWait is called"", ""Lock""); (""QueueObject"", ""QueueObject is related to Unlock because Unlock is a method that can be called by another thread when no thread is executing inside the synchronized block in Lock method of QueueObject"", ""Unlock""); (""DoWait"", ""DoWait is related to Lock because DoWait is called outside the synchronized block of Lock method to avoid nested monitor lockout"", ""Lock"")"
The read() and write() calls on the streams are blocking meaning if you try to use the same thread to both read and write this may result in the thread deadlocking itself,"(""Read"", ""The Read method is related to Streams because it is called on the streams."", ""Streams""); (""Write"", ""The Write method is related to Streams because it is called on the streams."", ""Streams"")"
"mutiple blocks from a large file, you call the update() once for each block of data, and finish with a call to doFinal() with the last data loce",NULL
That means that when a thread invokes a read() or write() that thread is blocked until there is some data to read or the data is fully written,"(""Thread"", ""The Thread entity is related to the Read entity because a thread invokes a read() method, indicating a clear interaction between the two."", ""Read"")"
You can convert a Java List to a Java Array using the List toArray() method,"(""List"", ""The List class has a relationship with the toArray() method because the toArray() method is used to convert a List to an Array, indicating that toArray() is a method of the List class"", ""toArray()""); (""Array"", ""The Array class has a relationship with the toArray() method because the toArray() method is used to convert a List to an Array, indicating that Array is the target type of the conversion performed by the toArray() method"", ""toArray()"")"
When the thread is done with the code in the critical section (the code between lock() and unlock()) the thread calls unlock(),"(""Thread"", ""The thread uses the lock to access the critical section, indicating a relationship between the Thread class and the Lock class"", ""Lock""); (""Thread"", ""The thread calls the unlock method when it is done with the critical section, indicating a relationship between the Thread class and the Unlock method"", ""Unlock"")"
The LinkedList class is a pretty standard Deque and Queue implementation,"(""LinkedList"", ""The LinkedList class is a Deque implementation, indicating a clear relationship between the two classes"", ""Deque"")"
The System class also has a getProperty() and setProperty() method which are shortcuts to the Properties getProperty() and setProperty() methods of the System Properties instance,"(""System"", ""The System class has a relationship with the Properties class through the getProperty() and setProperty() methods, which are shortcuts to the corresponding methods in the Properties instance."", ""Properties""); (""System"", ""The System class has a relationship with the getProperty() method, which is one of its shortcuts to the Properties getProperty() method."", ""getProperty()""); (""System"", ""The System class has a relationship with the setProperty() method, which is one of its shortcuts to the Properties setProperty() method."", ""setProperty()""); (""Properties"", ""The Properties class has a relationship with the getProperty() method, which is one of its methods that can be accessed through the System class shortcuts."", ""getProperty()""); (""Properties"", ""The Properties class has a relationship with the setProperty() method, which is one of its methods that can be accessed through the System class shortcuts."", ""setProperty()"")"
The Handler in the Java Logging API use a java.util.logging.Formatter to format the LogRecord before writing it to an external system,"(""Handler"", ""The Handler in the Java Logging API uses a Formatter to format the LogRecord"", ""Formatter""); (""Handler"", ""The Handler in the Java Logging API uses a Formatter to format the LogRecord before writing it to an external system"", ""LogRecord""); (""Formatter"", ""The Formatter is used to format the LogRecord before writing it to an external system"", ""LogRecord""); (""Handler"", ""The Handler is part of the Java Logging API"", ""Java Logging API""); (""Formatter"", ""The Formatter is part of the Java Logging API"", ""Java Logging API"")"
The compare() method returns an int with the same meaning as the String.compareTo() method,"(""Compare"", ""The compare() method returns an int with the same meaning as the String.compareTo() method, indicating a relationship between the compare() method and the String class"", ""String""); (""Compare"", ""The compare() method is related to the compareTo() method, as it returns an int with the same meaning as the String.compareTo() method, indicating a close relationship between the two methods"", ""CompareTo"")"
The method getBuffer() returns the StringBuffer used by the StringWriter to build the string from the written characters,"(""GetBuffer"", ""The GetBuffer method is used by the StringWriter class to build the string from the written characters"", ""StringWriter""); (""GetBuffer"", ""The GetBuffer method returns the StringBuffer used by the StringWriter"", ""StringBuffer"")"
java.io.Writer is faster to write an array of characters to a Java BufferedWriter than writing one character at a time,"(""Writer"", ""Writer is related to BufferedWriter because it is mentioned as a faster alternative for writing to a BufferedWriter"", ""BufferedWriter""); (""java.io"", ""java.io is related to Writer because it is the package where the Writer class is located"", ""Writer"")"
java.util.Stack Java example pushes a Java String with the text 1 onto the Stack,"(""java.util"", ""java.util is the package where the Stack class is located"", ""Stack""); (""Stack"", ""The Stack is used to push a String onto it"", ""String""); (""Java"", ""Java is the programming language in which the Stack class is used"", ""Stack""); (""Java"", ""Java is the programming language in which the String class is used"", ""String"")"
Deque.peekFirst() is similar to how peek() works but the method name peekFirst() is a bit more saying about which end of the Deque you peek at,"(""Deque"", ""Deque has a method called peekFirst() which allows users to peek at the first element of the Deque"", ""peekFirst()""); (""Deque"", ""Deque has a similar method called peek() which allows users to peek at an element of the Deque, although the end is not specified"", ""peek()"")"
To sort a collection of strings according to the rules of a certain Locale you use a java.text.Collator instance created for that specific Locale,"(""Collator"", ""A Collator instance is created for a specific Locale, indicating that Collator is related to Locale"", ""Locale""); (""Collator"", ""Collator is part of the java.text package, indicating that Collator is related to java.text"", ""java.text"")"
