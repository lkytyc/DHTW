The Java Collection interface (java.util.Collection) is one of the root interfaces of the Java Collection API.,"(""[Java Collection interface"", ""is part of"", ""Java Collection API]""); (""[Java Collection interface"", ""is located in"", ""java.util]""); (""[Java Collection API"", ""includes"", ""Java Collection interface]"")"
Adding an element to a Collection is done via the add() method.,"(""Collection"", ""has method"", ""add()"")"
"The add() method adds the given element to the collection, and returns true if the Collection changed as a result of calling the add() method.","(""Collection"", ""hasMethod"", ""add()""); (""add()"", ""returns"", ""boolean""); (""Collection"", ""changedBy"", ""add()"")"
"On the other hand, if you called add() on a List and the List already contained that element, the element would then exist twice in the List.","(""List"", ""add()"", ""element""); (""List"", ""contain"", ""element""); (""element"", ""exist"", ""List"")"
"The remove() method removes the given element from the Collection and returns true if the removed element was present in the Collection, and was removed.","(""remove()"", ""is method of"", ""Collection""); (""Collection"", ""has method"", ""remove()""); (""remove()"", ""returns"", ""boolean"")"
"If the element was not present, the remove() method returns false.","(""element"", ""has method"", ""remove()""); (""remove()"", ""returns"", ""false"")"
You can also add a collection of objects to a Java Collection using the addAll().,"(""Java Collection"", ""uses"", ""addAll()""); (""addAll()"", ""belongs to"", ""Java Collection"")"
The Java Collection addAll() adds all elements found in the Collection passed as parameter to the method.,"(""Collection"", ""hasMethod"", ""addAll()""); (""addAll()"", ""takesParameter"", ""Collection""); (""Collection"", ""passedTo"", ""addAll()"")"
"If you had called add() with the Collection as parameter instead, the Collection object itself would have been added, not its elements.","(""Collection"", ""add"", ""Collection""); (""Collection"", ""has"", ""elements""); (""add"", ""called with"", ""Collection"")"
Exactly how the addAll() method behaves depends on the Collection subtype.,"(""Collection"", ""has method"", ""addAll()""); (""Collection"", ""has subtype"", ""subtype""); (""addAll()"", ""belongs to"", ""Collection"")"
The Java Collection removeAll() removes all elements found the Collection passed as parameter to the method.,"(""Collection"", ""hasMethod"", ""removeAll()""); (""removeAll()"", ""removesElementsFrom"", ""Collection""); (""Collection"", ""passesAsParameterTo"", ""removeAll()"")"
"contains() returns true if the collection contains the element, and false if not.","(""Collection"", ""contains"", ""Element"")"
"containsAll() returns true if the collection contains all the elements in the parameter collection, and false if not.","(""Collection"", ""containsAll()"", ""Parameter Collection""); (""Collection"", ""contains"", ""Elements""); (""Parameter Collection"", ""contains"", ""Elements""); (""Collection"", ""returns"", ""true""); (""Collection"", ""returns"", ""false""); (""ContainsAll"", ""returns"", ""Boolean"")"
You can check the size of a collection using the size() method.,"(""collection"", ""uses"", ""size() method""); (""size() method"", ""belongs to"", ""collection"")"
The Java Stream API provides a more functional programming approach to iterating and processing elements of e.g.,"(""Java Stream API"", ""provides"", ""functional programming approach""); (""Java Stream API"", ""used for"", ""iterating""); (""Java Stream API"", ""used for"", ""processing elements"")"
You obtain a stream from a collection by calling the stream() method of the given collection.,"(""collection"", ""has method"", ""stream()""); (""collection"", ""calls"", ""stream()""); (""collection"", ""provides"", ""stream"")"
Then a Stream of strings is obtained by calling the items.stream() method.,"(""items"", ""has method"", ""items.stream()""); (""items.stream()"", ""is a"", ""Stream""); (""Stream"", ""is a type of"", ""java.util.Stream""); (""items"", ""returns"", ""Stream"")"
"This is similar to how you obtain an Iterator by calling the items.iterator() method, but a Stream is a different animal than an Iterator.","(""Iterator"", ""obtained by calling"", ""items.iterator()""); (""Stream"", ""compared to"", ""Iterator""); (""items.iterator()"", ""returns"", ""Iterator""); (""Stream"", ""different from"", ""Iterator"")"
The Predicate interface contains a function called test() which the lambda expression passed as parameter above is matched against.,"(""Predicate"", ""contains"", ""test()""); (""Predicate"", ""has method"", ""test()""); (""test()"", ""is part of"", ""Predicate"")"
"If you look at the lambda expression above, you can see that it takes a single parameter item and returns a boolean - the result of the item.startsWith(""o"") method call.","(""item"", ""startsWith"", ""o"")"
"When you call the filter() method on a Stream, the filter passed as parameter to the filter() method is stored internally.","(""Stream"", ""hasMethod"", ""filter()""); (""filter()"", ""isParameterOf"", ""filter()""); (""Stream"", ""calls"", ""filter()"")"
"The parameter passed to the filter() function determines what items in the stream should be processed, and which that should be excluded from the processing.","(""filter()"", ""determines"", ""parameter""); (""filter()"", ""processes"", ""items""); (""filter()"", ""excludes"", ""items""); (""parameter"", ""passed to"", ""filter()""); (""items"", ""processed by"", ""filter()""); (""items"", ""excluded from"", ""filter()"")"
"If the Predicate.test() method of the parameter passed to filter() returns true for an item, that means it should be processed.","(""Predicate"", ""hasMethod"", ""test()""); (""filter()"", ""takesParameter"", ""Predicate""); (""Predicate.test()"", ""returns"", ""boolean""); (""filter()"", ""processes"", ""item""); (""Predicate.test()"", ""isCalledOn"", ""item"")"
The collect() method is one of the stream processing methods on the Stream interface.,"(""Stream"", ""hasMethod"", ""collect()""); (""collect()"", ""isPartOf"", ""Stream"")"
"The min() and max() methods return an Optional instance which has a get() method on, which you use to obtain the value.","(""Optional"", ""has method"", ""get()""); (""Optional"", ""returned by"", ""min()""); (""Optional"", ""returned by"", ""max()"")"
In case the stream has no elements the get() method will return null.,"(""stream"", ""has method"", ""get()""); (""get()"", ""returns"", ""null""); (""stream"", ""has no"", ""elements"")"
The Comparator.comparing() method creates a Comparator based on the lambda expression passed to it.,"(""Comparator"", ""has_method"", ""comparing()""); (""comparing()"", ""returns"", ""Comparator"")"
"In fact, the comparing() method takes a Function which is a functional interface suited for lambda expressions.","(""comparing"", ""takes"", ""Function""); (""Function"", ""suited for"", ""lambda expressions"")"
The count() method simply returns the number of elements in the stream after filtering has been applied.,"(""count()"", ""returns"", ""number of elements""); (""count()"", ""applied to"", ""stream""); (""stream"", ""has been filtered by"", ""filtering""); (""count()"", ""returns number of elements in"", ""stream"")"
The count() method returns a long which is the count of elements in the stream after filtering etc.,"(""count()"", ""returns"", ""long""); (""stream"", ""has method"", ""count()""); (""count()"", ""is part of"", ""stream"")"
The reduce() method can reduce the elements of a stream to a single value.,"(""reduce()"", ""is a method of"", ""stream""); (""stream"", ""has a method"", ""reduce()""); (""reduce()"", ""reduces elements of"", ""stream"")"
"The reduce() method takes a BinaryOperator as parameter, which can easily be implemented using a lambda expression.","(""reduce()"", ""takes"", ""BinaryOperator""); (""BinaryOperator"", ""can be implemented using"", ""lambda expression""); (""lambda expression"", ""implements"", ""BinaryOperator"")"
The BinaryOperator.apply() method is the method implemented by the lambda expression above.,"(""BinaryOperator"", ""has method"", ""apply()""); (""BinaryOperator.apply()"", ""implemented by"", ""lambda expression""); (""lambda expression"", ""implements"", ""BinaryOperator"")"
"Thus, the value created by the reduce() function is the accumulated value after processing the last element in the stream.","(""reduce()"", ""is a function of"", ""stream""); (""stream"", ""has a method"", ""reduce()""); (""reduce()"", ""processes"", ""element"")"
The reduce() method taking a BinaryOperator as parameter returns an Optional .,"(""reduce()"", ""taking"", ""BinaryOperator""); (""reduce()"", ""returns"", ""Optional"")"
"In case the stream contains no elements, the Optional.get() returns null.","(""Optional"", ""returns"", ""null""); (""Optional"", ""has method"", ""get()""); (""stream"", ""contains"", ""elements"")"
"This version of the reduce() method returns the accumulated value directly, and not an Optional.","(""reduce()"", ""returns"", ""accumulated value""); (""reduce()"", ""is a method of"", ""Optional""); (""reduce()"", ""returns"", ""Optional"")"
The reduce() method can be combined with the filter() method too.,"(""reduce()"", ""can be combined with"", ""filter()"")"
"The Java Collections class, java.util.Collections, contains a long list of utility methods for working with collections in Java.","(""Java Collections"", ""contains"", ""utility methods""); (""Java Collections"", ""is in"", ""java.util""); (""java.util.Collections"", ""contains"", ""utility methods""); (""java.util.Collections"", ""is part of"", ""Java Collections"")"
The Java Collections addAll() method can add a variable number of elements to a Collection (typically either a List or a Set .,"(""Java Collections"", ""has method"", ""addAll()""); (""addAll()"", ""can add to"", ""Collection""); (""Collection"", ""can be"", ""List""); (""Collection"", ""can be"", ""Set"")"
Here is a java code example of calling the Collections addAll() method:,"(""Collections"", ""hasMethod"", ""addAll()""); (""addAll()"", ""belongsTo"", ""Collections""); (""Collections"", ""isPartOf"", ""java.util""); (""addAll()"", ""isMethodOf"", ""Collections""); (""java.util"", ""containsClass"", ""Collections"")"
The Collections binarySearch() method can search a Java List for an element using a binary search algorithm.,"(""Collections"", ""hasMethod"", ""binarySearch()""); (""List"", ""supportsMethod"", ""binarySearch()""); (""binarySearch()"", ""usesAlgorithm"", ""binary search algorithm""); (""List"", ""isPartOf"", ""Java""); (""Collections"", ""isPartOf"", ""Java"")"
The List must be sorted in ascending order before you search it using binarySearch() .,"(""List"", ""must be sorted before using"", ""binarySearch()""); (""List"", ""uses"", ""binarySearch()""); (""binarySearch()"", ""is used for"", ""List"")"
Here is an example of searching a List using the Collections binarySearch() method:,"(""List"", ""uses"", ""Collections""); (""Collections"", ""has method"", ""binarySearch()"")"
The Collections copy() method can copy all elements of a List into another List.,"(""Collections"", ""hasMethod"", ""copy()""); (""List"", ""hasElements"", ""elements""); (""Collections.copy()"", ""canCopy"", ""List""); (""List"", ""isCopiedTo"", ""List"")"
Here is a Java example of calling the Collections copy() method:,"("" Collections"", ""hasMethod"", ""copy() ""); ("" Java"", ""uses"", ""Collections ""); ("" copy()"", ""isMethodOf"", ""Collections "")"
The Collections reverse() method can reverse the elements in a Java List.,"(""Collections"", ""hasMethod"", ""reverse()""); (""reverse()"", ""operatesOn"", ""Java List""); (""Java List"", ""isPartOf"", ""Java""); (""Collections"", ""isPartOf"", ""Java"")"
The Collections shuffle() method can shuffle the elements of a List.,"(""Collections"", ""hasMethod"", ""shuffle()""); (""List"", ""hasElements"", ""elements""); (""Collections.shuffle()"", ""affects"", ""List""); (""List"", ""hasMethod"", ""none""); (""Collections"", ""canShuffle"", ""List"")"
Here is an example of shuffling a list with the Collections shuffle() method:,"(""Collections"", ""hasMethod"", ""shuffle()"")"
Here is an example of sorting a Java List using Collections sort() method:,"(""Java List"", ""uses"", ""Collections.sort()""); (""_Collections"", ""has method"", ""sort()""); (""Java List"", ""sorted by"", ""Collections.sort()"")"
The Java Collections copy() method can copy one List into another.,"(""Java Collections"", ""has method"", ""copy()""); (""copy()"", ""can copy"", ""List""); (""List"", ""can be copied into"", ""List""); (""Java Collections"", ""contains"", ""List"")"
You provide the source and destination List instances as parameters to the copy() method.,"(""List"", ""is parameter of"", ""copy()""); (""copy()"", ""has parameter"", ""List""); (""copy()"", ""has parameter"", ""List"")"
The Collections min() method can find the minimum element in a List according to the natural ordering of the elements (see my Java List sorting tutorial).,"(""Collections"", ""hasMethod"", ""min()""); (""List"", ""hasElements"", ""elements""); (""min()"", ""uses"", ""natural ordering""); (""List"", ""has"", ""natural ordering""); (""Collections"", ""operatesOn"", ""List"")"
Here is an example of finding the minimum element in a Java List using Collections min() method:,"(""Java"", ""uses"", ""Collections""); (""Collections"", ""has method"", ""min()""); (""List"", ""uses"", ""Collections""); (""List"", ""uses method"", ""min()""); (""Java"", ""uses"", ""List"")"
The Collections max() method can find the maximum element in a List according to the natural order of the elements (see my Java List sorting tutorial).,"(""Collections"", ""hasMethod"", ""max()""); (""max()"", ""returns"", ""maximum element""); (""List"", ""hasElements"", ""elements""); (""elements"", ""have"", ""natural order""); (""List"", ""usedWith"", ""Collections"")"
The Java Collections replaceAll() method can replace all occurrences of one element with another element.,"(""Java Collections"", ""has method"", ""replaceAll()""); (""replaceAll()"", ""can replace"", ""element""); (""getElement"", ""is replaced by"", ""another element""); (""Java Collections"", ""contains"", ""replaceAll()""); (""replaceAll()"", ""replaces"", ""occurrences"")"
You pass the element to replace and the element to replace it with as parameters to the replaceAll() method.,"(""replaceAll()"", ""is a method of"", ""unknown class""); (""unknown class"", ""has method"", ""replaceAll()""); (""unknown class"", ""uses"", ""replaceAll()"")"
"The Collections replaceAll() method returns true if any elements were replaced, and false if not.","(""Collections"", ""hasMethod"", ""replaceAll()""); (""replaceAll()"", ""returns"", ""true""); (""replaceAll()"", ""returns"", ""false"")"
The Collections replaceAll() method uses the equals() method of each element to determine if the element is equal to the element to replace or not.,"(""Collections"", ""uses"", ""equals()""); (""Collections"", ""has method"", ""replaceAll()""); (""replaceAll()"", ""uses"", ""equals()""); (""equals()"", ""is method of"", ""element"")"
I have a written a few more details about how the equals() method works in my section about the Java equals() method.,"(""Java"", ""hasMethod"", ""equals()""); (""equals()"", ""describedIn"", ""section""); (""Java"", ""hasSection"", ""section""); (""equals()"", ""worksLike"", ""Java equals()""); (""Java equals()"", ""describedIn"", ""section"")"
The unmodifiableSet() method in the Java Collections class can create an immutable (unmodifiable) Set from a normal Java Set .,"(""Java Collections"", ""has method"", ""unmodifiableSet()""); (""unmodifiableSet()"", ""returns"", ""Set""); (""Set"", ""can be created from"", ""Set""); (""Java Collections"", ""has method"", ""unmodifiableSet()""); (""unmodifiableSet()"", ""creates"", ""unmodifiable Set"")"
"The Java Comparable interface,java.lang.Comparable, represents an object which can be compared to other objects.","(""Java"", ""has interface"", ""Comparable""); (""Comparable"", ""is in package"", ""java.lang""); (""Comparable"", ""represents"", ""object""); (""object"", ""can be compared to"", ""other objects""); (""Comparable"", ""is represented by"", ""java.lang.Comparable"")"
Several of the built-in classes in Java implements the Java Comparable interface.,"(""Java"", ""implements"", ""Java Comparable interface""); (""Java Comparable interface"", ""is implemented by"", ""built-in classes""); (""built-in classes"", ""implement"", ""Java Comparable interface"")"
"You can also implement the Java Comparable interface yourself, to make your own classes comparable.","(""Java"", ""has interface"", ""Comparable""); (""Comparable"", ""is implemented by"", ""custom classes""); (""custom classes"", ""implement"", ""Java Comparable interface"")"
"When a class implements the Java Comparable interface, this means that instances (objects) of that class can be compared to each other, as mentioned above.","(""Java"", ""implements"", ""Comparable interface""); (""Comparable interface"", ""used for"", ""comparison""); (""class"", ""implements"", ""Java Comparable interface""); (""instances"", ""are"", ""objects""); (""objects"", ""compared to"", ""each other"")"
Please keep in mind that the Comparable interface is intended for comparison of objects of the same class.,"(""Comparable"", ""is intended for"", ""comparison""); (""Comparable"", ""is intended for comparison of"", ""objects""); (""objects"", ""are of"", ""class"")"
In the following section I will explain how the compareTo() method works.,"(""compareTo()"", ""is a method of"", ""unknown class"")"
The Java Comparable compareTo() method takes a single object as parameter and returns an int value.,"(""Java"", ""has method"", ""compareTo()""); (""compareTo()"", ""takes parameter"", ""object""); (""compareTo()"", ""returns"", ""int"")"
"The int returned signal whether the object the compareTo() method is called on is larger than, equal to or smaller than the parameter object.","(""compareTo()"", ""is called on"", ""object""); (""object"", ""is compared to"", ""parameter object""); (""compareTo()"", ""returns"", ""int"")"
"The Java Integer class implements the Comparable interface, so you can call compareTo() Here is an example:","(""Integer"", ""implements"", ""Comparable""); (""Integer"", ""call"", ""compareTo()"")"
Since the value 45 is smaller than 99 - the first comparison ( valA.compareTo(valB) = 45.compareTo(99) ) results in the value -1 being returned.,"(""valA"", ""compareTo"", ""valB""); (""45"", ""compareTo"", ""99""); (""valA.compareTo(valB)"", ""returns"", ""-1""); (""45.compareTo(99)"", ""returns"", ""-1"")"
"In the second comparison, when 99 is compared to 45 ( valB.compareTo(valA) = 99.compareTo(45) ) the result is 1 - because 99 is larger than 45.","(""valB"", ""compareTo"", ""valA""); (""99"", ""compareTo"", ""45""); (""valB"", ""compareTo"", ""99""); (""99"", ""compareTo"", ""45""); (""valorB.compareTo(valA)"", ""equals"", ""99.compareTo(45)"")"
Here is an example of a Spaceship class which can compare itself to other Spaceship instances:,"(""Spaceship"", ""has method"", ""compare()""); (""Spaceship"", ""can compare to"", ""Spaceship"")"
This way you can implement compareTo() to compare base on multiple factors.,"(""compareTo()"", ""implemented in"", ""class""); (""compareTo()"", ""used for"", ""comparison""); (""class"", ""has method"", ""compareTo()"")"
"By specifying a type parameter when implementing the Comparable interface, the compareTo() method parameter changes from Object to whatever type you have specified.","(""Comparable"", ""has method"", ""compareTo()""); (""compareTo()"", ""changes parameter type from"", ""Object""); (""compareTo()"", ""changes parameter type to"", ""type parameter"")"
"Notice how there is no type parameter specified after the ""implements Comparable"" interface in the class declaration.","(""Comparable"", ""implemented by"", ""class"")"
"Notice also, how the parameter type of the compareTo() object is no longer Spaceship, but Object.","(""compareTo()"", ""parameter type"", ""Object""); (""Spaceship"", ""compareTo()"", ""Object""); (""Object"", ""used as"", ""parameter type"")"
"Finally, also notice how it is now necessary to cast the parameter of the compareTo() method to Spaceship explicitly.","(""compareTo()"", ""is a method of"", ""Spaceship""); (""Spaceship"", ""has method"", ""compareTo()"")"
"Notice too, that the compareTo() method should throw a NullPointerException if the parameter object is null.","(""compareTo()"", ""should throw"", ""NullPointerException""); (""NullPointerException"", ""is thrown by"", ""compareTo()""); (""compareTo()"", ""is a method of"", ""Object"")"
"Similarly, the compareTo() method should throw a ClassCastException if the input parameter is not of the same class as the class of the object compareTo() is called on.","(""compareTo()"", ""is called on"", ""Class""); (""Class"", ""has method"", ""compareTo()""); (""compareTo()"", ""throws"", ""ClassCastException"")"
You can just cast to the desired class (as in the example above).,
"If the classes do not match, the Java VM will throw a ClassCastException.","(""Java VM"", ""throw"", ""ClassCastException""); (""ClassCastException"", ""is thrown by"", ""Java VM""); (""Java VM"", ""checks"", ""classes"")"
"The Java Comparator interface, java.util.Comparator, represents a component that can compare two objects so they can be sorted using sorting functionality in Java.","(""Java"", ""uses"", ""Comparator""); (""Comparator"", ""is part of"", ""java.util""); (""java.util.Comparator"", ""represents"", ""component""); (""component"", ""can be used for"", ""sorting functionality""); (""sorting functionality"", ""is in"", ""Java"")"
When sorting e.g a Java List you can pass a Java Comparator to the sorting method.,"(""List"", ""has method"", ""sorting method""); (""Comparator"", ""passed to"", ""sorting method""); (""List"", ""uses"", ""Comparator""); (""Java"", ""has class"", ""List""); (""Java"", ""has interface"", ""Comparator""); (""sorting method"", ""is part of"", ""Java"")"
"This method, the compare() method, takes two objects which the Comparator implementation is intended to compare.","(""Comparator"", ""implements"", ""compare()""); (""compare()"", ""takes"", ""objects""); (""Comparator"", ""compares"", ""objects"")"
The compare() method returns an int which signals which of the two objects was larger.,"(""compare()"", ""returns"", ""int"")"
Imagine you have the following Spaceship class that you would like to be able to compare instances of:,"(""Spaceship"", ""has instances"", ""instances of Spaceship"")"
"Notice that the Spaceship class already implements the Comparable interface which compares Spaceship objects on spaceshipClass first, and then registrationNo.","(""Spaceship"", ""implements"", ""Comparable""); (""Spaceship"", ""compares"", ""spaceshipClass""); (""Spaceship"", ""compares"", ""registrationNo"")"
"First, notice how the SpaceshipComparator class implements the Comparator interface with the type Spaceship specified inside the < > characters ( implements Comparator<Spaceship> ).","(""SpaceshipComparator"", ""implements"", ""Comparator""); (""Comparator"", ""has type"", ""Spaceship"")"
"Setting the generic type of the Comparator implementation to Spaceship means that the parameter types of the compare() method can be set to Spaceship, and not Object as it would have been - if no generic type had been specified ( implements Comparator ).","(""Comparator"", ""implements"", ""Spaceship""); (""Comparator"", ""has method"", ""compare()""); (""compare()"", ""has parameter type"", ""Spaceship""); (""compare()"", ""has parameter type"", ""Object"")"
"A Java Comparator implementation is pretty much always specialized to be able to compare objects of a specific type (class), so specifying a generic type in your Comparator implementation almost always makes sense.","(""Comparator"", ""implementation"", ""Java""); (""Comparator"", ""compare"", ""objects""); (""Comparator"", ""specialized to"", ""specific type""); (""Comparator"", ""implementation"", ""generic type"")"
"Second, notice how the compare() method returns the registrationNo of the first Spaceship parameter compared to the registrationNo of the second Spaceship parameter.","(""Spaceship"", ""has method"", ""compare()""); (""compare()"", ""returns"", ""registrationNo""); (""Spaceship"", ""has attribute"", ""registrationNo"")"
"Imagine if the registrationNo variable of the Spaceship class was an int instead, so getRegistrationNo() would return an int.","(""Spaceship"", ""hasMethod"", ""getRegistrationNo()""); (""getRegistrationNo()"", ""returns"", ""int""); (""Spaceship"", ""hasVariable"", ""registrationNo"")"
"The Java Deque interface, java.util.Deque, represents a double ended queue, meaning a queue where you can add and remove elements to and from both ends of the queue.","(""Java"", ""has interface"", ""Deque""); (""Deque"", ""represents"", ""double ended queue""); (""double ended queue"", ""has property"", ""add elements to both ends""); (""double ended queue"", ""has property"", ""remove elements from both ends""); (""Deque"", ""is part of"", ""java.util"")"
The LinkedList class is a pretty standard Deque and Queue implementation.,"(""LinkedList"", ""is"", ""Deque""); (""LinkedList"", ""is"", ""Queue"")"
The Java ArrayDeque class stores its elements internally in an array.,"(""ArrayDeque"", ""stores elements in"", ""array""); (""ArrayDeque"", ""is a"", ""class""); (""Java"", ""has a class"", ""ArrayDeque"")"
Before you can use a Java Deque you must create an instance of one of the classes that implements the Deque interface.,"(""Deque"", ""implements"", ""Deque interface""); (""Java Deque"", ""instance of"", ""classes that implement Deque"")"
You add elements to the beginning end of a Deque using the add() method.,"(""Deque"", ""uses"", ""add()""); (""add()"", ""belongs to"", ""Deque""); (""Deque"", ""has method"", ""add()"")"
"If the element cannot be inserted into the Deque, the add() method will throw an exception.","(""Deque"", ""uses"", ""add()""); (""add()"", ""throws"", ""exception""); (""Deque"", ""has method"", ""add()"")"
"This is different from the offer() method, which will return false if it cannot insert the element.","(""offer()"", ""is different from"", ""method""); (""offer()"", ""will return"", ""false""); (""offer()"", ""cannot insert"", ""element"")"
The addLast() method also adds an element to the end (tail) of a Java Deque.,"(""Deque"", ""has method"", ""addLast()""); (""addLast()"", ""adds to"", ""Deque""); (""Deque"", ""is part of"", ""Java"")"
This is the Deque interface's equivalent of the add() method inherited from the Queue interface.,"(""Deque"", ""inherits from"", ""Queue""); (""Deque"", ""has method"", ""add()""); (""Queue"", ""has method"", ""add()"")"
Here is an example of adding an element to a Java Deque instance using the addLast() method:,"(""Deque"", ""uses"", ""addLast()""); (""addLast()"", ""belongs to"", ""Deque""); (""Deque"", ""instance of"", ""Java"")"
"If the element cannot be inserted into the Deque, the addLast() method will throw an exception.","(""Deque"", ""has method"", ""addLast()""); (""addLast()"", ""throws"", ""exception""); (""Deque"", ""uses method"", ""addLast()"")"
This is different from the offerLast() method which will return false if the element cannot be added to the Deque.,"(""Deque"", ""hasMethod"", ""offerLast()""); (""offerLast()"", ""returns"", ""false""); (""Deque"", ""hasMethod"", ""add""); (""add"", ""relatesTo"", ""offerLast()"")"
To add an element at the beginning (head) instead of the end of a Java Deque you call the addFirst() method instead.,"(""Deque"", ""has method"", ""addFirst()"")"
"If the element cannot be added to the beginning of the Deque, the addFirst() method will throw an exception.","(""Deque"", ""hasMethod"", ""addFirst()""); (""addFirst()"", ""throws"", ""exception""); (""Deque"", ""cannotAddTo"", ""beginning"")"
This is different from the offerFirst() method which will return false if an element cannot be inserted in the beginning of the Deque.,"(""Deque"", ""has method"", ""offerFirst()""); (""offerFirst()"", ""returns"", ""false""); (""Deque"", ""has method"", ""insert"")"
The offer() method adds an element to the end (tail) of the Deque.,"(""Deque"", ""has method"", ""offer()""); (""offer()"", ""adds to"", ""Deque""); (""Deque"", ""has part"", ""tail""); (""offer()"", ""adds to"", ""tail"")"
This is different from the add() method which will throw an exception is adding an element to the end of the Deque fails.,"(""Deque"", ""has method"", ""add()""); (""add()"", ""throws"", ""exception""); (""Deque"", ""has operation"", ""add element""); (""add element"", ""fails at"", ""end of Deque"")"
Here is an example of how to add an element to the end of a Java Deque using the offer() method:,"(""Deque"", ""uses"", ""offer()"")"
"The offerLast() method adds an element to the end (tail) of the Deque, just like offer().","(""Deque"", ""hasMethod"", ""offerLast()""); (""offerLast()"", ""addsElementTo"", ""Deque""); (""offerLast()"", ""similarTo"", ""offer()""); (""Deque"", ""hasMethod"", ""offer()"")"
The method name offerLast() is just a bit more saying about where the element is added to the Deque.,"(""Deque"", ""hasMethod"", ""offerLast()"")"
This is different from the addLast() method which will throw an exception is adding an element to the end of the Deque fails.,"(""Deque"", ""has method"", ""addLast()""); (""addLast()"", ""throws"", ""exception""); (""Deque"", ""has operation"", ""add element to the end""); (""addLast()"", ""fails"", ""adding an element to the end of the Deque"")"
Here is an example of how to add an element to the end of a Java Deque using the offerLast() method:,"(""Deque"", ""hasMethod"", ""offerLast()""); (""offerLast()"", ""belongsTo"", ""Deque"")"
The offerFirst() method adds an element to the beginning (head) of the Deque.,"(""Deque"", ""has method"", ""offerFirst()""); (""offerFirst()"", ""adds to"", ""Deque"")"
This is different from the addFirst() method which will throw an exception is adding an element to the beginning of the Deque fails.,"(""Deque"", ""hasMethod"", ""addFirst()""); (""addFirst()"", ""throws"", ""exception""); (""Deque"", ""hasMethod"", ""addFirst()""); (""addFirst()"", ""modifies"", ""Deque"")"
Here is an example of how to add an element to the beginning of a Java Deque using the offerFirst() method:,"(""Deque"", ""uses"", ""offerFirst()""); (""offerFirst()"", ""belongs to"", ""Deque"")"
The push() method adds an element to the beginning (head) of a Java Deque method.,"(""push() method"", ""adds to"", ""Java Deque""); (""Java Deque"", ""has method"", ""push() method"")"
"If adding the element fails, for instance if the Deque is full, the push() method will throw an exception.","(""Deque"", ""has method"", ""push()""); (""push()"", ""throws"", ""exception""); (""Deque"", ""has state"", ""full"")"
Here is an example of adding an element to the beginning of a Java Deque using the push() method:,"(""Deque"", ""uses"", ""push()""); (""push()"", ""belongs to"", ""Deque""); (""Java"", ""contains"", ""Deque""); (""Deque"", ""is part of"", ""Java"")"
The peek() method returns the first element from the beginning (head) of a Java Deque without removing it.,"(""peek()"", ""returns"", ""element""); (""Deque"", ""has method"", ""peek()""); (""Java"", ""contains"", ""Deque"")"
Here is an example of peeking at the first element of a Java Deque using the peek() method:,"(""Deque"", ""uses"", ""peek()""); (""peek()"", ""belongs to"", ""Deque"")"
The peekFirst() method returns the first element from the beginning (head) of a Java Deque without removing it.,"(""Deque"", ""hasMethod"", ""peekFirst()""); (""peekFirst()"", ""returns"", ""element""); (""Deque"", ""contains"", ""element""); (""Java"", ""hasClass"", ""Deque"")"
"This is similar to how peek() works, but the method name peekFirst() is a bit more saying about which end of the Deque you peek at.","(""Deque"", ""hasMethod"", ""peek()""); (""Deque"", ""hasMethod"", ""peekFirst()"")"
Here is an example of peeking at the first element of a Java Deque using the peekFirst() method:,"(""Deque"", ""uses"", ""peekFirst()""); (""peekFirst()"", ""belongs to"", ""Deque"")"
To peek at the last element of a Java Deque you can use the peekLast() method.,"(""Java Deque"", ""has method"", ""peekLast()"")"
Here is an example of peeking at the last element of a Java Deque using the peekLast() method:,"(""Deque"", ""uses"", ""peekLast()""); (""peekLast()"", ""belongs to"", ""Deque""); (""Java"", ""contains"", ""Deque""); (""Deque"", ""has method"", ""peekLast()"")"
The getFirst() method returns the first element from the beginning (head) of a Java Deque without removing it.,"(""Deque"", ""hasMethod"", ""getFirst()""); (""getFirst()"", ""returns"", ""element""); (""Deque"", ""hasElement"", ""element""); (""getFirst()"", ""belongsTo"", ""Deque"")"
Here is an example of peeking at the first element of a Java Deque using the getFirst() method:,"(""Deque"", ""uses"", ""getFirst()""); (""getFirst()"", ""belongs to"", ""Deque"")"
To peek at the last element of a Java Deque you can use the getLast() method.,"(""Deque"", ""has method"", ""getLast()""); (""getLast()"", ""returns"", ""last element""); (""Java Deque"", ""uses method"", ""getLast()"")"
Here is an example of peeking at the last element of a Java Deque using the getLast() method:,"(""Deque"", ""uses"", ""getLast()""); (""getLast()"", ""belongs to"", ""Deque""); (""Java"", ""contains"", ""Deque""); (""Deque"", ""has method"", ""getLast()"")"
The remove() method removes the first element of a Java Deque.,"(""Deque"", ""has method"", ""remove()""); (""remove()"", ""is method of"", ""Deque""); (""Deque"", ""uses method"", ""remove()"")"
The remove() method returns the element that is removed from the Deque.,"(""Deque"", ""has method"", ""remove()""); (""remove()"", ""returns"", ""element"")"
Here is an example of removing the first element a Java Deque using the remove() method:,"(""Deque"", ""uses"", ""remove()""); (""remove()"", ""called on"", ""Deque"")"
This is different from poll() which returns null if the Deque is empty.,"(""Deque"", ""has method"", ""poll()""); (""poll()"", ""returns"", ""null""); (""Deque"", ""is checked for"", ""empty"")"
The removeFirst() method also removes the first element from a Deque - the element at the head of the Deque.,"(""Deque"", ""has method"", ""removeFirst()""); (""removeFirst()"", ""removes"", ""element""); (""Deque"", ""contains"", ""element""); (""Deque"", ""has"", ""head""); (""head"", ""contains"", ""element""); (""removeFirst()"", ""modifies"", ""Deque"")"
Here is an example of removing the first element of a Java Deque using the removeFirst() method:,"(""Java Deque"", ""uses"", ""removeFirst() method""); (""removeFirst() method"", ""belongs to"", ""Java Deque"")"
This is different from pollFirst() which returns null if the Deque is empty.,"(""Deque"", ""has method"", ""pollFirst()""); (""Deque"", ""has method"", ""pollFirst()""); (""pollFirst()"", ""returns"", ""null"")"
The removeLast() method removes the last element of a Deque - meaning the element at the tail of the Deque.,"(""Deque"", ""has method"", ""removeLast()""); (""removeLast()"", ""removes"", ""element""); (""Deque"", ""contains"", ""element""); (""Deque"", ""has"", ""tail""); (""removeLast()"", ""affects"", ""tail""); (""Deque"", ""has element at"", ""tail"")"
Here is an example of removing the last element of a Java Deque using the removeLast() method:,"(""Deque"", ""uses"", ""removeLast()""); (""removeLast()"", ""is method of"", ""Deque"")"
After running this Java example the removedElement variable will point to the String object element 2 - since that element was the last element of the Deque when removeLast() was called.,"(""Deque"", ""removeLast()"", ""removedElement""); (""Deque"", ""removeLast()"", ""String""); (""removedElement"", ""points to"", ""String"")"
This is different from pollLast() which returns null if the Deque is empty.,"(""Deque"", ""hasMethod"", ""pollLast()""); (""Deque"", ""hasMethod"", ""pollLast()""); (""null"", ""returnedBy"", ""pollLast()""); (""Deque"", ""returns"", ""null"")"
The poll() method removes an element from the beginning of the Deque.,"(""Deque"", ""has method"", ""poll()""); (""poll()"", ""removes from"", ""Deque"")"
This is different than remove() which throws an exception if the Deque is empty.,"(""Deque"", ""has method"", ""remove()"")"
Here is an example of removing the first element from a Java Deque using the poll() method:,"(""Deque"", ""uses"", ""poll()""); (""poll()"", ""removes"", ""element""); (""Java"", ""contains"", ""Deque"")"
"The pollFirst() method removes an element from the beginning of the Deque, just like poll().","(""Deque"", ""hasMethod"", ""pollFirst()""); (""Deque"", ""hasMethod"", ""poll()""); (""pollFirst()"", ""similarTo"", ""poll()"")"
The method name pollFirst() is just a bit more saying about from where the method removes elements.,"(""pollFirst()"", ""is_method_of"", ""unknown_class""); (""pollFirst()"", ""removes_elements_from"", ""collection"")"
This is different than removeFirst() which throws an exception if the Deque is empty.,"(""Deque"", ""has method"", ""removeFirst()""); (""removeFirst()"", ""throws"", ""exception""); (""Deque"", ""has state"", ""empty"")"
Here is an example of removing the first element from a Java Deque using the pollFirst() method:,"(""Deque"", ""uses"", ""pollFirst()""); (""Java"", ""contains"", ""Deque""); (""Deque"", ""has method"", ""pollFirst()"")"
The pollLast() method removes an element from the end (tail) of the Deque.,"(""Deque"", ""hasMethod"", ""pollLast()""); (""Deque"", ""contains"", ""element""); (""pollLast()"", ""removes"", ""element""); (""Deque"", ""hasElementAt"", ""end""); (""Deque"", ""hasEnd"", ""tail""); (""pollLast()"", ""isPartOf"", ""Deque"")"
This is different than removeLast() which throws an exception if the Deque is empty.,"(""Deque"", ""hasMethod"", ""removeLast()""); (""removeLast()"", ""throwsExceptionInCondition"", ""Deque.isEmpty"")"
Here is an example of removing the last element from a Java Deque using the pollLast() method:,"(""Deque"", ""uses"", ""pollLast()""); (""Java"", ""contains"", ""Deque""); (""Deque"", ""has method"", ""pollLast()"")"
The pop() method removes an element from the beginning (head) of a Java Deque.,"(""Deque"", ""has method"", ""pop()""); (""pop()"", ""removes from"", ""Deque""); (""Deque"", ""is part of"", ""Java"")"
"If removing the element fails, for instance if the Deque is empty, the pop() method will throw an exception.","(""Deque"", ""has method"", ""pop()""); (""pop()"", ""throws"", ""exception""); (""Deque"", ""can be"", ""empty"")"
Here is an example of removing the first element from a Java Deque using the pop() method:,"(""Deque"", ""uses"", ""pop()""); (""pop()"", ""removes"", ""element""); (""Java"", ""contains"", ""Deque""); (""Deque"", ""has"", ""pop()"")"
You can use the Java Deque contains() method to check if a Deque contains a given element.,"(""Deque"", ""contains"", ""element""); (""Java"", ""has method"", ""Deque.contains()"")"
"The contains() method will return true if the Deque contains the element, and false if not.","(""Deque"", ""contains"", ""element"")"
Here is an example of checking if a Java Deque contains a specific element using the contains() method:,"(""Deque"", ""uses"", ""contains()""); (""Java"", ""has"", ""Deque""); (""Deque"", ""has"", ""contains()""); (""contains()"", ""isMethodOf"", ""Deque"")"
The Java Deque size() method returns the number of elements stored in the Java Deque at the time you invoke the method.,"(""Java Deque"", ""has method"", ""size()""); (""Java Deque"", ""stores"", ""elements""); (""size()"", ""returns"", ""number of elements"")"
Here is an example of obtaining the number of elements in a Java Deque using its size() method:,"(""Java Deque"", ""has method"", ""size()""); (""Java Deque"", ""uses method"", ""size()""); (""size()"", ""belongs to"", ""Java Deque"")"
After running this code the size variable will contain the value 2 because the Deque contains 2 element at the time size() is called.,"(""Deque"", ""contains"", ""element""); (""Deque"", ""has method"", ""size()""); (""size()"", ""is called on"", ""Deque"")"
"When you have specified a generic type for a Java collection, that generic type also works for the Iterator returned by the iterator() method.","(""Java collection"", ""has method"", ""iterator()""); (""iterator()"", ""returns"", ""Iterator""); (""Iterator"", ""is returned by"", ""iterator()""); (""Java collection"", ""uses"", ""generic type""); (""generic type"", ""works for"", ""Iterator"")"
Notice how it is not necessary to cast the String returned from the iterator.next() method call.,"(""iterator"", ""hasMethod"", ""next()""); (""iterator.next()"", ""returns"", ""String"")"
"Because the Iterator has its generic type set to String, the Java compiler already knows that next() will return a String.","(""Iterator"", ""hasMethod"", ""next()""); (""Java compiler"", ""knowsReturnType"", ""String""); (""Iterator"", ""hasGenericType"", ""String"")"
The methods hashCode() and equals() play a distinct role in the objects you insert into Java collections.,"(""hashCode()"", ""is a method of"", ""Object""); (""equals()"", ""is a method of"", ""Object""); (""Object"", ""has method"", ""hashCode()""); (""Object"", ""has method"", ""equals()"")"
equals() is used in most collections to determine if a collection contains a given element.,"(""Collection"", ""contains"", ""Element""); (""Collection"", ""uses"", ""equals()""); (""equals()"", ""is used in"", ""Collection"")"
"The ArrayList iterates all its elements and execute ""123"".equals(element) to determine if the element is equal to the parameter object ""123"".","(""ArrayList"", ""iterates"", ""elements""); (""ArrayList"", ""executes"", ""equals()""); (""equals()"", ""compares"", ""element""); (""equals()"", ""compares"", ""123""); (""element"", ""isComparedTo"", ""123"")"
It is the String.equals() implementation that determines if two strings are equal.,"(""String"", ""has method"", ""equals()""); (""equals()"", ""is part of"", ""String"")"
"The ArrayList again iterates all its elements and execute ""123"".equals(element) to determine if the element is equal to the parameter object ""123"".",
"As you can see, a proper implementation of .equals() is essential for your own classes to work well with the Java Collection classes.","(""Java Collection"", ""work well with"", "".equals()""); (""Java Collection"", ""is used by"", ""own classes""); (""own classes"", ""implement"", "".equals()"")"
"That depends on your application, the classes, and what you are trying to do.","(""application"", ""depends on"", ""classes""); (""classes"", ""are used in"", ""application""); (""application"", ""is related to"", ""what you are trying to do"")"
"The hashCode() method of objects is used when you insert them into a HashTable, HashMap or HashSet.","(""HashTable"", ""uses"", ""hashCode()""); (""HashMap"", ""uses"", ""hashCode()""); (""HashSet"", ""uses"", ""hashCode()""); (""hashCode()"", ""called by"", ""HashTable""); (""hashCode()"", ""called by"", ""HashMap""); (""hashCode()"", ""called by"", ""HashSet"")"
"If you do not know the theory of how a hashtable works internally, you can read about hastables on Wikipedia.org.",
The hashtable then iterates this area (all keys with the same hash code) and uses the key's equals() method to find the right key.,"(""hashtable"", ""iterates"", ""area""); (""area"", ""contains"", ""keys""); (""keys"", ""have"", ""hash code""); (""key"", ""uses"", ""equals() method""); (""equals() method"", ""finds"", ""right key""); (""hashtable"", ""uses"", ""equals() method"")"
"So, as you can see, a combination of the hashCode() and equals() methods are used when storing and when looking up objects in a hashtable.","(""hashCode()"", ""used with"", ""equals()""); (""hashCode()"", ""used for"", ""storing objects""); (""equals()"", ""used for"", ""storing objects""); (""hashCode()"", ""used for"", ""looking up objects""); (""equals()"", ""used for"", ""looking up objects"")"
"Here are two rules that are good to know about implementing the hashCode() method in your own classes, if the hashtables in the Java Collections API are to work correctly:","(""Java Collections API"", ""contains"", ""hashCode()""); (""hashCode()"", ""implemented in"", ""classes""); (""hashtables"", ""part of"", ""Java Collections API"")"
Here are two example implementation of the hashCode() method matching the equals() methods shown earlier:,"(""hashCode()"", ""method of"", ""Object""); (""equals()"", ""method of"", ""Object""); (""hashCode()"", ""overrides"", ""Object.hashCode()""); (""equals()"", ""overrides"", ""Object.equals()"")"
For a 100% precise description of how to implement equals() and hashCode() you should check out the official JavaDoc's.,"(""JavaDoc"", ""describes"", ""equals()""); (""JavaDoc"", ""describes"", ""hashCode()"")"
The purpose of this text was mostly to explain how they are used by the Java Collection classes.,"(""Java Collection"", ""used by"", ""this text""); (""Java Collection classes"", ""used by"", ""this text""); (""Java Collection"", ""explained in"", ""this text""); (""Java"", ""contains"", ""Java Collection classes""); (""Java Collection classes"", ""part of"", ""Java"")"
"This means, that a class that implements the Java Iterable interface can have its elements iterated.","(""Java"", ""implements"", ""Iterable interface""); (""Iterable interface"", ""has elements iterated by"", ""class""); (""class"", ""implements"", ""Java Iterable interface"")"
"You can iterate the objects of a Java Iterable in three ways: Via the , by obtaining a Java Iterator from the Iterable, or by calling the Java Iterable forEach() method.","(""Java Iterator"", ""obtained from"", ""Java Iterable""); (""Java Iterable"", ""has method"", ""forEach()""); (""Java Iterable"", ""used by"", ""Java Iterator"")"
"Then it uses a for-each loop to iterate the elements of the List, and print out the toString() value of each element.","(""List"", ""uses"", ""for-each loop""); (""for-each loop"", ""iterates"", ""List""); (""List"", ""has"", ""elements""); (""elements"", ""have"", ""toString()""); (""toString()"", ""returns"", ""value""); (""List"", ""contains"", ""elements""); (""for-each loop"", ""prints"", ""toString()"")"
The second way you can iterate the elements of a Java Iterable is by obtaining a Java Iterator from it by calling the Iterable iterator() method.,"(""Java Iterable"", ""has method"", ""iterator()""); (""Iterable"", ""has method"", ""iterator()""); (""Java Iterator"", ""obtained from"", ""Iterable""); (""Iterable"", ""has method"", ""iterator()""); (""iterator()"", ""returns"", ""Java Iterator"")"
The third way to iterate the elements of a Java Iterable is via its forEach() method.,"(""Iterable"", ""has method"", ""forEach()""); (""Java"", ""has interface"", ""Iterable""); (""forEach()"", ""is method of"", ""Iterable"")"
Here is an example of iterating the elements of an Iterable via its forEach() method:,"(""Iterable"", ""has method"", ""forEach()"")"
The Java Iterable interface (java.lang.Iterable) is one of the root interfaces of the Java Collections API.,"(""Java Iterable"", ""is part of"", ""Java Collections API""); (""java.lang.Iterable"", ""is"", ""Java Iterable"")"
"Therefore, there are several classes in Java that implements the Java Iterable interface.","(""Java"", ""implements"", ""Iterable interface"")"
You can obtain a Java Spliterator from a Java Iterable via its spliterator() method.,"(""Java Iterable"", ""has method"", ""spliterator()""); (""Java Iterable"", ""returns"", ""Java Spliterator""); (""Java Spliterator"", ""obtained from"", ""Java Iterable""); (""spliterator()"", ""is method of"", ""Java Iterable"")"
"If you are writing some code that needs to iterate a collection lots of times in a tight loop, let's say iterate a Java List thousands of times per second, iterating the List via the Java for-each loop is slower than iterating the list via a standard for-loop as seen here: () .","(""List"", ""is iterated by"", ""Java for-each loop""); (""List"", ""is iterated by"", ""standard for-loop""); (""Java for-each loop"", ""is slower than"", ""standard for-loop"")"
"The reason the for-each loop is slower is, that each iteration will call the List iterator() method, which will create a new Iterator object.","(""List"", ""hasMethod"", ""iterator()""); (""List"", ""creates"", ""Iterator""); (""Iterator"", ""isCreatedby"", ""List.iterator()""); (""List"", ""hasMethod"", ""iterator()""); (""iterator()"", ""returns"", ""Iterator"")"
The standard Java collection interface Collection contains a method called iterator().,"(""Collection"", ""contains"", ""iterator()"")"
By calling iterator() you can obtain an iterator from the given Collection.,"(""Collection"", ""has method"", ""iterator()"")"
"You can also obtain an Iterator from many of the Java Collection data structures, e.g.","(""Java Collection"", ""has"", ""Iterator""); (""Java Collection"", ""obtained from"", ""data structures""); (""Iterator"", ""obtained from"", ""Java Collection""); (""Java Collection"", ""part of"", ""Java""); (""Iterator"", ""part of"", ""Java""); (""Java Collection"", ""related to"", ""data structures"")"
The first method is the Iterator hasNext() method which returns true if the Iterator contains more elements.,"(""Iterator"", ""has method"", ""hasNext()""); (""Iterator"", ""contains"", ""elements""); (""hasNext()"", ""returns"", ""true"")"
"In other words, if the Iterator has not yet iterated over all of the elements in the collection the Iterator was obtained from - the hasNext() method will return true.","(""Iterator"", ""hasMethod"", ""hasNext()""); (""hasNext()"", ""returns"", ""true""); (""Iterator"", ""obtainedFrom"", ""collection"")"
If the Iterator has iterated over all elements in the underlying collection - the hasNext() method returns false.,"(""Iterator"", ""has method"", ""hasNext()""); (""hasNext()"", ""returns"", ""false""); (""Iterator"", ""iterates over"", ""collection"")"
The second method to pay attention to is the next() method.,"(""next"", ""method of"", ""unknown class"")"
The next() method returns the next element of the collection the Iterator is iterating over.,"(""Iterator"", ""has method"", ""next()""); (""Iterator"", ""iterates over"", ""collection""); (""next()"", ""returns"", ""element"")"
In that case you will get a ConcurrentModificationException the next time you call the Iterator next() method.,"(""ConcurrentModificationException"", ""thrown by"", ""Iterator.next()""); (""Iterator"", ""has method"", ""next()"")"
The Java Iterator interface has a remove() method which lets you remove the element just returned by next() from the underlying collection.,"(""Java Iterator"", ""has method"", ""remove()""); (""remove()"", ""removes element from"", ""underlying collection""); (""remove()"", ""called after"", ""next()""); (""underlying collection"", ""has element removed by"", ""remove()"")"
"The Java Iterator forEachRemaining() method can iterate over all of the elements remaining in the Iterator internally, and for each element call a Java Lambda Expression passed as parameter to forEachRemaining() .","(""Iterator"", ""hasMethod"", ""forEachRemaining()""); (""forEachRemaining()"", ""takesParameter"", ""Lambda Expression""); (""Iterator"", ""uses"", ""Lambda Expression"")"
Here is an example of using the Java Iterator forEachRemaining() method:,"(""Java"", ""uses"", ""Iterator""); (""Iterator"", ""has method"", ""forEachRemaining()""); (""forEachRemaining()"", ""is a method of"", ""Iterator"")"
"The Java List interface, java.util.List, represents an ordered sequence of objects.","(""Java List"", ""represents"", ""ordered sequence of objects""); (""Java List"", ""is part of"", ""java.util.List""); (""java.util.List"", ""represents"", ""ordered sequence of objects"")"
"If the List is not typed, using Java Generics, then you can even mix objects of different types (classes) in the same List.","(""List"", ""isNotTypedWith"", ""Java Generics""); (""List"", ""canContain"", ""objects""); (""objects"", ""areOf"", ""different types""); (""objects"", ""areOf"", ""classes""); (""List"", ""canMix"", ""objects""); (""Java Generics"", ""types"", ""List""); (""List"", ""contains"", ""classes""); (""List"", ""contains"", ""objects"")"
These List implementations are explained in more detail in my java.util.concurrent tutorial .,"(""List"", ""is explained in"", ""java.util.concurrent""); (""List"", ""is part of"", ""java.util""); (""java.util.concurrent"", ""contains"", ""tutorial""); (""java.util"", ""contains"", ""List"")"
You create a List instance by creating an instance of one of the classes that implements the List interface.,"(""List"", ""implements"", ""List interface""); (""List"", ""created by"", ""classes""); (""List interface"", ""implemented by"", ""classes"")"
"Remember, most often you will use the ArrayList class, but there can be cases where using one of the other implementations might make sense.","(""ArrayList"", ""is_a"", ""class""); (""ArrayList"", ""has_implementation"", ""implementations""); (""implementations"", ""is_a"", ""classes""); (""ArrayList"", ""is_part_of"", ""Java Collections Framework"")"
"Thus, you need to cast them to the concrete class (or interface) that you know the object to be of.",
You insert elements (objects) into a Java List using its add() method.,"(""List"", ""hasMethod"", ""add()""); (""List"", ""usesMethod"", ""add()""); (""Java"", ""hasClass"", ""List""); (""List"", ""isPartOf"", ""Java"")"
Here is an example of adding elements to a Java List using the add() method:,"(""List"", ""hasMethod"", ""add()""); (""List"", ""usesMethod"", ""add()""); (""Java"", ""containsClass"", ""List""); (""List"", ""belongsTo"", ""Java""); (""add()"", ""isMethodOf"", ""List"")"
The first three add() calls add a String instance to the end of the list.,"(""list"", ""hasMethod"", ""add()""); (""list"", ""contains"", ""String"")"
"The List interface has a version of the add() method that takes an index as first parameter, and the element to insert as the second parameter.","(""List"", ""has"", ""add()""); (""List"", ""has method"", ""add()""); (""add()"", ""takes parameter"", ""index""); (""add()"", ""takes parameter"", ""element""); (""List"", ""contains method"", ""add()""); (""List"", ""has version of"", ""add()"")"
"The addAll() method takes a Collection as parameter, so you can pass either a List or Java Set as parameter.","(""addAll()"", ""takes"", ""Collection""); (""addAll()"", ""takes"", ""List""); (""addAll()"", ""takes"", ""Java Set"")"
"In other words, you can add all elements from a List or Set into a List with addAll() .","(""List"", ""hasMethod"", ""addAll()""); (""List"", ""usesMethod"", ""addAll()""); (""Set"", ""usesMethod"", ""addAll()""); (""List"", ""canContain"", ""List""); (""List"", ""canContain"", ""Set"")"
The indexOf() method finds the index of the first occurrence in the List of the given element.,"(""List"", ""has method"", ""indexOf()""); (""List"", ""contains"", ""element""); (""indexOf()"", ""returns"", ""index""); (""List"", ""has element"", ""element"")"
The lastIndexOf() method finds the index of the last occurrence in the List of a given element.,"(""List"", ""has method"", ""lastIndexOf()""); (""lastIndexOf()"", ""finds"", ""index""); (""List"", ""contains"", ""element"")"
You can check if a Java List contains a given element using the List contains() method.,"(""Java List"", ""contains"", ""element""); (""List"", ""has method"", ""contains()""); (""List"", ""contains method"", ""contains()"")"
Here is an example of checking if a Java List contains an element using the contains() method:,"(""Java List"", ""contains"", ""contains() method""); (""List"", ""has method"", ""contains()""); (""Java"", ""has class"", ""List""); (""List"", ""has method"", ""contains()"")"
"Obviously, if the input parameter to contains() is null, the contains() method will not use the equals() method to compare against each element, but rather use the == operator.","(""contains()"", ""uses"", ""equals()""); (""equals()"", ""compared by"", ""==""); (""contains()"", ""compares against"", ""element"")"
The Java List interface contains a clear() method which removes all elements from the list when called.,"(""List"", ""contains"", ""clear()""); (""List"", ""hasMethod"", ""clear()""); (""clear()"", ""removesFrom"", ""List""); (""List"", ""hasMethod"", ""clear()"")"
Here is simple example of removing all elements from a List (clearing) with the clear() method:,"(""List"", ""hasMethod"", ""clear()"")"
"After the clear() method has been called, the List will be completely empty.","(""List"", ""hasMethod"", ""clear()""); (""List"", ""becomes"", ""empty""); (""clear()"", ""isMethodOf"", ""List"")"
The Java List interface has a method called retainAll() which is capable of retaining all elements from one List which are also present in another List.,"(""Java List"", ""has method"", ""retainAll()""); (""List"", ""contains"", ""elements""); (""retainAll()"", ""retains"", ""elements""); (""List"", ""is present in"", ""another List""); (""List"", ""has method"", ""retainAll()"")"
"In other words, the retain() method removes all the elements from the target List which are not found in the other List.","(""List"", ""hasMethod"", ""retain()""); (""retain()"", ""removes"", ""elements""); (""List"", ""contains"", ""elements"")"
Here is a Java example of calling the List retainAll() method:,"(""List"", ""hasMethod"", ""retainAll()""); (""Java"", ""uses"", ""List""); (""List"", ""hasMethod"", ""retainAll()"")"
"Third, the retainAll() method is called on list, passing otherList as parameter.","(""list"", ""retainAll()"", ""otherList""); (""retainAll()"", ""is called on"", ""list""); (""list"", ""passes as parameter"", ""otherList"")"
"After list.retainAll(otherList) has finished executing, the list will only contain those elements which were both present in list and otherList before retainAll() was called.","(""list"", ""retainAll"", ""otherList""); (""list"", ""contain"", ""elements""); (""elements"", ""present"", ""list""); (""elements"", ""present"", ""otherList""); (""retainAll"", ""called"", ""list"")"
You can obtain the number of elements in the List by calling the size() method.,"(""List"", ""hasMethod"", ""size()"")"
The Java List interface has a method called subList() which can create a new List with a subset of the elements from the original List.,"(""Java List"", ""has method"", ""subList()""); (""List"", ""has subset"", ""elements""); (""subList()"", ""creates"", ""new List""); (""List"", ""has elements"", ""original List"")"
The subList() method takes 2 parameters: A start index and and end index.,"(""subList()"", ""takes"", ""parameters""); (""subList()"", ""has"", ""start index""); (""subList()"", ""has"", ""end index""); (""parameters"", ""include"", ""start index""); (""parameters"", ""include"", ""end index"")"
Here is a Java example of creating a sublist of elements from another List using the subList() method:,"(""List"", ""hasMethod"", ""subList()""); (""List"", ""usesMethod"", ""subList()""); (""subList()"", ""belongsTo"", ""List"")"
"After executing the list.subList(1,3) instruction the sublist will contain the elements at index 1 and 2.","(""list"", ""has method"", ""subList()""); (""subList()"", ""returns"", ""sublist""); (""sublist"", ""contains"", ""elements""); (""elements"", ""are at"", ""index"")"
"The list.subList(1,3) call will include index 1, but exclude index 3, thereby keeping the elements at index 1 and 2.","(""list"", ""hasMethod"", ""subList()""); (""list"", ""containsIndex"", ""1""); (""list"", ""containsIndex"", ""2""); (""list"", ""excludesIndex"", ""3""); (""subList()"", ""isMethodOf"", ""list"")"
You can convert a Java List to a Java Array using the List toArray() method.,"(""List"", ""hasMethod"", ""toArray()""); (""List"", ""usesMethod"", ""toArray()""); (""Java"", ""hasDataType"", ""List""); (""Java"", ""hasDataType"", ""Array""); (""toArray()"", ""belongsTo"", ""List""); (""List"", ""convertsTo"", ""Array"")"
"Note that even if we pass a String array of size 0 to the toArray(), the array returned will have all the elements in the List in it.","(""List"", ""has method"", ""toArray()""); (""List"", ""returns"", ""array""); (""toArray()"", ""takes parameter"", ""String array""); (""String array"", ""has size"", ""0""); (""List"", ""contains"", ""elements""); (""toArray()"", ""returns"", ""elements""); (""array"", ""contains"", ""elements"")"
It is the Arrays.asList() method that converts the array to a List.,"(""Arrays"", ""hasMethod"", ""asList()""); (""asList()"", ""convertsTo"", ""List""); (""Array"", ""convertedBy"", ""asList()"")"
You can sort a Java List using the Collections sort() method.,"(""Java List"", ""uses"", ""Collections""); (""Java List"", ""sorted by"", ""Collections.sort()""); (""Collections"", ""has method"", ""sort()"")"
"If the List contains objects that implement the Comparable interface (java.lang.Comparable), then the objects can compare themselves to each other.","(""List"", ""contains"", ""objects""); (""objects"", ""implement"", ""java.lang.Comparable""); (""objects"", ""compare"", ""each other""); (""java.lang.Comparable"", ""is implemented by"", ""objects"")"
"The Java String class implements the Comparable interface, you can sort them in their natural order, using the Collections sort() method.","(""String"", ""implements"", ""Comparable""); (""Comparable"", ""used in"", ""Collections.sort()""); (""String"", ""used in"", ""Collections.sort()""); (""_Collections"", ""has method"", ""sort()""); (""String"", ""sorted by"", ""Collections.sort()"")"
"If the objects in the Java List do not implement the Comparable interface, or if you want to sort the objects in another order than their compare() implementation, then you need to use a Comparator implementation (java.util.Comparator).","(""Java List"", ""uses"", ""Comparable interface""); (""Comparable interface"", ""has"", ""compare() method""); (""Comparator implementation"", ""implements"", ""java.util.Comparator""); (""Java List"", ""uses"", ""Comparator implementation""); (""Comparator implementation"", ""provides"", ""custom sorting order"")"
You obtain an Iterator by calling the iterator() method of the List interface.,"(""List"", ""has method"", ""iterator()""); (""Iterator"", ""obtained by"", ""iterator()""); (""List"", ""has method"", ""iterator()""); (""List interface"", ""has method"", ""iterator()""); (""iterator()"", ""called on"", ""List""); (""Iterator"", ""returned by"", ""iterator()""); (""List interface"", ""returns"", ""Iterator""); (""List"", ""returns"", ""Iterator"")"
Once you have obtained an Iterator you can keep calling its hasNext() method until it returns false.,"(""Iterator"", ""has"", ""hasNext() method""); (""Iterator"", ""has"", ""hasNext() method""); (""hasNext() method"", ""returns"", ""boolean value"")"
Calling hasNext() is done inside a while loop as you can see.,"(""while loop"", ""calls"", ""hasNext()"")"
Inside the while loop you call the Iterator next() method of the Iterator interface to obtain the next element pointed to by the Iterator.,"(""Iterator"", ""has method"", ""next()""); (""Iterator"", ""implements"", ""Iterator interface""); (""Iterator interface"", ""has method"", ""next()"")"
"Inside the for loop the example accesses the elements in the List via its get() method, passing the incrementing variable i as parameter.","(""List"", ""hasMethod"", ""get()""); (""get()"", ""takesParameter"", ""i""); (""List"", ""isAccessedVia"", ""get()"")"
"Again, if the List is typed using Java Generics to e.g.","(""List"", ""is typed using"", ""Java Generics"")"
"Hence, the compiler knows that only a String can be returned from the get() method.","(""get"", ""returns"", ""String"")"
Therefore you do not need to cast the element returned by get() to String.,
Obtaining a Stream from a List in Java is done by calling the List stream() method.,"(""List"", ""hasMethod"", ""stream()""); (""Java"", ""utilizes"", ""List""); (""Stream"", ""isReturnedBy"", ""List.stream()""); (""List"", ""hasMethod"", ""stream()""); (""List.stream()"", ""returns"", ""Stream"")"
It is the last line of this example that calls the List stream() method to obtain the Stream representing the elements in the List.,"(""List"", ""calls"", ""stream() method""); (""stream() method"", ""is called by"", ""List""); (""List"", ""has"", ""stream() method""); (""stream() method"", ""returns"", ""Stream""); (""List"", ""obtains"", ""Stream"")"
Once you have obtained a Stream from a List you can iterate the Stream by calling its forEach() method.,"(""Stream"", ""has method"", ""forEach()""); (""List"", ""has method"", ""forEach() is called on its Stream""); (""Stream"", ""is obtained from"", ""List""); (""forEach()"", ""is method of"", ""Stream"")"
Here is an example of iterating the elements of a List using the Stream forEach() method:,"(""List"", ""uses"", ""Stream""); (""Stream"", ""has method"", ""forEach()""); (""List"", ""iterated by"", ""forEach()"")"
"Calling the forEach() method will make the Stream iterate all the element of the Stream internally, and call the Consumer passed as parameter to the forEach() method for each element in the Stream.","(""Stream"", ""has method"", ""forEach()""); (""forEach()"", ""takes parameter"", ""Consumer""); (""Stream"", ""iterates over"", ""element""); (""forEach()"", ""calls"", ""Consumer""); (""Consumer"", ""is passed to"", ""forEach()""); (""Stream"", ""contains"", ""element"")"
"The Java Map interface, java.util.Map, represents a mapping between a key and a value.","(""Java Map"", ""represents"", ""mapping""); (""Java Map"", ""is part of"", ""java.util""); (""Java Map"", ""has relationship with"", ""key""); (""Java Map"", ""has relationship with"", ""value""); (""java.util.Map"", ""is"", ""Java Map"")"
To create a Java Map you must create an instance of one the classes that implement the Java Map interface.,"(""Java Map"", ""implements"", ""Java Map interface""); (""Java Map interface"", ""implemented by"", ""classes"")"
To add elements to a Map you call its put() method.,"(""Map"", ""has method"", ""put()"")"
The three put() calls maps a string value to a string key.,"(""put()"", ""maps"", ""string value""); (""put()"", ""maps"", ""string key""); (""put()"", ""called"", ""three times"")"
Here is an example of auto-boxing primitive parameters passed to the put() method:,"(""put()"", ""is a method of"", ""Map""); (""Map"", ""has a method"", ""put()""); (""put()"", ""is used for"", ""auto-boxing"")"
The value passed to the put() method in the above example is a primitive int.,"(""put()"", ""is a method of"", ""some object""); (""put()"", ""takes as parameter"", ""int""); (""int"", ""is passed to"", ""put()"")"
"Java auto-boxes it inside an Integer instance though, because the put() method requires an Oject instance as both key and value.","(""Integer"", ""instance of"", ""Object""); (""put()"", ""requires"", ""Object""); (""put()"", ""requires"", ""Object"")"
Auto-boxing would also happen if you passed a primitive as key to the put() method.,"(""put() method"", ""would happen in"", ""Auto-boxing""); (""put() method"", ""has parameter"", ""primitive""); (""primitive"", ""passed as"", ""key"")"
"If you call put() more than once with the same key, the latest value passed to put() for that key will overwrite what is already stored in the Map for that key.","(""Map"", ""has method"", ""put()""); (""put()"", ""overwrites"", ""value""); (""Map"", ""stores"", ""key""); (""Map"", ""stores"", ""value""); (""key"", ""has"", ""value"")"
To obtain the value stored by the null key you call the get() method with null as parameter value.,"(""get() method"", ""called with"", ""null""); (""get() method"", ""belongs to"", ""unspecified class""); (""null"", ""passed as parameter to"", ""get() method"")"
Just keep in mind that you will get a null out when you call get() later with that key - so this will return null:,
The Java Map interface has a method called putAll() which can copy all key + value pairs (entries) from another Map instance into itself.,"(""Map"", ""has method"", ""putAll()""); (""putAll()"", ""copies from"", ""Map""); (""Map"", ""contains"", ""key + value pairs""); (""Map"", ""contains"", ""entries"")"
Here is an example of copying all entries from one Java Map into another via putAll():,"(""Map"", ""putAll()"", ""another Map"")"
"Calling mapB.putAll(mapA) will only copy entries from mapA into mapB, not from mapB into mapA.","(""mapB"", ""putAll"", ""mapA""); (""mapA"", ""putAll"", ""mapB"")"
"To copy entries the other way, you would have to execute the code mapA.putAll(mapB).","(""mapA"", ""putAll"", ""mapB"")"
"To get a specific element stored in a Java Map you call its get() method, passing along the key for that element as parameter.","(""Java Map"", ""has method"", ""get()""); (""get()"", ""takes parameter"", ""key""); (""Java Map"", ""stores"", ""element"")"
"Notice that the get() method returns a Java Object, so we have to cast it to a String (because we know the value is a String).","(""get()"", ""returns"", ""Java Object""); (""Java Object"", ""is cast to"", ""String"")"
"If we had specified a generic type for the key and value of the Map, then it would not have been necessary to cast the object returned by get() method.","(""Map"", ""hasMethod"", ""get()""); (""get()"", ""returns"", ""Object""); (""Map"", ""hasMethod"", ""put()""); (""Object"", ""isReturnedBy"", ""get()"")"
The Java Map interface has a getOrDefault() method which can return a default value supplied by you - in case no value is stored in the Map by the given key.,"(""Java Map"", ""has method"", ""getOrDefault()""); (""getOrDefault()"", ""returns"", ""default value""); (""Map"", ""stores"", ""value""); (""getOrDefault()"", ""takes"", ""key"")"
"This example creates a Map and stores three values in it using the keys A, B and C. Then the example calls the Map getOrDefault() method, passing the String E as key, along with a default value - the String default value.","(""Map"", ""uses"", ""getOrDefault()""); (""getOrDefault()"", ""called with"", ""String""); (""Map"", ""stores"", ""values""); (""Map"", ""has keys"", ""A""); (""Map"", ""has keys"", ""B""); (""Map"", ""has keys"", ""C""); (""getOrDefault()"", ""passes"", ""String E""); (""getOrDefault()"", ""passes"", ""default value""); (""Map"", ""retrieves with"", ""getOrDefault()"")"
Since the Map does not contain any object stored by the key E the given default value will be returned - which is the String default value passed as the last parameter to the getOrDefault() method.,"(""Map"", ""contains"", ""key""); (""Map"", ""does not contain"", ""object""); (""getOrDefault() method"", ""returns"", ""default value""); (""getOrDefault() method"", ""has parameter"", ""default value""); (""default value"", ""is"", ""String"")"
You can check if a Java Map contains a specific key using the containsKey() method.,"(""Java Map"", ""contains"", ""key""); (""Java Map"", ""uses"", ""containsKey() method""); (""containsKey() method"", ""belongs to"", ""Java Map"")"
You can iterate all the keys of a Java Map via its keySet() method.,"(""Java Map"", ""has method"", ""keySet()"")"
"As you can see, the key Iterator returns every key stored in a Java Map, one by one (one for each call to next()).","(""Iterator"", ""returns"", ""key""); (""Java Map"", ""stores"", ""key""); (""Iterator"", ""calls"", ""next()"")"
"Once you have the key, you can obtain the element stored for that key using the Map get() method.","(""Map"", ""has method"", ""get()"")"
"In the example above, the Iterator next() method returns an Object - and so does the get() method.","(""Iterator"", ""hasMethod"", ""next()""); (""Iterator"", ""hasMethod"", ""get()""); (""next()"", ""returns"", ""Object""); (""get()"", ""returns"", ""Object"")"
Notice how a generic type is now also specified for the Iterator obtained from map.keySet().iterator().,"(""map"", ""keySet"", ""keySet()""); (""keySet"", ""iterator"", ""Iterator""); (""map"", ""keySet().iterator"", ""Iterator"")"
You obtain a Collection of the values stored in a Map via the values() method.,"(""Collection"", ""obtained via"", ""values() method""); (""Map"", ""has method"", ""values() method""); (""values() method"", ""returns"", ""Collection"")"
Notice how the key and value can be obtained from each Map.Entry instance.,"(""Map.Entry"", ""instance of"", ""Map""); (""Map.Entry"", ""has key"", ""key""); (""Map.Entry"", ""has value"", ""value"")"
You can remove all entries in a Java Map using the clear() method.,"(""Java Map"", ""has method"", ""clear()""); (""clear()"", ""belongs to"", ""Java Map""); (""Java Map"", ""uses method"", ""clear()"")"
It is possible to replace an element in a Java Map using the replace() method.,"(""Java Map"", ""has method"", ""replace()""); (""replace()"", ""is method of"", ""Java Map"")"
The replace() method will only insert the new value if there is already an existing value mapped to the key.,"(""replace()"", ""is method of"", ""Map""); (""replace()"", ""inserts"", ""value""); (""key"", ""has"", ""value""); (""Map"", ""has"", ""key"")"
"This is different from how put() works, which always insert the value no matter what.","(""put()"", ""works"", ""value""); (""put()"", ""insert"", ""value"")"
Here is an example of replacing one value with another using the Java Map replace() method:,"(""Map"", ""hasMethod"", ""replace()""); (""Java"", ""uses"", ""Map""); (""replace()"", ""isMethodOf"", ""Map"")"
You can read the number of entries in a Java Map using the size() method.,"(""Map"", ""uses"", ""size()""); (""Java Map"", ""has method"", ""size()""); (""Map"", ""has method"", ""size()""); (""Java"", ""contains"", ""Map""); (""Map"", ""has attribute"", ""size()""); (""Java Map"", ""contains method"", ""size()"")"
The number of entries in a Java Map is also referred to as the Map size - hence the method name size() .,"(""Java Map"", ""has method"", ""size()""); (""Map"", ""has size"", ""size()""); (""Map"", ""referred to as"", ""size""); (""Java Map"", ""uses method"", ""size()"")"
Here is an example of reading the number of entries in a Map using the size() method:,"(""Map"", ""has method"", ""size()"")"
This method is called isEmpty() and it returns either true or false.,"(""isEmpty()"", ""is called by"", ""method""); (""isEmpty()"", ""returns"", ""true""); (""isEmpty()"", ""returns"", ""false"")"
The isEmpty() method will return false if the Map instance contains 1 or more entries.,"(""Map"", ""contains"", ""entries""); (""Map"", ""has method"", ""isEmpty()""); (""isEmpty()"", ""returns"", ""false"")"
The Map compute() method takes a key object and a lambda expression as parameters.,"(""Map"", ""hasMethod"", ""compute()""); (""compute()"", ""takesParameter"", ""key""); (""compute()"", ""takesParameter"", ""lambda expression"")"
Here is an example of calling the Java Map compute() method:,"(""Java Map"", ""has method"", ""compute()""); (""compute()"", ""is part of"", ""Java Map""); (""Java"", ""contains class"", ""Map""); (""Map"", ""has method"", ""compute()"")"
"The compute() method will call the lambda expression internally, passing the key object and whatever value is stored in the Map for that key object, as parameters to the lambda expression.","(""compute()"", ""calls"", ""lambda expression""); (""lambda expression"", ""has parameters"", ""key object""); (""lambda expression"", ""has parameters"", ""value""); (""Map"", ""stores"", ""key object""); (""Map"", ""stores"", ""value"")"
"In the example above you can see that the lambda expression checks if the value mapped to the given key is null or not, before calling toString().toUpperCase() on it.","(""lambda expression"", ""checks"", ""value""); (""value"", ""is mapped to"", ""key""); (""value"", ""calls"", ""toString()""); (""toString()"", ""calls"", ""toUpperCase()"")"
"The Map computeIfAbsent() method works similarly to the compute() method, but the lambda expression is only called if no entry exists already for the given key.","(""Map"", ""hasMethod"", ""computeIfAbsent()""); (""computeIfAbsent()"", ""similarTo"", ""compute()""); (""computeIfAbsent()"", ""uses"", ""lambda expression""); (""Map"", ""hasMethod"", ""compute()""); (""compute()"", ""uses"", ""lambda expression""); (""Map"", ""computeIfAbsent()"", ""key""); (""Map"", ""compute()"", ""key"")"
"However, the lambda expression could have calculated the value in any way it needed to - e.g.",
"The Map merge() method takes a key, a value, and a lambda expression implementing the BiFunction interface as parameters.","(""Map"", ""hasMethod"", ""merge()""); (""merge()"", ""takesParameter"", ""key""); (""merge()"", ""takesParameter"", ""value""); (""merge()"", ""takesParameter"", ""lambda expression""); (""lambda expression"", ""implements"", ""BiFunction"")"
"If the Map does not have an entry for the key, or if the value for the key is null, the value passed as parameter to the merge() method is inserted for the given key.","(""Map"", ""has method"", ""merge()""); (""merge()"", ""is called with"", ""key""); (""merge()"", ""is called with"", ""value""); (""Map"", ""stores"", ""entry""); (""entry"", ""has"", ""key""); (""entry"", ""has"", ""value"")"
"The Java NavigableMap interface, java.util.NavigableMap, is a sub-interface of the Java SortedMap interface.","(""Java NavigableMap"", ""is a sub-interface of"", ""Java SortedMap""); (""java.util.NavigableMap"", ""is a sub-interface of"", ""Java SortedMap""); (""Java NavigableMap"", ""is a sub-interface of"", ""java.util.SortedMap""); (""java.util.NavigableMap"", ""is a sub-interface of"", ""java.util.SortedMap"")"
The java.util package only has one implementation of the NavigableMap interface: The java.util.TreeMap class.,"(""java.util"", ""has"", ""NavigableMap""); (""java.util"", ""contains"", ""TreeMap""); (""TreeMap"", ""implements"", ""NavigableMap"")"
"There is a Java NavigableMap implementation in the java.util.concurrent package too, but that is outside the scope of this tutorial.","(""Java"", ""has package"", ""java.util.concurrent""); (""Java"", ""has implementation"", ""NavigableMap""); (""NavigableMap"", ""is in package"", ""java.util.concurrent"")"
To create a Java NavigableMap you must create an instance of one of the classes that implements the NavigableMap interface.,"(""NavigableMap"", ""implements"", ""interface""); (""interface"", ""implemented by"", ""classes""); (""Java NavigableMap"", ""created by"", ""instance""); (""instance"", ""of"", ""classes""); (""NavigableMap"", ""instance of"", ""classes"")"
Here is an example of creating an instance of the Java TreeMap class which implements the NavigableMap interface:,"(""TreeMap"", ""implements"", ""NavigableMap""); (""TreeMap"", ""is a"", ""Java class""); (""NavigableMap"", ""is an"", ""interface"")"
The first interesting navigation method of NavigableMap is the descendingKeySet() method.,"(""NavigableMap"", ""has method"", ""descendingKeySet()"")"
The descendingKeySet() method returns a NavigableSet in which the order of the elements is reversed compared to the original key set.,"(""NavigableSet"", ""returned by"", ""descendingKeySet()""); (""descendingKeySet()"", ""returns"", ""NavigableSet""); (""NavigableSet"", ""has"", ""original key set"")"
The descendingMap() method returns a NavigableMap which is a view of the original Map.,"(""NavigableMap"", ""is a"", ""view of""); (""descendingMap()"", ""returns"", ""NavigableMap""); (""NavigableMap"", ""is a"", ""Map"")"
"The headMap() method returns a view of the original NavigableMap which only contains elements that are ""less than"" the given element.","(""NavigableMap"", ""has method"", ""headMap()""); (""headMap()"", ""returns"", ""view""); (""NavigableMap"", ""contains"", ""elements""); (""elements"", ""are less than"", ""given element""); (""NavigableMap"", ""is the original of"", ""view"")"
"The tailMap() method is similar to the headMap() method, except that tailMap() returns all elements that are equal to or higher than the given parameter element.","(""tailMap"", ""similar to"", ""headMap""); (""tailMap"", ""returns"", ""elements""); (""headMap"", ""compared to"", ""tailMap""); (""tailMap"", ""returns elements that are"", ""equal to or higher than parameter element"")"
"The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys ""c"", ""d"" and ""e"", as these keys are considered equal to or larger than the parameter value ""c"" passed to the tailMap() method.","(""SortedMap"", ""contains"", ""key + value pairs""); (""NavigableMap"", ""has method"", ""tailMap()""); (""tailMap()"", ""is called with"", ""parameter value""); (""NavigableMap"", ""has keys"", ""c""); (""NavigableMap"", ""has keys"", ""d""); (""NavigableMap"", ""has keys"", ""e""); (""tailMap()"", ""returns"", ""SortedMap""); (""parameter value"", ""is compared to"", ""keys""); (""NavigableMap"", ""is filtered by"", ""tailMap()"")"
The subMap() allows you to pass two parameters demarcating the boundaries of the view map to return.,"(""subMap()"", ""allows"", ""view map""); (""subMap()"", ""returns"", ""view map""); (""subMap()"", ""has parameters"", ""boundaries"")"
The ceilingKey() method returns the least (smallest) key in this map that is greater than or equal to the element passed as parameter to the ceilingKey() method.,"(""ceilingKey() method"", ""returns"", ""key""); (""map"", ""contains"", ""key""); (""ceilingKey() method"", ""is part of"", ""map"")"
"Thus, floorKey() returns the greatest key which is less than or equal to the parameter value passed to ceilingKey().","(""floorKey()"", ""returns"", ""ceilingKey()""); (""ceilingKey()"", ""parameter of"", ""floorKey()""); (""floorKey()"", ""compared to"", ""ceilingKey()"")"
The higherKey() method returns the least (smallest) element in this map that is greater than (not equal too) the element passed as parameter to the higherKey() method.,"(""Map"", ""hasMethod"", ""higherKey()""); (""higherKey()"", ""returns"", ""Element""); (""higherKey()"", ""takesParameter"", ""Element""); (""Map"", ""contains"", ""Element"")"
"Thus, lowerKey() returns the greatest key which is lower than the parameter value passed to the lowerKey() method.","(""lowerKey()"", ""returns"", ""key""); (""lowerKey()"", ""is called with"", ""parameter value""); (""parameter value"", ""is passed to"", ""lowerKey()"")"
"In the example above, the returned lowerKey will be ""1"", as this is the highest key which is lower than the parameter value ""2"" passed to the lowerKey() method.","(""lowerKey"", ""is returned by"", ""lowerKey()""); (""lowerKey()"", ""has parameter"", ""value""); (""value"", ""is compared to"", ""key""); (""lowerKey"", ""is highest key lower than"", ""parameter value""); (""parameter value"", ""is passed to"", ""lowerKey()"")"
"methods, except they return a Map.Entry instead of the key object itself.","(""Map"", ""hasMethod"", ""Entry""); (""methods"", ""return"", ""Map.Entry""); (""Map.Entry"", ""isReturnedBy"", ""methods"")"
"Each of the methods ceilingEntry(), floorEntry(), higherEntry() and lowerEntry() will be covered in the following sections.","(""ceilingEntry()"", ""ismethodof"", ""unnamed class""); (""floorEntry()"", ""ismethodof"", ""unnamed class""); (""higherEntry()"", ""ismethodof"", ""unnamed class""); (""lowerEntry()"", ""ismethodof"", ""unnamed class"")"
The ceilingEntry() method returns the key + value stored for the least (smallest) key in the NavigableMap which is higher than or equal to the parameter value passed to the ceilingEntry() method.,"(""NavigableMap"", ""has method"", ""ceilingEntry()""); (""ceilingEntry()"", ""returns"", ""key + value""); (""NavigableMap"", ""stores"", ""key + value""); (""ceilingEntry()"", ""is higher than or equal to"", ""parameter value""); (""NavigableMap"", ""contains"", ""parameter value""); (""ceilingEntry()"", ""belongs to"", ""NavigableMap"")"
"The ceilingEntry() is thus similar to the ceilingKey() method, except the ceilingKey() method only returns the key, and ceilingKey() returns a Map.Entry object containing both the key and value.","(""ceilingEntry()"", ""is similar to"", ""ceilingKey()""); (""ceilingKey()"", ""returns"", ""key""); (""ceilingEntry()"", ""returns"", ""Map.Entry""); (""Map.Entry"", ""contains"", ""key""); (""Map.Entry"", ""contains"", ""value"")"
"In the example above the returned ceilingEntry will contain the key ""c"" and the value ""3"", since the key ""c"" is the smallest key that is greater than or equal to the parameter value ""c"" passed to ceilingEntry() .","(""ceilingEntry"", ""contains"", ""key""); (""ceilingEntry"", ""contains"", ""value""); (""ceilingEntry"", ""passed to"", ""ceilingEntry()""); (""parameter value"", ""passed to"", ""ceilingEntry()""); (""key"", ""is"", ""smallest key""); (""key"", ""greater than or equal to"", ""parameter value""); (""ceilingEntry()"", ""returns"", ""ceilingEntry"")"
The floorEntry() method returns the key + value for the greatest key which is equal to or lower than the parameter value passed to the floorEntry() method.,"(""floorEntry()"", ""returns"", ""key + value""); (""floorEntry()"", ""is part of"", ""unknown class""); (""floorEntry()"", ""has parameter"", ""value"")"
"The floorEntry returned in the example above will contain the key + value pair ""c"" + ""3"" , because key ""c"" is the greatest key which is lower than or equal to the parameter value ""c"" passed to the floorEntry() method.",
The higherEntry() method returns the key + value stored for the smallest key that is higher than the parameter value passed to the higherEntry() method.,"(""higherEntry()"", ""returns"", ""key + value""); (""higherEntry()"", ""is called with"", ""parameter value""); (""higherEntry()"", ""is higher than"", ""parameter value""); (""parameter value"", ""is passed to"", ""higherEntry()"")"
"The higherEntry returned in the example above will contain the key + value pair ""d"" + ""4"" because the key ""d"" is the lowest key which is higher than the parameter value ""c"" passed to the higherEntry() method.","(""higherEntry"", ""returned in"", ""example""); (""higherEntry"", ""contains"", ""key + value pair""); (""higherEntry"", ""contains"", ""d + 4""); (""key"", ""is"", ""lowest key""); (""key"", ""is higher than"", ""parameter value""); (""parameter value"", ""passed to"", ""higherEntry() method""); (""key"", ""is"", ""d""); (""parameter value"", ""is"", ""c""); (""higherEntry() method"", ""is called with"", ""parameter value"")"
The lowerEntry() method in the NavigableMap interface returns the key + value pair for the highest key which is lower than the parameter value passed to the lowerEntry() method.,"(""NavigableMap"", ""hasMethod"", ""lowerEntry()""); (""lowerEntry()"", ""returns"", ""key + value pair""); (""NavigableMap"", ""hasMethod"", ""lowerEntry()""); (""lowerEntry()"", ""takesParameter"", ""value"")"
"The lowerEntry returned in this example will be the key + value pair ""a"" + ""1"" since ""a"" is the highest key which is lower than the parameter value ""b"" passed to the lowerEntry() method.","(""lowerEntry"", ""returned in"", ""example""); (""lowerEntry"", ""has key"", ""a""); (""lowerEntry"", ""has value"", ""1""); (""lowerEntry"", ""called by"", ""example""); (""lowerEntry"", ""compares to"", ""b""); (""lowerEntry"", ""uses method"", ""lowerEntry()"")"
"The pollFirstEntry() method returns and removes the ""first"" entry (key + value) in the NavigableMap or null if the map is empty.","(""NavigableMap"", ""hasMethod"", ""pollFirstEntry()""); (""pollFirstEntry()"", ""returns"", ""entry""); (""NavigableMap"", ""contains"", ""key""); (""NavigableMap"", ""contains"", ""value""); (""NavigableMap"", ""hasMethod"", ""pollFirstEntry()""); (""pollFirstEntry()"", ""removes"", ""entry""); (""NavigableMap"", ""mayBe"", ""empty"")"
"The pollLastEntry() returns and removes the ""last"" element in the map or null if the map is empty.","(""map"", ""has method"", ""pollLastEntry()""); (""pollLastEntry()"", ""returns"", ""element""); (""pollLastEntry()"", ""removes"", ""element""); (""map"", ""contains"", ""element""); (""map"", ""has state"", ""empty""); (""pollLastEntry()"", ""returns"", ""null"")"
"The Java NavigableSet interface, java.util.NavigableSet, is a subtype of the Java SortedSet interface.","(""java.util.NavigableSet"", ""is a subtype of"", ""java.util.SortedSet"")"
In Java 6 to 13 there is only one implementation of the NavigableSet interface in the java.util package: The java.util.TreeSet class.,"(""Java"", ""has package"", ""java.util""); (""java.util"", ""contains interface"", ""NavigableSet""); (""java.util"", ""contains class"", ""TreeSet""); (""NavigableSet"", ""implemented by"", ""TreeSet""); (""TreeSet"", ""implements"", ""NavigableSet"")"
There is an implementation in the java.util.concurrent package called ConcurrentSkipListSet but that is outside the scope of this trail.,"(""ConcurrentSkipListSet"", ""is_in"", ""java.util.concurrent"")"
To create a Java NavigableSet you must create an instance of one of the classes implementing the NavigableSet interface.,"(""NavigableSet"", ""is implemented by"", ""classes""); (""Java"", ""has"", ""NavigableSet""); (""NavigableSet"", ""is created by"", ""instance""); (""instance"", ""is of"", ""classes""); (""classes"", ""implement"", ""NavigableSet"")"
Here is an example of creating an instance of the class TreeSet which implements the NavigableSet interface:,"(""TreeSet"", ""implements"", ""NavigableSet"")"
The descendingSet() method returns a NavigableSet in which the order of the elements is reversed compared to this one.,"(""NavigableSet"", ""returned by"", ""descendingSet()""); (""descendingSet()"", ""returns"", ""NavigableSet"")"
"The descendingIterator() method allows you to iterate the elements of the NavigableSet (which is also a SortedSet) in reverse order, without changing the order of the elements internally.","(""NavigableSet"", ""has_method"", ""descendingIterator()""); (""SortedSet"", ""is_subset_of"", ""NavigableSet""); (""NavigableSet"", ""implements"", ""SortedSet""); (""descendingIterator()"", ""belongs_to"", ""NavigableSet"")"
"The headSet() method returns a view of the original NavigableSet which only contains elements that are ""less than"" the given element.","(""NavigableSet"", ""hasMethod"", ""headSet()""); (""headSet()"", ""returns"", ""view""); (""view"", ""contains"", ""elements""); (""NavigableSet"", ""contains"", ""elements"")"
"The tailSet() method works the same way as the headSet() method, except it returns all elements that are equal to or higher than the given parameter element.","(""tailSet()"", ""works the same way as"", ""headSet()""); (""tailSet()"", ""returns"", ""elements""); (""elements"", ""are equal to or higher than"", ""parameter element""); (""headSet()"", ""returns"", ""elements""); (""tailSet()"", ""is compared to"", ""headSet()"")"
The subSet() method allows you to pass two parameters demarcating the boundaries of the view set to return.,"(""subSet"", ""allows"", ""parameters""); (""subSet"", ""returns"", ""view set""); (""parameters"", ""demarcate"", ""boundaries""); (""subSet"", ""has"", ""parameters"")"
The ceiling() method returns the least (smallest) element in this set that is greater than or equal to the element passed as parameter to the ceiling() method.,"(""ceiling() method"", ""returns"", ""element""); (""ceiling() method"", ""is part of"", ""set""); (""element"", ""is passed to"", ""ceiling() method""); (""set"", ""contains"", ""element"")"
"The floor() method does the opposite of the ceiling() method, meaning it returns the greatest element that is less than or equal to the given parameter value.","(""floor() method"", ""does the opposite of"", ""ceiling() method""); (""floor() method"", ""returns"", ""greatest element""); (""ceiling() method"", ""returns"", ""greatest element""); (""floor() method"", ""compared to"", ""given parameter value""); (""ceiling() method"", ""compared to"", ""given parameter value"")"
The higher() method returns the least (smallest) element in this set that is greater than (not equal too) the element passed as parameter to the higher() method.,"(""set"", ""has method"", ""higher()""); (""higher()"", ""returns"", ""element""); (""higher()"", ""takes parameter"", ""element""); (""set"", ""contains"", ""element"")"
"The lower() method does the opposite of the higher() method, meaning it returns the highest element that is less than (not equal to) the given parameter.","(""lower()"", ""is opposite of"", ""higher()""); (""lower()"", ""returns"", ""highest element""); (""higher()"", ""is opposite of"", ""lower()"")"
"The pollFirst() method returns and removes the ""first"" element in the NavigableSet or null if the set is empty.","(""NavigableSet"", ""hasMethod"", ""pollFirst()""); (""pollFirst()"", ""returns"", ""element""); (""NavigableSet"", ""contains"", ""element""); (""NavigableSet"", ""hasState"", ""empty""); (""pollFirst()"", ""throws"", ""null"")"
"The pollLast() method returns and removes the ""last"" element in the NavigableSet.","(""NavigableSet"", ""has method"", ""pollLast()""); (""pollLast()"", ""returns"", ""last element""); (""NavigableSet"", ""contains"", ""last element"")"
"The Java Properties class, java.util.Properties, is like a Java Map of Java String key and value pairs.","(""Java Properties class"", ""is like"", ""Java Map""); (""Java Properties class"", ""has key type"", ""Java String""); (""Java Properties class"", ""has value type"", ""Java String""); (""Java Properties class"", ""belongs to"", ""java.util""); (""Java Map"", ""has key type"", ""Java String""); (""Java Map"", ""has value type"", ""Java String"")"
"The Java Properties class can write the key, value pairs to a properties file on disk, and read the properties back in again.","(""Java Properties"", ""can write to"", ""properties file""); (""Java Properties"", ""can read from"", ""properties file""); (""Java Properties"", ""uses"", ""disk"")"
To use the Java Properties class you must first create a Properties instance.,"(""Java"", ""uses"", ""Properties class""); (""Properties class"", ""instance created by"", ""user""); (""Properties"", ""instance of"", ""Properties class"")"
To set properties in a Java Properties instance you use the setProperty() method.,"(""Java Properties"", ""uses"", ""setProperty() method""); (""Java Properties"", ""has method"", ""setProperty() method""); (""setProperty() method"", ""belongs to"", ""Java Properties"")"
"To get properties from a Java Properties object you use the getProperty() method, passing the key of the property to get as parameter.","(""Java Properties"", ""uses"", ""getProperty()""); (""getProperty()"", ""belongs to"", ""Java Properties""); (""Java Properties"", ""has method"", ""getProperty()"")"
"You can remove a property from a Java Properties instance using its remove() method, passing as parameter to remove() the key for the property to remove.","(""Java Properties"", ""has method"", ""remove()""); (""remove()"", ""takes parameter"", ""key""); (""Java Properties"", ""uses method"", ""remove()""); (""remove()"", ""is used to remove"", ""property"")"
You store the contents of a Properties object via its store() method.,"(""Properties"", ""has method"", ""store()"")"
Notice the first line of the properties file is actually the comment that was passed as second parameter to the store() method call in the code example in the previous section about storing properties to a property file.,
You can also load properties stored in a property file back into a Java Properties object via its load() method.,"(""Properties"", ""has method"", ""load()""); (""Java Properties"", ""has method"", ""load()""); (""Properties"", ""stored in"", ""property file""); (""Java Properties"", ""loaded from"", ""property file""); (""load()"", ""belongs to"", ""Properties""); (""load()"", ""belongs to"", ""Java Properties"")"
By default the load() method will assume that the loaded file is encoded using ISO-8859-1 (Latin-1).,"(""load()"", ""uses"", ""ISO-8859-1""); (""load()"", ""assumes"", ""Latin-1"")"
The Java Properties class can also write the key-value pairs stored in it to an XML file via its storeToXML().,"(""Java Properties"", ""has method"", ""storeToXML()""); (""storeToXML()"", ""belongs to"", ""Java Properties""); (""Java Properties"", ""can write to"", ""XML file"")"
"Notice how the comment passed to the storeToXML() method is enclosed in a comment XML element, and not in an XML comment (<!-- -->) .","(""storeToXML"", ""enclosed in"", ""comment XML element""); (""comment XML element"", ""contains"", ""comment""); (""XML comment"", ""contrasted with"", ""comment XML element""); (""storeToXML"", ""passes"", ""comment"")"
You can load properties from an XML property file into a Java Properties object via its loadFromXML() method.,"(""Java Properties"", ""has method"", ""loadFromXML()""); (""loadFromXML()"", ""belongs to"", ""Java Properties""); (""Java Properties"", ""loads from"", ""XML property file"")"
By default the loadFromXML() method will assume that the XML file is stored using the UTF-8 encoding.,"(""loadFromXML()"", ""is_method_of"", ""unknown_class""); (""loadFromXML()"", ""uses"", ""UTF-8""); (""UTF-8"", ""is_encoding_of"", ""XML_file""); (""loadFromXML()"", ""loads"", ""XML_file"")"
It is possible to load properties into a Java Properties from a file that is available on the classpath.,"(""Java Properties"", ""load properties from"", ""file""); (""Java Properties"", ""loaded from"", ""classpath""); (""file"", ""available on"", ""classpath"")"
"That file could thus be located inside the same JAR file as the application loading the properties, or inside another JAR file or directory available on the Java classpath when your Java application is executed.","(""Java application"", ""loaded by"", ""Java classpath""); (""Java classpath"", ""contains"", ""JAR file""); (""Java application"", ""executes from"", ""JAR file""); (""JAR file"", ""contains"", ""properties file""); (""Java application"", ""loads"", ""properties file"")"
To load properties from a file available on the classpath you need to obtain a Class instance first.,"(""Class"", ""obtain"", ""Class instance""); (""Class instance"", ""load properties from"", ""file""); (""Class"", ""available on"", ""classpath""); (""File"", ""available on"", ""classpath"")"
In the example below I obtain it from the class that contains the main() method of my application:,"(""main class"", ""contains"", ""main() method""); (""application"", ""has"", ""main class""); (""main class"", ""has"", ""main() method"")"
Once I have the Class instance I can call its getResourceAsStream() method which returns a Java InputStream referencing the file.,"(""Class"", ""hasMethod"", ""getResourceAsStream()""); (""getResourceAsStream()"", ""returns"", ""InputStream""); (""Class"", ""uses"", ""InputStream""); (""InputStream"", ""references"", ""file"")"
Here is an example of obtaining a reference to a file from the classpath:,"(""Classpath"", ""contains"", ""File""); (""File"", ""obtained from"", ""Classpath""); (""Classpath"", ""provides reference to"", ""File"")"
The file would have to be located in the root directory of the classpath.,
"If you put it into a subdirectory, the path passed to getResourceAsStream() should reflect that.","(""getResourceAsStream"", ""should reflect"", ""path"")"
"Using the InputStream you can load the file into a Java Properties instance, using either the load() or loadFromXML() methods explained earlier in this Java Properties tutorial.","(""InputStream"", ""uses"", ""Java Properties""); (""Java Properties"", ""has method"", ""load()""); (""Java Properties"", ""has method"", ""loadFromXML()"")"
"The ResourceBundle class is covered as part of that tutorial, in the Java ResourceBundle tutorial.","(""ResourceBundle"", ""is covered in"", ""Java ResourceBundle tutorial"")"
The Java Properties class has the ability to provide default property values for properties that do not have any key registered in the Properties instance.,"(""Java Properties"", ""has ability to provide"", ""default property values""); (""Java Properties"", ""has"", ""key""); (""Properties instance"", ""has"", ""key""); (""Java Properties"", ""provides"", ""default property values""); (""Properties"", ""has"", ""instance"")"
The getProperty() method comes in a version that takes an extra parameter which is the default value to return in case the Properties instance does not contain a value for the given key.,"(""Properties"", ""contains"", ""key""); (""Properties"", ""has method"", ""getProperty()""); (""getProperty()"", ""takes parameter"", ""default value""); (""getProperty()"", ""returns"", ""default value"")"
Here is an example of calling getProperty() with a default value:,"(""getProperty()"", ""called with"", ""default value"")"
"If the Properties instance does not contain a property for the key preferredLanguage, then the value Danish will be returned - instead of returning null which would have been returned if no default value had been passed to getProperty().","(""Properties"", ""contains"", ""property""); (""Properties"", ""does not contain"", ""property""); (""Properties"", ""passed to"", ""getProperty()""); (""getProperty()"", ""returns"", ""null""); (""getProperty()"", ""returns"", ""Danish""); (""Properties"", ""has method"", ""getProperty()"")"
The Java Properties class can be instantiated with another Properties instance containing default values to use when the newly created Properties instance does not contain a value for a requested property key.,"(""Java"", ""has_class"", ""Properties""); (""Properties"", ""instantiated_with"", ""Properties""); (""Properties"", ""contains"", ""default_values""); (""Properties"", ""uses"", ""default_values""); (""Properties"", ""does_not_contain"", ""value""); (""Properties"", ""requested_with"", ""property_key"")"
The System class also has a getProperty() and setProperty() method which are shortcuts to the Properties getProperty() and setProperty() methods of the System Properties instance.,"(""System"", ""has method"", ""getProperty()""); (""System"", ""has method"", ""setProperty()""); (""Properties"", ""has method"", ""getProperty()""); (""Properties"", ""has method"", ""setProperty()""); (""System"", ""has instance"", ""Properties""); (""Properties"", ""has method"", ""getProperty()""); (""Properties"", ""has method"", ""setProperty()""); (""System.getProperty"", ""is shortcut to"", ""Properties.getProperty""); (""System.setProperty"", ""is shortcut to"", ""Properties.setProperty""); (""System"", ""hasMethod"", ""getProperty()""); (""System"", ""hasMethod"", ""setProperty()""); (""System"", ""hasInstance"", ""System Properties""); (""Properties"", ""hasMethod"", ""getProperty()""); (""Properties"", ""hasMethod"", ""setProperty()""); (""System.getProperty"", ""isShortcutFor"", ""Properties.getProperty()""); (""System.setProperty"", ""isShortcutFor"", ""Properties.setProperty()"")"
"The Java Properties class is a subclass of the Java Hashtable class, and as I will show you - this is actually a design mistake!","(""Java Properties"", ""is a subclass of"", ""Java Hashtable"")"
"It is a great example of when the classic ""Is a / Has a"" OOP rule about when to use inheritance vs. composition fails.",
"Being a subclass of Hashtable, you can actually use the get() and put() method of the Hashtable class, which allow the use of non-string keys and values.","(""Hashtable"", ""has method"", ""get()""); (""Hashtable"", ""has method"", ""put()""); (""Hashtable"", ""is superclass of"", ""subclass"")"
"This defeats the purpose of the Properties class, which is to function as a string,string map.","(""Properties"", ""is a"", ""string map""); (""Properties"", ""has function"", ""string map""); (""Properties"", ""defeats purpose of"", ""string map"")"
Notice how it is possible to call put() with non-string values.,
Just to make it clear: You should NOT use the put() and get() method of the Properties class!,"(""Properties"", ""hasMethod"", ""put()""); (""Properties"", ""hasMethod"", ""get()"")"
"If instead the value passed to put() had been two strings, then it would have worked as expected.","(""put()"", ""called with"", ""two strings""); (""put()"", ""passed value"", ""two strings""); (""put()"", ""had value"", ""strings"")"
Notice how the second value passed to put() is now also a string.,
"Even if you can get get() and put() to work, I would recommend that you do not use these methods.","(""get()"", ""is_method_of"", ""unknown""); (""put()"", ""is_method_of"", ""unknown"")"
"Using that formulation, Properties would not have been made a subclass of Hashtable, because Properties should not be usable as a Hashtable .","(""Properties"", ""subclass of"", ""Hashtable""); (""Properties"", ""usable as"", ""Hashtable""); (""Hashtable"", ""has subclass"", ""Properties"")"
"Instead, the Properties class should have just had an internal Hashtable to keep the property key,value pairs in.","(""Properties"", ""has"", ""Hashtable"")"
"The Java Queue interface, java.util.Queue represents a data structure designed to have elements inserted at the end of the queue, and elements removed from the beginning of the queue.","(""Java"", ""uses"", ""java.util.Queue""); (""java.util.Queue"", ""represents"", ""data structure"")"
"There are also Queue implementations in the java.util.concurrent package, but I will leave the concurrency utilities out of this tutorial.","(""Queue"", ""is implemented in"", ""java.util.concurrent""); (""java.util.concurrent"", ""contains"", ""Queue"")"
"The add() and offer() methods differ in how the behave if the Queue is full, so no more elements can be added.","(""add()"", ""differs from"", ""offer()""); (""add()"", ""is method of"", ""Queue""); (""offer()"", ""is method of"", ""Queue""); (""Queue"", ""has method"", ""add()""); (""Queue"", ""has method"", ""offer()"")"
"The add() method throws an exception in that case, whereas the offer() method just returns false.","(""add()"", ""throws"", ""exception""); (""offer()"", ""returns"", ""false"")"
Here are two examples of adding elements to a Java Queue via its add() and offer() methods:,"(""Queue"", ""has method"", ""add()""); (""Queue"", ""has method"", ""offer()"")"
To take an element from a Java Queue you can call either its poll() or remove() method.,"(""Queue"", ""hasMethod"", ""poll()""); (""Queue"", ""hasMethod"", ""remove()"")"
The poll() and remove() both removes the first element in the Queue.,"(""Queue"", ""hasMethod"", ""poll()""); (""Queue"", ""hasMethod"", ""remove()""); (""poll()"", ""removesElementFrom"", ""Queue""); (""remove()"", ""removesElementFrom"", ""Queue"")"
The remove() method throws an exception if the Queue is empty.,"(""Queue"", ""has method"", ""remove()""); (""remove()"", ""throws"", ""exception""); (""Queue"", ""can be"", ""empty"")"
Here are two examples of taking an element from a Java Queue using its poll() and remove() methods:,"(""Queue"", ""has method"", ""poll()""); (""Queue"", ""has method"", ""remove()"")"
"The call to poll() will remove the first element of the Queue - which is the first Java String instance added - ""element 1"".","(""Queue"", ""hasMethod"", ""poll()""); (""Queue"", ""contains"", ""String""); (""String"", ""isAddedTo"", ""Queue""); (""Queue"", ""removes"", ""String"")"
"The call to rmove() will remove the second element of the Queue - which after the first poll() call is now the String instance added - ""element 2"".","(""Queue"", ""hasMethod"", ""poll()""); (""Queue"", ""hasMethod"", ""remove()""); (""String"", ""isEqualTo"", ""element 2""); (""Queue"", ""contains"", ""String"")"
"If the Queue is empty, the element() method throws a NoSuchElementException.","(""Queue"", ""has method"", ""element()""); (""element()"", ""throws"", ""NoSuchElementException"")"
Here is an example of peeking at the first element of a Java Queue using the element() method:,"(""Queue"", ""uses"", ""element()""); (""Queue"", ""has method"", ""element()""); (""element()"", ""is method of"", ""Queue"")"
The peek() works like the element() method except it does not throw an exception if the Queue is empty.,"(""peek()"", ""works like"", ""element()""); (""peek()"", ""does not throw exception"", ""Queue""); (""element()"", ""throws exception"", ""Queue"")"
Here is an example of peeking at the first element of a Queue using the peek() method:,"(""Queue"", ""uses"", ""peek()"")"
"To remove elements from a Java Queue, you call the remove() method.","(""Java Queue"", ""call"", ""remove() method""); (""remove() method"", ""called by"", ""Java Queue""); (""Java Queue"", ""has method"", ""remove()"")"
You can remove all elements from a Java Queue using its clear() method.,"(""Java Queue"", ""has method"", ""clear()"")"
Here is an example of removing all elements from a Java Queue via its clear() method:,"(""Queue"", ""has method"", ""clear()"")"
You can read the number of elements stored in a Java Queue via its size() method.,"(""Java Queue"", ""has method"", ""size()"")"
Here is an example of obtaining the size of a Java Queue via its size() method:,"(""Queue"", ""has method"", ""size()"")"
After running this code the size variable should contain the value 3 - because the Queue contains 3 elements at the time size() is called.,"(""Queue"", ""contains"", ""elements""); (""Queue"", ""has method"", ""size()""); (""size()"", ""returns"", ""value""); (""Queue"", ""has variable"", ""size""); (""size()"", ""is called on"", ""Queue""); (""Queue"", ""has size"", ""3"")"
You can check if a Java Queue contains a certain element via its contains() method.,"(""Queue"", ""contains"", ""element""); (""Queue"", ""has method"", ""contains()"")"
"The contains() method will return true if the Queue contains the given element, and false if not.","(""Queue"", ""contains"", ""element"")"
"The contains() method is actually inherited from the Collection interface, but in practice that doesn't matter.","(""Collection"", ""hasMethod"", ""contains()""); (""Collection"", ""inheritsTo"", ""contains()""); (""contains()"", ""isInheritedFrom"", ""Collection"")"
"The Java Set interface, java.util.Set, represents a collection of objects where each object in the Java Set is unique.","(""Java Set"", ""represents"", ""collection of objects""); (""java.util.Set"", ""is a"", ""Java Set""); (""Java Set"", ""contains"", ""objects""); (""objects"", ""are"", ""unique"")"
"If the Set is not typed, using Java Generics, then you can even mix objects of different types (classes) in the same Set.","(""Set"", ""isNotTypedWith"", ""Java Generics""); (""Java Generics"", ""allows"", ""Set""); (""Set"", ""canContain"", ""objects""); (""objects"", ""areOf"", ""different types""); (""different types"", ""areDefinedBy"", ""classes"")"
This example creates a HashSet which is one of the classes in the Java APIs that implement the Set interface.,"(""HashSet"", ""implements"", ""Set""); (""HashSet"", ""is part of"", ""Java APIs""); (""Set"", ""is interface of"", ""Java APIs"")"
"In other words, the order in which the elements whould be sorted if you used a Collections.sort() on a List or array containing these elements.","(""Collections"", ""method"", ""sort()""); (""List"", ""contains"", ""elements""); (""array"", ""contains"", ""elements""); (""Collections.sort()"", ""used on"", ""List""); (""Collections.sort()"", ""used on"", ""array"")"
"There are also Set implementations in the java.util.concurrent package, but I will leave the concurrency utilities out of this tutorial.","(""Set"", ""is_in"", ""java.util.concurrent""); (""java.util.concurrent"", ""contains"", ""Set"")"
The Java Set static factory methods are called of() and take either zero or more parameters.,"(""Java Set"", ""has static factory methods"", ""of()""); (""of()"", ""takes"", ""zero or more parameters""); (""Java Set"", ""has static factory method"", ""of()"")"
"Here is first an example of creating an empty, immutable Set using Set.of() :","(""Set"", ""of"", ""empty immutable Set""); (""Set"", ""has method"", ""of()"")"
Specifying a generic type of the Set returned by Set.of() looks like this:,"(""Set"", ""returned by"", ""Set.of()""); (""Set.of()"", ""returns"", ""Set""); (""Set"", ""is returned by"", ""Set.of()"")"
Here is an example of how creating a Set containing elements using the Set.of() method looks:,"(""Set"", ""contains"", ""elements""); (""Set"", ""has method"", ""of()""); (""Set.of()"", ""returns"", ""Set""); (""Set"", ""uses method"", ""of()"")"
To add elements to a Set you call its add() method.,"(""Set"", ""has method"", ""add()"")"
The three add() calls add a String instance to the set.,"(""add()"", ""is a method of"", ""set""); (""String"", ""is added to"", ""set""); (""set"", ""has method"", ""add()"")"
You obtain an Iterator from a Set by calling the iterator() method.,"(""Set"", ""has method"", ""iterator()""); (""Iterator"", ""obtained from"", ""Set""); (""Set"", ""calls method"", ""iterator()"")"
You can remove all elements from a Java Set using the clear() method.,"(""Java Set"", ""uses"", ""clear() method""); (""clear() method"", ""called by"", ""Java Set"")"
The Java List interface has a method called addAll() which adds all elements from another Collection (List or Set) to the Set.,"(""Java List"", ""has method"", ""addAll()""); (""addAll()"", ""adds elements from"", ""Collection""); (""List"", ""implements"", ""Collection""); (""Set"", ""extends"", ""Collection""); (""addAll()"", ""adds elements to"", ""Set"")"
The Java Set interface as a method called removeAll() which removes all elements in the Set which are also present in another Collection.,"(""Java Set"", ""has method"", ""removeAll()""); (""removeAll()"", ""removes elements from"", ""Set""); (""Set"", ""has elements present in"", ""Collection""); (""removeAll()"", ""takes as parameter"", ""Collection"")"
"The element three has been removed, because it was present in set2, which was given as parameter to set.removeAll(set2) .","(""set"", ""removeAll"", ""set2""); (""set2"", ""givenAsParameterTo"", ""set.removeAll""); (""set"", ""hasElement"", ""three""); (""set2"", ""contains"", ""three""); (""set.removeAll"", ""takesParameter"", ""set2""); (""three"", ""presentIn"", ""set2""); (""three"", ""removedFrom"", ""set"")"
You can check the size of a Java Set using the size() method.,"(""Java Set"", ""uses"", ""size() method""); (""Java Set"", ""has method"", ""size()""); (""Set"", ""uses"", ""size() method""); (""Set"", ""has method"", ""size()"")"
"You can check if a Java Set is empty, meaning it contains no elements, by calling the isEmpty() method on the Set.","(""Java Set"", ""has method"", ""isEmpty()""); (""isEmpty()"", ""belongs to"", ""Java Set""); (""Java Set"", ""contains"", ""elements"")"
You can also check if a Set is empty by comparing the value returned by the size() method with 0.,"(""Set"", ""has method"", ""size()""); (""Set"", ""returns value from"", ""size()""); (""size()"", ""compared to"", ""0"")"
"After running this Java code the isEmpty variable will contain the value true, because the Set size() method returns 0 - because the Set in the example contains no elements.","(""Set"", ""hasMethod"", ""size()""); (""Set"", ""returns"", ""0""); (""isEmpty"", ""contains"", ""true""); (""Set"", ""hasMethod"", ""isEmpty""); (""Set"", ""contains"", ""no elements""); (""Java"", ""hasCode"", ""isEmpty variable""); (""Set"", ""hasSize"", ""0""); (""isEmpty"", ""isVariableOf"", ""Java""); (""Set"", ""returnsSize"", ""0"")"
You can check if a Java Set contains a given element (object) by calling the contains() method.,"(""Java Set"", ""contains"", ""element""); (""Java Set"", ""calling"", ""contains() method""); (""contains() method"", ""called by"", ""Java Set"")"
"You can convert a Java Set to a Java List by creating a List and calling its addAll() method, passing the Set as parameter to the addAll() method.","(""Java Set"", ""converted to"", ""Java List""); (""Java List"", ""has method"", ""addAll()""); (""addAll()"", ""takes parameter"", ""Java Set"")"
"The Java SortedMap interface, java.util.SortedMap, is a subtype of the java.util.Map interface, with the addition that the elements stored in a Java SortedMap map are sorted internally.","(""Java SortedMap"", ""is a subtype of"", ""java.util.Map""); (""Java SortedMap"", ""extends"", ""java.util.SortedMap""); (""java.util.SortedMap"", ""is a subtype of"", ""java.util.Map""); (""java.util.Map"", ""has subtype"", ""java.util.SortedMap""); (""Java SortedMap"", ""stores"", ""elements""); (""java.util.SortedMap"", ""stores"", ""elements""); (""java.util.Map"", ""has subtype"", ""java.util.SortedMap"")"
Java comes with a built-in implementation of the Java SortedMap interface called TreeMap (java.util.TreeMap).,"(""Java"", ""comes with"", ""Java SortedMap interface""); (""Java SortedMap interface"", ""implemented by"", ""TreeMap""); (""TreeMap"", ""located in"", ""java.util.TreeMap""); (""TreeMap"", ""implements"", ""Java SortedMap interface""); (""Java SortedMap interface"", ""part of"", ""java.util"")"
"The order of the sorting in a Java SortedMap is either the natural sorting order of the elements (if they implement java.lang.Comparable), or the order determined by a Comparator that you can give to the SortedSet.","(""SortedMap"", ""implements"", ""java.lang.Comparable""); (""SortedSet"", ""uses"", ""Comparator""); (""Comparator"", ""determines"", ""order""); (""SortedMap"", ""has"", ""order""); (""SortedSet"", ""has"", ""order""); (""java.lang.Comparable"", ""provides"", ""natural sorting order"")"
But it is also possible to iterate the elements in descending order using the method TreeMap.descendingKeySet().,"(""TreeMap"", ""hasMethod"", ""TreeMap.descendingKeySet()""); (""TreeMap"", ""returns"", ""descendingKeySet""); (""TreeMap.descendingKeySet"", ""isMethodOf"", ""TreeMap"")"
"You iterate the keys of a SortedMap by calling its keySet() method, like this:","(""SortedMap"", ""has method"", ""keySet()"")"
"Remember, if you want to iterate the keys in descending order rather than ascending order, use the sortedMap.descendingKeySet().iterator() method, like this:","(""sortedMap"", ""has method"", ""descendingKeySet()""); (""descendingKeySet()"", ""returns"", ""iterator""); (""iterator"", ""is part of"", ""descendingKeySet()"")"
"If your Java SortedMap was created using a Comparator, you can obtain the Comparator used via the SortedMap comparator() method.","(""SortedMap"", ""has method"", ""comparator()""); (""comparator()"", ""is obtained from"", ""SortedMap""); (""Comparator"", ""is used by"", ""SortedMap"")"
Here is an example of obtaining the Comparator used by a SortedMap via its comparator() method:,"(""SortedMap"", ""has method"", ""comparator()""); (""SortedMap"", ""uses method"", ""comparator()""); (""comparator()"", ""is method of"", ""SortedMap"")"
Here is an example of obtaining the first key of a SortedMap via its firstKey() method:,"(""SortedMap"", ""has method"", ""firstKey()"")"
Here is an example of obtaining the last key of a SortedMap via its lastKey() method:,"(""SortedMap"", ""has method"", ""lastKey()"")"
The SortedMap interface has a method named headMap() which returns a new Map which contains the first elements of the SortedMap according to the sort order used.,"(""SortedMap"", ""has method"", ""headMap()""); (""headMap()"", ""returns"", ""Map""); (""SortedMap"", ""uses"", ""sort order""); (""headMap()"", ""contains"", ""first elements""); (""SortedMap"", ""contains"", ""first elements""); (""Map"", ""contains"", ""first elements"")"
The headMap() method takes a parameter that acts as a delimiter for what elements gets included in the returned head map.,"(""headMap()"", ""takes a parameter"", ""delimiter""); (""headMap()"", ""returns"", ""head map""); (""delimiter"", ""acts as"", ""parameter"")"
All elements with a key that is smaller than / earlier than the parameter passed to the headMap() method.,"(""headMap"", ""method of"", ""Map""); (""headMap"", ""returns"", ""Map""); (""Map"", ""has method"", ""headMap"")"
Here is an example of obtaining a head map from a SortedMap via its headMap() method:,"(""SortedMap"", ""has method"", ""headMap()"")"
The SortedMap interface has a method named tailMap() which returns a new Map which contains the last elements of the SortedMap according to the sort order used.,"(""SortedMap"", ""has method"", ""tailMap()""); (""SortedMap"", ""uses"", ""sort order""); (""SortedMap"", ""contains"", ""Map""); (""Map"", ""contains"", ""last elements""); (""tailMap()"", ""returns"", ""Map""); (""SortedMap"", ""has"", ""last elements"")"
The tailMap() method takes a parameter that acts as a delimiter for what elements gets included in the returned tail map.,"(""tailMap()"", ""takes a parameter"", ""delimiter""); (""tailMap()"", ""returns"", ""tail map""); (""tailMap()"", ""is a method of"", ""Map"")"
All elements with a key that is equal to or larger than the parameter passed to the tailMap() method.,"(""Map"", ""has method"", ""tailMap()""); (""Map"", ""uses parameter in"", ""tailMap()""); (""Parameter"", ""is passed to"", ""tailMap()""); (""Parameter"", ""is used by"", ""Map""); (""tailMap()"", ""is method of"", ""Map"")"
Here is an example of obtaining a tail map from a SortedMap via its tailMap() method:,"(""SortedMap"", ""hasMethod"", ""tailMap()"")"
"The tail map returned will contain the key, value pairs (""c"", ""3""), (""d"", ""4"") and (""e"", ""5""), since ""c"", ""d"" and ""e"" are larger than or equal to the ""c"" passed as parameter to tailMap() .","(""tailMap()"", ""parameter"", ""c"")"
The Java SortedMap also has a method named subMap() which can return a new Map which is a submap of the SortedMap.,"(""Java SortedMap"", ""has method"", ""subMap()""); (""SortedMap"", ""returns"", ""Map""); (""SortedMap"", ""has method"", ""subMap()""); (""Map"", ""is"", ""submap of SortedMap""); (""SortedMap"", ""has submap"", ""Map"")"
The subMap() method takes two parameters which act as delimiters for what elements are included in the returned submap.,"(""subMap()"", ""takes"", ""parameters""); (""subMap()"", ""returns"", ""submap""); (""parameters"", ""act as"", ""delimiters""); (""submap"", ""includes"", ""elements""); (""elements"", ""are included in"", ""submap"")"
Here is an example of obtaining a submap from a Java SortedMap via its subMap() method:,"(""SortedMap"", ""has method"", ""subMap()"")"
"The Java SortedSet interface, java.util.SortedSet, is a subtype of the java.util.Set interface.","(""Java SortedSet"", ""is a subtype of"", ""java.util.Set""); (""java.util.SortedSet"", ""is a subtype of"", ""java.util.Set"")"
The Java Collections API only has one implementation of the Java SortedSet interface - the java.util.TreeSet class.,"(""Java Collections API"", ""has implementation"", ""java.util.TreeSet class""); (""Java SortedSet interface"", ""has implementation"", ""java.util.TreeSet class""); (""java.util.TreeSet class"", ""implements"", ""Java SortedSet interface"")"
"The java.util.concurrent package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail.","(""java.util.concurrent"", ""has"", ""implementation""); (""java.util.concurrent"", ""isPartOf"", ""concurrency utilities""); (""concurrency utilities"", ""isPartOf"", ""java.util.concurrent"")"
"It it possible to pass a Comparator, java.util.Comparator implementation to the constructor of the TreeSet.","(""TreeSet"", ""has constructor"", ""Comparator""); (""Comparator"", ""is implemented by"", ""java.util.Comparator""); (""TreeSet"", ""uses"", ""Comparator""); (""TreeSet"", ""has relationship with"", ""java.util.Comparator"")"
"For the SortedSet to be able to determine the natural order of the elements, the elements must implement the java.lang.Comparable interface.","(""SortedSet"", ""uses"", ""java.lang.Comparable""); (""elements"", ""implement"", ""java.lang.Comparable""); (""SortedSet"", ""determines"", ""natural order""); (""elements"", ""have"", ""natural order""); (""java.lang.Comparable"", ""provides"", ""natural order"")"
But it is also possible to iterate the elements in descending order using the method TreeSet.descendingIterator().,"(""TreeSet"", ""has_method"", ""descendingIterator()"")"
"If you created your SortedSet with a Comparator, you can obtain that Comparator via the SortedSet comparator() method.","(""SortedSet"", ""has method"", ""comparator()""); (""SortedSet"", ""uses"", ""Comparator""); (""comparator()"", ""returns"", ""Comparator"")"
Here is an example of obtaining the Comparator used by a SortedSet via the comparator() method:,"(""SortedSet"", ""has method"", ""comparator()""); (""SortedSet"", ""uses method"", ""comparator()""); (""comparator()"", ""is method of"", ""SortedSet"")"
You add elements to a Java SortedSet in the same way you do with a normal Java Set - via its add() method.,"(""Java SortedSet"", ""has method"", ""add()""); (""Java Set"", ""has method"", ""add()"")"
"To remove an element from a SortedSet you call its remove() method, passing the element to remove as parameter.","(""SortedSet"", ""has method"", ""remove()""); (""remove()"", ""is called on"", ""SortedSet""); (""remove()"", ""takes parameter"", ""element"")"
You can get the first element of a SortedSet according to its sort order by calling the first() method of the SortedSet.,"(""SortedSet"", ""has method"", ""first()"")"
You can get the last element of a SortedSet according to its sort order by calling the last() method of the SortedSet.,"(""SortedSet"", ""has method"", ""last()"")"
"You call the SortedSet iterator() method which returns an Iterator, and then you can iterate the elements via that.","(""SortedSet"", ""iterator()"", ""Iterator""); (""Iterator"", ""iterate"", ""elements""); (""SortedSet"", ""returns"", ""Iterator""); (""Iterator"", ""via"", ""elements"")"
"The Java SortedSet interface has a method named headSet() which returns another SortedSet with all elements that are smaller than (ahead of) a given parameter value, according to the sort order used by the SortedSet.","(""SortedSet"", ""has method"", ""headSet()""); (""headSet()"", ""returns"", ""SortedSet""); (""SortedSet"", ""uses"", ""sort order"")"
Here is an example of obtaining a head set from a Java SortedSet via its headSet() method:,"(""SortedSet"", ""hasMethod"", ""headSet()""); (""headSet()"", ""returns"", ""Subset""); (""SortedSet"", ""hasMethod"", ""subset""); (""Java"", ""uses"", ""SortedSet""); (""SortedSet"", ""isPartOf"", ""Java"")"
"After running this code the headSet will contain the elements ""a"" and ""b"" since these two elements are smaller than (ahead of) the parameter value ""c"" that was passed to the headSet() method.","(""headSet"", ""contains"", ""elements""); (""headSet"", ""created by"", ""headSet() method""); (""headSet()"", ""takes parameter"", ""parameter value""); (""elements"", ""compared to"", ""parameter value""); (""headSet"", ""contains"", ""a""); (""headSet"", ""contains"", ""b""); (""elements"", ""smaller than"", ""c"")"
"The Java SortedSet interface has a method named setSet() which returns another SortedSet with all elements that are greater than or equal to (tailing) a given parameter value, according to the sort order used by the SortedSet.","(""SortedSet"", ""has method"", ""setSet()""); (""setSet()"", ""returns"", ""SortedSet""); (""SortedSet"", ""uses"", ""sort order"")"
Here is an example of obtaining a tail set from a Java SortedSet via its tailSet() method:,"(""SortedSet"", ""has method"", ""tailSet()""); (""SortedSet"", ""uses method"", ""tailSet()""); (""Java"", ""has class"", ""SortedSet""); (""SortedSet"", ""has method"", ""tailSet()""); (""tailSet"", ""is method of"", ""SortedSet"")"
"After running this code the tailSet will contain the elements ""c"", ""d"" and ""e"", since these three elements are greater than or equal to (tailing) the parameter value ""c"" that was passed to the tailSet() method.","(""tailSet"", ""contains"", ""elements""); (""tailSet"", ""parameter"", ""value""); (""value"", ""compared to"", ""elements""); (""tailSet"", ""method"", ""tailSet()""); (""elements"", ""greater than or equal to"", ""value""); (""tailSet"", ""result of"", ""tailSet()""); (""tailSet()"", ""called with"", ""value"")"
The Java SortedSet interface has a method named subSet() method which will return a new SortedSet which is a subset of the SortedSet the subSet() method is called on.,"(""SortedSet"", ""has method"", ""subSet()""); (""SortedSet"", ""returns"", ""SortedSet""); (""subSet()"", ""is part of"", ""SortedSet"")"
The subSet() method takes two parameter values which specify what elements the returned SortedSet should contain.,"(""SortedSet"", ""has method"", ""subSet()""); (""subSet()"", ""takes parameter"", ""parameter values""); (""SortedSet"", ""contains"", ""elements"")"
Here is an example of obtaining a subset of a Java SortedSet via its subSet() method:,"(""SortedSet"", ""has method"", ""subSet()""); (""Java"", ""contains"", ""SortedSet""); (""SortedSet"", ""has method"", ""subSet()"")"
Notice how there is no longer a cast of the object returned from iterator.next() needed.,
"Because the generic type of the SortedSet is String, the compiler knows that the iterator is an Iterato<String>, so next() return String objects.","(""SortedSet"", ""has type"", ""String""); (""Iterator"", ""has type"", ""String""); (""SortedSet"", ""uses"", ""Iterator""); (""next()"", ""returns"", ""String""); (""Iterator"", ""has method"", ""next()"")"
You can sort a Java List collections using the java.util.Collections.sort() method.,"(""Java List"", ""uses"", ""java.util.Collections.sort()""); (""java.util.Collections.sort()"", ""sorts"", ""Java List""); (""Java List"", ""is part of"", ""Java collections""); (""java.util.Collections"", ""contains"", ""java.util.Collections.sort()"")"
For objects to have a natural order they must implement the interface java.lang.Comparable.,"(""objects"", ""must implement"", ""java.lang.Comparable""); (""java.lang.Comparable"", ""is implemented by"", ""objects"")"
"The compareTo() method should compare this object to another object, return an int value.","(""compareTo()"", ""should compare"", ""object""); (""object"", ""is compared by"", ""compareTo()""); (""compareTo()"", ""returns"", ""int"")"
"So, if a string is less than another string by alphabetic comparison it will return a negative number from the compareTo() method.","(""String"", ""hasMethod"", ""compareTo()""); (""compareTo()"", ""returns"", ""number""); (""String"", ""uses"", ""compareTo()"")"
When you implement the compareTo() method in your own classes you will have to decide how these objects should be compared to each other.,"(""compareTo"", ""implemented in"", ""classes""); (""classes"", ""have"", ""objects""); (""objects"", ""compared to"", ""objects""); (""compareTo"", ""method of"", ""classes"")"
Notice how the Collections.sort() method now takes a java.util.Comparator as parameter in addition to the List.,"(""Collections"", ""takes"", ""java.util.Comparator""); (""Collections.sort()"", ""takes"", ""java.util.Comparator""); (""Collections.sort()"", ""takes"", ""List"")"
The compare() method compares two objects to each other and should:,"(""compare"", ""is a method of"", ""Object""); (""compare"", ""compares"", ""Object"")"
"There are a few more requirements to the implementation of the compare() method, but these are the primary requirements.","(""compare"", ""is a method of"", ""implementation"")"
"If you want to compare objects by more than one factor, start by comparing by the first factor (e.g first name).",
"Then, if the first factors are equal, compare by the second factor (e.g.",
"The Java Stack class, java.util.Stack, is a classical stack data structure.","(""Java"", ""contains"", ""Stack class""); (""Stack class"", ""isPartOf"", ""java.util.Stack""); (""Stack class"", ""implements"", ""stack data structure""); (""java.util.Stack"", ""isA"", ""classical stack data structure"")"
"The Java Stack class actually implements the Java List interface, but you rarely use a Stack as a List - except perhaps if you need to inspect all elements currently stored on the stack.","(""Stack"", ""implements"", ""List""); (""Stack"", ""used as"", ""List""); (""Stack"", ""stores"", ""elements""); (""List"", ""used for"", ""inspection"")"
"Please note, that the Java Stack class is a subclass of Vector, an older Java class which is synchronized.","(""Java Stack"", ""is a subclass of"", ""Vector""); (""Vector"", ""is synchronized"", """"); (""Java Stack"", ""is a subclass of"", ""older Java class""); (""Vector"", ""is"", ""older Java class""); (""Java Stack"", ""is synchronized"", """")"
"Additionally, the Vector class uses several older (no longer recommended) parts of Java, like the Enumeration which is superseded by the Iterator interface.","(""Vector"", ""uses"", ""Enumeration""); (""Enumeration"", ""superseded by"", ""Iterator"")"
To use a Java Stack you must first create an instance of the Stack class.,"(""Java"", ""uses"", ""Stack class""); (""Stack class"", ""instance created by"", ""user"")"
You push elements onto a Java Stack using its push() method.,"(""Java Stack"", ""uses"", ""push() method""); (""push() method"", ""called by"", ""Java Stack""); (""Java Stack"", ""has method"", ""push() method"")"
You pop an element off a Java Stack using the pop() method.,"(""Java Stack"", ""uses"", ""pop() method""); (""pop() method"", ""called by"", ""Java Stack"")"
Here is an example of popping an element off a Stack using the pop() method:,"(""Stack"", ""uses"", ""pop()""); (""pop()"", ""is method of"", ""Stack"")"
"The Java Stack class has a method called peek() which enables you to see what the top element on the Stack is, without popping off the element.","(""Stack"", ""has method"", ""peek()""); (""Stack"", ""has method"", ""pop()""); (""peek()"", ""returns"", ""top element""); (""Stack"", ""contains"", ""top element"")"
After running this Java example the topElement variable will contain the String object 1 which was pushed onto the Stack just before peek() was called.,"(""Stack"", ""hasMethod"", ""push()""); (""Stack"", ""hasMethod"", ""peek()""); (""String"", ""newInstance"", ""1""); (""Stack"", ""contains"", ""String""); (""Stack"", ""hasVariable"", ""topElement""); (""topElement"", ""holds"", ""String"")"
The String object is still present on the Stack after calling peek().,"(""String"", ""is present on"", ""Stack""); (""peek()"", ""is a method of"", ""Stack"")"
"You can search for an object on the stack to get it's index, using the search() method.","(""stack"", ""has method"", ""search()"")"
The object's equals() method is called on every object on the Stack to determine if the searched-for object is present on the Stack.,"(""Object"", ""hasMethod"", ""equals()""); (""Stack"", ""hasMethod"", ""search()""); (""Object"", ""isOn"", ""Stack""); (""equals()"", ""determines"", ""presence""); (""Object"", ""isSearchedOn"", ""Stack"")"
"You can obtain the size of a Java Stack, meaning the number of elements currently stored on the Stack, via the Stack size() method.","(""Stack"", ""has method"", ""size()""); (""Stack"", ""returns size via"", ""size()""); (""Java Stack"", ""has method"", ""size()""); (""Stack size()"", ""is method of"", ""Stack"")"
Here is an example of obtaining the size of a Java Stack via its size() method:,"(""Java Stack"", ""has method"", ""size()"")"
"After running this code the size variable will contain the value 3, since the Stack in the example contains 3 elements at the time its size() method is called.","(""Stack"", ""contains"", ""elements""); (""Stack"", ""has method"", ""size()""); (""size()"", ""returns"", ""value""); (""Stack"", ""has attribute"", ""size"")"
You do so by first obtaining a Stream from the Stack via the stream() method.,"(""Stream"", ""obtained from"", ""Stack""); (""Stack"", ""has method"", ""stream()"")"
"Notice, that this example uses a Java Lambda as parameter to the Stream.forEach() method.","(""Java"", ""uses"", ""Lambda""); (""Lambda"", ""passed as parameter to"", ""Stream.forEach()""); (""Stream"", ""has method"", ""forEach()"")"
The non-parallelizable part of the programs is 40% which out of a total time of 1 is equal to 0.4 .,
The parallelizable part is thus equal to 1 - 0.4 = 0.6 .,
"If B is 0.4, O is 2 and N is 5, then the calculation looks like this:",
"With B = 0.4, O = 2 and N = 5, the calculation becomes:",
"That means, that if you optimize the non-parallelizable (sequential) part by a factor of 2, and paralellize the parallelizable part by a factor of 5, the new optimized version of the program or algorithm would run a maximum of 2.77777 times faster than the old version.",
Note: The content of this text is a part result of a M.Sc.,
Once a thread want to notify the waiting threads it calls notifyAll() on the object the waiting threads called wait() on.,"(""thread"", ""calls"", ""notifyAll()""); (""waiting threads"", ""called"", ""wait()""); (""thread"", ""calls"", ""notifyAll() on object""); (""waiting threads"", ""called wait() on"", ""object""); (""notifyAll()"", ""is called on"", ""object""); (""wait()"", ""is called on"", ""object""); (""thread"", ""notifies"", ""waiting threads"")"
Just have the notifying thread call notify() on the object the waiting threads have called wait() on.,"(""notifying thread"", ""call"", ""notify()""); (""waiting threads"", ""call"", ""wait()""); (""notifying thread"", ""notify"", ""object""); (""waiting threads"", ""wait"", ""object"")"
"To achive this each waiting thread must call wait() on its own, separate object.","(""thread"", ""call"", ""wait()""); (""thread"", ""have"", ""object""); (""object"", ""have"", ""wait()"")"
When the notifying thread wants to notify a specific waiting thread it will call notify() on the object this specific thread has called wait() on.,"(""thread"", ""calls"", ""notify()""); (""thread"", ""calls"", ""wait()""); (""notifying thread"", ""calls"", ""notify()""); (""notifying thread"", ""has"", ""waiting thread""); (""waiting thread"", ""calls"", ""wait()""); (""object"", ""has"", ""notify()""); (""object"", ""has"", ""wait()"")"
The lockWrite() method of a ReadWriteLock class shown below is an example of a test-and-set method.,"(""ReadWriteLock"", ""hasMethod"", ""lockWrite()""); (""lockWrite()"", ""isMethodOf"", ""ReadWriteLock"")"
Threads calling lockWrite() first sets the state before the test (writeRequests++).,"(""Threads"", ""calls"", ""lockWrite()""); (""lockWrite()"", ""sets"", ""state""); (""lockWrite()"", ""increments"", ""writeRequests"")"
Then it tests the internal state against the access condition in the canGrantWriteAccess() method.,"(""canGrantWriteAccess()"", ""ismethodof"", ""internal state""); (""canGrantWriteAccess()"", ""isusedby"", ""access condition""); (""internal state"", ""ischeckedby"", ""canGrantWriteAccess()""); (""access condition"", ""isusedwith"", ""canGrantWriteAccess()"")"
The BoundedSemaphore class shown below has two test-and-set methods: take() and release().,"(""BoundedSemaphore"", ""has methods"", ""take()""); (""BoundedSemaphore"", ""has methods"", ""release()"")"
A typical example of a set method is the unlock() method of a Lock class.,"(""Lock"", ""has method"", ""unlock()"")"
Java 5 comes with blocking queue implementations in the java.util.concurrent package.,"(""Java 5"", ""comes with"", ""java.util.concurrent package""); (""java.util.concurrent package"", ""contains"", ""blocking queue implementations"")"
Notice how notifyAll() is only called from enqueue() and dequeue() if the queue size is equal to the size bounds (0 or limit).,"(""notifyAll()"", ""called from"", ""enqueue()""); (""notifyAll()"", ""called from"", ""dequeue()"")"
"If the queue size is not equal to either bound when enqueue() or dequeue() is called, there can be no threads waiting to either enqueue or dequeue items.","(""queue"", ""has method"", ""enqueue()""); (""queue"", ""has method"", ""dequeue()""); (""enqueue()"", ""called by"", ""thread""); (""dequeue()"", ""called by"", ""thread""); (""queue"", ""has property"", ""size""); (""enqueue()"", ""affects"", ""queue size""); (""dequeue()"", ""affects"", ""queue size"")"
"As you can see, the lock() method first checks if the locked member variable is equal to false (check), and if it is it ses locked to true (then act).","(""lock() method"", ""checks"", ""locked member variable""); (""lock() method"", ""sets"", ""locked member variable"")"
"If multiple threads had access to the same MyLock instance, the above lock() function would not be guaranteed to work.","(""MyLock"", ""hasMethod"", ""lock()""); (""MyLock"", ""isAccessibleBy"", ""threads""); (""lock()"", ""belongsTo"", ""MyLock""); (""threads"", ""access"", ""MyLock"")"
Here is the code example from earlier with the lock() method turned into an atomic block of code using the synchronized keyword:,"(""synchronized"", ""uses"", ""lock()""); (""lock()"", ""replaced by"", ""synchronized"")"
Now the lock() method is synchronized so only one thread can executed it at a time on the same MyLock instance.,"(""MyLock"", ""has method"", ""lock()""); (""lock()"", ""is part of"", ""MyLock""); (""MyLock"", ""can be executed by"", ""thread""); (""lock()"", ""can be executed by"", ""one thread""); (""thread"", ""executes"", ""lock()""); (""MyLock"", ""instance of"", ""MyLock""); (""lock()"", ""synchronized by"", ""MyLock"")"
"The atomic lock() method is actually an example of ""compare and swap"".","(""lock"", ""is an example of"", ""compare and swap"")"
"The lock() method compares the variable locked to the expected value false and if locked is equal to this expected value, it swaps the variable's value to true .","(""lock()"", ""compares"", ""locked""); (""lock()"", ""swaps"", ""locked""); (""locked"", ""is compared to"", ""false""); (""locked"", ""is swapped to"", ""true"")"
From Java 5 you can get access to these functions in the CPU via some of the new atomic classes in the java.util.concurrent.atomic package.,"(""Java 5"", ""has"", ""java.util.concurrent.atomic package""); (""java.util.concurrent.atomic package"", ""contains"", ""atomic classes"")"
Here is an example showing how to implement the lock() method shown earlier using the AtomicBoolean class:,"(""AtomicBoolean"", ""has method"", ""lock()""); (""lock()"", ""is implemented using"", ""AtomicBoolean"")"
"This class has a compareAndSet() function which will compare the value of the AtomicBoolean instance to an expected value, and if has the expected value, it swaps the value with a new value.","(""AtomicBoolean"", ""has"", ""compareAndSet()""); (""compareAndSet()"", ""compares"", ""AtomicBoolean""); (""compareAndSet()"", ""swaps"", ""value""); (""AtomicBoolean"", ""has"", ""value"")"
"The compareAndSet() method returns true if the value was swapped, and false if not.","(""compareAndSet()"", ""returns"", ""true""); (""compareAndSet()"", ""returns"", ""false"")"
Many of the concurrency utilities in the java.util.concurrent Java package are designed for use with this model.,"(""java.util.concurrent"", ""is part of"", ""Java""); (""Java"", ""uses"", ""concurrency utilities""); (""concurrency utilities"", ""are in"", ""java.util.concurrent"")"
Non-blocking IO means that when a worker starts an IO operation (e.g.,
"When the IO operation finishes, the result of the IO operation ( e.g.",
It just needs to know what channel to forward the job to (or send the message to etc.).,
"The main disadvantage of the assembly line concurrency model is that the execution of a job is often spread out over multiple workers, and thus over multiple classes in your project.","(""concurrency model"", ""has disadvantage"", ""job execution""); (""execution of a job"", ""is spread out over"", ""multiple workers""); (""execution of a job"", ""is spread out over"", ""multiple classes""); (""job"", ""is executed by"", ""multiple workers""); (""job"", ""is executed by"", ""multiple classes"")"
"Of course parallel worker code may also be spread over many different classes, but the execution sequence is often easier to read from the code.",
With Java 7 we got the java.util.concurrent package contains the ForkAndJoinPool which can help you implement something similar to functional parallelism.,"(""Java 7"", ""contains"", ""java.util.concurrent""); (""java.util.concurrent"", ""contains"", ""ForkAndJoinPool""); (""ForkAndJoinPool"", ""helps implement"", ""functional parallelism"")"
"However, if the system is concurrently executing multiple other tasks (like e.g.",
when a Java application is started its main() method is executed by the main thread - a special thread that is created by the Java VM to run your application.,"(""Java application"", ""has method"", ""main()""); (""Java VM"", ""creates"", ""main thread""); (""main thread"", ""executes"", ""main()""); (""Java application"", ""runs on"", ""Java VM"")"
"Threads are instances of class java.lang.Thread, or instances of subclasses of this class.","(""java.lang.Thread"", ""is instances of"", ""java.lang.Thread""); (""java.lang.Thread"", ""has subclasses"", ""subclasses of java.lang.Thread""); (""subclasses of java.lang.Thread"", ""are instances of"", ""java.lang.Thread""); (""Threads"", ""are instances of"", ""java.lang.Thread""); (""Threads"", ""are instances of"", ""subclasses of java.lang.Thread"")"
"To start the Java thread you will call its start() method, like this:","(""Java thread"", ""call"", ""start() method""); (""thread"", ""has"", ""start() method"")"
The first is to create a subclass of Thread and override the run() method.,"(""Thread"", ""has method"", ""run()""); (""Thread"", ""can be subclassed by"", ""subclass""); (""Subclass"", ""overrides method"", ""run()"")"
The second method is to pass an object that implements Runnable (java.lang.Runnable to the Thread constructor.,"(""Thread"", ""implements"", ""java.lang.Runnable""); (""Thread"", ""has constructor"", ""Thread constructor""); (""java.lang.Runnable"", ""is implemented by"", ""object"")"
"The first way to specify what code a thread is to run, is to create a subclass of Thread and override the run() method.","(""Thread"", ""subclass"", ""subclass of Thread""); (""Thread"", ""has method"", ""run()""); (""subclass of Thread"", ""overrides"", ""run()"")"
The run() method is what is executed by the thread after you call start().,"(""thread"", ""has method"", ""run()""); (""thread"", ""calls"", ""start()""); (""run()"", ""is executed by"", ""thread"")"
The start() call will return as soon as the thread is started.,"(""thread"", ""has method"", ""start()"")"
The run() method will execute as if executed by a different CPU.,"(""run()"", ""executed by"", ""CPU"")"
"When the run() method executes it will print out the text ""MyThread running"".","(""run()"", ""executes"", ""MyThread""); (""MyThread"", ""has method"", ""run()""); (""run()"", ""prints"", ""MyThread running"")"
You can also create an anonymous subclass of Thread like this:,"(""Thread"", ""has subclass"", ""anonymous subclass"")"
"This example will print out the text ""Thread running"" once the run() method is executed by the new thread.","(""Thread"", ""has method"", ""run()"")"
The second way to specify what code a thread should run is by creating a class that implements the java.lang.Runnable interface.,"(""thread"", ""implements"", ""java.lang.Runnable""); (""java.lang.Runnable"", ""is implemented by"", ""thread"")"
Whatever the thread is supposed to do when it executes must be included in the implementation of the run() method.,"(""run() method"", ""is part of"", ""thread""); (""run() method"", ""is implemented by"", ""thread""); (""thread"", ""executes"", ""run() method"")"
The first way to implement the Java Runnable interface is by creating your own Java class that implements the Runnable interface.,"(""Java"", ""implements"", ""Runnable interface""); (""Java class"", ""implements"", ""Runnable interface""); (""Runnable interface"", ""is implemented by"", ""Java class"")"
Here is an example of a custom Java class that implements the Runnable interface:,"(""Custom Java class"", ""implements"", ""Runnable interface"")"
"After printing that text, the run() method exits, and the thread running the run() method will stop.","(""run() method"", ""exits"", ""thread""); (""run() method"", ""is running by"", ""thread""); (""thread"", ""is running"", ""run() method""); (""run() method"", ""will stop"", ""thread"")"
Here is an example of an anonymous Java class that implements the Runnable interface:,"(""Java"", ""implements"", ""Runnable""); (""Runnable"", ""interface of"", ""Java"")"
"Apart from being an anononymous class, this example is quite similar to the example that used a custom class to implement the Runnable interface.","(""Runnable"", ""implemented by"", ""custom class""); (""custom class"", ""used in"", ""example""); (""example"", ""similar to"", ""anonymous class""); (""anonymous class"", ""implements"", ""Runnable"")"
"To have the run() method executed by a thread, pass an instance of a class, anonymous class or lambda expression that implements the Runnable interface to a Thread in its constructor.","(""Thread"", ""has constructor"", ""Runnable""); (""Runnable"", ""implemented by"", ""class""); (""Runnable"", ""implemented by"", ""anonymous class""); (""Runnable"", ""implemented by"", ""lambda expression""); (""Thread"", ""executes"", ""run()""); (""Runnable"", ""has method"", ""run()"")"
When the thread is started it will call the run() method of the MyRunnable instance instead of executing it's own run() method.,"(""MyRunnable"", ""has method"", ""run()""); (""Thread"", ""calls method"", ""MyRunnable.run()""); (""Thread"", ""has method"", ""run()"")"
Sometimes you may have to implement Runnable as well as subclass Thread.,"(""Runnable"", ""implemented by"", ""Thread""); (""Thread"", ""subclass of"", ""Runnable""); (""Runnable"", ""extended by"", ""Thread"")"
"For instance, if creating a subclass of Thread that can execute more than one Runnable.","(""Thread"", ""subclass of"", ""Runnable""); (""Thread"", ""can execute"", ""Runnable""); (""Runnable"", ""executed by"", ""Thread"")"
"When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start(), like this:","(""Thread"", ""has method"", ""run()""); (""Thread"", ""has method"", ""start()"")"
At first you may not notice anything because the Runnable's run() method is executed like you expected.,"(""Runnable"", ""has method"", ""run()"")"
Instead the run() method is executed by the thread that created the thread.,"(""thread"", ""created"", ""thread""); (""thread"", ""executed"", ""run()""); (""run()"", ""executed by"", ""thread"")"
"To have the run() method of the MyRunnable instance called by the new created thread, newThread, you MUST call the newThread.start() method.","(""MyRunnable"", ""has method"", ""run()""); (""MyRunnable"", ""instance of"", ""MyRunnable""); (""newThread"", ""has method"", ""start()""); (""newThread"", ""is instance of"", ""Thread""); (""Thread"", ""has method"", ""start()"")"
"For instance, if multiple threads write to System.out it can be handy to see which thread wrote the text.","(""System.out"", ""is written to by"", ""multiple threads""); (""System.out"", ""is used for"", ""text output""); (""multiple threads"", ""write to"", ""System.out"")"
"Notice however, that since the MyRunnable class is not a subclass of Thread, it does not have access to the getName() method of the thread executing it.","(""MyRunnable"", ""is not a subclass of"", ""Thread""); (""Thread"", ""has method"", ""getName()""); (""MyRunnable"", ""does not have access to"", ""getName()"")"
The Thread.currentThread() method returns a reference to the Thread instance executing currentThread() .,"(""Thread"", ""hasMethod"", ""currentThread()""); (""Thread"", ""executes"", ""currentThread()""); (""Thread"", ""returns"", ""Thread""); (""Thread"", ""hasMethod"", ""currentThread()"")"
First it prints out the name of the thread executing the main() method.,"(""main"", ""is executing in"", ""thread"")"
"Note that even if the threads are started in sequence (1, 2, 3 etc.)",
"they may not execute sequentially, meaning thread 1 may not be the first thread to write its name to System.out.","(""Thread"", ""may write to"", ""System.out""); (""Thread 1"", ""may not be the first to write to"", ""System.out""); (""System.out"", ""is written to by"", ""Thread"")"
A thread can pause itself by calling the static method Thread.sleep() .,"(""Thread"", ""calls"", ""Thread.sleep()"")"
The sleep() method will attempt to sleep that number of milliseconds before resuming execution.,"(""sleep()"", ""is method of"", ""Thread""); (""sleep()"", ""attempts to"", ""sleep milliseconds""); (""Thread"", ""has method"", ""sleep()"")"
"The Thread sleep() is not 100% precise, but it is pretty good still.","(""Thread"", ""has method"", ""sleep()"")"
Here is an example of pausing a Java thread for 3 seconds (3.000 millliseconds) by calling the Thread sleep() method:,"(""Thread"", ""has method"", ""sleep()""); (""Thread.sleep()"", ""pauses"", ""Java thread""); (""Java thread"", ""uses method"", ""Thread.sleep()""); (""Thread"", ""is used in"", ""Java""); (""Thread.sleep()"", ""is called by"", ""Java thread"")"
"The thread executing the Java code above, will sleep for approximately 10 seconds (10.000 milliseconds).","(""Thread"", ""executing"", ""Java code""); (""Java code"", ""sleep for"", ""10 seconds""); (""10 seconds"", ""equivalent to"", ""10.000 milliseconds""); (""Thread"", ""sleep for"", ""10.000 milliseconds"")"
"The Java Thread class contains a stop() method, but it is deprecated.","(""Java Thread"", ""contains"", ""stop()""); (""stop()"", ""is"", ""deprecated"")"
The original stop() method would not provide any guarantees about in what state the thread was stopped.,"(""thread"", ""has method"", ""stop()"")"
Instead of calling the stop() method you will have to implement your thread code so it can be stopped.,"(""thread"", ""has method"", ""stop()"")"
Here is an example of a class that implements Runnable which contains an extra method called doStop() which signals to the Runnable to stop.,"(""Runnable"", ""implements"", ""class""); (""class"", ""contains"", ""doStop()""); (""doStop()"", ""signals"", ""Runnable"")"
The doStop() is intended to be called from another thread than the thread executing the MyRunnable's run() method.,"(""MyRunnable"", ""hasMethod"", ""run()""); (""MyRunnable"", ""executesIn"", ""thread""); (""doStop()"", ""calledFrom"", ""thread""); (""MyRunnable"", ""runsIn"", ""thread""); (""doStop()"", ""calledFrom"", ""another thread"")"
The keepRunning() method is called internally by the thread executing the MyRunnable's run() method.,"(""MyRunnable"", ""has method"", ""run()""); (""MyRunnable"", ""uses method"", ""keepRunning()""); (""keepRunning()"", ""is called by"", ""MyRunnable.run()"")"
As long as doStop() has not been called the keepRunning() method will return true - meaning the thread executing the run() method will keep running.,"(""doStop()"", ""has not been called"", ""keepRunning()""); (""keepRunning()"", ""will return"", ""true""); (""run()"", ""is executed by"", ""thread""); (""keepRunning()"", ""returns"", ""true""); (""thread"", ""executes"", ""run()"")"
"Here is an example of starting a Java thread that executes an instance of the above MyRunnable class, and stopping it again after a delay:","(""Thread"", ""executes"", ""MyRunnable""); (""Thread"", ""starts"", ""MyRunnable""); (""Thread"", ""stops"", ""MyRunnable"")"
"Then the thread executing the main() method (the main thread) sleeps for 10 seconds, and then calls the doStop() method of the MyRunnable instance.","(""main"", ""executes"", ""main() method""); (""main thread"", ""sleeps for"", ""10 seconds""); (""main thread"", ""calls"", ""doStop() method""); (""MyRunnable instance"", ""has"", ""doStop() method""); (""main thread"", ""interacts with"", ""MyRunnable instance"")"
"This will cause the thread executing the MyRunnable method to stop, because the keepRunning() will return false after doStop() has been called.","(""MyRunnable"", ""has method"", ""keepRunning()""); (""MyRunnable"", ""has method"", ""doStop()""); (""keepRunning()"", ""is called by"", ""MyRunnable""); (""doStop()"", ""is called by"", ""MyRunnable""); (""MyRunnable"", ""executes"", ""thread""); (""doStop()"", ""affects"", ""keepRunning()"")"
Please keep in mind that if your Runnable implementation needs more than just the run() method (e.g.,"(""Runnable"", ""hasMethod"", ""run()"")"
"a stop() or pause() method too), then you can no longer create your Runnable implementation with a Java lambda expression.","(""Runnable"", ""has method"", ""stop()""); (""Runnable"", ""has method"", ""pause()""); (""Runnable"", ""implemented by"", ""Java lambda expression""); (""Java lambda expression"", ""creates"", ""Runnable implementation"")"
"Instead you must use a custom class, or a custom interface that extends Runnable which has the extra methods, and which is implemented by an anonymous class.","(""Runnable"", ""extends"", ""custom interface""); (""custom interface"", ""implemented by"", ""anonymous class""); (""anonymous class"", ""implements"", ""Runnable"")"
You will have to create a custom lock class or use one of the Java 5 concurrency constructs in the java.util.concurrency package.,"(""java.util.concurrency"", ""contains"", ""custom lock class""); (""java.util.concurrency"", ""contains"", ""Java 5 concurrency constructs"")"
"Every time a thread takes a lock it is noted in a data structure (map, graph etc.)","(""thread"", ""takes"", ""lock""); (""lock"", ""is noted in"", ""data structure""); (""thread"", ""uses"", ""data structure""); (""data structure"", ""can be"", ""map""); (""data structure"", ""can be"", ""graph"")"
Here is an example of a TreeNode class that call synchronized methods in different instances:,"(""TreeNode"", ""has method"", ""synchronized""); (""TreeNode"", ""calls"", ""synchronized""); (""TreeNode"", ""is a"", ""class""); (""synchronized"", ""is called by"", ""TreeNode"")"
"If a thread (1) calls the parent.addChild(child) method at the same time as another thread (2) calls the child.setParent(parent) method, on the same parent and child instances, a deadlock can occur.","(""parent"", ""addChild"", ""child""); (""child"", ""setParent"", ""parent"")"
Here is some pseudo code that illustrates this: Thread 1: parent.addChild(child); //locks parent --> child.setParentOnly(parent); Thread 2: child.setParent(parent); //locks child --> parent.addChildOnly() First thread 1 calls parent.addChild(child).,"(""parent"", ""addChild"", ""child""); (""child"", ""setParentOnly"", ""parent""); (""child"", ""setParent"", ""parent""); (""parent"", ""addChildOnly"", """"); (""Thread 1"", ""calls"", ""parent.addChild""); (""Thread 2"", ""calls"", ""child.setParent""); (""parent"", ""locks"", ""child""); (""child"", ""locks"", ""child""); (""Thread 1"", ""calls"", ""child.setParentOnly""); (""Thread 2"", ""calls"", ""parent.addChildOnly"")"
Since addChild() is synchronized thread 1 effectively locks the parent object for access from other treads.,"(""Thread"", ""calls"", ""addChild()""); (""Parent object"", ""locked by"", ""Thread""); (""addChild()"", ""accessed by"", ""Thread"")"
Since setParent() is synchronized thread 2 effectively locks the child object for acces from other threads.,"(""setParent()"", ""is a method of"", ""Thread""); (""Thread"", ""has method"", ""setParent()""); (""setParent()"", ""locks"", ""child object""); (""child object"", ""is accessed by"", ""Thread""); (""Thread"", ""accesses"", ""child object"")"
"Next thread 1 tries to call child.setParentOnly() method, but the child object is locked by thread 2, so the method call just blocks.","(""child"", ""is locked by"", ""thread 2""); (""thread 1"", ""tries to call"", ""child.setParentOnly()""); (""child"", ""has method"", ""setParentOnly()"")"
"Thread 2 also tries to call parent.addChildOnly() but the parent object is locked by thread 1, causing thread 2 to block on that method call.","(""Thread"", ""calls"", ""parent.addChildOnly()""); (""parent"", ""is locked by"", ""Thread 1""); (""Thread 2"", ""blocks on"", ""parent.addChildOnly()""); (""Thread 1"", ""locks"", ""parent"")"
"Note: The two threads must call parent.addChild(child) and child.setParent(parent) at the same time as described above, and on the same two parent and child instances for a deadlock to occur.","(""parent"", ""addChild"", ""child""); (""child"", ""setParent"", ""parent"")"
Thread 1: parent.addChild(child); //locks parent --> child.setParentOnly(parent); Thread 2: child.setParent(parent); //locks child --> parent.addChildOnly() First thread 1 calls parent.addChild(child).,"(""parent"", ""addChild"", ""child""); (""child"", ""setParentOnly"", ""parent""); (""child"", ""setParent"", ""parent""); (""parent"", ""addChildOnly"", """"); (""parent"", ""addChild"", ""child""); (""child"", ""setParent"", ""parent"")"
By far the best book on the java.util.concurrent package in Java 5 and forward.,"(""Java"", ""uses"", ""java.util.concurrent""); (""java.util.concurrent"", ""part of"", ""Java 5"")"
"https://lmax-exchange.github.io/disruptor/ The LMAX Disrupter concurrent data structure (a single reader, single writer queue-like structure with high concurrency).","(""Disrupter"", ""isA"", ""concurrent data structure""); (""Disrupter"", ""hasCharacteristic"", ""single reader""); (""Disrupter"", ""hasCharacteristic"", ""single writer""); (""Disrupter"", ""hasCharacteristic"", ""queue-like structure""); (""Disrupter"", ""hasCharacteristic"", ""high concurrency""); (""LMAX Disrupter"", ""isA"", ""Disrupter"")"
In the following code example I have created an example of such a communication mechanism - a Java class called FrameExchanger.,"(""FrameExchanger"", ""is a"", ""Java class""); (""Java"", ""has class"", ""FrameExchanger"")"
It is not important how this class looks in order to understand how the FrameExchanger works.,"(""FrameExchanger"", ""works"", ""class"")"
"The producing thread will call storeFrame() continuously, and the drawing thread will call takeFrame() continuously.","(""producing thread"", ""calls"", ""storeFrame()""); (""drawing thread"", ""calls"", ""takeFrame()"")"
Notice how the three instructions inside the storeFrame() method seem like they do not depend on each other.,"(""storeFrame"", ""method of"", ""unknown class""); (""storeFrame"", ""contains"", ""instructions"")"
"That means, that if the drawing thread is waiting in the while-loop in the takeFrame() method, the drawing thread could exit that while-loop, and take the old Frame object.","(""drawing thread"", ""waiting in"", ""while-loop""); (""while-loop"", ""in"", ""takeFrame() method""); (""drawing thread"", ""exit"", ""while-loop""); (""drawing thread"", ""take"", ""Frame object""); (""takeFrame() method"", ""in"", ""while-loop"")"
Notice that the first instruction is a read of a volatile variable (other.volatileVarC).,
"When other.volatileVarC is read in from main memory, the other.nonVolatileB and other.nonVolatileA are also read in from main memory.","(""other.volatileVarC"", ""is read with"", ""other.nonVolatileB""); (""other.volatileVarC"", ""is read with"", ""other.nonVolatileA"")"
"To illustrate why this guarantee is necessary, let us modify the FrameExchanger class from earlier in this tutorial to have the hasNewFrame variable be declared volatile:","(""FrameExchanger"", ""has"", ""hasNewFrame""); (""FrameExchanger"", ""declared"", ""hasNewFrame""); (""hasNewFrame"", ""be"", ""volatile"")"
"Additionally, every time the drawing thread reads the hasNewFrame variable in the while-loop inside the takeFrame() method, the frame and framesStoredCount will also be refreshed from main memory.","(""drawing thread"", ""reads"", ""hasNewFrame variable""); (""hasNewFrame variable"", ""is refreshed from"", ""main memory""); (""takeFrame() method"", ""contains"", ""while-loop""); (""drawing thread"", ""calls"", ""takeFrame() method""); (""while-loop"", ""refreshes"", ""frame""); (""while-loop"", ""refreshes"", ""framesStoredCount""); (""main memory"", ""stores"", ""frame""); (""main memory"", ""stores"", ""framesStoredCount"")"
"Imagine if the Java VM reordered the instructions inside the storeFrame() method, like this:","(""Java VM"", ""reordered the instructions inside"", ""storeFrame() method""); (""storeFrame() method"", ""is part of"", ""Java VM""); (""Java VM"", ""has method"", ""storeFrame()"")"
"This means, that the drawing thread executing the takeFrame() method may exit the while-loop before the new value is assigned to the frame variable.","(""drawing thread"", ""executing"", ""takeFrame() method""); (""takeFrame() method"", ""is called by"", ""drawing thread""); (""drawing thread"", ""exits"", ""while-loop""); (""while-loop"", ""is part of"", ""drawing thread""); (""frame variable"", ""is assigned"", ""new value""); (""drawing thread"", ""assigns"", ""frame variable"")"
"As you can see, the reordering of the instructions inside storeFrame() method may make the application malfunction.","(""storeFrame"", ""method of"", ""unknown class""); (""storeFrame"", ""has method"", ""storeFrame()""); (""unknown class"", ""has method"", ""storeFrame()""); (""application"", ""may malfunction because of"", ""storeFrame()""); (""storeFrame"", ""is part of"", ""application""); (""storeFrame()"", ""affects"", ""application"")"
"In the case of the storeFrame() method that means that the two first write instructions cannot be reordered to happen after the last write to hasNewFrame, since hasNewFrame is a volatile variable.","(""storeFrame"", ""method of"", ""unknown class""); (""storeFrame"", ""uses"", ""hasNewFrame""); (""hasNewFrame"", ""is a"", ""volatile variable"")"
"This reordering does not break the code in the takeFrame() method, as the frame variable is still written to before the hasNewFrame variable is written to.","(""takeFrame"", ""method of"", ""unknown class""); (""hasNewFrame"", ""variable of"", ""unknown class""); (""frame"", ""variable of"", ""unknown class""); (""takeFrame"", ""uses"", ""frame""); (""takeFrame"", ""uses"", ""hasNewFrame"")"
"Because of the volatile read visibility guarantee, when this.volatileVarA is read from main memory, so are all other variables visible to the thread at that time.","(""main memory"", ""has variable"", ""this.volatileVarA""); (""main memory"", ""has variables"", ""other variables""); (""thread"", ""has visibility"", ""this.volatileVarA""); (""thread"", ""has visibility"", ""other variables"")"
"Thus, this.nonVolatileVarB and this.nonVolatileVarC are also read in from main memory at the same time.","(""this"", ""has field"", ""nonVolatileVarB""); (""this"", ""has field"", ""nonVolatileVarC""); (""main memory"", ""stores"", ""this.nonVolatileVarB""); (""main memory"", ""stores"", ""this.nonVolatileVarC"")"
"With regards to the takeFrame() method, the first read of a volatile variable is the read of the hasNewFrame field inside the while-loop.","(""takeFrame"", ""has"", ""hasNewFrame field""); (""hasNewFrame field"", ""is accessed by"", ""takeFrame""); (""takeFrame"", ""is method of"", ""unknown class""); (""takeFrame"", ""uses"", ""while-loop"")"
Notice the two synchronized blocks inside the set() and get() method.,"(""set()"", ""contains"", ""synchronized blocks""); (""get()"", ""contains"", ""synchronized blocks""); (""set()"", ""has"", ""synchronized blocks""); (""get()"", ""has"", ""synchronized blocks"")"
In the set() method the synchronized block at the end of the method will force all the variables to be synchronized to main memory after being updated.,"(""set() method"", ""has"", ""synchronized block""); (""synchronized block"", ""updates"", ""variables""); (""variables"", ""are synchronized to"", ""main memory"")"
In the get() method the synchronized block is placed at the beginning of the method.,"(""get() method"", ""has"", ""synchronized block"")"
"When the thread calling get() enters the synchronized block, all variables are re-read in from main memory.","(""thread"", ""calls"", ""get()""); (""get()"", ""is called by"", ""thread""); (""get()"", ""enters"", ""synchronized block""); (""synchronized block"", ""contains"", ""variables""); (""variables"", ""are re-read from"", ""main memory"")"
"To illustrate why, I will use the get() method of the ValueExchanger shown earlier:","(""ValueExchanger"", ""has method"", ""get()"")"
"As you can see, the synchronized block at the beginning of the method will guarantee that all of the variables this.valC, this.valB and this.valA are refreshed (read in) from main memory.","(""valC"", ""is variable of"", ""main memory""); (""valB"", ""is variable of"", ""main memory""); (""valA"", ""is variable of"", ""main memory"")"
"To illustrate why, I will use the set() method of the ValueExchanger shown earlier:","(""ValueExchanger"", ""has method"", ""set()"")"
"As you can see, the synchronized block at the end of the method will guarantee that all of the changed variables this.valA, this.valB and this.valC will be written back to (flushed) to main memory when the thread calling set() exits the synchronized blocks.","(""set()"", ""has parameter"", ""this.valA""); (""set()"", ""has parameter"", ""this.valB""); (""set()"", ""has parameter"", ""this.valC""); (""set()"", ""uses"", ""synchronized block""); (""synchronized block"", ""guarantees"", ""main memory""); (""set()"", ""writes to"", ""main memory""); (""thread"", ""calls"", ""set()""); (""set()"", ""exits"", ""synchronized block"")"
"The original Java memory model was insufficient, so the Java memory model was revised in Java 1.5.","(""Java memory model"", ""was revised in"", ""Java 1.5""); (""Java memory model"", ""was insufficient in"", ""Java""); (""Java 1.5"", ""revised"", ""Java memory model""); (""Java"", ""had"", ""Java memory model""); (""Java memory model"", ""was revised"", ""Java 1.5"")"
Static class variables are also stored on the heap along with the class definition.,"(""Static class variables"", ""are stored in"", ""heap""); (""Class definition"", ""is stored in"", ""heap""); (""Static class variables"", ""are stored with"", ""class definition"")"
If two threads were executing the run() method then the diagram shown earlier would be the outcome.,"(""thread"", ""executing"", ""run()""); (""run()"", ""method of"", ""thread""); (""thread"", ""executing"", ""run()"")"
methodOne() declares a primitive local variable (localVariable1 of type int) and an local variable which is an object reference (localVariable2).,"(""methodOne()"", ""declares"", ""localVariable1""); (""methodOne()"", ""declares"", ""localVariable2""); (""localVariable1"", ""isTypeOf"", ""int""); (""localVariable2"", ""isTypeOf"", ""object"")"
Each thread executing methodOne() will create its own copy of localVariable1 and localVariable2 on their respective thread stacks.,"(""thread"", ""executes"", ""methodOne()""); (""methodOne()"", ""uses"", ""localVariable1""); (""methodOne()"", ""uses"", ""localVariable2""); (""thread"", ""has"", ""thread stack""); (""thread stack"", ""stores"", ""localVariable1""); (""thread stack"", ""stores"", ""localVariable2"")"
Each thread executing methodOne() will also create their own copy of localVariable2.,"(""thread"", ""executing"", ""methodOne()""); (""methodOne()"", ""uses"", ""localVariable2""); (""thread"", ""creates"", ""localVariable2"")"
The localVariable1 reference will be stored in one copy per thread executing methodTwo().,"(""localVariable1"", ""stored in"", ""thread""); (""localVariable1"", ""referenced by"", ""methodTwo()""); (""methodTwo()"", ""executed by"", ""thread"")"
The Integer objects created inside methodTwo() correspond to Object 1 and Object 5 in the diagram above.,"(""Integer"", ""created inside"", ""methodTwo()"")"
Notice also the two member variables in the class MySharedObject of type long which is a primitive type.,"(""MySharedObject"", ""has member variables of type"", ""long"")"
That is why Java 5 got a whole set of concurrency utility classes to help developers implement more fine grained concurrency control than what you get with synchronized.,"(""Java 5"", ""has"", ""concurrency utility classes""); (""concurrency utility classes"", ""help"", ""developers""); (""developers"", ""implement"", ""concurrency control""); (""synchronized"", ""provides"", ""concurrency control"")"
Notice the use of the synchronized keyword in the add() method declaration.,"(""synchronized"", ""used in"", ""add()""); (""add()"", ""has keyword"", ""synchronized""); (""synchronized"", ""is keyword in"", ""method declaration""); (""add()"", ""is part of"", ""method declaration""); (""method declaration"", ""includes"", ""synchronized keyword""); (""add()"", ""has declaration"", ""method declaration"")"
Also here the synchronized keyword tells Java that the add() method is synchronized.,"(""Java"", ""has method"", ""add()""); (""add()"", ""is synchronized by"", ""synchronized keyword"")"
Synchronized static methods are synchronized on the class object of the class the synchronized static method belongs to.,"(""Class"", ""has"", ""Synchronized static methods""); (""Class"", ""belongs to"", ""Class object""); (""Synchronized static methods"", ""are synchronized on"", ""Class object""); (""Class object"", ""of"", ""Class"")"
"Since only one class object exists in the Java VM per class, only one thread can execute inside a static synchronized method in the same class.","(""Java VM"", ""has"", ""class""); (""class"", ""has"", ""static synchronized method""); (""static synchronized method"", ""executed by"", ""thread"")"
"In case a class contains more than one static synchronized method, only one thread can execute inside any of these methods at the same time.","(""Class"", ""contains"", ""static synchronized method""); (""Thread"", ""executes"", ""static synchronized method""); (""Class"", ""has"", ""static synchronized method"")"
Only one thread can execute inside any of the two add() and subtract() methods at any given time.,"(""add()"", ""executed by"", ""thread""); (""subtract()"", ""executed by"", ""thread"")"
If Thread A is executing add() then Thread B cannot execute neither add() nor subtract() until Thread A has exited add().,"(""Thread A"", ""is executing"", ""add()""); (""Thread B"", ""cannot execute"", ""add()""); (""Thread B"", ""cannot execute"", ""subtract()""); (""Thread A"", ""has exited"", ""add()"")"
"If the static synchronized methods are located in different classes, then one thread can execute inside the static synchronized methods of each class.","(""Thread"", ""execute"", ""static synchronized methods""); (""static synchronized methods"", ""located in"", ""classes""); (""thread"", ""execute inside"", ""static synchronized methods of each class"")"
One thread per class regardless of which static synchronized method it calls.,"(""thread"", ""calls"", ""method""); (""class"", ""has"", ""method""); (""method"", ""is"", ""synchronized""); (""thread"", ""accesses"", ""class""); (""class"", ""has"", ""static method""); (""method"", ""is"", ""static"")"
These methods are synchronized on the class object of the class the methods belong to:,"(""class"", ""hasMethods"", ""methods""); (""methods"", ""belongTo"", ""class""); (""class"", ""isSynchronizedOn"", ""class object"")"
"Had the second synchronized block been synchronized on a different object than MyClass.class, then one thread could execute inside each method at the same time.","(""MyClass"", ""has method"", ""synchronized block""); (""MyClass.class"", ""is synchronized on"", ""object""); (""Thread"", ""executes"", ""method""); (""synchronized block"", ""belongs to"", ""MyClass""); (""object"", ""is used for"", ""synchronization""); (""MyClass"", ""has"", ""synchronized block""); (""Thread"", ""accesses"", ""MyClass""); (""Method"", ""is part of"", ""MyClass""); (""synchronized block"", ""prevents"", ""concurrent execution"")"
It is even possible to use synchronized blocks inside a Java Lambda Expression as well as inside anonymous classes.,"(""Java"", ""uses"", ""Lambda Expression""); (""Lambda Expression"", ""contains"", ""synchronized blocks""); (""anonymous classes"", ""contains"", ""synchronized blocks""); (""Java"", ""uses"", ""anonymous classes"")"
Notice that the synchronized block is synchronized on the class object of the class containing the lambda expression.,"(""Class"", ""contains"", ""LambdaExpression""); (""LambdaExpression"", ""is synchronized on"", ""Class"")"
"It could have been synchronized on another object too, if that would have made more sense (given a specific use case), but using the class object is fine for this example.",
"Here are the two classes used in the example above, Counter and CounterThread.","(""Counter"", ""used in"", ""example""); (""CounterThread"", ""used in"", ""example""); (""Counter"", ""related to"", ""CounterThread"")"
"The Counter.add() method is synchronized on the instance, because the add method is an instance method, and marked as synchronized.","(""Counter"", ""hasMethod"", ""add()""); (""add()"", ""isSynchronizedOn"", ""instance""); (""Counter"", ""hasInstanceMethod"", ""add()"")"
Therefore only one of the threads can call the add() method at a time.,"(""thread"", ""can call"", ""add() method"")"
"The other thread will wait until the first thread leaves the add() method, before it can execute the method itself.","(""Thread"", ""waits for"", ""Thread""); (""Thread"", ""leaves"", ""add() method""); (""Thread"", ""executes"", ""add() method""); (""add() method"", ""is executed by"", ""Thread"")"
"If the two threads had referenced two separate Counter instances, there would have been no problems calling the add() methods simultaneously.","(""Counter"", ""hasMethod"", ""add()""); (""Thread"", ""references"", ""Counter""); (""Counter"", ""instanceOf"", ""Counter""); (""Counter"", ""hasMethod"", ""add()""); (""Thread"", ""calls"", ""add()"")"
Calling add() on counterA will thus not block a call to add() on counterB.,"(""counterA"", ""hasMethod"", ""add()""); (""counterB"", ""hasMethod"", ""add()""); (""add()"", ""isMethodOf"", ""counterA""); (""add()"", ""isMethodOf"", ""counterB"")"
Without the use of the synchronized keyword (or the Java volatile keyword) there is no guarantee that when one thread changes the value of a variable shared with other threads (e.g.,"(""thread"", ""shares"", ""variable""); (""variable"", ""isChangedBy"", ""thread""); (""Java"", ""uses"", ""synchronized keyword""); (""Java"", ""uses"", ""volatile keyword""); (""synchronized keyword"", ""guarantees"", ""visibility""); (""volatile keyword"", ""guarantees"", ""visibility"")"
"If you call Integer.valueOf(1) multiple times, it might actually return the same wrapper object instance for the same input parameter values.","(""Integer"", ""hasMethod"", ""valueOf()""); (""Integer"", ""returns"", ""wrapper object""); (""wrapper object"", ""isReturnedBy"", ""Integer.valueOf()""); (""Integer.valueOf()"", ""takesParameter"", ""input parameter""); (""Integer.valueOf()"", ""returns"", ""wrapper object instance"")"
"That means, that if you are synchronizing multiple blocks on the same primitive wrapper object (e.g.",
"use Integer.valueOf(1) multiple times as monitor object), then you risk that those synchronized blocks all get synchronized on the same object.","(""Integer"", ""valueOf"", ""1""); (""Integer"", ""risk"", ""synchronized blocks""); (""synchronized blocks"", ""get synchronized on"", ""object"")"
"To be on the safe side, synchronize on this - or on a new Object() .","(""Object"", ""synchronize on"", ""this""); (""Object"", ""created with"", ""new"")"
Java actually comes with a built in ReadWriteLock class you can use.,"(""Java"", ""comes with"", ""ReadWriteLock class""); (""ReadWriteLock class"", ""is used by"", ""Java"")"
Java actually comes with a built-in Java Semaphore class you can use.,"(""Java"", ""comes with"", ""Java Semaphore class""); (""Java Semaphore class"", ""is used in"", ""Java"")"
Just focus on how inside the synchronized block inside the count() method calls the count() method recursively.,"(""count"", ""calls"", ""count""); (""count"", ""inside"", ""synchronized block""); (""synchronized block"", ""contains"", ""count"")"
"Thus, the thread calling count() may eventually enter the same synchronized block multiple times.","(""count"", ""is called by"", ""thread""); (""thread"", ""enters"", ""synchronized block""); (""synchronized block"", ""is entered by"", ""thread"")"
The Java ThreadLocal class enables you to create variables that can only be read and written by the same thread.,"(""Java"", ""has class"", ""ThreadLocal""); (""ThreadLocal"", ""enables"", ""variables""); (""ThreadLocal"", ""creates"", ""variables""); (""variables"", ""can be read by"", ""thread""); (""variables"", ""can be written by"", ""thread""); (""ThreadLocal"", ""is used by"", ""thread"")"
"Thus, the Java ThreadLocal class provides a simple way to make code thread safe that would not otherwise be so.","(""Java"", ""provides"", ""ThreadLocal class""); (""ThreadLocal class"", ""makes"", ""code""); (""code"", ""made thread safe by"", ""ThreadLocal class""); (""ThreadLocal class"", ""used for"", ""thread safety"")"
Once a ThreadLocal has been created you can set the value to be stored in it using its set() method.,"(""ThreadLocal"", ""has method"", ""set()"")"
You read the value stored in a ThreadLocal using its get() method.,"(""ThreadLocal"", ""has method"", ""get()"")"
"Additionally, you do not have to typecast the value returned by get().","(""get()"", ""returns"", ""value"")"
It is possible to set an initial value for a Java ThreadLocal which will get used the first time get() is called - before set() has been called with a new value.,"(""ThreadLocal"", ""has method"", ""get()""); (""ThreadLocal"", ""has method"", ""set()""); (""Java"", ""has class"", ""ThreadLocal""); (""ThreadLocal"", ""uses"", ""initial value""); (""ThreadLocal"", ""calls"", ""get()""); (""ThreadLocal"", ""calls"", ""set()"")"
The first way to specify an initial value for a Java ThreadLocal variable is to create a subclass of ThreadLocal which overrides its initialValue() method.,"(""ThreadLocal"", ""overrides"", ""initialValue()""); (""ThreadLocal"", ""has method"", ""initialValue()""); (""initialValue()"", ""is overridden by"", ""subclass of ThreadLocal"")"
"The easiest way to create a subclass of ThreadLocal is to simply create an anonymous subclass, right where you create the ThreadLocal variable.","(""ThreadLocal"", ""is a superclass of"", ""anonymous subclass""); (""ThreadLocal"", ""has a"", ""variable""); (""anonymous subclass"", ""is a subclass of"", ""ThreadLocal""); (""ThreadLocal"", ""can be created as"", ""anonymous subclass"")"
Here is an example of creating an anonymous subclass of ThreadLocal which overrides the initialValue() method:,"(""ThreadLocal"", ""overrides"", ""initialValue()""); (""ThreadLocal"", ""has method"", ""initialValue()""); (""initialValue()"", ""is overridden by"", ""anonymous subclass""); (""ThreadLocal"", ""has subclass"", ""anonymous subclass""); (""anonymous subclass"", ""overrides"", ""initialValue()"")"
"Only if you return the exact same object from the initialValue() method, will all threads see the same object.","(""initialValue() method"", ""returns"", ""object""); (""object"", ""is seen by"", ""threads""); (""threads"", ""share"", ""object""); (""initialValue() method"", ""is called by"", ""threads"")"
"Here is an example of creating a ThreadLocal using its withInitial() static factory method, passing a simple Supplier implementation as parameter:","(""ThreadLocal"", ""hasMethod"", ""withInitial()""); (""ThreadLocal"", ""uses"", ""Supplier""); (""withInitial()"", ""takesParameter"", ""Supplier""); (""Supplier"", ""isImplemented"", ""implementation""); (""ThreadLocal"", ""creates"", ""ThreadLocal instance"")"
Here is how providing a Supplier implementation as a lambda expression to withInitial() looks:,"(""Supplier"", ""implementation"", ""lambda expression""); (""lambda expression"", ""passed to"", ""withInitial()""); (""withInitial()"", ""method of"", ""unknown entity"")"
Notice how the format() method calls the getThreadLocalSimpleDateFormat() method to obtain a Java SimpleDatFormat instance.,"(""format()"", ""calls"", ""getThreadLocalSimpleDateFormat()""); (""format()"", ""uses"", ""Java SimpleDatFormat""); (""getThreadLocalSimpleDateFormat()"", ""returns"", ""Java SimpleDatFormat"")"
"The SimpleDateFormat class is not thread safe, so multiple threads cannot use it at the same time.","(""SimpleDateFormat"", ""isNotThreadSafeWith"", ""multiple threads""); (""SimpleDateFormat"", ""cannotBeUsedBy"", ""multiple threads""); (""Multiple threads"", ""cannotUse"", ""SimpleDateFormat"")"
"To solve this problem, the MyDateFormatter class above creates a SimpleDateFormat per thread, so each thread calling the format() method will use its own SimpleDateFormat instance.","(""MyDateFormatter"", ""creates"", ""SimpleDateFormat""); (""MyDateFormatter"", ""calls"", ""format()""); (""SimpleDateFormat"", ""has method"", ""format()""); (""Thread"", ""calls"", ""format()""); (""MyDateFormatter"", ""uses"", ""SimpleDateFormat"")"
"Both threads execute the run() method, and thus sets different values on the ThreadLocal instance.","(""Thread"", ""execute"", ""run()""); (""run()"", ""sets"", ""ThreadLocal""); (""ThreadLocal"", ""has"", ""instance""); (""Thread"", ""sets"", ""ThreadLocal"")"
"If the access to the set() call had been synchronized, and it had not been a ThreadLocal object, the second thread would have overridden the value set by the first thread.","(""Thread"", ""calls"", ""set()""); (""set()"", ""is called by"", ""Thread""); (""ThreadLocal"", ""overrides"", ""set()""); (""Thread"", ""accesses"", ""set()"")"
"The udpate() method writes three variables, of which only days is volatile.","(""update()"", ""writes"", ""variables""); (""variables"", ""has"", ""days""); (""days"", ""is"", ""volatile"")"
Notice the totalDays() method starts by reading the value of days into the total variable.,"(""totalDays()"", ""starts by reading"", ""days""); (""totalDays()"", ""reads into"", ""total""); (""totalDays()"", ""is a method of"", ""unknown class"")"
Let us look at the MyClass class from the example earlier in this Java volatile tutorial:,"(""MyClass"", ""is.part.of"", ""Java""); (""MyClass"", ""is.discussed.in"", ""Java volatile tutorial"")"
"Once the update() method writes a value to days, the newly written values to years and months are also written to main memory.","(""update() method"", ""writes to"", ""days""); (""update() method"", ""writes to"", ""years""); (""update() method"", ""writes to"", ""months""); (""years"", ""written to"", ""main memory""); (""months"", ""written to"", ""main memory""); (""days"", ""written to"", ""main memory"")"
As an alternative to a synchronized block you could also use one of the many atomic data types found in the java.util.concurrent package.,"(""java.util.concurrent"", ""contains"", ""atomic data types""); (""atomic data types"", ""found in"", ""java.util.concurrent"")"
"From Java 5 the package java.util.concurrent.locks contains several lock implementations, so you may not have to implement your own locks.","(""Java 5"", ""contains"", ""java.util.concurrent.locks""); (""java.util.concurrent.locks"", ""contains"", ""lock implementations"")"
"The Counter class could have been written like this instead, using a Lock instead of a synchronized block:","(""Counter"", ""could have been written using"", ""Lock""); (""Counter"", ""uses"", ""synchronized block""); (""Lock"", ""used instead of"", ""synchronized block"")"
The lock() method locks the Lock instance so that all threads calling lock() are blocked until unlock() is executed.,"(""Lock"", ""has method"", ""lock()""); (""lock()"", ""is blocked by"", ""lock()""); (""lock()"", ""is unblocked by"", ""unlock()""); (""Lock"", ""has method"", ""unlock()"")"
Spin locks and the methods wait() and notify() are covered in more detail in the text Thread Signaling.,"(""Thread"", ""hasMethod"", ""wait()""); (""Thread"", ""hasMethod"", ""notify()""); (""Thread"", ""isDiscussedIn"", ""Thread Signaling"")"
"While isLocked is true, the thread calling lock() is parked waiting in the wait() call.","(""Thread"", ""calls"", ""lock()""); (""Thread"", ""waits in"", ""wait()""); (""lock()"", ""is called by"", ""Thread""); (""wait()"", ""is used by"", ""Thread""); (""isLocked"", ""is checked by"", ""Thread"")"
"In case the thread should return unexpectedly from the wait() call without having received a notify() call (AKA a Spurious Wakeup) the thread re-checks the isLocked condition to see if it is safe to proceed or not, rather than just assume that being awakened means it is safe to proceed.","(""thread"", ""return from"", ""wait()""); (""thread"", ""receive"", ""notify()""); (""thread"", ""re-check"", ""isLocked condition""); (""isLocked condition"", ""determine"", ""thread safety""); (""thread"", ""proceed"", ""based on isLocked condition"")"
"If isLocked is false, the thread exits the while(isLocked) loop, and sets isLocked back to true, to lock the Lock instance for other threads calling lock().","(""Lock"", ""has method"", ""lock()""); (""Thread"", ""calls"", ""lock()""); (""Lock"", ""has attribute"", ""isLocked""); (""Thread"", ""checks"", ""isLocked""); (""Thread"", ""sets"", ""isLocked"")"
"When the thread is done with the code in the critical section (the code between lock() and unlock()), the thread calls unlock().","(""thread"", ""calls"", ""unlock()""); (""lock()"", ""is called before"", ""unlock()""); (""thread"", ""executes"", ""critical section""); (""critical section"", ""is between"", ""lock()""); (""critical section"", ""is between"", ""unlock()""); (""lock()"", ""is called by"", ""thread"")"
"Executing unlock() sets isLocked back to false, and notifies (awakens) one of the threads waiting in the wait() call in the lock() method, if any.","(""lock"", ""has method"", ""wait()""); (""lock"", ""has method"", ""unlock()""); (""unlock"", ""affects"", ""isLocked""); (""wait"", ""called from"", ""lock""); (""unlock"", ""notifies"", ""threads"")"
"Notice how both outer() and inner() are declared synchronized, which in Java is equivalent to a synchronized(this) block.","(""outer()"", ""isDeclared"", ""synchronized""); (""inner()"", ""isDeclared"", ""synchronized""); (""synchronized"", ""isEquivalentTo"", ""synchronized(this)""); (""Java"", ""hasKeyword"", ""synchronized"")"
"If a thread calls outer() there is no problem calling inner() from inside outer(), since both methods (or blocks) are synchronized on the same monitor object (""this"").","(""outer"", ""calls"", ""inner""); (""outer"", ""synchronized on"", ""this""); (""inner"", ""synchronized on"", ""this"")"
"However, even if synchronized blocks are reentrant, the Lock class shown earlier is not reentrant.","(""Lock"", ""is not"", ""reentrant""); (""Lock"", ""shown in"", ""earlier context""); (""Lock"", ""has type"", ""class""); (""synchronized blocks"", ""are"", ""reentrant""); (""synchronized blocks"", ""use"", ""Lock"")"
"If we rewrite the Reentrant class like below, the thread calling outer() will be blocked inside the lock.lock() in the inner() method.","(""Reentrant"", ""hasMethod"", ""outer()""); (""Reentrant"", ""hasMethod"", ""inner()""); (""outer()"", ""calls"", ""inner()""); (""inner()"", ""uses"", ""lock.lock()""); (""Reentrant"", ""contains"", ""lock"")"
Inside the inner() method the thread will again try to lock the Lock instance.,"(""Lock"", ""instance of"", ""inner()""); (""inner()"", ""method of"", ""Lock"")"
"This will fail (meaning the thread will be blocked), since the Lock instance was locked already in the outer() method.","(""Lock"", ""was locked in"", ""outer()""); (""outer()"", ""is a method of"", ""Lock""); (""Lock"", ""has method"", ""outer()""); (""outer()"", ""is called by"", ""thread""); (""Lock"", ""is used by"", ""thread"")"
"The reason the thread will be blocked the second time it calls lock() without having called unlock() in between, is apparent when we look at the lock() implementation:","(""Thread"", ""calls"", ""lock()""); (""lock()"", ""implementation of"", ""lock()""); (""Thread"", ""calls"", ""unlock()"")"
It is the condition inside the while loop (spin lock) that determines if a thread is allowed to exit the lock() method or not.,"(""thread"", ""allowed to exit"", ""lock() method""); (""while loop"", ""determines"", ""condition""); (""condition"", ""determines"", ""thread""); (""lock() method"", ""exited by"", ""thread"")"
To make the Lock class reentrant we need to make a small change:,"(""Lock"", ""is changed to be"", ""reentrant"")"
"If either the lock is unlocked (isLocked = false) or the calling thread is the thread that locked the Lock instance, the while loop will not execute, and the thread calling lock() will be allowed to exit the method.","(""Lock"", ""hasMethod"", ""lock()""); (""Lock"", ""hasProperty"", ""isLocked""); (""Thread"", ""callsMethod"", ""lock()""); (""Lock"", ""isLockedBy"", ""Thread"")"
"Otherwise, a single call to unlock() will unlock the lock, even if the lock has been locked multiple times.","(""lock"", ""has method"", ""unlock()"")"
"We don't want the lock to be unlocked until the thread that locked it, has executed the same amount of unlock() calls as lock() calls.","(""thread"", ""has method"", ""lock()""); (""thread"", ""has method"", ""unlock()""); (""lock()"", ""is related to"", ""unlock()"")"
"When guarding a critical section with a Lock, and the critical section may throw exceptions, it is important to call the unlock() method from inside a finally-clause.","(""Lock"", ""has method"", ""unlock()""); (""Lock"", ""used for"", ""critical section""); (""critical section"", ""may throw"", ""exceptions""); (""unlock()"", ""called from"", ""finally-clause"")"
"If unlock() was not called from inside a finally-clause, and an exception was thrown from the critical section, the Lock would remain locked forever, causing all threads calling lock() on that Lock instance to halt indefinately.","(""Lock"", ""hasMethod"", ""unlock()""); (""Lock"", ""hasMethod"", ""lock()""); (""Thread"", ""callsMethod"", ""Lock.lock()""); (""Lock"", ""remainsInState"", ""locked"")"
"If you click a button that starts a long task, and the thread executing the task is the thread updating the windows, buttons etc., then the application will appear unresponsive while the task executes.","(""Button"", ""starts"", ""Task""); (""Thread"", ""executes"", ""Task""); (""Thread"", ""updates"", ""Windows""); (""Thread"", ""updates"", ""Buttons""); (""Application"", ""appears"", ""unresponsive""); (""Task"", ""executes"", ""Thread""); (""Button"", ""clicked by"", ""Thread"")"
"Imagine then, that one of the clients sends a request that takes a long time to process - e.g.",
"Notice how the lock() method first synchronizes on ""this"", then synchronizes on the monitorObject member.","(""lock() method"", ""synchronizes on"", ""this""); (""lock() method"", ""synchronizes on"", ""monitorObject"")"
"If isLocked is true however, the thread calling lock() is parked waiting in the monitorObject.wait() call.","(""lock()"", ""is called by"", ""thread""); (""wait()"", ""is called on"", ""monitorObject""); (""isLocked"", ""affects"", ""lock()""); (""monitorObject"", ""has method"", ""wait()""); (""lock()"", ""is method of"", ""thread"")"
"The problem with this is, that the call to monitorObject.wait() only releases the synchronization monitor on the monitorObject member, and not the synchronization monitor associated with ""this"".","(""monitorObject"", ""has method"", ""wait()""); (""monitorObject"", ""releases"", ""synchronization monitor""); (""this"", ""has"", ""synchronization monitor""); (""monitorObject"", ""is member of"", ""this"")"
When the thread that locked the Lock in the first place tries to unlock it by calling unlock() it will be blocked trying to enter the synchronized(this) block in the unlock() method.,"(""Lock"", ""has method"", ""unlock()""); (""unlock()"", ""is called by"", ""thread""); (""unlock()"", ""contains"", ""synchronized(this) block""); (""thread"", ""calls"", ""unlock()""); (""synchronized(this) block"", ""is part of"", ""unlock() method"")"
It will remain blocked until the thread waiting in lock() leaves the synchronized(this) block.,"(""thread"", ""waiting in"", ""lock()""); (""lock()"", ""leaves"", ""synchronized(this) block""); (""thread"", ""leaves"", ""synchronized(this) block"")"
"But the thread waiting in the lock() method will not leave that block until the isLocked is set to false, and a monitorObject.notify() is executed, as it happens in unlock().","(""lock() method"", ""is waiting in"", ""lock() block""); (""isLocked"", ""is set to"", ""false""); (""monitorObject"", ""executes"", ""notify() method""); (""unlock() method"", ""sets"", ""isLocked to false""); (""unlock() method"", ""executes"", ""monitorObject.notify() method""); (""lock() method"", ""waits for"", ""monitorObject.notify() method"")"
"Put shortly, the thread waiting in lock() needs an unlock() call to execute successfully for it to exit lock() and the synchronized blocks inside it.","(""lock()"", ""needs"", ""unlock()""); (""unlock()"", ""called by"", ""lock()""); (""lock()"", ""contains"", ""synchronized blocks""); (""synchronized blocks"", ""inside"", ""lock()"")"
"But, no thread can actually execute unlock() until the thread waiting in lock() leaves the outer synchronized block.","(""thread"", ""execute"", ""unlock()""); (""thread"", ""waiting in"", ""lock()""); (""lock()"", ""leaves"", ""outer synchronized block""); (""thread"", ""waiting in"", ""outer synchronized block"")"
This result is that any thread calling either lock() or unlock() will become blocked indefinately.,"(""thread"", ""calling"", ""lock()""); (""thread"", ""calling"", ""unlock()""); (""lock()"", ""blocks"", ""thread""); (""unlock()"", ""blocks"", ""thread"")"
"That you would not call wait() and notify() on an internal monitor object, but rather on the This is probably true.","(""wait()"", ""called on"", ""internal monitor object""); (""notify()"", ""called on"", ""internal monitor object"")"
"When doing so you want each thread to call wait() on each their own queue object, so that you can notify the threads one at a time.","(""thread"", ""call"", ""wait()""); (""wait()"", ""on"", ""queue""); (""thread"", ""have"", ""queue""); (""notify()"", ""the"", ""threads""); (""threads"", ""one at a time"", ""notify()"")"
"At first glance this implementation may look fine, but notice how the lock() method calls queueObject.wait(); from inside two synchronized blocks.","(""lock"", ""calls"", ""queueObject.wait()""); (""lock"", ""inside"", ""synchronized blocks""); (""queueObject"", ""has method"", ""wait()"")"
"When a thread calls queueObject.wait()it releases the lock on the QueueObject instance, but not the lock associated with ""this"".","(""queueObject"", ""calls"", ""wait()""); (""queueObject"", ""releases"", ""lock""); (""QueueObject instance"", ""has"", ""lock""); (""this"", ""has"", ""lock""); (""queueObject"", ""associated with"", ""this""); (""queueObject"", ""releases"", ""lock associated with this"")"
"Notice too, that the unlock() method is declared synchronized which equals a synchronized(this) block.","(""unlock()"", ""is declared in"", ""synchronized""); (""unlock()"", ""equals"", ""synchronized(this)""); (""synchronized"", ""has block"", ""synchronized(this)"")"
"This means, that if a thread is waiting inside lock() the monitor object associated with ""this"" will be locked by the waiting thread.","(""thread"", ""is waiting inside"", ""lock()""); (""lock()"", ""is associated with"", ""monitor object""); (""monitor object"", ""is locked by"", ""waiting thread"")"
"All threads calling unlock() will remain blocked indefinately, waiting for the waiting thread to release the lock on ""this"".","(""thread"", ""calling"", ""unlock()""); (""unlock()"", ""is called by"", ""thread""); (""thread"", ""waiting for"", ""lock""); (""thread"", ""release"", ""lock""); (""lock"", ""is released by"", ""thread"")"
"But this will never happen, since this only happens if a thread succeeds in sending a signal to the waiting thread, and this can only be sent by executing the unlock() method.","(""thread"", ""succeeds in sending a signal to"", ""waiting thread""); (""waiting thread"", ""receives signal from"", ""thread""); (""thread"", ""executes"", ""unlock() method""); (""unlock() method"", ""is executed by"", ""thread"")"
"For instance, the different implementations of the java.util.concurrent.BlockingQueue interface are all blocking data structures.","(""java.util.concurrent.BlockingQueue"", ""implements"", ""java.util.concurrent""); (""java.util.concurrent.BlockingQueue"", ""is implemented by"", ""blocking data structures"")"
"Other threads will read the value of the volatile from main memory every time, instead of from e.g.",
"Thus, this code may still lead to race conditions if performed by more than one thread: volatile myVar = 0; ... int temp = myVar; temp++; myVar = temp; First the value of the volatile variable myVar is read from main memory into a temp variable.","(""myVar"", ""isReadFrom"", ""main memory""); (""main memory"", ""stores"", ""myVar""); (""temp"", ""stores"", ""value of myVar""); (""myVar"", ""isUpdatedBy"", ""temp""); (""temp"", ""isIncrementedFrom"", ""myVar"")"
"If two threads execute this code and both of them read the value of myVar, add one to it and write the value back to main memory, then you risk that instead of 2 being added to the myVar variable, only 1 will be added (e.g.",
"Here is a single writer counter which does not use synchronization but is still concurrent: public class SingleWriterCounter { private volatile long count = 0; /** * Only one thread may ever call this method, * or it will lead to race conditions.","(""SingleWriterCounter"", ""has method"", ""SingleWriterCounter.method()""); (""SingleWriterCounter"", ""uses"", ""volatile""); (""SingleWriterCounter"", ""has field"", ""count"")"
"I mean, only the same, single thread is ever allowed to call inc().","(""thread"", ""is allowed to call"", ""inc()"")"
"Here is a simple double writer counter class that shows how that could look: public class DoubleWriterCounter { private volatile long countA = 0; private volatile long countB = 0; /** * Only one (and the same from thereon) thread may ever call this method, * or it will lead to race conditions.","(""DoubleWriterCounter"", ""hasMethod"", ""DoubleWriterCounter.countA""); (""DoubleWriterCounter"", ""hasMethod"", ""DoubleWriterCounter.countB"")"
"*/ public void incA() { this.countA++; } /** * Only one (and the same from thereon) thread may ever call this method, * or it will lead to race conditions.",
"*/ public void incB() { this.countB++; } /** * Many reading threads may call this method */ public long countA() { return this.countA; } /** * Many reading threads may call this method */ public long countB() { return this.countB; } } As you can see, the DoubleWriterCounter now contains two volatile variables, and two pairs of incrementation and read methods.","(""DoubleWriterCounter"", ""contains"", ""countA""); (""DoubleWriterCounter"", ""contains"", ""countB""); (""DoubleWriterCounter"", ""has method"", ""incB()""); (""DoubleWriterCounter"", ""has method"", ""countA()""); (""DoubleWriterCounter"", ""has method"", ""countB()"")"
"Only a single thread may ever call incA(), and only a single thread may ever call incB().","(""incA()"", ""called by"", ""single thread""); (""incB()"", ""called by"", ""single thread""); (""single thread"", ""calls"", ""incA()""); (""single thread"", ""calls"", ""incB()"")"
This is how such exclusive access could look using a synchronized block in Java: public class SynchronizedCounter { long count = 0; public void inc() { synchronized(this) { count++; } } public long count() { synchronized(this) { return this.count; } } } Notice how the inc() and count() methods both contain a synchronized block.,"(""SynchronizedCounter"", ""hasMethod"", ""inc()""); (""SynchronizedCounter"", ""hasMethod"", ""count()""); (""inc()"", ""uses"", ""synchronized""); (""count()"", ""uses"", ""synchronized""); (""SynchronizedCounter"", ""contains"", ""count"")"
This is what we want to avoid - synchronized blocks and wait() - notify() calls etc.,"(""synchronized"", ""uses"", ""blocks""); (""blocks"", ""uses"", ""wait()""); (""wait()"", ""relates to"", ""notify()""); (""notify()"", ""relates to"", ""wait()""); (""synchronized"", ""avoids"", ""blocks""); (""synchronized"", ""avoids"", ""wait()""); (""synchronized"", ""avoids"", ""notify()"")"
What is interesting about this version is the implementation of the inc() method.,"(""inc()"", ""is part of"", ""unknown class"")"
"Instead it contains these lines: boolean updated = false; while(!updated){ long prevCount = this.count.get(); updated = this.count.compareAndSet(prevCount, prevCount + 1); } These lines are not an atomic operation.","(""count"", ""get"", ""prevCount""); (""count"", ""compareAndSet"", ""updated""); (""updated"", ""set"", ""true""); (""updated"", ""set"", ""false"")"
"That means, that it is possible for two different threads to call the inc() method and execute the long prevCount = this.count.get() statement, and thus both obtain the previous count for the counter.","(""thread"", ""call"", ""inc()""); (""inc()"", ""execute"", ""prevCount = this.count.get()""); (""count"", ""get"", ""prevCount""); (""threads"", ""obtain"", ""prevCount""); (""inc()"", ""obtain"", ""prevCount"")"
The compareAndSet() method is typically supported by compare-and-swap instructions directly in the CPU.,"(""compareAndSet()"", ""is supported by"", ""compare-and-swap instructions""); (""compareAndSet()"", ""is typically supported by"", ""CPU""); (""CPU"", ""supports"", ""compare-and-swap instructions""); (""compare-and-swap instructions"", ""are used by"", ""compareAndSet()"")"
"Since compareAndSet() is an atomic operation, the threads will execute this method sequentially (one at a time).","(""compareAndSet()"", ""is a method of"", ""unknown class""); (""Unknown class"", ""has method"", ""compareAndSet()""); (""compareAndSet()"", ""executed by"", ""threads""); (""threads"", ""execute"", ""compareAndSet()""); (""threads"", ""execute"", ""compareAndSet() sequentially"")"
"If no other thread has called inc() in the meantime, the second iteration will succeed in updating the AtomicLong to 22.","(""AtomicLong"", ""hasMethod"", ""inc()""); (""Thread"", ""calls"", ""inc()""); (""AtomicLong"", ""updatedBy"", ""inc()""); (""Thread"", ""performs"", ""iteration""); (""inc()"", ""updates"", ""AtomicLong"")"
Instead Java provides the AtomicStampedReference class which can swap a reference and a stamp atomically using a compare-and-swap operation.,"(""Java"", ""provides"", ""AtomicStampedReference""); (""AtomicStampedReference"", ""uses"", ""compare-and-swap operation"")"
"import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicStampedReference; public class NonblockingTemplate { public static class IntendedModification { public AtomicBoolean completed = new AtomicBoolean(false); } private AtomicStampedReference<IntendedModification> ongoingMod = new AtomicStampedReference<IntendedModification>(null, 0); //declare the state of the data structure here.","(""NonblockingTemplate"", ""contains"", ""IntendedModification""); (""NonblockingTemplate"", ""uses"", ""AtomicStampedReference""); (""IntendedModification"", ""uses"", ""AtomicBoolean""); (""AtomicStampedReference"", ""isTypeOf"", ""IntendedModification""); (""java.util.concurrent.atomic"", ""contains"", ""AtomicBoolean""); (""java.util.concurrent.atomic"", ""contains"", ""AtomicStampedReference""); (""NonblockingTemplate"", ""imports"", ""java.util.concurrent.atomic"")"
"public void modify() { while(!attemptModifyASR()); } public boolean attemptModifyASR(){ boolean modified = false; IntendedModification currentlyOngoingMod = ongoingMod.getReference(); int stamp = ongoingMod.getStamp(); if(currentlyOngoingMod == null){ //copy data structure state - for use //in intended modification //prepare intended modification IntendedModification newMod = new IntendedModification(); boolean modSubmitted = ongoingMod.compareAndSet(null, newMod, stamp, stamp + 1); if(modSubmitted){ //complete modification via a series of compare-and-swap operations.",
"Multiple threads can access the same instance of this counter, as long as only one thread calls inc().","(""counter"", ""has method"", ""inc()""); (""thread"", ""accesses"", ""counter""); (""counter"", ""is accessed by"", ""thread""); (""thread"", ""calls"", ""inc()""); (""counter"", ""is instance of"", ""class""); (""class"", ""has method"", ""inc()"")"
Here is a simple double writer counter class that shows how that could look:,"(""DoubleWriterCounter"", ""hasMethod"", ""DoubleWriterCounter.constructor()""); (""DoubleWriterCounter"", ""isTypeOf"", ""Class"")"
Notice how the inc() and count() methods both contain a synchronized block.,
Here is how the same counter class could look using an AtomicLong instead:,"(""AtomicLong"", ""used by"", ""CounterClass""); (""CounterClass"", ""uses"", ""AtomicLong"")"
"The check-then-act pattern means, that two or more threads check a given condition, for instance if a Map contains a given value, and then go on to act based on that information, e.g.","(""Map"", ""contains"", ""value"")"
"Imagine if two threads, A and B, are executing the add method on the same instance of the Counter class.","(""Counter"", ""has method"", ""add""); (""Thread A"", ""executes"", ""Counter.add""); (""Thread B"", ""executes"", ""Counter.add""); (""Counter"", ""is instance of"", ""Counter class"")"
The code in the add() method is not executed as a single atomic instruction by the Java virtual machine.,"(""Java virtual machine"", ""executes"", ""add()""); (""add()"", ""is part of"", ""Java virtual machine""); (""Java virtual machine"", ""does not execute as atomic instruction"", ""add()"")"
"Instead of 5, the value left in this.count will be the value written by the last thread to write its value.",
The code in the add() method in the example earlier contains a critical section.,"(""add()"", ""located in"", ""example"")"
"If two or more threads call the checkThenAct() method on the same CheckThenActExample object, then two or more threads may execute the if-statement at the same time, evaluate sharedMap.containsKey(""key"") to true, and thus move into the body code block of the if-statement.","(""CheckThenActExample"", ""has method"", ""checkThenAct()""); (""checkThenAct()"", ""is called by"", ""threads""); (""sharedMap"", ""has method"", ""containsKey()""); (""checkThenAct()"", ""uses"", ""sharedMap""); (""CheckThenActExample"", ""is accessed by"", ""threads"")"
Thread synchronization can also be achieved using other synchronization constructs like locks or atomic variables like java.util.concurrent.atomic.AtomicInteger.,"(""Thread"", ""uses"", ""java.util.concurrent.atomic.AtomicInteger""); (""Thread"", ""uses"", ""locks""); (""java.util.concurrent.atomic.AtomicInteger"", ""is type of"", ""atomic variables"")"
Notice how the add() method adds values to two different sum member variables.,"(""add()"", ""adds to"", ""sum"")"
Now two threads can execute the add() method at the same time.,"(""Thread"", ""execute"", ""add()""); (""add()"", ""executed by"", ""Thread"")"
This way threads will have to wait less for each other to execute the add() method.,"(""thread"", ""execute"", ""add() method""); (""threads"", ""wait for"", ""each other""); (""threads"", ""execute"", ""add() method"")"
Java 5 comes with read / write lock implementations in the java.util.concurrent package.,"(""Java 5"", ""comes with"", ""read / write lock implementations""); (""read / write lock implementations"", ""are in"", ""java.util.concurrent package""); (""Java 5"", ""includes"", ""java.util.concurrent package"")"
The rules for read access are implemented in the lockRead() method.,"(""lockRead()"", ""implemented in"", ""read access rules"")"
The rules for write access are implemented in the lockWrite() method.,"(""lockWrite()"", ""is implemented in"", ""rules for write access"")"
It is worth noting that both unlockRead() and unlockWrite() calls notifyAll() rather than notify().,"(""unlockRead()"", ""calls"", ""notifyAll()""); (""unlockWrite()"", ""calls"", ""notifyAll()""); (""notifyAll()"", ""is called by"", ""unlockRead()""); (""notifyAll()"", ""is called by"", ""unlockWrite()"")"
"If a thread awakened by notify() was a read access thread, it would be put back to waiting because there are threads waiting for write access.","(""thread"", ""awakened by"", ""notify()""); (""notify()"", ""puts"", ""thread""); (""thread"", ""waiting for"", ""write access""); (""read access thread"", ""put back to"", ""waiting"")"
By calling noftifyAll() all waiting threads are awakened and check if they can get the desired access.,"(""Thread"", ""calls"", ""notifyAll()""); (""notifyAll()"", ""awakens"", ""Thread""); (""Thread"", ""waits for"", ""access"")"
"If multiple threads are waiting for read access and none for write access, and unlockWrite() is called, all threads waiting for read access are granted read access at once - not one by one.","(""Thread"", ""waitsFor"", ""readAccess""); (""Thread"", ""waitsFor"", ""writeAccess""); (""unlockWrite()"", ""isCalled"", ""none""); (""Thread"", ""isGranted"", ""readAccess"")"
Here is how the lockRead() and unlockRead() methods looks after that change:,"(""lockRead()"", ""is method of"", ""unnamed class""); (""unlockRead()"", ""is method of"", ""unnamed class""); (""lockRead()"", ""has counterpart"", ""unlockRead()"")"
Here is how the lockWrite() and unlockWrite() methods look after that change:,"(""lockWrite()"", ""isMethodOf"", ""unknown""); (""unlockWrite()"", ""isMethodOf"", ""unknown"")"
To achieve this the writeLock() method should be changed a bit.,"(""writeLock"", ""method of"", ""unknown class"")"
Here is how the canGrantReadAccess() method will look with that change:,"(""canGrantReadAccess()"", ""method of"", ""unknown class"")"
"When guarding a critical section with a ReadWriteLock, and the critical section may throw exceptions, it is important to call the readUnlock() and writeUnlock() methods from inside a finally-clause.","(""ReadWriteLock"", ""has method"", ""readUnlock()""); (""ReadWriteLock"", ""has method"", ""writeUnlock()""); (""finally-clause"", ""calls"", ""readUnlock()""); (""finally-clause"", ""calls"", ""writeUnlock()"")"
"If unlockWrite() was not called from inside a finally-clause, and an exception was thrown from the critical section, the ReadWriteLock would remain write locked forever, causing all threads calling lockRead() or lockWrite() on that ReadWriteLock instance to halt indefinately.","(""ReadWriteLock"", ""has method"", ""unlockWrite()""); (""ReadWriteLock"", ""has method"", ""lockRead()""); (""ReadWriteLock"", ""has method"", ""lockWrite()"")"
"The only thing that could unlock the ReadWriteLockagain would be if the ReadWriteLock is reentrant, and the thread that had it locked when the exception was thrown, later succeeds in locking it, executing the critical section and calling unlockWrite() again afterwards.","(""ReadWriteLock"", ""is"", ""reentrant""); (""ReadWriteLock"", ""has method"", ""lock""); (""ReadWriteLock"", ""has method"", ""unlockWrite""); (""thread"", ""locks"", ""ReadWriteLock""); (""thread"", ""executes"", ""critical section""); (""thread"", ""calls"", ""unlockWrite()"")"
Calling unlockWrite() from a finally-clause is a much more robust solution.,"(""unlockWrite()"", ""called from"", ""finally-clause"")"
"If a thread calls lock() twice without calling unlock() in between, the second call to lock() will block.","(""thread"", ""calls"", ""lock()""); (""lock()"", ""is called by"", ""thread""); (""lock()"", ""blocks"", ""thread""); (""thread"", ""calls"", ""lock() twice""); (""lock()"", ""requires"", ""unlock()""); (""unlock()"", ""is called by"", ""thread""); (""thread"", ""calls"", ""unlock()"")"
Java 5 comes with semaphore implementations in the java.util.concurrent package so you don't have to implement your own semaphores.,"(""Java 5"", ""comes with"", ""java.util.concurrent""); (""java.util.concurrent"", ""contains"", ""semaphore implementations"")"
"You can read more about it in the java.util.concurrent.Semaphore text, in my java.util.concurrent tutorial.","(""java.util.concurrent.Semaphore"", ""mentionedIn"", ""java.util.concurrent tutorial""); (""java.util.concurrent"", ""contains"", ""java.util.concurrent.Semaphore""); (""java.util.concurrent"", ""mentionedIn"", ""java.util.concurrent tutorial"")"
The take() method sends a signal which is stored internally in the Semaphore.,"(""Semaphore"", ""has method"", ""take()""); (""Semaphore"", ""stores"", ""signal""); (""take()"", ""sends"", ""signal"")"
"When received the signal flag is cleared again, and the release() method exited.","(""signal flag"", ""is cleared by"", ""release()""); (""release()"", ""exits"", ""signal flag""); (""release()"", ""clears"", ""signal flag"")"
You will call take() instead of notify() and release() instead of wait().,"(""take()"", ""replaces"", ""notify()""); (""release()"", ""replaces"", ""wait()"")"
"If the call to take() happens before the call to release() the thread calling release() will still know that take() was called, because the signal is stored internally in the signal variable.","(""Thread"", ""calls"", ""take()""); (""Thread"", ""calls"", ""release()""); (""take()"", ""happens before"", ""release()""); (""release()"", ""knows"", ""take()""); (""signal"", ""is stored in"", ""signal variable""); (""Thread"", ""uses"", ""signal variable""); (""take()"", ""sets"", ""signal variable""); (""release()"", ""checks"", ""signal variable"")"
The names take() and release() may seem a bit odd when using a semaphore for signaling.,"(""Semaphore"", ""hasMethod"", ""take()""); (""Semaphore"", ""hasMethod"", ""release()"")"
The Semaphore implementation in the previous section does not count the number of signals sent to it by take() method calls.,"(""Semaphore"", ""has method"", ""take()"")"
Notice how the take() method now blocks if the number of signals is equal to the upper bound.,"(""take"", ""method of"", ""unknown class""); (""unknown class"", ""has method"", ""take""); (""signals"", ""has relationship with"", ""upper bound""); (""upper bound"", ""has relationship with"", ""signals""); (""upper bound"", ""is related to"", ""take""); (""take"", ""is blocked by"", ""signals""); (""signals"", ""blocks"", ""take"")"
"Not until a thread has called release() will the thread calling take() be allowed to deliver its signal, if the BoundedSemaphore has reached its upper signal limit.","(""BoundedSemaphore"", ""has method"", ""release()""); (""BoundedSemaphore"", ""has method"", ""take()""); (""thread"", ""calls"", ""release()""); (""thread"", ""calls"", ""take()""); (""BoundedSemaphore"", ""has property"", ""upper signal limit"")"
"To do so, set the upper bound to 1, and have the call to take() and release() guard the critical section.",
In contrast to the signaling use case the methods take() and release() are now called by the same thread.,"(""signaling use case"", ""has methods"", ""take()""); (""signaling use case"", ""has methods"", ""release()""); (""same thread"", ""calls"", ""take()""); (""same thread"", ""calls"", ""release()"")"
"Since only one thread is allowed to take the semaphore, all other threads calling take() will be blocked until release() is called.","(""Semaphore"", ""hasMethod"", ""take()""); (""Semaphore"", ""hasMethod"", ""release()""); (""Thread"", ""callsMethod"", ""take()""); (""Thread"", ""callsMethod"", ""release()""); (""take()"", ""blocks"", ""Thread""); (""release()"", ""unblocks"", ""Thread"")"
The call to release() will never block since there has always been a call to take() first.,"(""release()"", ""called after"", ""take()""); (""release()"", ""never blocks because of"", ""take()""); (""take()"", ""always called before"", ""release()"")"
The relase() method is called from inside a finally-block to make sure it is called even if an exception is thrown from the critical section.,"(""relase()"", ""is called from"", ""finally-block"")"
In a classic multi-threaded architecture you will typically assign each task to a separate thread for execution.,
A classic multi-threaded architecture can also sometimes lead to congestion when multiple threads try to access the same data structure at the same time.,"(""Thread"", ""accesses"", ""DataStructure""); (""DataStructure"", ""isAccessed by"", ""Thread""); (""Architecture"", ""leads to"", ""Congestion"")"
The alternative to a classic multithreaded architecture is a single-threaded or same-threaded.,
"This kind of thread loop is both used in server applications (web services, services etc.)","(""thread"", ""used in"", ""server applications""); (""server applications"", ""includes"", ""web services""); (""server applications"", ""includes"", ""services"")"
"For instance, the task executor could keep the tasks in different lists internally, and e.g.",
"If a one-off task is waiting for some asynchronous operation to finish, e.g.",
"Imagine that isLocked is false, and two threads call lock() at the same time.","(""lock()"", ""is called by"", ""threads""); (""threads"", ""call"", ""lock()""); (""isLocked"", ""has value"", ""false"")"
"Notice how the synchronized(queueObject) with its queueObject.wait() call is nested inside the synchronized(this) block, resulting in the nested monitor lockout problem.","(""queueObject"", ""has method"", ""wait()""); (""this"", ""has method"", ""synchronized()""); (""queueObject"", ""used in"", ""synchronized()""); (""this"", ""used in"", ""synchronized()"")"
"Note: Only the lock() method is shown, since it is the only method I have changed.","(""lock"", ""method of"", ""unknown class"")"
The first synchronized(this) block checks the condition by setting mustWait = isLocked || waitingThreads.get(0) != queueObject.,"(""synchronized"", ""uses"", ""this""); (""waitingThreads"", ""gets"", ""queueObject""); (""this"", ""is checked by"", ""mustWait""); (""isLocked"", ""is checked by"", ""mustWait""); (""mustWait"", ""is set by"", ""isLocked""); (""mustWait"", ""is set by"", ""waitingThreads"")"
Imagine what will happen if two threads call lock() at the same time when the lock is unlocked.,"(""Thread"", ""calls"", ""lock()""); (""lock()"", ""is in state"", ""unlocked""); (""Thread"", ""competes with"", ""Thread""); (""Thread"", ""calls"", ""lock()"")"
Imagine that the FairLock instance is locked when a thread calls lock().,"(""FairLock"", ""is locked by"", ""thread""); (""FairLock"", ""has method"", ""lock()""); (""thread"", ""calls"", ""lock()"")"
"Then imagine that the thread calling lock() is preempted, and the thread that locked the lock calls unlock().","(""thread"", ""calls"", ""lock()""); (""lock"", ""is called by"", ""thread""); (""thread"", ""is preempted by"", ""thread that locked the lock""); (""thread that locked the lock"", ""calls"", ""unlock()""); (""lock"", ""is unlocked by"", ""thread that locked the lock""); (""thread"", ""calls"", ""lock()""); (""thread that locked the lock"", ""locked"", ""lock"")"
"If you look at the unlock() implementation shown earlier, you will notice that it calls queueObject.notify().","(""unlock()"", ""calls"", ""queueObject.notify()""); (""unlock()"", ""implementation in"", ""queueObject""); (""queueObject"", ""has method"", ""notify()"")"
"But, since the thread waiting in lock() has not yet called queueObject.wait(), the call to queueObject.notify() passes into oblivion.","(""queueObject"", ""wait"", ""thread""); (""queueObject"", ""notify"", ""lock""); (""lock"", ""has"", ""thread""); (""thread"", ""called"", ""queueObject.wait""); (""queueObject.notify"", ""passes"", ""oblivion"")"
"When the thread calling lock() right after calls queueObject.wait() it will remain blocked until some other thread calls unlock(), which may never happen.","(""Thread"", ""calls"", ""lock()""); (""Thread"", ""calls"", ""queueObject.wait()""); (""queueObject"", ""wait"", ""Thread""); (""Thread"", ""calls"", ""unlock()""); (""unlock()"", ""called by"", ""Thread""); (""lock()"", ""related to"", ""queueObject.wait()""); (""unlock()"", ""related to"", ""lock()""); (""Thread"", ""blocked by"", ""lock()""); (""lock()"", ""released by"", ""unlock()"")"
The missed signals problems is the reason that the FairLock implementation shown in the text Starvation and Fairness has turned the QueueObject class into a semaphore with two methods: doWait() and doNotify().,"(""QueueObject"", ""hasMethod"", ""doWait()""); (""QueueObject"", ""hasMethod"", ""doNotify()""); (""QueueObject"", ""isTypeOf"", ""Semaphore"")"
"That way the signal is not missed, even if doNotify() is called before doWait().","(""doNotify"", ""is called before"", ""doWait"")"
The notify() method makes no guarantee about what thread is awakened if multiple thread have called wait() on the object notify() is called on.,"(""notify()"", ""is a method of"", ""object""); (""wait()"", ""is a method of"", ""object""); (""object"", ""has method"", ""notify()""); (""object"", ""has method"", ""wait()"")"
"If more than one thread call the doSynchronized() method, some of them will be blocked until the first thread granted access has left the method.","(""thread"", ""call"", ""doSynchronized() method""); (""thread"", ""granted access"", ""doSynchronized() method""); (""doSynchronized() method"", ""block"", ""thread""); (""doSynchronized() method"", ""leave"", ""thread""); (""thread"", ""leave"", ""doSynchronized() method"")"
Instead the critical section is guarded by the lock.lock() and lock.unlock() calls.,"(""lock"", ""has method"", ""lock.lock()""); (""lock"", ""has method"", ""lock.unlock()"")"
A simple implementation of the Lock class could look like this:,"(""Lock"", ""has implementation"", ""simple implementation"")"
"If you look at the Synchronizer class above and look into this Lock implementation you will notice that threads are now blocked trying to access the lock() method, if more than one thread calls lock() simultanously.","(""Synchronizer"", ""hasMethod"", ""lock()""); (""Lock"", ""hasMethod"", ""lock()""); (""Thread"", ""callsMethod"", ""lock()""); (""Synchronizer"", ""uses"", ""Lock""); (""Lock"", ""blocks"", ""Thread"")"
"Second, if the lock is locked, the threads are blocked in the wait() call inside the while(isLocked) loop in the lock() method.","(""lock"", ""has method"", ""wait()""); (""lock"", ""has method"", ""lock()""); (""threads"", ""call"", ""wait()""); (""threads"", ""are blocked in"", ""lock()""); (""lock"", ""has loop"", ""while(isLocked)""); (""while(isLocked)"", ""is in"", ""lock()""); (""lock"", ""is checked by"", ""while(isLocked)"")"
"Remember that a thread calling wait() releases the synchronization lock on the Lock instance, so threads waiting to enter lock() can now do so.","(""Lock"", ""releases"", ""synchronization lock""); (""Lock"", ""has method"", ""wait()""); (""Lock"", ""has method"", ""lock()""); (""thread"", ""calls"", ""wait()""); (""thread"", ""waits to enter"", ""lock()"")"
The result is that multiple threads can end up having called wait() inside lock().,"(""Thread"", ""call"", ""wait()""); (""Thread"", ""have"", ""lock()""); (""wait()"", ""inside"", ""lock()"")"
"If you look back at the doSynchronized() method you will notice that the comment between lock() and unlock() states, that the code in between these two calls take a ""long"" time to execute.","(""doSynchronized"", ""hasMethod"", ""lock""); (""doSynchronized"", ""hasMethod"", ""unlock"")"
Let us further assume that this code takes long time to execute compared to entering the lock() method and calling wait() because the lock is locked.,"(""lock"", ""method of"", ""object""); (""wait"", ""method of"", ""object""); (""lock"", ""has method"", ""wait"")"
"This means that the majority of the time waited to be able to lock the lock and enter the critical section is spent waiting in the wait() call inside the lock() method, not being blocked trying to enter the lock() method.","(""lock"", ""has method"", ""wait()""); (""lock"", ""has method"", ""lock()""); (""lock()"", ""calls"", ""wait()"")"
Nor does wait() make any guarantees about what thread is awakened when notify() is called.,"(""wait()"", ""called by"", ""notify()""); (""wait()"", ""makes guarantees about"", ""thread""); (""notify()"", ""awakens"", ""thread""); (""wait()"", ""does not guarantee"", ""thread"")"
"So, the current version of the Lock class makes no different guarantees with respect to fairness than synchronized version of doSynchronized().","(""Lock"", ""makes no different guarantees with respect to fairness than"", ""doSynchronized()""); (""Lock"", ""has a version"", ""doSynchronized()""); (""doSynchronized()"", ""is synchronized by"", ""Lock"")"
The current version of the Lock class calls its own wait() method.,"(""Lock"", ""calls"", ""wait()""); (""Lock"", ""has method"", ""wait()"")"
"If instead each thread calls wait() on a separate object, so that only one thread has called wait() on each object, the Lock class can decide which of these objects to call notify() on, thereby effectively selecting exactly what thread to awaken.","(""Lock"", ""calls"", ""wait()""); (""Lock"", ""calls"", ""notify()""); (""Thread"", ""calls"", ""wait()""); (""Lock"", ""decides on"", ""objects""); (""Thread"", ""has called"", ""wait()""); (""Lock"", ""calls notify() on"", ""objects""); (""Lock"", ""selects"", ""thread""); (""Lock"", ""awakens"", ""thread"")"
Below is shown the previous Lock class turned into a fair lock called FairLock.,"(""Lock"", ""turned into"", ""FairLock""); (""Lock"", ""is a"", ""FairLock""); (""FairLock"", ""is a type of"", ""Lock"")"
You will notice that the implementation has changed a bit with respect to synchronization and wait() / notify() compared to the Lock class shown earlier.,"(""Lock"", ""compared to"", ""implementation""); (""implementation"", ""has changed"", ""synchronization""); (""synchronization"", ""uses"", ""wait()""); (""synchronization"", ""uses"", ""notify()""); (""Lock"", ""uses"", ""wait()""); (""Lock"", ""uses"", ""notify()"")"
"Exactly how I arrived at this design beginning from the previous Lock class is a longer story involving several incremental design steps, each fixing the problem of the previous step: Nested Monitor Lockout, Slipped Conditions, and Missed Signals.","(""Lock"", ""has problem"", ""Nested Monitor Lockout""); (""Lock"", ""has problem"", ""Slipped Conditions""); (""Lock"", ""has problem"", ""Missed Signals"")"
"What is important is, that every thread calling lock() is now queued, and only the first thread in the queue is allowed to lock the FairLock instance, if it is unlocked.","(""FairLock"", ""has method"", ""lock()""); (""Thread"", ""calls"", ""FairLock.lock()""); (""Thread"", ""is queued by"", ""FairLock""); (""FairLock"", ""allows"", ""Thread""); (""Thread"", ""waits in"", ""queue""); (""Queue"", ""contains"", ""Thread""); (""FairLock"", ""has state"", ""unlocked""); (""FairLock"", ""has state"", ""locked""); (""Thread"", ""acquires"", ""FairLock""); (""FairLock"", ""is acquired by"", ""Thread"")"
First you might notice that the lock() method is no longer declared synchronized.,"(""lock()"", ""is_method_of"", ""no_entity""); (""lock()"", ""no_longer_declared"", ""synchronized"")"
FairLock creates a new instance of QueueObject and enqueue it for each thread calling lock().,"(""FairLock"", ""creates"", ""QueueObject""); (""FairLock"", ""calls"", ""lock()""); (""QueueObject"", ""isEnqueuedBy"", ""FairLock""); (""FairLock"", ""enqueues"", ""QueueObject"")"
"The thread calling unlock() will take the top QueueObject in the queue and call doNotify() on it, to awaken the thread waiting on that object.","(""QueueObject"", ""hasMethod"", ""unlock()""); (""QueueObject"", ""hasMethod"", ""doNotify()""); (""Thread"", ""calls"", ""unlock()""); (""Thread"", ""calls"", ""doNotify()""); (""QueueObject"", ""isAwaited by"", ""Thread"")"
The doWait() and doNotify() methods store the signal internally in the QueueObject.,"(""QueueObject"", ""has method"", ""doWait()""); (""QueueObject"", ""has method"", ""doNotify()""); (""doWait()"", ""stores signal in"", ""QueueObject""); (""doNotify()"", ""stores signal in"", ""QueueObject"")"
"This is done to avoid missed signals caused by a thread being preempted just before calling queueObject.doWait(), by another thread which calls unlock() and thereby queueObject.doNotify().","(""queueObject"", ""doWait"", ""thread""); (""another thread"", ""calls"", ""unlock()""); (""queueObject"", ""doNotify"", ""thread""); (""queueObject"", ""doWait"", ""another thread"")"
"The queueObject.doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout, so another thread can actually call unlock() when no thread is executing inside the synchronized(this) block in lock() method.","(""queueObject"", ""hasMethod"", ""doWait()""); (""queueObject"", ""hasMethod"", ""unlock()""); (""this"", ""hasMethod"", ""lock()""); (""lock()"", ""contains"", ""synchronized(this) block""); (""doWait()"", ""calledOutside"", ""synchronized(this) block""); (""synchronized(this) block"", ""contains"", ""lock() method"")"
"Finally, notice how the queueObject.doWait() is called inside a try - catch block.","(""queueObject"", ""hasMethod"", ""doWait()""); (""queueObject.doWait()"", ""calledIn"", ""try-catch block"")"
"In case an InterruptedException is thrown the thread leaves the lock() method, and we need to dequeue it.","(""InterruptedException"", ""is thrown by"", ""lock() method""); (""lock() method"", ""leaves"", ""thread""); (""thread"", ""is dequeued from"", ""lock() method"")"
If you compare the Lock and FairLock classes you will notice that there is somewhat more going on inside the lock() and unlock() in the FairLock class.,"(""Lock"", ""hasMethod"", ""lock()""); (""Lock"", ""hasMethod"", ""unlock()""); (""FairLock"", ""hasMethod"", ""lock()""); (""FairLock"", ""hasMethod"", ""unlock()""); (""Lock"", ""comparedTo"", ""FairLock"")"
Threads waiting on an object (called wait() on it) remain waiting indefinitely,"(""Threads"", ""wait() on"", ""object""); (""object"", ""called wait() by"", ""Threads""); (""Threads"", ""remain waiting on"", ""object"")"
"In a desktop app the foreground thread (UI thread) could be responding to the user events - a.g. opening a file, or downloading a file, or saving a file etc.",
"Each thread consumes a certain amount of computer resources, such as memory (RAM), so if you have too many threads active at the same time, the total amount of resources (e.g.",
RAM) that is consumed may cause the computer to slow down - e.g.,
"Java comes with built in thread pools in the java.util.concurrent package, so you don't have to implement your own thread pool.","(""java.util.concurrent"", ""contains"", ""thread pools""); (""java.util.concurrent"", ""is part of"", ""Java""); (""Java"", ""has"", ""thread pools"")"
You can read more about it in my text on the java.util.concurrent.ExecutorService.,"(""java.util.concurrent"", ""contains"", ""ExecutorService"")"
"Below here is the PoolThreadRunnable class which implements the Runnable interface, so it can be executed by a Java thread:","(""PoolThreadRunnable"", ""implements"", ""Runnable""); (""PoolThreadRunnable"", ""executed by"", ""Java thread"")"
"A ThreadPool class which is the public interface to the thread pool, and a PoolThread class which implements the threads that execute the tasks.","(""ThreadPool"", ""implements"", ""thread pool""); (""PoolThread"", ""executes"", ""tasks""); (""ThreadPool"", ""has"", ""PoolThread"")"
To execute a task the method ThreadPool.execute(Runnable r) is called with a Runnable implementation as parameter.,"(""ThreadPool"", ""execute"", ""Runnable""); (""ThreadPool"", ""has method"", ""execute""); (""Runnable"", ""is parameter of"", ""ThreadPool.execute"")"
Then each thread in the pool is stopped by calling doStop() on each thread.,"(""Thread"", ""has method"", ""doStop()"")"
Notice how the execute() method will throw an IllegalStateException if execute() is called after stop() has been called.,"(""execute()"", ""throws"", ""IllegalStateException""); (""stop()"", ""called before"", ""execute()""); (""execute()"", ""called after"", ""stop()"")"
"This makes sure that a thread blocked in a wait() call inside the taskQueue.dequeue() call breaks out of the wait() call, and leaves the dequeue() method call with an InterruptedException thrown.","(""thread"", ""blocked in"", ""wait() call""); (""wait() call"", ""inside"", ""taskQueue.dequeue() call""); (""taskQueue"", ""has method"", ""dequeue()""); (""dequeue() method"", ""throws"", ""InterruptedException""); (""InterruptedException"", ""thrown by"", ""wait() call""); (""thread"", ""leaves"", ""dequeue() method call""); (""dequeue() method call"", ""with"", ""InterruptedException"")"
"This exception is caught in the PoolThread.run() method, reported, and then the isStopped variable is checked.","(""PoolThread"", ""has method"", ""run()""); (""PoolThread.run()"", ""checks"", ""isStopped""); (""isStopped"", ""is variable of"", ""PoolThread"")"
"Since isStopped is now true, the PoolThread.run() will exit and the thread dies.","(""PoolThread"", ""has method"", ""run()""); (""PoolThread"", ""has attribute"", ""isStopped""); (""PoolThread.run()"", ""uses attribute"", ""isStopped"")"
"Notice how the add() method returns a new ImmutableValue instance with the result of the add operation, rather than adding the value to itself.","(""add()"", ""returns"", ""ImmutableValue""); (""add()"", ""belongs to"", ""unknown class""); (""ImmutableValue"", ""instance of"", ""ImmutableValue"")"
Notice how it is possible to change that reference through both the setValue() and add() methods.,"(""setValue()"", ""is method of"", ""unknown class""); (""add()"", ""is method of"", ""unknown class""); (""setValue()"", ""has relationship with"", ""add()""); (""unknown class"", ""has method"", ""setValue()""); (""unknown class"", ""has method"", ""add()"")"
"Therefore, even if the Calculator class uses an immutable object internally, it is not itself immutable, and therefore not thread safe.","(""Calculator"", ""uses"", ""object""); (""Calculator"", ""is"", ""immutable""); (""Calculator"", ""is"", ""thread safe"")"
"In other words: The ImmutableValue class is thread safe, but the use of it is not.","(""ImmutableValue"", ""is"", ""thread safe"")"
"To make the Calculator class thread safe you could have declared the getValue(), setValue(), and add() methods synchronized.","(""Calculator"", ""hasMethod"", ""getValue()""); (""Calculator"", ""hasMethod"", ""setValue()""); (""Calculator"", ""hasMethod"", ""add()"")"
"The LocalObject instance in this example is not returned from the method, nor is it passed to any other objects that are accessible from outside the someMethod() method.","(""LocalObject"", ""instance of"", ""someMethod""); (""LocalObject"", ""returned from"", ""someMethod""); (""someMethod"", ""has parameter"", ""LocalObject""); (""LocalObject"", ""passed to"", ""someMethod""); (""someMethod"", ""has accessible"", ""outside objects"")"
Each thread executing the someMethod() method will create its own LocalObject instance and assign it to the localObject reference.,"(""LocalObject"", ""created by"", ""someMethod()""); (""localObject"", ""assigned to"", ""LocalObject""); (""someMethod()"", ""creates"", ""LocalObject""); (""Thread"", ""executes"", ""someMethod()"")"
"Even if the LocalObject instance is passed as parameter to other methods in the same class, or in other classes, the use of it is thread safe.","(""LocalObject"", ""is passed as parameter to"", ""methods""); (""LocalObject"", ""is used in"", ""same class""); (""LocalObject"", ""is used in"", ""other classes""); (""methods"", ""are in"", ""same class""); (""methods"", ""are in"", ""other classes"")"
If two threads call the add() method simultaneously on the same NotThreadSafe instance then it leads to race conditions.,"(""NotThreadSafe"", ""has method"", ""add()""); (""add()"", ""is called by"", ""threads""); (""NotThreadSafe"", ""is instance of"", ""NotThreadSafe""); (""threads"", ""call"", ""add()""); (""NotThreadSafe"", ""is accessed by"", ""threads""); (""add()"", ""leads to"", ""race conditions""); (""NotThreadSafe"", ""exhibits"", ""race conditions"")"
"Therefore, when they call the add() method on the NotThreadSafe instance it leads to race condition.","(""NotThreadSafe"", ""has method"", ""add()"")"
"However, if two threads call the add() method simultaneously on different instances then it does not lead to race condition.","(""thread"", ""call"", ""add() method""); (""add() method"", ""is called by"", ""thread""); (""thread"", ""access"", ""instance"")"
"In other words, it is waiting for a signal from thread A which causes hasDataToProcess() to return true.","(""thread A"", ""causes"", ""hasDataToProcess()""); (""thread A"", ""waits for signal from"", ""hasDataToProcess()""); (""hasDataToProcess()"", ""returns"", ""true"")"
Notice how the while loop keeps executing until hasDataToProcess() returns true.,"(""while loop"", ""uses"", ""hasDataToProcess()"")"
"The class java.lang.Object defines three methods, wait(), notify(), and notifyAll(), to facilitate this.","(""java.lang.Object"", ""defines"", ""wait()""); (""java.lang.Object"", ""defines"", ""notify()""); (""java.lang.Object"", ""defines"", ""notifyAll()"")"
A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object.,"(""thread"", ""calls"", ""wait()""); (""wait()"", ""on"", ""object""); (""object"", ""has"", ""notify()""); (""thread"", ""calls"", ""notify()""); (""object"", ""has"", ""wait()""); (""thread"", ""becomes"", ""inactive""); (""thread"", ""calls"", ""notify()""); (""notify()"", ""on"", ""object"")"
In order to call either wait() or notify the calling thread must first obtain the lock on that object.,"(""Thread"", ""must obtain lock on"", ""Object""); (""Thread"", ""calls"", ""wait()""); (""Thread"", ""calls"", ""notify()"")"
"In other words, the calling thread must call wait() or notify() from inside a synchronized block.","(""Thread"", ""calls"", ""wait()""); (""Thread"", ""calls"", ""notify()""); (""wait()"", ""is called from"", ""synchronized block""); (""notify()"", ""is called from"", ""synchronized block"")"
Here is a modified version of MySignal called MyWaitNotify that uses wait() and notify().,"(""MySignal"", ""called"", ""MyWaitNotify""); (""MyWaitNotify"", ""uses"", ""wait()""); (""MyWaitNotify"", ""uses"", ""notify()"")"
"The waiting thread would call doWait(), and the notifying thread would call doNotify().","(""waiting thread"", ""would call"", ""doWait()""); (""notifying thread"", ""would call"", ""doNotify()"")"
"When a thread calls notify() on an object, one of the threads waiting on that object are awakened and allowed to execute.","(""thread"", ""calls"", ""notify()""); (""thread"", ""waits on"", ""object""); (""notify()"", ""awakens"", ""thread""); (""object"", ""has"", ""thread""); (""thread"", ""executes on"", ""object"")"
There is also a notifyAll() method that will wake all threads waiting on a given object.,"(""Object"", ""has method"", ""notifyAll()""); (""Thread"", ""waits on"", ""Object""); (""notifyAll()"", ""wakes"", ""Thread"")"
As you can see both the waiting and notifying thread calls wait() and notify() from within a synchronized block.,"(""Thread"", ""calls"", ""wait()""); (""Thread"", ""calls"", ""notify()""); (""wait()"", ""from"", ""synchronized block""); (""notify()"", ""from"", ""synchronized block""); (""Thread"", ""uses"", ""synchronized block"")"
"A thread cannot call wait(), notify() or notifyAll() without holding the lock on the object the method is called on.","(""thread"", ""calls"", ""wait()""); (""thread"", ""calls"", ""notify()""); (""thread"", ""calls"", ""notifyAll()""); (""object"", ""has"", ""lock""); (""thread"", ""holds"", ""lock""); (""wait()"", ""is called on"", ""object""); (""notify()"", ""is called on"", ""object""); (""notifyAll()"", ""is called on"", ""object"")"
Will the waiting thread not block the notifying thread from ever entering the synchronized block in doNotify()?,"(""thread"", ""block"", ""notifying thread""); (""notifying thread"", ""enter"", ""synchronized block""); (""synchronized block"", ""contain"", ""doNotify()"")"
Once a thread calls wait() it releases the lock it holds on the monitor object.,"(""thread"", ""calls"", ""wait()""); (""wait()"", ""releases"", ""lock""); (""lock"", ""held by"", ""thread""); (""lock"", ""on"", ""monitor object""); (""thread"", ""holds"", ""lock""); (""lock"", ""on"", ""monitor object"")"
"This allows other threads to call wait() or notify() too, since these methods must be called from inside a synchronized block.","(""wait()"", ""called from"", ""synchronized block""); (""notify()"", ""called from"", ""synchronized block""); (""wait()"", ""related to"", ""notify()""); (""wait()"", ""used by"", ""threads""); (""notify()"", ""used by"", ""threads""); (""synchronized block"", ""contains"", ""wait()""); (""synchronized block"", ""contains"", ""notify()"")"
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block.,"(""Thread"", ""calls"", ""wait()""); (""Thread"", ""exits"", ""wait()""); (""Thread"", ""calls"", ""notify()""); (""Thread"", ""leaves"", ""synchronized block""); (""synchronized block"", ""contains"", ""notify()""); (""thread"", ""calls"", ""wait()""); (""thread"", ""exit"", ""wait()""); (""thread"", ""calls"", ""notify()""); (""notify()"", ""is called by"", ""thread""); (""thread"", ""leaves"", ""synchronized block""); (""synchronized block"", ""is left by"", ""thread"")"
"In other words: The awakened thread must reobtain the lock on the monitor object before it can exit the wait() call, because the wait call is nested inside a synchronized block.","(""Thread"", ""reobtain"", ""Lock""); (""Lock"", ""on"", ""Monitor""); (""Monitor"", ""has"", ""wait()""); (""Thread"", ""exits"", ""wait()""); (""wait()"", ""inside"", ""synchronized block""); (""synchronized block"", ""contains"", ""wait()"")"
"If multiple threads are awakened using notifyAll() only one awakened thread at a time can exit the wait() method, since each thread must obtain the lock on the monitor object in turn before exiting wait().","(""Thread"", ""uses"", ""notifyAll()""); (""Thread"", ""uses"", ""wait()""); (""Monitor"", ""has"", ""lock""); (""Thread"", ""obtains"", ""lock""); (""wait()"", ""is part of"", ""Monitor""); (""notifyAll()"", ""is part of"", ""Monitor"")"
The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called.,"(""notify()"", ""is called by"", ""no threads""); (""notifyAll()"", ""is called by"", ""no threads""); (""notify()"", ""does not save to"", ""method calls""); (""notifyAll()"", ""does not save to"", ""method calls""); (""no threads"", ""wait for"", ""notify()""); (""no threads"", ""wait for"", ""notifyAll()"")"
"Therefore, if a thread calls notify() before the thread to signal has called wait(), the signal will be missed by the waiting thread.","(""thread"", ""calls"", ""notify()""); (""notify()"", ""is called before"", ""wait()""); (""thread"", ""calls"", ""wait()""); (""thread to signal"", ""has called"", ""wait()""); (""signal"", ""will be missed by"", ""waiting thread""); (""waiting thread"", ""has called"", ""wait()"")"
To avoid losing signals they should be stored inside the signal class.,"(""signal class"", ""contains"", ""signals"")"
Notice how the doNotify() method now sets the wasSignalled variable to true before calling notify().,"(""doNotify()"", ""sets"", ""wasSignalled""); (""doNotify()"", ""calls"", ""notify()"")"
"Also, notice how the doWait() method now checks the wasSignalled variable before calling wait().","(""doWait()"", ""checks"", ""wasSignalled""); (""doWait()"", ""calls"", ""wait()"")"
In fact it only calls wait() if no signal was received in between the previous doWait() call and this.,"(""doWait"", ""calls"", ""wait"")"
For inexplicable reasons it is possible for threads to wake up even if notify() and notifyAll() has not been called.,"(""Thread"", ""uses"", ""notify()""); (""Thread"", ""uses"", ""notifyAll()"")"
If a spurious wakeup occurs in the MyWaitNofity2 class's doWait() method the waiting thread may continue processing without having received a proper signal to do so!,"(""MyWaitNofity2"", ""has method"", ""doWait()""); (""doWait()"", ""is part of"", ""MyWaitNofity2""); (""MyWaitNofity2"", ""can experience"", ""spurious wakeup""); (""waiting thread"", ""uses"", ""doWait()""); (""waiting thread"", ""may experience"", ""spurious wakeup""); (""spurious wakeup"", ""occurs in"", ""MyWaitNofity2"")"
Notice how the wait() call is now nested inside a while loop instead of an if-statement.,
"The while loop is also a nice solution if you have multiple threads waiting, which are all awakened using notifyAll(), but only one of them should be allowed to continue.","(""Thread"", ""uses"", ""notifyAll()""); (""notifyAll()"", ""awakens"", ""Thread"")"
"Only one thread at a time will be able to obtain the lock on the monitor object, meaning only one thread can exit the wait() call and clear the wasSignalled flag.","(""Thread"", ""obtains"", ""Lock""); (""Lock"", ""belongs to"", ""Monitor""); (""Monitor"", ""has"", ""wait()""); (""wait()"", ""clears"", ""wasSignalled flag""); (""Thread"", ""exits"", ""wait()""); (""wasSignalled flag"", ""belongs to"", ""Monitor"")"
"Once this thread then exits the synchronized block in the doWait() method, the other threads can exit the wait() call and check the wasSignalled member variable inside the while loop.","(""Thread"", ""exits"", ""synchronized block""); (""doWait() method"", ""contains"", ""synchronized block""); (""wait() call"", ""is exited by"", ""threads""); (""wasSignalled member variable"", ""is checked by"", ""threads""); (""while loop"", ""contains"", ""wasSignalled member variable""); (""Thread"", ""exits"", ""doWait() method""); (""threads"", ""exit"", ""wait() call"")"
"An earlier version of this text had an edition of the MyWaitNotify example class which used a constant string ( """" ) as monitor object.","(""MyWaitNotify"", ""uses"", ""monitor object""); (""monitor object"", ""is"", ""constant string""); (""MyWaitNotify"", ""has"", ""constant string"")"
"The problem with calling wait() and notify() on the empty string, or any other constant string is, that the JVM/Compiler internally translates constant strings into the same object.","(""JVM"", ""translates"", ""constant strings""); (""constant strings"", ""translated to"", ""object""); (""JVM"", ""uses"", ""object""); (""wait()"", ""called on"", ""empty string""); (""notify()"", ""called on"", ""empty string""); (""empty string"", ""is a"", ""constant string"")"
This also means that threads calling doWait() on the first MyWaitNotify instance risk being awakened by doNotify() calls on the second MyWaitNotify instance.,"(""MyWaitNotify"", ""doWait"", ""threads""); (""threads"", ""doWait"", ""MyWaitNotify""); (""MyWaitNotify"", ""doNotify"", ""threads""); (""threads"", ""doNotify"", ""MyWaitNotify"")"
"Remember, that even if the 4 threads call wait() and notify() on the same shared string instance, the signals from the doWait() and doNotify() calls are stored individually in the two MyWaitNotify instances.","(""MyWaitNotify"", ""has method"", ""wait()""); (""MyWaitNotify"", ""has method"", ""notify()""); (""MyWaitNotify"", ""stores signals from"", ""doWait()""); (""MyWaitNotify"", ""stores signals from"", ""doNotify()""); (""doWait()"", ""calls"", ""wait()""); (""doNotify()"", ""calls"", ""notify()"")"
"A doNotify() call on the MyWaitNotify 1 may wake threads waiting in MyWaitNotify 2, but the signal will only be stored in MyWaitNotify 1.","(""MyWaitNotify 1"", ""has method"", ""doNotify()""); (""MyWaitNotify 2"", ""has threads waiting in"", ""threads""); (""doNotify()"", ""wakes threads in"", ""MyWaitNotify 2""); (""MyWaitNotify 1"", ""stores signal in"", ""MyWaitNotify 1"")"
"After all, if doNotify() is called on the second MyWaitNotify instance all that can really happen is that Thread A and B are awakened by mistake.","(""MyWaitNotify"", ""has method"", ""doNotify()""); (""Thread A"", ""is awakened by"", ""MyWaitNotify""); (""Thread B"", ""is awakened by"", ""MyWaitNotify""); (""MyWaitNotify"", ""can awaken"", ""Thread A""); (""MyWaitNotify"", ""can awaken"", ""Thread B"")"
"This awakened thread (A or B) will check its signal in the while loop, and go back to waiting because doNotify() was not called on the first MyWaitNotify instance, in which they are waiting.","(""MyWaitNotify"", ""hasMethod"", ""doNotify()""); (""Thread"", ""callsMethod"", ""doNotify()""); (""Thread"", ""usesInstance"", ""MyWaitNotify""); (""Thread"", ""waitsOn"", ""MyWaitNotify""); (""MyWaitNotify"", ""isUsedBy"", ""Thread""); (""Thread"", ""hasState"", ""waiting""); (""MyWaitNotify"", ""hasMethod"", ""wait()""); (""Thread"", ""callsMethod"", ""wait()"")"
"The problem is, that since the doNotify() call only calls notify() and not notifyAll(), only one thread is awakened even if 4 threads are waiting on the same string instance (the empty string).","(""Thread"", ""waits_on"", ""String""); (""doNotify"", ""calls"", ""notify""); (""String"", ""has_instance"", ""empty string""); (""empty string"", ""is_instance_of"", ""String""); (""notify"", ""awakens"", ""Thread""); (""doNotify"", ""awakens"", ""one Thread""); (""Thread"", ""waits_on"", ""empty string""); (""notifyAll"", ""awakens"", ""all waiting Threads""); (""String"", ""has_waiting_threads"", ""Thread"")"
"If the doNotify() method had called notifyAll() instead of notify(), all waiting threads had been awakened and checked for signals in turn.","(""doNotify"", ""called"", ""notifyAll""); (""doNotify"", ""called"", ""notify""); (""notifyAll"", ""awakens"", ""threads""); (""notify"", ""awakens"", ""thread"")"
"Thread A and B would have gone back to waiting, but one of either C or D would have noticed the signal and left the doWait() method call.","(""Thread A"", ""would have gone back to waiting"", ""doWait() method""); (""Thread B"", ""would have gone back to waiting"", ""doWait() method""); (""C"", ""would have noticed"", ""signal""); (""D"", ""would have noticed"", ""signal""); (""C"", ""would have left"", ""doWait() method""); (""D"", ""would have left"", ""doWait() method"")"
"The other of C and D would go back to waiting, because the thread discovering the signal clears it on the way out of doWait().","(""C"", ""discovers"", ""signal""); (""signal"", ""cleared by"", ""thread""); (""thread"", ""exits"", ""doWait()""); (""C"", ""waits"", ""doWait()""); (""D"", ""waits"", ""doWait()"")"
"You may be tempted then to always call notifyAll() instead notify(), but this is a bad idea performance wise.","(""notifyAll()"", ""is alternative to"", ""notify()""); (""notify()"", ""has alternative"", ""notifyAll()""); (""notify()"", ""compared to"", ""notifyAll()""); (""notifyAll()"", ""compared to"", ""notify()"")"
"For instance, each MyWaitNotify3 (example from earlier sections) instance has its own MonitorObject instance rather than using the empty string for wait() / notify() calls.","(""MyWaitNotify3"", ""has"", ""MonitorObject""); (""MyWaitNotify3"", ""uses"", ""wait()""); (""MyWaitNotify3"", ""uses"", ""notify()""); (""MonitorObject"", ""usedBy"", ""MyWaitNotify3"")"
"The AtomicBoolean class provides you with a boolean variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().","(""AtomicBoolean"", ""provides"", ""boolean variable""); (""AtomicBoolean"", ""contains"", ""compareAndSet()""); (""boolean variable"", ""can be read and written by"", ""AtomicBoolean""); (""AtomicBoolean"", ""contains"", ""atomic operations""); (""compareAndSet()"", ""is part of"", ""atomic operations""); (""AtomicBoolean"", ""provides"", ""atomic operations"")"
"The AtomicBoolean class is located in the java.util.concurrent.atomic package, so the full class name is java.util.concurrent.atomic.AtomicBoolean .","(""AtomicBoolean"", ""is located in"", ""java.util.concurrent.atomic""); (""java.util.concurrent.atomic"", ""contains"", ""AtomicBoolean""); (""java.util.concurrent.atomic.AtomicBoolean"", ""is full class name of"", ""AtomicBoolean"")"
You can get the value of an AtomicBoolean using the get() method.,"(""AtomicBoolean"", ""uses"", ""get()"")"
You can set the value of an AtomicBoolean using the set() method.,"(""AtomicBoolean"", ""uses"", ""set()""); (""AtomicBoolean"", ""has method"", ""set()""); (""set()"", ""is method of"", ""AtomicBoolean"")"
You can swap the value of an AtomicBoolean using the getAndSet() method.,"(""AtomicBoolean"", ""hasMethod"", ""getAndSet()"")"
"The getAndSet() method returns the AtomicBoolean's current value, and sets a new value for it.","(""AtomicBoolean"", ""hasMethod"", ""getAndSet()""); (""getAndSet()"", ""returns"", ""AtomicBoolean's current value""); (""getAndSet()"", ""sets"", ""new value"")"
"The method compareAndSet() allows you to compare the current value of the AtomicBoolean to an expected value, and if current value is equal to the expected value, a new value can be set on the AtomicBoolean.","(""AtomicBoolean"", ""hasMethod"", ""compareAndSet()""); (""compareAndSet()"", ""takesParameter"", ""expected value""); (""compareAndSet()"", ""setsValueOn"", ""AtomicBoolean""); (""AtomicBoolean"", ""hasMethod"", ""compareAndSet()""); (""AtomicBoolean"", ""compareTo"", ""expected value""); (""AtomicBoolean"", ""sets"", ""new value"")"
"The compareAndSet() method is atomic, so only a single thread can execute it at the same time.","(""compareAndSet()"", ""is a method of"", ""no specific class mentioned""); (""compareAndSet()"", ""executed by"", ""thread""); (""thread"", ""executes"", ""compareAndSet()"")"
"Thus, the compareAndSet() method can be used to implemented simple synchronizers like locks.","(""compareAndSet"", ""can be used to implement"", ""locks""); (""compareAndSet"", ""is a method of"", ""synchronizers""); (""locks"", ""is a type of"", ""synchronizers""); (""compareAndSet"", ""is used in"", ""synchronizers"")"
"The AtomicInteger class provides you with a int variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().","(""AtomicInteger"", ""provides"", ""int variable""); (""AtomicInteger"", ""contains"", ""advanced atomic operations""); (""AtomicInteger"", ""contains"", ""compareAndSet()""); (""compareAndSet()"", ""is part of"", ""AtomicInteger"")"
"The AtomicInteger class is located in the java.util.concurrent.atomic package, so the full class name is java.util.concurrent.atomic.AtomicInteger .","(""AtomicInteger"", ""located in"", ""java.util.concurrent.atomic""); (""java.util.concurrent.atomic"", ""contains"", ""AtomicInteger""); (""AtomicInteger"", ""has full name"", ""java.util.concurrent.atomic.AtomicInteger"")"
You can get the value of an AtomicInteger instance via the get() method.,"(""AtomicInteger"", ""has method"", ""get()"")"
You can set the value of an AtomicInteger instance via the set() method.,"(""AtomicInteger"", ""has method"", ""set()"")"
The AtomicInteger class contains a few methods you can use to add a value to the AtomicInteger and get its value returned.,"(""AtomicInteger"", ""contains"", ""methods""); (""AtomicInteger"", ""has method"", ""add""); (""AtomicInteger"", ""has method"", ""get""); (""methods"", ""include"", ""add""); (""methods"", ""include"", ""get""); (""add"", ""returns"", ""value""); (""get"", ""returns"", ""value""); (""AtomicInteger"", ""has method"", ""get value""); (""AtomicInteger"", ""has method"", ""add value"")"
"The first method, addAndGet() adds a number to the AtomicInteger and returns its value after the addition.","(""AtomicInteger"", ""hasMethod"", ""addAndGet()""); (""addAndGet()"", ""returns"", ""value""); (""AtomicInteger"", ""hasOperation"", ""addition"")"
"The second method, getAndAdd() also adds a number to the AtomicInteger but returns the value the AtomicInteger had before the value was added.","(""AtomicInteger"", ""hasMethod"", ""getAndAdd()""); (""getAndAdd()"", ""returns"", ""value""); (""getAndAdd()"", ""adds"", ""number""); (""AtomicInteger"", ""hasMethod"", ""add()""); (""AtomicInteger"", ""returns"", ""value""); (""getAndAdd()"", ""modifies"", ""AtomicInteger"")"
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicInteger.,"(""AtomicInteger"", ""hasMethod"", ""getAndIncrement()""); (""AtomicInteger"", ""hasMethod"", ""incrementAndGet()""); (""AtomicInteger"", ""hasMethod"", ""getAndAdd()""); (""AtomicInteger"", ""hasMethod"", ""addAndGet()""); (""getAndIncrement()"", ""similarTo"", ""getAndAdd()""); (""incrementAndGet()"", ""similarTo"", ""addAndGet()"")"
The AtomicInteger class also contains a few methods for subtracting values from the AtomicInteger value atomically.,"(""AtomicInteger"", ""contains"", ""methods""); (""methods"", ""are used for"", ""subtracting values""); (""AtomicInteger"", ""has"", ""value""); (""methods"", ""subtract from"", ""AtomicInteger value""); (""AtomicInteger"", ""provides"", ""atomic operations"")"
The decrementAndGet() subtracts 1 from the AtomicInteger value and returns its value after the subtraction.,"(""AtomicInteger"", ""hasMethod"", ""decrementAndGet()""); (""decrementAndGet()"", ""subtractsFrom"", ""AtomicInteger""); (""decrementAndGet()"", ""returns"", ""AtomicInteger value"")"
The getAndDecrement() also subtracts 1 from the AtomicInteger value but returns the value the AtomicInteger had before the subtraction.,"(""AtomicInteger"", ""hasMethod"", ""getAndDecrement()""); (""getAndDecrement()"", ""subtractsFrom"", ""AtomicInteger""); (""getAndDecrement()"", ""returns"", ""AtomicInteger"")"
The Java AtomicIntegerArray class (java.util.concurrent.atomic.AtomicIntegerArray) represents an array of int .,"(""Java"", ""uses"", ""AtomicIntegerArray""); (""AtomicIntegerArray"", ""represents"", ""array of int""); (""AtomicIntegerArray"", ""belongs to"", ""java.util.concurrent.atomic"")"
You can get the value of a given element using the get() method on the AtomicIntegerArray.,"(""AtomicIntegerArray"", ""has method"", ""get()"")"
Here is an example showing how calling the get() method looks:,"(""get()"", ""is method of"", ""unknown entity"")"
You can set the value of a given element using the set() method on the AtomicIntegerArray.,"(""AtomicIntegerArray"", ""has method"", ""set()"")"
Here is an example showing how calling the set() method looks:,"(""set"", ""method of"", ""unknown class"")"
"The compareAndSet() method is used to compare the value of a given element with a specified value, and if the two values are equal, set a new value for that element.","(""compareAndSet()"", ""is used by"", ""element""); (""compareAndSet()"", ""compares"", ""value""); (""compareAndSet()"", ""sets"", ""new value""); (""element"", ""has"", ""value""); (""element"", ""has"", ""new value"")"
Only one thread at a time can execute the compareAndSet() method.,"(""thread"", ""execute"", ""compareAndSet() method""); (""compareAndSet() method"", ""called by"", ""thread"")"
"The compareAndSet() method returns a boolean with the value true if the element had a new value set, and false if not (if the element did not have the expected value).","(""compareAndSet()"", ""returns"", ""boolean""); (""compareAndSet()"", ""called on"", ""element""); (""element"", ""has"", ""value"")"
Calling addAndGet() is also an atomic operation (like all operations on the AtomicIntegerArray).,"(""AtomicIntegerArray"", ""hasMethod"", ""addAndGet()""); (""AtomicIntegerArray"", ""hasOperations"", ""atomic operations"")"
"The getAndAdd() method does the same as the addAndGet() method, except the getAndAdd() method returns the value of the element before a value is added to it.","(""getAndAdd()"", ""isSameAs"", ""addAndGet()""); (""getAndAdd()"", ""returns"", ""value""); (""addAndGet()"", ""returns"", ""value"")"
The incrementAndGet() method increments (adds 1) to the value of a given element and returns the new value of that element.,"(""incrementAndGet()"", ""increments"", ""value""); (""incrementAndGet()"", ""returns"", ""new value""); (""incrementAndGet()"", ""adds"", ""1"")"
"The getAndIncrement() method does the same as the incrementAndGet() method, except the getAndIncrement() method returns the value of the element before it is incremented.","(""getAndIncrement()"", ""is similar to"", ""incrementAndGet()""); (""getAndIncrement()"", ""returns"", ""element value""); (""incrementAndGet()"", ""returns"", ""element value"")"
The decrementAndGet() method decrements (subtracts 1) to the value of a given element and returns the new value of that element.,"(""decrementAndGet()"", ""is_method_of"", ""Atomic classes""); (""decrementAndGet()"", ""subtracts_from"", ""element""); (""decrementAndGet()"", ""returns"", ""new_value"")"
"The getAndDecrement() method does the same as the decrementAndGet() method, except the getAndDecrement() method returns the value of the element before it is decremented.","(""getAndDecrement()"", ""is similar to"", ""decrementAndGet()""); (""getAndDecrement()"", ""returns"", ""element value""); (""decrementAndGet()"", ""returns"", ""element value"")"
You should check out the JavaDoc for the AtomicIntegerArray class to learn more about those methods.,"(""AtomicIntegerArray"", ""hasJavaDoc"", ""JavaDoc""); (""AtomicIntegerArray"", ""hasMethods"", ""methods"")"
"The AtomicLong class provides you with a long variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().","(""AtomicLong"", ""provides"", ""long variable""); (""AtomicLong"", ""contains"", ""compareAndSet()""); (""long variable"", ""can be read and written by"", ""AtomicLong""); (""AtomicLong"", ""contains"", ""atomic operations""); (""atomic operations"", ""include"", ""compareAndSet()"")"
"The AtomicLong class is located in the java.util.concurrent.atomic package, so the full class name is java.util.concurrent.atomic.AtomicLong .","(""AtomicLong"", ""is located in"", ""java.util.concurrent.atomic""); (""java.util.concurrent.atomic"", ""contains"", ""AtomicLong""); (""AtomicLong"", ""has full name"", ""java.util.concurrent.atomic.AtomicLong"")"
You can get the value of an AtomicLong instance via the get() method.,"(""AtomicLong"", ""has method"", ""get()"")"
You can set the value of an AtomicLong instance via the set() method.,"(""AtomicLong"", ""has method"", ""set()"")"
The AtomicLong class contains a few methods you can use to add a value to the AtomicLong and get its value returned.,"(""AtomicLong"", ""contains"", ""methods""); (""AtomicLong"", ""has method"", ""add""); (""AtomicLong"", ""has method"", ""get"")"
"The first method, addAndGet() adds a number to the AtomicLong and returns its value after the addition.","(""AtomicLong"", ""hasMethod"", ""addAndGet()""); (""addAndGet()"", ""returns"", ""value""); (""AtomicLong"", ""hasMethod"", ""addAndGet()""); (""addAndGet()"", ""adds"", ""number""); (""AtomicLong"", ""returns"", ""value"")"
"The second method, getAndAdd() also adds a number to the AtomicLong but returns the value the AtomicLong had before the value was added.","(""AtomicLong"", ""hasMethod"", ""getAndAdd()""); (""getAndAdd()"", ""returns"", ""value""); (""AtomicLong"", ""hasMethod"", ""add()""); (""getAndAdd()"", ""addsTo"", ""AtomicLong"")"
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicLong.,"(""AtomicLong"", ""hasMethod"", ""getAndIncrement()""); (""AtomicLong"", ""hasMethod"", ""incrementAndGet()""); (""AtomicLong"", ""hasMethod"", ""getAndAdd()""); (""AtomicLong"", ""hasMethod"", ""addAndGet()""); (""getAndIncrement()"", ""similarTo"", ""getAndAdd()""); (""getAndIncrement()"", ""similarTo"", ""incrementAndGet()""); (""incrementAndGet()"", ""similarTo"", ""getAndAdd()""); (""incrementAndGet()"", ""similarTo"", ""addAndGet()""); (""getAndAdd()"", ""similarTo"", ""addAndGet()"")"
The AtomicLong class also contains a few methods for subtracting values from the AtomicLong value atomically.,"(""AtomicLong"", ""contains"", ""methods""); (""AtomicLong"", ""has method"", ""subtract""); (""methods"", ""are used for"", ""subtracting values""); (""AtomicLong"", ""supports"", ""atomic operations""); (""methods"", ""belong to"", ""AtomicLong"")"
The decrementAndGet() subtracts 1 from the AtomicLong value and returns its value after the subtraction.,"(""AtomicLong"", ""has method"", ""decrementAndGet()""); (""decrementAndGet()"", ""subtracts from"", ""AtomicLong""); (""AtomicLong"", ""returns value after"", ""decrementAndGet()"")"
The getAndDecrement() also subtracts 1 from the AtomicLong value but returns the value the AtomicLong had before the subtraction.,"(""AtomicLong"", ""hasMethod"", ""getAndDecrement()""); (""getAndDecrement()"", ""subtractsFrom"", ""AtomicLong""); (""getAndDecrement()"", ""returns"", ""AtomicLong"")"
The Java AtomicLongArray class (java.util.concurrent.atomic.AtomicLongArray) represents an array of long .,"(""Java"", ""has class"", ""AtomicLongArray""); (""AtomicLongArray"", ""belongs to"", ""java.util.concurrent.atomic""); (""AtomicLongArray"", ""represents"", ""array of long"")"
You can get the value of a given element using the get() method on the AtomicLongArray.,"(""AtomicLongArray"", ""has method"", ""get()"")"
You can set the value of a given element using the set() method on the AtomicLongArray.,"(""AtomicLongArray"", ""has method"", ""set()"")"
Calling addAndGet() is also an atomic operation (like all operations on the AtomicLongArray).,"(""AtomicLongArray"", ""hasMethod"", ""addAndGet()""); (""AtomicLongArray"", ""hasOperation"", ""addAndGet()""); (""addAndGet()"", ""isPartOf"", ""AtomicLongArray"")"
You should check out the JavaDoc for the AtomicLongArray class to learn more about those methods.,"(""AtomicLongArray"", ""hasJavaDoc"", ""JavaDoc""); (""AtomicLongArray"", ""contains"", ""methods"")"
The AtomicReference class provides an object reference variable which can be read and written atomically.,"(""AtomicReference"", ""provides"", ""object reference variable""); (""object reference variable"", ""can be read and written by"", ""AtomicReference""); (""AtomicReference"", ""has method"", ""read()""); (""AtomicReference"", ""has method"", ""write()"")"
By atomic is meant that multiple threads attempting to change the same AtomicReference (e.g.,"(""AtomicReference"", ""is used by"", ""threads""); (""threads"", ""attempt to change"", ""AtomicReference""); (""AtomicReference"", ""is accessed by"", ""multiple threads"")"
"AtomicReference even has an advanced compareAndSet() method which lets you compare the reference to an expected value (reference) and if they are equal, set a new reference inside the AtomicReference object.","(""AtomicReference"", ""has"", ""compareAndSet()""); (""compareAndSet()"", ""compares"", ""reference""); (""compareAndSet()"", ""sets"", ""new reference""); (""AtomicReference"", ""contains"", ""reference""); (""compareAndSet()"", ""is part of"", ""AtomicReference"")"
You can get the reference stored in an AtomicReference using the AtomicReference's get() method.,"(""AtomicReference"", ""has method"", ""get()""); (""AtomicReference"", ""uses method"", ""get()""); (""get()"", ""is method of"", ""AtomicReference"")"
If you have an untyped AtomicReference then the get() method returns an Object reference.,"(""AtomicReference"", ""hasMethod"", ""get()""); (""get()"", ""returns"", ""Object"")"
If you have a typed AtomicReference then get() returns a reference to the type you declared on the AtomicReference variable when you created it.,"(""AtomicReference"", ""hasMethod"", ""get()""); (""AtomicReference"", ""returns"", ""reference""); (""get()"", ""returns"", ""type""); (""AtomicReference"", ""declaredWith"", ""type"")"
Notice how it is necessary to cast the reference returned by get() to a String because get() returns an Object reference when the AtomicReference is untyped.,"(""AtomicReference"", ""returns"", ""Object""); (""get()"", ""returns"", ""Object""); (""AtomicReference"", ""has method"", ""get()"")"
Notice how it is no longer necessary to cast the referenced returned by get() because the compiler knows it will return a String reference.,
You can set the reference stored in an AtomicReference instance using its set() method.,"(""AtomicReference"", ""has method"", ""set()""); (""AtomicReference"", ""uses method"", ""set()""); (""set()"", ""is method of"", ""AtomicReference"")"
In an untyped AtomicReference instance the set() method takes an Object reference as parameter.,"(""AtomicReference"", ""has method"", ""set()""); (""set()"", ""takes parameter"", ""Object"")"
In a typed AtomicReference the set() method takes whatever type as parameter you declared as its type when you declared the AtomicReference.,"(""AtomicReference"", ""hasMethod"", ""set()""); (""set()"", ""takesParameter"", ""type""); (""AtomicReference"", ""declares"", ""type"")"
There is no difference to see in the use of the set() method for an untyped or typed reference.,"(""set() method"", ""used for"", ""untyped reference""); (""set() method"", ""used for"", ""typed reference"")"
"The compareAndSet() method can compare the reference stored in the AtomicReference instance with an expected reference, and if they two references are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicReference instance.","(""AtomicReference"", ""has method"", ""compareAndSet()""); (""compareAndSet()"", ""uses"", ""equals()""); (""AtomicReference"", ""stores"", ""reference""); (""compareAndSet()"", ""sets"", ""reference""); (""AtomicReference"", ""instance of"", ""AtomicReference""); (""compareAndSet()"", ""compares"", ""reference"")"
If compareAndSet() sets a new reference in the AtomicReference the compareAndSet() method returns true.,"(""AtomicReference"", ""hasMethod"", ""compareAndSet()""); (""compareAndSet()"", ""returns"", ""true""); (""AtomicReference"", ""usesMethod"", ""compareAndSet()"")"
"Then it calls comparesAndSet() two times to compare the stored reference to the initial reference, and set a new reference if the stored reference is equal to the initial reference.","(""comparing entity"", ""calls"", ""comparesAndSet()""); (""comparesAndSet()"", ""compared to"", ""stored reference""); (""stored reference"", ""compared to"", ""initial reference""); (""comparesAndSet()"", ""sets"", ""new reference"")"
"The second time the stored reference is the new reference just set in the call to compareAndSet() before, so the stored reference is of course not equal to the initial reference.","(""compareAndSet()"", ""is called by"", ""unknown entity""); (""stored reference"", ""is compared to"", ""initial reference""); (""stored reference"", ""is updated by"", ""compareAndSet()""); (""initial reference"", ""is compared to"", ""stored reference""); (""compareAndSet()"", ""returns"", ""boolean value"")"
"Thus, a new reference is not set on the AtomicReference and the compareAndSet() method returns false.","(""AtomicReference"", ""has method"", ""compareAndSet()"")"
The AtomicReferenceArray in the java.util.concurrent.atomic package is an array of object references which can be updated atomically.,"(""AtomicReferenceArray"", ""is part of"", ""java.util.concurrent.atomic""); (""AtomicReferenceArray"", ""updates"", ""object references""); (""java.util.concurrent.atomic"", ""contains"", ""AtomicReferenceArray"")"
"The second constructor takes a E[] array as parameter, where E is the type (class) of the object references.","(""E"", ""is the type of"", ""object references""); (""constructor"", ""takes"", ""E array""); (""E"", ""is the type parameter of"", ""constructor"")"
The get() method returns the value of the element with the given index.,"(""get() method"", ""returns"", ""value""); (""get() method"", ""is part of"", ""element""); (""element"", ""has"", ""value""); (""get() method"", ""takes"", ""index""); (""element"", ""has"", ""index"")"
"If the AtomicReferenceArray has a generic type, the get() method returns objects of that type.","(""AtomicReferenceArray"", ""has method"", ""get()""); (""get()"", ""returns"", ""objects""); (""AtomicReferenceArray"", ""has generic type"", ""type"")"
"For instance, if the generic type is String, then you can call get() like this:",
The set() method sets the value of an element with a specific index.,"(""set()"", ""sets"", ""value""); (""set()"", ""sets"", ""element""); (""set()"", ""has"", ""index"")"
The index and value is passed as parameters to the set() method.,"(""index"", ""is passed to"", ""set()""); (""value"", ""is passed to"", ""set()""); (""set()"", ""is called with"", ""index""); (""set()"", ""is called with"", ""value"")"
"The compareAndSet() method of the AtomicReferenceArray can compare the current reference stored in a given element with an expected reference, and if the references are the same, swap the current reference with a new reference.","(""AtomicReferenceArray"", ""hasMethod"", ""compareAndSet()""); (""compareAndSet()"", ""belongsTo"", ""AtomicReferenceArray""); (""AtomicReferenceArray"", ""usesMethod"", ""compareAndSet()"")"
You should check out the JavaDoc for the AtomicReferenceArray class to learn more about those methods.,"(""AtomicReferenceArray"", ""hasJavaDoc"", ""JavaDoc"")"
The AtomicStampedReference class provides an object reference variable which can be read and written atomically.,"(""AtomicStampedReference"", ""provides"", ""object reference variable""); (""AtomicStampedReference"", ""has method"", ""read""); (""AtomicStampedReference"", ""has method"", ""write"")"
"The reference and stamp can be swapped using a single atomic compare-and-swap operation, via the compareAndSet() method.","(""compareAndSet()"", ""is method of"", ""reference""); (""compareAndSet()"", ""is method of"", ""stamp""); (""reference"", ""uses"", ""compareAndSet()""); (""stamp"", ""uses"", ""compareAndSet()"")"
You can get the reference stored in an AtomicStampedReference using the AtomicStampedReference's getReference() method.,"(""AtomicStampedReference"", ""has method"", ""getReference()""); (""AtomicStampedReference"", ""uses"", ""getReference()""); (""AtomicStampedReference.getReference()"", ""returns"", ""reference"")"
If you have an untyped AtomicStampedReference then the getReference() method returns an Object reference.,"(""AtomicStampedReference"", ""hasMethod"", ""getReference()""); (""AtomicStampedReference"", ""returns"", ""Object""); (""getReference()"", ""belongsTo"", ""AtomicStampedReference"")"
If you have a typed AtomicStampedReference then getReference() returns a reference to the type you declared on the AtomicStampedReference variable when you created it.,"(""AtomicStampedReference"", ""hasMethod"", ""getReference()""); (""AtomicStampedReference"", ""returns"", ""reference""); (""getReference()"", ""belongsTo"", ""AtomicStampedReference""); (""AtomicStampedReference"", ""hasVariable"", ""reference""); (""getReference()"", ""returns"", ""type""); (""AtomicStampedReference"", ""hasType"", ""declared type"")"
Notice how it is necessary to cast the reference returned by getReference() to a String because getReference() returns an Object reference when the AtomicStampedReference is untyped.,"(""AtomicStampedReference"", ""returns"", ""Object""); (""AtomicStampedReference"", ""has method"", ""getReference()""); (""getReference()"", ""returns"", ""Object"")"
Notice how it is no longer necessary to cast the referenced returned by getReference() because the compiler knows it will return a String reference.,
The AtomicStampedReference also contains a getStamp() method which can be used to obtain the internally stored stamp.,"(""AtomicStampedReference"", ""contains"", ""getStamp()""); (""getStamp()"", ""used to obtain"", ""stamp""); (""AtomicStampedReference"", ""has method"", ""getStamp()"")"
"You can obtain both reference and stamp from an AtomicStampedReference in a single, atomic operation using the get() method.","(""AtomicStampedReference"", ""has method"", ""get()""); (""get()"", ""returns"", ""reference""); (""get()"", ""returns"", ""stamp""); (""AtomicStampedReference"", ""provides"", ""atomic operation"")"
The get() method returns the reference as return value from the method.,"(""get() method"", ""returns"", ""reference"")"
The stamp is inserted into an int[] array that is passed as parameter to the get() method.,"(""int array"", ""passed to"", ""get() method""); (""get() method"", ""is called with"", ""int array"")"
You can set the reference stored in an AtomicStampedReference instance using its set() method.,"(""AtomicStampedReference"", ""has method"", ""set()"")"
In an untyped AtomicStampedReference instance the set() method takes an Object reference as first parameter.,"(""AtomicStampedReference"", ""has method"", ""set()""); (""set()"", ""takes parameter"", ""Object"")"
In a typed AtomicStampedReference the set() method takes whatever type as parameter you declared as its type when you declared the AtomicStampedReference.,"(""AtomicStampedReference"", ""has method"", ""set()""); (""set()"", ""takes parameter of type"", ""declared type""); (""AtomicStampedReference"", ""declared with type"", ""declared type""); (""set()"", ""is part of"", ""AtomicStampedReference"")"
"The compareAndSet() method can compare the reference stored in the AtomicStampedReference instance with an expected reference, and the stored stamp with an expected stamp, and if they two references and stamps are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicStampedReference instance.","(""AtomicStampedReference"", ""has method"", ""compareAndSet()""); (""compareAndSet()"", ""compares"", ""reference""); (""compareAndSet()"", ""compares"", ""stamp""); (""AtomicStampedReference"", ""stores"", ""reference""); (""AtomicStampedReference"", ""stores"", ""stamp""); (""reference"", ""compared with"", ""expected reference""); (""stamp"", ""compared with"", ""expected stamp""); (""compareAndSet()"", ""sets"", ""new reference"")"
If compareAndSet() sets a new reference in the AtomicStampedReference the compareAndSet() method returns true.,"(""AtomicStampedReference"", ""has method"", ""compareAndSet()""); (""compareAndSet()"", ""returns"", ""true""); (""AtomicStampedReference"", ""uses method"", ""compareAndSet()"")"
This example first creates an AtomicStampedReference and then uses compareAndSet() to swap the reference and stamp.,"(""AtomicStampedReference"", ""uses"", ""compareAndSet()""); (""compareAndSet()"", ""called by"", ""AtomicStampedReference""); (""AtomicStampedReference"", ""has method"", ""compareAndSet()"")"
After the first compareAndSet() call the example attempts to swap the reference and stamp two times without success.,"(""compareAndSet"", ""call"", ""example""); (""example"", ""attempts"", ""swap""); (""swap"", ""reference"", ""stamp"")"
"The first time the initialRef is passed as expected reference, but the internally stored reference is newRef at this time, so the compareAndSet() call fails.","(""initialRef"", ""is passed as"", ""expected reference""); (""internally stored reference"", ""is"", ""newRef""); (""compareAndSet()"", ""call fails"", ""expected reference"")"
"The second time the initialStamp is passed as the expected stamp, but the internally stored stamp is newStamp at this time, so the compareAndSet() call fails.","(""initialStamp"", ""is passed as"", ""expected stamp""); (""internally stored stamp"", ""is"", ""newStamp""); (""compareAndSet()"", ""call fails"", ""expected stamp"")"
"The final compareAndSet() call will succeed, because the expected reference is newRef and the expected stamp is newStamp.","(""compareAndSet()"", ""is a method of"", ""unknown class""); (""unknown class"", ""has method"", ""compareAndSet()""); (""compareAndSet()"", ""uses"", ""expected reference""); (""compareAndSet()"", ""uses"", ""expected stamp"")"
Thread 1 can copy the reference and stamp out of the AtomicStampedReference atomically using get().,"(""Thread"", ""uses"", ""AtomicStampedReference""); (""AtomicStampedReference"", ""has method"", ""get()"")"
"If another thread changes the reference from A to B and then back to A, then the stamp will have changed (provided threads update the stamp sensibly - e.g increment it).",
"The BlockingDeque interface in the java.util.concurrent class represents a deque which is thread safe to put into, and take instances from.","(""BlockingDeque"", ""isPartOf"", ""java.util.concurrent""); (""BlockingDeque"", ""represents"", ""deque""); (""deque"", ""isModifiedBy"", ""thread""); (""BlockingDeque"", ""supportsOperation"", ""put""); (""BlockingDeque"", ""supportsOperation"", ""take"")"
"The BlockingDeque class is a Deque which blocks threads tring to insert or remove elements from the deque, in case it is either not possible to insert or remove elements from the deque.","(""BlockingDeque"", ""is a"", ""Deque""); (""BlockingDeque"", ""blocks"", ""threads""); (""threads"", ""try to insert"", ""BlockingDeque""); (""threads"", ""try to remove"", ""BlockingDeque""); (""BlockingDeque"", ""blocks"", ""elements""); (""elements"", ""are inserted into"", ""BlockingDeque""); (""elements"", ""are removed from"", ""BlockingDeque"")"
The java.util.concurrent package has the following implementations of the BlockingDeque interface:,"(""java.util.concurrent"", ""has"", ""BlockingDeque""); (""BlockingDeque"", ""implemented in"", ""java.util.concurrent"")"
The java.util.concurrent.ConcurrentMap interface represents a Map which is capable of handling concurrent access (puts and gets) to it.,"(""java.util.concurrent.ConcurrentMap"", ""represents"", ""Map""); (""java.util.concurrent.ConcurrentMap"", ""handles"", ""concurrent access""); (""ConcurrentMap"", ""capable of"", ""puts""); (""ConcurrentMap"", ""capable of"", ""gets""); (""java.util.concurrent.ConcurrentMap"", ""is a type of"", ""Map"")"
"The ConcurrentMap has a few extra atomic methods in addition to the methods it inherits from its superinterface, java.util.Map.","(""ConcurrentMap"", ""has methods"", ""atomic methods""); (""ConcurrentMap"", ""inherits from"", ""java.util.Map""); (""ConcurrentMap"", ""has superinterface"", ""java.util.Map"")"
The java.util.concurrent package contains the following implementations of the ConcurrentMap interface:,"(""java.util.concurrent"", ""contains"", ""ConcurrentMap""); (""ConcurrentMap"", ""is implemented by"", ""java.util.concurrent""); (""ConcurrentMap"", ""is part of"", ""java.util.concurrent"")"
"The ConcurrentHashMap is very similar to the java.util.HashTable class, except that ConcurrentHashMap offers better concurrency than HashTable does.","(""ConcurrentHashMap"", ""similar to"", ""HashTable""); (""ConcurrentHashMap"", ""offers"", ""concurrency""); (""HashTable"", ""offers"", ""concurrency""); (""ConcurrentHashMap"", ""better than"", ""HashTable""); (""ConcurrentHashMap"", ""in package"", ""java.util""); (""HashTable"", ""in package"", ""java.util"")"
"The java.util.concurrent.ConcurrentNavigableMap class is a java.util.NavigableMap with support for concurrent access, and which has concurrent access enabled for its submaps.","(""ConcurrentNavigableMap"", ""is a"", ""NavigableMap""); (""ConcurrentNavigableMap"", ""has"", ""submaps""); (""ConcurrentNavigableMap"", ""has support for"", ""concurrent access""); (""NavigableMap"", ""has"", ""submaps""); (""ConcurrentNavigableMap"", ""belongs to"", ""java.util.concurrent""); (""NavigableMap"", ""belongs to"", ""java.util"")"
"The ""submaps"" are the maps returned by various methods like headMap(), subMap() and tailMap().","(""headMap()"", ""returned by"", ""submaps""); (""subMap()"", ""returned by"", ""submaps""); (""tailMap()"", ""returned by"", ""submaps"")"
Here is an example illustrating the use of the headMap() method.,"(""headMap"", ""method of"", ""Map""); (""Map"", ""has method"", ""headMap"")"
Here is an example illustrating the use of the tailMap() method:,"(""Map"", ""hasMethod"", ""tailMap()"")"
"The subMap() method returns a view of the original map which contains all keys from (including), to (excluding) two keys given as parameters to the method.","(""subMap()"", ""returns"", ""view""); (""subMap()"", ""contains"", ""keys""); (""keys"", ""are given as parameters to"", ""subMap()""); (""view"", ""is of"", ""original map""); (""original map"", ""contains"", ""keys"")"
A java.util.concurrent.CountDownLatch is a concurrency construct that allows one or more threads to wait for a given set of operations to complete.,"(""java.util.concurrent.CountDownLatch"", ""is a"", ""concurrency construct""); (""concurrency construct"", ""allows"", ""threads""); (""threads"", ""wait for"", ""operations""); (""java.util.concurrent.CountDownLatch"", ""allows"", ""threads""); (""threads"", ""to wait for"", ""operations""); (""java.util.concurrent.CountDownLatch"", ""is used in"", ""concurrency"")"
Threads waiting for this count to reach zero can call one of the await() methods.,"(""Threads"", ""call"", ""await()""); (""Threads"", ""wait for"", ""count""); (""count"", ""reach"", ""zero"")"
"After the Decrementer has called countDown() 3 times on the CountDownLatch, the waiting Waiter is released from the await() call.","(""Decrementer"", ""calls"", ""countDown()""); (""Decrementer"", ""calls countDown() on"", ""CountDownLatch""); (""CountDownLatch"", ""has method"", ""countDown()""); (""CountDownLatch"", ""has method"", ""await()""); (""Waiter"", ""calls"", ""await()""); (""Waiter"", ""waits on"", ""CountDownLatch""); (""CountDownLatch"", ""releases"", ""Waiter"")"
The java.util.concurrent.CyclicBarrier class is a synchronization mechanism that can synchronize threads progressing through some algorithm.,"(""java.util.concurrent.CyclicBarrier"", ""is a"", ""synchronization mechanism""); (""java.util.concurrent.CyclicBarrier"", ""synchronize"", ""threads""); (""threads"", ""progressing through"", ""algorithm""); (""java.util.concurrent.CyclicBarrier"", ""can synchronize"", ""threads progressing through some algorithm""); (""java.util.concurrent"", ""contains"", ""CyclicBarrier""); (""CyclicBarrier"", ""is part of"", ""java.util.concurrent"")"
The threads wait for each other by calling the await() method on the CyclicBarrier.,"(""CyclicBarrier"", ""has method"", ""await()""); (""threads"", ""call"", ""await()""); (""threads"", ""wait for"", ""each other""); (""threads"", ""use"", ""CyclicBarrier"")"
The value returned by the getDelay() method should be the delay remaining before this element can be released.,"(""getDelay()"", ""is method of"", ""this element""); (""this element"", ""has method"", ""getDelay()""); (""getDelay()"", ""returns"", ""delay"")"
"If 0 or a negative value is returned, the delay will be considered expired, and the element released at the next take() etc.",
The TimeUnit instance passed to the getDelay() method is an Enum that tells which time unit the delay should be returned in.,"(""TimeUnit"", ""passed to"", ""getDelay()""); (""getDelay()"", ""returns delay in"", ""TimeUnit""); (""TimeUnit"", ""is an"", ""Enum"")"
"The Delayed interface also extends the java.lang.Comparable interface, as you can see, which means that Delayed objects can be compared to each other.","(""Delayed"", ""extends"", ""java.lang.Comparable""); (""Delayed"", ""implements"", ""java.lang.Comparable""); (""Delayed"", ""compared to"", ""Delayed"")"
You will have to create your own implementation of the Delayed interface to use the DelayQueue class.,"(""Delayed"", ""implemented by"", ""custom implementation""); (""Delayed"", ""used by"", ""DelayQueue""); (""DelayQueue"", ""uses"", ""Delayed"")"
The java.util.concurrent.Exchanger class represents a kind of rendezvous point where two threads can exchange objects.,"(""java.util.concurrent.Exchanger"", ""represents"", ""rendezvous point""); (""java.util.concurrent.Exchanger"", ""exchanges"", ""objects""); (""threads"", ""exchange"", ""objects""); (""java.util.concurrent.Exchanger"", ""used by"", ""threads"")"
Exchanging objects is done via one of the two exchange() methods.,"(""exchange() methods"", ""is done via"", ""one of the two""); (""one of the two exchange() methods"", ""is used for"", ""exchanging objects""); (""exchange() methods"", ""are used for"", ""exchanging objects"")"
"The Java BlockingQueue interface, java.util.concurrent.BlockingQueue, represents a queue which is thread safe to put elements into, and take elements out of from.","(""Java"", ""has interface"", ""BlockingQueue""); (""BlockingQueue"", ""is in package"", ""java.util.concurrent""); (""BlockingQueue"", ""represents"", ""queue""); (""queue"", ""is"", ""thread safe""); (""BlockingQueue"", ""allows"", ""put elements""); (""BlockingQueue"", ""allows"", ""take elements"")"
The java.util.concurrent package has the following implementations of the BlockingQueue interface:,"(""java.util.concurrent"", ""has"", ""BlockingQueue""); (""BlockingQueue"", ""is part of"", ""java.util.concurrent"")"
"First, the BlockingQueueExample class which starts a Producer and a Consumer in separate threads.","(""BlockingQueueExample"", ""starts"", ""Producer""); (""BlockingQueueExample"", ""starts"", ""Consumer"")"
"It just takes out the objects from the queue, and prints them to System.out.","(""queue"", ""takes out objects from"", ""objects""); (""objects"", ""are printed to"", ""System.out""); (""queue"", ""has objects"", ""objects""); (""System.out"", ""prints"", ""objects"")"
The Java BlockingQueue add() method will add the element passed as parameter to this method if the BlockingQueue has space for it internally.,"(""Java"", ""has method"", ""BlockingQueue""); (""BlockingQueue"", ""has method"", ""add()""); (""add()"", ""adds element to"", ""BlockingQueue"")"
"If the BlockingQueue does not have space internally for this new element, the add() method throws an IllegalStateException.","(""BlockingQueue"", ""has method"", ""add()""); (""add()"", ""throws"", ""IllegalStateException""); (""BlockingQueue"", ""uses method"", ""add()"")"
The BlockingQueue offer() method will add the element passed as parameter to this method if the BlockingQueue has space for it internally.,"(""BlockingQueue"", ""has method"", ""offer()""); (""offer()"", ""is part of"", ""BlockingQueue""); (""BlockingQueue"", ""has property"", ""space""); (""offer()"", ""adds to"", ""BlockingQueue""); (""offer()"", ""takes parameter"", ""element"")"
"If the BlockingQueue does not have space internally for this new element, the offer() method return false.","(""BlockingQueue"", ""has method"", ""offer()""); (""offer()"", ""returns"", ""false""); (""BlockingQueue"", ""uses method"", ""offer()"")"
The BlockingQueue offer() method exists in a version which takes a time out as parameter.,"(""BlockingQueue"", ""hasMethod"", ""offer()""); (""offer()"", ""hasParameter"", ""time out"")"
"This version of the offer() method will add the element passed as parameter if the BlockingQueue has space for it internally, or space becomes available.","(""offer()"", ""is a method of"", ""BlockingQueue""); (""BlockingQueue"", ""has method"", ""offer()""); (""offer()"", ""adds element to"", ""BlockingQueue"")"
"If the BlockingQueue does not have or get space internally for this new element within the time out, this version of the offer() method returns false.","(""BlockingQueue"", ""has method"", ""offer()""); (""offer()"", ""returns"", ""false""); (""BlockingQueue"", ""does not have"", ""space"")"
The BlockingQueue put() method inserts the element into the BlockingQueue if it has space for it internally.,"(""BlockingQueue"", ""has method"", ""put()"")"
"If the BlockingQueue does not have space for the new element, the put() method will block the thread calling the put() method until the BlockingQueue as space internally for the new element.","(""BlockingQueue"", ""has method"", ""put()""); (""put()"", ""blocks"", ""thread""); (""BlockingQueue"", ""has space for"", ""new element""); (""put()"", ""is called by"", ""thread""); (""BlockingQueue"", ""has internal space for"", ""new element"")"
The Java BlockingQueue take() method will remove the first element in the BlockingQueue.,"(""Java"", ""has method"", ""BlockingQueue.take()""); (""BlockingQueue"", ""has method"", ""take()""); (""BlockingQueue.take()"", ""removes"", ""element"")"
"If the BlockingQueue does not contain any elements, the take() method will block the thread calling take() until an element is inserted into the BlockingQueue.","(""BlockingQueue"", ""contains"", ""elements""); (""BlockingQueue"", ""has method"", ""take()""); (""take()"", ""blocks"", ""thread""); (""thread"", ""calls"", ""take()""); (""BlockingQueue"", ""has method"", ""take()""); (""take()"", ""waits for"", ""element""); (""BlockingQueue"", ""receives"", ""element""); (""element"", ""is inserted into"", ""BlockingQueue"")"
The BlockingQueue poll() method will remove the first element in the BlockingQueue.,"(""BlockingQueue"", ""hasMethod"", ""poll()""); (""BlockingQueue"", ""contains"", ""element""); (""poll()"", ""removes"", ""element"")"
"If the BlockingQueue does not contain any elements, the poll() method will return null.","(""BlockingQueue"", ""contains"", ""elements""); (""BlockingQueue"", ""has method"", ""poll()""); (""poll()"", ""returns"", ""null"")"
"If the BlockingQueue does not contain any elements, this version of the poll() method will wait for an element to become available for the given amount of time passed to it as parameter.","(""BlockingQueue"", ""contains"", ""elements""); (""BlockingQueue"", ""has method"", ""poll()""); (""poll()"", ""waits for"", ""elements""); (""poll()"", ""takes parameter"", ""time"")"
The remove() method will use the o.equals(element) to decide if the object o passed as parameter matches a given element in the BlockingQueue.,"(""remove()"", ""uses"", ""equals()""); (""remove()"", ""takes parameter"", ""o""); (""BlockingQueue"", ""contains"", ""element""); (""equals()"", ""is method of"", ""o""); (""o"", ""is parameter of"", ""remove()""); (""element"", ""is part of"", ""BlockingQueue"")"
"The remove() method will return true if an element was removed, and false if not.","(""remove()"", ""returns"", ""true""); (""remove()"", ""returns"", ""false"")"
The BlockingQueue peek() method will return the first element of the BlockingQueue without removing it.,"(""BlockingQueue"", ""has method"", ""peek()""); (""peek()"", ""returns"", ""element""); (""BlockingQueue"", ""contains"", ""element"")"
"If the BlockingQueue does not contain any elements, the peek() method will return null.","(""BlockingQueue"", ""contains"", ""elements""); (""BlockingQueue"", ""has method"", ""peek()""); (""peek()"", ""returns"", ""null"")"
The BlockingQueue element() method will return the first element of the BlockingQueue without removing it.,"(""BlockingQueue"", ""has method"", ""element()""); (""BlockingQueue"", ""returns"", ""element""); (""element()"", ""is method of"", ""BlockingQueue"")"
"If the BlockingQueue does not contain any elements, the element() method will throw a NoSuchElementException.","(""BlockingQueue"", ""contains"", ""element""); (""BlockingQueue"", ""has method"", ""element()""); (""element()"", ""throws"", ""NoSuchElementException"")"
The BlockingQueue contains(Object o) method will return true if the BlockingQueue contains an object matching the object passed as parameter to the contains() method.,"(""BlockingQueue"", ""contains"", ""Object""); (""BlockingQueue"", ""contains"", ""contains()""); (""contains()"", ""returns"", ""true""); (""BlockingQueue"", ""has method"", ""contains()""); (""contains()"", ""takes parameter"", ""Object"")"
"The Objects.equals(o, element) statement is used to check if the parameter object o matches a given element in the BlockingQueue.","(""Objects"", ""equals"", ""o""); (""Objects"", ""equals"", ""element""); (""BlockingQueue"", ""contains"", ""element""); (""Objects"", ""equals"", ""BlockingQueue"")"
The BlockingQueue size() method returns the number of elements stored in BlockingQueue.,"(""BlockingQueue"", ""has method"", ""size()""); (""BlockingQueue"", ""returns number of elements from"", ""size()""); (""BlockingQueue"", ""stores elements in"", ""size()""); (""BlockingingQueue"", ""has return value of type number"", ""size()""); (""size()"", ""is method of"", ""BlockingQueue"")"
The BlockingQueue remainingCapacity() method returns the remaining (unused) capacity of the BlockingQueue.,"(""BlockingQueue"", ""has method"", ""remainingCapacity()""); (""remainingCapacity()"", ""returns"", ""capacity""); (""BlockingQueue"", ""has attribute"", ""capacity"")"
"The Java Callable interface, java.util.concurrent.Callable, represents an asynchronous task which can be executed by a separate thread.","(""Java"", ""has interface"", ""Callable""); (""Callable"", ""represents"", ""asynchronous task""); (""asynchronous task"", ""can be executed by"", ""separate thread""); (""Callable"", ""is part of"", ""java.util.concurrent"")"
The call() method is called in order to execute the asynchronous task.,"(""call()"", ""is called in"", ""asynchronous task"")"
The call() method can also thrown an Exception in case the task fails during execution.,"(""call()"", ""thrown"", ""Exception"")"
The result of that is that the call() method will return a String.,"(""call()"", ""returns"", ""String"")"
The call() implementation just returns a String representation of the current time in milliseconds.,"(""call"", ""implementation returns"", ""String""); (""call"", ""returns"", ""time in milliseconds""); (""String"", ""representation of"", ""time in milliseconds""); (""call"", ""implementation uses"", ""current time""); (""call"", ""returns"", ""current time in milliseconds"")"
"A Java Callable is different from a Runnable in that the Runnable interface's run() method does not return a value, and it cannot throw checked exceptions (only RuntimeExceptions).","(""Java Callable"", ""is different from"", ""Runnable""); (""Runnable interface"", ""has method"", ""run()""); (""run() method"", ""does not return"", ""value""); (""run() method"", ""cannot throw"", ""checked exceptions""); (""run() method"", ""can throw"", ""RuntimeExceptions"")"
"Additionally, a Runnable was originally designed for long running concurrent execution, e.g.","(""Runnable"", ""designed for"", ""concurrent execution"")"
"Java 5 added a new Java package to the Java platform, the java.util.concurrent package.","(""Java 5"", ""added"", ""java.util.concurrent package""); (""Java platform"", ""contains"", ""java.util.concurrent package"")"
This package contains a set of classes that makes it easier to develop concurrent (multithreaded) applications in Java.,"(""concurrent"", ""contains"", ""classes""); (""classes"", ""makes"", ""applications""); (""applications"", ""developed in"", ""Java""); (""package"", ""contains"", ""classes""); (""classes"", ""easier to develop"", ""applications""); (""applications"", ""are"", ""concurrent""); (""applications"", ""are"", ""multithreaded"")"
"Before this package was added, you would have to program your utility classes yourself.","(""package"", ""was added"", ""utility classes"")"
"In this tutorial I will take you through the new java.util.concurrent classes, one by one, so you can learn how to use them.","(""java.util.concurrent"", ""contains"", ""classes""); (""java.util.concurrent"", ""is_part_of"", ""java""); (""classes"", ""are_part_of"", ""java.util.concurrent"")"
Here is a list of the topics covered in this java.util.concurrent trail.,
"If you disagree with anything I write here about the java.util.concurrent utilities, or just have comments, questions, etc, feel free to send me an email.",
"The Java ExecutorService interface, java.util.concurrent.ExecutorService, represents an asynchronous execution mechanism which is capable of executing tasks concurrently in the background.","(""Java"", ""utilizes"", ""ExecutorService""); (""ExecutorService"", ""extends"", ""java.util.concurrent.ExecutorService""); (""ExecutorService"", ""provides"", ""asynchronous execution mechanism""); (""asynchronous execution mechanism"", ""executed by"", ""ExecutorService""); (""ExecutorService"", ""resides in"", ""java.util.concurrent"")"
First an ExecutorService is created using the Executors newFixedThreadPool() factory method.,"(""ExecutorService"", ""created using"", ""Executors.newFixedThreadPool()""); (""Executors"", ""has method"", ""newFixedThreadPool()""); (""ExecutorService"", ""created by"", ""Executors.newFixedThreadPool()"")"
"Second, an anonymous implementation of the Runnable interface is passed to the execute() method.","(""Runnable"", ""is implemented by"", ""anonymous implementation""); (""anonymous implementation"", ""is passed to"", ""execute()""); (""execute()"", ""is a method of"", ""unknown class"")"
"In fact, the implementation of the ExecutorService interface present in the java.util.concurrent package is a thread pool implementation.","(""ExecutorService"", ""implemented in"", ""java.util.concurrent""); (""ExecutorService"", ""is a"", ""thread pool""); (""java.util.concurrent"", ""contains"", ""ExecutorService"")"
"However, you can use the Executors factory class to create ExecutorService instances too.","(""Executors"", ""use to create"", ""ExecutorService"")"
"The Java ExecutorService execute(Runnable) method takes a java.lang.Runnable object, and executes it asynchronously.","(""ExecutorService"", ""execute"", ""Runnable""); (""ExecutorService"", ""has method"", ""execute(Runnable)""); (""execute(Runnable)"", ""takes"", ""Runnable""); (""Java"", ""has package"", ""java.lang""); (""ExecutorService"", ""is in package"", ""java.util""); (""java.lang"", ""contains"", ""Runnable"")"
The submit() method returns a Java Future object which can be used to check when the Runnable has completed.,"(""submit()"", ""returns"", ""Java Future object""); (""Java Future object"", ""used by"", ""Runnable""); (""submit()"", ""belongs to"", ""Runnable"")"
"The invokeAny() method takes a collection of Callable objects, or subinterfaces of Callable.","(""invokeAny"", ""takes"", ""Callable""); (""Callable"", ""has"", ""subinterfaces""); (""invokeAny"", ""takes"", ""collection"")"
"If one Callable finishes, so that a result is returned from invokeAny(), then the rest of the Callable instances are cancelled.","(""Callable"", ""finishes"", ""invokeAny()""); (""Callable"", ""returns"", ""result""); (""invokeAny()"", ""cancels"", ""Callable"")"
The invokeAll() method invokes all of the Callable objects you pass to it in the collection passed as parameter.,"(""invokeAll()"", ""invokes"", ""Callable""); (""invokeAll()"", ""takes"", ""collection""); (""Callable"", ""passed to"", ""invokeAll()"")"
The invokeAll() returns a list of Future objects via which you can obtain the results of the executions of each Callable.,"(""invokeAll()"", ""returns"", ""Future""); (""Future"", ""obtained from"", ""invokeAll()""); (""Callable"", ""executions of"", ""invokeAll()"")"
The main difference between the Runnable run() method and the Callable call() method is that the call() method can return an Object from the method call.,"(""Runnable"", ""has method"", ""run()""); (""Callable"", ""has method"", ""call()""); (""call()"", ""returns"", ""Object""); (""Runnable"", ""has difference with"", ""Callable"")"
"Another difference between call() and run() is that call() can throw an exception, whereas run() cannot (except for unchecked exceptions - subclasses of RuntimeException).","(""call()"", ""can throw"", ""exception""); (""run()"", ""cannot throw"", ""exception""); (""RuntimeException"", ""is subclass of"", ""Exception"")"
You can cancel a task (Runnable or Callable) submitted to a Java ExecutorService by calling the cancel() method on the Future returned when the task is submitted.,"(""Runnable"", ""submitted to"", ""ExecutorService""); (""Callable"", ""submitted to"", ""ExecutorService""); (""ExecutorService"", ""returns"", ""Future""); (""Future"", ""has method"", ""cancel()"")"
Here is an example of cancelling a task by calling the Future.cancel() method:,"(""Future"", ""hasMethod"", ""cancel()"")"
"If your application is started via a main() method and your main thread exits your application, the application will keep running if you have an active ExexutorService in your application.","(""Application"", ""has"", ""main() method""); (""main() method"", ""starts"", ""Application""); (""Application"", ""has"", ""ExecutorService""); (""ExecutorService"", ""keeps running"", ""Application""); (""main thread"", ""exits"", ""Application"")"
To terminate the threads inside the ExecutorService you call its shutdown() method.,"(""ExecutorService"", ""has method"", ""shutdown()"")"
"All tasks submitted to the ExecutorService before shutdown() is called, are executed.","(""ExecutorService"", ""has method"", ""shutdown()""); (""ExecutorService"", ""executes"", ""tasks""); (""shutdown()"", ""is called before"", ""tasks are executed""); (""ExecutorService"", ""submits"", ""tasks""); (""tasks"", ""are executed by"", ""ExecutorService"")"
"If you want to shut down the ExecutorService immediately, you can call the shutdownNow() method.","(""ExecutorService"", ""hasMethod"", ""shutdownNow()"")"
"The ExecutorService awaitTermination() method will block the thread calling it until either the ExecutorService has shutdown completely, or until a given time out occurs.","(""ExecutorService"", ""hasMethod"", ""awaitTermination()""); (""awaitTermination()"", ""belongsTo"", ""ExecutorService""); (""ExecutorService"", ""shutdown"", """"); (""awaitTermination()"", ""waitsFor"", ""ExecutorService""); (""ExecutorService"", ""hasTimeout"", ""timeout""); (""awaitTermination()"", ""throwsException"", ""timeout"")"
The awaitTermination() method is typically called after calling shutdown() or shutdownNow().,"(""awaitTermination()"", ""called after"", ""shutdown()""); (""awaitTermination()"", ""called after"", ""shutdownNow()"")"
"The ForkJoinPool located in the java.util.concurrent package, so the full class name is java.util.concurrent.ForkJoinPool.","(""ForkJoinPool"", ""located in"", ""java.util.concurrent""); (""java.util.concurrent.ForkJoinPool"", ""is in package"", ""java.util.concurrent""); (""java.util.concurrent"", ""contains"", ""ForkJoinPool"")"
These two types of tasks are represented by the RecursiveAction and RecursiveTask classes.,"(""RecursiveAction"", ""is represented by"", ""tasks""); (""RecursiveTask"", ""is represented by"", ""tasks"")"
"If the workLoad is above a certain threshold, the work is split into subtasks which are also scheduled for execution (via the .fork() method of the subtasks.","(""workLoad"", ""has threshold"", ""threshold""); (""work"", ""is split into"", ""subtasks""); (""subtasks"", ""are scheduled for execution via"", ""fork() method""); (""subtasks"", ""have method"", ""fork()"")"
The class MyRecursiveTask extends RecursiveTask<Long> which means that the result returned from the task is a Long .,"(""MyRecursiveTask"", ""extends"", ""RecursiveTask""); (""RecursiveTask"", ""returns"", ""Long"")"
"The MyRecursiveTask example also breaks the work down into subtasks, and schedules these subtasks for execution using their fork() method.","(""MyRecursiveTask"", ""has method"", ""fork()""); (""MyRecursiveTask"", ""breaks down into"", ""subtasks""); (""subtasks"", ""are scheduled using"", ""fork()""); (""subtasks"", ""have method"", ""fork()"")"
"Additionally, this example then receives the result returned by each subtask by calling the join() method of each subtask.","(""subtask"", ""has method"", ""join()""); (""subtask"", ""returns"", ""result""); (""subtask"", ""calls"", ""join()"")"
Notice how you get the final result out from the ForkJoinPool.invoke() method call.,"(""ForkJoinPool"", ""invoke"", ""result"")"
"A Java Future, java.util.concurrent.Future, represents the result of an asynchronous computation.","(""Java"", ""represents"", ""asynchronous computation""); (""java.util.concurrent.Future"", ""is a"", ""Java Future""); (""asynchronous computation"", ""has result"", ""java.util.concurrent.Future"")"
"To obtain the result, you call one of the two get() methods on the Future.","(""Future"", ""has method"", ""get()"")"
"The get() methods both return an Object, but the return type can also be a generic return type (meaning an object of a specific class, and not just an Object).","(""get()"", ""returns"", ""Object""); (""get()"", ""has return type"", ""generic return type"")"
Here is an example of obtaining the result from a Java Future via its get() method:,"(""Java"", ""has method"", ""Future.get()""); (""Future"", ""has method"", ""get()"")"
"If you call the get() method before the asynchronous task has completed, the get() method will block until the result is ready.","(""get() method"", ""is called by"", ""asynchronous task""); (""get() method"", ""blocks until"", ""result""); (""asynchronous task"", ""provides"", ""result""); (""get() method"", ""waits for"", ""result"")"
There is a version of the get() method which can time out after an amount of time has passed which you can specify via method parameters.,"(""get()"", ""has parameter"", ""time""); (""get()"", ""has parameter"", ""amount of time""); (""get()"", ""can time out"", ""time"")"
You can cancel the asynchronous task represented by a Java Future instance by calling the Future cancel() method.,"(""Future"", ""has method"", ""cancel()""); (""Java"", ""has instance"", ""Future""); (""Future"", ""represented by"", ""asynchronous task""); (""Future"", ""has method"", ""cancel()""); (""cancel()"", ""is method of"", ""Future"")"
Here is an example of canceling a task via the Java Future cancel() method:,"(""Java"", ""uses"", ""Future""); (""Future"", ""has method"", ""cancel()"")"
You can check if the asynchronous task is done (and a result available) by calling the Future isDone() method.,"(""Future"", ""has method"", ""isDone()"")"
Here is an example of calling the Java Future isDone() method:,"(""Java"", ""has method"", ""Future.isDone()""); (""Future"", ""has method"", ""isDone()"")"
"The Java Lock interface, java.util.concurrent.locks.Lock, represents a concurrent lock which can be used to guard against race conditions inside critical sections.","(""Java"", ""uses"", ""Lock""); (""Lock"", ""is represented by"", ""java.util.concurrent.locks.Lock""); (""java.util.concurrent.locks.Lock"", ""guards against"", ""race conditions"")"
You must create an instance of a class that implements the Lock interface.,"(""Lock"", ""implements"", ""class""); (""class"", ""instance of"", ""Lock"")"
The java.util.concurrent.locks package has the following implementations of the Lock interface:,"(""java.util.concurrent.locks"", ""has"", ""Lock""); (""Lock"", ""implemented by"", ""java.util.concurrent.locks"")"
In the following sections I will explain how to use the ReentrantLock class as a Lock.,"(""ReentrantLock"", ""is a"", ""Lock"")"
"To create an instance of the ReentrantLock class you simply use the new operator, like this:","(""ReentrantLock"", ""instantiated by"", ""new operator"")"
To lock the Lock instance you must call its lock() method.,"(""Lock"", ""has method"", ""lock()"")"
To unlock the Lock instance you must call its unlock() method.,"(""Lock"", ""has method"", ""unlock()"")"
Any other thread calling lock() will be blocked until the thread that locked the lock calls unlock().,"(""lock"", ""is called by"", ""thread""); (""thread"", ""calls"", ""lock()""); (""lock"", ""is unlocked by"", ""thread""); (""thread"", ""calls"", ""unlock()"")"
"Finally unlock() is called, and the Lock is now unlocked so other threads can lock it.","(""Lock"", ""unlock"", ""threads""); (""Lock"", ""is called"", ""unlock()""); (""threads"", ""can lock"", ""Lock""); (""Lock"", ""is unlocked by"", ""unlock()"")"
"If you look at the example in the previous section, imagine what happens if an exception is thrown between the call to lock.lock() and lock.unlock() .","(""lock"", ""hasMethod"", ""lock.lock()""); (""lock"", ""hasMethod"", ""lock.unlock()""); (""lock.lock()"", ""isCalledBefore"", ""lock.unlock()"")"
"The exception would interrupt the program flow, and the call to lock.unlock() would never be executed.","(""lock"", ""hasMethod"", ""unlock()"")"
"To better understand how using a Lock looks different from using a synchronized block, I have created two simple concurrent Counter classes which protects their internal count in different ways.","(""Lock"", ""looks different from"", ""synchronized block""); (""Counter"", ""protects"", ""internal count""); (""Counter"", ""has"", ""internal count""); (""concurrent Counter"", ""uses"", ""Lock""); (""concurrent Counter"", ""uses"", ""synchronized block"")"
"The first class uses a synchronized block, and the second class uses a Java Lock:","(""class"", ""uses"", ""synchronized block""); (""class"", ""uses"", ""Java Lock"")"
Notice that the CounterLock class is longer than the CounterSynchronized class.,"(""CounterLock"", ""is longer than"", ""CounterSynchronized"")"
"Notice how the calculate() method both locks the Calculator instance's Lock before performing any calculations, and also call the add() and subtract() methods which also locks the lock.","(""Calculator"", ""hasMethod"", ""calculate()""); (""calculate()"", ""calls"", ""add()""); (""calculate()"", ""calls"", ""subtract()""); (""Calculator"", ""hasMethod"", ""add()""); (""Calculator"", ""hasMethod"", ""subtract()""); (""Calculator"", ""hasField"", ""Lock""); (""Lock"", ""isUsedBy"", ""calculate()""); (""Lock"", ""isUsedBy"", ""add()""); (""Lock"", ""isUsedBy"", ""subtract()"")"
The ReentrantLock class has a constructor that takes a boolean parameter specifying whether the ReentrantLock should provide fairness or not to waiting threads.,"(""ReentrantLock"", ""has constructor"", ""ReentrantLock constructor""); (""ReentrantLock constructor"", ""takes parameter"", ""boolean""); (""ReentrantLock"", ""provides"", ""fairness""); (""ReentrantLock"", ""waiting for"", ""threads"")"
"Please note, that the method tryLock() (covered later in this Java Lock tutorial) with no parameters does not respect the fairness mode of the ReentrantLock.","(""ReentrantLock"", ""hasMethod"", ""tryLock()""); (""tryLock()"", ""isPartOf"", ""ReentrantLock""); (""ReentrantLock"", ""hasMode"", ""fairness mode"")"
"If the Lock instance is already locked, the thread calling lock() is blocked until the Lock is unlocked.","(""Lock"", ""has method"", ""lock()""); (""Lock"", ""has method"", ""unlock()""); (""Thread"", ""calls"", ""lock()""); (""Lock"", ""blocks"", ""Thread"")"
The lockInterruptibly() method locks the Lock unless the thread calling the method has been interrupted.,"(""Lock"", ""has method"", ""lockInterruptibly()""); (""lockInterruptibly()"", ""called by"", ""thread""); (""lockInterruptibly()"", ""throws"", ""InterruptedException""); (""Thread"", ""calls"", ""lockInterruptibly()"")"
"The tryLock(long timeout, TimeUnit timeUnit) works like the tryLock() method, except it waits up the given timeout before giving up trying to lock the Lock.","(""Lock"", ""is related to"", ""tryLock()"")"
The Java ReentrantLock getHoldCount() method returns the number of times a given thread has locked this Lock instance.,"(""ReentrantLock"", ""hasMethod"", ""getHoldCount()""); (""getHoldCount()"", ""returns"", ""hold count""); (""ReentrantLock"", ""isTypeOf"", ""Lock"")"
The ReentrantLock getQueueLength() method returns the number of threads waiting to lock the Lock.,"(""ReentrantLock"", ""hasMethod"", ""getQueueLength()""); (""getQueueLength()"", ""returns"", ""number of threads""); (""ReentrantLock"", ""hasRelationship"", ""Lock"")"
"The ReentrantLock hasQueuedThreads() method returns true if any threads are queued up waiting to lock this Lock, and false if not.","(""ReentrantLock"", ""has method"", ""hasQueuedThreads()""); (""hasQueuedThreads()"", ""returns"", ""boolean""); (""ReentrantLock"", ""has method"", ""Lock"")"
"The ReentrantLock isFair() method returns true if this Lock guarantees fairness among threads waiting to lock it, and false if not.","(""ReentrantLock"", ""hasMethod"", ""isFair()""); (""isFair()"", ""returns"", ""boolean""); (""ReentrantLock"", ""guarantees"", ""fairness"")"
"The ReentrantLock isHeldByCurrentThread() method returns true if the Lock is held (locked) by the thread calling isHeldByCurrentThread(), and false if not.","(""ReentrantLock"", ""hasMethod"", ""isHeldByCurrentThread()""); (""isHeldByCurrentThread()"", ""returns"", ""boolean""); (""ReentrantLock"", ""hasMethod"", ""isHeldByCurrentThread()""); (""Lock"", ""hasState"", ""locked""); (""isHeldByCurrentThread()"", ""calledBy"", ""thread"")"
"The ReentrantLock isLocked() method returns true if the Lock is currently locked, and false if not.","(""ReentrantLock"", ""hasMethod"", ""isLocked()""); (""isLocked()"", ""returns"", ""true""); (""isLocked()"", ""returns"", ""false""); (""Lock"", ""hasState"", ""locked""); (""Lock"", ""hasState"", ""unlocked"")"
"If no upper bound is specified, Integer.MAX_VALUE is used as the upper bound.","(""Integer"", ""hasConstant"", ""MAX_VALUE"")"
All elements inserted into the PriorityBlockingQueue must implement the java.lang.Comparable interface.,"(""PrioriyBlockingQueue"", ""must implement"", ""java.lang.Comparable"")"
Notice that the PriorityBlockingQueue does not enforce any specific behaviour for elements that have equal priority (compare() == 0).,"(""PriorityBlockingQueue"", ""does not enforce behaviour for"", ""elements""); (""PriorityBlockingQueue"", ""has method"", ""compare()""); (""compare()"", ""returns value"", ""0"")"
"The java.util.concurrent.ScheduledExecutorService is an ExecutorService which can schedule tasks to run after a delay, or to execute repeatedly with a fixed interval of time in between each execution.","(""java.util.concurrent.ScheduledExecutorService"", ""is"", ""ExecutorService""); (""java.util.concurrent.ScheduledExecutorService"", ""can schedule"", ""tasks""); (""ExecutorService"", ""can be scheduled by"", ""java.util.concurrent.ScheduledExecutorService""); (""java.util.concurrent.ScheduledExecutorService"", ""executes"", ""tasks"")"
Then an anonymous implementation of the Callable interface is created and passed to the schedule() method.,"(""Callable"", ""is implemented by"", ""anonymous implementation""); (""anonymous implementation"", ""is passed to"", ""schedule()""); (""schedule()"", ""is method of"", ""unknown class""); (""anonymous implementation"", ""uses"", ""Callable""); ("" schedule()"", ""is called by"", ""unknown class"")"
"Since ScheduledExecutorService is an interface, you will have to use its implementation in the java.util.concurrent package, in order to use it.","(""ScheduledExecutorService"", ""is part of"", ""java.util.concurrent""); (""java.util.concurrent"", ""contains"", ""ScheduledExecutorService"")"
"However, you can use the Executors factory class to create ScheduledExecutorService instances too.","(""Executors"", ""use to create"", ""ScheduledExecutorService""); (""Executors"", ""create"", ""ScheduledExecutorService instances""); (""Executors"", ""is a"", ""factory class""); (""ScheduledExecutorService"", ""created by"", ""Executors"")"
"This method works like the method version taking a Callable as parameter, except a Runnable cannot return a value, so the ScheduledFuture.get() method returns null when the task is finished.","(""ScheduledFuture"", ""get"", ""null""); (""Runnable"", ""cannot return"", ""value""); (""Callable"", ""taking as parameter"", ""method""); (""ScheduledFuture"", ""returns"", ""null""); (""Runnable"", ""cannot return"", ""value""); (""Callable"", ""compared to"", ""Runnable""); ("" ScheduledFuture"", ""get"", ""null""); (""Method"", ""taking"", ""Callable""); (""Method"", ""compared to"", ""ScheduledFuture"")"
This method works very much like scheduleAtFixedRate() except that the period is interpreted differently.,"(""scheduleAtFixedRate()"", ""is similar to"", ""this method"")"
"In the scheduleAtFixedRate() method the period is interpreted as a delay between the start of the previous execution, until the start of the next execution.","(""scheduleAtFixedRate"", ""is a method of"", ""None""); (""scheduleAtFixedRate"", ""has parameter"", ""period""); (""period"", ""is interpreted as"", ""delay""); (""delay"", ""occurs between"", ""executions""); (""executions"", ""are started by"", ""scheduleAtFixedRate""); (""scheduleAtFixedRate"", ""controls"", ""executions"")"
You shut down a ScheduledExecutorService using the shutdown() or shutdownNow() methods which are inherited from the ExecutorService interface.,"(""ScheduledExecutorService"", ""uses"", ""shutdown()""); (""ScheduledExecutorService"", ""uses"", ""shutdownNow()""); (""ScheduledExecutorService"", ""inherits from"", ""ExecutorService""); (""shutdown()"", ""inherited by"", ""ScheduledExecutorService""); (""shutdownNow()"", ""inherited by"", ""ScheduledExecutorService""); (""ScheduledExecutorService"", ""shuts down using"", ""shutdown()""); (""ScheduledExecutorService"", ""shuts down using"", ""shutdownNow()"")"
For each call to acquire() a permit is taken by the calling thread.,"(""acquire()"", ""is called by"", ""thread""); (""thread"", ""takes"", ""permit"")"
For each call to release() a permit is returned to the semaphore.,"(""release()"", ""returns"", ""permit""); (""semaphore"", ""has"", ""permit"")"
"Thus, at most N threads can pass the acquire() method without any release() calls, where N is the number of permits the semaphore was initialized with.","(""Semaphore"", ""has method"", ""acquire()""); (""Semaphore"", ""has method"", ""release()""); (""acquire()"", ""requires"", ""permits""); (""release()"", ""affects"", ""permits""); (""Semaphore"", ""initialized with"", ""N""); (""Semaphore"", ""has attribute"", ""permits""); (""permits"", ""set by"", ""initialization""); (""acquire()"", ""limited by"", ""N""); (""threads"", ""pass through"", ""acquire()"")"
"If you use a semaphore to send signals between threads, then you would typically have one thread call the acquire() method, and the other thread to call the release() method.","(""thread"", ""call"", ""acquire() method""); (""thread"", ""call"", ""release() method""); (""acquire() method"", ""used by"", ""thread""); (""release() method"", ""used by"", ""thread"")"
"If no permits are available, the acquire() call will block until a permit is released by another thread.","(""acquire()"", ""is called by"", ""thread""); (""acquire()"", ""blocks until"", ""permit is released""); (""permit"", ""is released by"", ""thread""); (""acquire()"", ""waits for"", ""permit""); (""permit"", ""is acquired by"", ""acquire()"")"
"Similarly, a release() calls is blocked if no more permits can be released into this semaphore.","(""release()"", ""calls"", ""semaphore""); (""semaphore"", ""has"", ""permits""); (""release()"", ""is blocked by"", ""no permits"")"
"For instance, if acquire was called after Thread 1 had inserted an object in a shared list, and Thread 2 had called release() just before taking an object from that list, you had essentially created a blocking queue.","(""Thread"", ""called"", ""acquire""); (""Thread 1"", ""inserted"", ""object""); (""object"", ""in"", ""shared list""); (""Thread 2"", ""called"", ""release()""); (""release()"", ""before"", ""taking""); (""taking"", ""an object from"", ""shared list""); (""shared list"", ""created"", ""blocking queue"")"
"That is, there is no guarantee that the first thread to call acquire() is also the first thread to obtain a permit.","(""Thread"", ""calls"", ""acquire()"")"
"If you want to enforce fairness, the Semaphore class has a constructor that takes a boolean telling if the semaphore should enforce fairness.","(""Semaphore"", ""has constructor"", ""constructor""); (""constructor"", ""takes parameter"", ""boolean""); (""Semaphore"", ""enforces"", ""fairness""); (""constructor"", ""enforces"", ""fairness""); (""Semaphore"", ""has parameter"", ""boolean"")"
Calling this class a queue is a bit of an overstatement.,
"However, unless you need to specify all these parameters explicitly for your ThreadPoolExecutor, it is often easier to use one of the factory methods in the java.util.concurrent.Executors class, as shown in the ExecutorService text.","(""ThreadPoolExecutor"", ""has factory methods in"", ""java.util.concurrent.Executors""); (""ExecutorService"", ""has text"", ""java.util.concurrent.Executors""); (""ThreadPoolExecutor"", ""uses"", ""java.util.concurrent.Executors""); (""java.util.concurrent.Executors"", ""provides"", ""ExecutorService""); (""ThreadPoolExecutor"", ""is related to"", ""ExecutorService"")"
"A Java Certificate class instance contains name plus other details of the entity it identifies, plus possibly a digital signature from a Certificate Authority (CA).","(""Certificate"", ""contains"", ""name""); (""Certificate"", ""contains"", ""details""); (""Certificate"", ""contains"", ""digital signature""); (""Certificate"", ""identifies"", ""entity""); (""Certificate"", ""signed by"", ""Certificate Authority""); (""Certificate Authority"", ""issues"", ""digital signature"")"
"The Java Certificate class is an abstract class, so while you may use Certificate as variable type, your variable will always point to a subclass of Certificate.","(""Certificate"", ""is a"", ""abstract class""); (""Certificate"", ""has subclass"", ""subclass of Certificate""); (""variable"", ""points to"", ""subclass of Certificate""); (""Certain class"", ""is a"", ""subclass of Certificate""); (""Certificate"", ""can be used as"", ""variable type"")"
The Java Certificate class has one subclass - the X509Certificate class.,"(""Certificate"", ""has subclass"", ""X509Certificate"")"
This class represents an X.509 certificate which is used as identity certificate in HTTPS and TLS.,"(""X.509 certificate"", ""used in"", ""HTTPS""); (""X.509 certificate"", ""used in"", ""TLS""); (""X.509 certificate"", ""represents"", ""identity certificate"")"
The Java Certificate getEncoded() method returns an encoded version of the Certificate as a byte array.,"(""Java Certificate"", ""has method"", ""getEncoded()""); (""getEncoded()"", ""returns"", ""byte array""); (""Certificate"", ""has method"", ""getEncoded()"")"
"For instance, if the Certificate is an X509Certificate the returned byte array will contain an X.590 (ASN.1 DER) encoded version of the Certificate instance.","(""Certificate"", ""is"", ""X509Certificate""); (""X509Certificate"", ""has"", ""byte array""); (""Certificate"", ""has"", ""instance""); (""byte array"", ""contains"", ""X.509 encoded version""); (""X.509 encoded version"", ""is"", ""ASN.1 DER encoded""); (""Certificate"", ""instance of"", ""X509Certificate"")"
The Java Certificate getPublicKey() method returns the PublicKey of this Certificate instance.,"(""Certificate"", ""has method"", ""getPublicKey()""); (""getPublicKey()"", ""returns"", ""PublicKey""); (""Certificate"", ""instance of"", ""PublicKey"")"
The Java Certificate getType() method returns the type of the Certificate instance.,"(""Java Certificate"", ""has method"", ""getType()""); (""Certificate"", ""has instance"", ""type""); (""getType()"", ""returns"", ""type"")"
The Java CertificateFactory class (java.security.cert.CertificateFactory) is capable of creating Java Certificate instances from binary certificate encodings like X.509 (ASN.1 DER).,"(""CertificateFactory"", ""creates"", ""Certificate""); (""CertificateFactory"", ""uses"", ""X.509""); (""CertificateFactory"", ""isPartOf"", ""java.security.cert"")"
"To read more about the Java Certificate class, see the Java Certificate tutorial.","(""Java Certificate"", ""hasTutorial"", ""Java Certificate tutorial""); (""Java Certificate class"", ""isPartOf"", ""Java""); (""Java Certificate tutorial"", ""describes"", ""Java Certificate class"")"
See the Java CertPath tutorial for more information about the CertPath class.,"(""CertPath"", ""is described in"", ""Java CertPath tutorial"")"
This example creates a CertificateFactory instance capable of creating X.509 certificate instances (X509Certificate - a subclass of Certificate).,"(""CerificateFactory"", ""creates"", ""X509Certificate""); (""X509Certificate"", ""is a"", ""Certificate""); (""CerificateFactory"", ""capable of creating"", ""X509Certificate""); (""X509Certificate"", ""is a subclass of"", ""Certificate"")"
You create a CertPath instance by calling the CertificateFactory generateCertPath() method.,"(""CertificateFactory"", ""generateCertPath"", ""CertPath""); (""CertPath"", ""created by"", ""CertificateFactory.generateCertPath()""); (""CertificateFactory"", ""has method"", ""generateCertPath()""); (""CertPath"", ""instance of"", ""CertificateFactory.generateCertPath()"")"
"The Java CertPath class (java.security.cert.CertPath represents a chain of cryptographic identity certificates (Java Certificate objects), where each certificate is the digital signer of the next certificate in the chain.","(""CertPath"", ""represents"", ""chain of certificates""); (""CertPath"", ""contains"", ""Certificate""); (""Certificate"", ""is signed by"", ""Certificate""); (""CertPath"", ""is part of"", ""java.security.cert"")"
The Java CertPath class is typically used to verify an identity certificate along with the certificates of the Certificate Authorities (CAs) that signed the certificate.,"(""CertPath"", ""used to verify"", ""identity certificate""); (""CertPath"", ""used along with"", ""Certificate Authorities""); (""Certificate Authorities"", ""signed"", ""certificate""); (""CertPath"", ""verify"", ""certificate"")"
Once you have a Java CertPath instance you can obtain the Certificate instances the CertPath consists of by calling the CertPath getCertificates() method.,"(""CertPath"", ""has method"", ""getCertificates()""); (""CertPath"", ""consists of"", ""Certificate""); (""getCertificates()"", ""returns"", ""Certificate"")"
The CertPath getType() method returns a string telling what type of certificates (e.g.,"(""CertPath"", ""hasMethod"", ""getType()""); (""getType()"", ""returns"", ""string""); (""CertPath"", ""uses"", ""string"")"
Here is an example of obtaining the CertPath type via getType():,"(""CertPath"", ""getType()"", ""type"")"
That is why the Java class is called Cipher and not e.g.,"(""Java"", ""has class"", ""Cipher"")"
This Java Cipher tutorial will explain how the Cipher class of the Java Cryptography API works.,"(""Cipher"", ""is part of"", ""Java Cryptography API""); (""Java Cryptography API"", ""contains"", ""Cipher""); (""Cipher"", ""works in"", ""Java"")"
Before you can use a Java Cipher you just create an instance of the Cipher class.,"(""Cipher"", ""create instance of"", ""Cipher class""); (""Java Cipher"", ""use"", ""Cipher class""); (""Cipher class"", ""create instance of"", ""Java Cipher"")"
You create a Cipher instance by calling its getInstance() method with a parameter telling what type of encryption algorithm you want to use.,"(""Cipher"", ""getInstance()"", ""encryption algorithm""); (""Cipher"", ""has method"", ""getInstance()""); (""getInstance()"", ""called with"", ""encryption algorithm""); (""Cipher"", ""uses"", ""encryption algorithm"")"
There are several overridden versions of both update() and doFinal() which takes different parameters.,"(""update()"", ""overridden by"", ""doFinal()""); (""doFinal()"", ""overridden by"", ""update()""); (""update()"", ""has parameter"", ""parameter""); (""doFinal()"", ""has parameter"", ""parameter"")"
"If you have to encrypt or decrypt a single block of data, just call the doFinal() with the data to encrypt or decrypt.","(""data"", ""doFinal()"", ""encryption/decryption process""); (""encryption/decryption process"", ""uses"", ""doFinal()""); (""doFinal()"", ""processes"", ""data"")"
"If you have to encrypt or decrypt multiple blocks of data, e.g.",
"multiple blocks from a large file, you call the update() once for each block of data, and finish with a call to doFinal() with the last data block.","(""update()"", ""called by"", ""user""); (""doFinal()"", ""called by"", ""user""); (""update()"", ""related to"", ""doFinal()""); (""doFinal()"", ""receives"", ""last data block""); (""update()"", ""receives"", ""block of data"")"
"The reason a call to doFinal() is needed for the last block of data is, that some encryption algorithms need to pad the the data to fit a certain cipher block size (e.g.","(""doFinal()"", ""is needed for"", ""last block of data""); (""doFinal()"", ""is used by"", ""encryption algorithms""); (""encryption algorithms"", ""need to pad"", ""data""); (""encryption algorithms"", ""have"", ""cipher block size"")"
"Hence the calls to update() for intermediate blocks of data, and the call to doFinal() for the last block of data.","(""update()"", ""calls"", ""intermediate blocks of data""); (""doFinal()"", ""calls"", ""last block of data"")"
"When decrypting multiple blocks of data you also call the Cipher update() method for intermediate data blocks, and the doFinal() method for the last block.","(""Cipher"", ""hasMethod"", ""update()""); (""Cipher"", ""hasMethod"", ""doFinal()"")"
The Java Cipher class encryption and decryption methods can encrypt or decrypt part of the data stored in a byte array.,"(""Java Cipher class"", ""has methods"", ""encryption methods""); (""Java Cipher class"", ""has methods"", ""decryption methods""); (""encryption methods"", ""can encrypt"", ""byte array""); (""decryption methods"", ""can decrypt"", ""byte array"")"
You simply pass an offset and length to the update() and / or doFinal() method.,"(""update()"", ""called by"", ""user""); (""doFinal()"", ""called by"", ""user""); (""update()"", ""related to"", ""doFinal()"")"
You can encrypt or decrypt data into an existing byte array by passing the destination byte array as parameter to the update() and / or doFinal() method.,"(""update()"", ""is method of"", ""unknown class""); (""doFinal()"", ""is method of"", ""unknown class""); (""byte array"", ""is parameter of"", ""update()""); (""byte array"", ""is parameter of"", ""doFinal()"")"
If you want to set a different offset for the dest byte array there is a version of update() and doFinal() which takes an offset parameter extra.,
Here is an example of calling the doFinal() method with an offset into the dest array:,"(""doFinal()"", ""called by"", ""unknown""); (""doFinal()"", ""has parameter"", ""dest array""); (""doFinal()"", ""has parameter"", ""offset""); (""dest array"", ""passed to"", ""doFinal()""); (""offset"", ""passed to"", ""doFinal()"")"
"When you call the doFinal() method on a Cipher instance, the Cipher instance is returned to the state it had just after initialization.","(""Cipher"", ""has method"", ""doFinal()""); (""Cipher"", ""has state"", ""initialization state""); (""Cipher"", ""returns to state"", ""initialization state""); (""Cipher"", ""calls method"", ""doFinal()""); (""Cipher instance"", ""calls method"", ""doFinal()""); (""Cipher instance"", ""returns to state"", ""initialization state"")"
Notice the call to update() and then doFinal() for these two blocks of data.,
This is done with the doFinal() call with the third data block.,"(""doFinal()"", ""call"", ""data block"")"
After this doFinal() call you can encrypt yet another block of data with the same Java Cipher instance.,"(""Java Cipher"", ""has method"", ""doFinal()""); (""Java Cipher"", ""can perform action"", ""encrypt""); (""Java Cipher"", ""operates on"", ""data""); (""Java Cipher"", ""instance of"", ""Java Cipher instance""); (""doFinal()"", ""called on"", ""Java Cipher""); (""encrypt"", ""performed by"", ""Java Cipher"")"
JCA is structured around some central general purpose classes and interfaces.,"(""JCA"", ""has"", ""classes""); (""JCA"", ""has"", ""interfaces""); (""classes"", ""are"", ""general purpose""); (""interfaces"", ""are"", ""general purpose""); (""JCA"", ""structured around"", ""classes""); (""JCA"", ""structured around"", ""interfaces"")"
"Thus, you may use a Cipher class to encrypt and decrypt some data, but the concrete cipher implementation (encryption algorithm) depends on the concrete provider used.","(""Cipher"", ""uses"", ""provider""); (""Cipher"", ""depends on"", ""provider""); (""Cipher"", ""encrypts"", ""data""); (""Cipher"", ""decrypts"", ""data"")"
The most commonly used of these classes are covered throughout the rest of this Java Cryptography tutorial.,
The Provider (java.security.Provider) class is a central class in the Java cryptography API.,"(""Provider"", ""is part of"", ""Java cryptography API""); (""Provider"", ""is in package"", ""java.security"")"
"The Cipher class is explained in more detail in the text on the Java Cipher class, but I will give a brief introduction to the Cipher class in the following sections.","(""Cipher"", ""is explained in"", ""Java Cipher""); (""Cipher"", ""is introduced in"", ""following sections""); (""Java Cipher"", ""is related to"", ""Cipher"")"
"The Cipher.getInstance(...) method take a String identifying which encryption algorithm to use, as well as a few other configurations of the algorithm.","(""Cipher"", ""hasMethod"", ""getInstance(...)""); (""getInstance(...)"", ""takesParameter"", ""String""); (""getInstance(...)"", ""configures"", ""algorithm"")"
"To initialize a Cipher instance to decrypt data you have to use the Cipher.DECRYPT_MODE, like this:","(""Cipher"", ""has_mode"", ""Cipher.DECRYPT_MODE""); (""Cipher"", ""instance_of"", ""Cipher""); (""Cipher.DECRYPT_MODE"", ""used_for"", ""decrypting_data""); (""Cipher"", ""used_to"", ""decrypt_data"")"
You do so by calling the Cipher update() or doFinal() methods.,"(""Cipher"", ""has method"", ""update()""); (""Cipher"", ""has method"", ""doFinal()"")"
The update() method is used if you are encrypting or decrypting part of a bigger chunk of data.,"(""update()"", ""is used in"", ""encrypting""); (""update()"", ""is used in"", ""decrypting"")"
"The doFinal() method is called when you are encrypting the last part of the big chunk of data, or if the block you pass to doFinal() represents the complete data block to encrypt.","(""doFinal()"", ""is called by"", ""last part of the big chunk of data""); (""doFinal()"", ""represents"", ""complete data block to encrypt""); (""doFinal()"", ""is method of"", ""unspecified class"")"
Here is an example of encrypting some data with the doFinal() method,"(""doFinal"", ""method of"", ""unknown class"")"
To decrypt data you would have passed cipher text (encrypted data) into the doFinal() or doUpdate() method instead.,"(""cipher text"", ""passed into"", ""doFinal()""); (""cipher text"", ""passed into"", ""doUpdate()"")"
"The example in the previous section about the Cipher class used a very simple, hardcoded key.","(""Cipher"", ""used"", ""key"")"
You can use the Java KeyGenerator class to generate more random encryption keys.,"(""Java"", ""uses"", ""KeyGenerator class""); (""KeyGenerator class"", ""generates"", ""encryption keys"")"
"The resulting SecretKey instance can be passed to the Cipher.init() method, like this:","(""SecretKey"", ""passed to"", ""Cipher.init()""); (""SecretKey"", ""used with"", ""Cipher""); (""Cipher"", ""has method"", ""Cipher.init()"")"
To generate an asymmetric key pair you can use the KeyPairGenerator (java.security.KeyPairGenerator).,"(""KeyPairGenerator"", ""uses"", ""java.security.KeyPairGenerator""); (""KeyPairGenerator"", ""located in"", ""java.security"")"
The KeyStore class is quite advanced so it is described in more detail in its own Java KeyStore Tutorial.,"(""KeyStore"", ""is described in"", ""Java KeyStore Tutorial"")"
You can use the Java MessageDigest (java.security.MessageDigest) to calculate message digests.,"(""Java"", ""uses"", ""MessageDigest""); (""MessageDigest"", ""is part of"", ""java.security"")"
In order to calculate a message digest of some data you call the update() or digest() method.,"(""update()"", ""is method of"", ""MessageDigest""); (""digest()"", ""is method of"", ""MessageDigest""); (""MessageDigest"", ""has method"", ""update()""); (""MessageDigest"", ""has method"", ""digest()"")"
"The update() method can be called multiple times, and the message digest is updated internally.","(""update()"", ""called by"", ""multiple times""); (""update()"", ""updates"", ""message digest"")"
"When you have passed all the data you want to include in the message digest, you call digest() and get the resulting message digest data out.","(""digest"", ""call"", ""digest()""); (""digest"", ""get"", ""message digest data"")"
Here is an example of calling update() several times followed by a digest() call:,
You can also call digest() a single time passing all the data to calculate the message digest from.,"(""digest()"", ""is called by"", ""user""); (""digest()"", ""calculates"", ""message digest"")"
The Java Mac class is used to create a MAC from a message.,"(""Mac"", ""used to create"", ""MAC""); (""Mac"", ""is used with"", ""message""); (""Java"", ""contains class"", ""Mac""); (""Mac"", ""creates"", ""MAC""); (""message"", ""used with"", ""Mac"")"
"The Mac class is described in more detail in the Java Mac tutorial, but below is a short introduction.","(""Mac"", ""is described in"", ""Java Mac tutorial"")"
"You create a Java Mac instance by calling the Mac.getInstance() method, passing as parameter the name of the algorithm to use.","(""Mac"", ""getInstance()"", ""algorithm""); (""Mac"", ""hasMethod"", ""getInstance()""); (""Mac.getInstance()"", ""usesParameter"", ""algorithm"")"
Once the Mac instance is initialized you can calculate a MAC from data by calling the update() and doFinal() method.,"(""Mac"", ""has method"", ""update()""); (""Mac"", ""has method"", ""doFinal()"")"
"If you have all the data to calculate the MAC for, you can call the doFinal() method immediately.","(""doFinal()"", ""is method of"", ""unspecified class"")"
"If you only have the access to the data in separate blocks, call update() multiple times with the data, and finish off with a call to doFinal().","(""update()"", ""called with"", ""data""); (""update()"", ""called multiple times"", ""data""); (""update()"", ""followed by"", ""doFinal()""); (""doFinal()"", ""called after"", ""update()"")"
You do so by calling the initSign(...) method passing the private key to use to sign the data.,
You do so by calling update() passing the data to sign as parameter.,
You can call the update() method several times with more data to include when creating the signature.,"(""update()"", ""called by"", ""user""); (""update()"", ""includes"", ""data""); (""signature"", ""created by"", ""update()"")"
When all the data has been passed to the update() method you call the sign() method to obtain the digital signature.,"(""update() method"", ""calls"", ""sign() method""); (""sign() method"", ""obtains"", ""digital signature"")"
This is done by calling the initVerify(...) method passing as parameter the public key to use to verify the signature.,
"Once initialized into verification mode, you call the update() method with the data the signature is signing, and finish with a call to verify() which returns true or false depending on whether the signature could be verified or not.","(""update()"", ""called with"", ""data""); (""update()"", ""followed by"", ""verify()""); (""verify()"", ""returns"", ""true""); (""verify()"", ""returns"", ""false""); (""verify()"", ""depends on"", ""signature verification"")"
Here is a full example of both creating and verifying a digital signature with the Signature class:,"(""Signature"", ""used for"", ""creating digital signature""); (""Signature"", ""used for"", ""verifying digital signature"")"
The Java KeyGenerator class (javax.crypto.KeyGenerator) is used to generate symmetric encryption keys.,"(""javax.crypto.KeyGenerator"", ""is used to generate"", ""symmetric encryption keys""); (""Java"", ""has class"", ""javax.crypto.KeyGenerator""); (""javax.crypto.KeyGenerator"", ""generates"", ""symmetric encryption keys"")"
Before you can use the Java KeyGenerator class you must create a KeyGenerator instance.,"(""Java KeyGenerator class"", ""must create"", ""KeyGenerator instance""); (""KeyGenerator instance"", ""created using"", ""Java KeyGenerator class"")"
You create a KeyGenerator instance by calling the static method getInstance() passing as parameter the name of the encryption algorithm to create a key for.,"(""KeyGenerator"", ""getInstance()"", ""encryption algorithm""); (""KeyGenerator"", ""creates"", ""key""); (""getInstance()"", ""called on"", ""KeyGenerator""); (""encryption algorithm"", ""passed to"", ""getInstance()"")"
Initializing a KeyGenerator instance is done by calling its init() method.,"(""KeyGenerator"", ""init"", ""init()""); (""KeyGenerator"", ""has method"", ""init()""); (""init()"", ""is method of"", ""KeyGenerator"")"
"The KeyGenerator init() method takes two parameters: The bit size of the keys to generate, and a SecureRandom that is used during key generation.","(""KeyGenerator"", ""hasMethod"", ""init()""); (""init()"", ""takesParameter"", ""bit size""); (""init()"", ""takesParameter"", ""SecureRandom""); (""KeyGenerator"", ""uses"", ""SecureRandom"")"
Generating a key is done by calling the KeyGenerator generateKey() method.,"(""KeyGenerator"", ""has method"", ""generateKey()"")"
You can access the PublicKey of a KeyPair by calling its getPublic() method.,"(""KeyPair"", ""has method"", ""getPublic()""); (""getPublic()"", ""returns"", ""PublicKey""); (""KeyPair"", ""contains"", ""PublicKey"")"
You can access the PrivateKey of a KeyPair by calling the getPrivate() method.,"(""PrivateKey"", ""accessed by"", ""KeyPair.getPrivate()""); (""KeyPair"", ""has method"", ""getPrivate()""); (""getPrivate()"", ""returns"", ""PrivateKey"")"
The Java KeyPairGenerator class (java.security.KeyPairGenerator) is used to generate asymmetric encryption / decryption key pairs.,"(""Java"", ""uses"", ""KeyPairGenerator""); (""KeyPairGenerator"", ""is part of"", ""java.security""); (""KeyPairGenerator"", ""generates"", ""key pairs"")"
Creating a KeyPairGenerator instance is done by calling the method getInstance() method.,"(""KeyPairGenerator"", ""getInstance"", ""instance"")"
The getInstance() method takes the name of the encryption algorithm to generate the key pair for.,"(""getInstance()"", ""takes"", ""encryption algorithm""); (""encryption algorithm"", ""is used to generate"", ""key pair""); (""getInstance()"", ""generates"", ""key pair"")"
To generate a KeyPair with a KeyPairGenerator you call the generateKeyPair() method.,"(""KeyPairGenerator"", ""call"", ""generateKeyPair()""); (""generateKeyPair()"", ""generate"", ""KeyPair"")"
This makes the KeyStore class a useful mechanism to handle encryption keys securely.,"(""KeyStore"", ""is a"", ""mechanism""); (""KeyStore"", ""handle"", ""encryption keys""); (""KeyStore"", ""is used for"", ""encryption""); (""KeyStore"", ""provides"", ""secure handling""); (""encryption keys"", ""are handled by"", ""KeyStore""); (""KeyStore"", ""is useful for"", ""secure encryption""); (""KeyStore"", ""is a part of"", ""security mechanism""); (""security mechanism"", ""includes"", ""KeyStore""); (""KeyStore"", ""is related to"", ""secure key handling""); (""KeyStore"", ""handles"", ""encryption keys securely""); (""encryption keys"", ""are securely handled by"", ""KeyStore"")"
You can create a Java KeyStore instance by calling its getInstance() method.,"(""Java KeyStore"", ""getInstance"", ""getInstance() method""); (""Java KeyStore"", ""has method"", ""getInstance()""); (""getInstance() method"", ""belongs to"", ""Java KeyStore"")"
It is also possible to create other types of KeyStore instance by passing a different parameter to the getInstance() method.,"(""KeyStore"", ""getInstance()"", ""parameter""); (""getInstance()"", ""called on"", ""KeyStore""); (""KeyStore"", ""has method"", ""getInstance()"")"
That is why the KeyStore class assumes that you must read its data in before you can use it.,"(""KeyStore"", ""assumes"", ""data""); (""KeyStore"", ""reads"", ""data""); (""KeyStore"", ""uses"", ""data"")"
Loading the KeyStore data from a file or other storage is done by calling the KeyStore load() method.,"(""KeyStore"", ""has method"", ""load()""); (""KeyStore"", ""uses"", ""file""); (""KeyStore"", ""uses"", ""storage""); (""load()"", ""belongs to"", ""KeyStore"")"
This example loads the KeyStore file located in the keystore.ks file.,"(""KeyStore"", ""loads"", ""keystore.ks"")"
You can get the keys of a Java KeyStore instance via its getEntry() method.,"(""Java KeyStore"", ""has method"", ""getEntry()""); (""getEntry()"", ""belongs to"", ""Java KeyStore""); (""Java KeyStore"", ""instance of"", ""KeyStore"")"
"Thus, to access a key you must pass the key alias and password to the getEntry() method.","(""getEntry()"", ""is called with"", ""key alias""); (""getEntry()"", ""is called with"", ""password"")"
"If you know that the key entry you want to access is a private key, you can cast the KeyStore.Entry instance to a KeyStore.PrivateKeyEntry.","(""KeyStore.Entry"", ""is cast to"", ""KeyStore.PrivateKeyEntry""); (""KeyStore.Entry"", ""instance of"", ""KeyStore""); (""KeyStore.PrivateKeyEntry"", ""is a type of"", ""KeyStore.Entry"")"
"After casting to a KeyStore.PrivateKeyEntry you can access the private key, certificate and certificate chain via these methods:","(""KeyStore.PrivateKeyEntry"", ""has method"", ""getPrivateKey()""); (""KeyStore.PrivateKeyEntry"", ""has method"", ""getCertificate()""); (""KeyStore.PrivateKeyEntry"", ""has method"", ""getCertificateChain()"")"
"Sometimes you may want to store a KeyStore to some storage (disk, database etc.)","(""KeyStore"", ""stored to"", ""storage""); (""storage"", ""may be"", ""disk""); (""storage"", ""may be"", ""database"")"
"To execute it, open a command line (cmd, console, shell etc.).",
This Keytool -delete command will remove the KeyStore entry with the alias testkey from the KeyStore stored in the file keystore.jks .,"(""Keytool"", ""hasCommand"", ""-delete""); (""Keytool"", ""affects"", ""KeyStore""); (""KeyStore"", ""hasEntry"", ""testkey""); (""KeyStore"", ""storedIn"", ""keystore.jks""); (""-delete"", ""removes"", ""KeyStore entry"")"
"Once generated, the certificate request should be sent to the CA you want to create a certificate for you (e.g.",
"This command will generate a certificate request for the key stored with alias testkey in the keystore file keystore.jks, and write the certificate request into the file named certreq.certreq .",
The Java Mac (javax.crypto.Mac class can create a Message Authentication Code (MAC) from binary data.,"(""javax.crypto.Mac"", ""can create"", ""Message Authentication Code""); (""javax.crypto.Mac"", ""is a class in"", ""Java""); (""Message Authentication Code"", ""is created from"", ""binary data""); (""javax.crypto.Mac"", ""is used with"", ""binary data"")"
Before you can use the Java Mac class you must create a Mac instance.,"(""Java"", ""uses"", ""Mac class""); (""Mac class"", ""instance of"", ""Mac""); (""Mac"", ""created before"", ""Java Mac class"")"
The String parameter passed to the Mac getInstance() method contains the name of the MAC algorithm to use.,"(""String"", ""passed to"", ""Mac.getInstance()""); (""Mac"", ""has method"", ""getInstance()""); (""String"", ""contains"", ""MAC algorithm""); (""Mac.getInstance()"", ""uses"", ""MAC algorithm"")"
You initialize the Mac instance by calling its init() method passing as parameter the secret key to be used by the Mac instance.,"(""Mac"", ""init()"", ""secret key""); (""Mac"", ""has method"", ""init()""); (""init()"", ""takes parameter"", ""secret key""); (""Mac instance"", ""uses"", ""secret key"")"
To calculate a MAC value you call the Mac update() or doFinal() method.,"(""Mac"", ""has method"", ""update()""); (""Mac"", ""has method"", ""doFinal()"")"
"If you only have a single block of data to calculate the MAC for, you can call doFinal() directly, like this:",
"If you have multiple blocks of data to calculate the MAC for, e.g.",
"if you are reading a file block by block, then you must call the update() method with each block, and finish with a call to doFinal().","(""update()"", ""called with"", ""block""); (""update()"", ""finished with"", ""doFinal()""); (""doFinal()"", ""called after"", ""update()"")"
The Java MessageDigest class represents a cryptographic hash function which can calculate a message digest from binary data.,"(""Java"", ""uses"", ""MessageDigest""); (""MessageDigest"", ""represents"", ""cryptographic hash function""); (""MessageDigest"", ""calculates"", ""message digest""); (""MessageDigest"", ""processes"", ""binary data"")"
This tutorial only explains how to use the Java Cryptography API representation of a message digest in the MessageDigest class.,"(""Java Cryptography API"", ""uses"", ""MessageDigest class""); (""MessageDigest class"", ""represents"", ""message digest"")"
To create a Java MessageDigest instance you call the static getInstance() method of the MessageDigest class.,"(""MessageDigest"", ""hasMethod"", ""getInstance()""); (""MessageDigest"", ""getInstance"", ""MessageDigest instance""); (""MessageDigest class"", ""hasMethod"", ""getInstance()"")"
The text parameter passed to the getInstance() method is the name of the concrete message digest algorithm to use.,"(""getMessageDigest"", ""uses"", ""algorithm""); (""getInstance"", ""takes"", ""text parameter""); (""algorithm"", ""is used by"", ""getInstance"")"
"If you have a single block of data to calculate a message digest from, use the digest() method.","(""digest"", ""method of"", ""unspecified class"")"
"If you have multiple blocks of data to include in the same message digest, call the update() method and finish off with a call to digest().","(""update() method"", ""called before"", ""digest() method""); (""digest() method"", ""called after"", ""update() method""); (""Message digest"", ""includes"", ""blocks of data""); (""update() method"", ""used for"", ""multiple blocks of data""); (""digest() method"", ""finishes"", ""message digest"")"
The Java Signature class (java.security.Signature) can create a digital signature for binary data.,"(""Java Signature class"", ""can create"", ""digital signature""); (""Java Signature class"", ""is located in"", ""java.security.Signature""); (""Digital signature"", ""is created for"", ""binary data""); (""Java Signature class"", ""creates digital signature for"", ""binary data"")"
Before you can use the Java Signature class you must create a Signature instance.,"(""Java Signature class"", ""must create"", ""Signature instance""); (""Signature instance"", ""created by"", ""Java Signature class""); (""Java Signature class"", ""has instance"", ""Signature instance"")"
You create a Signature instance by calling the static getInstance() method.,"(""Signature"", ""hasMethod"", ""getInstance()""); (""getInstance()"", ""returns"", ""Signature""); (""Signature"", ""hasStaticMethod"", ""getInstance()"")"
The String passed as parameter to the getInstance() method is the name of the digital signature algorithm to use.,"(""String"", ""passed to"", ""getInstance()""); (""getInstance()"", ""uses"", ""digital signature algorithm""); (""digital signature algorithm"", ""has name"", ""String"")"
"You create a digital signature by calling the update() method one or more times, finishing with a call to sign().","(""update()"", ""called by"", ""sign()""); (""update()"", ""part of"", ""digital signature creation""); (""sign()"", ""part of"", ""digital signature creation""); (""update()"", ""followed by"", ""sign()"")"
Therefore I have put together this little trail on Java's date and time classes.,"(""Java"", ""has"", ""date and time classes"")"
Hopefully that will help you get an overview of Java's date and time classes.,"(""Java"", ""has"", ""date and time classes"")"
I also hope it may clear up some of the confusion Sun has created with Java's many date and time classes.,"(""Java"", ""has"", ""date classes""); (""Java"", ""has"", ""time classes""); (""Sun"", ""created"", ""Java""); (""Java"", ""has"", ""confusion"")"
"Actually, the Java date time API has been changed (cleaned up) in Java 8 with the introduction of a whole new set of classes.","(""Java"", ""has"", ""Java date time API""); (""Java date time API"", ""introduced in"", ""Java 8""); (""Java 8"", ""introduced"", ""new set of classes""); (""Java date time API"", ""cleaned up in"", ""Java 8"")"
The new Java date time API is located in the Java package java.time which is part of the standard Java 8 class library.,"(""Java"", ""has package"", ""java.time""); (""java.time"", ""is part of"", ""Java 8""); (""Java 8"", ""contains"", ""java.time""); (""java.time"", ""is located in"", ""Java"")"
You will see this new date and time representation in many of the classes in the new Java date time API.,"(""Java date time API"", ""contains"", ""classes"")"
The java.time package also contains a set of subpackages which contain more utilities etc.,"(""java.time"", ""contains"", ""subpackages"")"
"For instance the java.time.chrono contains classes to work with Japanese, Thai, Taiwanese and Islamic calendars.","(""java.time.chrono"", ""contains"", ""Japanese calendars""); (""java.time.chrono"", ""contains"", ""Thai calendars""); (""java.time.chrono"", ""contains"", ""Taiwanese calendars""); (""java.time.chrono"", ""contains"", ""Islamic calendars"")"
The java.time.format package contains classes used to parse and format dates from and to strings.,"(""java.time.format"", ""contains"", ""classes""); (""java.time.format"", ""used to parse"", ""dates""); (""java.time.format"", ""used to format"", ""dates""); (""classes"", ""used to parse"", ""dates""); (""classes"", ""used to format"", ""dates""); (""dates"", ""parsed from"", ""strings""); (""dates"", ""formatted to"", ""strings"")"
The core of the Java 8 date time API consists of the following classes:,"(""Java 8 date time API"", ""consists of"", ""classes"")"
Java 7 has the following date and time classes and methods.,"(""Java 7"", ""has"", ""date and time classes""); (""Java 7"", ""has"", ""date and time methods""); (""Java 7"", ""includes"", ""date classes""); (""Java 7"", ""includes"", ""time classes""); (""Java 7"", ""includes"", ""date methods""); (""Java 7"", ""includes"", ""time methods"")"
"Each of these classes are also explained in their own pages, later.",
If you need to do simple timing the System.currentTimeMillis() method will do just fine.,"(""System"", ""hasMethod"", ""currentTimeMillis()""); (""currentTimeMillis()"", ""belongsTo"", ""System"")"
"If you just need an object to hold a date, for instance as a property in a simple domain model object, you can use the java.util.Date class.","(""java.util.Date"", ""used in"", ""domain model object""); (""java.util.Date"", ""holds"", ""date""); (""domain model object"", ""has property"", ""java.util.Date"")"
"If you need to read and write the date and time to a database, use the java.sql.Date and java.sql.Timestamp classes.","(""java.sql.Date"", ""used with"", ""database""); (""java.sql.Timestamp"", ""used with"", ""database""); (""java.sql.Date"", ""used for"", ""reading and writing date and time""); (""java.sql.Timestamp"", ""used for"", ""reading and writing date and time"")"
"If you need to do date calculations like adding days or months to another date, or check what weekday (monday, tuesday etc.)",
"a given date is, or convert dates and times between time zones, use the java.util.Calendar and java.util.GregorianCalendar classes.","(""java.util.Calendar"", ""used with"", ""java.util.GregorianCalendar""); (""java.util.Calendar"", ""used for"", ""date conversion""); (""java.util.GregorianCalendar"", ""used for"", ""date conversion""); (""java.util.Calendar"", ""related to"", ""time zones""); (""java.util.GregorianCalendar"", ""related to"", ""time zones"")"
The Java DateTimeFormatter class is used to parse and format dates represented with the classes in the Java 8 date time API.,"(""Java DateTimeFormatter"", ""used with"", ""Java 8 date time API""); (""Java DateTimeFormatter"", ""parses"", ""dates""); (""Java DateTimeFormatter"", ""formats"", ""dates""); (""Java 8 date time API"", ""contains"", ""classes""); (""Java DateTimeFormatter"", ""is part of"", ""Java 8 date time API"")"
The DateTimeFormatter is located in the java.time.format package so the fully qualified class name is java.time.format.DateTimeFormatter.,"(""DateTimeFormatter"", ""is located in"", ""java.time.format""); (""DateTimeFormatter"", ""has fully qualified class name"", ""java.time.format.DateTimeFormatter""); (""java.time.format"", ""contains"", ""DateTimeFormatter"")"
The DateTimeFormatter class contains a set of predefined (constant) instances which can parse and format dates from standard date formats.,"(""DateTimeFormatter"", ""contains"", ""instances""); (""instances"", ""can parse"", ""dates""); (""instances"", ""can format"", ""dates""); (""dates"", ""are in"", ""standard date formats""); (""DateTimeFormatter"", ""can parse"", ""standard date formats""); (""DateTimeFormatter"", ""can format"", ""standard date formats"")"
You can read about them in the JavaDoc for the DateTimeFormatter class.,"(""DateTimeFormatter"", ""hasJavaDoc"", ""JavaDoc"")"
Once you have an instance of a DateTimeFormatter you can format a date using its format() method.,"(""DateTimeFormatter"", ""has method"", ""format()"")"
A Duration object (java.time.Duration) represents a period of time between two Instant objects.,"(""Duration"", ""represents"", ""period of time""); (""Duration"", ""is related to"", ""Instant""); (""Instant"", ""is part of"", ""Duration""); (""java.time.Duration"", ""is type of"", ""Duration"")"
The Duration class was added to the Java date time API from Java 8.,"(""Duration"", ""was added to"", ""Java date time API""); (""Java date time API"", ""is part of"", ""Java 8""); (""Duration"", ""is part of"", ""Java 8"")"
Creating a Duration object is done using one of the Duration class factory methods.,"(""Duration"", ""has factory methods"", ""Duration class factory methods""); (""Duration class"", ""has"", ""factory methods""); (""Duration"", ""created by"", ""Duration class factory methods"")"
Here is an example of how to create a Duration object using the between() method:,"(""Duration"", ""uses"", ""between()""); (""between()"", ""creates"", ""Duration"")"
This is somewhat different from what we are used to with System.getCurrentTimeMillis() where a moment in time (or a period between two moments) is represented as a number of milliseconds.,"(""System"", ""hasMethod"", ""getCurrentTimeMillis()"")"
The toNanos() is different from the getNano() in that the getNano() only returns the part of the Duration which is less than one second.,"(""Duration"", ""hasMethod"", ""toNanos()""); (""Duration"", ""hasMethod"", ""getNano()""); (""getNano()"", ""returns"", ""part of Duration""); (""toNanos()"", ""returns"", ""value in nanos"")"
The toNanos() method returns the full time interval converted to nanoseconds.,"(""toNanos"", ""returns"", ""full time interval""); (""toNanos"", ""is method of"", ""time interval""); (""toNanos"", ""converted to"", ""nanoseconds"")"
You might be asking yourself if there is not a toSeconds() method.,"(""toSeconds"", ""method of"", ""unknown class"")"
You can obtain the seconds part of the Duration using the getSeconds() method as explained earlier.,"(""Duration"", ""uses"", ""getSeconds()"")"
The Duration class contains a set of methods you can use to perform calculations based on a Duration object.,"(""Duration"", ""contains"", ""methods""); (""Duration"", ""has"", ""Duration object""); (""Duration"", ""perform calculations with"", ""Duration object""); (""methods"", ""are used to perform calculations with"", ""Duration object""); (""Duration"", ""has"", ""set of methods"")"
The Instant class in the Java date time API (java.time.Instant) represents a specific moment on the time line.,"(""Instant"", ""represents"", ""moment on the timeline""); (""Instant"", ""is part of"", ""java.time""); (""Java date time API"", ""contains"", ""Instant""); (""Instant"", ""is in package"", ""java.time"")"
"Time is measured using 86.400 seconds per day, moving forward from the origin.",
You create an Instant instance using one of the Instant class factory methods.,"(""Instant"", ""has factory methods"", ""Instant class""); (""Instant class"", ""has factory methods"", ""Instant""); (""Instant"", ""created by"", ""Instant class factory methods"")"
"For instance, to create an Instant which represents this exact moment of now, call Instant.now(), like this:","(""Instant"", ""has method"", ""now()"")"
The Instant class also has several methods which can be used to make calculations relative to an Instant.,"(""Instant"", ""has"", ""methods""); (""methods"", ""used for"", ""calculations""); (""calculations"", ""relative to"", ""Instant"")"
The LocalDate class in the Java 8 date time API represents a local date which is a date without time zone information.,"(""LocalDate"", ""represents"", ""local date""); (""LocalDate"", ""is part of"", ""Java 8 date time API""); (""Java 8 date time API"", ""contains"", ""LocalDate"")"
"The LocalDate Java class is located in the java.time package, so its fully qualified class name is java.time.LocalDate.","(""LocalDate"", ""is located in"", ""java.time""); (""LocalDate"", ""has fully qualified class name"", ""java.time.LocalDate""); (""java.time"", ""contains"", ""LocalDate"")"
Here is an example of creating a LocalDate using the now() method:,"(""LocalDate"", ""uses"", ""now()""); (""LocalDate"", ""has method"", ""now()""); (""now()"", ""returns"", ""LocalDate"")"
"The LocalDate's of() method creates a LocalDate instance representing a specific day of a specific month of a specific year, but without time zone information.","(""LocalDate"", ""has method"", ""of()""); (""LocalDate"", ""represents"", ""day""); (""LocalDate"", ""represents"", ""month""); (""LocalDate"", ""represents"", ""year""); (""of()"", ""creates"", ""LocalDate instance""); (""LocalDate"", ""lacks"", ""time zone information"")"
Notice how the getMonth() and getDayOfWeek() methods return an enum instead of an int.,"(""getMonth()"", ""returns"", ""enum""); (""getDayOfWeek()"", ""returns"", ""enum"")"
From these enums you can obtain their information as int values by calling their getValue() methods.,"(""enums"", ""have method"", ""getValue()""); (""enums"", ""obtain information as"", ""int values""); (""enums"", ""call"", ""getValue() methods""); (""getValue() methods"", ""return"", ""int values""); (""enums"", ""use"", ""getValue() methods""); (""enums"", ""get information from"", ""int values""); (""getValue()"", ""return"", ""int""); (""enums"", ""have"", ""getValue()"")"
You can perform a set of simple date calculations with the LocalDate class using one or more of the following methods:,"(""LocalDate"", ""uses"", ""methods""); (""LocalDate"", ""has method"", ""LocalDate.plus()""); (""LocalDate"", ""has method"", ""LocalDate.minus()""); (""LocalDate"", ""has method"", ""LocalDate.plusYears()""); (""LocalDate"", ""has method"", ""LocalDate.plusMonths()""); (""LocalDate"", ""has method"", ""LocalDate.plusWeeks()""); (""LocalDate"", ""has method"", ""LocalDate.plusDays()""); (""LocalDate"", ""has method"", ""LocalDate.minusYears()""); (""LocalDate"", ""has method"", ""LocalDate.minusMonths()""); (""LocalDate"", ""has method"", ""LocalDate.minusWeeks()""); (""LocalDate"", ""has method"", ""LocalDate.minusDays()"")"
The LocalDateTime class in the Java 8 date time API (java.time.LocalDateTime) represents a local date and time without any time zone information.,"(""LocalDateTime"", ""represents"", ""local date and time""); (""LocalDateTime"", ""belongs to"", ""java.time""); (""Java 8 date time API"", ""contains"", ""LocalDateTime"")"
You could view the LocalDateTime as a combination of the LocalDate and LocalTime classes of the Java 8 date time API.,"(""LocalDateTime"", ""combines"", ""LocalDate""); (""LocalDateTime"", ""combines"", ""LocalTime""); (""LocalDate"", ""partOf"", ""Java 8 date time API""); (""LocalTime"", ""partOf"", ""Java 8 date time API""); (""LocalDateTime"", ""partOf"", ""Java 8 date time API"")"
Here is an example that shows how to create a LocalDateTime object via the now() method:,"(""LocalDateTime"", ""has method"", ""now()"")"
"The parameters to the of() method are year, month, day (of month), hours, minutes, seconds and nanoseconds.","(""of()"", ""hasParameter"", ""year""); (""of()"", ""hasParameter"", ""month""); (""of()"", ""hasParameter"", ""day""); (""of()"", ""hasParameter"", ""hours""); (""of()"", ""hasParameter"", ""minutes""); (""of()"", ""hasParameter"", ""seconds""); (""of()"", ""hasParameter"", ""nanoseconds"")"
Via the methods that return an enum you can get an int representation of the enum by calling the getValue() of the enum .,"(""enum"", ""hasMethod"", ""getValue()""); (""getValue()"", ""returns"", ""int"")"
The LocalTime class in the Java 8 date time API represents a specific time of day without any time zone information.,"(""LocalTime"", ""represents"", ""time of day""); (""Java 8"", ""contains"", ""LocalTime""); (""LocalTime"", ""lacks"", ""time zone information"")"
"The LocalTime class is immutable, so all calculations on LocalTime objects return a new LocalTime instance.","(""LocalTime"", ""is"", ""class""); (""LocalTime"", ""is"", ""immutable""); (""LocalTime"", ""return"", ""LocalTime""); (""LocalTime"", ""calculations on"", ""LocalTime""); (""LocalTime"", ""has"", ""objects"")"
"There are also other versions of the of() method that only takes hours and minutes, or hours, minutes and seconds as parameters.","(""of()"", ""hasVersion"", ""of()""); (""of()"", ""takesParameter"", ""hours""); (""of()"", ""takesParameter"", ""minutes""); (""of()"", ""takesParameter"", ""seconds"")"
The LocalTime class contains a set of methods that enable you to perform local time calculations.,"(""LocalTime"", ""contains"", ""methods""); (""LocalTime"", ""enables"", ""local time calculations""); (""methods"", ""perform"", ""local time calculations""); (""LocalTime"", ""has"", ""set of methods"")"
The static method System.currentTimeMillis() returns the time since January 1st 1970 in milliseconds.,"(""System"", ""hasMethod"", ""System.currentTimeMillis()""); (""System.currentTimeMillis()"", ""returns"", ""time""); (""System"", ""returnsTimeSince"", ""January 1st 1970"")"
"The returned long value can be used to initialize java.util.Date, java.sql.Date, java.sql.Timestamp and java.util.GregorianCalendar objects.",
The granularity of the System.currentTimeMillis() method is larger than 1 millisecond.,"(""System"", ""hasMethod"", ""currentTimeMillis()""); (""currentTimeMillis()"", ""isPartOf"", ""System""); (""System.currentTimeMillis()"", ""hasGranularity"", ""millisecond"")"
Measuring time in Java is easiest to do with the System.currentTimeMillis() method.,"(""System"", ""hasMethod"", ""System.currentTimeMillis()""); (""Java"", ""uses"", ""System.currentTimeMillis()""); (""System.currentTimeMillis()"", ""returns"", ""time""); (""System"", ""belongsTo"", ""Java"")"
The variable totalTime will now contain the total time it took to execute the callOperationToTime() method.,"(""callOperationToTime()"", ""is method of"", ""unknown class""); (""callOperationToTime()"", ""returns value to"", ""totalTime""); (""totalTime"", ""stores result of"", ""callOperationToTime()"")"
"Because System.currentTimeMillis() does not return the time that accurately, it is a good idea to execute the operation to measure more than once.","(""System"", ""uses"", ""System.currentTimeMillis()""); (""System.currentTimeMillis()"", ""isusedby"", ""operation""); (""operation"", ""measures"", ""time""); (""System.currentTimeMillis()"", ""returns"", ""time"")"
"Another good reason to repeat the operation to measure a lot of times is to allow the Java virtual machine to load the classes containing the code, JIT-compile it, and perhaps even optimize it.","(""Java virtual machine"", ""load"", ""classes""); (""Java virtual machine"", ""JIT-compile"", ""code""); (""Java virtual machine"", ""optimize"", ""code""); (""classes"", ""contain"", ""code"")"
"The calculations listed earlier in this text are rather trivial yet tedious to do, and could be encapsulated in a Timer class.","(""Timer"", ""encapsulates"", ""calculations"")"
The ZonedDateTime class in the Java 8 date time API represents a date and time with time zone information.,"(""ZonedDateTime"", ""represents"", ""date and time with time zone information""); (""ZonedDateTime"", ""belongs to"", ""Java 8 date time API""); (""Java 8 date time API"", ""contains"", ""ZonedDateTime"")"
The first way is to call the now() method of the ZonedDateTime class.,"(""ZonedDateTime"", ""hasMethod"", ""now()""); (""ZonedDateTime"", ""isClassOf"", ""now()""); (""now()"", ""isMethodOf"", ""ZonedDateTime"")"
Here is an example of creating a ZonedDateTime object using the now() method:,"(""ZonedDateTime"", ""uses"", ""now()""); (""ZonedDateTime"", ""has method"", ""now()""); (""now()"", ""returns"", ""ZonedDateTime"")"
Another way to create a ZonedDateTime object is to use the of() method which can create a ZonedDateTime object from a concrete date and time.,"(""ZonedDateTime"", ""has method"", ""of()""); (""of()"", ""returns"", ""ZonedDateTime""); (""ZonedDateTime"", ""created from"", ""date and time"")"
Here is an example of creating a ZonedDateTime object using the of() method:,"(""ZonedDateTime"", ""uses"", ""of()""); (""ZonedDateTime"", ""hasMethod"", ""of()""); (""of()"", ""returns"", ""ZonedDateTime"")"
From the enums you can return an int representation of their value using their getValue() methods.,"(""enums"", ""has method"", ""getValue()"")"
The ZonedDateTime class contains a set of methods used for date time calculations.,"(""ZonedDateTime"", ""contains"", ""methods""); (""ZonedDateTime"", ""has"", ""set of methods""); (""ZonedDateTime"", ""used for"", ""date time calculations""); (""methods"", ""used for"", ""date time calculations""); (""ZonedDateTime"", ""has"", ""methods"")"
The time zones are represented by the ZoneId class as shown in the earlier example.,"(""ZoneId"", ""isRepresentedby"", ""time zones""); (""ZoneId"", ""shownIn"", ""earlier example""); (""earlier example"", ""contains"", ""ZoneId"")"
The parameter passed to the of() method is the ID of the time zone to create a ZoneId for.,"(""ZoneId"", ""created for"", ""time zone""); (""ZoneId"", ""has method"", ""of()""); (""of()"", ""takes parameter"", ""ID"")"
"You can find the UTC offset for the desired time zone and create an ID matching it by combining ""UTC"" with the offset (e.g.",
"If you need to set a date on a java.sql.PreparedStatement or get a date from a java.sql.ResultSet, you will interact with java.sql.Date.","(""java.sql.PreparedStatement"", ""set date on"", ""java.sql.Date""); (""java.sql.ResultSet"", ""get date from"", ""java.sql.Date""); (""java.sql.Date"", ""used with"", ""java.sql.PreparedStatement""); (""java.sql.Date"", ""used with"", ""java.sql.ResultSet"")"
"Actually, java.sql.Date extends java.util.Date, so anything you can do with a java.util.Date you can also do with a java.sql.Date.","(""java.sql.Date"", ""extends"", ""java.util.Date""); (""java.util.Date"", ""is extended by"", ""java.sql.Date"")"
"The biggest difference between java.sql.Date and java.util.Date is that the java.sql.Date only keeps the date, not the time, of the date it represents.","(""java.sql.Date"", ""represents"", ""date""); (""java.sql.Date"", ""differs from"", ""java.util.Date""); (""java.util.Date"", ""includes"", ""time""); (""java.sql.Date"", ""excludes"", ""time"")"
"So, for instance, if you create a java.sql.Date using the date and time 2009-12-24 23:20, then the time (23:20) would be cut off.","(""java.sql.Date"", ""uses"", ""date""); (""java.sql.Date"", ""uses"", ""time""); (""java.sql.Date"", ""creates"", ""instance""); (""instance"", ""has"", ""date""); (""instance"", ""has"", ""time"")"
"If you need to keep the time, use a java.sql.Timestamp instead.","(""java.sql.Timestamp"", ""is_a"", ""class""); (""java.sql.Timestamp"", ""used_in_place_of"", ""time"")"
"If you need to set a date + time on a java.sql.PreparedStatement or get a date + time from a java.sql.ResultSet, you will interact with java.sql.Timestamp.","(""java.sql.PreparedStatement"", ""interact with"", ""java.sql.Timestamp""); (""java.sql.ResultSet"", ""interact with"", ""java.sql.Timestamp""); (""java.sql.Timestamp"", ""used by"", ""java.sql.PreparedStatement""); (""java.sql.Timestamp"", ""used by"", ""java.sql.ResultSet"")"
"Actually, java.sql.Timestamp extends java.util.Date, so anything you can do with a java.util.Date you can also do with a java.sql.Timestamp.","(""java.sql.Timestamp"", ""extends"", ""java.util.Date"")"
"The biggest difference between java.sql.Date and java.sql.Timestamp is that the java.sql.Date only keeps the date, not the time, of the date it represents.","(""java.sql.Date"", ""represents"", ""date""); (""java.sql.Date"", ""keeps"", ""date""); (""java.sql.Timestamp"", ""represents"", ""date""); (""java.sql.Timestamp"", ""keeps"", ""time""); (""java.sql.Date"", ""differs from"", ""java.sql.Timestamp"")"
One difference in the java.sql.Timestamp from its superclass java.util.Date is its ability to hold the nanoseconds of a date too.,"(""java.sql.Timestamp"", ""is a subclass of"", ""java.util.Date""); (""java.sql.Timestamp"", ""has ability"", ""hold nanoseconds""); (""java.util.Date"", ""does not have ability"", ""hold nanoseconds"")"
You can get and set the nanoseconds using the getNanos() and setNanos().,"(""getNanos()"", ""used to get"", ""nanoseconds""); (""setNanos()"", ""used to set"", ""nanoseconds"")"
Java's java.util.Calendar class is used to do date and time arithmetic.,"(""Java"", ""has class"", ""java.util.Calendar""); (""java.util.Calendar"", ""is used for"", ""date and time arithmetic"")"
"Whenever you have something slightly more advanced than just representing a date and time, this is the class to use.",
"Java only comes with a Gregorian calendar implementation, the java.util.GregorianCalendar class.","(""Java"", ""comes with"", ""Gregorian calendar""); (""Java"", ""has"", ""java.util.GregorianCalendar class""); (""java.util.GregorianCalendar"", ""is a"", ""Gregorian calendar implementation"")"
"The Calendar class has a couple of methods you can use to access the year, month, day, hour, minutes, seconds, milliseconds and time zone of a given date.","(""Calendar"", ""has"", ""method to access year""); (""Calendar"", ""has"", ""method to access month""); (""Calendar"", ""has"", ""method to access day""); (""Calendar"", ""has"", ""method to access hour""); (""Calendar"", ""has"", ""method to access minutes""); (""Calendar"", ""has"", ""method to access seconds""); (""Calendar"", ""has"", ""method to access milliseconds""); (""Calendar"", ""has"", ""method to access time zone"")"
The Calendar class has a corresponding set() method so you can set these fields too.,"(""Calendar"", ""has"", ""set()"")"
"The add() method is really handy when doing date arithmetics like adding or subtracting years, months, days, hours etc.","(""add()"", ""is part of"", ""date arithmetics""); (""add()"", ""used for"", ""adding years""); (""add()"", ""used for"", ""subtracting years""); (""add()"", ""used for"", ""adding months""); (""add()"", ""used for"", ""subtracting months""); (""add()"", ""used for"", ""adding days""); (""add()"", ""used for"", ""subtracting days""); (""add()"", ""used for"", ""adding hours""); (""add()"", ""used for"", ""subtracting hours"")"
"To subtract from the fields call the add() method with negative values, like this:","(""add()"", ""called with"", ""negative values"")"
There are a few minor traps in the Calendar class that you should be aware of to avoid unnecessary headaches.,"(""Calendar"", ""has_traps"", ""headaches"")"
The MONTH field of the Calendar class does not go from 1 to 12 like they do when we write dates otherwise.,"(""Calendar"", ""has field"", ""MONTH"")"
"That means that 1 = sunday, 2 = monday, ..., 7 = saturday.",
If you need to do heavy or complex date and time calculations it is a good idea to read the class documentation for java.util.Calendar in the official JavaDoc's.,"(""java.util.Calendar"", ""is_part_of"", ""JavaDoc""); (""java.util.Calendar"", ""is_used_for"", ""date and time calculations""); (""JavaDoc"", ""contains"", ""java.util.Calendar"")"
The class documentation contains more detail about the specific behaviour of the class.,"(""class documentation"", ""contains"", ""class""); (""class"", ""has"", ""behaviour"")"
Today most of the methods in the class are deprecated in favor of the java.util.Calendar class.,"(""class"", ""uses"", ""java.util.Calendar""); (""java.util.Calendar"", ""replaces"", ""class"")"
You can still use the java.util.Date class to represent a date though.,"(""java.util.Date"", ""is used to represent"", ""date"")"
"You can access the date and time contained in a java.util.Date instance using the getTime() method, like this:","(""java.util.Date"", ""has method"", ""getTime()"")"
"You can also create a java.util.Date from a time in milliseconds, like this:","(""java.util.Date"", ""created from"", ""time in milliseconds"")"
You can compare java.util.Date instance because the class implements the java.lang.Comparable interface.,"(""java.util.Date"", ""implements"", ""java.lang.Comparable""); (""java.util.Date"", ""instance of"", ""java.util.Date""); (""java.lang.Comparable"", ""implemented by"", ""java.util.Date"")"
"The comparison follows the rules for the Comparable interface, meaning the compareTo() method returns:","(""Comparable"", ""has method"", ""compareTo()"")"
"The Java TimeZone class is a class that represents time zones, and is helpful when doing calendar arithmetics across time zones.","(""Java"", ""contains"", ""TimeZone""); (""TimeZone"", ""represents"", ""time zones""); (""TimeZone"", ""helpful for"", ""calendar arithmetics""); (""calendar arithmetics"", ""performed across"", ""time zones"")"
The java.util.TimeZone class is used in conjunction with the java.util.Calendar class.,"(""java.util.TimeZone"", ""used in conjunction with"", ""java.util.Calendar"")"
Note: In the Java 8 date time API the time zones are represented by the java.time.ZoneId class.,"(""java.time.ZoneId"", ""is represented by"", ""Java 8 date time API""); (""Java 8 date time API"", ""includes"", ""java.time.ZoneId""); (""java.time.ZoneId"", ""represents"", ""time zones"")"
But you only need to use the ZoneId class if you are using the Java 8 date time classes (like the ZonedDateTime class).,"(""ZoneId"", ""used with"", ""ZonedDateTime""); (""ZoneId"", ""used with"", ""Java 8 date time classes""); (""ZonedDateTime"", ""part of"", ""Java 8 date time classes"")"
If you use a Calendar (from the Java 7 and earlier date time API) you can still use the java.util.TimeZone class.,"(""Calendar"", ""uses"", ""java.util.TimeZone""); (""Calendar"", ""from"", ""Java 7""); (""Java 7"", ""includes"", ""java.util.TimeZone""); (""java.util.TimeZone"", ""class of"", ""Java 7"")"
The first method (TimeZone.getDefault()) returns the default time zone for the system (computer) this program is running on.,"(""TimeZone"", ""hasMethod"", ""getDefault()""); (""getDefault()"", ""returns"", ""default time zone""); (""default time zone"", ""belongsTo"", ""system""); (""TimeZone"", ""isUsedBy"", ""system""); (""system"", ""uses"", ""TimeZone""); (""getDefault()"", ""isMethodOf"", ""TimeZone"")"
"The second method (TimeZone.getTimeZone(""Europe/Copenhagen"")) returns the TimeZone corresponding to the given time zone ID (in this example ""Europe/Copenhagen"").","(""TimeZone"", ""getTimeZone"", ""Europe/Copenhagen""); (""TimeZone"", ""returns"", ""TimeZone""); (""getTimeZone"", ""corresponds to"", ""time zone ID""); (""getTimeZone"", ""takes"", ""Europe/Copenhagen""); (""TimeZone"", ""has method"", ""getTimeZone"")"
"The getOffset() method returns the offset in milliseconds for the given time zone to UTC, at the given time.","(""getOffset()"", ""returns"", ""offset""); (""getOffset()"", ""is method of"", ""unknown class""); (""time zone"", ""has relationship"", ""UTC""); (""getOffset()"", ""takes"", ""time zone""); (""getOffset()"", ""takes"", ""time"")"
The Calendar class is capable of converting the date and time between time zones.,"(""Calendar"", ""is capable of converting"", ""date""); (""Calendar"", ""is capable of converting"", ""time""); (""Calendar"", ""converts between"", ""time zones"")"
"Here is a list of the available time zone ids in the TimeZone class, printed as returned by TimeZone.getAvailableIDs().","(""TimeZone"", ""getAvailableIDs"", ""AvailableIDs""); (""TimeZone"", ""hasMethod"", ""getAvailableIDs()""); (""TimeZone.getAvailableIDs"", ""returns"", ""AvailableIDs"")"
"It is possible to both parse dates from strings, and format dates to strings, using Java's java.text.SimpleDateFormat class.","(""java.text.SimpleDateFormat"", ""uses"", ""Java""); (""java.text.SimpleDateFormat"", ""parses"", ""dates""); (""java.text.SimpleDateFormat"", ""formats"", ""dates""); (""java.text.SimpleDateFormat"", ""is part of"", ""Java"")"
It is also possible to parse and format dates using the newer Java DateTimeFormatter which is able to parse and format dates from and to the newer date time classes added in Java 8.,"(""Java DateTimeFormatter"", ""is able to parse and format dates from"", ""Java 8 date time classes""); (""Java DateTimeFormatter"", ""is able to parse and format dates to"", ""Java 8 date time classes""); (""Java 8"", ""added"", ""Java 8 date time classes""); (""Java DateTimeFormatter"", ""parse and format dates"", ""dates"")"
"Even though both classes for parsing and formatting dates are covered in more detail in their own texts, I will show you a few examples of how to use them below.",
Here is an example of how to format and parse a date using the SimpleDateFormat class.,"(""SimpleDateFormat"", ""uses"", ""date""); (""SimpleDateFormat"", ""has method"", ""format()""); (""SimpleDateFormat"", ""has method"", ""parse()"")"
The string passed as parameter to the SimpleDateFormat class is a pattern that tells how the instance is to parse and format dates.,"(""SimpleDateFormat"", ""is instance of"", ""class""); (""SimpleDateFormat"", ""has parameter"", ""string""); (""SimpleDateFormat"", ""parses"", ""dates""); (""SimpleDateFormat"", ""formats"", ""dates""); (""SimpleDateFormat"", ""uses"", ""pattern"")"
"For a full list, see the official JavaDoc for the SimpleDateFormat class.","(""SimpleDateFormat"", ""is documented in"", ""JavaDoc"")"
Another way to format dates is to use the DateTimeFormatter which works with the newer date time classes added in Java 8.,"(""DateTimeFormatter"", ""works with"", ""Java 8""); (""Java 8"", ""added"", ""date time classes""); (""DateTimeFormatter"", ""used for"", ""date formatting"")"
In the example above we use the DateTimeFormatter.BASIC_ISO_DATE instance which is configured to parse and format dates using the ISO date time format.,"(""DateTimeFormatter"", ""has instance"", ""DateTimeFormatter.BASIC_ISO_DATE""); (""DateTimeFormatter.BASIC_ISO_DATE"", ""is configured to"", ""parse dates""); (""DateTimeFormatter.BASIC_ISO_DATE"", ""is configured to"", ""format dates""); (""DateTimeFormatter.BASIC_ISO_DATE"", ""uses"", ""ISO date time format"")"
"Exceptions are regular Java classes that extends java.lang.Exception, or any of the other built-in exception classes.","(""Exceptions"", ""extends"", ""java.lang.Exception"")"
"If a method declares that it throws an exception A, then it is also legal to throw subclasses of A.","(""Exception"", ""is superclass of"", ""Subclass""); (""Method"", ""declares"", ""Exception""); (""Method"", ""throws"", ""Exception""); (""Method"", ""throws"", ""Subclass"")"
"In the example above the ""System.out.println(result);"" statement will not get executed if an exception is thrown fromt the divide method.","(""System"", ""hasMethod"", ""out.println()""); (""System"", ""hasMethod"", ""divide()""); (""divide"", ""throws"", ""exception"")"
"In the example above the ""System.out.println(""Division attempt done"");"" statement will always get executed.","(""System"", ""out"", ""println""); (""println"", ""executed by"", ""System""); (""System"", ""has method"", ""out""); (""println"", ""is method of"", ""System"")"
Here is how the callDivide() method would look in that case.,"(""callDivide"", ""method of"", ""unknown class"")"
"Thus the ""System.out.println(result);"" method will not get executed if an exception is thrown from the divide method.","(""System.out"", ""hasMethod"", ""println""); (""divide"", ""throws"", ""exception""); (""System.out.println"", ""willNotGetExecutedIf"", ""exceptionIsThrown""); (""divide"", ""throws"", ""exception""); (""System.out.println"", ""calledAfter"", ""divide"")"
"If the reader.read() method call throws an IOException, the following System.out.println((char) i ); is not executed.","(""reader"", ""hasMethod"", ""read()""); (""reader.read()"", ""throwsException"", ""IOException""); (""System.out"", ""hasMethod"", ""println""); (""reader.read()"", ""affectsExecution"", ""System.out.println"")"
"Neither is the last reader.close() or the System.out.println(""--- File End ---""); statements.","(""reader"", ""close"", """"); (""System.out"", ""println"", ""--- File End ---"")"
Instead the program skips directly to the catch(IOException e){ ... } catch clause.,"(""IOException"", ""thrown by"", ""catch clause"")"
"If an exception is thrown from the reader.read() method then program execution is halted, and the exception is passed up the call stack to the method that called openFile().","(""reader"", ""hasMethod"", ""read()""); (""read()"", ""throws"", ""exception""); (""exception"", ""isPassedTo"", ""openFile()""); (""openFile()"", ""isCalledBy"", ""method""); (""reader"", ""hasMethod"", ""openFile()""); (""read()"", ""isCalledBy"", ""method"")"
"If the calling method also just throws the method on, the calling method is also interrupted at the openFile() method call, and the exception passed on up the call stack.","(""calling method"", ""calls"", ""openFile()""); (""calling method"", ""throws"", ""exception""); (""openFile()"", ""throws"", ""exception""); (""calling method"", ""is interrupted at"", ""openFile()"")"
That is why the previous example had the reader.close() method call in the finally block wrapped in a try-catch block:,"(""reader"", ""hasMethod"", ""close()"")"
"That way the System.out.println(""--- File End ---""); method call will always be executed.","(""System"", ""out"", ""println""); (""println"", ""method call"", ""--- File End ---""); (""System"", ""method call"", ""println"")"
Notice how the two exception class names in the first catch block are separated by the pipe character |.,"(""catch block"", ""contains"", ""exception class""); (""exception class"", ""separated by"", ""pipe character""); (""pipe character"", ""separates"", ""exception class names"")"
The pipe character between exception class names is how you declare multiple exceptions to be caught by the same catch clause.,"(""exception"", ""is caught by"", ""catch clause""); (""catch clause"", ""catches"", ""exception""); (""exception class names"", ""are declared with"", ""pipe character""); (""pipe character"", ""declares"", ""multiple exceptions""); (""catch clause"", ""catches"", ""multiple exceptions""); (""multiple exceptions"", ""are declared with"", ""pipe character""); (""exception class names"", ""declare"", ""multiple exceptions""); (""catch clause"", ""is used with"", ""exception class names"")"
If storeDataFromUrl() wants to call readDataFromUrl() it has only two choices.,"(""storeDataFromUrl"", ""wants to call"", ""readDataFromUrl"")"
Notice how the readDataFromUrl() method no longer declares that it throws BadUrlException.,"(""readDataFromUrl()"", ""throws"", ""BadUrlException"")"
"The storeDataFromUrl() method can still choose to catch the exception but it no longer has to, and it no longer has to declare that it propagates the exception.","(""storeDataFromUrl()"", ""can catch"", ""exception""); (""storeDataFromUrl()"", ""declares"", ""exception""); (""storeDataFromUrl()"", ""propagates"", ""exception"")"
As you can see the readNumberFromUrl() needs to declare throwing both the BadUrlException and the BadNumberException that are thrown from the readDataFromUrl() and converData() methods.,"(""readNumberFromUrl()"", ""declares"", ""BadUrlException""); (""readNumberFromUrl()"", ""declares"", ""BadNumberException""); (""readNumberFromUrl()"", ""calls"", ""readDataFromUrl()""); (""readDataFromUrl()"", ""throws"", ""BadUrlException""); (""readNumberFromUrl()"", ""calls"", ""convertData()""); (""convertData()"", ""throws"", ""BadNumberException"")"
Imagine how many exceptions would need to be declared at the top level methods of an application with thousands of classes.,"(""application"", ""has"", ""methods""); (""methods"", ""declared at"", ""top level""); (""classes"", ""part of"", ""application""); (""application"", ""has"", ""classes""); (""methods"", ""handle"", ""exceptions"")"
As you can see the readNumberFromUrl() method now only declares throwing ApplicationException.,"(""readNumberFromUrl()"", ""declares throwing"", ""ApplicationException"")"
Notice how the readNumberFromUrl() method does not declare throwing the ApplicationException even if it throws it.,"(""readNumberFromUrl()"", ""does not declare throwing"", ""ApplicationException""); (""readNumberFromUrl()"", ""throws"", ""ApplicationException"")"
All exceptions thrown in the application must be a subclass of the base exception.,"(""Exception"", ""is a subclass of"", ""base exception"")"
As you know a method throwing Exception may also throw any subclass of Exception.,"(""Exception"", ""has subclass"", ""subclass of Exception""); (""Method"", ""throws"", ""Exception""); (""Method"", ""throws"", ""subclass of Exception"")"
They are subclasses of the ApplicationException so they will get propagated up the call stack.,"(""ApplicationException"", ""hasSubclass"", ""subclasses""); (""subclasses"", ""isSubclassOf"", ""ApplicationException""); (""call stack"", ""propagates"", ""subclasses""); (""call stack"", ""propagates"", ""ApplicationException""); (""ApplicationException"", ""propagatesUp"", ""call stack""); (""subclasses"", ""propagatesUp"", ""call stack"")"
Argument 5 (Pro Unchecked Exceptions) Checked exceptions declared on methods become part of a the class or interface contract.,"(""Method"", ""declared on"", ""Class""); (""Method"", ""declared on"", ""Interface""); (""Checked exceptions"", ""part of"", ""Class contract""); (""Checked exceptions"", ""part of"", ""Interface contract""); (""Method"", ""has"", ""Checked exceptions""); (""Class contract"", ""includes"", ""Checked exceptions""); (""Interface contract"", ""includes"", ""Checked exceptions"")"
The only requirement is that the new exceptions thrown are subclasses of the base exception.,"(""exceptions"", ""are subclasses of"", ""base exception"")"
Anders Hejlsberg on checked vs. unchecked exceptions http://www.artima.com/intv/handcuffs.html James Gosling on checked exceptions http://www.artima.com/intv/solid.html Bill Venners on Exceptions http://www.artima.com/interfacedesign/exceptions.html Bruce Eckel on checked exceptions http://www.artima.com/intv/typingP.html Designing with Exceptions (Bill Venners - www.artima.com) http://www.artima.com/designtechniques/desexcept.html Effective Java (Joshua Bloch - Addison Wesley 2001) Daniel Pietraru - in favor of checked exceptions Exceptional Java - Checked exceptions are priceless?For everything else there is the RuntimeException,"(""Effective Java"", ""writtenBy"", ""Joshua Bloch""); (""Effective Java"", ""publishedBy"", ""Addison Wesley""); (""Exceptional Java"", ""discusses"", ""Checked exceptions""); (""Checked exceptions"", ""advocatedBy"", ""Daniel Pietraru""); (""Checked exceptions"", ""opposedBy"", ""Anders Hejlsberg""); (""Checked exceptions"", ""discussedBy"", ""James Gosling""); (""Checked exceptions"", ""discussedBy"", ""Bruce Eckel""); (""RuntimeException"", ""usedFor"", ""everything else"")"
Checked exceptions declared on methods become part of a the class or interface contract.,"(""Exception"", ""declared on"", ""Method""); (""Method"", ""part of"", ""Class""); (""Method"", ""part of"", ""Interface""); (""Exception"", ""part of"", ""Class contract""); (""Exception"", ""part of"", ""Interface contract"")"
As you can see the method1() throws an EnrichableException which is a superclass for enrichable exceptions.,"(""method1()"", ""throws"", ""EnrichableException""); (""EnrichableException"", ""is superclass of"", ""enrichable exceptions"")"
"Notice how method2() calls the addInfo() method on the caught EnrichableException, and rethrow it afterwards.","(""EnrichableException"", ""has method"", ""addInfo()""); (""method2()"", ""calls"", ""addInfo()""); (""EnrichableException"", ""is thrown by"", ""method2()"")"
"Notice how method1() adds the code ""ERROR1"" to the thrown EnrichableException to uniquely identify that error cause.","(""EnrichableException"", ""hasMethod"", ""method1()""); (""EnrichableException"", ""thrownBy"", ""method1()""); (""method1()"", ""adds"", ""ERROR1""); (""EnrichableException"", ""contains"", ""ERROR1"")"
But notice too that method1() is called from both method2() and method3().,"(""method2()"", ""calls"", ""method1()""); (""method3()"", ""calls"", ""method1()"")"
"Though the error may seem the same to method1() no matter which of method2() and method3() that called it, this may important to know for the developer investigating the error.","(""method1()"", ""called by"", ""method2()""); (""method1()"", ""called by"", ""method3()"")"
Here is an example where the addInfo() method has been changed to accommodate this:,"(""addInfo()"", ""is method of"", ""undefined""); (""addInfo()"", ""has been changed in"", ""undefined"")"
Two new parameters have been added to the addInfo() method and the constructor of the EnrichableException.,"(""EnrichableException"", ""hasMethod"", ""addInfo()""); (""EnrichableException"", ""hasMethod"", ""constructor""); (""addInfo()"", ""isMethodOf"", ""EnrichableException""); (""constructor"", ""isMethodOf"", ""EnrichableException"")"
An error identification for an exception thrown by method1() when called from method2() will now look like this:,"(""method1"", ""thrown by"", ""method2""); (""method2"", ""calls"", ""method1""); (""method1"", ""has relationship"", ""exception""); (""method2"", ""has relationship"", ""exception"")"
When method1() is called from method3() the error identification will look like this:,"(""method3()"", ""calls"", ""method1()"")"
As you can see it is now possible to distinguish an exception thrown from method1() via method2() from the same exception thrown from method1() via method3().,"(""method1()"", ""thrown from"", ""method2()""); (""method1()"", ""thrown from"", ""method3()"")"
"Here is an example where method1() catches a non-enrichable exception and wraps it in an enrichable exception, and throws the enrichable exception:","(""method1()"", ""catches"", ""non-enrichable exception""); (""method1()"", ""wraps"", ""non-enrichable exception""); (""method1()"", ""throws"", ""enrichable exception""); (""non-enrichable exception"", ""is wrapped in"", ""enrichable exception"")"
Exceptions caught in the program will be passed to the handleException() which will decide what concrete exception to throw instead.,"(""handleException"", ""will decide what concrete exception to throw instead"", ""Exception""); (""program"", ""will pass exceptions to"", ""handleException()""); (""handleException"", ""will throw"", ""concrete exception"")"
If the EnrichableException is unchecked it is not necessary to declare it in the handleException() method.,"(""EnrichableException"", ""is"", ""unchecked""); (""handleException()"", ""method"", ""declare""); (""EnrichableException"", ""declared in"", ""handleException()"")"
You may need to change the class definition to suit your own needs.,"(""class"", ""definition"", ""class"")"
"If an exception is thrown from within the try block, and another exception is thrown from the input.close() call in the finally block, both exceptions are preserved in the MyException instance, and propagated up the call stack.","(""MyException"", ""hasMethod"", ""MyException.instance()""); (""try"", ""contains"", ""input.close()""); (""finally"", ""contains"", ""input.close()""); (""MyException"", ""preserves"", ""exception""); (""exception"", ""isThrownFrom"", ""try""); (""exception"", ""isThrownFrom"", ""input.close()""); (""MyException"", ""propagates"", ""exception"")"
"RuntimeExceptions thrown from the try-block are not preserved, if the input.close() call also throws an exception.","(""RuntimeException"", ""thrown from"", ""try-block""); (""try-block"", ""contains"", ""input.close()""); (""input.close()"", ""throws"", ""exception"")"
Notice how the process() method calls the doProcess() method inside the try-catch block.,"(""process()"", ""calls"", ""doProcess()"")"
"You will use the template by subclassing it, and overriding the doProcess() method.","(""template"", ""has method"", ""doProcess()""); (""User"", ""overrides method"", ""doProcess()""); (""template"", ""is subclassed by"", ""User"")"
"This example creates an anonymous subclass of the InputStreamProcessingTemplate class, instantiates an instance of the subclass, and calls its process() method.","(""InputStreamProcessingTemplate"", ""has method"", ""process()""); (""InputStreamProcessingTemplate"", ""is subclass of"", ""anonymous subclass""); (""anonymous subclass"", ""has method"", ""process()"")"
"You will typically also get more help from your IDE's code completion when writing it, because the IDE will recognize both the doProcess() and process() methods.","(""doProcess()"", ""recognized by"", ""IDE's code completion""); (""process()"", ""recognized by"", ""IDE's code completion"")"
Instead of subclassing the InputStreamProcessingTempate you could rewrite it to take an instance of an InputStreamProcessor interface.,"(""InputStreamProcessingTempate"", ""subclassed by"", ""InputStreamProcessor""); (""InputStreamProcessor"", ""implemented by"", ""InputStreamProcessingTempate""); (""InputStreamProcessingTempate"", ""uses"", ""InputStreamProcessor"")"
"This is the InputStreamProcessor, which is called from inside the try block (processor.process(input)).","(""InputStreamProcessor"", ""is called from"", ""try block""); (""processor"", ""has method"", ""process()""); (""processor.process()"", ""takes parameter"", ""input""); (""InputStreamProcessor"", ""has method"", ""process()"")"
"It doesn't look much different from the previous usage, except the call to the InputStreamProcessingTemplate.process() method is now closer to the top of the code.","(""InputStreamProcessingTemplate"", ""hasMethod"", ""process()"")"
Notice how the call to the template's process() method is now a static method call.,"(""template"", ""has method"", ""process()"")"
"The advantage of exception hierarchies is that if you decide to catch (using try-catch) a certain exception in the hierarchy, then you will automatically also catch all subclasses of that exception too.","(""Exception"", ""has subclasses"", ""Subclasses""); (""try-catch"", ""catches"", ""Exception""); (""Exception"", ""is caught by"", ""try-catch""); (""Subclasses"", ""are caught by"", ""try-catch"")"
"In the example with FileNotFoundException, if you catch IOException which is the superclass of FileNotFoundException, you will also catch FileNotFoundException.","(""IOException"", ""is superclass of"", ""FileNotFoundException""); (""IOException"", ""catches"", ""FileNotFoundException""); (""FileNotFoundException"", ""is subclass of"", ""IOException"")"
"But, multiple catch blocks can also be used in the case where all the exceptions thrown inside the try-block are the same type or subclasses of that type.",
"The fact that FileNotFoundException is a subclass of IOException gives us the choice of either treating all IOExceptions the same, or catch some of IOExceptions subclasses individually, as is done in the code example above.","(""FileNotFoundException"", ""is a subclass of"", ""IOException"")"
"If the catch(FileNotFoundException e) block is removed any FileNotFoundException will be caught by the catch(IOException e) block, since FileNotFoundException is a subclass of IOException.",
"If a method can throw either a certain exception A, or any subclasses of A (Asub), then it is enough to declare in the method declaration that the method throws A.","(""Method"", ""throws"", ""Exception A""); (""Exception A"", ""hasSubclasses"", ""Asub""); (""Method"", ""throws"", ""Asub"")"
It is then allowed to throw subclasses of A from the method too.,"(""A"", ""is superclass of"", ""subclasses of A"")"
"You are allowed to declare the subclasses in the throws clause of the method, even if you don't really need to.","(""Method"", ""has"", ""throws clause""); (""throws clause"", ""contains"", ""subclasses""); (""Subclasses"", ""are declared in"", ""throws clause""); (""Method"", ""declares"", ""subclasses"")"
"As long as the superclass of any declared exception is also declared thrown, it doesn't have any effect on the code to include the throwing of the subclass.","(""Exception"", ""is superclass of"", ""declared exception""); (""Declared exception"", ""is subclass of"", ""superclass""); (""Superclass"", ""is declared thrown"", ""declared exception""); (""Subclass"", ""is thrown"", ""code""); (""Declared exception"", ""is declared thrown"", ""code""); (""Superclass"", ""is declared thrown"", ""code"")"
"It is still possible to handle the two exceptions with each their own catch-block as shown earlier, even if only the superclass is declared thrown.",
"If you need more granularity on the exceptions thrown, for instance because you think the exceptions may be handled differently, then add new exceptions as subclasses of your API or application base exception.","(""API"", ""has"", ""exceptions""); (""exceptions"", ""are handled by"", ""application""); (""exceptions"", ""are subclasses of"", ""base exception""); (""base exception"", ""is part of"", ""API""); (""application"", ""has"", ""base exception"")"
"In Mr. Persister we could add a ConnectionOpenException, QueryException, UpdateException, CommitException, and ConnectionCloseException as subclasses of PersistenceException.","(""ConnectionOpenException"", ""is a subclass of"", ""PersistenceException""); (""QueryException"", ""is a subclass of"", ""PersistenceException""); (""UpdateException"", ""is a subclass of"", ""PersistenceException""); (""CommitException"", ""is a subclass of"", ""PersistenceException""); (""ConnectionCloseException"", ""is a subclass of"", ""PersistenceException"")"
Summary In this text we have seen that exception hierarchies can be created by subclassing exception classes.,"(""Exception"", ""isSubclassedBy"", ""ExceptionClass""); (""ExceptionClass"", ""isSubclassOf"", ""Exception""); (""ExceptionClass"", ""canBeCreated"", ""ExceptionHierarchies"")"
"It is a good idea to create a base exception for your API or application, and have all other exceptions subclass this base exception.","(""Exception"", ""subclass"", ""base exception""); (""base exception"", ""subclassed by"", ""other exceptions"")"
Individual subclasses makes it possible (but not obligatory) to catch and handle these individual exceptions differently.,
In this text we have seen that exception hierarchies can be created by subclassing exception classes.,"(""exception"", ""can be created by"", ""subclassing""); (""exception classes"", ""are subclassed by"", ""exception hierarchies""); (""exception hierarchies"", ""are created by"", ""subclassing exception classes"")"
Exception wrapping is a standard feature in Java since JDK 1.4.,"(""JDK"", ""hasFeature"", ""Exception wrapping""); (""JDK"", ""hasVersion"", ""1.4""); (""Java"", ""hasFeature"", ""Exception wrapping""); (""JDK"", ""isPartOf"", ""Java"")"
They also have a getCause() method that will return the wrapped exception.,"(""getCause()"", ""method of"", ""Exception""); (""Exception"", ""has method"", ""getCause()"")"
"When a request is successfully processed, you can write the whole execution context object to a log file, as a single, coherent structure (e.g.",
"It's implemented as a single class called ExecutionContext, which keeps all calls to it internally in a list.","(""ExecutionContext"", ""has"", ""list""); (""ExecutionContext"", ""keeps"", ""calls"")"
Notice how each method ( level1() to level3() ) calls the ExecutionContext.,"(""level1()"", ""calls"", ""ExecutionContext""); (""level2()"", ""calls"", ""ExecutionContext""); (""level3()"", ""calls"", ""ExecutionContext"")"
"Therefore, I have developed an ExecutionContextTree class, which can contain this information.","(""ExecutionContextTree"", ""contains"", ""information""); (""ExecutionContextTree"", ""is_a"", ""class"")"
"The pre() call creates a new node, and attaches it to the parent node (if any).","(""pre()"", ""creates"", ""node""); (""pre()"", ""attaches to"", ""parent node""); (""node"", ""has"", ""parent node"")"
"Any calls to pre() after this one, will result in new nodes being attached to the newly created node.",
The post() call removes the node as the current parent in the execution tree.,"(""post()"", ""removes"", ""node""); (""node"", ""is"", ""parent""); (""execution tree"", ""has"", ""node""); (""post()"", ""modifies"", ""execution tree""); (""node"", ""is removed by"", ""post()"")"
The next call to pre() will now attach a node to the parent of the node just removed as parent node.,"(""node"", ""attach to"", ""parent node""); (""parent node"", ""is parent of"", ""node""); (""node"", ""removed from"", ""parent node"")"
"As you can see, the pre() and post() calls are very often insert at the start and end of a method call.","(""pre()"", ""is called at"", ""start of method call""); (""post()"", ""is called at"", ""end of method call""); (""method call"", ""has"", ""pre() call""); (""method call"", ""has"", ""post() call"")"
"If the input.close() call fails, and an IOException is thrown, then it is caught, wrapped and rethrown.","(""input"", ""calls"", ""close()""); (""input"", ""throws"", ""IOException""); (""IOException"", ""is"", ""caught""); (""IOException"", ""is"", ""wrapped""); (""IOException"", ""is"", ""rethrown"")"
All classes implementing this interface can be used inside the try-with-resources construct.,"(""AutoCloseable"", ""implements"", ""interface""); (""classes"", ""used in"", ""try-with-resources construct""); (""interface"", ""used in"", ""try-with-resources construct""); (""AutoCloseable"", ""extends"", ""interface"")"
The Java try-with-resources construct does not just work with Java's built-in classes.,"(""Java"", ""has"", ""try-with-resources construct""); (""try-with-resources construct"", ""works with"", ""built-in classes""); (""Java"", ""has"", ""built-in classes"")"
"You can also implement the java.lang.AutoCloseable interface in your own classes, and use them with the try-with-resources construct.","(""java.lang.AutoCloseable"", ""implemented in"", ""custom classes""); (""custom classes"", ""used with"", ""try-with-resources construct""); (""java.lang.AutoCloseable"", ""used with"", ""try-with-resources construct"")"
Any class that implements this interface can be used with the Java try-with-resources construct.,"(""Java"", ""implements"", ""interface""); (""interface"", ""used with"", ""Java try-with-resources construct"")"
Here is the output printed to System.out when the method myAutoClosable() is called:,"(""System.out"", ""printed to"", ""output""); (""myAutoClosable()"", ""called"", ""method""); (""System.out"", ""is used by"", ""myAutoClosable()"")"
"If an exception is thrown both from inside the try-with-resources block, and when a resource is closed (when close() is called), the exception thrown inside the try block will be propagated up the call stack.","(""try-with-resources"", ""has method"", ""close()""); (""try block"", ""throws"", ""exception""); (""close()"", ""throws"", ""exception""); (""exception"", ""propagated by"", ""call stack""); (""call stack"", ""handles"", ""exception""); (""try block"", ""contains"", ""resource""); (""resource"", ""has method"", ""close()"")"
"In that case, the exception thrown when attempted closed will be propagated up the call stack to the main() method where the try-catch block will catch it.","(""main()"", ""has try-catch block"", ""try-catch block""); (""exception"", ""is thrown by"", ""attempted closed""); (""exception"", ""is propagated to"", ""main()""); (""main()"", ""has"", ""try-catch block""); (""attempted closed"", ""throws"", ""exception""); (""try-catch block"", ""catches"", ""exception"")"
"In that case, the Throwable array returned from e.getSuppessed() will be an empty array (size of 0).","(""e"", ""getSuppressed()"", ""Throwable"")"
"In case the parameter to resourceOne.doOp() was changed to true also, the doOp() method would throw an exception.","(""resourceOne"", ""hasMethod"", ""doOp()""); (""doOp()"", ""throws"", ""exception""); (""resourceOne.doOp()"", ""calledWith"", ""true"")"
"In that case, it is this exception that is propagated up the call stack to the main() method.","(""exception"", ""is propagated up the call stack to"", ""main()"")"
The exception thrown when attempting to close the resource would be available inside the Throwable array returned by e.getSuppressed().,"(""Throwable"", ""returned by"", ""e.getSuppressed()""); (""e"", ""has method"", ""e.getSuppressed()""); (""e.getSuppressed()"", ""returns"", ""Throwable"")"
"However, in the example above I have forced both resources to throw an exception when attempted closed, and the first resource to throw an exception when used (when doOp() is called).","(""Resource"", ""throw"", ""Exception""); (""Resource"", ""attempted closed"", ""Exception""); (""doOp()"", ""called"", ""Resource""); (""Resource"", ""throw"", ""Exception""); (""Resource"", ""used"", ""doOp()"")"
The two exceptions thrown when attempting to close the resources are available in the Throwable array returned by e.getSuppressed().,"(""Throwable"", ""hasMethod"", ""getSuppressed()""); (""getSuppressed()"", ""returns"", ""array"")"
"In case an exception is thrown when attempting to close one of the resources, these exceptions will be available from the exception's getSuppressed() method inside the catch block.","(""Exception"", ""hasMethod"", ""getSuppressed()""); (""getSuppressed()"", ""returns"", ""exceptions""); (""catch block"", ""contains"", ""getSuppressed()""); (""Exception"", ""isCaughtBy"", ""catch block"")"
"In the example above, the AutoClosableResource is configured to throw an exception both when doOp() is called, and when it is attempted closed (via close()).","(""AutoClosableResource"", ""hasMethod"", ""doOp()""); (""AutoClosableResource"", ""hasMethod"", ""close()"")"
"The exception thrown from doOp() is caught in the catch block, its getSuppressed() method returns an array with the exception thrown when the resource was attempted closed.","(""doOp()"", ""throws"", ""exception""); (""exception"", ""has method"", ""getSuppressed()""); (""getSuppressed()"", ""returns"", ""array""); (""exception"", ""thrown when"", ""resource closed"")"
"The getSuppressed() method of that exception will return an empty array, since no exceptions where suppressed.","(""exception"", ""hasMethod"", ""getSuppressed()""); (""getSuppressed()"", ""returns"", ""array""); (""exception"", ""suppresses"", ""exceptions"")"
The Throwable class has a method named addSuppressed() which takes a Throwable object as parameter.,"(""Throwable"", ""has method"", ""addSuppressed()""); (""addSuppressed()"", ""takes parameter"", ""Throwable"")"
"Using the addSuppressed() method it is possible to add suppressed exceptions to another exception, in case you need that.","(""addSuppressed()"", ""method of"", ""Exception""); (""Exception"", ""has method"", ""addSuppressed()""); (""addSuppressed()"", ""adds to"", ""Exception"")"
"To understand why, look at the following method which reads a file and prints it to the System.out:","(""System.out"", ""prints to"", ""file""); (""file"", ""read by"", ""method""); (""method"", ""prints to"", ""System.out"")"
"The InputStream's close() method may throw an exception too, if closing it fails.","(""InputStream"", ""has method"", ""close()""); (""close()"", ""may throw"", ""exception""); (""InputStream"", ""has method"", ""close()"")"
You will have to code your own exception class in order to make exception enrichment possible.,"(""Exception"", ""is used in"", ""exception enrichment"")"
"However, the ExceptionHandler can throw all the unchecked exceptions it wants (RuntimeException and subclasses of it).","(""ExceptionHandler"", ""can throw"", ""RuntimeException""); (""RuntimeException"", ""has subclasses"", ""subclasses of RuntimeException""); (""ExceptionHandler"", ""can throw"", ""subclasses of RuntimeException"")"
"In contrast, inside a DAO class you will most likely not be able to interact with the user to correct the error.","(""DAO"", ""contains"", ""class""); (""DAO"", ""interacts with"", ""user""); (""DAO"", ""corrects"", ""error""); (""class"", ""is inside"", ""DAO""); (""user"", ""is interacted with"", ""DAO""); (""error"", ""is corrected by"", ""DAO"")"
In this example the validate() method throws an exception as soon as an validation error is found.,"(""validate()"", ""throws"", ""exception""); (""exception"", ""is thrown by"", ""validate()""); (""validate()"", ""finds"", ""validation error"")"
"Notice how it is not necessary to cast the object obtained from the List.get() method call, as is normally necessary.","(""List"", ""get"", ""object""); (""List"", ""get"", ""List.get()""); (""List.get"", ""obtained from"", ""object""); (""List.get"", ""call"", ""object"")"
Notice how it is not necessary to cast the object returned from the iterator.next() next call.,"(""iterator"", ""hasMethod"", ""next()""); (""iterator"", ""returns"", ""object""); (""object"", ""isReturnedBy"", ""next()"")"
"Adding and getting elements to a generic Map is done using the put() and get() methods, just like you have always done:","(""Map"", ""uses"", ""put()""); (""Map"", ""uses"", ""get()"")"
Also notice how it is not necessary to cast the String instance returned by the get() method.,"(""String"", ""returned by"", ""get()""); (""String"", ""instance of"", ""get()""); (""get()"", ""returns"", ""String"")"
Most often you iterate the key Set and access the values for each key via the Map.get() method.,"(""Map"", ""has method"", ""get()""); (""Map"", ""returns"", ""values""); (""Set"", ""is part of"", ""Map""); (""Map"", ""has relationship with"", ""key""); (""Map.get()"", ""accesses"", ""values"")"
"Adding elements to a generic Set is done using the add() method, just like you have always done:","(""Set"", ""hasMethod"", ""add()"")"
Generics is not restricted to the predefined classes in the Java API's.,"(""Java API"", ""contains"", ""Generics""); (""Java API"", ""has"", ""predefined classes""); (""Generics"", ""not restricted to"", ""predefined classes""); (""Java API"", ""includes"", ""predefined classes""); (""Generics"", ""used in"", ""Java API"")"
The <T> is a type token that signals that this class can have a type set when instantiated.,"(""T"", ""is a type of"", ""type token"")"
Notice how it is not necessary to cast the object returned from the factory.createInstance() method.,"(""factory"", ""createInstance"", ""object"")"
Notice how we can call the addAndReturn() method using both String's and Integer's and their corresponding collections.,"(""String"", ""has method"", ""addAndReturn()""); (""Integer"", ""has method"", ""addAndReturn()""); (""String"", ""corresponds to collection"", ""collection""); (""Integer"", ""corresponds to collection"", ""collection"")"
"Java Generic's wildcards is a mechanism in Java Generics aimed at making it possible to cast a collection of a certain class, e.g A, to a collection of a subclass or superclass of A.","(""Java Generics"", ""has mechanism"", ""wildcards""); (""Java Generics"", ""aims at"", ""making collection cast possible""); (""Collection"", ""has class"", ""A""); (""A"", ""has subclass"", ""subclass of A""); (""A"", ""has superclass"", ""superclass of A""); (""Collection"", ""can be cast to"", ""collection of subclass of A""); (""Collection"", ""can be cast to"", ""collection of superclass of A"")"
"In listA you can insert objects that are either instances of A, or subclasses of A (B and C).","(""A"", ""is superclass of"", ""B""); (""A"", ""is superclass of"", ""C""); (""B"", ""is subclass of"", ""A""); (""C"", ""is subclass of"", ""A"")"
When you then try to take objects out of listB you could risk to get non-B objects out (e.g.,
Thus you could insert non-B objects into a list declared to hold B (or B subclass) instances.,
"Imagine you have a method that processes the elements of a List, e.g.","(""List"", ""has elements"", ""elements""); (""method"", ""processes"", ""List""); (""List"", ""has"", ""elements"")"
The processElements() method can now be called with any generic List as parameter.,"(""processElements()"", ""called with"", ""List"")"
"When you know that the instances in the collection are of instances of A or subclasses of A, it is safe to read the instances of the collection and cast them to A instances.","(""A"", ""is a superclass of"", ""subclasses of A""); (""A"", ""has instances of"", ""instances in the collection""); (""instances in the collection"", ""are cast to"", ""A""); (""subclasses of A"", ""are instances of"", ""A""); (""A"", ""has subclasses"", ""subclasses of A"")"
"You can now call the processElements() method with either a List<A>, List<B> or List<C>.","(""processElements()"", ""is method of"", ""unspecified class""); (""List<A>"", ""is type parameter of"", ""processElements()""); (""List<B>"", ""is type parameter of"", ""processElements()""); (""List<C>"", ""is type parameter of"", ""processElements()"")"
"super A> means that the list is typed to either the A class, or a superclass of A.","(""super"", ""means"", ""list""); (""list"", ""is typed to"", ""A class""); (""A class"", ""has superclass"", ""superclass of A"")"
"When you know that the list is typed to either A, or a superclass of A, it is safe to insert instances of A or subclasses of A (e.g.","(""A"", ""is superclass of"", ""A""); (""A"", ""has subclasses"", ""subclasses of A"")"
"All of the elements inserted here are either A instances, or instances of A's superclass.","(""A"", ""is superclass of"", ""A's subclass""); (""A"", ""has instances of"", ""A instances""); (""A's superclass"", ""has instances of"", ""A instances"")"
"Since both B and C extend A, if A had a superclass, B and C would also be instances of that superclass.","(""B"", ""extend"", ""A""); (""C"", ""extend"", ""A"")"
"You can now call insertElements() with either a List<A>, or a List typed to a superclass of A.","(""List"", ""has method"", ""insertElements()""); (""insertElements()"", ""called with"", ""List<A>""); (""List<A>"", ""is subtype of"", ""List""); (""A"", ""has superclass"", ""superclass of A""); (""List"", ""typed to"", ""superclass of A"")"
"The insertElements() method cannot read from the list though, except if it casts the read objects to Object.","(""insertElements()"", ""cannot read from"", ""list""); (""insertElements()"", ""casts"", ""objects""); (""insertElements()"", ""casts to"", ""Object"")"
"The elements already present in the list when insertElements() is called could be of any type that is either an A or superclass of A, but it is not possible to know exactly which class it is.","(""insertElements"", ""called on"", ""list""); (""list"", ""contains elements of type"", ""A""); (""A"", ""has superclass"", ""superclass of A"")"
"However, since any class eventually subclass Object you can read objects from the list if you cast them to Object.","(""Object"", ""is superclass of"", ""any class""); (""any class"", ""is subclass of"", ""Object""); (""Object"", ""can be cast to"", ""any class""); (""any class"", ""can be read as"", ""Object"")"
Here are a few examples of calls to the getInstance() method:,"(""getInstance()"", ""is a method of"", ""unknown class"")"
As you can see the return type changes depending on what class object you pass in as parameter to the method.,"(""Method"", ""has parameter"", ""Class""); (""Method"", ""returns"", ""Type""); (""Class"", ""passed to"", ""Method"")"
It is possible to use your own collection type classes with the new for-loop.,"(""Collection"", ""used with"", ""for-loop"")"
And here is the corresponding implementation skeleton of the MyIterator class:,"(""MyIterator"", ""is Implemented By"", ""implementation skeleton""); (""MyIterator"", ""is a"", ""class""); (""implementation skeleton"", ""corresponds to"", ""MyIterator"")"
Generics add a way to specify concrete types to general purpose classes and methods that operated on Object before.,"(""Generics"", ""add to"", ""classes""); (""Generics"", ""add to"", ""methods""); (""classes"", ""operated on"", ""Object""); (""methods"", ""operated on"", ""Object"")"
"Note: Java generics can be used with other classes than the collection classes, but it is easiest to show the basics of Java generics using collections.","(""Java"", ""uses"", ""generics""); (""generics"", ""can be used with"", ""classes""); (""collections"", ""show"", ""generics""); (""Java"", ""uses"", ""collections""); (""generics"", ""used with"", ""collection classes"")"
"When you just write a diamond operator as generic type, the Java compiler will assume that the class instantiated is to have the same type as the variable it is assigned to.","(""Java compiler"", ""assumes type of"", ""class instantiated""); (""Java compiler"", ""assigns to"", ""variable""); (""class instantiated"", ""has type of"", ""variable"")"
This for-loop is shorter than original while-loop where you would iterate the collections Iterator and call Iterator.next() to obtain the next instance.,"(""Iterator"", ""hasMethod"", ""next()""); (""Iterator"", ""isUsedIn"", ""for-loop""); (""Iterator"", ""isUsedIn"", ""while-loop""); (""for-loop"", ""isComparedTo"", ""while-loop""); (""while-loop"", ""uses"", ""Iterator""); (""Iterator"", ""isPartOf"", ""collections"")"
It is of course possible to use Generics for other classes than the Java collections.,"(""Java"", ""uses"", ""Generics""); (""Generics"", ""used for"", ""Java collections"")"
"Using Java generics in your own classes is described in more detail in the tutorials about generic classes, generic methods and using class objects as type literals.","(""Java"", ""uses"", ""generics""); (""generics"", ""described in"", ""tutorials""); (""tutorials"", ""include"", ""generic classes""); (""tutorials"", ""include"", ""generic methods""); (""tutorials"", ""include"", ""class objects""); (""class objects"", ""used as"", ""type literals"")"
The java.text.DateFormat class is used to format dates as strings according to a specific Locale.,"(""java.text.DateFormat"", ""used to format dates with"", ""Locale""); (""java.text.DateFormat"", ""is used in"", ""date formatting""); (""Locale"", ""is used with"", ""java.text.DateFormat"")"
You create a DateFormat using the getDateInstance() and getTimeInstance() method of the DateFormat class.,"(""DateFormat"", ""uses"", ""getDateInstance()""); (""DateFormat"", ""uses"", ""getTimeInstance()""); (""DateFormat"", ""has method"", ""getDateInstance()""); (""DateFormat"", ""has method"", ""getTimeInstance()"")"
The date format parameter can be chosen among the following constants in the DateFormat class:,"(""DateFormat class"", ""has constants"", ""date format parameter""); (""DateFormat class"", ""contains"", ""constants""); (""constants"", ""are in"", ""DateFormat class""); (""DateFormat class"", ""defines"", ""date format parameter"")"
"In order to format only time and not the date itself, you need a time instance of the DateFormat class.","(""DateFormat"", ""has instance"", ""time instance""); (""DateFormat"", ""used for"", ""formatting time""); (""time instance"", ""is instance of"", ""DateFormat"")"
The java.text.DecimalFormat class is used to format numbers using a formatting pattern you specify yourself.,
This text explains how to use the DecimalFormat class to format different types of numbers.,"(""DecimalFormat"", ""used to format"", ""numbers""); (""DecimalFormat"", ""class"", ""numbers""); (""DecimalFormat"", ""formats"", ""different types of numbers"")"
You can change this pattern later using the applyPattern() or applyLocalizedPattern() method.,"(""applyPattern()"", ""is method of"", ""unknown class""); (""applyLocalizedPattern()"", ""is method of"", ""unknown class"")"
The applyPattern() method simply applies a new pattern to the DecimalFormat instance as if it were created with that pattern.,"(""DecimalFormat"", ""has method"", ""applyPattern()""); (""applyPattern()"", ""applies to"", ""DecimalFormat""); (""DecimalFormat"", ""created with"", ""pattern"")"
The applyLocalizedPattern() does the same as applyPattern() except it interpretes the characters in the pattern according to the Locale the DecimalFormat was created with.,"(""DecimalFormat"", ""has method"", ""applyLocalizedPattern()""); (""applyLocalizedPattern()"", ""similar to"", ""applyPattern()""); (""DecimalFormat"", ""created with"", ""Locale"")"
You format a number using the format() method of the DecimalFormat instance.,"(""DecimalFormat"", ""has method"", ""format()"")"
"For a full explanation of what these methods do, see the JavaDoc for the DecimalFormatSymbols class.","(""DecimalFormatSymbols"", ""hasJavaDoc"", ""JavaDoc"")"
The DecimalFormat class has a method called setGroupingSize() which sets how many digits of the integer part to group.,"(""DecimalFormat"", ""has method"", ""setGroupingSize()"")"
"The java.text.BreakIterator class is used to find character, word and sentence boundaries across different languages.","(""java.text.BreakIterator"", ""is used to find"", ""character boundaries""); (""java.text.BreakIterator"", ""is used to find"", ""word boundaries""); (""java.text.BreakIterator"", ""is used to find"", ""sentence boundaries""); (""java.text.BreakIterator"", ""is used across"", ""different languages"")"
You create an instance that can recognize one of the above boundaries using the corresponding factory method in the BreakIterator class.,"(""BreakIterator"", ""has method"", ""create instance factory method""); (""BreakIterator"", ""recognizes"", ""boundaries"")"
"A character instance of the BreakIterator class finds character boundaries for user characters, not unicode characters.","(""BreakIterator"", ""finds"", ""character boundaries""); (""BreakIterator"", ""is instance of"", ""character""); (""character boundaries"", ""are found for"", ""user characters""); (""BreakIterator"", ""distinguishes between"", ""user characters""); (""BreakIterator"", ""distinguishes between"", ""unicode characters"")"
"This example creates a BreakIterator targeted at the British language, and sets the text to find character breaks in using the setText() method.","(""BreakIterator"", ""targeted at"", ""British language""); (""BreakIterator"", ""sets text to"", ""text""); (""BreakIterator"", ""uses method"", ""setText()"")"
"Again, here the first() and next() methods return the unicode index of the found word boundary.","(""first()"", ""returns"", ""unicode index""); (""next()"", ""returns"", ""unicode index"")"
"Notice how the isWord() method uses the Character.isLetterOrDigit() method to determine if a character is a letter or digit, or something else (like semicolon, quote etc.).","(""Character"", ""uses"", ""isLetterOrDigit()""); (""isWord()"", ""uses"", ""Character.isLetterOrDigit()"")"
"The Character.isLetterOrDigit() checks according to the unicode characters if a character is a letter or digit - and thus not just in the english language, but also in other languages.","(""Character"", ""hasMethod"", ""isLetterOrDigit()"")"
Java has some methods in the java.lang.Character class that are useful in internationalization of Java applications.,"(""Java"", ""has"", ""java.lang.Character""); (""java.lang.Character"", ""contains"", ""methods"")"
"To safely check if a character is a letter, number or space character you need to use the methods in java.lang.Character to do so.",
The Character class also has a getType() method which returns the type of a certain character.,"(""Character"", ""has"", ""getType()""); (""Character"", ""has method"", ""getType()""); (""getType()"", ""returns"", ""type""); (""Character"", ""returns"", ""type""); (""Character"", ""has method"", ""getType()"")"
The returned type is an int which matches a set of predefined constants in the Character class.,"(""Character"", ""has"", ""predefined constants""); (""Character"", ""returns"", ""int"")"
Look in the JavaDoc for the Character class for more constants.,"(""Character"", ""has"", ""constants""); (""JavaDoc"", ""contains"", ""Character"")"
The Character class also has a method that enables you to determine if the value of a given int defines a character in unicode.,"(""Character"", ""has method"", ""defines character in unicode""); (""Character"", ""has method"", ""determine if int defines character""); (""Character"", ""enables"", ""determine if int defines character in unicode"")"
"Thus, simply using the String.compareTo() method may not work for all languages.","(""String"", ""compareTo"", ""method""); (""String"", ""hasMethod"", ""compareTo()"")"
"To sort a collection of strings according to the rules of a certain Locale, you use a java.text.Collator instance created for that specific Locale.","(""java.text.Collator"", ""created for"", ""Locale""); (""java.text.Collator"", ""use"", ""collection of strings""); (""Locale"", ""has"", ""rules""); (""java.text.Collator"", ""instance of"", ""java.text"")"
To compare two strings using the Collator instance you call the compare() method.,"(""Collator"", ""has method"", ""compare()"")"
The compare() method returns an int with the same meaning as the String.compareTo() method:,"(""compare()"", ""returns"", ""int""); (""compare()"", ""similar to"", ""String.compareTo()""); (""String"", ""has method"", ""compareTo()"")"
A 0 means that the two strings have the same order - e.g.,
There are more rules you can use with the RuleBasedCollator class.,"(""RuleBasedCollator"", ""is a class used with"", ""rules"")"
You normalize a string using the static normalize() method of the java.text.Normalizer class.,"(""java.text.Normalizer"", ""hasMethod"", ""normalize()""); (""java.text.Normalizer"", ""isUsedFor"", ""string normalization""); (""string"", ""isNormalizedBy"", ""java.text.Normalizer.normalize()"")"
The first parameter to the normalize() method is the text to normalize.,"(""text"", ""is parameter to"", ""normalize()""); (""normalize()"", ""is method of"", ""unknown"")"
You can use the String class to convert a byte array to a String instance.,"(""String"", ""used to convert"", ""byte array""); (""String"", ""convert to"", ""String instance""); (""String"", ""has method"", ""convert method""); (""byte array"", ""converted to"", ""String instance""); (""String"", ""has class"", ""String""); (""byte array"", ""related to"", ""String"")"
You can convert the text of a String to another format using the getBytes() method.,"(""String"", ""hasMethod"", ""getBytes()"")"
The Reader and Writer classes are stream oriented classes that enable a Java application to read and write streams of characters.,"(""Reader"", ""is related to"", ""Writer""); (""Reader"", ""enables"", ""Java application""); (""Writer"", ""enables"", ""Java application""); (""Reader"", ""reads"", ""streams of characters""); (""Writer"", ""writes"", ""streams of characters"")"
This is done using the second constructor paramter in the InputStreamReader class.,"(""InputStreamReader"", ""has constructor parameter"", ""second constructor parameter""); (""InputStreamReader"", ""is a"", ""class"")"
"Input is everything that your application receives from its users, either directly through the user interface, sent to it via service calls (e.g.",
"The internationalization layer should convert from whatever character encoding the input comes in (ascii, UTF-8 etc.)",
Java has a set of built-in classes that can help you handle internationalization of your application.,"(""Java"", ""has"", ""built-in classes""); (""built-in classes"", ""help"", ""internationalization""); (""internationalization"", ""of"", ""application""); (""application"", ""handle"", ""internationalization""); (""Java"", ""handle"", ""internationalization"")"
Each of these classes are covered in more detail in later texts in this trail.,
In Java you can convert between time zones using the java.util.Calendar class.,"(""Java"", ""uses"", ""java.util.Calendar""); (""java.util.Calendar"", ""used for"", ""time zone conversion"")"
"Please not, that the Calendar.getTimeInMillis() always returns the time in UTC, regardless of the time zone set on the Calendar instance.","(""Calendar"", ""hasMethod"", ""getTimeInMillis()""); (""Calendar"", ""instanceOf"", ""Calendar""); (""getTimeInMillis()"", ""returns"", ""time""); (""Calendar"", ""hasProperty"", ""time zone""); (""Calendar"", ""setProperty"", ""time zone""); (""getTimeInMillis()"", ""ignores"", ""time zone"")"
"As you saw in the example, you get the time zone from the java.util.TimeZone class.","(""java.util.TimeZone"", ""get time zone from"", ""example""); (""java.util.TimeZone"", ""is used in"", ""example""); (""example"", ""uses"", ""java.util.TimeZone""); (""java.util"", ""contains"", ""java.util.TimeZone""); (""java.util.TimeZone"", ""is part of"", ""java.util"")"
You can obtain a list of the available time zone ID's using the TimeZone.getAvailableIDs() .,"(""TimeZone"", ""getAvailableIDs"", ""available time zone IDs"")"
"This examples obtains all the available time zone ID's, and then prints them to System.out.","(""com.example"", ""uses"", ""System.out""); (""AvailableTimeZones"", ""obtains"", ""time zone ID's""); (""AvailableTimeZones"", ""prints to"", ""System.out"")"
"I have described the java.util.TimeZone class in more detail in my Java Date Time tutorial, in the TimeZone class.","(""java.util.TimeZone"", ""described in"", ""Java Date Time tutorial""); (""Java Date Time tutorial"", ""contains"", ""TimeZone class""); (""java.util.TimeZone"", ""is same as"", ""TimeZone class"")"
"This Java internationalization tutorial is ""work in progress"", so if you spot a a missing description of a feature etc., please be patient.",
"The Java Locale class, java.util.Locale, is used to represent a ""geographical, political or cultural"" region to localize a given text, number, date or operation to.","(""Java Locale class"", ""is used to represent"", ""geographical region""); (""Java Locale class"", ""is used to represent"", ""political region""); (""Java Locale class"", ""is used to represent"", ""cultural region""); (""Java Locale class"", ""localizes"", ""text""); (""Java Locale class"", ""localizes"", ""number""); (""Java Locale class"", ""localizes"", ""date""); (""Java Locale class"", ""localizes"", ""operation""); (""java.util.Locale"", ""is"", ""Java Locale class"")"
The Locale class cannot do any internationalization or localization by itself.,"(""Locale"", ""cannot do"", ""internationalization""); (""Locale"", ""cannot do"", ""localization"")"
"The Locale class complies with the BCP 47 (IETF BCP 47, ""Tags for Identifying Languages"") standard.","(""Locale"", ""complies with"", ""BCP 47"")"
"The Locale class also has support for the LDML (UTS#35 ""Unicode Locale Data Markup Language"") standard, which is a BCP 47-compatible extension for locale data exchange.","(""Locale"", ""has support for"", ""LDML""); (""LDML"", ""is"", ""UTS#35""); (""LDML"", ""is compatible with"", ""BCP 47"")"
"Language codes are case insensitive, but the Locale class always use lowercase versions of the language codes.","(""Locale"", ""uses"", ""language codes""); (""language codes"", ""are"", ""case insensitive""); (""Locale"", ""uses"", ""lowercase""); (""language codes"", ""have"", ""lowercase versions""); (""Locale"", ""always uses"", ""lowercase versions of the language codes"")"
"Script codes are case insensitive, but the Locale class always uses a version with the first letter in uppercase, and the rest in lowercase.","(""Locale"", ""uses"", ""version""); (""version"", ""has"", ""first letter""); (""first letter"", ""is in"", ""uppercase""); (""version"", ""has"", ""rest""); (""rest"", ""is in"", ""lowercase""); (""Script codes"", ""are"", ""case insensitive""); (""Locale class"", ""always uses"", ""version"")"
"The country code is a 2 character code following the ISO 3166 standard, or a UN M.49 numeric area code.",
"The country code is case insensitive, but the Locale class uses an uppercase version of the country code.","(""Locale"", ""uses"", ""country code"")"
See the JavaDoc for the Locale class for more detail about variant.,"(""Locale"", ""hasJavaDoc"", ""JavaDoc"")"
"For instance, what calendar to use when displaying dates (Gregorian, Arab, Japanese etc.).",
See the JavaDoc for the Locale class for more detail about extensions.,"(""Locale"", ""hasJavaDoc"", ""JavaDoc"")"
Creating a java.util.Locale instance can be done in four different ways:,"(""java.util.Locale"", ""can be instantiated by"", ""four different ways"")"
The java.util.Locale class contains a set of constants that represent the most commonly used languages in the world.,"(""java.util.Locale"", ""contains"", ""constants""); (""java.util.Locale"", ""represent"", ""languages"")"
You can also create a java.util.Locale instance by using one of its constructors.,"(""java.util.Locale"", ""has constructor"", ""java.util.Locale""); (""java.util.Locale"", ""instance of"", ""java.util.Locale"")"
From Java 7 you can use the Locale.Builder class to build a Locale instance.,"(""Java 7"", ""uses"", ""Locale.Builder""); (""Locale.Builder"", ""builds"", ""Locale"")"
The factory method Locale.forLanguageTag() can also be used to create a Locale instance.,"(""Locale"", ""forLanguageTag"", ""Locale"")"
The ResourceBundle class is covered in more detail in the text about the ResourceBundle class.,"(""ResourceBundle"", ""is covered in"", ""text""); (""ResourceBundle"", ""is related to"", ""ResourceBundle class""); (""ResourceBundle class"", ""is covered in"", ""text"")"
"Finally, I may want to show how a given application works to a person who doesn't speak the language that my application is localized to (e.g.",
"English or Danish), so I may want to temporarily change language to e.g.",
The java.text.NumberFormat class is used to format numbers according to a specific Locale.,"(""java.text.NumberFormat"", ""used to format"", ""numbers""); (""java.text.NumberFormat"", ""is used according to"", ""Locale"")"
Formatting a number using a NumberFormatter is done using the format() method.,"(""NumberFormatter"", ""uses"", ""format() method""); (""NumberFormatter"", ""has method"", ""format()""); (""format() method"", ""is part of"", ""NumberFormatter"")"
"Notice that numbers like 100.00 might be formatted without the decimals, as 100.",
Formatting a number as a currency is still done using the format() method.,"(""format() method"", ""is used by"", ""number""); (""number"", ""is formatted by"", ""format() method"")"
"You can also set the Currency object to use for formatting a number as a currency, using the setCurrency() method on the NumberFormat class.","(""NumberFormat"", ""has method"", ""setCurrency()""); (""Currency"", ""used by"", ""NumberFormat""); (""setCurrency()"", ""belongs to"", ""NumberFormat"")"
Formatting a number as a percentage is also done using the format() method.,"(""format() method"", ""is used by"", ""number""); (""number"", ""is formatted by"", ""format() method"")"
You can set the rounding mode using the setRoundingMode() method of the NumberFormat class.,"(""NumberFormat"", ""has method"", ""setRoundingMode()""); (""setRoundingMode()"", ""is method of"", ""NumberFormat""); (""NumberFormat"", ""uses"", ""setRoundingMode()"")"
"Had the NumberFormat instance been created using a UK Locale instance, the number had been parsed to 10000, because the comma would have been interpreted as a integer separator (e.g.","(""NumberFormat"", ""instance created using"", ""Locale""); (""Locale"", ""used for"", ""NumberFormat""); (""NumberFormat"", ""parses number using"", ""integer separator""); (""Locale"", ""affects interpretation of"", ""comma""); (""comma"", ""interpreted as"", ""integer separator"")"
"The Java ResourceBundle class, java.util.ResourceBundle, is used to store texts and components that are locale sensitive.","(""Java ResourceBundle class"", ""is used in"", ""java.util.ResourceBundle""); (""Java ResourceBundle class"", ""is part of"", ""java.util""); (""java.util.ResourceBundle"", ""stores"", ""texts""); (""java.util.ResourceBundle"", ""stores"", ""components"")"
"A user's locale is represented by the Java Locale class, by the way.","(""User"", ""represented by"", ""Java Locale""); (""Java Locale"", ""is class of"", ""Java"")"
This text takes a closer look at the ResourceBundle class and its subclasses.,"(""ResourceBundle"", ""has subclasses"", ""ResourceBundle subclasses""); (""ResourceBundle"", ""is a class"", ""Java classes""); (""ResourceBundle subclasses"", ""are subclasses of"", ""ResourceBundle"")"
The PropertyResourceBundle class stores localized texts in standard Java property files.,"(""PropertyResourceBundle"", ""stores"", ""localized texts""); (""PropertyResourceBundle"", ""uses"", ""Java property files"")"
Then you pass that Locale instance to the ResourceBundle.getBundle() method along with the name of the resource bundle to load.,"(""ResourceBundle"", ""getBundle()"", ""Locale""); (""Locale"", ""passed to"", ""ResourceBundle.getBundle()""); (""ResourceBundle.getBundle()"", ""takes"", ""Locale"")"
Finally you can access the localized values in the ResourceBundle via its different getString() and getObject() etc.,"(""ResourceBundle"", ""has method"", ""getString()""); (""ResourceBundle"", ""has method"", ""getObject()"")"
"You are never actually creating a ResourceBundle instance, but an instance of one of its two subclasses.","(""ResourceBundle"", ""hasSubclass"", ""subclass1""); (""ResourceBundle"", ""hasSubclass"", ""subclass2""); (""ResourceBundle"", ""isSuperclassOf"", ""subclass1""); (""ResourceBundle"", ""isSuperclassOf"", ""subclass2"")"
"First the ResourceBundle class will look for a ListResourceBundle, and then for a PropertyResourceBundle.","(""ResourceBundle"", ""will look for"", ""ListResourceBundle""); (""ResourceBundle"", ""will look for"", ""PropertyResourceBundle"")"
"It does so by matching the name of the requested resource bundle (first parameter in the getBundle() method) against the class names of a ListResourceBundle first, and if none found, against a property file resource bundle.","(""ListResourceBundle"", ""is a type of"", ""resource bundle""); (""getBundle() method"", ""takes as parameter"", ""resource bundle name""); (""getBundle() method"", ""is used to retrieve"", ""resource bundle""); (""ListResourceBundle"", ""is checked before"", ""property file resource bundle""); (""property file resource bundle"", ""is a type of"", ""resource bundle"")"
For this example to work you should put a standard Java property file named MyBundle.properties in a Java package named i18n.,"(""MyBundle.properties"", ""isLocatedIn"", ""i18n""); (""i18n"", ""contains"", ""MyBundle.properties"")"
"Make sure this property file is available on your class path when you run the above code, meaning the property file should be located among the classes of your application, and in the i18n package.","(""property file"", ""located in"", ""class path""); (""class path"", ""contains"", ""classes of your application""); (""i18n package"", ""contains"", ""property file""); (""classes of your application"", ""located in"", ""class path""); (""property file"", ""part of"", ""i18n package"")"
The name of a resource bundle is like a class name.,"(""resource bundle"", ""is like"", ""class name"")"
"Thus, i18n.MyBundle means a property file named MyBundle.properties in the package (directory) i18n.","(""i18n"", ""contains"", ""MyBundle""); (""MyBundle"", ""is_a"", ""property file""); (""i18n"", ""is_a"", ""package""); (""MyBundle.properties"", ""is_a"", ""property file""); (""i18n"", ""contains"", ""MyBundle.properties"")"
"In case no property file is available for the language (Locale) passed to the ResourceBundle.getBundle() method, and the system has no default Locale set (e.g.","(""ResourceBundle"", ""getBundle"", ""Locale"")"
You can also use a set of classes to contain your resources.,"(""classes"", ""contain"", ""resources""); (""set"", ""of"", ""classes""); (""classes"", ""to contain"", ""resources"")"
"Like with the property files, you create a set of classes with a bundle base name and language suffixes.","(""property files"", ""has"", ""bundle base name""); (""property files"", ""has"", ""language suffixes""); (""classes"", ""has"", ""bundle base name""); (""classes"", ""has"", ""language suffixes"")"
Here is an example implementation of the default bundle class file:,
"You can also obtain a set of all keys contained in the ResourceBundle using the keySet() method, like this:","(""ResourceBundle"", ""has method"", ""keySet()"")"
The java.text.SimpleDateFormat class is used to both parse and format dates according to a formatting pattern you specify yourself.,"(""java.text.SimpleDateFormat"", ""isUsedBy"", ""date parsing""); (""java.text.SimpleDateFormat"", ""isUsedFor"", ""date formatting""); (""java.text.SimpleDateFormat"", ""follows"", ""formatting pattern"")"
This text explains how to use the SimpleDateFormat class to format dates.,"(""SimpleDateFormat"", ""used for"", ""date formatting""); (""SimpleDateFormat"", ""class of"", ""java.text""); (""SimpleDateFormat"", ""formats"", ""dates"")"
Once you have created a SimpleDateFormat instance you can format dates using its format() method.,"(""SimpleDateFormat"", ""has method"", ""format()"")"
The Date instance passed to the format() method is a java.util.Date instance.,"(""Date"", ""passed to"", ""format()""); (""format()"", ""is a method of"", ""java.util.Date""); (""java.util.Date"", ""has method"", ""format()"")"
"The Java SimpleDateFormat class is also capable of formatting a Date object into a StringBuffer, instead of returning an individual String with the date formatted.","(""SimpleDateFormat"", ""is capable of formatting"", ""Date""); (""SimpleDateFormat"", ""formats into"", ""StringBuffer""); (""SimpleDateFormat"", ""formats instead of returning"", ""String"")"
"The SimpleDateFormat class does this via a version of the format() method that takes the Date, StringBuffer and a FieldPosition instance as parameters.","(""SimpleDateFormat"", ""uses"", ""format()""); (""format()"", ""takes"", ""Date""); (""format()"", ""takes"", ""StringBuffer""); (""format()"", ""takes"", ""FieldPosition"")"
It seems the format() method appends the formatted String to the end of the StringBuffer no matter what the int value passed to the FieldPosition constructor is.,"(""StringBuffer"", ""has method"", ""format()""); (""FieldPosition"", ""has constructor"", ""FieldPosition(int)""); (""format()"", ""appends to"", ""StringBuffer""); (""String"", ""is result of"", ""format()"")"
You can parse a String into a java.util.Date instance using the parse() method of the SimpleDateFormat instance.,"(""String"", ""parsed into"", ""java.util.Date""); (""String"", ""parsed using"", ""SimpleDateFormat.parse()""); (""SimpleDateFormat"", ""has method"", ""parse()""); (""String"", ""related to"", ""SimpleDateFormat"")"
"For instance, you can write either yy for a 2-character version of the year (e.g.",
"12), or you can write yyyy for a 4-character version of the year (e.g.",
"For more information about the patterns accepted, see the JavaDoc for the SimpleDateFormat class.","(""SimpleDateFormat"", ""is documented in"", ""JavaDoc""); (""JavaDoc"", ""provides information about"", ""SimpleDateFormat""); (""SimpleDateFormat"", ""uses"", ""JavaDoc"")"
"The indices in this array must start from one, to be indexable by the Calendar.SUNDAY, Calendar.MONDAY etc.","(""Calendar"", ""has constant"", ""Calendar.SUNDAY""); (""Calendar"", ""has constant"", ""Calendar.MONDAY""); (""Calendar.SUNDAY"", ""is indexable by"", ""array""); (""Calendar.MONDAY"", ""is indexable by"", ""array""); (""Calendar"", ""is related to"", ""array"")"
See the JavaDoc for the java.text.DateFormatSymbols class for more details about these methods and symbols.,"(""java.text.DateFormatSymbols"", ""has methods"", ""java.text.DateFormatSymbols methods""); (""java.text.DateFormatSymbols"", ""is in package"", ""java.text""); (""JavaDoc"", ""describes"", ""java.text.DateFormatSymbols"")"
You can set the time zone of a SimpleDateFormat using its setTimeZone() method.,"(""SimpleDateFormat"", ""has method"", ""setTimeZone()""); (""SimpleDateFormat"", ""uses method"", ""setTimeZone()""); (""setTimeZone()"", ""is method of"", ""SimpleDateFormat"")"
The setTimeZone() method takes an Java TimeZone instance (java.util.TimeZone) as parameter.,"(""setTimeZone()"", ""takes"", ""java.util.TimeZone"")"
"Of these ISO time zone formats, the Java SimpleDateFormat class only supports the second format (+hhmm), or the format ending with the Z character.","(""Java"", ""uses"", ""SimpleDateFormat""); (""SimpleDateFormat"", ""supports"", ""ISO time zone formats""); (""ISO time zone formats"", ""has format"", ""+hhmm""); (""ISO time zone formats"", ""has format"", ""Z character"")"
"This is to make the SimpleDateFormat class treat them as literal characters to be inserted, instead of trying to interpret them as representing some part of the date.","(""SimpleDateFormat"", ""treat"", ""literal characters""); (""SimpleDateFormat"", ""interpret"", ""date"")"
"The Java BufferedInputStream class, java.io.BufferedInputStream, provides transparent reading of chunks of bytes and buffering for a Java InputStream, including any subclasses of InputStream.","(""Java BufferedInputStream"", ""provides"", ""transparent reading""); (""Java BufferedInputStream"", ""provides"", ""buffering""); (""Java BufferedInputStream"", ""is a"", ""java.io.BufferedInputStream""); (""Java BufferedInputStream"", ""reads from"", ""Java InputStream""); (""Java InputStream"", ""has subclasses"", ""InputStream subclasses""); (""Java BufferedInputStream"", ""provides buffering for"", ""Java InputStream""); (""Java BufferedInputStream"", ""provides buffering for"", ""InputStream subclasses"")"
"The BufferedInputStream creates a byte array internally, and attempts to fill the array by calling the InputStream.read(byte[]) methods on the underlying InputStream.","(""BufferedInputStream"", ""creates"", ""byte array""); (""BufferedInputStream"", ""calls"", ""InputStream.read(byte)""); (""InputStream"", ""has method"", ""read(byte)""); (""BufferedInputStream"", ""uses"", ""InputStream"")"
An interesting aspect to note about the BufferedInputStream is that is supports the mark() and reset() methods inherited from the InputStream.,"(""BufferedInputStream"", ""supports"", ""mark()""); (""BufferedInputStream"", ""supports"", ""reset()""); (""BufferedInputStream"", ""inherited from"", ""InputStream""); (""InputStream"", ""has method"", ""mark()""); (""InputStream"", ""has method"", ""reset()"")"
"In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not, but the BufferedInputStream supports them.","(""InputStream"", ""has methods"", ""mark()""); (""InputStream"", ""has methods"", ""reset()""); (""BufferedInputStream"", ""supports"", ""mark()""); (""BufferedInputStream"", ""supports"", ""reset()""); (""InputStream"", ""has method"", ""markSupported()""); (""BufferedInputStream"", ""has method"", ""markSupported()"")"
You close a BufferedInputStream by calling the close() method inherited from InputStream.,"(""BufferedInputStream"", ""inherits"", ""InputStream""); (""BufferedInputStream"", ""has method"", ""close()""); (""InputStream"", ""has method"", ""close()"")"
Notice how the while loop continues until a -1 value is read from the BufferedInputStream read() method.,"(""while loop"", ""uses"", ""BufferedInputStream""); (""BufferedInputStream"", ""has method"", ""read()"")"
"After that, the while loop exits, and the BufferedInputStream close() method is called.","(""BufferedInputStream"", ""has method"", ""close()"")"
"If an exception is thrown while reading data from the BufferedInputStream, the close() method is never called.","(""BufferedInputStream"", ""has method"", ""close()""); (""BufferedInputStream"", ""throws"", ""exception""); (""close()"", ""is method of"", ""BufferedInputStream""); (""exception"", ""is thrown by"", ""BufferedInputStream"")"
Proper exception handling for use of Java IO classes is also explained in my tutorial on Java IO Exception Handling.,"(""Java IO"", ""used in"", ""Java IO Exception Handling""); (""Java IO Exception Handling"", ""explains"", ""Java IO"")"
"The setSource() method actually returns a reference to the ReusableBufferedInputStream, so you can actually create a ReusableBufferedInputStream and set the source in a single instruction:","(""ReusableBufferedInputStream"", ""hasMethod"", ""setSource()""); (""setSource()"", ""returns"", ""ReusableBufferedInputStream""); (""ReusableBufferedInputStream"", ""hasMethod"", ""setSource()"")"
"Note, that this implementation only overrides the read() method of the InputStream class that it extends.","(""InputStream"", ""extends"", ""implementation""); (""InputStream"", ""has method"", ""read()""); (""implementation"", ""overrides"", ""read()"")"
"The Java BufferedOutputStream class, java.io.BufferedOutputStream, is used to capture bytes written to the BufferedOutputStream in a buffer, and write the whole buffer in one batch to an underlying Java OutputStream for increased performance.","(""Java"", ""uses"", ""BufferedOutputStream""); (""BufferedOutputStream"", ""writes to"", ""OutputStream""); (""BufferedOutputStream"", ""captures"", ""bytes""); (""OutputStream"", ""receives"", ""buffer""); (""BufferedOutputStream"", ""is part of"", ""java.io"")"
The only difference is that you may need to call flush() if you need to be absolutely sure that the data written until now is flushed out of the buffer and onto the network or disk.,"(""buffer"", ""has method"", ""flush()"")"
To write data to a Java BufferedOutputStream you can use its write() method.,"(""Java BufferedOutputStream"", ""has method"", ""write()""); (""BufferedOutputStream"", ""has method"", ""write()""); (""BufferedOutputStream.write()"", ""is method of"", ""Java BufferedOutputStream"")"
The write() method takes an int which contains the byte value of the byte to write.,"(""write()"", ""takes"", ""int"")"
Here is an example of writing data to a Java BufferedOutputStream using its write() method:,"(""BufferedOutputStream"", ""uses"", ""write()""); (""BufferedOutputStream"", ""has method"", ""write()""); (""Java"", ""uses"", ""BufferedOutputStream"")"
"Since the Java BufferedOutputStream is a subclass of OutputStream, you can write arrays of bytes to the BufferedOutputStream too, instead of just a single byte at a time.","(""BufferedOutputStream"", ""is a subclass of"", ""OutputStream""); (""BufferedOutputStream"", ""can write to"", ""arrays of bytes""); (""BufferedOutputStream"", ""can write to"", ""single byte""); (""OutputStream"", ""can write"", ""arrays of bytes""); (""OutputStream"", ""can write"", ""single byte"")"
If you want to make sure that all written data is written to disk without having to close the BufferedOutputStream you can call its flush() method.,"(""BufferedOutputStream"", ""has method"", ""flush()"")"
"Calling flush() will make sure that all data which has been written to the BufferedOutputStream so far, is fully written to the underlying OutputStream too, plus flush() will also have been called on the underlying OutputStream.","(""BufferedOutputStream"", ""has method"", ""flush()""); (""BufferedOutputStream"", ""writes to"", ""OutputStream""); (""OutputStream"", ""has method"", ""flush()""); (""BufferedOutputStream"", ""calls method"", ""OutputStream.flush()"")"
Here is an example of calling the Java BufferedOutputStream flush() method:,"(""BufferedOutputStream"", ""has method"", ""flush()""); (""Java"", ""uses class"", ""BufferedOutputStream""); (""flush()"", ""is method of"", ""BufferedOutputStream"")"
"The concrete implementations of hasMoreData() and getMoreData() are left out, but they are not really super important to understand the principle of this example.","(""hasMoreData()"", ""is method of"", ""unknown class""); (""getMoreData()"", ""is method of"", ""unknown class"")"
"What matters is, that once the while loop ends, and you are done writing data to the BufferedOutputStream, its close() method is called, which closes the BufferedOutputStream .","(""BufferedOutputStream"", ""has method"", ""close()""); (""while loop"", ""ends"", ""BufferedOutputStream""); (""BufferedOutputStream"", ""is closed by"", ""close()""); (""BufferedOutputStream"", ""is used for"", ""writing data""); (""close()"", ""is method of"", ""BufferedOutputStream"")"
"In case the write() method throws an exception, the close() method will never get called.","(""write() method"", ""throws"", ""exception""); (""write() method"", ""prevents call to"", ""close() method""); (""close() method"", ""never gets called"", ""write() method"")"
"Once the try block is exited, the close() method of the BufferedOutputStream is called automatically, because the BufferedOutputStream was declared inside the parentheses of the try block.","(""BufferedOutputStream"", ""hasMethod"", ""close()""); (""try block"", ""contains"", ""BufferedOutputStream""); (""BufferedOutputStream"", ""isDeclaredIn"", ""try block"")"
"Even if an exception is thrown from inside the try block, the close() method is still called before the exception is propagated up the call stack.","(""try block"", ""contains"", ""close() method""); (""close() method"", ""is called by"", ""try block""); (""exception"", ""is thrown from"", ""try block""); (""close() method"", ""is called before"", ""exception"")"
"The Java BufferedReader class, java.io.BufferedReader, provides buffering for your Java Reader instances.","(""Java BufferedReader class"", ""provides"", ""java.io.BufferedReader""); (""Java Reader instances"", ""uses"", ""Java BufferedReader class""); (""Java BufferedReader class"", ""is part of"", ""java.io"")"
"The Java BufferedReader class is a subclass of the Java Reader class, so you can use a BufferedReader anywhere a Reader is required.","(""Java BufferedReader class"", ""is a subclass of"", ""Java Reader class""); (""Java BufferedReader class"", ""can be used in place of"", ""Java Reader class"")"
Each character returned from read() is thus returned from this internal array.,
The readLine() method will return a textual line (all text until at line break is found) read from the BufferedReader.,"(""BufferedReader"", ""has method"", ""readLine()""); (""readLine()"", ""returns"", ""textual line""); (""BufferedReader"", ""reads from"", ""textual line"")"
"If there is no more data to read from the underlying Reader, then the BufferedReader's readLine() method will return null .","(""BufferedReader"", ""has method"", ""readLine()""); (""Reader"", ""is underlying"", ""BufferedReader""); (""readLine()"", ""returns"", ""null"")"
The read() method of a Java BufferedReader returns an int which contains the char value of the next character read.,"(""BufferedReader"", ""has method"", ""read()""); (""read()"", ""returns"", ""int"")"
"If the read() method returns -1, there is no more data to read in the BufferedReader, and it can be closed.","(""BufferedReader"", ""has method"", ""read()""); (""read()"", ""returns"", ""-1""); (""BufferedReader"", ""can be"", ""closed"")"
"If not, it processes that char and continues reading until -1 is returned from the BufferedReader read() method.","(""BufferedReader"", ""has method"", ""read()"")"
"As mentioned earlier, the BufferedReader will actually read an array of characters from the underlying Reader and return these characters one by one, rather than forwarding every read() call to the underlying Reader.","(""BufferedReader"", ""will read from"", ""Reader""); (""BufferedReader"", ""returns"", ""characters""); (""Reader"", ""receives"", ""read() call""); (""BufferedReader"", ""reads"", ""array of characters"")"
"The Java BufferedReader class also has a read() method that takes a char array as parameter, as well as a start offset and length.","(""Java"", ""has"", ""BufferedReader""); (""BufferedReader"", ""has"", ""read()""); (""read()"", ""takes"", ""char""); (""read()"", ""has"", ""parameter""); (""parameter"", ""includes"", ""start offset""); (""parameter"", ""includes"", ""length""); (""BufferedReader"", ""hasMethod"", ""read()"")"
The char array is where the read() method will read the characters into.,"(""char array"", ""has method"", ""read()""); (""read()"", ""belongs to"", ""char array"")"
The offset parameter is where in the char array the read() method should start reading into.,"(""char array"", ""has method"", ""read()""); (""read()"", ""is located in"", ""char array""); (""char array"", ""uses"", ""read()"")"
The length parameter is how many characters the read() method should read into the char array from the offset and forward.,"(""read()"", ""is method of"", ""char array""); (""read()"", ""has parameter"", ""length""); (""read()"", ""reads from"", ""offset"")"
The Java BufferedReader has a special read method named readLine() which reads a full line of text from the BufferedReader's internal buffer.,"(""BufferedReader"", ""has method"", ""readLine()""); (""BufferedReader"", ""reads from"", ""internal buffer""); (""readLine()"", ""reads"", ""line of text""); (""BufferedReader"", ""contains"", ""internal buffer"")"
"If there are no more lines to read from the BufferedReader, the readLine() method returns null.","(""BufferedReader"", ""has method"", ""readLine()""); (""readLine()"", ""returns"", ""null"")"
The Java BufferedReader class has a method named skip() which can be used to skip over a number of characters in the input that you do not want to read.,"(""Java"", ""has"", ""BufferedReader""); (""BufferedReader"", ""has"", ""skip()""); (""skip()"", ""used to"", ""skip over characters""); (""BufferedReader"", ""uses"", ""skip()""); (""skip()"", ""skips"", ""characters"")"
You pass the number of characters to skip as parameter to the skip() method.,"(""skip() method"", ""is called with"", ""number of characters to skip"")"
Notice how there is no longer any explicit close() method call.,
"The setSource() method actually returns a reference to the ReusableBufferedReader, so you can actually create a ReusableBufferedReader and set the source in a single instruction:","(""ReusableBufferedReader"", ""hasMethod"", ""setSource()""); (""setSource()"", ""returns"", ""ReusableBufferedReader""); (""ReusableBufferedReader"", ""hasMethod"", ""setSource()"")"
"Note, that this implementation only overrides the read() and read(char[] dest, int offset, int length) methods of the Reader class that it extends.","(""Reader"", ""extends"", ""implementation""); (""Reader"", ""has method"", ""read()""); (""implementation"", ""overrides method"", ""read()"")"
"The Java BufferedWriter is a Java Writer subclass, so it can be used anywhere a Writer is required.","(""BufferedWriter"", ""is a subclass of"", ""Writer""); (""BufferedWriter"", ""can be used as"", ""Writer"")"
The BufferedWriter adds one extra method though: The newLine() method which can write a new-line character to the underlying Writer.,"(""BufferedWriter"", ""adds"", ""newLine()""); (""BufferedWriter"", ""has method"", ""newLine()""); (""newLine()"", ""writes to"", ""Writer""); (""BufferedWriter"", ""uses"", ""Writer"")"
"In addition, you may need to call flush() if you need to be absolutely sure that the characters written until now is flushed out of the buffer and onto the network or disk.","(""flush()"", ""called by"", ""user""); (""buffer"", ""writes to"", ""network""); (""buffer"", ""writes to"", ""disk""); (""flush()"", ""ensures data is written to"", ""network""); (""flush()"", ""ensures data is written to"", ""disk"")"
"Since the BufferedWriter collects the characters written internally in a buffer before writing them to the underlying Writer, the speedup is not as noticeable as with other Writer classes (that do not use buffering).","(""BufferedWriter"", ""collects"", ""characters""); (""BufferedWriter"", ""writes"", ""underlying Writer""); (""BufferedWriter"", ""uses"", ""buffering""); (""Writer"", ""has"", ""buffering"")"
The Java BufferedWriter's flush() method flushes all data written to the BufferedWriter to the underlying data destination.,"(""BufferedWriter"", ""has method"", ""flush()""); (""BufferedWriter"", ""writes to"", ""data destination""); (""flush()"", ""is method of"", ""BufferedWriter""); (""BufferedWriter"", ""uses"", ""underlying data destination"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your BufferedWriter has).","(""BufferedWriter"", ""has method"", ""flush()""); (""BufferedWriter"", ""writes to"", ""disk""); (""BufferedWriter"", ""writes to"", ""network"")"
Here is an example of flushing data written to a Java BufferedWriter by calling its flush() method:,"(""BufferedWriter"", ""has method"", ""flush()""); (""Java"", ""uses"", ""BufferedWriter""); (""BufferedWriter"", ""method"", ""flush()"")"
"The Java ByteArrayInputStream class, java.io.ByteArrayInputStream, of the Java IO API enables you to read data from byte arrays as streams of bytes.","(""Java IO API"", ""contains"", ""ByteArrayInputStream""); (""ByteArrayInputStream"", ""belongs to"", ""java.io""); (""ByteArrayInputStream"", ""enables"", ""read data from byte arrays""); (""ByteArrayInputStream"", ""is part of"", ""Java ByteArrayInputStream class"")"
"In other words, the ByteArrayInputStream class can turn a byte array into an InputStream.","(""ByteArrayInputStream"", ""can turn into"", ""InputStream""); (""ByteArrayInputStream"", ""takes"", ""byte array"")"
"The ByteArrayInputStream class is a subclass of the InputStream class, so you can use a ByteArrayInputStream as an InputStream.","(""ByteArrayInputStream"", ""is a subclass of"", ""InputStream""); (""ByteArrayInputStream"", ""can be used as"", ""InputStream"")"
The ByteArrayInputStream also has a set of additional methods that are specific to the ByteArrayInputStream class.,"(""ByteArrayInputStream"", ""has"", ""methods""); (""ByteArrayInputStream"", ""has"", ""set""); (""methods"", ""are specific to"", ""ByteArrayInputStream""); (""set"", ""is part of"", ""ByteArrayInputStream"")"
To use a Java ByteArrayInputStream you must first create an instance of the ByteArrayInputStream class.,"(""ByteArrayInputStream"", ""is instantiable as"", ""instance""); (""ByteArrayInputStream"", ""is a"", ""class""); (""instance"", ""is an instance of"", ""ByteArrayInputStream"")"
"You read bytes from a Java ByteArrayInputStream just like you would from a regular InputStream, via its read() method.","(""ByteArrayInputStream"", ""hasMethod"", ""read()""); (""InputStream"", ""hasMethod"", ""read()""); (""ByteArrayInputStream"", ""inheritsFrom"", ""InputStream"")"
"The read() will return the next byte from the byte array, or -1 if the end of the byte array (or byte array section) has been reached.","(""read()"", ""returns"", ""byte""); (""read()"", ""returns"", ""-1""); (""byte array"", ""has"", ""end""); (""read()"", ""is part of"", ""byte array""); (""byte array section"", ""has"", ""end""); (""read()"", ""is part of"", ""byte array section"")"
The Java ByteArrayInputStream available() method tells you how many bytes are still available in the ByteArrayInputStream.,"(""Java ByteArrayInputStream"", ""has method"", ""available()""); (""available()"", ""returns"", ""number of bytes""); (""ByteArrayInputStream"", ""has method"", ""available()"")"
The mark() method of the ByteArrayInputStream class sets an internal mark at the current byte position - meaning right after the previous byte read.,"(""ByteArrayInputStream"", ""has method"", ""mark()""); (""mark()"", ""is method of"", ""ByteArrayInputStream""); (""ByteArrayInputStream"", ""sets"", ""internal mark""); (""internal mark"", ""is set by"", ""mark()""); (""mark()"", ""sets at"", ""current byte position""); (""ByteArrayInputStream"", ""reads"", ""byte""); (""current byte position"", ""is after"", ""previous byte read""); (""previous byte read"", ""is read by"", ""ByteArrayInputStream""); (""mark()"", ""is used in"", ""ByteArrayInputStream"")"
"The mark() method takes a parameter telling how many bytes can be read past this mark, before this mark becomes invalid.","(""mark()"", ""takes"", ""parameter""); (""parameter"", ""is part of"", ""mark()""); (""mark()"", ""becomes"", ""invalid"")"
Here is an example of setting a mark in a ByteArrayInputStream via its mark() method:,"(""ByteArrayInputStream"", ""has method"", ""mark()"")"
The reset() method of the ByteArrayInputStream resets how far it has read into the byte array.,"(""ByteArrayInputStream"", ""has method"", ""reset()""); (""reset()"", ""is method of"", ""ByteArrayInputStream""); (""ByteArrayInputStream"", ""reads from"", ""byte array""); (""reset()"", ""resets"", ""byte array""); (""ByteArrayInputStream"", ""uses"", ""byte array"")"
The Java ByteArrayInputStream skip() method enables you to skip over a number of bytes from the underlying byte array.,"(""Java"", ""has method"", ""ByteArrayInputStream.skip()""); (""ByteArrayInputStream"", ""has method"", ""skip()""); (""skip()"", ""is method of"", ""ByteArrayInputStream"")"
Here is an example of skipping over a number of bytes using the ByteArrayInputStream skip() method:,"(""ByteArrayInputStream"", ""has method"", ""skip()"")"
Notice how the while loop continues until a -1 value is read from the ByteArrayInputStream read() method.,"(""while loop"", ""continues until"", ""-1 value""); (""while loop"", ""uses"", ""ByteArrayInputStream""); (""ByteArrayInputStream"", ""has method"", ""read()""); (""read()"", ""returns"", ""-1 value"")"
"After that, the while loop exits, and the ByteArrayInputStream close() method is called.","(""BaInputStream"", ""hasMethod"", ""close()""); (""while loop"", ""exits"", ""ByteArrayInputStream""); (""ByteArrayInputStream"", ""hasMethod"", ""close()""); (""ByteArrayInputStream"", ""isClosedBy"", ""close()""); (""close()"", ""isMethodOf"", ""ByteArrayInputStream"")"
"If an exception is thrown while reading data from the ByteArrayInputStream, the close() method is never called.","(""ByteArrayInputStream"", ""hasMethod"", ""close()""); (""ByteArrayInputStream"", ""throwsException"", ""exception""); (""close()"", ""isMethodOf"", ""ByteArrayInputStream"")"
"The Java ByteArrayOutputStream class, java.io.ByteArrayOutputStream of the Java IO API enables you to capture data written to a stream in a byte array.","(""Java ByteArrayOutputStream"", ""part of"", ""Java IO API""); (""ByteArrayOutputStream"", ""belongs to"", ""java.io""); (""ByteArrayOutputStream"", ""enables"", ""capture data""); (""Java IO API"", ""contains"", ""ByteArrayOutputStream""); (""ByteArrayOutputStream"", ""is a"", ""class""); (""ByteArrayOutputStream"", ""writes to"", ""byte array"")"
You write your data to the ByteArrayOutputStream and when you are done you call the its toByteArray() method to obtain all the written data in a byte array.,"(""ByteArrayOutputStream"", ""hasMethod"", ""toByteArray()""); (""ByteArrayOutputStream"", ""usedFor"", ""writingData""); (""toByteArray()"", ""returns"", ""byteArray""); (""ByteArrayOutputStream"", ""writesTo"", ""byteArray"")"
"Since the Java ByteArrayOutputStream class is a subclass of the Java OutputStream class, you write bytes to it using the same write methods that OutputStream has:","(""ByteArrayOutputStream"", ""is a subclass of"", ""OutputStream""); (""OutputStream"", ""has method"", ""write""); (""ByteArrayOutputStream"", ""uses method"", ""write"")"
"Once you have finished writing to the ByteArrayOutputStream you can obtain all the bytes written as a Java byte array, using the ByteArrayOutputStream toByteArray() method.","(""ByteArrayOutputStream"", ""hasMethod"", ""toByteArray()""); (""ByteArrayOutputStream"", ""returns"", ""byte array""); (""ByteArrayOutputStream.toByteArray()"", ""returns"", ""byte array"")"
Being a subclass of OutputStream the ByteArrayOutputStream also has a close() method.,"(""ByteArrayOutputStream"", ""is a subclass of"", ""OutputStream""); (""OutputStream"", ""has method"", ""close()""); (""ByteArrayOutputStream"", ""has method"", ""close()"")"
But calling the close() method has no effect on the ByteArrayOutputStream.,"(""ByteArrayOutputStream"", ""has method"", ""close()"")"
"The Java DataInputStream class, java.io.DataInputStream, enables you to read Java primitives (int, float, long etc.)","(""Java DataInputStream"", ""enables"", ""reading Java primitives""); (""Java DataInputStream"", ""belongs to"", ""java.io""); (""DataInputStream"", ""reads"", ""Java primitives""); (""DataInputStream"", ""is part of"", ""java.io""); (""Java primitives"", ""can be read by"", ""DataInputStream""); (""DataInputStream"", ""is in package"", ""java.io"")"
"The Java DataInputStream class is a subclass of InputStream, so DataInputStream also has the basic read methods that enable you to read a single byte or an array of bytes from the underlying InputStream, in case you need that.","(""DataInputStream"", ""is a subclass of"", ""InputStream""); (""DataInputStream"", ""has"", ""read methods""); (""InputStream"", ""has"", ""read methods""); (""DataInputStream"", ""enables"", ""read a single byte""); (""DataInputStream"", ""enables"", ""read an array of bytes"")"
"As mentioned earlier, the DataInputStream class is often used together with a DataOutputStream.","(""DataInputStream"", ""used together with"", ""DataOutputStream"")"
You can read a Java boolean from the DataInputStream using its readBoolean() method.,"(""DataInputStream"", ""has method"", ""readBoolean()"")"
Here is an example of reading a boolean from a Java DataInputStream using readBoolean():,"(""DataInputStream"", ""hasMethod"", ""readBoolean()""); (""readBoolean()"", ""belongsTo"", ""DataInputStream""); (""DataInputStream"", ""isPartOf"", ""Java""); (""readBoolean()"", ""returns"", ""boolean"")"
You can read a Java byte from the DataInputStream using its readByte() method.,"(""DataInputStream"", ""has method"", ""readByte()"")"
Here is an example of reading a byte from a Java DataInputStream using readByte():,"(""DataInputStream"", ""has method"", ""readByte()""); (""readByte()"", ""belongs to"", ""DataInputStream""); (""Java"", ""uses"", ""DataInputStream"")"
You can read a Java unsigned byte (only positive values) from the DataInputStream using its readUnsignedByte() method.,"(""DataInputStream"", ""has method"", ""readUnsignedByte()"")"
Here is an example of reading an unsigned byte from a Java DataInputStream using readUnsignedByte():,"(""DataInputStream"", ""hasMethod"", ""readUnsignedByte()""); (""Java"", ""uses"", ""DataInputStream""); (""DataInputStream"", ""reads"", ""unsigned byte"")"
You can read a Java char from the DataInputStream using its readChar() method.,"(""DataInputStream"", ""has method"", ""readChar()"")"
Here is an example of reading a char from a Java DataInputStream using readChar():,"(""DataInputStream"", ""hasMethod"", ""readChar()""); (""readChar()"", ""isMethodOf"", ""DataInputStream""); (""Java"", ""usesClass"", ""DataInputStream""); (""DataInputStream"", ""isUsedIn"", ""Java"")"
You can read a Java double from the DataInputStream using its readDouble() method.,"(""DataInputStream"", ""has method"", ""readDouble()""); (""readDouble()"", ""is method of"", ""DataInputStream""); (""DataInputStream"", ""reads"", ""Java double"")"
Here is an example of reading a double from a Java DataInputStream using readDouble():,"(""DataInputStream"", ""hasMethod"", ""readDouble()""); (""readDouble()"", ""belongsTo"", ""DataInputStream""); (""Java"", ""uses"", ""DataInputStream""); (""DataInputStream"", ""isPartOf"", ""Java""); (""readDouble()"", ""reads"", ""double"")"
You can read a Java float from the DataInputStream using its readFloat() method.,"(""DataInputStream"", ""has method"", ""readFloat()""); (""readFloat()"", ""is method of"", ""DataInputStream""); (""DataInputStream"", ""reads"", ""Java float"")"
Here is an example of reading a float from a Java DataInputStream using readFloat():,"(""DataInputStream"", ""uses"", ""readFloat()""); (""readFloat()"", ""belongs to"", ""DataInputStream""); (""DataInputStream"", ""reads"", ""float"")"
You can read a Java short from the DataInputStream using its readShort() method.,"(""DataInputStream"", ""has method"", ""readShort()"")"
Here is an example of reading a short from a Java DataInputStream using readShort():,"(""DataInputStream"", ""hasMethod"", ""readShort()""); (""Java"", ""uses"", ""DataInputStream""); (""DataInputStream"", ""method"", ""readShort()""); (""readShort()"", ""belongsTo"", ""DataInputStream"")"
You can read a Java unsigned short (only positive values) from the DataInputStream using its readUnsignedShort() method.,"(""DataInputStream"", ""has method"", ""readUnsignedShort()"")"
Here is an example of reading an unsigned short from a Java DataInputStream using readUnsignedShort():,"(""DataInputStream"", ""hasMethod"", ""readUnsignedShort()""); (""readUnsignedShort()"", ""returns"", ""unsigned short""); (""DataInputStream"", ""uses"", ""readUnsignedShort()""); (""Java"", ""uses"", ""DataInputStream""); (""DataInputStream"", ""belongsTo"", ""Java"")"
You can read a Java int from the DataInputStream using its readInt() method.,"(""DataInputStream"", ""has method"", ""readInt()"")"
Here is an example of reading an int from a Java DataInputStream using readInt():,"(""DataInputStream"", ""uses"", ""readInt()""); (""readInt()"", ""belongs to"", ""DataInputStream""); (""DataInputStream"", ""instance of"", ""Java"")"
You can read a Java long from the DataInputStream using its readLong() method.,"(""DataInputStream"", ""has method"", ""readLong()""); (""readLong()"", ""belongs to"", ""DataInputStream""); (""DataInputStream"", ""uses"", ""Java long"")"
Here is an example of reading an int from a Java DataInputStream using readLong():,"(""DataInputStream"", ""uses"", ""readLong()""); (""readLong"", ""belongs to"", ""DataInputStream""); (""DataInputStream"", ""reads"", ""int"")"
You can read a Java String from the DataInputStream using its readUTF() method.,"(""DataInputStream"", ""has method"", ""readUTF()""); (""String"", ""is read by"", ""DataInputStream.readUTF()""); (""DataInputStream.readUTF()"", ""returns"", ""String"")"
Here is an example of reading a String from a Java DataInputStream using readUTF():,"(""DataInputStream"", ""uses"", ""readUTF()""); (""String"", ""read by"", ""DataInputStream""); (""Java"", ""provides"", ""DataInputStream""); (""readUTF()"", ""belongs to"", ""DataInputStream"")"
"The Java File class, java.io.File in the Java IO API gives you access to the underlying file system.","(""Java File"", ""is part of"", ""Java IO API""); (""Java IO API"", ""contains"", ""java.io.File""); (""java.io.File"", ""gives access to"", ""file system"")"
Note: The Java File class only gives you access to the file and directory meta data.,"(""Java File class"", ""gives access to"", ""file meta data""); (""Java File class"", ""gives access to"", ""directory meta data"")"
Note: If you are want to Java NIO (Java's non-blocking IO API) you will have to use the java.nio.FileChannel class instead.,"(""Java NIO"", ""uses"", ""java.nio.FileChannel""); (""java.nio.FileChannel"", ""is part of"", ""Java NIO"")"
"Both Java File and FileChannel works, but in case you want a pure Java NIO solution use the Java NIO FileChannel class.","(""Java File"", ""works with"", ""FileChannel""); (""FileChannel"", ""is part of"", ""Java NIO""); (""Java NIO"", ""includes"", ""FileChannel class"")"
"Before you can do anything with the file system or File class, you must create a Java File instance.","(""File class"", ""used with"", ""file system""); (""Java"", ""has instance of"", ""File class""); (""File class"", ""instance creation required for"", ""file system"")"
The Java File class also has a few other constructors you can use to instantiate File instances in different ways.,"(""Java"", ""has"", ""File""); (""File"", ""has"", ""constructors""); (""File"", ""instantiate"", ""File instances"")"
You can check if a file referenced by a Java File object exists using the File exists() method.,"(""File"", ""hasMethod"", ""exists()""); (""File"", ""referencedBy"", ""Java File object""); (""Java File object"", ""usesMethod"", ""exists()"")"
You can use the Java File class to create directories if they don't already exists.,"(""Java"", ""uses"", ""File class""); (""File class"", ""creates"", ""directories"")"
The File class contains the method mkdir() and mkdirs() for that purpose.,"(""File"", ""contains"", ""mkdir()""); (""File"", ""contains"", ""mkdirs()"")"
The mkdir() method creates a single directory if it does not already exist.,"(""mkdir()"", ""creates"", ""directory"")"
Here is an example of creating a single directory via the Java File class:,"(""Java File class"", ""has method"", ""create directory""); (""Java File class"", ""creates"", ""directory""); (""Java"", ""has class"", ""Java File class""); (""Java File class"", ""used for"", ""creating directory""); (""create directory"", ""is method of"", ""Java File class"")"
"The mkdir() returns true if the directory was created, and false if not.","(""mkdir()"", ""returns"", ""true""); (""mkdir()"", ""returns"", ""false"")"
The mkdirs() will create all directories that are missing in the path the File object represents.,"(""File"", ""represents"", ""path""); (""File"", ""has method"", ""mkdirs()"")"
Here is an example of creating multiple directories via the Java File class:,"(""Java"", ""uses"", ""File class""); (""File class"", ""has method"", ""mkdir()""); (""File class"", ""has method"", ""mkdirs()"")"
"The mkdirs() method will return true if all the directories were created, and false if not.","(""mkdirs()"", ""is method of"", ""unidentified class"")"
The Java File class enables you to read the length in bytes of a file.,"(""Java"", ""enables"", ""File class""); (""File class"", ""has method"", ""read""); (""File class"", ""returns"", ""length in bytes""); (""File"", ""is associated with"", ""bytes"")"
"To read the length of a file, call the File length() method.","(""File"", ""has method"", ""length()"")"
Here is an example of reading the length of a file via the Java File length() method:,"(""File"", ""has method"", ""length()""); (""Java"", ""uses"", ""File""); (""File"", ""has method"", ""length()"")"
"To rename (or move) a file, call the method renameTo() on the File class.","(""File"", ""has method"", ""renameTo()""); (""renameTo()"", ""is called on"", ""File"")"
"As briefly mentioned earlier, the renameTo() method can also be used to move a file to a different directory.","(""renameTo()"", ""is method of"", ""File""); (""renameTo()"", ""used to"", ""move file""); (""move file"", ""to"", ""different directory""); (""File"", ""has method"", ""renameTo()"")"
The new file name passed to the renameTo() method does not have to be in the same directory as the file was already residing in.,"(""file"", ""passed to"", ""renameTo()""); (""renameTo()"", ""method of"", ""file""); (""file"", ""residing in"", ""directory"")"
"The renameTo() method returns boolean (true or false), indicating whether the renaming was successful.","(""renameTo()"", ""returns"", ""boolean"")"
"The Java File renameTo() method also works for directories, by the way.","(""Java File"", ""has method"", ""renameTo()""); (""renameTo()"", ""works for"", ""directories"")"
"The delete() method returns boolean (true or false), indicating whether the deletion was successful.","(""delete()"", ""returns"", ""boolean"")"
"The Java File delete() method also works for directories, meaning you can also delete directories with it.","(""Java File"", ""has method"", ""delete()""); (""delete()"", ""works for"", ""directories""); (""delete()"", ""can delete"", ""directories"")"
The Java File delete() method can only delete a directory if the directory is empty.,"(""Java File"", ""has method"", ""delete()""); (""delete()"", ""can delete"", ""directory""); (""directory"", ""must be"", ""empty"")"
"You can check if a File object points to a file or directory, by calling its isDirectory() method.","(""File"", ""has method"", ""isDirectory()"")"
You can obtain a list of all the files in a directory by calling either the Java File list() method or the listFiles() method.,"(""File"", ""hasMethod"", ""list()""); (""File"", ""hasMethod"", ""listFiles()"")"
The list() method returns an array of String's with the file and / or directory names of directory the File object points to.,"(""List"", ""returns"", ""Array""); (""List"", ""contains"", ""String""); (""File"", ""has"", ""list() method""); (""File"", ""points to"", ""Directory""); (""List"", ""includes"", ""File""); (""List"", ""includes"", ""Directory"")"
The listFiles() returns an array of File objects representing the files and / or directories in the directory the File points to.,"(""File"", ""has method"", ""listFiles()""); (""File"", ""points to"", ""directory""); (""File"", ""represents"", ""files""); (""File"", ""represents"", ""directories""); (""listFiles()"", ""returns"", ""File"")"
Here is an example of listing all files in a directory via the Java File list() and listFiles() methods:,"(""File"", ""hasMethod"", ""list()""); (""File"", ""hasMethod"", ""listFiles()"")"
"The Java FileInputStream class, java.io.FileInputStream, makes it possible to read the contents of a file as a stream of bytes.","(""Java FileInputStream class"", ""makes use of"", ""java.io.FileInputStream""); (""java.io.FileInputStream"", ""is part of"", ""java.io""); (""Java FileInputStream class"", ""reads"", ""file""); (""java.io.FileInputStream"", ""reads"", ""file"")"
"Note also, that since FileInputStream is a subclass of InputStream, we can cast the created FileInputStream to an InputStream everywhere we want to, as we do in the example above.","(""FileInputStream"", ""is a subclass of"", ""InputStream""); (""FileInputStream"", ""can be cast to"", ""InputStream"")"
The FileInputStream class has a three different constructors you can use to create a FileInputStream instance.,"(""FileInputStream"", ""has"", ""constructors""); (""FileInputStream"", ""creates"", ""FileInputStream instance""); (""constructors"", ""are part of"", ""FileInputStream"")"
"Actually, in my experience Java will also understand if you use a / as directory separator on Windows (e.g.",
The read() method of a FileInputStream returns an int which contains the byte value of the byte read.,"(""FileInputStream"", ""hasMethod"", ""read()""); (""FileInputStream.read()"", ""returns"", ""int"")"
"If the read() method returns -1, there is no more data to read in the FileInputStream, and it can be closed.","(""FileInputStream"", ""has method"", ""read()""); (""read()"", ""returns"", ""-1""); (""FileInputStream"", ""can be"", ""closed"")"
You use the read() method just like the read() method of an InputStream.,"(""read() method"", ""is similar to"", ""InputStream.read() method"")"
Being an InputStream the FileInputStream also has two read() methods which can read data into a byte array.,"(""FileInputStream"", ""has"", ""read()""); (""FileInputStream"", ""extends"", ""InputStream""); (""read()"", ""reads"", ""byte array""); (""InputStream"", ""has"", ""read()"")"
"These methods are inherited from the Java InputStream class, by the way.","(""Java InputStream class"", ""has methods"", ""methods""); (""methods"", ""are inherited by"", ""Java InputStream class""); (""Java InputStream class"", ""inherits to"", ""None"")"
"If all bytes have been read from the FileInputStream, these read() methods will return -1.","(""FileInputStream"", ""has method"", ""read()""); (""read()"", ""returns"", ""-1""); (""FileInputStream"", ""uses"", ""read()"")"
Therefore it is necessary to inspect the value returned from these read() method calls.,"(""read()"", ""is called from"", ""unknown""); (""unknown"", ""returns"", ""value""); (""read()"", ""returns"", ""value""); (""value"", ""is returned from"", ""read()""); (""read()"", ""is used for"", ""inspection"")"
The doSomethingWithData() method implementation has been left out of this example to keep it short.,"(""doSomethingWithData()"", ""is method of"", ""unspecified class"")"
"Notice, that a BufferedInputStream is an InputStream subclass and can be used in any place where an InputStream can be used.","(""BufferedInputStream"", ""is a"", ""InputStream""); (""BufferedInputStream"", ""can be used in"", ""place where InputStream can be used""); (""InputStream"", ""can be used in"", ""place where InputStream can be used"")"
You close a FileInputStream by calling the close() method inherited from InputStream.,"(""FileInputStream"", ""inherits from"", ""InputStream""); (""FileInputStream"", ""has method"", ""close()""); (""InputStream"", ""has method"", ""close()"")"
Notice how the while loop continues until a -1 value is read from the FileInputStream read() method.,"(""FileInputStream"", ""has method"", ""read()"")"
"After that, the while loop exits, and the FileInputStream close() method is called.","(""FileInputStream"", ""has method"", ""close()"")"
"If an exception is thrown while reading data from the FileInputStream, the close() method is never called.","(""FileInputStream"", ""has method"", ""close()""); (""FileInputStream"", ""throws"", ""exception""); (""close()"", ""is method of"", ""FileInputStream"")"
"The Java FileOutputStream class, java.io.FileOutputStream, makes it possible to write a file as a stream of bytes.","(""Java"", ""uses"", ""FileOutputStream""); (""FileOutputStream"", ""belongs to"", ""java.io""); (""FileOutputStream"", ""has capability"", ""writing bytes""); (""FileOutputStream"", ""is part of"", ""java.io"")"
The Java FileOutputStream class is a subclass of Java OutputStream meaning you can use a FileOutputStream as an OutputStream.,"(""FileOutputStream"", ""is a subclass of"", ""OutputStream""); (""FileOutputStream"", ""can be used as"", ""OutputStream"")"
The Java FileOutputStream class contains a set of different useful constructors.,"(""Java"", ""contains"", ""FileOutputStream""); (""FileOutputStream"", ""has"", ""constructors"")"
To write data to a Java FileOutputStream you can use its write() method.,"(""FileOutputStream"", ""has method"", ""write()""); (""FileOutputStream"", ""uses method"", ""write()""); (""write()"", ""is method of"", ""FileOutputStream"")"
Here is an example of writing data to a Java FileOutputStream using its write() method:,"(""FileOutputStream"", ""uses"", ""write() method""); (""FileOutputStream"", ""has method"", ""write()""); (""write() method"", ""belongs to"", ""FileOutputStream"")"
"Since the Java FileOutputStream is a subclass of OutputStream, you can write arrays of bytes to the FileOutputStream too, instead of just a single byte at a time.",
If you want to make sure that all written data is written to disk without having to close the FileOutputStream you can call its flush() method.,"(""FileOutputStream"", ""hasMethod"", ""flush()""); (""flush()"", ""calledOn"", ""FileOutputStream"")"
"Calling flush() will make sure that all data which has been written to the FileOutputStream so far, is fully written to disk too.","(""FileOutputStream"", ""hasMethod"", ""flush()""); (""flush()"", ""calledOn"", ""FileOutputStream""); (""FileOutputStream"", ""writesTo"", ""disk"")"
Here is an example of calling the Java FileOutputStream flush() method:,"(""FileOutputStream"", ""hasMethod"", ""flush()""); (""flush()"", ""calledBy"", ""example""); (""Java"", ""usesClass"", ""FileOutputStream""); (""FileOutputStream"", ""usesMethod"", ""flush()"")"
Here is an example of closing a Java FileOutputStream by calling its close() method:,"(""FileOutputStream"", ""hasMethod"", ""close()""); (""FileOutputStream"", ""hasMethod"", ""close()""); (""FileOutputStream"", ""calls"", ""close()""); (""close()"", ""belongsTo"", ""FileOutputStream"")"
"Unfortunately, if an exception is thrown during the write() call in the example above, that exception will cause the program flow to break before the close() method is called.","(""write()"", ""is called before"", ""close()""); (""close()"", ""is called after"", ""write()""); (""exception"", ""is thrown during"", ""write()""); (""program flow"", ""is broken by"", ""exception""); (""write()"", ""throws"", ""exception""); (""close()"", ""is affected by"", ""exception"")"
"In other words, the FileOutputStream close() will be called automatically for you.","(""FileOutputStream"", ""has method"", ""close()"")"
You can convert a FileOutputStream to a character based Writer using the Java OutputStreamWriter class.,"(""FileOutputStream"", ""converted to"", ""Writer""); (""FileOutputStream"", ""uses"", ""OutputStreamWriter""); (""OutputStreamWriter"", ""is a"", ""Writer"")"
"The Java FileReader class, java.io.FileReader makes it possible to read the contents of a file as a stream of characters.","(""Java FileReader"", ""uses"", ""java.io.FileReader""); (""json.io.FileReader"", ""reads"", ""file""); (""Java"", ""has class"", ""FileReader""); (""FileReader"", ""is in package"", ""java.io"")"
"The Java FileReader is a subclass of the Java Reader class, so it has many of the same methods.","(""FileReader"", ""is a subclass of"", ""Reader""); (""FileReader"", ""has methods of"", ""Reader"")"
The read() method of the Java FileReader returns an int which contains the char value of the character read.,"(""FileReader"", ""has method"", ""read()""); (""read()"", ""returns"", ""int"")"
"If the read() method returns -1, there is no more data to read in the FileReader, and it can be closed.","(""FileReader"", ""has method"", ""read()""); (""read()"", ""returns"", ""-1""); (""FileReader"", ""can be"", ""closed"")"
"Notice, that a BufferedReader is a Reader subclass and can be used in any place where an Reader can be used.","(""BufferedReader"", ""is a"", ""Reader""); (""BufferedReader"", ""can be used in"", ""Reader""); (""Reader"", ""can be used in"", ""BufferedReader"")"
Notice how there is no longer any explicit close() method call to the FileReader instance.,"(""FileReader"", ""hasMethod"", ""close()"")"
"The Java FileWriter class, java.io.FileWriter, makes it possible to write characters to a file.","(""Java"", ""uses"", ""FileWriter""); (""FileWriter"", ""belongs_to"", ""java.io""); (""FileWriter"", ""writes_to"", ""file""); (""FileWriter"", ""is_type"", ""java.io.FileWriter"")"
"The Java FileWriter class is a subclass of the Java Writer class, by the way.","(""FileWriter"", ""is a subclass of"", ""Writer"")"
The Java FileWriter's flush() method flushes all data written to the FileWriter to the underlying file.,"(""FileWriter"", ""has method"", ""flush()""); (""flush()"", ""belongs to"", ""FileWriter""); (""FileWriter"", ""writes to"", ""file""); (""flush()"", ""affects"", ""file"")"
By calling flush() you can assure that any buffered data will be flushed (written) to disk.,"(""flush()"", ""is a method of"", ""an unspecified class"")"
Here is an example of flushing data written to a Java FileWriter by calling its flush() method:,"(""FileWriter"", ""hasMethod"", ""flush()""); (""FileWriter"", ""hasMethod"", ""write()""); (""FileWriter"", ""flush()"", ""flush()"")"
Notice how there is no longer any explicit close() method call to the FileWriter instance.,"(""FileWriter"", ""hasMethod"", ""close()"")"
"The Java InputStream class, java.io.InputStream, represents an ordered stream of bytes.","(""Java"", ""has class"", ""InputStream""); (""InputStream"", ""is in package"", ""java.io""); (""InputStream"", ""represents"", ""ordered stream of bytes""); (""java.io.InputStream"", ""is equivalent to"", ""InputStream"")"
The Java InputStream class is the base class (superclass) of all input streams in the Java IO API.,"(""Java InputStream"", ""is superclass of"", ""input streams""); (""Java IO API"", ""contains"", ""InputStream""); (""InputStream"", ""is part of"", ""Java IO API"")"
"Each subclass of InputStream typically has a very specific use, but can be used as an InputStream.","(""InputStream"", ""has subclass"", ""subclass of InputStream""); (""InputStream"", ""can be used as"", ""InputStream""); (""subclass of InputStream"", ""is a"", ""InputStream"")"
FileInputStream is a subclass of InputStream so it is safe to assign an instance of FileInputStream to an InputStream variable (the inputstream variable).,"(""FileInputStream"", ""is a subclass of"", ""InputStream""); (""InputStream"", ""has variable"", ""inputstream""); (""FileInputStream"", ""can be assigned to"", ""InputStream"")"
The read() method of an InputStream returns an int which contains the byte value of the byte read.,"(""InputStream"", ""hasMethod"", ""read()""); (""read()"", ""returns"", ""int"")"
"If the read() method returns -1, the end of stream has been reached, meaning there is no more data to read in the InputStream.","(""InputStream"", ""has method"", ""read()""); (""read()"", ""returns"", ""-1""); (""InputStream"", ""reaches end"", ""end of stream"")"
The InputStream class also contains two read() methods which can read data from the InputStream's source into a byte array.,"(""InputStream"", ""contains"", ""read()""); (""read()"", ""reads"", ""byte array""); (""InputStream"", ""has source"", ""source""); (""read()"", ""reads from"", ""InputStream's source"")"
"Inside the while loop the doSomethingWithData() method is called, passing along the data byte array as well as how many bytes were read into the array as parameters.","(""while loop"", ""calls"", ""doSomethingWithData()""); (""doSomethingWithData()"", ""takes"", ""data byte array""); (""doSomethingWithData()"", ""takes"", ""number of bytes read"")"
The Java InputStream class contains a method called readAllBytes() (since Java 9).,"(""Java InputStream"", ""contains"", ""readAllBytes()""); (""readAllBytes()"", ""is part of"", ""Java InputStream""); (""Java InputStream"", ""introduced in"", ""Java 9""); (""readAllBytes()"", ""introduced in"", ""Java 9"")"
Here is an example of reading all bytes from a Java InputStream via readAllBytes():,"(""InputStream"", ""hasMethod"", ""readAllBytes()""); (""InputStream"", ""isPartOf"", ""Java"")"
The InputStream class has two methods called mark() and reset() which subclasses of InputStream may or may not support.,"(""InputStream"", ""has method"", ""mark()""); (""InputStream"", ""has method"", ""reset()""); (""InputStream"", ""has subclasses"", ""subclasses of InputStream"")"
"If an InputStream subclass supports the mark() and reset() methods, then that subclass should override the markSupported() to return true.","(""InputStream"", ""supports"", ""mark()""); (""InputStream"", ""supports"", ""reset()""); (""InputStream"", ""should override"", ""markSupported()""); (""markSupported()"", ""should return"", ""true""); (""mark()"", ""is supported by"", ""InputStream""); (""reset()"", ""is supported by"", ""InputStream"")"
If the markSupported() method returns false then mark() and reset() are not supported.,"(""markSupported()"", ""returns"", ""false""); (""mark()"", ""is supported by"", ""markSupported()""); (""reset()"", ""is supported by"", ""markSupported()"")"
The mark() sets a mark internally in the InputStream which marks the point in the stream to which data has been read so far.,"(""InputStream"", ""has method"", ""mark()""); (""mark()"", ""is part of"", ""InputStream""); (""InputStream"", ""uses"", ""mark()"")"
"If the code using the InputStream wants to go back to the point in the stream where the mark was set, the code calls reset() on the InputStream.","(""InputStream"", ""hasMethod"", ""reset()""); (""InputStream"", ""calls"", ""reset()""); (""reset()"", ""belongsTo"", ""InputStream""); (""code"", ""uses"", ""InputStream""); (""InputStream"", ""hasMethod"", ""mark()""); (""mark()"", ""belongsTo"", ""InputStream""); (""code"", ""calls"", ""reset()""); (""InputStream"", ""isUsedBy"", ""code"")"
The methods mark() and reset() methods are typically used when implementing parsers.,"(""mark()"", ""used with"", ""reset()""); (""mark()"", ""typically used when implementing"", ""parsers""); (""reset()"", ""typically used when implementing"", ""parsers""); (""mark()"", ""used with"", ""parsers""); (""reset()"", ""used with"", ""parsers"")"
Notice how the while loop continues until a -1 value is read from the InputStream read() method.,"(""while loop"", ""continues until"", ""-1 value""); (""while loop"", ""uses"", ""InputStream read() method""); (""InputStream"", ""has method"", ""read() method"")"
"After that, the while loop exits, and the InputStream close() method is called.","(""InputStream"", ""has method"", ""close()"")"
"If an exception is thrown while reading data from the InputStream, the close() method is never called.","(""InputStream"", ""has method"", ""close()"")"
"The Java InputStreamReader class, java.io.InputStreamReader, wraps a Java InputStream, thereby turning the byte based InputStream into a character based Reader.","(""InputStreamReader"", ""wraps"", ""InputStream""); (""InputStreamReader"", ""turns into"", ""Reader""); (""InputStreamReader"", ""is part of"", ""java.io""); (""InputStream"", ""is part of"", ""java.io""); (""Reader"", ""is part of"", ""java.io"")"
The Java InputStreamReader class is thus a subclass of the Java Reader class.,"(""InputStreamReader"", ""is a subclass of"", ""Reader"")"
You can get the character encoding used by a Java InputStreamReader instance via its getEncoding() method.,"(""InputStreamReader"", ""has method"", ""getEncoding()""); (""getEncoding()"", ""returns"", ""character encoding""); (""InputStreamReader"", ""uses"", ""character encoding""); (""Java"", ""has class"", ""InputStreamReader""); (""InputStreamReader"", ""has method"", ""getEncoding()"")"
The read() method of an InputStreamReader returns an int which contains the char value of the char read.,"(""InputStreamReader"", ""hasMethod"", ""read()""); (""read()"", ""returns"", ""int"")"
"If the read() method returns -1, the end of stream has been reached, meaning there is no more data to read in the InputStreamReader.","(""InputStreamReader"", ""has method"", ""read()""); (""read()"", ""returns"", ""-1""); (""InputStreamReader"", ""uses"", ""stream""); (""stream"", ""has state"", ""end""); (""read()"", ""indicates"", ""end of stream"")"
"As you can see, the while loop keeps running until a -1 is read from the InputStreamReader read() method.","(""InputStreamReader"", ""has method"", ""read()"")"
"Once all the data is written to it, simply call the method toByteArray() or toCharArray, and all the data written is returned in array form.","(""toByteArray()"", ""is method of"", ""unknown class""); (""toCharArray"", ""is method of"", ""unknown class"")"
The Java CharArrayReader class (java.io.CharArrayReader) enables you to read the contents of a char array as a character stream.,"(""CharArrayReader"", ""is_part_of"", ""java.io""); (""CharArrayReader"", ""reads"", ""char_array""); (""CharArrayReader"", ""enables"", ""character_stream""); (""java.io"", ""contains"", ""CharArrayReader""); (""character_stream"", ""is_enabled_by"", ""CharArrayReader""); (""char_array"", ""is_read_by"", ""CharArrayReader"")"
"The Java CharArrayReader is handy when you have data in a char array, but need to pass that data to some component which can only read from a Reader (or a Reader subclass).","(""CharArrayReader"", ""is a"", ""Reader""); (""CharArrayReader"", ""is used with"", ""char array""); (""Reader"", ""has subclass"", ""Reader subclass""); (""CharArrayReader"", ""passes data to"", ""Reader""); (""CharArrayReader"", ""passes data to"", ""Reader subclass"")"
Closing a CharArrayReader can be done using the close() method like this:,"(""CharArrayReader"", ""hasMethod"", ""close()"")"
Notice that there is no explicit close() call on the CharArrayReader.,"(""CharArrayReader"", ""hasMethod"", ""close()"")"
The Java CharArrayWriter class (java.io.CharArrayWriter) makes it possible to write characters via the Writer methods (CharArrayWriter is a subclass of Writer) and convert the written characters into a char array.,"(""CharArrayWriter"", ""subclass of"", ""Writer""); (""CharArrayWriter"", ""uses"", ""Writer methods""); (""Writer"", ""has"", ""methods""); (""CharArrayWriter"", ""writes to"", ""char array""); (""CharArrayWriter"", ""is in"", ""java.io""); (""Writer"", ""is in"", ""java.io"")"
"The Java CharArrayWriter class is handy when you have a component that can only write characters to a Writer, but you need the characters as a char array.","(""CharArrayWriter"", ""is a"", ""class""); (""CharArrayWriter"", ""writes to"", ""Writer""); (""Writer"", ""receives characters from"", ""CharArrayWriter"")"
"Simply pass that component a CharArrayWriter and when all characters are written to it, call toCharArray() on the CharArrayWriter.","(""CharArrayWriter"", ""passed to"", ""component""); (""CharArrayWriter"", ""call method"", ""toCharArray()"")"
"Third, the written characters are obtained as a char array by calling the toCharArray() method on the CharArrayWriter.","(""CharArrayWriter"", ""hasMethod"", ""toCharArray()""); (""CharArrayWriter"", ""returns"", ""char array""); (""toCharArray()"", ""belongsTo"", ""CharArrayWriter"")"
Notice how there is no longer any explicit close() method call to the CharArrayWriter instance.,"(""CharArrayWriter"", ""hasMethod"", ""close()"")"
The Java DataOutputStream class enables you to write Java primitives to OutputStream's instead of only bytes.,"(""Java DataOutputStream"", ""enables"", ""writing Java primitives""); (""Java DataOutputStream"", ""writes to"", ""OutputStream""); (""Java primitives"", ""are written by"", ""Java DataOutputStream""); (""OutputStream"", ""is written to by"", ""Java DataOutputStream"")"
"As mentioned earlier, the DataOutputStream class is often used together with a DataInputStream.","(""DataOutputStream"", ""used together with"", ""DataInputStream"")"
But what happens if an exception is thrown from inside the doSomethingWithData() method?,"(""doSomethingWithData"", ""is a method of"", ""unknown class"")"
"Well, to catch that situation you will have to wrap the call to close() in a try-catch block too, like this:","(""close()"", ""wrapped in"", ""try-catch block"")"
"But, what happens if an exception is also thrown from the input.close() method?","(""input"", ""hasMethod"", ""close()"")"
"Separate pages will describe each of these methods or classes in more detail, including examples of their usage etc.",
The Java IO API contains the following classes which are relevant to working with files in Java:,"(""Java IO API"", ""contains"", ""classes""); (""classes"", ""are relevant to"", ""working with files in Java""); (""Java IO API"", ""is used for"", ""working with files in Java"")"
"These classes are explained in more detail in their own texts, but the sections below will give a brief introduction to these classes.",
"These two classes lets you read a file one byte or character at a time from the start to the end of the file, or read the bytes into an array of byte or char, again from start towards the end of the file.","(""File"", ""has method"", ""read()""); (""File"", ""has method"", ""readbyte()""); (""File"", ""has method"", ""readchar()""); (""File"", ""reads into"", ""byte array""); (""File"", ""reads into"", ""char array"")"
"As I have already mentioned, you can get random access to files with Java IO via the RandomAccessFile class.","(""Java IO"", ""uses"", ""RandomAccessFile class""); (""RandomAccessFile class"", ""provides"", ""random access""); (""Java IO"", ""utilizes"", ""RandomAccessFile"")"
Both file and directory information is available via the File class.,"(""File"", ""has"", ""information""); (""File"", ""provides"", ""directory information""); (""File"", ""provides"", ""file information"")"
The FilterInputStream is a base class for implementing your own filtering input streams.,"(""FilterInputStream"", ""is a base class for"", ""filtering input streams""); (""FilterInputStream"", ""implements"", ""filtering input streams"")"
"It is intended to be a base class for your own subclasses, but in my opinion you might as well just subclass InputStream directly.","(""InputStream"", ""is a base class for"", ""subclasses""); (""InputStream"", ""can be subclassed directly by"", ""subclasses""); (""subclasses"", ""subclass"", ""InputStream"")"
I cannot see that this class actually adds or changes any behaviour in InputStream except that it takes an InputStream in its constructor.,"(""InputStream"", ""has constructor"", ""InputStream"")"
The FilterOutputStream is a base class for implementing your own filtering output streams.,"(""FilterOutputStream"", ""is a base class for"", ""output streams"")"
I cannot see that this class actually adds or changes any behaviour in OutputStream except that it takes an OutputStream in its constructor.,"(""OutputStream"", ""has constructor"", ""OutputStream"")"
"If you choose to extend this class you might as well extend the OutputStream class directly, and avoid the extra class in the hierarchy.","(""OutputStream"", ""extended by"", ""this class""); (""this class"", ""extends"", ""OutputStream"")"
The FilterReader is a base class for implementing your own filtering readers.,"(""FilterReader"", ""is a base class for"", ""filtering readers"")"
"Like with FilterInputStream, I see no sensible purpose for this class.","(""FilterInputStream"", ""relatedTo"", ""class"")"
I cannot see that this class actually adds or changes any behaviour in Reader except that it takes a Reader in its constructor.,"(""Reader"", ""has constructor"", ""Reader"")"
"If you choose to extend this class you might as well extend the Reader class directly, and avoid the extra class in the hierarchy.","(""Reader"", ""extended by"", ""subclass""); (""Reader"", ""is base for"", ""subclass""); (""subclass"", ""extends"", ""Reader"")"
The FilterWriter is a base class for implementing your own filtering Writer's.,"(""FilterWriter"", ""is a base class for"", ""Writer"")"
"Like with FilterOutputStream, I see no sensible purpose for this class.","(""FilterOutputStream"", ""is related to"", ""class"")"
I cannot see that this class actually adds or changes any behaviour in Writer except that it takes a Writer in its constructor.,"(""Writer"", ""hasMethod"", ""constructor""); (""Writer"", ""takesInConstructor"", ""Writer"")"
"If you choose to extend this class you might as well extend the Writer class directly, and avoid the extra class in the hierarchy.","(""Writer"", ""extended by"", ""subclass""); (""Writer"", ""extended directly"", ""subclass""); (""subclass"", ""extends"", ""Writer""); (""Writer"", ""in hierarchy of"", ""subclass"")"
Some of the classes in the Java IO API are designed to help you parse input.,"(""Java IO API"", ""contains"", ""classes"")"
The purpose was rather to give you above quick list of classes related to parsing of input data.,"(""InputData"", ""relatedTo"", ""Parsing""); (""InputData"", ""parsedBy"", ""Classes""); (""Classes"", ""relatedTo"", ""Parsing"")"
If you have to parse data you will often end up writing your own classes that use some of the classes in this list.,"(""User"", ""uses"", ""classes""); (""classes"", ""are used by"", ""User""); (""classes"", ""are in"", ""list""); (""List"", ""contains"", ""classes""); (""User"", ""writes"", ""classes""); (""classes"", ""are written by"", ""User"")"
The Java LineNumberReader class (java.io.LineNumberReader is a BufferedReader that keeps track of line numbers of the read characters.,"(""LineNumberReader"", ""is a"", ""BufferedReader""); (""LineNumberReader"", ""keeps track of"", ""line numbers""); (""LineNumberReader"", ""is in package"", ""java.io""); (""BufferedReader"", ""is in package"", ""java.io"")"
You can get the current line number from the LineNumberReader by calling the getLineNumber() method.,"(""LineNumberReader"", ""has method"", ""getLineNumber()"")"
"You can also set the current line number, should you need to, by calling the setLineNumber() method.","(""setLineNumber()"", ""called by"", ""undefined""); (""setLineNumber()"", ""belongs to"", ""undefined"")"
Since FileOutputStream is a subclass of OutputStream this should be no problem.,"(""FileOutputStream"", ""is a subclass of"", ""OutputStream"")"
In this example the process() method cannot see if the InputStream it gets as parameter comes from the file system or the network (the example only shows the file system version).,"(""process()"", ""gets"", ""InputStream""); (""process()"", ""cannot see"", ""file system""); (""process()"", ""cannot see"", ""network""); (""InputStream"", ""comes from"", ""file system""); (""InputStream"", ""comes from"", ""network"")"
The Java ObjectInputStream class (java.io.ObjectInputStream) enables you to read Java objects from an InputStream instead of just raw bytes.,"(""ObjectInputStream"", ""enables"", ""reading Java objects""); (""ObjectInputStream"", ""reads from"", ""InputStream""); (""ObjectInputStream"", ""is in package"", ""java.io"")"
"For this ObjectInputStream example to work the object you read must be an instance of MyClass, and must have been serialized into the file ""object.data"" via an ObjectOutputStream.","(""ObjectInputStream"", ""instance of"", ""MyClass""); (""MyClass"", ""serialized via"", ""ObjectOutputStream""); (""ObjectInputStream"", ""reads from"", ""file object.data""); (""ObjectOutputStream"", ""writes to"", ""file object.data"")"
Before you can serialize and de-serialize objects the class of the object must implement java.io.Serializable.,
"After that the ObjectInputStream is also closed, and the values read into the Person object are printed to System.out.","(""ObjectInputStream"", ""closed"", ""ObjectInputStream""); (""Person"", ""read into"", ""values""); (""values"", ""printed to"", ""System.out""); (""ObjectInputStream"", ""used to read"", ""Person"")"
The Java ObjectOutputStream class (java.io.ObjectOutputStream) enables you to write Java objects to an OutputStream instead of just raw bytes.,"(""Java ObjectOutputStream"", ""enables"", ""write Java objects""); (""Java ObjectOutputStream"", ""writes to"", ""OutputStream""); (""OutputStream"", ""contains"", ""raw bytes""); (""Java ObjectOutputStream"", ""is in package"", ""java.io"")"
In this text I will try to give you an overview of the classes in the Java IO (java.io) package.,"(""Java IO"", ""contains"", ""java.io""); (""java.io"", ""is package of"", ""classes"")"
"More specifically, I will try to group the classes after their purpose.","(""classes"", ""grouped by"", ""purpose"")"
"This grouping should make it easier for you in the future, to determine the purpose of a class, or find the class you need for a specific purpose.","(""class"", ""is used for"", ""purpose""); (""class"", ""is needed for"", ""purpose""); (""class"", ""has"", ""purpose"")"
"Java IO contains many subclasses of the InputStream, OutputStream, Reader and Writer classes.","(""Java IO"", ""contains"", ""InputStream""); (""Java IO"", ""contains"", ""OutputStream""); (""Java IO"", ""contains"", ""Reader""); (""Java IO"", ""contains"", ""Writer""); (""InputStream"", ""is a subclass of"", ""Java IO""); (""OutputStream"", ""is a subclass of"", ""Java IO""); (""Reader"", ""is a subclass of"", ""Java IO""); (""Writer"", ""is a subclass of"", ""Java IO"")"
"The reason is, that all of these subclasses are addressing various different purposes.",
These purposes are nice to know about when reading through the Java IO classes.,"(""Java IO"", ""contains"", ""classes"")"
They make it somewhat easier to understand what the classes are targeting.,
"Having discussed sources, destinations, input, output and the various IO purposes targeted by the Java IO classes, here is a table listing most (if not all) Java IO classes divided by input, output, being byte based or character based, and any more specific purpose they may be addressing, like buffering, parsing etc.","(""Java IO"", ""divided by"", ""input""); (""Java IO"", ""divided by"", ""output""); (""Java IO"", ""divided by"", ""byte based""); (""Java IO"", ""divided by"", ""character based""); (""Java IO"", ""has purpose"", ""buffering""); (""Java IO"", ""has purpose"", ""parsing"")"
The PipedInputStream class makes it possible to read the contents of a pipe as a stream of bytes.,"(""PipedInputStream"", ""makes it possible to read"", ""pipe""); (""PipedInputStream"", ""reads"", ""bytes""); (""PipedInputStream"", ""is a"", ""stream"")"
The read() method of a PipedInputStream returns an int which contains the byte value of the byte read.,"(""PipedInputStream"", ""has method"", ""read()""); (""read()"", ""returns"", ""int"")"
"If the read() method returns -1, there is no more data to read in the stream, and it can be closed.","(""stream"", ""has method"", ""read()""); (""read()"", ""returns"", ""-1""); (""stream"", ""can be"", ""closed"")"
"Since PipedInputStream is a subclass of InputStream, PipedInputStream has the same basic methods and use patterns as an InputStream.","(""PipedInputStream"", ""is a subclass of"", ""InputStream""); (""PipedInputStream"", ""has methods"", ""InputStream""); (""PipedInputStream"", ""has use patterns"", ""InputStream"")"
The PipedOutputStream class makes it possible to write to a Java pipe as a stream of bytes.,"(""PipedOutputStream"", ""makes it possible to write to"", ""Java pipe""); (""PipedOutputStream"", ""is a"", ""stream of bytes""); (""PipedOutputStream"", ""writes to"", ""Java pipe"")"
The write() method of a PipedOutputStream takes an int which contains the byte value of the byte to write.,"(""PipedOutputStream"", ""has method"", ""write()""); (""write()"", ""takes parameter"", ""int""); (""PipedOutputStream"", ""contains method"", ""write()"")"
"Since PipedOutputStream is a subclass of OutputStream, PipedOutputStream has the same basic methods and use patterns as an OutputStream.","(""PipedOutputStream"", ""is a subclass of"", ""OutputStream""); (""PipedOutputStream"", ""has methods"", ""OutputStream""); (""PipedOutputStream"", ""has use patterns"", ""OutputStream"")"
The Java PipedReader class (java.io.PipedReader) makes it possible to read the contents of a pipe as a stream of characters.,"(""java.io.PipedReader"", ""makes"", ""possible""); (""java.io.PipedReader"", ""read"", ""pipe""); (""pipe"", ""as"", ""stream of characters""); (""java.io.PipedReader"", ""is"", ""class""); (""Java"", ""has"", ""java.io.PipedReader""); (""pipe"", ""contains"", ""stream of characters""); (""java.io.PipedReader"", ""reads"", ""contents of a pipe"")"
The read() method of a Java PipedReader returns an int which contains the char value of the character read.,"(""PipedReader"", ""has method"", ""read()""); (""read()"", ""returns"", ""int"")"
"If the read() method returns -1, there is no more data to read in the PipedReader, and it can be closed.","(""PipedReader"", ""has method"", ""read()""); (""read()"", ""returns"", ""-1""); (""PipedReader"", ""can be"", ""closed"")"
Notice how there is no longer any explicit close() method call to the PipedReader instance.,"(""PipedReader"", ""hasMethod"", ""close()"")"
The Java PipedWriter class (java.io.PipedWriter) makes it possible to write to a Java pipe as a stream of characters.,"(""java.io.PipedWriter"", ""makes it possible to write to"", ""java pipe""); (""java.io.PipedWriter"", ""is a part of"", ""java.io""); (""java pipe"", ""is used as"", ""stream of characters"")"
The write() method of a PipedWriter takes an int which contains the byte value of the byte to write.,"(""PipedWriter"", ""has method"", ""write()""); (""write()"", ""takes"", ""int""); (""PipedWriter"", ""contains"", ""byte""); (""write()"", ""writes"", ""byte"")"
"There are also versions of the write() method that take a String, char array etc.","(""write()"", ""is a method of"", ""unknown class""); (""write()"", ""takes"", ""String""); (""write()"", ""takes"", ""char array"")"
Notice how there is no longer any explicit close() method call to the PipedWriter instance.,"(""PipedWriter"", ""hasMethod"", ""close()"")"
Creating a pipe using Java IO is done via the PipedOutputStream and PipedInputStream classes.,"(""PipedOutputStream"", ""uses"", ""Java IO""); (""PipedInputStream"", ""uses"", ""Java IO""); (""PipedOutputStream"", ""related to"", ""PipedInputStream"")"
You can also connect the two pipe streams using their connect() methods.,"(""pipe streams"", ""have"", ""connect() methods""); (""pipe streams"", ""use"", ""connect() methods""); (""connect() methods"", ""belong to"", ""pipe streams"")"
Both PipedInputStream and PipedOutputStream has a connect() method that can connect one to the other.,"(""PipedInputStream"", ""has method"", ""connect()""); (""PipedOutputStream"", ""has method"", ""connect()""); (""PipedInputStream"", ""connects to"", ""PipedOutputStream""); (""PipedOutputStream"", ""connects to"", ""PipedInputStream""); (""connect()"", ""is method of"", ""PipedInputStream""); (""connect()"", ""is method of"", ""PipedOutputStream"")"
"The read() and write() calls on the streams are blocking, meaning if you try to use the same thread to both read and write, this may result in the thread deadlocking itself.","(""streams"", ""hasMethod"", ""read()""); (""streams"", ""hasMethod"", ""write()""); (""read()"", ""isCalledOn"", ""streams""); (""write()"", ""isCalledOn"", ""streams""); (""threads"", ""mayCall"", ""read()""); (""threads"", ""mayCall"", ""write()""); (""threads"", ""mayDeadlock"", ""threads"")"
The Java PrintStream class (java.io.PrintStream) enables you to write formatted data to an underlying OutputStream.,"(""PrintStream"", ""enables"", ""write formatted data""); (""PrintStream"", ""extends"", ""OutputStream""); (""PrintStream"", ""is in"", ""java.io""); (""PrintStream"", ""writes to"", ""OutputStream""); (""PrintStream"", ""is part of"", ""java.io"")"
"The PrintStream class can format primitive types like int, long etc.","(""PrintStream"", ""can format"", ""int""); (""PrintStream"", ""can format"", ""long"")"
You may be familiar with these two well-known PrintStream instances in Java: System.out and System.err .,"(""PrintStream"", ""is-instance-of"", ""System.out""); (""PrintStream"", ""is-instance-of"", ""System.err""); (""System"", ""contains"", ""System.out""); (""System"", ""contains"", ""System.err"")"
"The Java PrintStream class contains the powerful format() and printf() methods (they do exactly the same, but the name ""printf"" is more familiar to C-programmers).","(""Java PrintStream"", ""contains"", ""format()""); (""Java PrintStream"", ""contains"", ""printf()"")"
The Java PrintWriter class (java.io.PrintWriter) enables you to write formatted data to an underlying Writer.,"(""PrintWriter"", ""enables"", ""write formatted data""); (""PrintWriter"", ""extends"", ""Writer""); (""PrintWriter"", ""is in"", ""java.io""); (""PrintWriter"", ""writes to"", ""Writer"")"
The PrintWriter class has all the same methods as the PrintStream except for the methods to write raw bytes.,"(""PrintWriter"", ""has methods"", ""PrintStream""); (""PrintStream"", ""has methods"", ""PrintWriter""); (""PrintWriter"", ""does not have methods"", ""write raw bytes""); (""PrintStream"", ""has methods"", ""write raw bytes"")"
Being a Writer subclass the PrintWriter is intended to write text.,"(""Writer"", ""subclass"", ""PrintWriter""); (""PrintWriter"", ""intended to"", ""write text""); (""Writer"", ""subclass"", ""PrintWriter"")"
"Third, the example calls the advanced printf() method of the PrintWriter which can insert formatted numbers into a text string.","(""PrintWriter"", ""calls"", ""printf()""); (""printf()"", ""inserts"", ""numbers""); (""PrintWriter"", ""has method"", ""printf()"")"
"In that way the PrintWriter is a bit different from other Writer subclasses which tend to have mostly constructors that can take other Writer instances as parameters (except for a few, like OutputStreamWriter).","(""PrintWriter"", ""is a subclass of"", ""Writer""); (""Writer"", ""has subclasses"", ""OutputStreamWriter""); (""OutputStreamWriter"", ""is a subclass of"", ""Writer""); (""PrintWriter"", ""is different from"", ""Writer subclasses""); (""Writer subclasses"", ""have constructors that take"", ""Writer instances""); (""OutputStreamWriter"", ""has constructors that take"", ""parameters""); (""Writer subclasses"", ""have constructors that take"", ""parameters""); (""PrintWriter"", ""has constructors"", ""constructors""); (""OutputStreamWriter"", ""is an exception to"", ""Writer subclasses"")"
The Java PrintWriter class contains the powerful format() and printf() methods.,"(""Java PrintWriter class"", ""contains"", ""format() method""); (""Java PrintWriter class"", ""contains"", ""printf() method"")"
"The format() and printf() methods allow you to mix text and data in very advanced ways, using a formatting string.","(""format()"", ""used with"", ""text""); (""format()"", ""used with"", ""data""); (""printf()"", ""used with"", ""text""); (""printf()"", ""used with"", ""data""); (""format()"", ""uses"", ""formatting string""); (""printf()"", ""uses"", ""formatting string"")"
The Java Reader (java.io.Reader) and Java Writer class (java.io.Writer) in Java IO work much like the InputStream and OutputStream with the exception that Reader and Writer are character based.,"(""Java Reader"", ""is similar to"", ""InputStream""); (""Java Writer"", ""is similar to"", ""OutputStream""); (""Java Reader"", ""is part of"", ""java.io""); (""Java Writer"", ""is part of"", ""java.io""); (""InputStream"", ""is part of"", ""Java IO""); (""OutputStream"", ""is part of"", ""Java IO""); (""Java Reader"", ""works with"", ""Java Writer"")"
The Java Reader is the base class of all Reader's in the Java IO API.,"(""Java Reader"", ""is base class of"", ""Reader""); (""Reader"", ""is part of"", ""Java IO API""); (""Java Reader"", ""is part of"", ""Java IO API"")"
The Java Writer class is the base class of all Writers in the Java IO API.,"(""Java Writer"", ""is base class of"", ""Writers""); (""Java Writer"", ""is part of"", ""Java IO API""); (""Writers"", ""inherit from"", ""Java Writer"")"
Before you can use the SequenceInputStream you must import it in your Java class.,"(""SequenceInputStream"", ""imported in"", ""Java class"")"
"This import statement should be at the top of your Java class, right under the package declaration.","(""import statement"", ""located in"", ""Java class""); (""import statement"", ""placed under"", ""package declaration""); (""package declaration"", ""located in"", ""Java class"")"
"The FileInputStream extends the InputStream class, so they can be used with the SequenceInputStream.","(""FileInputStream"", ""extends"", ""InputStream""); (""FileInputStream"", ""used with"", ""SequenceInputStream""); (""InputStream"", ""used with"", ""SequenceInputStream"")"
"When there is no more data to read from the second InputStream, the SequenceInputStream read() method will return -1, just like any other InputStream does.","(""SequenceInputStream"", ""has method"", ""read()""); (""InputStream"", ""has method"", ""read()""); (""SequenceInputStream"", ""is a type of"", ""InputStream"")"
The Java Serializable interface (java.io.Serializable is a marker interface your classes must implement if they are to be serialized and deserialized.,"(""Java"", ""has interface"", ""java.io.Serializable""); (""java.io.Serializable"", ""is implemented by"", ""classes""); (""java.io.Serializable"", ""used for"", ""serialization""); (""java.io.Serializable"", ""used for"", ""deserialization""); (""classes"", ""implement"", ""java.io.Serializable""); (""classes"", ""must be"", ""serialized""); (""classes"", ""must be"", ""deserialized"")"
"Therefore, a class implementing Serializable does not have to implement any specific methods.","(""Serializable"", ""implements"", ""no specific methods"")"
Implementing Serializable thus just tells the Java serialization classes that this class is intended for object serialization.,"(""Java serialization classes"", ""use"", ""Serializable""); (""Serializable"", ""implemented by"", ""this class""); (""this class"", ""intended for"", ""object serialization"")"
Here is an example of a class that implements the Java Serializable interface:,"(""Java"", ""implements"", ""Serializable""); (""Serializable"", ""is implemented by"", ""example class""); (""example class"", ""implements"", ""Java Serializable interface""); (""Java Serializable interface"", ""is implemented by"", ""example class""); (""example class"", ""is a"", ""class""); (""Java"", ""has interface"", ""Serializable""); (""Serializable"", ""is a"", ""Java interface"")"
"As you can see, the Person class implements the Serializable interface, but does not actually implement any methods.","(""Person"", ""implements"", ""Serializable"")"
"In addition to implementing the Serializable interface, a class intended for serialization should also contain a private static final long variable named serialVersionUID.","(""Serializable"", ""is implemented by"", ""a class intended for serialization""); (""a class intended for serialization"", ""contains"", ""a private static final long variable""); (""a private static final long variable"", ""is named"", ""serialVersionUID"")"
"Here is the Person class from before, with a serialVersionUID variable added:","(""Person"", ""has"", ""serialVersionUID"")"
"The serialVersionUID variable is used by Java's object serialization API to determine if a deserialized object was serialized (written) with the same version of the class, as it is now attempting to deserialize it into.","(""Java"", ""uses"", ""object serialization API""); (""object serialization API"", ""determines"", ""serialVersionUID""); (""serialVersionUID"", ""used by"", ""Java's object serialization API""); (""Java's object serialization API"", ""serializes"", ""object""); (""object"", ""deserialized by"", ""Java's object serialization API"")"
Now the serialized Person object may not correspond to the new version of the Person class.,"(""Person"", ""may not correspond to"", ""Person class""); (""Person object"", ""is an instance of"", ""Person class""); (""Person class"", ""has a new version of"", ""Person class"")"
To detect such problems a class implementing Serializable should contain a serialVersionUID field.,"(""Serializable"", ""should contain"", ""serialVersionUID""); (""Serializable"", ""implementing"", ""serialVersionUID""); (""serialVersionUID"", ""field of"", ""Serializable"")"
"If you make big changes to the class, you should also change its serialVersionUID value.","(""class"", ""has attribute"", ""serialVersionUID""); (""class"", ""has method"", ""serialVersionUID change""); (""serialVersionUID"", ""is attribute of"", ""class"")"
"These other object serialization mechanisms typically do not require your Java classes to implement Serializable, by the way.","(""Java classes"", ""implement"", ""Serializable"")"
"They are typically using Java Reflection to inspect your class, so implementing the Serializable interface would be superflous - it would not add any useful information.","(""Serializable"", ""implements"", ""interface""); (""Java Reflection"", ""inspects"", ""class"")"
The class java.io.InputStream is the base class for all Java IO input streams.,"(""java.io.InputStream"", ""is base class for"", ""Java IO input streams"")"
"If you are writing a component that needs to read input from a stream, try to make our component depend on an InputStream, rather than any of it's subclasses (e.g.","(""Component"", ""depends on"", ""InputStream"")"
"Doing so makes your code able to work with all types of input streams, instead of only the concrete subclass.",
Otherwise your code will not be able to call the unread() method on the PushbackInputStream.,"(""PushbackInputStream"", ""has method"", ""unread()"")"
You typically read data from an InputStream by calling the read() method.,"(""InputStream"", ""has method"", ""read()"")"
The read() method returns a int containing the byte value of the byte read.,"(""read()"", ""returns"", ""int"")"
"If there is no more data to be read, the read() method typically returns -1;","(""read()"", ""returns"", ""-1"")"
The class java.io.OutputStream is the base class of all Java IO output streams.,"(""java.io.OutputStream"", ""is base class of"", ""Java IO output streams"")"
"If you are writing a component that needs to write output to a stream, try to make sure that component depends on an OutputStream and not one of its subclasses.","(""OutputStream"", ""hasSubclass"", ""subclass""); (""component"", ""dependsOn"", ""OutputStream""); (""component"", ""writesOutputTo"", ""OutputStream""); (""OutputStream"", ""isSuperclassOf"", ""subclass"")"
You can even write your own stream classes to wrap the standard stream classes that comes with Java.,"(""Java"", ""comes with"", ""standard stream classes""); (""standard stream classes"", ""wrapped by"", ""stream classes""); (""stream classes"", ""written by"", ""user""); (""Java"", ""has"", ""standard stream classes"")"
The Java StringReader class enables you to turn an ordinary String into a Reader.,"(""StringReader"", ""enables"", ""Reader""); (""StringReader"", ""turns"", ""String""); (""Java"", ""has class"", ""StringReader"")"
Closing a Java StringReader can be done using the close() method like this:,"(""StringReader"", ""has method"", ""close()"")"
Notice that there is no explicit close() call on the StringReader.,"(""StringReader"", ""hasMethod"", ""close()"")"
The Java StringWriter class (java.io.StringWriter) enables you to obtain the characters written to a Writer as a String.,"(""StringWriter"", ""enables"", ""Writer""); (""StringWriter"", ""is part of"", ""java.io""); (""Writer"", ""is used by"", ""StringWriter"")"
Third the characters written to the StringWriter are obtained via the two methods toString() and getBuffer().,"(""StringWriter"", ""hasMethod"", ""toString()""); (""StringWriter"", ""hasMethod"", ""getBuffer()"")"
The method toString() returns the characters written to the StringWriter as a String.,"(""StringWriter"", ""hasMethod"", ""toString()""); (""toString()"", ""returns"", ""String"")"
The method getBuffer() returns the StringBuffer used by the StringWriter to build the string from the written characters.,"(""StringWriter"", ""uses"", ""StringBuffer""); (""getBuffer()"", ""returns"", ""StringBuffer""); (""StringWriter"", ""has method"", ""getBuffer()"")"
Notice how there is no longer any explicit close() method call to the StringWriter instance.,"(""StringWriter"", ""hasMethod"", ""close()""); (""StringWriter"", ""instanceOf"", ""StringWriter""); (""StringWriter"", ""methodCall"", ""close()"")"
The Java IO API is located in the Java IO package (java.io).,"(""Java IO API"", ""is located in"", ""java.io"")"
If you look at the Java IO classes in the java.io package the vast amount of choices can be rather confusing.,"(""Java IO"", ""located in"", ""java.io""); (""java.io"", ""contains"", ""Java IO classes"")"
"The purpose of this tutorial is to try to give you an overview of how all these classes are grouped, and the purpose behind them, so you don't have to wonder whether you chose the right class, or whether a class already exists for your purpose.","(""class"", ""is grouped with"", ""class""); (""class"", ""exists for"", ""purpose""); (""class"", ""is chosen by"", ""user""); (""class"", ""has"", ""purpose"")"
"That tutorial gives you a quick overview of the central concepts in the Java IO API, and an overview of all the central classes in the Java IO API.","(""Java IO API"", ""contains"", ""central concepts""); (""Java IO API"", ""contains"", ""central classes"")"
The java.io package doesn't actually address all types of input and output.,"(""java.io"", ""doesn't address"", ""input""); (""java.io"", ""doesn't address"", ""output"")"
"Those types of input are covered elsewhere, for instance by the JFC classes in the Swing project, or the Servlet and HTTP packages in the Java Enterprise Edition.","(""JFC"", ""isPartOf"", ""Swing""); (""Servlet"", ""isPartOf"", ""Java Enterprise Edition""); (""HTTP"", ""isPartOf"", ""Java Enterprise Edition"")"
"However, the Java IO package does not contain classes to open network sockets which are necessary for network communication.","(""Java IO package"", ""contains"", ""classes""); (""Java IO package"", ""does not contain"", ""network sockets""); (""network sockets"", ""are necessary for"", ""network communication""); (""classes"", ""are part of"", ""Java IO package"")"
"Once you have opened a socket (network connection) though, you read and write data to and from it via Java IO's InputStream and OutputStream classes.","(""Java IO"", ""has"", ""InputStream""); (""Java IO"", ""has"", ""OutputStream""); (""InputStream"", ""used for"", ""reading data""); (""OutputStream"", ""used for"", ""writing data"")"
"It contains classes that does much of the same as the Java IO and Java Networking APIs, but Java NIO can work in non-blocking mode.","(""Java NIO"", ""contains"", ""Java IO""); (""Java NIO"", ""contains"", ""Java Networking APIs""); (""Java IO"", ""compared to"", ""Java NIO""); (""Java Networking APIs"", ""compared to"", ""Java NIO""); (""Java NIO"", ""works in mode"", ""non-blocking mode"")"
The tutorial trail called Java How To's and Utilities also contain a few Java IO utilities - e.g.,
"Here is a table listing most (if not all) Java IO classes divided by input, output, being byte based or character based, and any more specific purpose they may be addressing, like buffering, parsing etc.","(""Java IO"", ""contains"", ""input classes""); (""Java IO"", ""contains"", ""output classes""); (""Java IO"", ""divided by"", ""byte based classes""); (""Java IO"", ""divided by"", ""character based classes""); (""Java IO"", ""includes"", ""buffering classes""); (""Java IO"", ""includes"", ""parsing classes"")"
"The Java OutputStream class, java.io.OutputStream, is the base class of all output streams in the Java IO API.","(""Java OutputStream"", ""is base class of"", ""all output streams""); (""all output streams"", ""are part of"", ""Java IO API""); (""Java IO API"", ""contains"", ""java.io.OutputStream""); (""java.io.OutputStream"", ""is part of"", ""Java IO API"")"
Subclasses of OutputStream include the Java BufferedOutputStream and the Java FileOutputStream among others.,"(""OutputStream"", ""includes"", ""BufferedOutputStream""); (""OutputStream"", ""includes"", ""FileOutputStream"")"
Here are some of the well-known subclasses of the Java OutputStream class:,"(""OutputStream"", ""has subclasses"", ""subclasses""); (""Java"", ""contains class"", ""OutputStream""); (""OutputStream"", ""is part of"", ""Java""); (""subclasses"", ""are part of"", ""Java""); (""OutputStream"", ""has subclasses"", ""subclasses of OutputStream"")"
The write() method of an OutputStream takes an int which contains the byte value of the byte to write.,"(""OutputStream"", ""has method"", ""write()""); (""write()"", ""takes parameter"", ""int""); (""OutputStream"", ""contains"", ""byte""); (""write()"", ""writes"", ""byte"")"
This OutputStream write() example first creates a FileOutputStream to which the data will be written.,"(""OutputStream"", ""hasMethod"", ""write()""); (""FileOutputStream"", ""extends"", ""OutputStream""); (""FileOutputStream"", ""usedFor"", ""writing data""); (""OutputStream"", ""uses"", ""FileOutputStream"")"
The condition to exit the while loop is the return value of the method hasMoreData().,"(""while loop"", ""uses"", ""hasMoreData()""); (""hasMoreData()"", ""is method of"", ""unknown class"")"
"The implementation of hasMoreData() is not shown, but imagine that it returns true if there is more data to write, and false if not.","(""hasMoreData()"", ""is method of"", ""unknown class"")"
"Inside the while loop the example calls the method getMoreData() to get the next data to write to the OutputStream, and then writes that data to the OutputStream.","(""while loop"", ""calls"", ""getMoreData()""); (""getMoreData()"", ""returns"", ""data""); (""data"", ""writes to"", ""OutputStream""); (""getMoreData()"", ""gets"", ""next data""); (""next data"", ""writes to"", ""OutputStream"")"
The Java OutputStream's flush() method flushes all data written to the OutputStream to the underlying data destination.,"(""OutputStream"", ""has_method"", ""flush()""); (""flush()"", ""belongs_to"", ""OutputStream""); (""OutputStream"", ""writes_to"", ""data destination"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your OutputStream has).","(""OutputStream"", ""has method"", ""flush()""); (""flush()"", ""writes to"", ""disk""); (""flush()"", ""writes to"", ""network""); (""OutputStream"", ""has destination"", ""disk""); (""OutputStream"", ""has destination"", ""network"")"
Here is an example of flushing data written to a Java OutputStream by calling its flush() method:,"(""OutputStream"", ""has method"", ""flush()"")"
"What matters is, that once the while loop ends, and you are done writing data to the OutputStream, its close() method is called, which closes the OutputStream .","(""OutputStream"", ""has method"", ""close()""); (""while loop"", ""ends"", ""OutputStream""); (""OutputStream"", ""has method"", ""write()""); (""OutputStream"", ""is closed by"", ""close()"")"
"Once the try block is exited, the close() method of the OutputStream is called automatically, because the OutputStream was declared inside the parentheses of the try block.","(""OutputStream"", ""hasMethod"", ""close()""); (""try block"", ""contains"", ""OutputStream""); (""OutputStream"", ""isCalled"", ""close()"")"
You can convert a OutputStream to a character based Writer using the Java OutputStreamWriter class.,"(""OutputStream"", ""can be converted to"", ""Writer""); (""OutputStream"", ""uses"", ""OutputStreamWriter""); (""OutputStreamWriter"", ""converts"", ""OutputStream""); (""OutputStreamWriter"", ""to"", ""Writer"")"
"The Java OutputStreamWriter class, java.io.OutputStreamWriter, is intended to wrap an Java OutputStream and thereby turning the byte based output stream into a character based Writer.","(""OutputStreamWriter"", ""wraps"", ""OutputStream""); (""OutputStreamWriter"", ""is part of"", ""java.io""); (""OutputStream"", ""is part of"", ""java.io""); (""OutputStreamWriter"", ""turns into"", ""Writer"")"
"The Java OutputStreamWriter is useful if you need to write characters to a file, encoded as e.g.","(""OutputStreamWriter"", ""is useful for"", ""writing characters to a file""); (""OutputStreamWriter"", ""writes to"", ""file""); (""OutputStreamWriter"", ""encodes as"", ""characters"")"
The Java OutputStreamWriter is a subclass of the Java Writer class.,"(""OutputStreamWriter"", ""is a subclass of"", ""Writer"")"
"The Java OutputStreamWriter also has alternative constructors that allow you to specify the character set (ISO-Latin1, UTF-8, UTF-16 etc.)","(""OutputStreamWriter"", ""has"", ""constructors""); (""constructors"", ""allow specification of"", ""character set""); (""character set"", ""includes"", ""ISO-Latin1""); (""character set"", ""includes"", ""UTF-8""); (""character set"", ""includes"", ""UTF-16""); (""OutputStreamWriter"", ""uses"", ""character set"")"
The Java OutputStreamWriter's flush() method flushes all data written to the OutputStreamWriter to the underlying data destination.,"(""OutputStreamWriter"", ""hasMethod"", ""flush()""); (""flush()"", ""belongsTo"", ""OutputStreamWriter""); (""OutputStreamWriter"", ""writesTo"", ""data destination""); (""OutputStreamWriter"", ""uses"", ""OutputStream"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your OutputStreamWriter has).","(""OutputStreamWriter"", ""hasMethod"", ""flush()""); (""flush()"", ""writesTo"", ""disk""); (""flush()"", ""writesTo"", ""network"")"
Here is an example of flushing data written to a Java OutputStreamWriter by calling its flush() method:,"(""OutputStreamWriter"", ""hasMethod"", ""flush()""); (""Java"", ""uses"", ""OutputStreamWriter""); (""OutputStreamWriter"", ""writesTo"", ""OutputStream""); (""flush()"", ""belongsTo"", ""OutputStreamWriter"")"
These bytes will then be read again the next time you call read().,"(""read()"", ""called by"", ""next time""); (""bytes"", ""read by"", ""read()""); (""read()"", ""reads"", ""bytes"")"
"The Java PushbackInputStream is a subclass of the Java InputStream so it inherits its public methods - read(), close() etc.","(""PushbackInputStream"", ""is a subclass of"", ""InputStream""); (""PushbackInputStream"", ""inherits"", ""read()""); (""PushbackInputStream"", ""inherits"", ""close()"")"
The call to read() reads a byte just like from an InputStream.,"(""read()"", ""is a method of"", ""InputStream"")"
The call to unread() pushes a byte back into the PushbackInputStream.,"(""PushbackInputStream"", ""has method"", ""unread()""); (""unread()"", ""is part of"", ""PushbackInputStream"")"
The next time read() is called the pushed back bytes will be read first.,"(""read"", ""is called"", ""pushed back bytes""); (""pushed back bytes"", ""will be read"", ""first""); (""read"", ""will be read"", ""pushed back bytes"")"
"If you push back multiple bytes into the PushbackInputStream, the latest byte pushed back will be returned first from read(), just like on a stack.","(""PushbackInputStream"", ""has method"", ""read()""); (""read()"", ""returns"", ""byte""); (""PushbackInputStream"", ""pushes back"", ""byte"")"
"You read bytes from the Java PushbackInputStream via its read() method, just like you do from a regular InputStream .","(""PushbackInputStream"", ""has method"", ""read()""); (""InputStream"", ""has method"", ""read()""); (""PushbackInputStream"", ""inherits from"", ""InputStream"")"
"Notice, that once the PushbackInputStream has no more bytes to read, from its underlying PushbackInputStream, the read() method will return -1.","(""PushbackInputStream"", ""has method"", ""read()""); (""PushbackInputStream"", ""has underlying"", ""PushbackInputStream""); (""read()"", ""returns"", ""-1"")"
To push a byte back into the Java PushbackInputStream you use the unread() method.,"(""PushbackInputStream"", ""uses"", ""unread()""); (""unread()"", ""method of"", ""PushbackInputStream""); (""PushbackInputStream"", ""is a"", ""Java class""); (""unread()"", ""belongs to"", ""PushbackInputStream"")"
"This example first reads a byte from the PushbackInputStream, then pushes it back into the PushbackInputStream, and then reads that byte back again with the final read() call.","(""PushbackInputStream"", ""reads"", ""byte""); (""byte"", ""is pushed back into"", ""PushbackInputStream""); (""PushbackInputStream"", ""reads"", ""byte"")"
"The Java PushbackReader class, java.io.PushbackReader, is intended to be used when you parse data from a Reader.","(""Java"", ""uses"", ""PushbackReader""); (""PushbackReader"", ""extends"", ""Reader""); (""PushbackReader"", ""belongs to"", ""java.io"")"
These characters will then be read again the next time you call read().,"(""read()"", ""called by"", ""next time""); (""read()"", ""has relationship"", ""call""); (""call"", ""triggers"", ""read()"")"
The call to read() reads a character from the PushbackReader just like from any other Reader.,"(""PushbackReader"", ""has method"", ""read()""); (""Reader"", ""has method"", ""read()""); (""PushbackReader"", ""inherits from"", ""Reader"")"
The call to unread() pushes a character back into the PushbackReader.,"(""PushbackReader"", ""has method"", ""unread()""); (""unread()"", ""pushes character back into"", ""PushbackReader"")"
The next time read() is called the pushed back characters will be read first.,"(""read()"", ""is called"", ""pushed back characters"")"
"If you push back multiple characters into the PushbackReader, the latest pushed back character will be returned first from the read() method, just like with a stack.","(""PushbackReader"", ""has method"", ""read()""); (""read()"", ""returns"", ""character""); (""PushbackReader"", ""uses"", ""stack"")"
You read characters from a Java PushbackReader just like you do from a Java Reader - because PushbackReader is a Java Reader subclass.,"(""PushbackReader"", ""is a subclass of"", ""Reader""); (""PushbackReader"", ""inherits from"", ""Reader""); (""Reader"", ""has subclass"", ""PushbackReader"")"
"In other words, you use its read() method which is inherited from the Reader class.","(""Reader"", ""has method"", ""read()""); (""Reader"", ""inherits"", ""read()""); (""read()"", ""is method of"", ""Reader"")"
Here is an example of reading characters from a Java PushbackReader via its read() method:,"(""PushbackReader"", ""has method"", ""read()""); (""Java"", ""uses"", ""PushbackReader""); (""PushbackReader"", ""uses method"", ""read()"")"
"The read() returns an int which you will have to cast to a char yourself, as shown in the example above.","(""read()"", ""returns"", ""int"")"
When there are no characters available in the PushbackReader the read() method will return the int value -1.,"(""PushbackReader"", ""has method"", ""read()""); (""read()"", ""returns"", ""int"")"
To push a character back into a Java PushbackReader you must call its unread() method.,"(""PushbackReader"", ""has method"", ""unread()""); (""PushbackReader"", ""calls"", ""unread()""); (""unread()"", ""is method of"", ""PushbackReader"")"
"This way the nextToken() method can ""sample"" the first character of the next token, and based on that decide what kind of token it is, and what read method to call for that kind of token.","(""nextToken()"", ""decides"", ""next token""); (""nextToken()"", ""calls"", ""read method""); (""read method"", ""is called for"", ""token""); (""nextToken()"", ""samples"", ""first character"")"
"For the readSingleTokenWord() however, it is necessary, as the character read is the first character of the token's value.","(""readSingleTokenWord()"", ""is part of"", ""token""); (""character"", ""is read by"", ""readSingleTokenWord()""); (""token"", ""has value"", ""character"")"
"The implementations of the readDoubleQuotedToken(), readSingleQuotedToken() and readSingleWordToken() have been left out to keep the example short.","(""readDoubleQuotedToken()"", ""has implementation"", ""readDoubleQuotedToken()""); (""readSingleQuotedToken()"", ""has implementation"", ""readSingleQuotedToken()""); (""readSingleWordToken()"", ""has implementation"", ""readSingleWordToken()"")"
"Just imagine they read a token enclosed by double quotes (""), single quotes (') or a token which ends with a non-word character (e.g.",
The Java RandomAccessFile class in the Java IO API allows you to move navigate a file and read from it or write to it as you please.,"(""RandomAccessFile"", ""is part of"", ""Java IO API""); (""RandomAccessFile"", ""allows"", ""navigate a file""); (""RandomAccessFile"", ""allows"", ""read from a file""); (""RandomAccessFile"", ""allows"", ""write to a file"")"
Before you can work with the RandomAccessFile class you must instantiate it.,"(""RandomAccessFile"", ""instantiate"", ""RandomAccessFile"")"
You can obtain the current position of a Java RandomAccessFile using its getFilePointer() method.,"(""RandomAccessFile"", ""has method"", ""getFilePointer()""); (""RandomAccessFile"", ""uses"", ""getFilePointer()""); (""getFilePointer()"", ""belongs to"", ""RandomAccessFile"")"
Here is an example of obtaining the current position of a RandomAccessFile using its getFilePointer() method:,"(""RandomAccessFile"", ""has method"", ""getFilePointer()"")"
Reading a byte from a Java RandomAccessFile is done using its read() method.,"(""RandomAccessFile"", ""uses"", ""read()""); (""RandomAccessFile"", ""has method"", ""read()""); (""read()"", ""is method of"", ""RandomAccessFile"")"
The read() method reads the byte located a the position in the file currently pointed to by the file pointer in the RandomAccessFile instance.,"(""RandomAccessFile"", ""has method"", ""read()""); (""read()"", ""reads"", ""byte""); (""RandomAccessFile"", ""has"", ""file pointer""); (""file pointer"", ""points to"", ""position""); (""RandomAccessFile"", ""has"", ""position"")"
Here is a thing the JavaDoc forgets to mention: The read() method increments the file pointer to point to the next byte in the file after the byte just read!,"(""read()"", ""increments"", ""file pointer""); (""file pointer"", ""points to"", ""next byte""); (""read()"", ""reads"", ""byte"")"
This means that you can continue to call read() without having to manually move the file pointer.,
This example reads a sequence of bytes into the dest byte array passed as parameter to the read() method.,"(""read()"", ""is method of"", ""unknown class""); (""dest"", ""is parameter of"", ""read()""); (""read()"", ""reads into"", ""dest""); (""byte array"", ""is type of"", ""dest""); (""read()"", ""is called on"", ""unknown class""); (""sequence of bytes"", ""is read by"", ""read()"")"
The read() method will start reading in the file from the current file position of the RandomAccessFile.,"(""RandomAccessFile"", ""has method"", ""read()""); (""RandomAccessFile"", ""has property"", ""current file position""); (""read()"", ""is method of"", ""RandomAccessFile""); (""RandomAccessFile"", ""uses"", ""file""); (""read()"", ""affects"", ""file position"")"
"The read() method will start writing data into the byte array starting from the array position provided by the offset parameter, and at most the number of bytes provided by the length parameter.","(""read()"", ""starts writing data into"", ""byte array""); (""read()"", ""uses"", ""offset parameter""); (""read()"", ""limited by"", ""length parameter""); (""byte array"", ""has position"", ""offset parameter""); (""byte array"", ""has limit"", ""length parameter"")"
You can write a single byte to a RandomAccessFile using its write() method which takes an int as parameter.,"(""RandomAccessFile"", ""has method"", ""write()""); (""write()"", ""takes parameter"", ""int"")"
"Remember, calling this write() method will advance the file position of the RandomAccessFile by 1.","(""RandomAccessFile"", ""has method"", ""write()""); (""RandomAccessFile"", ""has property"", ""file position""); (""write()"", ""advances"", ""file position"")"
Writing to a RandomAccessFile can be done using one it its many write() methods.,"(""RandomAccessFile"", ""has method"", ""write()"")"
Just like with the read() method the write() method advances the file pointer after being called.,"(""write() method"", ""advances"", ""file pointer""); (""read() method"", ""advances"", ""file pointer""); (""write() method"", ""is similar to"", ""read() method"")"
The RandomAccessFile has a close() method which must be called when you are done using the RandomAccessFile instance.,"(""RandomAccessFile"", ""has"", ""close()""); (""RandomAccessFile"", ""has method"", ""close()""); (""close()"", ""is method of"", ""RandomAccessFile""); (""RandomAccessFile"", ""uses"", ""close()"")"
You can see example of calls to close() in the examples above.,
"The Java Reader class, java.io.Reader, is the base class for all Reader subclasses in the Java IO API.","(""java.io.Reader"", ""is base class for"", ""Reader""); (""Reader"", ""is subclass of"", ""java.io.Reader""); (""Java IO API"", ""contains"", ""java.io.Reader""); (""Java IO API"", ""contains"", ""Reader"")"
"This is done when you instantiate the Reader (actually, when you instantiate one of its subclasses).","(""Reader"", ""instantiate"", ""subclasses""); (""Reader"", ""has"", ""subclasses""); (""subclasses"", ""inherit from"", ""Reader"")"
You will normally use a Reader subclass rather than a Reader directly.,"(""Reader"", ""is a superclass of"", ""Reader subclass""); (""Reader subclass"", ""is a subclass of"", ""Reader"")"
Here is an example of creating a Java FileReader which is a subclass of Java Reader:,"(""FileReader"", ""is a subclass of"", ""Reader""); (""FileReader"", ""is part of"", ""Java""); (""Reader"", ""is part of"", ""Java"")"
The read() method of a Java Reader returns an int which contains the char value of the next character read.,"(""Java Reader"", ""has method"", ""read()""); (""read()"", ""returns"", ""int""); (""read()"", ""contains"", ""char""); (""Reader"", ""has method"", ""read()"")"
"If the read() method returns -1, there is no more data to read in the Reader, and it can be closed.","(""Reader"", ""has method"", ""read()""); (""read()"", ""returns"", ""-1""); (""Reader"", ""can be"", ""closed"")"
"If not, it processes that char and continues reading until -1 is returned from the Reader read() method.","(""Reader"", ""has method"", ""read()"")"
"The Java Reader class also has a read() method that takes a char array as parameter, as well as a start offset and length.","(""Java Reader"", ""has method"", ""read()""); (""read()"", ""takes parameter"", ""char array""); (""read()"", ""has parameter"", ""start offset""); (""read()"", ""has parameter"", ""length"")"
The Java Reader class has a method named skip() which can be used to skip over a number of characters in the input that you do not want to read.,"(""Java Reader"", ""has method"", ""skip()""); (""skip()"", ""used for"", ""skipping characters""); (""Java Reader"", ""uses"", ""skip()"")"
The Java StreamTokenizer class (java.io.StreamTokenizer) can tokenize the characters read from a Reader into tokens.,"(""Java StreamTokenizer"", ""can tokenize from"", ""Reader""); (""Java StreamTokenizer"", ""is in package"", ""java.io""); (""Reader"", ""is used by"", ""Java StreamTokenizer"")"
You do so by calling the nextToken() method of the StreamTokenizer inside a loop.,"(""StreamTokenizer"", ""has method"", ""nextToken()"")"
"After each call to nextToken() the StreamTokenizer has several fields you can read to see what kind of token was read, it's value etc.","(""StreamTokenizer"", ""has method"", ""nextToken()""); (""StreamTokenizer"", ""has fields"", ""fields""); (""nextToken()"", ""returns"", ""token""); (""StreamTokenizer"", ""reads"", ""token"")"
"Java has 3 streams called System.in, System.out, and System.err which are commonly used to provide input to, and output from Java applications.","(""Java"", ""has"", ""System.in""); (""Java"", ""has"", ""System.out""); (""Java"", ""has"", ""System.err""); (""Java applications"", ""provide input to"", ""System.in""); (""Java applications"", ""provide output from"", ""System.out""); (""Java applications"", ""provide output from"", ""System.err"")"
Most commonly used is probably System.out for writing output to the console from console programs (command line applications).,"(""System"", ""uses"", ""System.out""); (""console programs"", ""use"", ""System.out""); (""System.out"", ""writes"", ""output""); (""console programs"", ""write to"", ""console""); (""System.out"", ""is used in"", ""command line applications"")"
"System.in, System.out and System.err are initialized by the Java runtime when a Java VM starts up, so you don't have to instantiate any streams yourself (although you can exchange them at runtime).","(""System.in"", ""initialized by"", ""Java runtime""); (""System.out"", ""initialized by"", ""Java runtime""); (""System.err"", ""initialized by"", ""Java runtime""); (""Java VM"", ""starts up"", ""Java runtime""); (""Java runtime"", ""instantiates"", ""streams""); (""System.in"", ""exchanged at"", ""runtime""); (""System.out"", ""exchanged at"", ""runtime""); (""System.err"", ""exchanged at"", ""runtime"")"
System.in is an InputStream which is typically connected to keyboard input of console programs.,"(""System.in"", ""is"", ""InputStream""); (""InputStream"", ""connected to"", ""keyboard input""); (""console programs"", ""has"", ""keyboard input""); (""System.in"", ""connected to"", ""console programs"")"
"In other words, if you start a Java application from the command line, and you type something on the keyboard while the CLI console (or terminal) has focus, the keyboard input can typically be read via System.in from inside that Java application.","(""System.in"", ""read via"", ""Java application""); (""Java application"", ""started from"", ""command line""); (""CLI console"", ""has focus"", ""keyboard input""); (""Java application"", ""reads"", ""keyboard input""); (""CLI console"", ""provides"", ""keyboard input"")"
"However, it is only keyboard input directed to that Java application (the console / terminnal that started the application) which can be read via System.in.","(""System.in"", ""can be read via"", ""keyboard input""); (""Java application"", ""has"", ""console""); (""console"", ""is also known as"", ""terminnal""); (""Java application"", ""started from"", ""console""); (""console"", ""is related to"", ""System.in"")"
Keyboard input for other applications cannot be read via System.in .,"(""System.in"", ""used for"", ""reading keyboard input""); (""Keyboard input"", ""read by"", ""System.in""); (""System.in"", ""cannot read"", ""keyboard input for other applications"")"
"System.in is not used as often since data is commonly passed to a command line Java application via command line arguments, files, or possibly via network connections if the application is designed for that.","(""System.in"", ""is not used by"", ""command line Java application""); (""command line Java application"", ""uses"", ""command line arguments""); (""command line Java application"", ""uses"", ""files""); (""command line Java application"", ""uses"", ""network connections"")"
System.out normally outputs the data you write to it to the CLI console / terminal.,"(""System"", ""outputs"", ""data""); (""System.out"", ""writes"", ""CLI console""); (""System.out"", ""outputs"", ""terminal""); (""CLI console"", ""receives"", ""data""); (""terminal"", ""receives"", ""data"")"
System.out is often used from console-only programs like command line tools as a way to display the result of their execution to the user.,"(""System.out"", ""is used from"", ""console-only programs""); (""console-only programs"", ""are like"", ""command line tools""); (""System.out"", ""is used to display"", ""result of execution""); (""result of execution"", ""is displayed to"", ""the user""); (""System.out"", ""is used in"", ""command line tools"")"
System.err works like System.out except it is normally only used to output error texts.,"(""System.err"", ""works like"", ""System.out""); (""System.err"", ""used to output"", ""error texts""); (""System.out"", ""used to output"", ""texts"")"
"Some programs (like Eclipse) will show the output to System.err in red text, to make it more obvious that it is error text.","(""System.err"", ""show"", ""output""); (""Eclipse"", ""show"", ""System.err""); (""System.err"", ""is"", ""error text"")"
"Even if the 3 System streams are static members of the java.lang.System class, and are pre-instantiated at JVM startup, you can change what streams to use for each of them.","("" java.lang.System"", ""has members"", ""System streams ""); ("" System streams"", ""are part of"", ""java.lang.System class ""); ("" java.lang.System"", ""has startup"", ""JVM startup ""); ("" JVM startup"", ""pre-instantiates"", ""System streams "")"
"Just set a new InputStream for System.in or a new OutputStream for System.out or System.err, and all further data will be read / written to the new stream.","(""System.in"", ""set"", ""InputStream""); (""System.out"", ""set"", ""OutputStream""); (""System.err"", ""set"", ""OutputStream""); (""InputStream"", ""read"", ""data""); (""OutputStream"", ""write"", ""data"")"
"To set a new System stream, use one of th emethods System.setIn(), System.setOut() or System.setErr().","(""System"", ""hasMethod"", ""System.setIn()""); (""System"", ""hasMethod"", ""System.setOut()""); (""System"", ""hasMethod"", ""System.setErr()"")"
"Now all data written to System.out should be redirected into the file ""c:\\data\\system.out.txt"".","(""System.out"", ""redirected into"", ""file""); (""System.out"", ""writes to"", ""file""); (""file"", ""located at"", ""c:\\data\\system.out.txt"")"
"Keep in mind though, that you should make sure to flush System.out and close the file before the JVM shuts down, to be sure that all data written to System.out is actually flushed to the file.","(""System.out"", ""flush"", ""System.out""); (""System.out"", ""close"", ""file""); (""JVM"", ""shuts down"", ""JVM""); (""System.out"", ""write"", ""data""); (""System.out"", ""flush"", ""file"")"
The Java Writer class (java.io.Writer) is the base class for all Writer subclasses in the Java IO API.,"(""Java Writer"", ""is base class for"", ""Writer subclasses""); (""Java IO API"", ""contains"", ""Writer""); (""Writer subclasses"", ""inherit from"", ""Java Writer""); (""Java Writer"", ""is part of"", ""Java IO API""); (""Java Writer"", ""is in package"", ""java.io"")"
"The Java Writer subclasses can normally handle UTF-8 and UTF-16 encoding for you, so you don't have to worry about that.","(""Java Writer"", ""subclasses"", ""UTF-8""); (""Java Writer"", ""subclasses"", ""UTF-16"")"
You will normally use a Writer subclass rather than a Writer directly.,"(""Writer"", ""is a superclass of"", ""Writer subclass""); (""Writer subclass"", ""is a"", ""Writer"")"
The Java Writer's flush() method flushes all data written to the Writer to the underlying data destination.,"(""Writer"", ""has method"", ""flush()""); (""flush()"", ""belongs to"", ""Writer""); (""Writer"", ""writes to"", ""data destination"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your Writer has).","(""flush()"", ""called by"", ""Writer""); (""Writer"", ""has destination"", ""disk""); (""Writer"", ""has destination"", ""network"")"
Here is an example of flushing data written to a Java Writer by calling its flush() method:,"(""Java Writer"", ""has method"", ""flush()""); (""flush()"", ""called by"", ""Java Writer""); (""Java Writer"", ""writes"", ""data"")"
"The concrete implementations of hasMoreCharacters() and getNextCharacter() are left out, but they are not really super important to understand the principle of this example.","(""hasMoreCharacters()"", ""is method of"", ""unknown class""); (""getNextCharacter()"", ""is method of"", ""unknown class"")"
"What matters is, that once the while loop ends, and you are done writing data to the Writer, its close() method is called, which closes the Writer .","(""Writer"", ""has method"", ""close()""); (""while loop"", ""ends"", ""Writer""); (""Writer"", ""is closed by"", ""close()""); (""Writer"", ""has method called"", ""close()""); (""close()"", ""is method of"", ""Writer""); (""Writer"", ""is written to"", ""data""); (""Writer"", ""is used by"", ""while loop""); (""while loop"", ""uses"", ""Writer""); (""close()"", ""closes"", ""Writer"")"
"Once the try block is exited, the close() method of the Writer is called automatically, because the Writer was declared inside the parentheses of the try block.","(""Writer"", ""hasMethod"", ""close()""); (""try block"", ""contains"", ""Writer""); (""Writer"", ""isCalled"", ""close()"")"
"The SQL dialect used by the various different databases will vary slightly, so to be 100% database independent, you SQL must also be 100% database independent (i.e.",
The Java String parameter passed to the Class forName() method is the name of the JDBC driver class for the given JDBC driver.,"(""Java"", ""uses"", ""String""); (""Class"", ""has method"", ""forName()""); (""forName()"", ""takes parameter"", ""String""); (""JDBC driver"", ""has class"", ""JDBC driver class""); (""Class"", ""loads"", ""JDBC driver class""); (""JDBC driver class"", ""is parameter of"", ""forName()"")"
You will have to find the right class name for the JDBC driver you are using.,"(""JDBC"", ""uses"", ""driver""); (""driver"", ""has"", ""class name""); (""class name"", ""is used by"", ""JDBC"")"
"Typically, each database has its own JDBC driver, so you will have to look up what the JDBC driver class name is (if you are using pre Java 6).","(""JDBC"", ""has"", ""driver""); (""database"", ""has"", ""JDBC driver""); (""Java"", ""has version"", ""Java 6""); (""JDBC driver"", ""has"", ""class name"")"
"First you add the SQL statements to be executed in the batch, using the addBatch() method.","(""addBatch"", ""method of"", ""unknown class""); (""unknown class"", ""has method"", ""addBatch()""); (""Batch"", ""related to"", ""SQL statements""); (""SQL statements"", ""executed by"", ""addBatch()""); (""addBatch"", ""executes"", ""SQL statements"")"
The int[] array returned by the executeBatch() method is an array of int telling how many records were affected by each executed SQL statement in the batch.,"(""executeBatch()"", ""returns"", ""int""); (""executeBatch()"", ""affects"", ""SQL statement""); (""SQL statement"", ""is executed in"", ""batch""); (""int"", ""contains"", ""records""); (""records"", ""are affected by"", ""SQL statement"")"
"Second, each set of parameter values are inserted into the preparedStatement, and the addBatch() method is called.","(""preparedStatement"", ""has method"", ""addBatch()"")"
"Third, the executeBatch() method is called, which executes all the batch updates.","(""executeBatch()"", ""is called by"", ""unknown""); (""executeBatch()"", ""executes"", ""batch updates"")"
"By the way, imagine that the used Person class looks like this:","(""Person"", ""isA"", ""class"")"
A java.sql.CallableStatement is used to call stored procedures in a database.,"(""java.sql.CallableStatement"", ""is used to call"", ""stored procedures""); (""stored procedures"", ""are called by"", ""java.sql.CallableStatement""); (""java.sql.CallableStatement"", ""is part of"", ""java.sql"")"
"A stored procedure is like a function or method in a class, except it lives inside the database.","(""stored procedure"", ""is like"", ""function""); (""stored procedure"", ""is like"", ""method""); (""function"", ""in"", ""class""); (""method"", ""in"", ""class""); (""stored procedure"", ""lives in"", ""database"")"
You create an instance of a CallableStatement by calling the prepareCall() method on a connection object.,"(""CallableStatement"", ""created by"", ""prepareCall()""); (""prepareCall()"", ""called on"", ""connection""); (""connection"", ""has method"", ""prepareCall()"")"
"If the stored procedure returns a ResultSet, and you need a non-default ResultSet (e.g.",
The executeQuery() method is used if the stored procedure returns a ResultSet.,"(""executeQuery()"", ""is used by"", ""stored procedure""); (""stored procedure"", ""returns"", ""ResultSet""); (""executeQuery()"", ""returns"", ""ResultSet"")"
"If the stored procedure just updates the database, you can call the executeUpdate() method instead, like this:","(""stored procedure"", ""calls"", ""executeUpdate()""); (""executeUpdate()"", ""method of"", ""unknown class"")"
"The JDBC Connection class, java.sql.Connection, represents a database connection to a relational database.","(""JDBC Connection"", ""represents"", ""database connection""); (""java.sql.Connection"", ""is a"", ""JDBC Connection""); (""java.sql.Connection"", ""connects to"", ""relational database"")"
Each JDBC driver has a primary driver class that initializes the driver when it is loaded.,"(""JDBC driver"", ""has"", ""primary driver class""); (""primary driver class"", ""initializes"", ""driver"")"
You open a JDBC Connection by call the java.sql.DriverManager class method getConnection().,"(""java.sql.DriverManager"", ""hasMethod"", ""getConnection()""); (""getConnection()"", ""returns"", ""JDBC Connection""); (""JDBC Connection"", ""openedBy"", ""java.sql.DriverManager.getConnection()"")"
This is how calling getConnection() only with the URL as parameter looks:,"(""getConnection()"", ""called with"", ""URL"")"
"The second variant of getConnection() takes both a database URL, a user name and a password as parameters.","(""getConnection()"", ""takes"", ""database URL""); (""getConnection()"", ""takes"", ""user name""); (""getConnection()"", ""takes"", ""password"")"
Here is an example of calling that variant of getConnection() :,"(""getConnection()"", ""is a method of"", ""unspecified class"")"
The third variant of getConnection() takes a database URL and a Properties object as parameter.,"(""getConnection()"", ""takes"", ""database URL""); (""getConnection()"", ""takes"", ""Properties object""); (""getConnection()"", ""parameter"", ""database URL""); (""getConnection()"", ""parameter"", ""Properties object"")"
"The JDBC Connection setAutoCommit() method is used to switch the connection into, or out of, auto commit mode.","(""JDBC Connection"", ""hasMethod"", ""setAutoCommit()""); (""setAutoCommit()"", """", ""JDBC Connection""); (""JDBC Connection"", ""usedFor"", ""auto commit mode"")"
"When not in auto commit mode, each database transaction must be explicitly committed by calling the Connection commit() method.","(""Connection"", ""hasMethod"", ""commit()""); (""Connection"", ""useMethod"", ""commit()""); (""commit()"", ""calledBy"", ""Connection""); (""database transaction"", ""committedBy"", ""commit()""); (""Connection"", ""manages"", ""database transaction"")"
"Keep in mind, that if some of the operations in the transaction fail, you would most likely want to call the rollback() method instead of commit().","(""transaction"", ""has method"", ""rollback()""); (""transaction"", ""has method"", ""commit()"")"
The Java JDBC Connection rollback() method rolls back the operations executed within the currently ongoing transaction.,"(""Java JDBC Connection"", ""has method"", ""rollback()""); (""rollback()"", ""rolls back"", ""transaction""); (""transaction"", ""is executed within"", ""Java JDBC Connection"")"
Exactly how to handle the calls to commit() and / or rollback() is covered in the JDBC Transactions Tutorial.,"(""JDBC"", ""hasMethod"", ""commit()""); (""JDBC"", ""hasMethod"", ""rollback()"")"
Here is a simple example of calling the JDBC Connection rollback() method:,"(""JDBC Connection"", ""has method"", ""rollback()"")"
Notice how rollback() is called within the catch-block of a try-catch block.,"(""try-catch block"", ""contains"", ""rollback()""); (""catch-block"", ""calls"", ""rollback()""); (""rollback()"", ""is called by"", ""catch-block"")"
Here is an example of creating a JDBC Statement instance via the JDBC Connection createStatement() method:,"(""JDBC Connection"", ""createStatement()"", ""JDBC Statement"")"
Here is an example of creating a JDBC PreparedStatement instance via the JDBC Connection prepareStatement() method:,"(""JDBC Connection"", ""has method"", ""prepareStatement()""); (""prepareStatement()"", ""returns"", ""JDBC PreparedStatement""); (""JDBC Connection"", ""creates"", ""JDBC PreparedStatement"")"
The JDBC Connection getMetaData() method returns a JDBC DatabaseMetaData object which can be used to introspect the database the JDBC Connection is connected to.,"(""JDBC Connection"", ""has method"", ""getMetaData()""); (""getMetaData()"", ""returns"", ""JDBC DatabaseMetaData""); (""JDBC Connection"", ""is connected to"", ""database""); (""JDBC DatabaseMetaData"", ""used for"", ""introspection""); (""JDBC DatabaseMetaData"", ""introspects"", ""database"")"
Here is an example of creating a JDBC DatabaseMetaData object via the JDBC Connection getMetaData() method:,"(""JDBC Connection"", ""getMetaData"", ""DatabaseMetaData""); (""JDBC Connection"", ""has method"", ""getMetaData()""); (""DatabaseMetaData"", ""created by"", ""getMetaData()"")"
Through the java.sql.DatabaseMetaData interface you can obtain meta data about the database you have connected to.,"(""java.sql.DatabaseMetaData"", ""obtain meta data about"", ""database""); (""java.sql.DatabaseMetaData"", ""connected to"", ""database""); (""database"", ""provide meta data through"", ""java.sql.DatabaseMetaData"")"
"First you call the getTables() method, passing it 4 parameters which are all null.","(""getTables()"", ""called with"", ""null""); (""getTables()"", ""has parameter"", ""null""); (""getTables()"", ""has parameter"", ""null""); (""getTables()"", ""has parameter"", ""null""); (""getTables()"", ""has parameter"", ""null"")"
The ResultSet returned from the getTables() method contains a list of table names matching the 4 given parameters (which were all null).,"(""getTables()"", ""returns"", ""ResultSet""); (""ResultSet"", ""contains"", ""table names"")"
The ResultSet returned by the getColumns() method contains a list of columns for the given table.,"(""ResultSet"", ""returned by"", ""getColumns()""); (""getColumns()"", ""contains"", ""columns""); (""columns"", ""belongs to"", ""table"")"
The column type is an integer matching one of the type constants found in java.sql.Types,"(""java.sql.Types"", ""contains"", ""type constants""); (""java.sql.Types"", ""is_type_of"", ""integer"")"
"First you call the getPrimaryKeys() method, passing 3 parameters to it.","(""getPrimaryKeys()"", ""called with"", ""3 parameters"")"
The ResultSet returned by the getPrimaryKeys() method contains a list of columns which make up the primary key of the given table.,"(""getPrimaryKeys()"", ""returns"", ""ResultSet""); (""ResultSet"", ""contains"", ""columns""); (""columns"", ""make up"", ""primary key""); (""primary key"", ""belongs to"", ""table"")"
"A JDBC driver is a set of Java classes that implement the JDBC interfaces, targeting a specific database.","(""JDBC driver"", ""implements"", ""JDBC interfaces""); (""Java classes"", ""implement"", ""JDBC interfaces""); (""JDBC interfaces"", ""are targeted by"", ""JDBC driver""); (""JDBC driver"", ""targets"", ""specific database"")"
A JDBC driver is a collection of Java classes that enables you to connect to a certain database.,"(""JDBC driver"", ""enables"", ""Java classes""); (""Java classes"", ""connect to"", ""database"")"
"This works for executing queries too, using the executeQuery() method, which returns a ResultSet.","(""executeQuery()"", ""returns"", ""ResultSet"")"
"The ResultSet.next() method moves to the next row in the ResultSet, if there are anymore rows.","(""ResultSet"", ""has method"", ""next()""); (""ResultSet.next()"", ""moves to"", ""row""); (""ResultSet"", ""contains"", ""row"")"
You need to call next() at least one time before you can read any data.,"(""next()"", ""is called by"", ""user""); (""next()"", ""returns"", ""data""); (""data"", ""is read by"", ""user"")"
Before the first next() call the ResultSet is positioned before the first row.,"(""ResultSet"", ""is positioned before"", ""first row""); (""ResultSet"", ""has method"", ""next()""); (""ResultSet"", ""is used for"", ""row retrieval""); (""ResultSet"", ""has state"", ""before first row""); (""ResultSet"", ""receives method call"", ""next()""); (""First row"", ""is retrieved by"", ""next()""); (""Next()"", ""is method of"", ""ResultSet"")"
"You can get column data for the current row by calling some of the getXXX() methods, where XXX is a primitive data type.","(""getXXX()"", ""is a method of"", ""row""); (""row"", ""has method"", ""getXXX()""); (""getXXX()"", ""returns"", ""primitive data type""); (""row"", ""contains"", ""column data""); (""getXXX()"", ""retrieves"", ""column data"")"
The column name to get the value of is passed as parameter to any of these getXXX() method calls.,"(""column"", ""is passed to"", ""getXXX()""); (""getXXX()"", ""is called with"", ""column""); (""parameter"", ""is passed to"", ""getXXX()"")"
"You can get the index of a given column by calling the ResultSet.findColumn() method, like this:","(""ResultSet"", ""hasMethod"", ""findColumn()"")"
The text about queries shows how the result of a query is returned as a java.sql.ResultSet.,"(""java.sql.ResultSet"", ""returned as"", ""query result""); (""query"", ""returns"", ""java.sql.ResultSet""); (""java.sql"", ""contains"", ""ResultSet"")"
"The next() method returns true if the ResultSet has a next record, and moves the ResultSet to point to the next record.","(""ResultSet"", ""has method"", ""next()""); (""ResultSet"", ""returns"", ""true""); (""ResultSet"", ""moves to"", ""next record""); (""next()"", ""returns"", ""true""); (""ResultSet"", ""has"", ""next record"")"
"If there were no more records, next() returns false, and you can no longer.","(""next()"", ""returns"", ""false"")"
"Once the next() method has returned false, you should not call it anymore.","(""next()"", ""has returned"", ""false""); (""next()"", ""should not call"", ""next()"")"
Here is an example of iterating a ResultSet using the next() method:,"(""ResultSet"", ""uses"", ""next()""); (""ResultSet"", ""has method"", ""next()""); (""next()"", ""belongs to"", ""ResultSet"")"
"As you can see, the next() method is actually called before the first record is accessed.","(""next"", ""is called by"", ""first record""); (""next"", ""is part of"", ""record access""); (""next"", ""is called before"", ""first record access"")"
"Once next() has been called once, it points at the first record.","(""next()"", ""has been called"", ""first record""); (""next()"", ""points at"", ""first record"")"
"Similarly, when next() is called and returns false, the ResultSet is actually pointing after the last record.","(""ResultSet"", ""is pointing after"", ""last record""); (""ResultSet"", ""has method"", ""next()""); (""next()"", ""returns"", ""false"")"
You do so by calling one or more of the many getXXX() methods.,"(""getXXX()"", ""called by"", ""unknown""); (""unknown"", ""calls"", ""getXXX()"")"
"You pass the name of the column to get the value of, to the many getXXX() methods.","(""getXXX() methods"", ""are called with"", ""column name""); (""getXXX() methods"", ""retrieve"", ""column value""); (""column name"", ""is passed to"", ""getXXX() methods"")"
"There are a lot of getXXX() methods you can call, which return the value of the column as a certain data type, e.g.","(""getXXX()"", ""returns"", ""column""); (""getXXX()"", ""called by"", ""user""); (""column"", ""has data type"", ""data type"")"
Here is a list of quick examples of these getXXX() methods:,"(""getXXX() methods"", ""listed in"", ""quick examples""); (""quick examples"", ""contain"", ""getXXX() methods""); (""getXXX() methods"", ""are type of"", ""methods"")"
The getXXX() methods also come in versions that take a column index instead of a column name.,"(""getXXX()"", ""takes"", ""column index""); (""getXXX()"", ""takes"", ""column name"")"
"If you do not know the index of a certain column you can find the index of that column using the ResultSet.findColumn(String columnName) method, like this:",
The DatabaseMetaData.supportsResultSetType(int type) method returns true or false depending on whether the given type is supported or not.,"(""DatabaseMetaData"", ""hasMethod"", ""supportsResultSetType(int type)""); (""supportsResultSetType(int type)"", ""returns"", ""boolean""); (""DatabaseMetaData"", ""usesType"", ""int""); (""supportsResultSetType(int type)"", ""isMethodOf"", ""DatabaseMetaData"")"
The DatabaseMetaData.supportsResultSetConcurrency(int concurrency) method returns true or false depending on whether the given concurrency mode is supported or not.,"(""DatabaseMetaData"", ""supportsResultSetConcurrency"", ""int""); (""DatabaseMetaData.supportsResultSetConcurrency"", ""returns"", ""boolean""); (""DatabaseMetaData"", ""hasMethod"", ""supportsResultSetConcurrency"")"
It is when updateRow() is called that the database is updated with the values of the row.,"(""updateRow()"", ""is called by"", ""database""); (""updateRow()"", ""updates"", ""row""); (""database"", ""is updated with"", ""row"")"
"If you call updateRow() inside a transaction, the data is not actually committed to the database until the transaction is committed.","(""updateRow()"", ""called inside"", ""transaction""); (""transaction"", ""commits"", ""data""); (""updateRow()"", ""does not commit to"", ""database""); (""transaction"", ""commits to"", ""database"")"
"The row pointed to after calling moveToInsertRow() is a special row, a buffer, which you can use to build up the row until all column values has been set on the row.","(""moveToInsertRow()"", ""is called on"", ""row""); (""row"", ""has"", ""column values""); (""moveToInsertRow()"", ""returns"", ""buffer row""); (""row"", ""is used to"", ""build up row""); (""buffer row"", ""is used to"", ""set column values""); (""row"", ""has"", ""buffer"")"
"Once the row is ready to be inserted into the ResultSet, call the insertRow() method.","(""ResultSet"", ""has method"", ""insertRow()"")"
"If you need to insert another row, explicitly call moveToInsertRow() to signal this to the ResultSet.","(""ResultSet"", ""hasMethod"", ""moveToInsertRow()"")"
The ResultSet holdability determines if a ResultSet is closed when the commit() method of the underlying connection is called.,"(""ResultSet"", ""holdability determined by"", ""commit()""); (""ResultSet"", ""closed when"", ""commit()""); (""commit()"", ""called on"", ""connection""); (""ResultSet"", ""underlying connection"", ""connection"")"
The DatabaseMetaData.supportsResultSetHoldability(int holdability) returns true or false depending on whether the given holdability mode is supported or not.,"(""DatabaseMetaData"", ""supportsResultSetHoldability"", ""int""); (""DatabaseMetaData.supportsResultSetHoldability"", ""returns"", ""boolean""); (""DatabaseMetaData.supportsResultSetHoldability"", ""depends on"", ""int""); (""DatabaseMetaData"", ""has method"", ""supportsResultSetHoldability""); (""supportsResultSetHoldability"", ""is method of"", ""DatabaseMetaData"")"
The CLOSE_CURSORS_OVER_COMMIT holdability means that all ResultSet instances are closed when connection.commit() method is called on the connection that created the ResultSet.,"(""ResultSet"", ""is closed by"", ""connection.commit()""); (""connection.commit()"", ""closes"", ""ResultSet""); (""connection"", ""creates"", ""ResultSet"")"
The HOLD_CURSORS_OVER_COMMIT holdability means that the ResultSet is kept open when the connection.commit() method is called on the connection that created the ResultSet.,"(""ResultSet"", ""is kept open by"", ""connection.commit()""); (""connection"", ""creates"", ""ResultSet""); (""connection.commit()"", ""is called on"", ""connection"")"
"Thus, you can open a ResultSet, update rows in it, call connection.commit() and still keep the same ResultSet open for future transactions on the same rows.","(""ResultSet"", ""open"", ""connection""); (""connection"", ""commit"", ""transaction""); (""ResultSet"", ""update"", ""rows""); (""connection"", ""keep"", ""ResultSet""); (""ResultSet"", ""use"", ""rows""); (""connection"", ""manage"", ""transaction""); (""transaction"", ""affect"", ""rows"")"
"The Java JDBC Statement, java.sql.Statement, interface is used to execute SQL statements against a relational database.","(""Java"", ""uses"", ""JDBC Statement""); (""java.sql.Statement"", ""is"", ""interface""); (""Java JDBC Statement"", ""executes"", ""SQL statements""); (""SQL statements"", ""are executed against"", ""relational database""); (""relational database"", ""is accessed through"", ""java.sql.Statement"")"
"You do so by calling its executeQuery() method, passing an SQL statement as parameter.","(""executeQuery()"", ""is method of"", ""unknown class""); (""SQL statement"", ""is parameter of"", ""executeQuery()"")"
The Statement executeQuery() method returns a Java JDBC ResultSet which can be used to navigate the response of the query.,"(""Statement"", ""hasMethod"", ""executeQuery()""); (""Statement.executeQuery()"", ""returns"", ""ResultSet""); (""ResultSet"", ""usedFor"", ""navigatingQueryResponse""); (""JDBC"", ""hasClass"", ""ResultSet"")"
Here is an example of calling the Java JDBC Statement executeQuery() and navigating the returned ResultSet:,"(""Statement"", ""hasMethod"", ""executeQuery()""); (""Statement"", ""returns"", ""ResultSet""); (""ResultSet"", ""hasMethod"", ""navigate"")"
"The rowsAffected returned by the statement.executeUpdate(sql) call, tells how many records in the database were affected by the SQL statement.","(""statement"", ""hasMethod"", ""executeUpdate()""); (""executeUpdate()"", ""takesParameter"", ""sql""); (""statement"", ""returns"", ""rowsAffected""); (""sql"", ""isParameterOf"", ""executeUpdate()""); (""executeUpdate()"", ""affects"", ""records""); (""records"", ""areIn"", ""database""); (""executeUpdate()"", ""returns"", ""rowsAffected"")"
The classic example of when transactions are necessary is the example of bank accounts.,
"But, instead of calling the executeQuery() method, you call the executeUpdate() method.",
The executeUpdate() method is used for both of these types of updates.,"(""executeUpdate()"", ""is used for"", ""updates"")"
"Again, the rowsAffected returned by the statement.executeUpdate(sql) call, tells how many records in the database were affected by the SQL statement.","(""statement"", ""executeUpdate"", ""sql""); (""sql"", ""affects"", ""database""); (""statement"", ""returns"", ""rowsAffected""); (""rowsAffected"", ""represents"", ""records""); (""records"", ""areIn"", ""database""); (""sql"", ""executedBy"", ""statement""); (""statement"", ""hasMethod"", ""executeUpdate""); (""executeUpdate"", ""returns"", ""rowsAffected"")"
"Once you have installed the Java SDK, test that you have it working by opening a command prompt (textual interface to your computer, ala Unix Shell, Windows CMD etc.)",
"A Java abstract class is a class which cannot be instantiated, meaning you cannot create new instances of an abstract class.","(""Java"", ""has"", ""abstract class""); (""abstract class"", ""cannot be instantiated by"", ""new instances""); (""abstract class"", ""is a type of"", ""class""); (""class"", ""can be instantiated by"", ""new instances""); (""abstract class"", ""is a"", ""class"")"
The purpose of an abstract class is to function as a base for subclasses.,"(""abstract class"", ""is a"", ""base""); (""abstract class"", ""function as"", ""base""); (""base"", ""is for"", ""subclasses""); (""abstract class"", ""is for"", ""subclasses"")"
"This Java abstract class tutorial explains how abstract classes are created in Java, what rules apply to them.","(""Java"", ""has"", ""abstract classes""); (""abstract classes"", ""are created in"", ""Java""); (""Java"", ""applies"", ""rules"")"
This tutorial gets into the purpose of abstract classes in Java in more detail towards the end of this text.,"(""Java"", ""has"", ""abstract classes""); (""abstract classes"", ""used in"", ""Java""); (""Java"", ""provides"", ""abstract classes"")"
In Java you declare that a class is abstract by adding the abstract keyword to the class declaration.,"(""Java"", ""declares"", ""abstract class""); (""abstract keyword"", ""added to"", ""class declaration""); (""class declaration"", ""contains"", ""abstract keyword"")"
That is all there is to declaring an abstract class in Java.,"(""JDK"", ""contains"", ""Java""); (""Java"", ""has"", ""abstract class"")"
"If you try to compile the code above the Java compiler will generate an error, saying that you cannot instantiate MyAbstractClass because it is an abstract class.","(""Java compiler"", ""generate"", ""error""); (""MyAbstractClass"", ""instantiate"", ""error"")"
"If a class has an abstract method, the whole class must be declared abstract.","(""class"", ""has"", ""abstract method""); (""whole class"", ""must be declared"", ""abstract""); (""class"", ""has"", ""method""); (""class"", ""must be declared"", ""abstract"")"
Not all methods in an abstract class have to be abstract methods.,"(""abstract class"", ""have"", ""methods""); (""methods"", ""in"", ""abstract class""); (""abstract class"", ""have to be"", ""abstract methods"")"
An abstract class can have a mixture of abstract and non-abstract methods.,"(""Abstract Class"", ""can have"", ""Abstract Methods""); (""Abstract Class"", ""can have"", ""Non-Abstract Methods""); (""Abstract Class"", ""has"", ""Methods"")"
Subclasses of an abstract class must implement (override) all abstract methods of its abstract superclass.,"(""Subclasses"", ""implement"", ""abstract methods""); (""Subclasses"", ""override"", ""abstract methods""); (""Abstract class"", ""has"", ""abstract methods""); (""Subclasses"", ""inherit from"", ""abstract superclass""); (""Abstract superclass"", ""has"", ""abstract methods""); (""Subclasses"", ""implement"", ""abstract superclass"")"
The non-abstract methods of the superclass are just inherited as they are.,"(""superclass"", ""has"", ""methods""); (""methods"", ""are inherited by"", ""subclass""); (""superclass"", ""inherits to"", ""subclass""); (""methods"", ""are part of"", ""superclass"")"
Notice how MySubClass has to implement the abstract method abstractMethod() from its abstract superclass MyAbstractClass.,"(""MySubClass"", ""implements"", ""MyAbstractClass.abstractMethod()""); (""MySubClass"", ""extends"", ""MyAbstractClass""); (""MyAbstractClass"", ""declares"", ""MyAbstractClass.abstractMethod()"")"
"The only time a subclass of an abstract class is not forced to implement all abstract methods of its superclass, is if the subclass is also an abstract class.","(""subclass"", ""is a"", ""abstract class""); (""abstract class"", ""has"", ""abstract methods""); (""subclass"", ""implements"", ""abstract methods""); (""superclass"", ""has"", ""abstract methods""); (""subclass"", ""is a"", ""superclass"")"
The purpose of abstract classes is to function as base classes which can be extended by subclasses to create a full implementation.,"(""abstract classes"", ""can be extended by"", ""subclasses""); (""abstract classes"", ""function as"", ""base classes""); (""subclasses"", ""create"", ""full implementation""); (""abstract classes"", ""are"", ""base classes"")"
"If the steps before and after the action are always the same, the 3-step process could be implemented in an abstract superclass with this Java code:","(""Java"", ""implemented in"", ""abstract superclass""); (""abstract superclass"", ""has"", ""3-step process""); (""3-step process"", ""implemented in"", ""Java code"")"
Subclasses of MyAbstractProcess can now extend MyAbstractProcess and just override the action() method.,"(""MyAbstractProcess"", ""hasMethod"", ""action()""); (""MyAbstractProcess"", ""hasSubclass"", ""Subclasses of MyAbstractProcess""); (""Subclasses of MyAbstractProcess"", ""overrides"", ""MyAbstractProcess.action()"")"
"When the process() method of the subclass is called, the full process is executed, including the stepBefore() and stepAfter() of the abstract superclass, and the action() method of the subclass.","(""subclass"", ""has method"", ""process()""); (""abstract superclass"", ""has method"", ""stepBefore()""); (""abstract superclass"", ""has method"", ""stepAfter()""); (""subclass"", ""has method"", ""action()""); (""subclass"", ""executes"", ""process()""); (""process()"", ""includes"", ""stepBefore()""); (""process()"", ""includes"", ""stepAfter()""); (""process()"", ""includes"", ""action()"")"
"Of course, the MyAbstractProcess did not have to be an abstract class to function as a base class.","(""MyAbstractProcess"", ""is a"", ""base class""); (""MyAbstractProcess"", ""did not have to be"", ""abstract class"")"
"However, by making the method to implement abstract, and thus the class too, you signal clearly to users of this class that this class should not be used as it is.","(""Class"", ""has"", ""Method""); (""Method"", ""is part of"", ""Class""); (""Class"", ""is"", ""Abstract"")"
"Instead it should be used as a base class for a subclass, and that the abstract method should be implemented in the subclass.","(""abstract method"", ""should be implemented in"", ""subclass""); (""subclass"", ""is a"", ""base class"")"
The above example did not have a default implementation for the action() method.,"(""action"", ""has method"", ""default implementation""); (""action"", ""is a method of"", ""unspecified class"")"
In some cases your superclass might actually have a default implementation for the method that subclasses are supposed to override.,"(""subclasses"", ""override"", ""method""); (""superclass"", ""have"", ""method""); (""subclasses"", ""supposed to override"", ""method"")"
"You can still make the superclass abstract though, even if it contains no abstract methods.","(""superclass"", ""contains"", ""methods"")"
"Notice how the processURLData() is an abstract method, and that URLProcessorBase is an abstract class.","(""URLProcessorBase"", ""is a"", ""abstract class""); (""processURLData()"", ""is an"", ""abstract method""); (""processURLData()"", ""is part of"", ""URLProcessorBase"")"
Subclasses of URLProcessorBase have to implement the processURLData() method because it is an abstract method.,"(""URLProcessorBase"", ""has method"", ""processURLData()""); (""Subclasses of URLProcessorBase"", ""implement"", ""processURLData()""); (""URLProcessorBase"", ""has subclasses"", ""Subclasses of URLProcessorBase""); (""processURLData()"", ""is part of"", ""URLProcessorBase"")"
Subclasses of URLProcessorBase abstract class can process data downloaded from URLs without worrying about opening and closing the network connection to the URL.,"(""URLProcessorBase"", ""is subclass of"", ""None""); (""URLProcessorBase"", ""can process"", ""data""); (""URLProcessorBase"", ""downloads from"", ""URLs""); (""Subclasses of URLProcessorBase"", ""inherit from"", ""URLProcessorBase""); (""Subclasses of URLProcessorBase"", ""process"", ""data""); (""Subclasses of URLProcessorBase"", ""download from"", ""URLs""); (""Subclasses of URLProcessorBase"", ""handle"", ""network connection""); (""Subclasses of URLProcessorBase"", ""handle"", ""opening and closing network connection to URL""); (""URLProcessorBase"", ""handles"", ""network connection""); (""URLProcessorBase"", ""handles"", ""opening and closing network connection to URL""); (""URLs"", ""have"", ""data""); (""URLs"", ""are used by"", ""URLProcessorBase""); (""URLs"", ""are used by"", ""Subclasses of URLProcessorBase""); (""Subclasses of URLProcessorBase"", ""use"", ""URLs""); (""URLProcessorBase"", ""uses"", ""URLs""); (""Network connection"", ""is used by"", ""URLProcessorBase""); (""Network connection"", ""is used by"", ""Subclasses of URLProcessorBase""); (""Subclasses of URLProcessorBase"", ""use"", ""network connection""); (""URLProcessorBase"", ""uses"", ""network connection""); (""URLProcessorBase"", ""is parent of"", ""Subclasses of URLProcessorBase""); (""Subclasses of URLProcessorBase"", ""is child of"", ""URLProcessorBase"")"
Subclasses only need to worry about processing the data from the InputStream passed to the processURLData() method.,"(""Subclasses"", ""has method"", ""processURLData()""); (""processURLData()"", ""uses"", ""InputStream"")"
This makes it easier to implement classes that processes data from URLs.,"(""Class"", ""implements"", ""processes data from URLs""); (""classes"", ""processes"", ""data from URLs""); (""classes"", ""implement"", ""data from URLs""); (""URLs"", ""are used by"", ""classes""); (""classes"", ""process"", ""data""); (""classes"", ""use"", ""URLs"")"
"Notice how the subclass only implements the processURLData() method, and nothing more.","(""subclass"", ""implements"", ""processURLData()"")"
The rest of the code is inherited from the URLProcessorBase superclass.,"(""URLProcessorBase"", ""is superclass of"", ""the rest of the code"")"
Here is an example of how to use the URLProcessorImpl class:,"(""URLProcessorImpl"", ""is a"", ""class""); (""URLProcessorImpl"", ""used in"", ""example"")"
"The process() method is called, which is implemented in the URLProcessorBase superclass.","(""URLProcessorBase"", ""implements"", ""process()""); (""process()"", ""called by"", ""URLProcessorBase""); (""URLProcessorBase"", ""has method"", ""process()"")"
This method in turn calls the processURLData() in the URLProcessorImpl class.,"(""This method"", ""calls"", ""processURLData()""); (""processURLData()"", ""is part of"", ""URLProcessorImpl""); (""this method"", ""is part of"", ""unknown class""); (""URLProcessorImpl"", ""contains"", ""processURLData()"")"
The example I showed you above with the URLProcessorBase class is actually an example of the Template Method design pattern.,"(""URLProcessorBase"", ""is an example of"", ""Template Method"")"
"The Template Method design pattern provides a partial implementation of some process, which subclasses can complete when extending the Template Method base class.","(""Template Method"", ""provides"", ""partial implementation""); (""Template Method"", ""is extended by"", ""subclasses""); (""Template Method"", ""has base class"", ""Template Method base class""); (""Template Method base class"", ""is extended by"", ""subclasses"")"
"A Java access modifier specifies which classes can access a given class and its fields, constructors and methods.","(""Java access modifier"", ""specifies"", ""class""); (""class"", ""has"", ""fields""); (""class"", ""has"", ""constructors""); (""class"", ""has"", ""methods"")"
"Access modifiers can be specified separately for a class, its constructors, fields and methods.","(""class"", ""has"", ""constructors""); (""class"", ""has"", ""fields""); (""class"", ""has"", ""methods""); (""constructors"", ""specified by"", ""access modifiers""); (""fields"", ""specified by"", ""access modifiers""); (""methods"", ""specified by"", ""access modifiers""); (""class"", ""specified by"", ""access modifiers"")"
"Assigning an access modifier to a class, constructor, field or method is also sometimes referred to as ""marking"" that class, constructor, field or method as that which the access modifier specifies.","(""class"", ""has"", ""access modifier""); (""constructor"", ""has"", ""access modifier""); (""field"", ""has"", ""access modifier""); (""method"", ""has"", ""access modifier""); (""access modifier"", ""is assigned to"", ""class""); (""access modifier"", ""is assigned to"", ""constructor""); (""access modifier"", ""is assigned to"", ""field""); (""access modifier"", ""is assigned to"", ""method"")"
"If a method or variable is marked as private (has the private access modifier assigned to it), then only code inside the same class can access the variable, or call the method.","(""Class"", ""has access modifier"", ""private""); (""Method"", ""has access modifier"", ""private""); (""Variable"", ""has access modifier"", ""private""); (""Class"", ""contains"", ""Method""); (""Class"", ""contains"", ""Variable""); (""Code"", ""is inside"", ""Class""); (""Code"", ""can access"", ""Variable""); (""Code"", ""can call"", ""Method"")"
"Code inside subclasses cannot access the variable or method, nor can code from any external class.","(""subclasses"", ""cannot access"", ""variable""); (""subclasses"", ""cannot access"", ""method""); (""external class"", ""cannot access"", ""variable""); (""external class"", ""cannot access"", ""method"")"
"Marking a class with the private access modifier would mean that no other class could access it, which means that you could not really use the class at all.","(""class"", ""has access modifier"", ""private access modifier""); (""private access modifier"", ""restricts access to"", ""class""); (""class"", ""has relationship with"", ""other class""); (""other class"", ""is restricted from accessing"", ""class"")"
"That means, that the member variable time inside the Clock class cannot be accessed from code outside the Clock class.","(""Clock"", ""has member variable"", ""time""); (""time"", ""is inside"", ""Clock""); (""Clock"", ""restricts access to"", ""time""); (""time"", ""is accessed from"", ""code outside the Clock class""); (""Clock"", ""hides"", ""time""); (""Clock class"", ""has"", ""time""); (""Cclock"", ""encapsulates"", ""time"")"
"In some cases the fields are truly private, meaning they are only used internally in the class.","(""fields"", ""are used in"", ""class"")"
In other cases the fields can be accessed via accessor methods (e.g.,
In the above example the two methods getTime() and setTime() can access the time member variable.,"(""getTime()"", ""can access"", ""time""); (""setTime()"", ""can access"", ""time"")"
"If a constructor in a class is assigned the private Java access modifier, that means that the constructor cannot be called from anywhere outside the class.","(""constructor"", ""is assigned"", ""private Java access modifier""); (""constructor"", ""is part of"", ""class""); (""class"", ""has"", ""constructor""); (""constructor"", ""cannot be called from"", ""outside the class"")"
"A private constructor can still get called from other constructors, or from static methods in the same class.","(""constructor"", ""can be called from"", ""constructors""); (""constructor"", ""can be called from"", ""static methods""); (""static methods"", ""are in"", ""class""); (""constructor"", ""is in"", ""class"")"
This version of the Clock class contains a private constructor and a public constructor.,"(""Clock"", ""contains"", ""private constructor""); (""Clock"", ""contains"", ""public constructor""); (""private constructor"", ""is part of"", ""Clock""); (""public constructor"", ""is part of"", ""Clock"")"
The private constructor is called from the public constructor (the statement this();).,"(""private constructor"", ""is called from"", ""public constructor"")"
The private constructor is also called from the static method newClock().,"(""static method newClock()"", ""is called from"", ""private constructor"")"
The above example only serves to show you that a private constructor can be called from public constructors and from static methods inside the same class.,"(""class"", ""has"", ""constructor""); (""constructor"", ""can be called from"", ""public constructors""); (""constructor"", ""can be called from"", ""static methods""); (""class"", ""has"", ""public constructors""); (""class"", ""has"", ""static methods""); (""public constructors"", ""are in"", ""class""); (""static methods"", ""are in"", ""class"")"
"The default access modifier means that code inside the class itself as well as code inside classes in the same package as this class, can access the class, field, constructor or method which the default access modifier is assigned to.","(""class"", ""has access modifier"", ""default access modifier""); (""class"", ""is in"", ""package""); (""package"", ""contains"", ""class""); (""class"", ""has"", ""field""); (""class"", ""has"", ""constructor""); (""class"", ""has"", ""method""); (""default access modifier"", ""applies to"", ""class""); (""default access modifier"", ""applies to"", ""field""); (""default access modifier"", ""applies to"", ""constructor""); (""default access modifier"", ""applies to"", ""method""); (""class"", ""can access"", ""class""); (""class"", ""can access"", ""field""); (""class"", ""can access"", ""constructor""); (""class"", ""can access"", ""method"")"
"Subclasses cannot access methods and member variables (fields) in the superclass, if they these methods and fields are marked with the default access modifier, unless the subclass is located in the same package as the superclass.","(""Subclass"", ""cannot access"", ""Method""); (""Subclass"", ""cannot access"", ""Member Variable""); (""Subclass"", ""located in"", ""Package""); (""Superclass"", ""has"", ""Method""); (""Superclass"", ""has"", ""Member Variable""); (""Method"", ""marked with"", ""Default Access Modifier""); (""Member Variable"", ""marked with"", ""Default Access Modifier"")"
"The time field in the Clock class has no access modifier, which means that it is implicitly assigned the default / package access modifier.","(""Clock"", ""hasField"", ""time""); (""time"", ""hasAccessModifier"", ""default""); (""Clock"", ""hasAccessModifier"", ""default"")"
"Therefore, the ClockReader class can read the time member variable of the Clock object, provided that ClockReader and Clock are located in the same Java package.","(""ClockReader"", ""can read"", ""Clock""); (""ClockReader"", ""located in"", ""Java package""); (""Clock"", ""located in"", ""Java package"")"
"The protected access modifier provides the same access as the default access modifier, with the addition that subclasses can access protected methods and member variables (fields) of the superclass.","(""protected access modifier"", ""provides access to"", ""default access modifier""); (""protected access modifier"", ""allows access to"", ""subclasses""); (""protected methods"", ""are accessed by"", ""subclasses""); (""member variables"", ""are accessed by"", ""subclasses""); (""subclasses"", ""access"", ""protected methods""); (""subclasses"", ""access"", ""member variables"")"
This is true even if the subclass is not located in the same package as the superclass.,"(""subclass"", ""is Located In"", ""package""); (""subclass"", ""is Not Located In"", ""same package""); (""superclass"", ""is Located In"", ""package""); (""superclass"", ""is Located In"", ""same package""); (""subclass"", ""is A"", ""superclass"")"
In the above example the subclass SmartClock has a method called getTimeInSeconds() which accesses the time variable of the superclass Clock.,"(""SmartClock"", ""has method"", ""getTimeInSeconds()""); (""SmartClock"", ""accesses"", ""time""); (""SmartClock"", ""is subclass of"", ""Clock""); (""Clock"", ""has variable"", ""time""); (""getTimeInSeconds()"", ""accesses"", ""time"")"
"The Java access modifier public means that all code can access the class, field, constructor or method, regardless of where the accessing code is located.","(""Java"", ""has"", ""access modifier""); (""access modifier"", ""is"", ""public""); (""public"", ""applies to"", ""class""); (""public"", ""applies to"", ""field""); (""public"", ""applies to"", ""constructor""); (""public"", ""applies to"", ""method""); (""accessing code"", ""can access"", ""class""); (""accessing code"", ""can access"", ""field""); (""accessing code"", ""can access"", ""constructor""); (""accessing code"", ""can access"", ""method""); (""class"", ""has"", ""field""); (""class"", ""has"", ""constructor""); (""class"", ""has"", ""method"")"
The accessing code can be in a different class and different package.,"(""accessing code"", ""can be in"", ""class""); (""accessing code"", ""can be in"", ""package""); (""class"", ""can be in"", ""package""); (""accessing code"", ""is in"", ""different class""); (""accessing code"", ""is in"", ""different package"")"
The time field in the Clock class is marked with the public Java access modifier.,"(""Clock"", ""has field"", ""time""); (""time"", ""has access modifier"", ""public""); (""Clock"", ""uses access modifier"", ""public"")"
"Therefore, the ClockReader class can access the time field in the Clock no matter what package the ClockReader is located in.","(""ClockReader"", ""can access"", ""time""); (""ClockReader"", ""is located in"", ""package""); (""Clock"", ""has field"", ""time""); (""ClockReader"", ""accesses"", ""Clock"")"
"It is important to keep in mind that the Java access modifier assigned to a Java class takes precedence over any access modifiers assigned to fields, constructors and methods of that class.","(""Java class"", ""has"", ""fields""); (""Java class"", ""has"", ""constructors""); (""Java class"", ""has"", ""methods""); (""Java access modifier"", ""assigned to"", ""Java class""); (""Java access modifier"", ""assigned to"", ""fields""); (""Java access modifier"", ""assigned to"", ""constructors""); (""Java access modifier"", ""assigned to"", ""methods""); (""Java access modifier"", ""takes precedence over"", ""access modifiers"")"
"If the class is marked with the default access modifier, then no other class outside the same Java package can access that class, including its constructors, fields and methods.","(""class"", ""has"", ""constructors""); (""class"", ""has"", ""fields""); (""class"", ""has"", ""methods""); (""class"", ""is part of"", ""package""); (""package"", ""contains"", ""class""); (""class"", ""has"", ""access modifier""); (""access modifier"", ""is type of"", ""default access modifier"")"
The Java access modifiers private and protected cannot be assigned to a class.,"(""Java"", ""has"", ""access modifiers""); (""access modifiers"", ""include"", ""private""); (""access modifiers"", ""include"", ""protected""); (""private"", ""cannot be assigned to"", ""class""); (""protected"", ""cannot be assigned to"", ""class""); (""class"", ""has"", ""access modifiers"")"
Java interfaces are meant to specify fields and methods that are publicly available in classes that implement the interfaces.,"(""Java"", ""has"", ""interfaces""); (""interfaces"", ""specify"", ""fields""); (""interfaces"", ""specify"", ""methods""); (""classes"", ""implement"", ""interfaces""); (""interfaces"", ""are implemented by"", ""classes"")"
"When you create a subclass of some class, the methods in the subclass cannot have less accessible access modifiers assigned to them than they had in the superclass.","(""subclass"", ""has method"", ""method""); (""subclass"", ""inherits from"", ""superclass""); (""superclass"", ""has method"", ""method""); (""method"", ""has access modifier"", ""access modifier""); (""subclass"", ""cannot have"", ""less accessible access modifier""); (""superclass"", ""has"", ""access modifier""); (""access modifier"", ""is assigned to"", ""method""); (""subclass"", ""inherits"", ""access modifier"")"
"For instance, if a method in the superclass is public then it must be public in the subclass too, in case the subclass overrides the method.","(""subclass"", ""overrides"", ""method""); (""subclass"", ""has"", ""method""); (""superclass"", ""has"", ""method""); (""method"", ""is"", ""public"")"
If a method in the superclass is protected then it must be either protected or public in the subclass.,"(""superclass"", ""has method"", ""method""); (""subclass"", ""overrides"", ""method""); (""method"", ""has access modifier"", ""protected""); (""method"", ""has access modifier"", ""public"")"
"For instance, if a method is assigned the default access modifier in the superclass, then it is allowed to assign the overridden method in the subclass the public access modifier.","(""Method"", ""is assigned"", ""Access Modifier""); (""Superclass"", ""has"", ""Method""); (""Subclass"", ""overrides"", ""Method""); (""Method"", ""is overridden"", ""Method""); (""Subclass"", ""has"", ""Method""); (""Method"", ""is assigned"", ""Access Modifier""); (""Access Modifier"", ""is default"", ""Access Modifier""); (""Access Modifier"", ""is public"", ""Access Modifier"")"
"The build process includes generating source code, compiling the source, generating XML files (e.g.",
"You can place Java annotations above classes, interfaces, methods, method parameters, fields and local variables.","(""Java annotations"", ""can be placed above"", ""classes""); (""Java annotations"", ""can be placed above"", ""interfaces""); (""Java annotations"", ""can be placed above"", ""methods""); (""Java annotations"", ""can be placed above"", ""method parameters""); (""Java annotations"", ""can be placed above"", ""fields""); (""Java annotations"", ""can be placed above"", ""local variables"")"
"Here is a bigger example with annotations above both the class, fields, methods, parameters and local variables:","(""class"", ""has"", ""fields""); (""class"", ""has"", ""methods""); (""class"", ""has"", ""annotations""); (""fields"", ""has"", ""annotations""); (""methods"", ""has"", ""annotations""); (""parameters"", ""has"", ""annotations""); (""local variables"", ""has"", ""annotations"")"
"If your code uses deprecated classes, methods or fields, the compiler will give you a warning.","(""Code"", ""uses"", ""Classes""); (""Code"", ""uses"", ""Methods""); (""Code"", ""uses"", ""Fields""); (""Compiler"", ""gives"", ""Warning"")"
"If the method does not match a method in the superclass, the compiler will give you an error.","(""method"", ""does not match"", ""superclass""); (""compiler"", ""will give"", ""error""); (""superclass"", ""has"", ""method""); (""method"", ""is in"", ""superclass""); (""compiler"", ""checks"", ""method"")"
"In case someone changed the name of the overridden method in the superclass, your subclass method would no longer override it.","(""subclass"", ""overrides"", ""superclass""); (""subclass method"", ""overrides"", ""superclass method"")"
"In case the method doTheThing() in MySuperClass changes signature so that the same method in the subclass no longer overrides it, the compiler will generate an error.","(""MySuperClass"", ""hasMethod"", ""doTheThing()""); (""doTheThing()"", ""isIn"", ""MySuperClass""); (""MySuperClass"", ""hasSubclass"", ""subclass"")"
"Annotations are defined in their own file, just like a Java class or interface.","(""Annotation"", ""isDefinedIn"", ""file""); (""Java class"", ""isDefinedIn"", ""file""); (""interface"", ""isDefinedIn"", ""file""); (""Annotation"", ""resembles"", ""Java class""); (""Annotation"", ""resembles"", ""interface"")"
"RetentionPolicy.CLASS means that the annotation is stored in the .class file, but not available at runtime.","(""RetentionPolicy"", ""has_value"", ""CLASS""); (""RetentionPolicy.CLASS"", ""is_stored_in"", "".class file""); (""RetentionPolicy.CLASS"", ""is_available_at"", ""runtime"")"
"RetentionPolicy.SOURCE means that the annotation is only available in the source code, and not in the .class files and not a runtime.","(""RetentionPolicy"", ""has_value"", ""SOURCE""); (""RetentionPolicy.SOURCE"", ""is_available_in"", ""source code""); (""RetentionPolicy.SOURCE"", ""is_not_available_in"", "".class files""); (""RetentionPolicy.SOURCE"", ""is_not_available_at"", ""runtime"")"
"The second line declares an array of references to objects of the class MyClass, which symbolizes a class you have created yourself.","(""MyClass"", ""is instantiated as"", ""array of objects"")"
Personally I prefer to locate the square brackets [] after the data type (e.g.,
Java allows you to create an array of references to any type of object (to instances of any class).,"(""Java"", ""allows"", ""array""); (""Java"", ""creates"", ""array""); (""array"", ""references to"", ""object""); (""object"", ""instances of"", ""class""); (""Java"", ""creates"", ""object""); (""class"", ""has"", ""object""); (""object"", ""is instance of"", ""class""); (""Java"", ""supports"", ""class""); (""array"", ""contains"", ""object"")"
Notice how the values to be inserted into the array are listed inside the { ... } block.,
"Of course, if the insertIntoArray() method is located in a different class than the above code, you would need an object of that class in order to be able to call the method.","(""insertIntoArray()"", ""located in"", ""different class""); (""different class"", ""has method"", ""insertIntoArray()""); (""object"", ""is instance of"", ""different class""); (""object"", ""calls method"", ""insertIntoArray()"")"
"Or, if the insertIntoArray() method was static, you would need to put the class name and a dot in front of the method name.","(""insertIntoArray()"", ""is method of"", ""undefined class"")"
"This removeFromArray() method takes two parameters: The array to remove the element from, and the index of the element to remove.","(""removeFromArray()"", ""takes two parameters"", ""array""); (""removeFromArray()"", ""takes two parameters"", ""index""); (""removeFromArray()"", ""is a method of"", ""array""); (""removeFromArray()"", ""removes element from"", ""array""); (""removeFromArray()"", ""uses"", ""index"")"
"Of course, if the removeFromArray() method is located in a different class than the above code, you would need an object of that class in order to be able to call the method.","(""removeFromArray()"", ""located in"", ""different class""); (""different class"", ""has method"", ""removeFromArray()""); (""object"", ""is instance of"", ""different class""); (""object"", ""calls method"", ""removeFromArray()"")"
"Or, if the removeFromArray() method was static, you would need to put the class name and a dot in front of the method name.","(""removeFromArray"", ""is a method of"", ""unknown class""); (""unknown class"", ""has method"", ""removeFromArray()"")"
The example first sets the minVal to Integer.MAX_VALUE which is the highest possible value an int can take.,"(""Integer"", ""has_constant"", ""MAX_VALUE""); (""Integer"", ""has_method"", ""MAX_VALUE""); (""MAX_VALUE"", ""is_attribute_of"", ""Integer""); (""Integer"", ""is_type_of"", ""minVal""); (""minVal"", ""has_value"", ""Integer.MAX_VALUE"")"
"Java contains a special utility class that makes it easier for you to perform many often used array operations like copying and sorting arrays, filling in data, searching in arrays etc.","(""Java"", ""contains"", ""utility class""); (""utility class"", ""performs"", ""array operations""); (""array operations"", ""include"", ""copying""); (""array operations"", ""include"", ""sorting arrays""); (""array operations"", ""include"", ""filling in data""); (""array operations"", ""include"", ""searching in arrays"")"
The utility class is called Arrays and is located in the standard Java package java.util.,"(""Arrays"", ""isLocatedIn"", ""java.util"")"
I will cover a few of the methods found in this class in the following sections.,
"Remember, in order to use java.util.Arrays in your Java classes you must import it.","(""java.util.Arrays"", ""is imported by"", ""Java classes""); (""Java classes"", ""use"", ""java.util.Arrays"")"
Here is how importing java.util.Arrays could look in a Java class of your own:,"(""Java class"", ""imports"", ""java.util.Arrays"")"
It is this statement that imports the class java.util.Arrays into your Java class.,"(""java.util.Arrays"", ""imports"", ""Java class"")"
The second method to copy a Java array is to use the Arrays.copyOf() method.,"(""Arrays"", ""hasMethod"", ""copyOf()""); (""Arrays.copyOf()"", ""belongsTo"", ""Arrays""); (""Arrays"", ""isClassIn"", ""Java"")"
The third method to copy a Java array is to use the Arrays.copyOfRange() method.,"(""Arrays"", ""hasMethod"", ""copyOfRange()""); (""Arrays.copyOfRange()"", ""copies"", ""Java array""); (""Java array"", ""isCopiedBy"", ""Arrays.copyOfRange()"")"
"The Arrays.copyOfRange() method copies a range of an array, not necessarily the full array.","(""Arrays"", ""hasMethod"", ""copyOfRange()"")"
Here is how copying a full array using Arrays.copyOfRange() in Java looks:,"(""Arrays"", ""hasMethod"", ""copyOfRange()""); (""Arrays.copyOfRange()"", ""returns"", ""array""); (""Java"", ""uses"", ""Arrays""); (""Arrays.copyOfRange()"", ""isUsedFor"", ""copying array"")"
You can convert an Java array of primitive types to a String using the Arrays.toString() method.,"(""Arrays"", ""hasMethod"", ""toString()""); (""Arrays.toString()"", ""belongsTo"", ""Arrays""); (""Java"", ""hasArrayType"", ""primitive types""); (""primitive types"", ""canBeConvertedTo"", ""String""); (""Arrays.toString()"", ""converts"", ""Java array""); (""Java array"", ""ofType"", ""primitive types""); (""Arrays.toString()"", ""returns"", ""String"")"
Here is an example of how to convert an array of int to a String using Arrays.toString():,"(""Arrays"", ""toString()"", ""String""); (""Arrays"", ""toString()"", ""int"")"
You can sort the elements of an array using the Arrays.sort() method.,"(""Arrays"", ""hasMethod"", ""sort()""); (""Arrays.sort()"", ""belongsTo"", ""Arrays""); (""Arrays"", ""isUsedFor"", ""array""); (""Arrays.sort()"", ""sorts"", ""array"")"
After the for loop the array is converted to a String using Arrays.toString() and printed out to the console (command line).,"(""Arrays"", ""toString()"", ""String""); (""console"", ""printed out to"", ""command line""); (""Arrays"", ""toString()"", ""console"")"
The Arrays.sort() example shown earlier only works for Java arrays of primitive data types.,"(""Arrays"", ""hasMethod"", ""sort()""); (""Java"", ""hasArrays"", ""arrays""); (""arrays"", ""ofType"", ""primitive data types""); (""Arrays.sort()"", ""worksFor"", ""Java arrays""); (""Java arrays"", ""areOf"", ""primitive data types"")"
Here is first the class for the objects we want to sort:,
The class Employee is a simple model of an employee (I have created the Employee class).,"(""Employee"", ""is a"", ""model""); (""Employee"", ""is a"", ""class""); (""Employee"", ""created by"", ""I"")"
Here is first an example of sorting an array of Employee objects by their name using the Arrays.sort() method:,"(""Arrays"", ""hasMethod"", ""sort()""); (""Employee"", ""hasProperty"", ""name""); (""Arrays.sort()"", ""sorts"", ""Employee""); (""Employee"", ""isSortedBy"", ""name"")"
The array is of type Employee - the class I showed you earlier.,"(""Employee"", ""is_type_of"", ""array"")"
"As parameter to the Arrays.sort() method we pass the employee array, and a Comparator implementation which can determine the order of Employee objects.","(""Arrays"", ""hasMethod"", ""sort()""); (""Arrays.sort()"", ""takesParameter"", ""employee array""); (""Comparator"", ""hasImplementation"", ""implementation""); (""Comparator implementation"", ""determinesOrderOf"", ""Employee""); (""Employee"", ""hasOrder"", ""order""); (""Arrays.sort()"", ""uses"", ""Comparator implementation"")"
Anonymous implementations of interfaces are covered in my text about nested classes in Java.,"(""Java"", ""hasFeature"", ""nested classes""); (""nested classes"", ""areCoveredIn"", ""text""); (""text"", ""isAbout"", ""Anonymous implementations""); (""Anonymous implementations"", ""areOfType"", ""interfaces""); (""interfaces"", ""areCoveredIn"", ""text""); (""Java"", ""hasConcept"", ""Anonymous implementations""); (""Java"", ""hasFeature"", ""interfaces""); (""nested classes"", ""areIn"", ""Java"")"
What is important to catch in this example is the implementation of the compare() method of the anonymous inner implementation of the Comparator interface.,"(""Comparator"", ""has method"", ""compare()""); (""Comparator"", ""implemented by"", ""anonymous inner class""); (""anonymous inner class"", ""implements"", ""Comparator""); (""compare()"", ""is method of"", ""Comparator""); (""compare()"", ""is part of"", ""anonymous inner class"")"
In the example above we simply call the String.compare() method which does the comparison for us (compares the employee names).,"(""String"", ""hasMethod"", ""compare()""); (""String"", ""methodCalled"", ""compare()""); (""compare()"", ""usedFor"", ""comparison""); (""String"", ""usedFor"", ""employee names""); (""employee names"", ""comparedBy"", ""String.compare()"")"
"Here is the example from before, with a modified implementation of the compare() method of the anonymous implementation of the Comparator interface:","(""Comparator"", ""has method"", ""compare()""); (""Comparator"", ""implemented by"", ""anonymous implementation""); (""anonymous implementation"", ""implements"", ""Comparator""); (""anonymous implementation"", ""has method"", ""compare()""); (""compare()"", ""part of"", ""Comparator""); (""compare()"", ""modified in"", ""anonymous implementation"")"
Notice how the compare() method returns the difference between the employee ids by subtracting one from the other.,"(""compare"", ""returns"", ""difference""); (""compare"", ""subtracts"", ""employee ids""); (""employee ids"", ""compared by"", ""compare"")"
"To compare the Employee objects in the array first by their name, and if that is the same, then by their employee id, the compare() implementation would look like this:","(""Employee"", ""has"", ""name""); (""Employee"", ""has"", ""employee id""); (""compare()"", ""takes"", ""Employee""); (""Employee"", ""compared by"", ""name""); (""Employee"", ""compared by"", ""employee id"")"
These Arrays.fill() methods can fill an array with a given value.,"(""Arrays"", ""hasMethod"", ""fill()""); (""Arrays.fill()"", ""fills"", ""array""); (""Arrays.fill()"", ""takesValue"", ""given value""); (""array"", ""isFilledBy"", ""Arrays.fill()"")"
Here is an example of using Arrays.fill() to fill an int array:,"(""Arrays"", ""hasMethod"", ""fill()""); (""Arrays.fill()"", ""fills"", ""int array""); (""Arrays"", ""isUsedWith"", ""int array""); (""int array"", ""isFilledBy"", ""Arrays.fill()"")"
"There is a version of the Arrays.fill() method which takes a from and to index, so only elements with indexes in this interval are filled with the given value.","(""Arrays"", ""hasMethod"", ""fill()""); (""fill()"", ""takesParameter"", ""from""); (""fill()"", ""takesParameter"", ""to""); (""fill()"", ""takesParameter"", ""value""); (""Arrays.fill()"", ""operatesOn"", ""elements"")"
"You can do so yourself, or via the Arrays.sort() method covered earlier in this text.","(""Arrays"", ""hasMethod"", ""sort()"")"
The binarySearch() method will return the index in the array in which the element was found.,"(""Array"", ""has method"", ""binarySearch()"")"
"If all elements in the array are smaller than the sought value, then binarySearch() will return - length of the array - 1.","(""array"", ""contains"", ""elements""); (""binarySearch()"", ""returns"", ""value""); (""elements"", ""are smaller than"", ""sought value""); (""binarySearch()"", ""returns"", ""- length of the array - 1""); (""array"", ""has"", ""length"")"
Therefore binarySearch() will return -length (-6) - 1 = -6 -1 = -7.,
The Arrays.binarySearch() method also exists in a version where you just search part of the array.,"(""Arrays"", ""hasMethod"", ""binarySearch()""); (""Arrays.binarySearch()"", ""isVersionOf"", ""binarySearch()""); (""Arrays.binarySearch()"", ""searches"", ""array"")"
"This version of binarySearch() works just like the other version, except in the cases where no matching element is found.","(""binarySearch()"", ""works just like"", ""binarySearch()""); (""binarySearch()"", ""works with"", ""no matching element""); (""binarySearch()"", ""is compared to"", ""other version"")"
"If no element is found matching within the index interval, then binarySearch() will still return the index of where the value should have been inserted.","(""binarySearch()"", ""is method of"", ""unknown class""); (""binarySearch()"", ""returns"", ""index""); (""index"", ""is part of"", ""unknown class"")"
"But, if all values in the interval are smaller than the sought value, binarySearch() will return -toIndex -1 , and not -array length - 1.","(""binarySearch()"", ""return"", ""-toIndex - 1""); (""binarySearch()"", ""return"", ""-array length - 1"")"
The java.util.Arrays class contains a set of methods called equals() which can be used to check if two Java arrays are equal.,"(""java.util.Arrays"", ""contains"", ""equals()""); (""java.util.Arrays"", ""has method"", ""equals()""); (""equals()"", ""used for"", ""checking Java arrays""); (""java.util.Arrays"", ""has method"", ""equals()""); (""equals()"", ""checks"", ""Java arrays"")"
"Java classes are some of the core building blocks of Java applications, toolkits, frameworks, APIs etc.","(""Java"", ""contains"", ""classes""); (""APIs"", ""consist of"", ""Java classes""); (""Java applications"", ""use"", ""Java classes""); (""Java toolkits"", ""use"", ""Java classes""); (""Java frameworks"", ""use"", ""Java classes"")"
"A small Java application may consist of a single Java class with a main() method in, as covered in the Java main method tutorial.","(""Java class"", ""has method"", ""main()""); (""Java application"", ""consists of"", ""Java class""); (""Java main method tutorial"", ""covers"", ""main()"")"
"As your Java application grows, keeping all the code in the same class makes it harder and harder to keep an overview of the code.","(""Java application"", ""has"", ""class""); (""class"", ""contains"", ""code"")"
Therefore it might be beneficial to start splitting the Java code up into multiple classes.,"(""Java"", ""has"", ""code""); (""Java code"", ""split into"", ""classes"")"
"A Java class is a single, coherent unit of Java code which belongs together.","(""Java"", ""has"", ""class""); (""class"", ""is"", ""unit""); (""Java"", ""has"", ""code""); (""class"", ""belongs to"", ""Java""); (""Java"", ""contains"", ""code""); (""class"", ""consists of"", ""code"")"
A Java class may contain a mix of data (variables) and actions (methods).,"(""Java class"", ""contains"", ""data""); (""Java class"", ""contains"", ""actions""); (""Java class"", ""contains"", ""methods""); (""data"", ""is part of"", ""Java class""); (""actions"", ""is part of"", ""Java class""); (""methods"", ""is part of"", ""Java class"")"
Grouping variables and operations on these variables into Java classes makes it easier to structure your Java program when it gets too big to fit comfortably inside a single Java class.,"(""Java program"", ""contains"", ""Java class""); (""Java class"", ""structures"", ""Java program""); (""Java class"", ""groups"", ""variables""); (""Java class"", ""groups"", ""operations"")"
"Therefore, as the class grows, the file you are editing grows too, and becomes harder to keep an overview of in your head.","(""class"", ""grows"", ""file""); (""file"", ""becomes"", ""harder to overview""); (""class"", ""editing"", ""file"")"
"Your Java application will typically have to contain at least a single Java class, but it may contain as many classes as you see fit to divide your application into.","(""Java application"", ""contains"", ""Java class""); (""Java class"", ""divides"", ""Java application""); (""Java application"", ""has"", ""Java class"")"
"Java also comes with a lot of predefined classes for you, so you don't have to code every little function you might desire yourself.","(""Java"", ""comes with"", ""classes"")"
"Fields are variables (data) that are local to the class, or instances (objects) of that class.","(""Class"", ""has"", ""Fields""); (""Fields"", ""are"", ""variables""); (""Class"", ""has"", ""instances""); (""instances"", ""are"", ""objects""); (""Class"", ""has"", ""objects"")"
Methods are operations that the class or instances of that class can perform.,"(""Class"", ""can perform"", ""Methods""); (""Instances of Class"", ""can perform"", ""Methods"")"
Nested classes are Java classes that are defined inside another class.,"(""Java"", ""has"", ""Nested classes""); (""Nested classes"", ""defined inside"", ""class"")"
"Nested classes are typically intended to either be used only internally be the Java class that contains them, or to be used in connection with the class that contains them.","(""Java class"", ""contains"", ""Nested classes""); (""Java class"", ""uses"", ""Nested classes""); (""Nested classes"", ""used with"", ""Java class""); (""Nested classes"", ""used by"", ""Java class"")"
Nested classes are covered in more detail in my Java nested class tutorial.,"(""Java"", ""has"", ""nested class""); (""nested class"", ""covered in"", ""Java nested class tutorial"")"
"Sometimes you have classes that only contain fields (data), and sometimes you have classes that only contain methods (operations).","(""classes"", ""contain"", ""fields""); (""classes"", ""contain"", ""methods"")"
It depends on what the Java class is supposed to do.,"(""Java"", ""depends on"", ""class"")"
All it takes to define a class in Java is this:,"(""Java"", ""defines"", ""class"")"
The above class definition should be put in its own file named MyClass.java.,"(""MyClass"", ""definedIn"", ""MyClass.java"")"
"Java files should be named the same as the name of the class they contain, with the .java as file name extension.","(""Java files"", ""contain"", ""class""); (""class"", ""has"", ""name""); (""Java files"", ""have"", ""file name extension""); (""file name extension"", ""is"", "".java"")"
Make sure you keep the same uppercase and lowercase characters from the class name in the file name too.,
"Only put a single class definition in each Java file, unless your class contains inner classes of some kind.","(""Java file"", ""contains"", ""class definition""); (""class definition"", ""contains"", ""inner classes"")"
"As mentioned earlier, a Java class can contain data in the shape of variables.","(""Java class"", ""can contain"", ""data""); (""Java class"", ""contains"", ""variables""); (""variables"", ""are part of"", ""Java class"")"
The next example shows a Java class which is to model a car.,"(""Java"", ""hasClass"", ""Car"")"
A constructor is a special method that is called when an object of the given class is created (explained later).,"(""constructor"", ""is a"", ""method""); (""object"", ""is created from"", ""class""); (""constructor"", ""is called on"", ""object""); (""class"", ""has"", ""constructor"")"
The purpose of a constructor is to initialize the fields in the class.,"(""constructor"", ""initialize"", ""fields""); (""constructor"", ""is part of"", ""class""); (""class"", ""has"", ""fields"")"
Here is an example of a Java class with two constructors:,
"The constructors are the two methods that have the same name as the class, and which have no return type specified.","(""Class"", ""has"", ""Constructor""); (""Constructor"", ""isMethodOf"", ""Class""); (""Constructor"", ""hasNo"", ""Return Type"")"
"A Java method contains Java instructions that typically perform some operations on a field in the class, or on one of the parameters (also variables) values passed to the method when the method was called.","(""Java method"", ""contains"", ""Java instructions""); (""Java instructions"", ""perform operations on"", ""field""); (""Java instructions"", ""perform operations on"", ""parameter""); (""Method"", ""called with"", ""parameters""); (""Method"", ""performs operations on"", ""class"")"
"Here is the Java class, Car example from the previous section with a method added:","(""Car"", ""hasMethod"", ""Car.methodAdded()""); (""Car"", ""isA"", ""Java class""); (""Car"", ""fromSection"", ""previous section"")"
In the class definition above I have added a setColor() method.,"(""class definition"", ""has method"", ""setColor()"")"
"As mentioned earlier, you can define a nested class inside another Java class.","(""Java class"", ""contains"", ""nested class"")"
Here is an example of defining a nested class inside a Java class:,"(""Java class"", ""contains"", ""nested class"")"
"In the example above, the outer class is called MyClass and the nested class is called MyNestedClass .","(""MyClass"", ""contains"", ""MyNestedClass"")"
"Neither of the classes in this example has any fields or methods, but both the outer and nested class could have as many fields and methods as you see fit.","(""outer class"", ""has"", ""fields""); (""outer class"", ""has"", ""methods""); (""nested class"", ""has"", ""fields""); (""nested class"", ""has"", ""methods"")"
You can read more about nested classes in my tutorial about nested classes in Java,"(""Java"", ""hasConcept"", ""nested classes""); (""nested classes"", ""describedIn"", ""tutorial""); (""Java"", ""hasTutorial"", ""tutorial""); (""tutorial"", ""describes"", ""nested classes"")"
A Java class is a template for how objects of that class looks.,"(""Java"", ""has"", ""class""); (""class"", ""is a"", ""template""); (""template"", ""defines"", ""objects""); (""objects"", ""are instances of"", ""class""); (""class"", ""looks"", ""objects"")"
"In other words, the Car class in the previous section is a template for how Car objects look.","(""Car"", ""is a template for"", ""Car objects"")"
"To create objects of a certain class, you use the new keyword.","(""class"", ""uses"", ""new keyword"")"
"This example creates 3 Car variables, and assign a new instance of the Car class to each variable.","(""Car"", ""hasInstance"", ""Car class""); (""Car class"", ""instantiatedBy"", ""example""); (""example"", ""creates"", ""Car variables""); (""Car variables"", ""areInstancesOf"", ""Car class"")"
"Thus, the fields of different objects (even of the same class) can vary independently of each other.",
"After creating the 3 Car objects, the setColor() method is called on each object.","(""Car"", ""hasMethod"", ""setColor()""); (""Car"", ""creates"", ""Car object""); (""Car"", ""callsMethod"", ""setColor()"")"
"Creating an object of a certain class is also called ""instantiating"" an object.","(""Object"", ""is instantiated by"", ""Class""); (""Class"", ""instantiates"", ""Object"")"
"The object is thus also called an ""instance"" of the given class.","(""object"", ""is an instance of"", ""class""); (""class"", ""has"", ""instance""); (""instance"", ""is an"", ""object"")"
"For instance, each of the Car objects above are also called an instance of the Car class, or simply ""Car instances"".","(""Car"", ""is an instance of"", ""Car class""); (""Car class"", ""has"", ""Car instances""); (""Car"", ""is also known as"", ""Car instances"")"
What you have seen in this text only covers the very basics of Java classes.,"(""Java"", ""has"", ""classes"")"
"You need to learn about fields, constructors, methods nested classes, abstract classes, inheritance, access modifiers and interfaces too.","(""fields"", ""isrelatedto"", ""classes""); (""constructors"", ""isrelatedto"", ""classes""); (""methods"", ""isrelatedto"", ""classes""); (""nested classes"", ""isrelatedto"", ""classes""); (""abstract classes"", ""isrelatedto"", ""classes""); (""inheritance"", ""isrelatedto"", ""classes""); (""access modifiers"", ""isrelatedto"", ""classes""); (""interfaces"", ""isrelatedto"", ""classes"")"
"Here is a simple example that creates an object, which results in the class constructor being called:","(""object"", ""creates"", ""class""); (""class"", ""has"", ""constructor""); (""constructor"", ""is called by"", ""object"")"
The example shows a very simple Java class with a single constructor.,"(""Java"", ""has"", ""class""); (""class"", ""has"", ""constructor"")"
The second part of a Java constructor declaration is the name of the class the constructor belongs to.,"(""Java constructor"", ""belongs to"", ""class""); (""constructor"", ""is part of"", ""class declaration""); (""constructor declaration"", ""has"", ""class name""); (""class"", ""has"", ""constructor declaration""); (""constructor"", ""is declared in"", ""class"")"
Using the class name for the constructor signals to the Java compiler that this is a constructor.,"(""Java compiler"", ""uses"", ""class name""); (""class name"", ""signals"", ""constructor""); (""constructor"", ""is signaled by"", ""class name"")"
The constructor parameters are declared inside the parentheses () after the class name part of the constructor .,"(""constructor"", ""is declared in"", ""class""); (""constructor parameters"", ""are declared inside"", ""parentheses""); (""class name"", ""is part of"", ""constructor"")"
"A class can have multiple constructors, as long as their signature (the parameters they take) are not the same.","(""class"", ""can have"", ""constructors""); (""constructors"", ""have"", ""parameters""); (""class"", ""have"", ""signature""); (""constructors"", ""take"", ""parameters""); (""signature"", ""are"", ""parameters""); (""constructors"", ""are not the same"", ""signature"")"
"When a Java class contains multiple constructors, we say that the constructor is overloaded (comes in multiple versions).","(""Java class"", ""contains"", ""constructors""); (""constructor"", ""is overloaded"", ""multiple versions""); (""Java class"", ""has"", ""multiple constructors"")"
"This is what constructor overloading means, that a Java class contains multiple constructors.","(""Java class"", ""contains"", ""constructors""); (""constructor"", ""is part of"", ""Java class""); (""constructor overloading"", ""is a feature of"", ""Java class"")"
The keyword this in front of the field name (this.number) is not necessary.,"(""field"", ""hasKeyword"", ""this""); (""this"", ""refersTo"", ""field""); (""field"", ""hasName"", ""number"")"
"You don't have to define a constructor for a class, but if you don't define any constructor, the Java compiler will insert a default, no-argument constructor for you.","(""Java compiler"", ""inserts"", ""default constructor""); (""Class"", ""has"", ""constructor""); (""Constructor"", ""is"", ""no-argument constructor""); (""Java compiler"", ""provides"", ""default constructor""); (""Class"", ""requires"", ""constructor""); (""Default constructor"", ""is"", ""no-argument constructor"")"
"Thus, once the class is compiled it will always at least have a no-argument constructor.","(""class"", ""has"", ""constructor""); (""constructor"", ""is part of"", ""class""); (""class"", ""is compiled to"", ""bytecode"")"
"If you do define a constructor for your class, then the Java compiler will not insert the default no-argument constructor into your class.","(""Java compiler"", ""will not insert"", ""default no-argument constructor""); (""class"", ""has"", ""constructor""); (""Java compiler"", ""inserts"", ""default no-argument constructor""); (""class"", ""has"", ""default no-argument constructor"")"
The parameters are passed to the constructor inside the parentheses after the class name on the right side of the equal sign.,"(""constructor"", ""is part of"", ""class""); (""parameters"", ""are passed to"", ""constructor""); (""class"", ""has"", ""constructor""); (""class name"", ""is followed by"", ""constructor"")"
"By default, if a parameter (or local variable) has the same name as a field in the same class, the parameter (or local variable) ""shadows"" for the field.","(""parameter"", ""shadows"", ""field""); (""local variable"", ""shadows"", ""field""); (""parameter"", ""has same name as"", ""field""); (""local variable"", ""has same name as"", ""field""); (""class"", ""contains"", ""field""); (""class"", ""contains"", ""parameter""); (""class"", ""contains"", ""local variable"")"
"Inside the constructor of the Employee class the firstName, lastName and birthYear identifiers now refer to the constructor parameters, not to the Employee fields with the same names.","(""Employee"", ""has constructor parameter"", ""firstName""); (""Employee"", ""has constructor parameter"", ""lastName""); (""Employee"", ""has constructor parameter"", ""birthYear""); (""Employee"", ""has field"", ""firstName""); (""Employee"", ""has field"", ""lastName""); (""Employee"", ""has field"", ""birthYear""); (""Employee"", ""has constructor"", ""Employee.constructor()"")"
"To signal to the Java compiler that you mean the fields of the Employee class and not the parameters, put the this keyword and a dot in front of the field name.","(""Java compiler"", ""uses"", ""this keyword""); (""Employee class"", ""has"", ""fields""); (""this keyword"", ""is used with"", ""field name""); (""fields"", ""are part of"", ""Employee class""); (""parameters"", ""are distinct from"", ""fields"")"
You call a constructor when you create a new instance of the class containing the constructor.,"(""Class"", ""contains"", ""Constructor""); (""Constructor"", ""is called when"", ""new instance of Class""); (""Class"", ""has"", ""Constructor"")"
"In case you want to pass parameters to the constructor, you include the parameters between the parentheses after the class name, like this:",
The this keyword followed by parentheses and parameters means that another constructor in the same Java class is being called.,"(""Java class"", ""has"", ""constructor""); (""constructor"", ""is called by"", ""this keyword""); (""this keyword"", ""is followed by"", ""parentheses""); (""parentheses"", ""contain"", ""parameters""); (""Java class"", ""contains"", ""constructor""); (""constructor"", ""is in"", ""Java class"")"
In this example it is the first constructor in the class that is being called.,"(""class"", ""has"", ""constructor""); (""constructor"", ""is called in"", ""class"")"
"When a class extends another class it is also said to ""inherit"" from the class it extends.","(""Class"", ""extends"", ""Class""); (""Class"", ""inherits"", ""Class""); (""Class"", ""inherits from"", ""Class"")"
"The class that extends is called the subclass, and the class being extended is called the superclass.","(""subclass"", ""extends"", ""superclass"")"
A class that extends another class does not inherit its constructors.,"(""Class"", ""extends"", ""another class""); (""Class"", ""does not inherit"", ""constructors""); (""Class"", ""inherits"", ""methods""); (""Class"", ""has"", ""constructors""); (""Constructors"", ""are not inherited by"", ""Class""); (""Class"", ""extends"", ""Class"")"
"However, the subclass must call a constructor in the superclass inside of its the subclass constructors!","(""subclass"", ""call"", ""constructor""); (""subclass"", ""have"", ""subclass constructors""); (""constructor"", ""be in"", ""superclass""); (""subclass constructors"", ""call"", ""constructor"")"
"If a subclass calls another constructor within itself, then the called constructor must call the superclass constructor.","(""subclass"", ""calls"", ""constructor""); (""constructor"", ""calls"", ""superclass constructor""); (""subclass"", ""has"", ""constructor"")"
It calls the constructor in the superclass using this Java statement:,"(""constructor"", ""is called in"", ""superclass"")"
Using the keyword super refers to the superclass of the class using the super keyword.,"(""class"", ""uses"", ""super keyword""); (""super keyword"", ""refers to"", ""superclass""); (""class"", ""has"", ""superclass"")"
"When super keyword is followed by parentheses like it is here, it refers to a constructor in the superclass.","(""super"", ""refers to"", ""constructor""); (""super"", ""is followed by"", ""parentheses""); (""constructor"", ""is in"", ""superclass"")"
In this case it refers to the constructor in the Vehicle class.,"(""Vehicle"", ""has constructor"", ""Vehicle constructor"")"
The access modifier of a constructor determines what classes in your application that are allowed to call that constructor.,"(""constructor"", ""has"", ""access modifier""); (""access modifier"", ""determines"", ""classes""); (""constructor"", ""called by"", ""classes""); (""classes"", ""in"", ""application"")"
"For instance, if a constructor is declared protected then only classes in the same package, or subclasses of that class can call that constructor.","(""constructor"", ""is declared in"", ""class""); (""constructor"", ""can be called by"", ""subclass""); (""constructor"", ""can be called by"", ""class in same package""); (""subpackage"", ""is part of"", ""package""); (""class"", ""is in"", ""package""); (""subclass"", ""is a"", ""class"")"
"A class can have multiple constructors, and each constructor can have its own access modifier.","(""class"", ""can have"", ""constructors""); (""constructor"", ""can have"", ""access modifier""); (""class"", ""has"", ""constructors"")"
"Thus, some constructors may be available to all classes in your application, while other constructors are only available to classes in the same package, subclasses, or even only to the class itself (private constructors).","(""Class"", ""has"", ""Constructor""); (""Constructor"", ""is available to"", ""Class""); (""Class"", ""is in"", ""Package""); (""Package"", ""contains"", ""Class""); (""Constructor"", ""is accessible by"", ""Subclass""); (""Constructor"", ""is accessible by"", ""Class""); (""Class"", ""has"", ""Private Constructor"")"
Here is an example of a Java class with a constructor that can throw an exception:,
Making a constructor throw an exception can be a good idea if you want to prevent an object of the given class to be created in an invalid state.,
"A class can have fields, constructors and methods (plus more, but that is not important now).","(""class"", ""can have"", ""fields""); (""class"", ""can have"", ""constructors""); (""class"", ""can have"", ""methods"")"
"When you create an object, that object is of a certain class.","(""object"", ""is of"", ""class"")"
The class is like a template (or blueprint) telling how objects of that class should look.,"(""class"", ""is like"", ""template""); (""class"", ""tells"", ""objects""); (""objects"", ""of"", ""class""); (""class"", ""has"", ""template"")"
"When you create an object, you say ""give me an object of this class"".","(""Object"", ""created from"", ""Class"")"
"If you think of a factory producing lots and lots of the same items, then the class would be the blueprint / manual of how the finished product should look, and the objects would be each of the finished products.","(""class"", ""is blueprint of"", ""object""); (""object"", ""is instance of"", ""class""); (""class"", ""defines"", ""object"")"
"If the factory produced cars, then the blueprint / design manual of the cars to produce corresponds to a Java class, and the physical cars produced corresponds to Java objects.","(""Java class"", ""corresponds to"", ""blueprint""); (""Java objects"", ""corresponds to"", ""physical cars""); (""Java class"", ""used to create"", ""Java objects""); (""blueprint"", ""used to create"", ""physical cars""); (""factory"", ""produces"", ""physical cars""); (""Java class"", ""represents"", ""design manual""); (""physical cars"", ""are instances of"", ""blueprint""); (""Java objects"", ""are instances of"", ""Java class"")"
Here is a simple diagram illustrating the principle of objects being of a certain class.,
The class determines what fields and methods the objects of that class have.,"(""class"", ""determines"", ""fields""); (""class"", ""determines"", ""methods""); (""class"", ""have"", ""objects""); (""objects"", ""of"", ""class""); (""class"", ""have"", ""fields""); (""class"", ""have"", ""methods"")"
"The Car class does not contain any fields, constructors or methods.","(""Car"", ""does not contain"", ""fields""); (""Car"", ""does not contain"", ""constructors""); (""Car"", ""does not contain"", ""methods"")"
The example primarily serves to show you an example of how a class declaration looks in Java code.,"(""Java"", ""uses"", ""class declaration""); (""Java code"", ""contains"", ""class declaration""); (""class declaration"", ""is part of"", ""Java"")"
A field is a variable that belongs to a class or an object.,"(""field"", ""belongs to"", ""class""); (""field"", ""belongs to"", ""object"")"
"For instance, a Car class could define the field brand which all Car objects would have.","(""Car"", ""has field"", ""brand""); (""Car"", ""defines"", ""brand""); (""Car"", ""has"", ""Car objects"")"
Here is the Car class declaration from above with a field name brand added:,"(""Car"", ""has field"", ""brand"")"
Constructors are a special kind of method that is executed when an object of that class is created.,"(""Constructors"", ""is a"", ""method""); (""Constructors"", ""executed when"", ""object creation""); (""object"", ""created of"", ""class"")"
Here is the Car class from before with a constructor that initializes the brand field:,"(""Car"", ""has"", ""constructor""); (""constructor"", ""initializes"", ""brand""); (""Car"", ""has"", ""brand"")"
"Here is the Car class from before with a single, simple method named getBrand added:","(""Car"", ""hasMethod"", ""getBrand""); (""Car"", ""contains"", ""getBrand()"")"
"When a class implements an interface, the class has to implement all the methods described in the interface.","(""class"", ""implements"", ""interface""); (""interface"", ""has"", ""methods""); (""class"", ""implements"", ""methods""); (""class"", ""has to implement"", ""methods"")"
"Packages provides a handy way of grouping related classes and interfaces, thus making modularization of your Java code easier.","(""Packages"", ""provides"", ""way""); (""Packages"", ""groups"", ""classes""); (""Packages"", ""groups"", ""interfaces""); (""Packages"", ""makes"", ""modularization""); (""modularization"", ""of"", ""Java code""); (""Java code"", ""easier"", ""modularization""); (""Packages"", ""makes"", ""Java code""); (""Packages"", ""provides"", ""modularization""); (""Packages"", ""groups"", ""Java code"")"
"That these are primitive data types means that they are not objects, nor references to objects (classes and objects are explained in later texts in this Java tutorial).",
You can also create your own more complex data types by creating custom classes.,"(""custom classes"", ""created by"", ""complex data types""); (""complex data types"", ""have"", ""custom classes""); (""custom classes"", ""are"", ""data types"")"
"More precisely, a Java enum type is a special kind of Java class.","(""Java enum type"", ""is a special kind of"", ""Java class"")"
Notice the enum keyword which is used in place of class or interface.,
Replace the ... with the code to execute if the level variable matches the given Level constant value.,"(""level"", ""matches"", ""Level""); (""Level"", ""has constant value"", ""level""); (""Level"", ""is compared to"", ""level""); (""variable"", ""has value"", ""Level""); (""level"", ""is compared to"", ""Level"")"
You can obtain an array of all the possible values of a Java enum type by calling its static values() method.,"(""Java enum type"", ""has method"", ""values()""); (""values()"", ""is method of"", ""Java enum type""); (""Java enum type"", ""has values"", ""array of possible values"")"
All enum types get a static values() method automatically by the Java compiler.,"(""Enum"", ""gets"", ""values() method""); (""Java compiler"", ""adds"", ""values() method""); (""Enum"", ""has"", ""values() method"")"
An enum class automatically gets a toString() method in the class when compiled.,"(""enum class"", ""gets"", ""toString() method""); (""enum class"", ""has"", ""toString() method""); (""toString() method"", ""is in"", ""enum class"")"
The toString() method returns a string value of the name of the given enum instance.,"(""enum instance"", ""has method"", ""toString()""); (""toString()"", ""returns"", ""string value""); (""enum instance"", ""has attribute"", ""name"")"
"Then the toString() method will get called behind the scenes, so the value that will be printed out is the textual name of the enum instance.","(""enum instance"", ""has method"", ""toString()""); (""toString()"", ""gets called by"", ""enum instance"")"
An enum class automatically gets a static valueOf() method in the class when compiled.,"(""enum class"", ""gets"", ""valueOf() method""); (""enum class"", ""has"", ""valueOf() method""); (""valueOf() method"", ""is in"", ""enum class""); (""enum class"", ""compiled to have"", ""valueOf() method"")"
The valueOf() method can be used to obtain an instance of the enum class for a given String value.,"(""enum class"", ""has method"", ""valueOf()""); (""valueOf()"", ""returns"", ""enum class instance""); (""String"", ""used by"", ""valueOf()"")"
The level variable will point to the Level.HIGH after executing this line.,"(""Level"", ""has_variable"", ""level""); (""Level"", ""has_value"", ""Level.HIGH"")"
It is possible for a Java enum class to have abstract methods too.,"(""Java enum class"", ""to have"", ""abstract methods""); (""Java enum class"", ""to be a type of"", ""class"")"
"If an enum class has an abstract method, then each instance of the enum class must implement it.","(""enum class"", ""has"", ""abstract method""); (""enum class"", ""must implement"", ""abstract method""); (""instance of enum class"", ""implements"", ""abstract method"")"
Notice the abstract method declaration at the bottom of the enum class.,"(""enum class"", ""has"", ""abstract method declaration"")"
It is the method getDescription() that comes from the interface MyInterface.,"(""MyInterface"", ""hasMethod"", ""getDescription()"")"
"Java enums extend the java.lang.Enum class implicitly, so your enum types cannot extend another class.","(""Java enums"", ""extend"", ""java.lang.Enum""); (""java.lang.Enum"", ""is extended by"", ""Java enums""); (""Java enums"", ""cannot extend"", ""another class"")"
"The purpose of this exercise is to verify that you know how to create classes, how to create instance variables inside the classes, how to create an array of objects and how to iterate that array while referencing the objects in it.","(""Class"", ""has"", ""instance variables""); (""Class"", ""contains"", ""array of objects""); (""Array of objects"", ""is iterated by"", ""Class""); (""Class"", ""references"", ""objects in array"")"
"For instance, in a class representing an employee, the Employee class might contain the following fields:","(""Employee"", ""contains"", ""fields"")"
The access modifier determines which object classes that can access the field.,"(""access modifier"", ""determines"", ""field""); (""object classes"", ""can access"", ""field""); (""access modifier"", ""affects"", ""object classes"")"
"In Java, static fields belongs to the class, not instances of the class.","(""static fields"", ""belongs to"", ""class""); (""class"", ""has"", ""static fields""); (""instances of the class"", ""does not have"", ""static fields"")"
"Thus, all instances of any class will access the same static field variable.","(""class"", ""has"", ""static field variable""); (""static field variable"", ""is accessed by"", ""class""); (""instances"", ""access"", ""static field variable""); (""class"", ""has"", ""instances"")"
A non-static field value can be different for every object (instance) of a class.,"(""field"", ""is a part of"", ""class""); (""object"", ""is an instance of"", ""class""); (""class"", ""has"", ""field""); (""class"", ""has"", ""object"")"
The Java field access modifier determines whether the field can be accessed by classes other than the the class owning the field.,"(""Java"", ""has"", ""field access modifier""); (""field access modifier"", ""determines"", ""accessibility""); (""Java field"", ""owned by"", ""class""); (""class"", ""has"", ""field""); (""field access modifier"", ""affects"", ""field accessibility""); (""class"", ""owns"", ""field"")"
The private access modifier means that only code inside the class itself can access this Java field.,"(""class"", ""has access modifier"", ""private""); (""class"", ""has"", ""field""); (""field"", ""has access modifier"", ""private""); (""Java"", ""has"", ""class""); (""class"", ""is written in"", ""Java"")"
"The package access modifier means that only code inside the class itself, or other classes in the same package, can access the field.","(""class"", ""has modifier"", ""package access modifier""); (""package"", ""contains"", ""class""); (""class"", ""has field"", ""field""); (""field"", ""has modifier"", ""package access modifier"")"
"The protected access modifier is like the package modifier, except subclasses of the class can also access the field, even if the subclass is not located in the same package.","(""protected access modifier"", ""is like"", ""package modifier""); ("" subclasses"", ""can access"", ""field""); (""subclasses"", ""are located in"", ""package""); (""class"", ""has"", ""field""); (""protected access modifier"", ""allows access to"", ""subclasses""); (""package modifier"", ""restricts access to"", ""package"")"
The public access modifier means that the field can be accessed by all classes in your application.,"(""public access modifier"", ""means that the field can be accessed by"", ""all classes""); (""all classes"", ""in your application"", ""application""); (""public access modifier"", ""allows access to"", ""field""); (""field"", ""can be accessed by"", ""all classes""); (""all classes"", ""are part of"", ""application"")"
You would probably not use all access modifiers in the same class.,"(""access modifiers"", ""are used in"", ""class"")"
"For simple, data carrying classes you may declare all fields public.","(""Class"", ""has"", ""fields""); (""fields"", ""are"", ""public""); (""Class"", ""declares"", ""fields"")"
"Thus, no matter how many objects you create of that class, there will only exist one field located in the class, and the value of that field is the same, no matter from which object it is accessed.","(""class"", ""has"", ""field""); (""field"", ""located in"", ""class""); (""object"", ""accesses"", ""field""); (""class"", ""has"", ""objects""); (""field"", ""shared by"", ""objects"")"
"Static fields are located in the class, so you don't need an instance of the class to access static fields.","(""Class"", ""has"", ""Static fields""); (""Static fields"", ""are located in"", ""Class""); (""Class"", ""can be accessed without"", ""Instance""); (""Static fields"", ""can be accessed without"", ""Instance""); (""Instance"", ""is not needed for"", ""Static fields""); (""Class"", ""does not require"", ""Instance"")"
"Non-static Java fields, on the other hand, are located in the instances of the class.","(""Java"", ""has"", ""fields""); (""fields"", ""are located in"", ""instances""); (""instances"", ""are part of"", ""class""); (""class"", ""has"", ""instances""); (""Java"", ""has"", ""class"")"
Each instance of the class can have its own values for these fields.,"(""Class"", ""has"", ""fields""); (""Instance"", ""is"", ""Class""); (""Fields"", ""belong to"", ""Class""); (""Instance"", ""has"", ""values""); (""Values"", ""are part of"", ""fields""); (""Class"", ""has"", ""instance"")"
To access a non-static field you need an instance of the class (an object) on which you can access it.,"(""class"", ""has"", ""instance""); (""instance"", ""of"", ""class""); (""class"", ""has"", ""field""); (""field"", ""is"", ""non-static""); (""object"", ""is"", ""instance""); (""class"", ""has"", ""object"")"
"That means, that even if the field belongs to objects (class instances), you cannot vary the value of the field from object to object.","(""field"", ""belongs to"", ""object""); (""object"", ""has"", ""field""); (""class instances"", ""are"", ""object""); (""field"", ""has"", ""value""); (""object"", ""has"", ""value""); (""value"", ""varies from"", ""object"")"
"That way it only exists in the class, not in every object too.","(""class"", ""exists in"", ""object"")"
"The first line creates a new Customer object (an instance of the Customer class), and stores it in a variable called customer.","(""Customer"", ""instance of"", ""Customer class""); (""customer"", ""is a"", ""Customer object""); (""Customer class"", ""creates"", ""Customer object""); (""customer"", ""stored in"", ""variable""); (""variable"", ""called"", ""customer""); (""Customer"", ""stored in"", ""customer"")"
A class is loaded the first time it is referenced in your program.,"(""class"", ""is loaded in"", ""program""); (""class"", ""is referenced in"", ""program"")"
"Inside the parentheses () after the for keyword, are three statements separated by semicolon (;).",
"In this example, only the first System.out.println() statement is executed inside the for loop.","(""System"", ""uses"", ""System.out""); (""System.out"", ""has method"", ""println()""); (""for loop"", ""contains"", ""System.out.println()"")"
The second System.out.println() statement is not executed until after the for loop is finished.,"(""System"", ""uses"", ""System.out.println()""); (""for loop"", ""uses"", ""System.out.println()""); (""System.out"", ""contains"", ""println()"")"
"Second, inside the isValid() method the String.equals() method is used to test for equality to a certain string value.","(""String"", ""equals"", ""certain string value""); (""String"", ""used in"", ""isValid()""); (""isValid()"", ""contains"", ""String.equals()"")"
The isValid() method could actually have been written in a shorter way.,"(""isValid()"", ""is method of"", ""unknown class"")"
Now the isValid() method returns the value returned by the value.equals() method call.,"(""isValid()"", ""returns"", ""value.equals()""); (""value.equals()"", ""called by"", ""isValid()"")"
Java inheritance refers to the ability in Java for one class to inherit from another class.,"(""Java"", ""inherits from"", ""class""); (""class"", ""inherits from"", ""class"")"
One class can extend another class and thereby inherit from that class.,"(""One class"", ""extend"", ""another class""); (""One class"", ""inherit from"", ""another class"")"
"When one class inherits from another class in Java, the two classes take on certain roles.","(""Class"", ""inherits from"", ""Class"")"
The class that extends (inherits from another class) is the subclass and the class that is being extended (the class being inherited from) is the superclass .,"(""subclass"", ""extends"", ""superclass""); (""subclass"", ""inherits from"", ""superclass""); (""superclass"", ""is inherited by"", ""subclass"")"
"A subclass is a specialization of a superclass, and a superclass is a generalization of one or more subclasses.","(""subclass"", ""is a specialization of"", ""superclass""); (""superclass"", ""is a generalization of"", ""subclass"")"
"Inheritance can be an effective method to share code between classes that have some traits in common, yet allowing the classes to have some parts that are different.","(""Inheritance"", ""can be used in"", ""classes""); (""classes"", ""have"", ""traits""); (""classes"", ""have"", ""parts"")"
"Here is diagram illustrating a class called Vehicle, which has two subclasses called Car and Truck.","(""Vehicle"", ""has subclass"", ""Car""); (""Vehicle"", ""has subclass"", ""Truck"")"
The Vehicle class can contain those fields and methods that all Vehicles need (e.g.,"(""Vehicle"", ""contains"", ""fields""); (""Vehicle"", ""contains"", ""methods"")"
Note: Some people will claim that inheritance is a way to categorize your classes based on what they are.,
"In practice, however, that is not how you determine which superclasses and subclasses your application needs to have.",
Then it makes sense to have a common Vehicle superclass for the two classes.,"(""Vehicle"", ""superclass of"", ""classes"")"
"If you never process Car and Truck objects in the same way, there is no point in having a common superclass for them, except perhaps to share code between them (to avoid writing duplicate code).","(""Car"", ""has superclass"", ""common superclass""); (""Truck"", ""has superclass"", ""common superclass""); (""Car"", ""shares code with"", ""Truck"")"
Superclasses and subclasses form an inheritance structure which is also called a class hierarchy.,"(""Superclasses"", ""form"", ""inheritance structure""); (""Superclasses"", ""related to"", ""subclasses""); (""Subclasses"", ""form"", ""inheritance structure""); (""Inheritance structure"", ""also called"", ""class hierarchy""); (""Superclasses"", ""part of"", ""class hierarchy""); (""Subclasses"", ""part of"", ""class hierarchy"")"
At the top of the class hierarchy you have the superclasses.,"(""class hierarchy"", ""has"", ""superclasses""); (""superclasses"", ""is at top of"", ""class hierarchy"")"
At the bottom of the class hierarchy you have the subclasses.,"(""class hierarchy"", ""has"", ""subclasses"")"
"A class hierarchy may have multiple levels, meaning multiple levels of superclasses and subclasses.","(""class hierarchy"", ""has"", ""levels""); (""levels"", ""are"", ""superclasses""); (""levels"", ""are"", ""subclasses""); (""subclasses"", ""have"", ""superclasses""); (""superclasses"", ""have"", ""subclasses"")"
A subclass may itself be a superclass of other subclasses etc.,"(""subclass"", ""is a"", ""superclass""); (""subclass"", ""has"", ""subclasses"")"
"When a class inherits from a superclass, it inherits parts of the superclass methods and fields.","(""class"", ""inherits"", ""superclass""); (""class"", ""inherits"", ""superclass methods""); (""class"", ""inherits"", ""superclass fields""); (""superclass"", ""has"", ""methods""); (""superclass"", ""has"", ""fields""); (""class"", ""inherits from"", ""superclass"")"
"When a subclass extends a superclass in Java, all protected and public fields and methods of the superclass are inherited by the subclass.","(""Subclass"", ""extends"", ""Superclass""); (""Superclass"", ""has"", ""Fields""); (""Superclass"", ""has"", ""Methods""); (""Subclass"", ""inherits"", ""Fields""); (""Subclass"", ""inherits"", ""Methods"")"
"By inherited is meant that these fields and methods are part of of the subclass, as if the subclass had declared them itself.",
protected and public fields can be called and referenced just like the methods declared directly in the subclass.,"(""fields"", ""can be called"", ""methods""); (""fields"", ""can be referenced"", ""methods""); (""protected fields"", ""can be called"", ""subclass""); (""public fields"", ""can be referenced"", ""subclass""); (""methods"", ""are declared in"", ""subclass"")"
Fields and methods with default (package) access modifiers can be accessed by subclasses only if the subclass is located in the same package as the superclass.,"(""Subclass"", ""is located in"", ""Package""); (""Superclass"", ""is located in"", ""Package""); (""Fields"", ""have access modifier"", ""Default""); (""Methods"", ""have access modifier"", ""Default""); (""Subclass"", ""accesses"", ""Fields""); (""Subclass"", ""accesses"", ""Methods""); (""Superclass"", ""contains"", ""Fields""); (""Superclass"", ""contains"", ""Methods"")"
Private fields and methods of the superclass can never be referenced directly by subclasses.,"(""Subclasses"", ""reference"", ""Private fields""); (""Subclasses"", ""reference"", ""Private methods""); (""Superclass"", ""have"", ""Private fields""); (""Superclass"", ""have"", ""Private methods""); (""Subclasses"", ""inherit from"", ""Superclass"")"
"They can, however, be referenced indirectly via methods reachable from the subclass (e.g default (package), protected and public methods).","(""methods"", ""are reachable from"", ""subclass""); (""subclass"", ""has"", ""default methods""); (""subclass"", ""has"", ""protected methods""); (""subclass"", ""has"", ""public methods"")"
"Constructors are not inherited by subclasses, but a subclass constructor must call a constructor in the superclass.","(""subclass"", ""must call"", ""superclass constructor""); (""subclass constructor"", ""calls"", ""superclass constructor""); (""superclass"", ""has"", ""constructor""); (""subclass"", ""inherits from"", ""superclass"")"
The Java inheritance mechanism only allows a Java class to inherit from a single superclass (singular inheritance).,"(""Java"", ""has"", ""inheritance mechanism""); (""Java class"", ""inherits from"", ""superclass""); (""Java"", ""allows"", ""singular inheritance""); (""Java class"", ""can inherit from"", ""single superclass"")"
"In some programming languages, like C++, it is possible for a subclass to inherit from multiple superclasses (multiple inheritance).","(""Subclass"", ""inherit from"", ""Superclasses""); (""Subclass"", ""inherit from"", ""Multiple Superclasses""); (""C++"", ""support"", ""Multiple Inheritance""); (""Multiple Inheritance"", ""allowed in"", ""Subclass""); (""Subclass"", ""use"", ""Multiple Inheritance"")"
"the superclasses contain methods with the same names and parameters, multiple inheritance was left out in Java.","(""Java"", ""contains"", ""methods""); (""methods"", ""have"", ""parameters""); (""Java"", ""left out"", ""multiple inheritance""); (""superclasses"", ""contain"", ""methods"")"
You declare that one class extends another class by using the extends keyword in the class definition.,"(""class"", ""extends"", ""another class"")"
"The Car class in this example extends the Vehicle class, meaning the Car class inherits from the Vehicle class.","(""Car"", ""extends"", ""Vehicle""); (""Car"", ""inherits from"", ""Vehicle"")"
"Because the Car class extends the Vehicle class, the protected field licensePlate from the Vehicle class is inherited by the Car class.","(""Car"", ""extends"", ""Vehicle""); (""Vehicle"", ""has field"", ""licensePlate""); (""Car"", ""inherits"", ""licensePlate"")"
"The licensePlate field is not actually being referenced from the Car class in the code above, but it could if we wanted to.","(""Car"", ""has field"", ""licensePlate""); (""Car"", ""references"", ""licensePlate"")"
In many cases it would have made sense to place the getLicensePlate() method in the Vehicle class where the licensePlate field is located.,"(""Vehicle"", ""has method"", ""getLicensePlate()""); (""getLicensePlate()"", ""is located in"", ""Vehicle""); (""licensePlate"", ""is field of"", ""Vehicle"")"
I just placed the getLicensePlate() method in the Car class to show that it is possible.,"(""Car"", ""has method"", ""getLicensePlate()"")"
It is possible to reference a subclass as an instance of one of its superclasses.,"(""subclass"", ""is instance of"", ""superclass"")"
"For instance, using the class definitions from the example in the previous section it is possible to reference an instance of the Car class as an instance of the Vehicle class.","(""Car"", ""is instance of"", ""Vehicle""); (""Vehicle"", ""has subclass"", ""Car"")"
"Because the Car class extends (inherits from) the Vehicle class, it is also said to be a Vehicle.","(""Car"", ""extends"", ""Vehicle""); (""Car"", ""is a"", ""Vehicle"")"
Here is a Java code example: Car car = new Car(); Vehicle vehicle = car; First a Car instance is created.,"(""Car"", ""inherits"", ""Vehicle""); (""Car"", ""instantiated"", ""car""); (""Vehicle"", ""assigned"", ""car"")"
This is possible because the Car class inherits from the Vehicle class.,"(""Car"", ""inherits from"", ""Vehicle"")"
"As you can see, it is possible to use an instance of some subclass as if it were an instance of its superclass.","(""subclass"", ""is instance of"", ""superclass"")"
"That way, you don't need to know exactly what subclass the object is an instance of.",
The process of referencing an object of class as a different type than the class itself is called type casting.,"(""object"", ""is referenced by"", ""class""); (""class"", ""has property"", ""type""); (""type"", ""is used for"", ""type casting""); (""object"", ""undergoes"", ""type casting""); (""class"", ""is involved in"", ""type casting"")"
Upcasting and Downcasting You can always cast an object of a subclass to one of its superclasses.,"(""Object"", ""cast to"", ""Subclass""); (""Subclass"", ""is a"", ""Superclass""); (""Object"", ""is an instance of"", ""Subclass""); (""Subclass"", ""has a"", ""Superclass"")"
This is referred to as upcasting (from a subclass type to a superclass type).,"(""subclass"", ""referred to as"", ""upcasting""); (""subclass"", ""upcasted to"", ""superclass""); (""upcasting"", ""from"", ""subclass""); (""upcasting"", ""to"", ""superclass"")"
"It may also be possible to cast an object from a superclass type to a subclass type, but only if the object really is an instance of that subclass (or an instance of a subclass of that subclass).","(""superclass"", ""hasSubclass"", ""subclass""); (""object"", ""isInstanceof"", ""subclass""); (""subclass"", ""isSubclassOf"", ""superclass"")"
This is referred to as downcasting (from a superclass type to a subclass type).,
"Thus, this example of downcasting is valid: Car car = new Car(); // upcast to Vehicle Vehicle vehicle = car; // downcast to car again Car car2 = (Car) vehicle; However, the following downcast example is not valid.","(""Car"", ""inherits"", ""Vehicle""); (""Vehicle"", ""isDowncastTo"", ""Car""); (""Car"", ""isUpcastTo"", ""Vehicle"")"
"Truck truck = new Truck(); // upcast to Vehicle Vehicle vehicle = truck; // downcast to car again Car car = (Car) vehicle; The Truck object can be upcast to a Vehicle object, but it cannot be downcast to a Car object later.","(""Truck"", ""is_a"", ""Vehicle""); (""Vehicle"", ""has_instance"", ""Truck""); (""Truck"", ""cannot_be_downcast_to"", ""Car""); (""Car"", ""is_not_base_of"", ""Truck""); (""Vehicle"", ""has_subclass"", ""Truck""); (""Truck"", ""is_subclass_of"", ""Vehicle""); (""Car"", ""is_not_superclass_of"", ""Truck"")"
Overriding Methods In a subclass you can override (redefine) methods defined in the superclass.,"(""subclass"", ""overrides"", ""methods""); (""methods"", ""are defined in"", ""superclass""); (""subclass"", ""is a"", ""superclass"")"
Here is a Java method override example: public class Vehicle { String licensePlate = null; public void setLicensePlate(String licensePlate) { this.licensePlate = licensePlate; } } public class Car extends Vehicle { public void setLicensePlate(String license) { this.licensePlate = license.toLowerCase(); } } Notice how both the Vehicle class and the Car class defines a method called setLicensePlate().,"(""Vehicle"", ""extends"", ""Car""); (""Vehicle"", ""defines"", ""setLicensePlate()""); (""Car"", ""overrides"", ""Vehicle.setLicensePlate()""); (""Car"", ""defines"", ""setLicensePlate()""); (""Vehicle"", ""has method"", ""setLicensePlate()""); (""Car"", ""has method"", ""setLicensePlate()"")"
"Now, whenever the setLicensePlate() method is called on a Car object, it is the method defined in the Car class that is called.","(""Car"", ""has method"", ""setLicensePlate()""); (""Car"", ""defines"", ""setLicensePlate()""); (""setLicensePlate()"", ""is called on"", ""Car"")"
To override a method the method signature in the subclass must be the same as in the superclass.,"(""subclass"", ""overrides"", ""method""); (""subclass"", ""has"", ""method signature""); (""superclass"", ""has"", ""method signature""); (""subclass"", ""inherits from"", ""superclass""); (""method signature"", ""is the same as"", ""method signature""); (""subclass"", ""contains"", ""method""); (""superclass"", ""contains"", ""method"")"
"That means that the method definition in the subclass must have exactly the same name and the same number and type of parameters, and the parameters must be listed in the exact same sequence as in the superclass.","(""subclass"", ""has method"", ""method definition""); (""method definition"", ""is defined in"", ""subclass""); (""method definition"", ""is defined in"", ""superclass""); (""subclass"", ""inherits from"", ""superclass""); (""superclass"", ""has method"", ""method definition""); (""method definition"", ""has parameters"", ""parameters""); (""parameters"", ""are listed in"", ""sequence""); (""sequence"", ""is part of"", ""method definition""); (""superclass"", ""has parameters"", ""parameters""); (""subclass"", ""has parameters"", ""parameters"")"
Otherwise the method in the subclass will be considered a separate method.,"(""subclass"", ""has"", ""method""); (""method"", ""in"", ""subclass""); (""subclass"", ""will be considered"", ""separate method"")"
"If the superclass calls a private method internally from some other method, it will continue to call that method from the superclass, even if you create a private method in the subclass with the same signature.","(""Superclass"", ""calls"", ""PrivateMethod""); (""PrivateMethod"", ""is called by"", ""Superclass""); (""Subclass"", ""creates"", ""PrivateMethod""); (""PrivateMethod"", ""has same signature as"", ""PrivateMethod""); (""Superclass"", ""continues to call"", ""PrivateMethod"")"
"It would be nice if the compiler could tell you that the method being overridden no longer overrides a method in the superclass, right?","(""compiler"", ""tell"", ""method""); (""method"", ""being overridden"", ""superclass""); (""superclass"", ""has"", ""method"")"
"You can call superclass implementations from any method in a subclass, like above.","(""subclass"", ""calls"", ""superclass""); (""superclass"", ""has"", ""method""); (""subclass"", ""has"", ""method"")"
"For instance, you could also have called super.setLicensePlate() from a method in the Car class called updateLicensePlate() which does not override the setLicensePlate() method.","(""Car"", ""hasMethod"", ""updateLicensePlate()""); (""updateLicensePlate()"", ""calls"", ""setLicensePlate()""); (""Car"", ""hasMethod"", ""setLicensePlate()""); (""updateLicensePlate()"", ""doesNotOverride"", ""setLicensePlate()"")"
The instanceof instruction can determine whether a given object is an instance of some class.,
Here is a Java instanceof example: Car car = new Car(); boolean isCar = car instanceof Car; After this code has been executed the isCar variable will contain the value true.,"(""Car"", ""instanceof"", ""Car"")"
The instanceof instruction can also be used determine if an object is a instance of a superclass of its class.,
"Here is an instanceof example that checks if a Car object is an instance of Vehicle: Car car = new Car(); boolean isVehicle = car instanceof Vehicle; Assuming that the Car class extends (inherits from) the Vehicle class, the isVehicle variable will contain the value true after this code is executed.","(""Car"", ""extends"", ""Vehicle""); (""Car"", ""instanceof"", ""Vehicle"")"
A Car object is also a Vehicle object because Car is a subclass of Vehicle.,"(""Car"", ""is a subclass of"", ""Vehicle"")"
"Look at this instanceof example: Car car = new Car(); Vehicle vehicle = car; boolean isCar = vehicle instanceof Car; Even though the vehicle variable is of type Vehicle, the object it ends up pointing to in this example is a Car object.","(""Car"", ""instanceof"", ""Vehicle""); (""Vehicle"", ""hasType"", ""Car""); (""Car"", ""isAssignCompatibleWith"", ""Vehicle"")"
"Here is the same instanceof example, but using a Truck object instead of a Car object: Truck truck = new Truck(); Vehicle vehicle = truck; boolean isCar = vehicle instanceof Car; After executing this code the isCar will contain the value false.","(""Truck"", ""instanceof"", ""Car""); (""Vehicle"", ""="", ""Truck""); (""Truck"", ""instanceof"", ""Vehicle""); (""vehicle"", ""="", ""Truck""); (""isCar"", ""="", ""false""); (""Truck"", ""extends"", ""Vehicle""); (""vehicle"", ""="", ""truck"")"
"Fields and Inheritance As mentioned earlier, in Java fields cannot be overridden in a subclass.","(""Java"", ""has concept"", ""fields""); (""Java"", ""has concept"", ""inheritance""); (""fields"", ""cannot be"", ""overridden""); (""inheritance"", ""related to"", ""subclass""); (""subclass"", ""has characteristic"", ""cannot override fields""); (""fields"", ""belong to"", ""Java""); (""inheritance"", ""belong to"", ""Java""); (""Java"", ""allows"", ""subclass"")"
"If you define a field in a subclass with the same name as a field in the superclass, the field in the subclass will hide (shadow) the field in the superclass.","(""subclass"", ""hides"", ""superclass""); (""subclass"", ""defines"", ""field""); (""superclass"", ""defines"", ""field""); (""subclass"", ""has"", ""field""); (""superclass"", ""has"", ""field"")"
"If the subclass tries to access the field, it will access the field in the subclass.","(""subclass"", ""tries to access"", ""field""); (""subclass"", ""access"", ""field""); (""field"", ""in"", ""subclass"")"
"If, however, the subclass calls up into a method in the superclass, and that method accesses the field with the same name as in the subclass, it is the field in the superclass that is accessed.","(""subclass"", ""calls"", ""superclass""); (""subclass"", ""has"", ""field""); (""superclass"", ""has"", ""field""); (""superclass"", ""accesses"", ""field""); (""method"", ""accesses"", ""field""); (""subclass"", ""inherits"", ""superclass"")"
Both the Vehicle class and Car class has the methods setLicensePlate() and getLicensePlate().,"(""Vehicle"", ""has method"", ""setLicensePlate()""); (""Vehicle"", ""has method"", ""getLicensePlate()""); (""Car"", ""has method"", ""setLicensePlate()""); (""Car"", ""has method"", ""getLicensePlate()"")"
The methods in the Car class calls the corresponding methods in the Vehicle class.,"(""Car"", ""calls"", ""Vehicle""); (""Car.class"", ""hasMethod"", ""Car.method()""); (""Vehicle.class"", ""hasMethod"", ""Vehicle.method()""); (""Car.method()"", ""calls"", ""Vehicle.method()"")"
"The result is, that eventually both set of methods access the licensePlate field in the Vehicle class.","(""Vehicle"", ""has field"", ""licensePlate""); (""methods"", ""access"", ""licensePlate""); (""methods"", ""access"", ""Vehicle""); (""Vehicle"", ""has methods"", ""methods"")"
"The updateLicensePlate() method in the Car class however, accesses the licensePlate field directly.","(""Car"", ""hasMethod"", ""updateLicensePlate()""); (""updateLicensePlate()"", ""accesses"", ""licensePlate""); (""Car"", ""hasField"", ""licensePlate"")"
"Therefore, you will not get the same result if you call setLicensePlate() as when you call the updateLicense() method.","(""setLicensePlate()"", ""called as alternative to"", ""updateLicense()""); (""updateLicense()"", ""compared to"", ""setLicensePlate()"")"
"Look at the following lines of Java code: Car car = new Car(); car.setLicensePlate(""123""); car.updateLicensePlate(""abc""); System.out.println(""license plate: "" + car.getLicensePlate()); This Java code will print out the text 123.","(""Car"", ""has method"", ""Car()""); (""Car"", ""has method"", ""setLicensePlate()""); (""Car"", ""has method"", ""updateLicensePlate()""); (""Car"", ""has method"", ""getLicensePlate()""); (""car"", ""calls method"", ""setLicensePlate()""); (""car"", ""calls method"", ""updateLicensePlate()""); (""car"", ""calls method"", ""getLicensePlate()""); (""System"", ""has method"", ""println()""); (""car"", ""has attribute"", ""license plate"")"
The updateLicensePlate() method sets the license plate value on the licensePlate field in the Car class.,"(""Car"", ""has method"", ""updateLicensePlate()""); (""updateLicensePlate()"", ""updates"", ""licensePlate""); (""Car"", ""has field"", ""licensePlate"")"
"The getLicensePlate() method, however, returns the value of the licensePlate field in the Vehicle class.","(""Vehicle"", ""hasMethod"", ""getLicensePlate()""); (""getLicensePlate()"", ""returns"", ""licensePlate""); (""Vehicle"", ""hasField"", ""licensePlate"")"
"Therefore, the value 123 which is set as value for the licensePlate field in the Vehicle class via the setLicensePlate() method, is what is printed out.","(""Vehicle"", ""has field"", ""licensePlate""); (""Vehicle"", ""has method"", ""setLicensePlate()""); (""setLicensePlate()"", ""sets field"", ""licensePlate"")"
"In other words, constructors of a superclass are not inherited by subclasses.","(""Superclass"", ""has"", ""Constructors""); (""Subclasses"", ""inherit"", ""nothing""); (""Superclass"", ""has"", ""Subclasses"")"
Subclasses can still call the constructors in the superclass using the super() contruct.,"(""Subclasses"", ""can call"", ""constructors""); (""Subclasses"", ""use"", ""super()""); (""super()"", ""is used in"", ""subclasses""); (""constructors"", ""are in"", ""superclass""); (""Subclasses"", ""inherit from"", ""superclass"")"
"In fact, a subclass constructor is required to call one of the constructors in the superclass as the very first action inside the constructor body.","(""subclass"", ""required to call"", ""superclass constructor""); (""constructor"", ""calls"", ""superclass constructor""); (""superclass"", ""has"", ""constructor""); (""subclass constructor"", ""calls"", ""superclass"")"
Here is how that looks: public class Vehicle { public Vehicle() { } } public class Car extends Vehicle{ public Car() { super(); //perform other initialization here } } Notice the call to super() inside the Car constructor.,"(""Car"", ""extends"", ""Vehicle""); (""Car"", ""calls"", ""Vehicle()""); (""Vehicle"", ""has"", ""Vehicle()""); (""Car"", ""has"", ""Car()"")"
You may have seen Java classes where the subclass constructors did not seem to call the constructors in the superclass.,"(""Java classes"", ""have"", ""subclass constructors""); (""subclass constructors"", ""did not call"", ""superclass constructors""); (""superclass"", ""have"", ""constructors"")"
"However, the subclass constructors have still called superclass constructors in those case.",
"Let me explain why: If a class does not have any explicit constructor defined, the Java compiler inserts an implicit no-arg constructor.","(""Java compiler"", ""inserts"", ""implicit no-arg constructor""); (""class"", ""has"", ""explicit constructor""); (""Java compiler"", ""defines"", ""implicit no-arg constructor""); (""class"", ""does not have"", ""explicit constructor"")"
"Therefore the following version of Vehicle is equivalent to the version shown just above: public class Vehicle { } Second, if a constructor does not explicitly call a constructor in the superclass, the Java compiler inserts an implicit call to the no-arg constructor in the superclass.","(""Vehicle"", ""is a"", ""class""); (""Vehicle"", ""has a"", ""constructor""); (""constructor"", ""is implicitly called by"", ""Java compiler""); (""Java compiler"", ""inserts a call to"", ""no-arg constructor""); (""no-arg constructor"", ""is in"", ""superclass""); (""Vehicle"", ""has a"", ""superclass"")"
"That means that the following version of the Car class is actually equivalent to the version shown earlier: public class Car extends Vehicle{ public Car() { } } In fact, since the constructor is now empty, we could leave it out and the Java compiler would insert it, and insert an implicit call to the no-arg constructor in the superclass.","(""Car"", ""extends"", ""Vehicle""); (""Car"", ""has constructor"", ""Car()""); (""Vehicle"", ""has constructor"", ""Vehicle()""); (""Car"", ""has superclass"", ""Vehicle""); (""Java compiler"", ""inserts"", ""Car()""); (""Java compiler"", ""inserts call to"", ""Vehicle()"")"
"This is how the two classes would look then: public class Vehicle { } public class Car extends Vehicle{ } Even though no constructors are declared in these two classes, they both get a no-arg constructor, and the no-arg constructor in the Car class will call the no-arg constructor in the Vehicle class.","(""Car"", ""extends"", ""Vehicle""); (""Car"", ""has constructor"", ""no-arg constructor""); (""Vehicle"", ""has constructor"", ""no-arg constructor""); (""Car"", ""calls constructor"", ""Vehicle"")"
"If the Vehicle class did not have a no-arg constructor, but had another constructor which takes parameters, the Java compiler would complain.","(""Vehicle"", ""has"", ""no-arg constructor""); (""Vehicle"", ""has"", ""constructor""); (""Java compiler"", ""complains about"", ""Vehicle""); (""Vehicle"", ""has"", ""constructor which takes parameters"")"
"The Car class would then be required to declare a constructor, and inside that constructor call the constructor in the Vehicle class.","(""Car"", ""declares"", ""constructor""); (""Car"", ""calls"", ""Vehicle.constructor()""); (""Vehicle"", ""has"", ""constructor()""); (""Car"", ""inherits from"", ""Vehicle"")"
Nested Classes and Inheritance The same Java inheritance rules apply to nested classes.,"(""Java"", ""has"", ""inheritance rules""); (""Java inheritance rules"", ""apply to"", ""nested classes""); (""nested classes"", ""follow"", ""Java inheritance rules"")"
Nested classes with the default (package) access modifier are only accessible to subclasses if the subclass is located in the same package as the superclass.,"(""Subclass"", ""is located in"", ""Same package""); (""Superclass"", ""has access modifier"", ""Default access modifier""); (""Subclass"", ""accesses"", ""Nested classes""); (""Nested classes"", ""have access modifier"", ""Default access modifier""); (""Superclass"", ""is in"", ""Same package""); (""Subclass"", ""is in"", ""Same package"")"
Nested classes with the protected or public access modifier are always inherited by subclasses.,"(""subclasses"", ""inherit"", ""Nested classes""); (""Nested classes"", ""have"", ""protected access modifier""); (""Nested classes"", ""have"", ""public access modifier""); (""Nested classes"", ""are inherited by"", ""subclasses"")"
Here is a nested class inheritance example: class MyClass { class MyNestedClass { } } public class MySubclass extends MyClass { public static void main(String[] args) { MySubclass subclass = new MySubclass(); MyNestedClass nested = subclass.new MyNestedClass(); } } Notice how it is possible to create an instance of the nested class MyNestedClass which is defined in the superclass (MyClass) via a reference to the subclass (MySubclass).,"(""MyClass"", ""contains"", ""MyNestedClass""); (""MySubclass"", ""extends"", ""MyClass""); (""MySubclass"", ""instantiates"", ""MyNestedClass""); (""MyClass"", ""defines"", ""MyNestedClass"")"
Here is now that looks: public final class MyClass { } A final class cannot be extended.,"(""MyClass"", ""cannot be extended by"", ""any class""); (""MyClass"", ""is"", ""class""); (""any class"", ""cannot extend"", ""MyClass"")"
"In other words, you cannot inherit from a final class in Java.","(""Java"", ""has restriction on"", ""final class""); (""final class"", ""cannot be inherited by"", ""subclass"")"
Abstract Classes and Inheritance In Java a class can be declared abstract.,"(""Java"", ""has concept"", ""Abstract Classes""); (""Abstract Classes"", ""related to"", ""Inheritance""); (""Class"", ""can be declared"", ""Abstract""); (""Java"", ""supports"", ""Inheritance"")"
I have explained abstract classes in more detail in my Java abstract classes tutorial.,"(""Java"", ""has"", ""abstract classes""); (""abstract classes"", ""are explained in"", ""Java abstract classes tutorial"")"
An abstract class is a class that does not contain the full implementation of whatever the abstract class should do.,"(""abstract class"", ""is a"", ""class"")"
"In other words, you cannot create objects of an abstract class.","(""Abstract Class"", ""cannot create objects of"", ""Objects"")"
In Java abstract classes are intended to be extended to create a full implementation.,"(""Java"", ""has"", ""abstract classes""); (""abstract classes"", ""are extended by"", ""full implementation""); (""full implementation"", ""extends"", ""abstract classes"")"
The Java inheritance rules are the same for abstract classes as for non-abstract classes.,"(""Java"", ""has"", ""inheritance rules""); (""abstract classes"", ""follow"", ""Java inheritance rules""); (""non-abstract classes"", ""follow"", ""Java inheritance rules"")"
You can always cast an object of a subclass to one of its superclasses.,"(""Object"", ""cast to"", ""Subclass""); (""Subclass"", ""is a"", ""Superclass""); (""Object"", ""is an instance of"", ""Subclass""); (""Subclass"", ""is a subclass of"", ""Superclass"")"
In a subclass you can override (redefine) methods defined in the superclass.,"(""subclass"", ""override"", ""methods""); (""subclass"", ""inherit from"", ""superclass""); (""methods"", ""defined in"", ""superclass""); (""subclass"", ""redefine"", ""methods"")"
Notice how both the Vehicle class and the Car class defines a method called setLicensePlate().,"(""Vehicle"", ""defines"", ""setLicensePlate()""); (""Car"", ""defines"", ""setLicensePlate()""); (""Vehicle"", ""has method"", ""setLicensePlate()""); (""Car"", ""has method"", ""setLicensePlate()"")"
"If you override a method in a subclass, and the method is all of a sudden removed or renamed or have its signature changed in the superclass, the method in the subclass no longer overrides the method in the superclass.","(""subclass"", ""overrides"", ""method""); (""subclass"", ""contains"", ""method""); (""superclass"", ""contains"", ""method""); (""subclass"", ""inherits from"", ""superclass""); (""method"", ""is removed from"", ""superclass""); (""method"", ""is renamed in"", ""superclass""); (""method"", ""has signature changed in"", ""superclass"")"
"If you override a method in a subclass, but still need to call the method defined in the superclass, you can do so using the super reference, like this:","(""subclass"", ""overrides"", ""method""); (""super"", ""references"", ""superclass""); (""method"", ""is defined in"", ""superclass""); (""subclass"", ""uses"", ""super reference"")"
"In the above code example the method setLicensePlate() in the Car class, calls the setLicensePlate() method in the Vehicle class.","(""Car"", ""calls"", ""Vehicle""); (""Car.setLicensePlate()"", ""calls"", ""Vehicle.setLicensePlate()"")"
"Assuming that the Car class extends (inherits from) the Vehicle class, the isVehicle variable will contain the value true after this code is executed.","(""Car"", ""extends"", ""Vehicle""); (""Car"", ""inherits from"", ""Vehicle"")"
"As mentioned earlier, in Java fields cannot be overridden in a subclass.","(""Java"", ""has concept"", ""fields""); (""fields"", ""cannot be"", ""overridden""); (""overridden"", ""related to"", ""subclass""); (""Java"", ""allows"", ""subclass""); (""fields"", ""belong to"", ""class""); (""subclass"", ""is a"", ""class"")"
Here is Java inheritance example that illustrates how fields in subclasses shadow (hides) fields in superclasses:,
"If a class does not have any explicit constructor defined, the Java compiler inserts an implicit no-arg constructor.","(""Java compiler"", ""inserts"", ""implicit no-arg constructor""); (""Class"", ""does not have"", ""explicit constructor""); (""Class"", ""has"", ""implicit no-arg constructor""); (""Java compiler"", ""inserts"", ""constructor""); (""Class"", ""has"", ""constructor"")"
"Second, if a constructor does not explicitly call a constructor in the superclass, the Java compiler inserts an implicit call to the no-arg constructor in the superclass.","(""constructor"", ""calls"", ""superclass""); (""Java compiler"", ""inserts"", ""implicit call""); (""constructor"", ""is in"", ""superclass""); (""implicit call"", ""is to"", ""no-arg constructor""); (""no-arg constructor"", ""is in"", ""superclass"")"
That means that the following version of the Car class is actually equivalent to the version shown earlier:,"(""Car"", ""is equivalent to"", ""Car"")"
"In fact, since the constructor is now empty, we could leave it out and the Java compiler would insert it, and insert an implicit call to the no-arg constructor in the superclass.","(""Java compiler"", ""would insert"", ""constructor""); (""constructor"", ""is in"", ""superclass""); (""superclass"", ""has"", ""no-arg constructor""); (""Java compiler"", ""would insert"", ""no-arg constructor"")"
"Even though no constructors are declared in these two classes, they both get a no-arg constructor, and the no-arg constructor in the Car class will call the no-arg constructor in the Vehicle class.","(""Car"", ""has constructor"", ""no-arg constructor""); (""Vehicle"", ""has constructor"", ""no-arg constructor""); (""Car"", ""inherits from"", ""Vehicle"")"
Notice how it is possible to create an instance of the nested class MyNestedClass which is defined in the superclass (MyClass) via a reference to the subclass (MySubclass).,"(""MyClass"", ""hasNestedClass"", ""MyNestedClass""); (""MySubclass"", ""inheritsFrom"", ""MyClass""); (""MySubclass"", ""hasAccessTo"", ""MyNestedClass""); (""MyClass"", ""isSuperclassOf"", ""MySubclass"")"
"The Java instanceof operator can determine if a given Java object is an instance of a given class, superclass or interface.",
The Java instanceof operator is also referred to as a type comparison operator because it compares the type of a given instance (object) with a specific type (class or interface).,"(""Java"", ""has operator"", ""instanceof""); (""instanceof"", ""compares"", ""type""); (""instanceof"", ""compares"", ""class""); (""instanceof"", ""compares"", ""interface""); (""object"", ""has"", ""type""); (""class"", ""is"", ""type""); (""interface"", ""is"", ""type"")"
"The expression map instanceof Object will evaluate to true if the map variable references an object that is an instance of class Object, or any subclass of class Object.","(""map"", ""references"", ""Object""); (""Object"", ""has subclass"", ""subclass of Object""); (""map"", ""is instance of"", ""Object""); (""map"", ""is instance of"", ""subclass of Object"")"
"Since all classes in Java inherit from Object, this expression will evaluate to true.","(""Object"", ""inheritedBy"", ""all classes in Java"")"
"As mentioned earlier, the Java instanceof operator will evaluate to true if you compare an object to the exact class of that object.","(""Java"", ""has operator"", ""instanceof""); (""instanceof"", ""evaluates"", ""object""); (""object"", ""has class"", ""class""); (""instanceof"", ""compares"", ""object""); (""object"", ""is compared to"", ""class"")"
Here is a Java instanceof example showing a comparison of an object to its exact class:,"(""Java"", ""has operator"", ""instanceof""); (""object"", ""compared to"", ""class""); (""instanceof"", ""used for"", ""comparison"")"
"As also mentioned earlier, the Java instanceof operator also evaluates to true when comparing an object against a superclass of the type of that object.","(""Java"", ""has operator"", ""instanceof""); (""instanceof"", ""evaluates"", ""true""); (""object"", ""is compared to"", ""superclass""); (""superclass"", ""is type of"", ""object""); (""object"", ""has type"", ""type"")"
"Since HashMap is a subclass of Object - even if not a direct subclass, the expression map instanceof Object evaluates to true.","(""HashMap"", ""is a subclass of"", ""Object""); (""HashMap"", ""evaluates to true with"", ""instanceof Object""); (""Object"", ""has subclass"", ""HashMap"")"
"Note, that it does not matter how high up in the inheritance hierarchy the compared type is superclass of the type of the object.","(""type"", ""is superclass of"", ""object""); (""compared type"", ""is superclass of"", ""type""); (""superclass"", ""is in"", ""inheritance hierarchy""); (""type"", ""is in"", ""inheritance hierarchy""); (""object"", ""is of"", ""type"")"
"As long as the type compared to is a superclass somewhere up the inheritance hierarchy, instanceof will evaluate to true.",
The Java instanceof operator also works when comparing an object against an interface instead of a class.,
"Notice, that even if the map variable is of type HashMap, the instanceof operator returns true for the expression map instanceof Map because the HashMap class implements the Map interface.","(""HashMap"", ""implements"", ""Map""); (""HashMap"", ""instanceof"", ""Map""); (""Map"", ""is implemented by"", ""HashMap"")"
"The Java instanceof operator also evaluates to true when comparing an object against a superinterface which the class of the object, or a superclass of the object implements.","(""Java"", ""has operator"", ""instanceof operator""); (""instanceof operator"", ""evaluates"", ""true""); (""object"", ""has class"", ""class of the object""); (""class of the object"", ""implements"", ""superinterface""); (""superinterface"", ""is implemented by"", ""superclass of the object""); (""object"", ""has superclass"", ""superclass of the object""); (""superclass of the object"", ""implements"", ""superinterface"")"
"The TreeMap class implements SortedMap, and thus also indirectly the Map interface.","(""TreeMap"", ""implements"", ""SortedMap""); (""TreeMap"", ""implements"", ""Map"")"
The Java instanceof operator always evaluates to false when a null variable is compared against any class or interface.,"(""Java"", ""has operator"", ""instanceof""); (""instanceof"", ""evaluates against"", ""class""); (""instanceof"", ""evaluates against"", ""interface""); (""null"", ""compared using"", ""instanceof""); (""variable"", ""compared against"", ""class""); (""variable"", ""compared against"", ""interface"")"
Here is a Java instanceof example illustrating the comparison of null against a class:,"(""Java"", ""has operator"", ""instanceof""); (""instanceof"", ""compares"", ""null""); (""null"", ""compared to"", ""class""); (""Java"", ""uses operator"", ""instanceof""); (""class"", ""is compared to"", ""null"")"
"That is because it is not the reference type that is compared against the target class or interface, but the actual type of the referenced object.",
"Since a Java String object can never be an instance of the Java Integer class, the Java compiler will catch this an give you an error.","(""Java String"", ""is not an instance of"", ""Java Integer""); (""Java compiler"", ""catches"", ""error""); (""Java String object"", ""cannot be"", ""Java Integer class""); (""Java compiler"", ""gives"", ""error""); (""Java String"", ""is not"", ""Java Integer"")"
That means that the actual class of the referenced object could be pretty much any class (since all classes are subclasses of Object).,"(""Object"", ""is superclass of"", ""all classes""); (""all classes"", ""are subclasses of"", ""Object"")"
"In short, we can avoid the explicit downcast of an object when comparing it against a subclass.",
Notice the str variable after the String class name in the instanceof expression inside the if-statement.,
"Since the right hand side of the expression is only evaluated if the left hand side evaluates to true, this cannot result in startsWith() being called on a non-String object.","(""String"", ""hasMethod"", ""startsWith()"")"
"A question I get a lot is what the difference is between Java interfaces and abstract classes, and when to use each.","(""Java"", ""has"", ""interfaces""); (""Java"", ""has"", ""abstract classes""); (""interfaces"", ""differ from"", ""abstract classes"")"
"Having answered this question by email multiple times, I decided to write this tutorial about Java interfaces vs abstract classes.","(""Java"", ""has"", ""interfaces""); (""Java"", ""has"", ""abstract classes"")"
"In other words, to make the classes using the interface independent of the classes implementing the interface.","(""classes"", ""using"", ""interface""); (""classes"", ""independent of"", ""classes""); (""interface"", ""implemented by"", ""classes"")"
"Thus, you can exchange the implementation of the interface, without having to change the class using the interface.","(""interface"", ""is used by"", ""class"")"
Abstract classes are typically used as base classes for extension by subclasses.,"(""Abstract class"", ""is used as"", ""base class""); (""base class"", ""is extended by"", ""subclass""); (""subclass"", ""extends"", ""abstract class"")"
"Some programming languages use abstract classes to achieve polymorphism, and to separate interface from implementation, but in Java you use interfaces for that.","(""Java"", ""uses"", ""interfaces""); (""interfaces"", ""separate"", ""implementation""); (""abstract classes"", ""achieve"", ""polymorphism""); (""Java"", ""uses"", ""abstract classes""); (""interfaces"", ""separate"", ""interface""); (""polymorphism"", ""achieved by"", ""abstract classes""); (""interfaces"", ""used in"", ""Java"")"
"Remember, a Java class can only have 1 superclass, but it can implement multiple interfaces.","(""Java class"", ""can have"", ""superclass""); (""Java class"", ""can implement"", ""interfaces""); (""superclass"", ""is implemented by"", ""Java class""); (""interfaces"", ""are implemented by"", ""Java class"")"
"Thus, if a class already has a different superclass, it can implement an interface, but it cannot extend another abstract class.","(""class"", ""has"", ""superclass""); (""class"", ""implement"", ""interface""); (""class"", ""extend"", ""abstract class""); (""interface"", ""implemented by"", ""class""); (""abstract class"", ""extended by"", ""class"")"
"If you also need to provide a base class or default implementation of the interface, add an abstract class (or normal class) that implements the interface.","(""interface"", ""implemented by"", ""abstract class""); (""interface"", ""implemented by"", ""normal class""); (""abstract class"", ""implements"", ""interface""); (""normal class"", ""implements"", ""interface"")"
"Here is an example showing a class referencing an interface, an abstract class implementing that interface, and a subclass extending the abstract class.","(""class"", ""referencing"", ""interface""); (""abstract class"", ""implementing"", ""interface""); (""abstract class"", ""extended by"", ""subclass""); (""subclass"", ""extends"", ""abstract class"")"
"Below are the code examples from the text on Java Abstract Classes, but with an interface added which is implemented by the abstract base class.","(""Java"", ""has"", ""Abstract Classes""); (""Abstract Classes"", ""implements"", ""interface""); (""interface"", ""implemented by"", ""abstract base class""); (""abstract base class"", ""extends"", ""Java"")"
"Fourth, how to use the interface URLProcessor as variable type, even though it is the subclass UrlProcessorImpl that is instantiated.","(""URLProcessor"", ""is superclass of"", ""UrlProcessorImpl""); (""UrlProcessorImpl"", ""is subclass of"", ""URLProcessor"")"
Using both an interface and an abstract base class makes your code more flexible.,"(""interface"", ""used with"", ""abstract base class""); (""abstract base class"", ""makes"", ""code""); (""code"", ""more flexible"", ""flexibility"")"
It possible to implement simple URL processors simply by subclassing the abstract base class.,"(""abstract base class"", ""subclassed by"", ""URL processors"")"
"A Java interface is a bit like a Java class, except a Java interface can only contain method signatures and fields.","(""Java interface"", ""can only contain"", ""method signatures""); (""Java interface"", ""can only contain"", ""fields""); (""Java interface"", ""is similar to"", ""Java class""); (""Java class"", ""can contain"", ""method signatures""); (""Java class"", ""can contain"", ""fields"")"
"However, it is possible to provide default implememntations of a method in a Java interface, to make the implementation of the interface easier for classes implementing the interface.","(""Java interface"", ""has"", ""method""); (""Java interface"", ""is implemented by"", ""classes""); (""method"", ""is part of"", ""Java interface""); (""classes"", ""implement"", ""Java interface"")"
"Just like with classes, a Java interface can be declared public or package scope (no access modifier).","(""Java interface"", ""can be declared"", ""public""); (""Java interface"", ""can be declared"", ""package scope"")"
"As you can see, accessing a variable from an interface is very similar to accessing a static variable in a class.","(""interface"", ""has"", ""variable""); (""variable"", ""is accessed from"", ""interface""); (""class"", ""has"", ""static variable""); (""static variable"", ""is accessed from"", ""class"")"
"The method, however, needs to be implemented by some class before you can access it.","(""method"", ""needs to be implemented by"", ""class""); (""class"", ""implements"", ""method""); (""method"", ""is accessed by"", ""class"")"
"Before you can really use an interface, you must implement that interface in some Java class.","(""interface"", ""implemented in"", ""Java class"")"
Here is a class that implements the MyInterface interface shown above:,"(""class"", ""implements"", ""MyInterface"")"
This signals to the Java compiler that the MyInterfaceImpl class implements the MyInterface interface.,"(""MyInterfaceImpl"", ""implements"", ""MyInterface"")"
A class that implements an interface must implement all the methods declared in the interface.,"(""class"", ""implements"", ""interface""); (""interface"", ""declares"", ""methods""); (""class"", ""implements"", ""methods""); (""interface"", ""has"", ""methods""); (""class"", ""must implement"", ""methods"")"
The class does not need to implement (declare) the variables of an interface.,"(""class"", ""implements"", ""interface""); (""interface"", ""has"", ""variables""); (""class"", ""declares"", ""variables"")"
Once a Java class implements an Java interface you can use an instance of that class as an instance of that interface.,"(""Java class"", ""implements"", ""Java interface""); (""Java class"", ""instance of"", ""Java interface"")"
Java allows this because the class MyInterfaceImpl implements the MyInterface interface.,"(""MyInterfaceImpl"", ""implements"", ""MyInterface"")"
You can then reference instances of the MyInterfaceImpl class as instances of the MyInterface interface.,"(""MyInterfaceImpl"", ""implements"", ""MyInterface"")"
"You must always create an instance of some class that implements the interface, and reference that instance as an instance of the interface.","(""class"", ""implements"", ""interface""); (""instance"", ""is a"", ""class""); (""instance"", ""referenced as"", ""interface"")"
In that case the class must implement all the methods declared in all the interfaces implemented.,"(""class"", ""implements"", ""interface""); (""class"", ""must implement"", ""methods""); (""interface"", ""declares"", ""methods""); (""class"", ""implements"", ""methods"")"
"If the interfaces are not located in the same packages as the implementing class, you will also need to import the interfaces.","(""interfaces"", ""are located in"", ""packages""); (""interfaces"", ""are imported by"", ""class""); (""class"", ""implements"", ""interfaces""); (""interfaces"", ""are part of"", ""packages"")"
Java interfaces are imported using the import instruction just like Java classes.,"(""Java interfaces"", ""are imported using"", ""import instruction""); (""Java interfaces"", ""are imported like"", ""Java classes""); (""import instruction"", ""is used for"", ""Java interfaces""); (""import instruction"", ""is used for"", ""Java classes"")"
Here are the two Java interfaces implemented by the class above:,
"If a Java class implements multiple Java interfaces, there is a risk that some of these interfaces may contain methods with the same signature (name + parameters).","(""Java class"", ""implements"", ""Java interfaces""); (""Java interfaces"", ""contain"", ""methods""); (""methods"", ""have"", ""signature"")"
"Since a Java class can only implement at method with a given signature once, this could potentially lead to some problems.","(""Java class"", ""can implement"", ""method""); (""Java class"", ""has"", ""method""); (""method"", ""has"", ""signature"")"
"Especially if those constants are to be used by the classes implementing the interface, e.g.",
It is up to the classes implementing the interface to specify an implementation.,"(""classes"", ""implementing"", ""interface""); (""interface"", ""implemented by"", ""classes"")"
"If the API just adds the method to the desired interface, all classes that implements the interface must implement that new method.","(""API"", ""adds"", ""method""); (""method"", ""to"", ""interface""); (""interface"", ""implemented by"", ""classes""); (""classes"", ""must implement"", ""method"")"
That is fine if all implementing classes are located within the API.,"(""API"", ""has"", ""implementing classes""); (""implementing classes"", ""are located within"", ""API"")"
"But if some implementing classes are located in client code of the API (the code that uses the API), then that code breaks.","(""API"", ""is used by"", ""client code""); (""client code"", ""uses"", ""API""); (""implementing classes"", ""are located in"", ""client code""); (""API"", ""has"", ""implementing classes"")"
Look at this interface and imagine that it is part of e.g.,"(""e.g."", ""part of"", ""interface"")"
"If the developer of the API wants to add one more method to the ResourceLoader interface, then the FileLoader class will be broken when that project upgrades to the new version of the API.","(""ResourceLoader"", ""has method"", ""new method""); (""ResourceLoader"", ""interface of"", ""FileLoader""); (""FileLoader"", ""implements"", ""ResourceLoader""); (""FileLoader"", ""broken by"", ""new method""); (""API"", ""has interface"", ""ResourceLoader""); (""API"", ""has class"", ""FileLoader"")"
"A class can override the implementation of a default method simply by implementing that method explicitly, as is done normally when implementing a Java interface.","(""class"", ""overrides"", ""default method""); (""class"", ""implements"", ""method""); (""Java interface"", ""has"", ""default method""); (""class"", ""implements"", ""Java interface"")"
Any implementation in a class takes precedence over interface default method implementations.,"(""class"", ""has"", ""implementation""); (""interface"", ""has"", ""default method implementations""); (""class"", ""takes precedence over"", ""interface default method implementations"")"
Calling a static method in an interface looks and works just like calling a static method in a class.,"(""Interface"", ""has"", ""static method""); (""Class"", ""has"", ""static method""); (""static method"", ""called from"", ""Interface""); (""static method"", ""called from"", ""Class"")"
Here is an example of calling the static print() method from the above MyInterface interface:,"(""MyInterface"", ""has method"", ""print()"")"
"It is possible for a Java interface to inherit from another Java interface, just like classes can inherit from other classes.","(""Java interface"", ""inherit from"", ""another Java interface""); (""classes"", ""inherit from"", ""other classes"")"
"That then means, that if a class implements MySubInterface, that class has to implement all methods defined in both MySubInterface and MySuperInterface.","(""MySubInterface"", ""implements"", ""MySuperInterface""); (""MySubInterface"", ""has"", ""methods""); (""MySuperInterface"", ""has"", ""methods""); (""Class"", ""implements"", ""MySubInterface""); (""Class"", ""implements"", ""MySuperInterface"")"
A class implementing an interface which inherits from multiple interfaces must implement all methods from the interface and its superinterfaces.,"(""class"", ""implements"", ""interface""); (""class"", ""inherits"", ""superinterfaces""); (""class"", ""must implement"", ""methods""); (""interface"", ""has"", ""methods""); (""superinterfaces"", ""has"", ""methods""); (""class"", ""implements"", ""superinterfaces"")"
"While it is normally possible for a class to implement multiple interfaces even if the interfaces contain methods with the same signature, this is not possible if one or more of these methods are default methods.","(""class"", ""implements"", ""interface""); (""interface"", ""contains"", ""method""); (""class"", ""implements"", ""multiple interfaces""); (""interface"", ""contains"", ""default method""); (""method"", ""has"", ""signature""); (""default method"", ""is part of"", ""interface"")"
"In other words, if two interfaces contain the same method signature (name + parameters) and one of the interfaces declare this method as a default method, a class cannot automatically implement both interfaces.","(""Interface"", ""contains"", ""Method""); (""Method"", ""has"", ""Signature""); (""Signature"", ""consists of"", ""Name""); (""Signature"", ""consists of"", ""Parameters""); (""Interface"", ""declares"", ""DefaultMethod""); (""Class"", ""implements"", ""Interface""); (""Interface"", ""has"", ""DefaultMethod""); (""Class"", ""cannot implement"", ""MultipleInterfaces"")"
In both of the above situations the Java compiler requires that the class implementing the interface(s) explicitly implements the method which causes the problem.,"(""Java compiler"", ""requires"", ""class""); (""class"", ""implements"", ""interface""); (""class"", ""implements"", ""method""); (""interface"", ""has"", ""method""); (""class"", ""explicitly implements"", ""method""); (""Java compiler"", ""requires"", ""explicit implementation""); (""class"", ""implements"", ""interface(s)"")"
That way there is no doubt about which implementation the class will have.,
The implementation in the class takes precedence over any default implementations.,"(""implementation"", ""takes precedence over"", ""default implementations""); (""class"", ""has"", ""implementation"")"
"Basically, polymorphism means that an instance of an class (an object) can be used as if it were of different types.",
"The classes above are all parts of a model representing different types of vehicles and drivers, with fields and methods.","(""vehicles"", ""has"", ""fields""); (""vehicles"", ""has"", ""methods""); (""drivers"", ""has"", ""fields""); (""drivers"", ""has"", ""methods""); (""vehicles"", ""isPartOf"", ""model""); (""drivers"", ""isPartOf"", ""model"")"
That is the responsibility of these classes - to model these entities from real life.,"(""classes"", ""model"", ""entities""); (""classes"", ""have"", ""responsibility""); (""responsibility"", ""of"", ""classes""); (""classes"", ""model"", ""real life""); (""entities"", ""from"", ""real life""); (""classes"", ""model"", ""entities"")"
"Please forget for a while, that implementing this functionality as methods directly on the objects may lead to a messy class hierarchy.","(""Functionality"", ""implemented as"", ""methods""); (""methods"", ""on the objects"", ""objects""); (""objects"", ""may lead to"", ""class hierarchy""); (""class hierarchy"", ""described as"", ""messy"")"
"Where in the above diagram would you put these three methods, so they are accessible on all classes?","(""methods"", ""are accessible on"", ""classes"")"
"One way to solve this problem would be to create a common superclass for the Vehicle and Driver class, which has the storage and serialization methods.","(""Vehicle"", ""has superclass"", ""common superclass""); (""Driver"", ""has superclass"", ""common superclass""); (""common superclass"", ""has methods"", ""storage""); (""common superclass"", ""has methods"", ""serialization"")"
"The class hierarchy would no longer model vehicles and drivers, but also be tied to the storage and serialization mechanisms used in your application.","(""Class hierarchy"", ""model"", ""vehicles""); (""Class hierarchy"", ""model"", ""drivers""); (""Class hierarchy"", ""tied to"", ""storage mechanisms""); (""Class hierarchy"", ""tied to"", ""serialization mechanisms"")"
"A better solution would be to create some interfaces with the storage and serialization methods on, and let the classes implement these interfaces.","(""classes"", ""implement"", ""interfaces""); (""interfaces"", ""have"", ""storage methods""); (""interfaces"", ""have"", ""serialization methods""); (""classes"", ""use"", ""storage methods""); (""classes"", ""use"", ""serialization methods"")"
"When each class implements these two interfaces and their methods, you can access the methods of these interfaces by casting the objects to instances of the interface types.","(""Class"", ""implements"", ""Interface""); (""Object"", ""cast to"", ""Interface""); (""Class"", ""implements"", ""Interface""); (""Object"", ""has methods of"", ""Interface"")"
"You don't need to know exactly what class a given object is of, as long as you know what interface it implements.","(""Object"", ""implements"", ""Interface"")"
"As you can probably imagine by now, interfaces provide a cleaner way of implementing cross cutting functionality in classes than inheritance.","(""interfaces"", ""provide"", ""functionality""); (""functionality"", ""implemented in"", ""classes""); (""inheritance"", ""compared to"", ""interfaces""); (""classes"", ""use"", ""interfaces""); (""interfaces"", ""used for"", ""cross cutting functionality"")"
A generic Java interface is an interface which can be typed - meaning it can be specialized to work with a specific type (e.g.,"(""Java"", ""has"", ""interface""); (""interface"", ""can be typed with"", ""type""); (""interface"", ""can be specialized to work with"", ""type""); (""interface"", ""is part of"", ""Java"")"
This interface represents an interface which contains a single method called produce() which can produce a single object.,"(""Interface"", ""contains"", ""method""); (""Method"", ""called"", ""produce()""); (""produce()"", ""produces"", ""object"")"
"Since the return value of produce() is Object, it can return any Java object.","(""produce()"", ""returns"", ""Object"")"
The implementation of the produce() method returns a new Car object every time it is called.,"(""produce()"", ""returns"", ""Car""); (""Car"", ""is returned by"", ""produce()"")"
"Notice how the object returned from the carProducer.produce() method call has to be cast to a Car instance, because the produce() method return type is Object.","(""carProducer"", ""produce"", ""Object""); (""carProducer.produce()"", ""returns"", ""Object""); (""Object"", ""cast to"", ""Car""); (""Car"", ""instance of"", ""Object""); (""produce"", ""method of"", ""carProducer"")"
"Now when I implement the MyProducer interface in the CarProducer class, I have to include the generic type declaration too, like this:","(""MyProducer"", ""is implemented by"", ""CarProducer""); (""CarProducer"", ""implements"", ""MyProducer"")"
"As you can see, since the generic type for the CarProducer instance is set to Car, it is no longer necessary to cast the object returned from the produce() method, since the original method declaration in the MyProducer interface states, that this method returns the same type as is specified in the generic type when used.","(""CarProducer"", ""implements"", ""MyProducer""); (""MyProducer"", ""declaresMethod"", ""produce()""); (""CarProducer"", ""usesMethod"", ""produce()""); (""MyProducer"", ""specifiesReturnType"", ""generic type""); (""Car"", ""isTypeOf"", ""generic type""); (""produce()"", ""returns"", ""generic type"")"
But - now it is actually possible to specify another generic type for a CarProducer instance than the type it actually returns from it's produce() method implementation.,"(""CarProducer"", ""has method"", ""produce()""); (""CarProducer"", ""has instance of"", ""generic type""); (""produce()"", ""returns"", ""generic type"")"
"If you scroll up, you can see that the CarProducer.produce() implementation returns a Car object no matter what generic type you specify for it when you create it.","(""CarProducer"", ""produces"", ""Car""); (""CarProducer.produce()"", ""returns"", ""Car""); (""CarProducer"", ""has method"", ""produce()"")"
"Instead, you can lock down the generic type of the MyProducer interface already when you implement it, in the CarProducer class.","(""MyProducer"", ""implemented by"", ""CarProducer""); (""CarProducer"", ""implements"", ""MyProducer"")"
"As you can see, it is still not necessary to cast the object returned by produce(), as the CarProducer implementation declares that to be a Car instance.","(""CarProducer"", ""implements"", ""Car""); (""CarProducer"", ""declares"", ""Car""); (""produce()"", ""returns"", ""Car""); (""Car"", ""instance of"", ""Object""); (""CarProducer"", ""implements"", ""produce()"")"
A Java lambda expression is thus a function which can be created without belonging to any class.,"(""Java"", ""has"", ""lambda expression""); (""lambda expression"", ""is"", ""function"")"
Imagine you have a class called StateOwner which can register state event listeners.,"(""StateOwner"", ""can register"", ""state event listeners""); (""StateOwner"", ""has method"", ""register""); (""register"", ""is used for"", ""state event listeners"")"
The lambda expression is matched against the parameter type of the addStateListener() method's parameter.,"(""lambda expression"", ""is matched against"", ""parameter type""); (""addStateListener() method"", ""has parameter"", ""parameter type""); (""addStateListener() method"", ""is part of"", ""unknown class""); (""parameter type"", ""is type of"", ""addStateListener() method's parameter"")"
"For instance, the interface type of the parameter can be inferred from the method declaration of the addStateListener() method (the single method on the StateChangeListener interface).","(""StateChangeListener"", ""has method"", ""addStateListener()""); (""addStateListener()"", ""is declared in"", ""StateChangeListener"")"
"In the example above, the compiler can infer their type from the onStateChange() method declaration.","(""compiler"", ""infer type from"", ""onStateChange()""); (""onStateChange()"", ""is method of"", ""unknown""); (""compiler"", ""uses"", ""onStateChange()"")"
"Thus, the type of the parameters oldState and newState are inferred from the method declaration of the onStateChange() method.","(""onStateChange"", ""has parameter"", ""oldState""); (""onStateChange"", ""has parameter"", ""newState""); (""onStateChange"", ""is method of"", ""unknown class""); (""oldState"", ""is parameter of"", ""onStateChange""); (""newState"", ""is parameter of"", ""onStateChange"")"
"In this case, these parameters have to match the parameters of the onStateChange() method of the StateChangeListener interface:","(""StateChangeListener"", ""has method"", ""onStateChange()"")"
Here is an example class that creates a lambda which references a static variable from inside the lambda body:,"(""lambda"", ""references"", ""static variable""); (""lambda body"", ""contains"", ""static variable""); (""class"", ""creates"", ""lambda"")"
The class primarily serves to show you that a lambda can access static variables.,"(""lambda"", ""access"", ""static variables"")"
"Since all the lambda body does is forward the string parameter to the System.out.println() method, we can replace the above lambda declaration with a method reference.","(""System.out"", ""hasMethod"", ""println()""); (""lambda"", ""calls"", ""System.out.println()""); (""System.out.println()"", ""isReferencedBy"", ""lambda"")"
Whatever class or object that owns the referenced method comes before the double colons.,"(""Class"", ""owns"", ""Method""); (""Object"", ""owns"", ""Method"")"
"Since the parameters of the Finder.find() and MyClass.doFind() methods match, it is possible to create a lambda expression that implements Finder.find() and references the MyClass.doFind() method.","(""Finder"", ""hasMethod"", ""find()""); (""MyClass"", ""hasMethod"", ""doFind()""); (""Finder.find()"", ""implementedBy"", ""lambda expression""); (""MyClass.doFind()"", ""referencedBy"", ""lambda expression""); (""Finder.find()"", ""matches"", ""MyClass.doFind()"")"
Here is an example of a Java lambda expression that calls String.indexOf() to search:,"(""String"", ""calls"", ""String.indexOf()""); (""String.indexOf()"", ""is called by"", ""Java lambda expression""); (""Java lambda expression"", ""uses"", ""String.indexOf()"")"
The convertToInt() method has the same signature as the deserialize() method of the Deserializer deserialize() method.,"(""convertToInt()"", ""has same signature as"", ""deserialize()""); (""convertToInt()"", ""is part of"", ""Deserializer""); (""deserialize()"", ""is part of"", ""Deserializer"")"
"Because of that, we can create an instance of StringConverter and reference its convertToInt() method from a Java lambda expression, like this:","(""StringConverter"", ""hasMethod"", ""convertToInt()""); (""StringConverter"", ""usedIn"", ""Java lambda expression""); (""Java lambda expression"", ""referencesMethod"", ""convertToInt()"")"
Finally it is possible to reference a constructor of a class.,"(""Class"", ""has"", ""Constructor""); (""Constructor"", ""of"", ""Class"")"
"You do that by writing the class name followed by ::new, like this:","(""class"", ""has method"", ""new"")"
The create() method of this interface matches the signature of one of the constructors in the String class.,"(""String"", ""has constructor"", ""create()""); (""create()"", ""matches signature of"", ""String constructor""); (""String"", ""has method"", ""create()"")"
"In Java, all instructions (code) have to be located inside a Java class.","(""Java"", ""contains"", ""instructions""); (""Java class"", ""contains"", ""instructions""); (""instructions"", ""located inside"", ""Java class"")"
A class is a way of grouping data and instructions that belong together.,"(""class"", ""is a way of grouping"", ""data""); (""class"", ""is a way of grouping"", ""instructions"")"
"Declaring a simple class without any variables, methods or any other instructions, looks like this in Java code:",
This Java code needs to be located in a file with the same file name as the class and ending with the file suffix .java.,"(""Java"", ""uses"", ""file suffix .java""); (""file name"", ""is the same as"", ""class name""); (""file"", ""has suffix"", "".java"")"
"Once the file is located in a file matching its class name and ending with .java, you can compile it with the Java compiler from the Java SDK, or from inside your Java IDE (which is much easier).",
It is recommended that you locate your class in a Java package.,"(""class"", ""located in"", ""Java package"")"
"If you locate a Java class inside a Java package, you have to specify the package name at the top of the Java file.","(""Java class"", ""located inside"", ""Java package""); (""Java package"", ""specified at top of"", ""Java file""); (""Java file"", ""contains"", ""Java class"")"
Here is how the class from earlier looks with a package declaration added:,
Note: The file MyClass.java must now be located in the directory myjavacode and contain the package declaration package myjavacode; .,"(""MyClass.java"", ""located in"", ""myjavacode""); (""myjavacode"", ""contains"", ""MyClass.java""); (""MyClass.java"", ""contains"", ""package myjavacode"")"
A Java program starts by executing the main method of some class.,"(""Java program"", ""starts by executing"", ""main method""); (""main method"", ""of"", ""some class""); (""some class"", ""has"", ""main method"")"
"You can choose the name of the class to execute, but not the name of the method.","(""class"", ""to execute"", ""method""); (""class"", ""has"", ""method""); (""class"", ""choose"", ""name""); (""method"", ""has"", ""name""); (""class"", ""execute"", ""method"")"
Here is how the main method declaration looks when located inside the Java class declaration from earlier:,"(""main method"", ""located inside"", ""Java class declaration""); (""Java class declaration"", ""contains"", ""main method""); (""main method"", ""declared in"", ""Java class"")"
Just remember that a main() method declaration needs these three keywords.,"(""main()"", ""needs"", ""keywords"")"
"In the main() method example earlier I called the String array parameter args, and in the second example I called it stringArray.","(""main()"", ""calls"", ""String.array""); (""String"", ""has parameter"", ""args""); (""String"", ""has alias"", ""stringArray"")"
"You call the java command that comes with the JRE, and tells it what Java class to execute, and what arguments to pass to the main() method.","(""java command"", ""comes with"", ""JRE""); (""java command"", ""tells"", ""Java class""); (""Java class"", ""execute"", ""main() method""); (""main() method"", ""pass arguments to"", ""Java class"")"
The second and third arguments (-cp classes) tells the JVM in what directory the compiled Java classes are located (cp means class path).,"(""JVM"", ""uses"", ""class path""); (""class path"", ""is located in"", ""directory""); (""Java classes"", ""are located in"", ""directory""); (""JVM"", ""uses"", ""cp""); (""cp"", ""means"", ""class path"")"
In this case the compiled Java classes are located in a directory named classes.,"(""Java"", ""uses"", ""classes""); (""classes"", ""located in"", ""directory""); (""Java"", ""compiles to"", ""classes""); (""classes"", ""has location"", ""directory"")"
The fourth argument is the name of the Java class the JVM is to execute.,"(""Java"", ""is executed by"", ""JVM""); (""JVM"", ""executes"", ""Java class"")"
"Notice how the class name also contains the name of the package the class is located in (the ""fully qualified class name"").","(""class"", ""is located in"", ""package"")"
You can pass arguments from the command line to the main() method.,"(""command line"", ""passes arguments to"", ""main() method""); (""main() method"", ""is called from"", ""command line"")"
"When the JVM executes the main() method of the myjavacode.MyClass, the String array passed as parameter to the main() method will contain two Strings: ""Hello"" and ""World"".","(""myjavacode.MyClass"", ""has method"", ""main()""); (""main()"", ""takes parameter"", ""String array""); (""myjavacode.MyClass"", ""executes"", ""main()""); (""String array"", ""contains"", ""Hello""); (""String array"", ""contains"", ""World"")"
The main() method can access the arguments from the command line like this:,"(""main()"", ""can access"", ""arguments""); (""arguments"", ""are from"", ""command line""); (""main()"", ""accesses"", ""command line"")"
"If only a single Java class in your Java program contains a main() method, then the class containing the main() method is often referred to as the main class.","(""Java program"", ""contains"", ""main() method""); (""Java class"", ""contains"", ""main() method""); (""main class"", ""contains"", ""main() method""); (""main() method"", ""is part of"", ""Java class""); (""main() method"", ""is part of"", ""main class"")"
You can have as many classes as you want in your project with a main() method in.,"(""Class"", ""has method"", ""main()""); (""Project"", ""contains"", ""Class""); (""Class"", ""contains"", ""main()"")"
You can still call the other main() methods from inside the main() method the Java Virtual Machine executes (you haven't seen how yet) and you can also start up multiple virtual machines which each execute a single main() method.,"(""Java Virtual Machine"", ""executes"", ""main() method""); (""main() method"", ""calls"", ""main() method""); (""Java Virtual Machine"", ""starts"", ""virtual machines""); (""Virtual Machine"", ""executes"", ""main() method"")"
Therefore Java also contains the Java Math class which contains methods for performing more advanced math calculations in Java.,"(""Java"", ""contains"", ""Java Math class""); (""Java Math class"", ""contains"", ""methods""); (""methods"", ""perform"", ""math calculations"")"
This Java math tutorial will take a closer look at both Java's math operators as well as the Java Math class.,"(""Java"", ""has"", ""math operators""); (""Java"", ""has"", ""Math class""); (""Java Math class"", ""is part of"", ""Java"")"
"The result of this division would be 12.5 , but since the two numbers are integers, the .5 fraction is cut off.",
"Even though the result variable is now a floating point type (double), the final result is still just 12 instead of 12.5 .",
Now the result variable would end up with the value 12.5.,
"The first System.out.println() statement correctly prints the value 0.0 , which is the start value of the the resultDbl3 variable.","(""System"", ""has method"", ""out.println()""); (""System"", ""has field"", ""out""); (""println"", ""is method of"", ""out""); (""out"", ""is field of"", ""System""); (""resultDbl3"", ""has type"", ""double""); (""System.out"", ""has method"", ""println()"")"
"Adding the value 0.01 to 0 a total of 100 times should result in the value 1.0, right?",
The Java Math class provides more advanced mathematical calculations than what the basic Java math operators provide.,"(""Java Math class"", ""provides"", ""mathematical calculations""); (""Java Math class"", ""is compared to"", ""Java math operators""); (""Java math operators"", ""provide"", ""basic mathematical calculations"")"
"The Math class contains methods for finding the maximum or minimum of two values, rounding values, logarithmic functions, square root, and trigonometric functions (sin, cos, tan etc.","(""Math"", ""contains"", ""maximum""); (""Math"", ""contains"", ""minimum""); (""Math"", ""contains"", ""rounding""); (""Math"", ""contains"", ""logarithmic functions""); (""Math"", ""contains"", ""square root""); (""Math"", ""contains"", ""sin""); (""Math"", ""contains"", ""cos""); (""Math"", ""contains"", ""tan"")"
"The Math is located in the java.lang package, and not in the java.math package.","(""Math"", ""is located in"", ""java.lang""); (""Math"", ""is not located in"", ""java.math"")"
"Thus, the fully qualified class name of the Math class is java.lang.Math .","(""java.lang"", ""contains"", ""Math""); (""Math"", ""is part of"", ""java.lang"")"
"Since many of the functions of the Math class are independent from each other, each method will be explained in its own section below.","(""Math"", ""hasMethod"", ""independent functions""); (""Math"", ""contains"", ""each method""); (""Math"", ""hasMethods"", ""functions"")"
"The java.lang.Math contains a set of basic math functions for obtaining the absolute value, highest and lowest of two values, rounding of values, random values etc.","(""java.lang.Math"", ""contains"", ""basic math functions""); (""java.lang.Math"", ""provides"", ""absolute value""); (""java.lang.Math"", ""provides"", ""highest of two values""); (""java.lang.Math"", ""provides"", ""lowest of two values""); (""java.lang.Math"", ""provides"", ""rounding of values""); (""java.lang.Math"", ""provides"", ""random values"")"
These basic math functions of the Java Math class will be covered in the following sections.,"(""Java Math class"", ""has functions"", ""basic math functions""); (""Java Math class"", ""is covered in"", ""following sections""); (""following sections"", ""cover"", ""Java Math class""); (""Java Math class"", ""is part of"", ""Java""); (""basic math functions"", ""are part of"", ""Java Math class"")"
The Math.abs() function returns the absolute value of the parameter passed to it.,"(""Math"", ""returns"", ""absolute value""); (""Math.abs()"", ""is method of"", ""Math""); (""parameter"", ""is passed to"", ""Math.abs()"")"
Which of these methods are called depends on the type of the parameter passed to the Math.abs() method.,"(""Math.abs()"", ""called by"", ""method""); (""Math.abs()"", ""depends on"", ""parameter type""); (""parameter type"", ""passed to"", ""Math.abs()"")"
The Math.ceil() function rounds a floating point value up to the nearest integer value.,"(""Math"", ""contains"", ""ceil()""); (""ceil()"", ""is part of"", ""Math""); (""Math"", ""has method"", ""ceil()"")"
After executing this Java code the ceil variable will contain the value 8.0 .,
The Math.floor() function rounds a floating point value down to the nearest integer value.,"(""Math"", ""hasMethod"", ""floor()""); (""Float"", ""roundedBy"", ""Math.floor()""); (""Math.floor()"", ""rounds"", ""Float"")"
After executing this Java code the floor variable will contain the value 7.0 .,
"The Math.floorDiv() method divides one integer (int or long) by another, and rounds the result down to the nearest integer value.","(""Math"", ""contains"", ""floorDiv""); (""floorDiv"", ""isMethodOf"", ""Math""); (""Math.floorDiv"", ""divides"", ""integer"")"
"The floorDiv() method rounds down to the nearest negative integer, instead of the rounding up that would occur with fraction truncation.","(""floorDiv"", ""method of"", ""unknown class""); (""floorDiv"", ""rounds down to"", ""nearest negative integer"")"
This shows the difference between the / division operator and Math.floorDiv() .,"(""Math"", ""uses"", ""division operator""); (""division operator"", ""compared to"", ""Math.floorDiv()""); (""Math"", ""contains"", ""floorDiv()"")"
The Math.min() method returns the smallest of two values passed to it as parameter.,"(""Math"", ""hasMethod"", ""Math.min()""); (""Math.min()"", ""returns"", ""smallest value""); (""Math.min()"", ""takesParameter"", ""two values"")"
The Math.max() method returns the largest of two values passed to it as parameter.,"(""Math"", ""hasMethod"", ""Math.max()""); (""Math.max()"", ""returns"", ""largest value""); (""Math.max()"", ""takesParameter"", ""two values"")"
The Math.round() method rounds a float or double to the nearest integer using normal math round rules (either up or down).,"(""Math"", ""hasMethod"", ""round()""); (""round()"", ""belongsTo"", ""Math""); (""Math"", ""uses"", ""normal math round rules""); (""round()"", ""operatesOn"", ""float""); (""round()"", ""operatesOn"", ""double""); (""round()"", ""roundsTo"", ""integer"")"
"After executing these two Java statements the roundedDown variable will contain the value 23.0 , and the roundedUp variable will contain the value 24.0.",
The Math.random() method returns a random floating point number between 0 and 1.,"(""Math"", ""method"", ""random()""); (""Math.random()"", ""returns"", ""random floating point number""); (""Math.random()"", ""between"", ""0""); (""Math.random()"", ""between"", ""1"")"
"100, multiply the value returned by Math.random() with the maximum number (e.g.","(""Math"", ""random"", ""Number"")"
"If you need an integer value, use the round(), floor() or ceil() method.","(""round()"", ""is_a"", ""method""); (""floor()"", ""is_a"", ""method""); (""ceil()"", ""is_a"", ""method"")"
The Java Math class also contains a set of functions intended for exponential and logarithmic calculations.,"(""Java Math class"", ""contains"", ""functions""); (""functions"", ""intended for"", ""exponential calculations""); (""functions"", ""intended for"", ""logarithmic calculations""); (""Java Math class"", ""contains"", ""exponential calculations""); (""Java Math class"", ""contains"", ""logarithmic calculations"")"
The Math.exp() function returns e (Euler's number) raised to the power of the value provided as parameter.,"(""Math"", ""returns"", ""e""); (""Math.exp()"", ""parameter"", ""value""); (""Math.exp()"", ""returns"", ""result"")"
The Math.log10 method works like the Math.log() method except is uses 10 as is base for calculating the logarithm instead of e (Euler's Number).,"(""Math.log10"", ""works like"", ""Math.log()""); (""Math.log10"", ""uses base"", ""10""); (""Math.log"", ""uses base"", ""e""); (""Math.log10"", ""calculates"", ""logarithm""); (""Math.log"", ""calculates"", ""logarithm"")"
"In other words, the Math.pow() example calculate the values of 22 and 28 which are 4 and 256.","(""Math"", ""hasMethod"", ""pow()""); (""Math.pow()"", ""calculates"", ""values""); (""Math.pow()"", ""takesArguments"", ""22""); (""Math.pow()"", ""takesArguments"", ""28""); (""Math.pow()"", ""returns"", ""4""); (""Math.pow()"", ""returns"", ""256"")"
The Math.sqrt() method calculates the square root of the parameter given to it.,"(""Math"", ""hasMethod"", ""sqrt()""); (""Math.sqrt()"", ""calculates"", ""square root""); (""parameter"", ""givenTo"", ""Math.sqrt()"")"
"If you are looking for a trigonometric function and you cannot find it here, check the JavaDoc for the Java Math class.","(""Java Math class"", ""has"", ""trigonometric function""); (""Java Math class"", ""is documented in"", ""JavaDoc"")"
"The Math class just might have the function you are looking for, even if I have not described it here.","(""Math"", ""has"", ""function"")"
The Math.PI constant is a double with a value that is very close to the value of PI - the mathematical definition of PI.,"(""Math"", ""has constant"", ""Math.PI""); (""Math.PI"", ""is a"", ""double"")"
You will often need the Math.PI field when making trigonometric calculations.,"(""Math"", ""has field"", ""Math.PI"")"
The Math.sin() method calculates the sine value of some angle value in radians.,"(""Math"", ""hasMethod"", ""Math.sin()""); (""Math.sin()"", ""calculates"", ""sine value""); (""Math.sin()"", ""takesInput"", ""angle value"")"
The Math.cos() method calculates the cosine value of some angle value in radians.,"(""Math"", ""hasMethod"", ""Math.cos()""); (""Math.cos()"", ""calculates"", ""cosine""); (""angle"", ""hasUnit"", ""radians""); (""Math.cos()"", ""takesInput"", ""angle""); (""Math.cos()"", ""returns"", ""cosine value"")"
The Math.tan() method calculates the tangens value of some angle value in radians.,"(""Math"", ""hasMethod"", ""Math.tan()""); (""Math.tan()"", ""calculates"", ""angle value"")"
The Math.asin() method calculates the arc sine value of a value between 1 and -1.,"(""Math"", ""hasMethod"", ""asin()""); (""asin()"", ""calculates"", ""arc sine value""); (""arc sine value"", ""isCalculatedFor"", ""value""); (""value"", ""hasRange"", ""1""); (""value"", ""hasRange"", ""-1"")"
The Math.acos() method calculates the arc cosine value of a value between 1 and -1.,"(""Math"", ""hasMethod"", ""acos()"")"
The Math.atan() method calculates the arc tangens value of a value between 1 and -1.,"(""Math"", ""hasMethod"", ""atan()""); (""atan()"", ""belongsTo"", ""Math""); (""Math"", ""returns"", ""value""); (""atan()"", ""calculates"", ""arc tangens value""); (""arc tangens value"", ""isCalculatedBy"", ""atan()""); (""atan()"", ""takes"", ""value""); (""value"", ""isTakenBy"", ""atan()"")"
The Math.sinh() method calculates the hyperbolic sine value of a value between 1 and -1.,"(""Math"", ""hasMethod"", ""sinh()""); (""Math.sinh()"", ""calculates"", ""hyperbolic sine""); (""hyperbolic sine"", ""isCalculatedFor"", ""value""); (""value"", ""hasRange"", ""1""); (""value"", ""hasRange"", ""-1"")"
The Math.cosh() method calculates the hyperbolic cosine value of a value between 1 and -1.,"(""Math"", ""hasMethod"", ""Math.cosh()""); (""Math.cosh()"", ""calculates"", ""hyperbolic cosine value"")"
The Math.tanh() method calculates the hyperbolic tangens value of a value between 1 and -1.,"(""Math"", ""hasMethod"", ""Math.tanh()""); (""Math.tanh()"", ""calculates"", ""hyperbolic tangens value""); (""hyperbolic tangens value"", ""isCalculatedFor"", ""value between 1 and -1"")"
Java methods are similar to what is called functions or procedures in other programming languages (e.g.,
The example above defines a method called writeText inside a class named MyClass.,"(""MyClass"", ""contains"", ""writeText""); (""writeText"", ""is_method_of"", ""MyClass""); (""MyClass"", ""has_method"", ""writeText()"")"
You can use any primitive data type or built-in Java class as data type for parameters.,"(""primitive data type"", ""used as"", ""parameter data type""); (""built-in Java class"", ""used as"", ""parameter data type"")"
"When the above Java code is executed, the writeText() method will get executed, and the parameters will contain the values ""Hello"" and ""World"".","(""Java code"", ""executes"", ""writeText() method""); (""writeText() method"", ""contains"", ""parameters""); (""parameters"", ""has values"", ""Hello""); (""parameters"", ""has values"", ""World"")"
"But, instead of returning to where the method was called from, the execution is resumed inside the first catch() { } clause surrounding the method, targeted at that exception.","(""catch()"", ""surrounds"", ""method""); (""method"", ""throws"", ""exception""); (""exception"", ""is caught by"", ""catch()"")"
"Notice how the method callSum() creates a variable called theSum, and assigns it the value returned by the add(1, 3) method call.","(""callSum"", ""creates"", ""theSum""); (""callSum"", ""calls"", ""add""); (""add"", ""returns"", ""theSum"")"
Before Java 9 and the Java Platform Module System you would have had to package all of the Java Platform APIs with your Java application because there was no official way of reliably checking what classes your Java application used.,"(""Java Platform APIs"", ""used by"", ""Java application""); (""Java application"", ""uses"", ""Java Platform APIs""); (""Java Platform Module System"", ""introduced in"", ""Java 9"")"
"Since the Java Platform APIs have grown quite large over the years, your application would get a large amount of Java classes included in its distribution, many of which your application would probably not be using.","(""Java Platform"", ""has"", ""APIs""); (""APIs"", ""include"", ""classes""); (""Java Platform"", ""includes"", ""Java classes""); (""Application"", ""uses"", ""Java classes""); (""Application"", ""distributes"", ""Java classes"")"
The unused classes makes your application distributable bigger than it needs to be.,"(""Class"", ""makes"", ""Application""); (""Application"", ""bigger than"", ""needs""); (""Class"", ""makes"", ""Application""); (""Application"", ""needs to be"", ""distributable""); (""Class"", ""makes"", ""Application"")"
from a missing JAR file) would not be detected until the application actually tried to use the missing class.,"(""JAR file"", ""contains"", ""class""); (""class"", ""used by"", ""application""); (""application"", ""tries to use"", ""class""); (""JAR file"", ""missing from"", ""application"")"
This would happen sometime at runtime - depending on when the application tried to use the missing class.,"(""application"", ""uses"", ""class"")"
Having missing modules reported at application startup time is a big advantage compared to at runtime when trying to use the missing module / JAR / class.,"(""application"", ""has"", ""modules""); (""modules"", ""reported at"", ""startup time""); (""missing module"", ""used at"", ""runtime""); (""application"", ""uses"", ""JAR""); (""application"", ""uses"", ""class"")"
"However, you should not use underscores (_) in module names (or package names, class names, method names, variable names etc.)","(""module names"", ""should not use"", ""underscores""); (""package names"", ""should not use"", ""underscores""); (""class names"", ""should not use"", ""underscores""); (""method names"", ""should not use"", ""underscores""); (""variable names"", ""should not use"", ""underscores"")"
"Before Java 9 all Java classes for an application or API were nested directly inside a root class directory (which was added to the classpath), or directly inside a JAR file.","(""Java"", ""has classes"", ""Java classes""); (""Java classes"", ""nested in"", ""root class directory""); (""Java classes"", ""nested in"", ""JAR file""); (""root class directory"", ""added to"", ""classpath""); (""Java classes"", ""part of"", ""application""); (""Java classes"", ""part of"", ""API"")"
The module root directory is used both for the source files and compiled classes of a Java module.,"(""module"", ""has"", ""root directory""); (""Java module"", ""uses"", ""module root directory""); (""module root directory"", ""contains"", ""source files""); (""module root directory"", ""contains"", ""compiled classes"")"
Each Java module needs a Java module descriptor named module-info.java which has to be located in the corresponding module root directory.,"(""Java module"", ""needs"", ""Java module descriptor""); (""Java module descriptor"", ""named"", ""module-info.java""); (""module-info.java"", ""located in"", ""module root directory""); (""Java module"", ""has"", ""module root directory"")"
Notice also how the module descriptor is suffixed .java and yet it uses a hyphen in the file name (module-info.java).,
"Hyphens are not normally allowed in Java class names, but in module descriptor file names they are required!","(""Java"", ""has"", ""class names""); (""Java"", ""uses"", ""module descriptor file names""); (""class names"", ""contain"", ""hyphens""); (""module descriptor file names"", ""require"", ""hyphens"")"
This example module descriptor declares that it requires the standard Java module named javafx.graphics.,"(""javafx.graphics"", ""requires"", ""Java""); (""example module descriptor"", ""declares"", ""javafx.graphics""); (""Java"", ""has module"", ""javafx.graphics"")"
By split package is meant that the total content (classes) of the package is split between multiple modules.,"(""Package"", ""contains"", ""Classes""); (""Modules"", ""split"", ""Package""); (""Package"", ""has"", ""Content""); (""Content"", ""includes"", ""Classes"")"
"Inside that directory you will find a directory with the name of the module, and inside that directory you will find the compiled classes plus a compiled version of the module-info.java module descriptor named module-info.class.","(""module-info.java"", ""hasDescriptor"", ""module-info.class""); (""module-info.class"", ""isCompiledVersionOf"", ""module-info.java""); (""module"", ""hasDescriptor"", ""module-info.java""); (""module"", ""contains"", ""module-info.class""); (""module"", ""hasDirectory"", ""compiled classes"")"
"In order to run the main class of a Java module you use the java command, like this:",
The --module argument tells what module + main class to run.,"(""module"", ""has"", ""main class""); (""main class"", ""runs in"", ""module""); (""module"", ""contains"", ""main class"")"
Notice how the module name and main class name are separated by a slash (/) character.,"(""module"", ""has"", ""name""); (""main class"", ""has"", ""name""); (""module"", ""separated by"", ""slash""); (""main class"", ""separated by"", ""slash""); (""module name"", ""separated by"", ""main class name""); (""slash"", ""separates"", ""module name""); (""slash"", ""separates"", ""main class name"")"
You can still set the JAR main class when generating the module JAR file.,"(""JAR"", ""has"", ""main class""); (""module JAR file"", ""has"", ""JAR main class"")"
Here is an example of setting the main class of a Java module JAR file:,"(""Java"", ""hasModule"", ""JAR file""); (""JAR file"", ""hasAttribute"", ""main class""); (""main class"", ""belongsTo"", ""Java module"")"
You can now run the main class of this JAR file with a shortcut.,
Here is how you run the main class from a Java module JAR file:,"(""Java"", ""has"", ""main class""); (""main class"", ""runs from"", ""Java module JAR file""); (""Java module JAR file"", ""contains"", ""main class"")"
"If the Java module JAR file has a main class set (see a few sections earlier in this tutorial for how to do that), you can run the Java module main class with a little shorter command line.","(""Java module"", ""has"", ""main class""); (""main class"", ""set in"", ""JAR file""); (""Java module"", ""run with"", ""command line""); (""JAR file"", ""has"", ""main class"")"
Here is an example of running a Java module from a JAR file with a main class set:,"(""Java"", ""has"", ""module""); (""module"", ""runs from"", ""JAR file""); (""JAR file"", ""has"", ""main class"")"
The --module argument specifies which module plus main class to run.,"(""module"", ""specifies"", ""main class""); (""main class"", ""run"", ""module""); (""module"", ""has"", ""main class""); (""main class"", ""is part of"", ""module""); (""module"", ""run"", ""argument""); (""argument"", ""specifies"", ""module"")"
"From Java 9 and forward, all Java classes must be located in a module for the Java VM to use them.","(""Java 9"", ""has requirement"", ""Java classes""); (""Java classes"", ""must be located in"", ""module""); (""Java VM"", ""uses"", ""Java classes""); (""Java classes"", ""located in"", ""module""); (""Java VM"", ""requires"", ""module"")"
"But what do you do with older Java libraries where you just have the compiled classes, or a JAR file?","(""Java"", ""has"", ""libraries""); (""libraries"", ""are stored in"", ""JAR file""); (""JAR file"", ""contains"", ""compiled classes"")"
In Java 9 you can still use the -classpath argument to the Java VM when running an application.,
"On the classpath you can include all your older Java classes, just like you have done before Java 9.","(""Java classes"", ""included in"", ""classpath""); (""classpath"", ""contains"", ""Java classes""); (""Java 9"", ""compared to"", ""older Java classes"")"
All classes found on the classpath will be included in what Java calls the unnamed module.,"(""classpath"", ""included in"", ""unnamed module""); (""Java"", ""calls"", ""unnamed module""); (""unnamed module"", ""includes"", ""classes""); (""classpath"", ""contains"", ""classes""); (""classes"", ""found on"", ""classpath""); (""Java"", ""has"", ""classpath"")"
"However, the classes in the unnamed module are only readable by other classes in the unnamed module - or from automatic modules (see next section).","(""classes"", ""are readable by"", ""other classes""); (""classes"", ""are readable by"", ""automatic modules""); (""unnamed module"", ""contains"", ""classes""); (""automatic modules"", ""can read"", ""classes"")"
No named module can read the classes of the unnamed module.,"(""Module"", ""can read"", ""Classes""); (""Named Module"", ""is type of"", ""Module""); (""Unnamed Module"", ""is type of"", ""Module""); (""Named Module"", ""reads"", ""Unnamed Module"")"
All classes in the unnamed module requires all modules found on the module path.,"(""classes"", ""requires"", ""modules""); (""modules"", ""found on"", ""module path""); (""module path"", ""contains"", ""modules""); (""classes"", ""in"", ""unnamed module""); (""unnamed module"", ""requires"", ""modules"")"
"That way, all classes in the unnamed module can read all classes exported by all the Java modules found on the module path.","(""classes"", ""can read"", ""classes""); (""unnamed module"", ""can read"", ""Java modules""); (""Java modules"", ""are found on"", ""module path""); (""classes"", ""are exported by"", ""Java modules""); (""unnamed module"", ""has"", ""classes""); (""Java modules"", ""are on"", ""module path"")"
"While you can include the third party library on the classpath and thus include it in the unnamed module, your own named modules cannot use it, because named modules cannot read classes from the unnamed module.","(""Named Modules"", ""cannot use"", ""Third Party Library""); (""Named Modules"", ""cannot read classes from"", ""Unnamed Module""); (""Unnamed Module"", ""includes"", ""Third Party Library"")"
"An automatic module is made from a JAR file with Java classes that are not modularized, meaning the JAR file has no module descriptor.","(""JAR file"", ""has"", ""Java classes""); (""JAR file"", ""has no"", ""module descriptor""); (""Java classes"", ""are part of"", ""JAR file""); (""JAR file"", ""is used to create"", ""automatic module"")"
When you place an ordinary JAR file on the module path (not the classpath) the Java VM will convert it to an automatic module at runtime.,"(""Java VM"", ""converts"", ""JAR file""); (""JAR file"", ""placed on"", ""module path""); (""Java VM"", ""uses"", ""module path""); (""Java VM"", ""uses"", ""classpath"")"
"If your application contains multiple automatic modules, each automatic module can read the classes of all other automatic modules.","(""automatic module"", ""contains"", ""classes""); (""automatic module"", ""can read"", ""classes""); (""automatic module"", ""read"", ""automatic module"")"
This is different from explicitly named modules (real Java modules) which cannot read classes in the unnamed module.,"(""Java modules"", ""cannot read classes in"", ""unnamed module""); (""Unnamed module"", ""contains"", ""classes""); (""Java modules"", ""cannot read"", ""unnamed module"")"
"An automatic module exports all its packages, so all named modules on the module path can use the classes of an automatic module.","(""automatic module"", ""exports"", ""packages""); (""packages"", ""are used by"", ""named modules""); (""named modules"", ""use"", ""classes""); (""automatic module"", ""contains"", ""classes""); (""classes"", ""are part of"", ""packages"")"
"If a JAR file contains versioning in its file name, e.g.",
"The service interface is typically located in a service interface Java module which only contains the service interface, plus any classes and interfaces related to the service interface.","(""service interface"", ""located in"", ""service interface Java module""); (""service interface Java module"", ""contains"", ""service interface""); (""service interface Java module"", ""contains"", ""classes""); (""service interface Java module"", ""contains"", ""interfaces"")"
The com folder at the root level of the JAR file contains the compiled Java classes for pre Java 9 versions.,"(""com"", ""contains"", ""Java classes""); (""JAR file"", ""contains"", ""com""); (""Java classes"", ""compiled for"", ""pre Java 9 versions""); (""com"", ""at root level of"", ""JAR file""); (""pre Java 9 versions"", ""have compiled Java classes in"", ""com""); (""JAR file"", ""at root level has"", ""com"")"
Earlier versions of Java do not understand multi Java version JAR files so they use the classes found here.,"(""Java"", ""uses"", ""classes""); (""Java"", ""has"", ""versions""); (""versions"", ""do not understand"", ""multi Java version JAR files""); (""JAR files"", ""contain"", ""classes"")"
The META-INF directory contains the MANIFEST.MF file and a directory named versions.,"(""META-INF"", ""contains"", ""MANIFEST.MF""); (""META-INF"", ""contains"", ""versions"")"
The MANIFEST.MF file needs a special entry that marks the JAR file as a multi version JAR file.,
The versions directory which can contain the compiled classes for different versions of Java for your module.,"(""versions directory"", ""contains"", ""compiled classes""); (""compiled classes"", ""are for"", ""Java""); (""Java"", ""has"", ""different versions""); (""versions directory"", ""is for"", ""module"")"
"Upgrading utility libraries first to automatic modules, and later to full modules, starting at the bottom of the dependency hierarchy should assure that your libraries can still read each other during upgrade, plus be readable by the main applications on the classpath in the unnamed module or as an automatic or named module.","(""utility libraries"", ""upgraded to"", ""automatic modules""); (""automatic modules"", ""upgraded to"", ""full modules""); (""dependency hierarchy"", ""starts at"", ""bottom""); (""libraries"", ""read"", ""each other""); (""libraries"", ""readable by"", ""main applications""); (""main applications"", ""located in"", ""unnamed module""); (""main applications"", ""located in"", ""automatic module""); (""main applications"", ""located in"", ""named module""); (""unnamed module"", ""on"", ""classpath""); (""automatic module"", ""on"", ""classpath""); (""named module"", ""on"", ""classpath"")"
In Java nested classes are classes that are defined inside another class.,"(""Java"", ""has"", ""nested classes""); (""nested classes"", ""are defined in"", ""class"")"
"The purpose of a nested class is to clearly group the nested class with its surrounding class, signaling that these two classes are to be used together.","(""nested class"", ""is grouped with"", ""surrounding class""); (""surrounding class"", ""is grouped with"", ""nested class""); (""nested class"", ""is used with"", ""surrounding class""); (""surrounding class"", ""is used with"", ""nested class"")"
Or perhaps that the nested class is only to be used from inside its enclosing (owning) class.,"(""nested class"", ""is used from"", ""enclosing class""); (""enclosing class"", ""owns"", ""nested class""); (""nested class"", ""is inside"", ""enclosing class"")"
"Java developers often refer to nested classes as inner classes, but inner classes (non-static nested classes) are only one out of several different types of nested classes in Java.","(""Java"", ""has"", ""nested classes""); (""Java"", ""refers to"", ""inner classes""); (""nested classes"", ""include"", ""inner classes""); (""inner classes"", ""are"", ""non-static nested classes"")"
In Java nested classes are considered members of their enclosing class.,"(""Java"", ""has"", ""nested classes""); (""nested classes"", ""are members of"", ""enclosing class"")"
"Thus, a nested class can be declared public, package (no access modifier), protected and private (see access modifiers for more info).","(""nested class"", ""can be declared"", ""public""); (""nested class"", ""can be declared"", ""package""); (""nested class"", ""can be declared"", ""protected""); (""nested class"", ""can be declared"", ""private""); (""access modifiers"", ""for more info"", ""nested class"")"
Therefore nested classes in Java can also be inherited by subclasses as explained in my tutorial about Java inheritance.,"(""Java"", ""has"", ""nested classes""); (""nested classes"", ""can be inherited by"", ""subclasses""); (""Java"", ""has"", ""subclasses""); (""Java"", ""has"", ""inheritance""); (""subclasses"", ""inherit"", ""nested classes""); (""Java"", ""supports"", ""inheritance"")"
You can create several different types of nested classes in Java.,"(""Java"", ""has"", ""nested classes""); (""nested classes"", ""can be created in"", ""Java"")"
All these types of nested classes will be covered in the following sections.,
"In order to create an instance of the Nested class you must reference it by prefixing it with the Outer class name, like this:","(""Nested"", ""is nested in"", ""Outer""); (""Outer"", ""contains"", ""Nested""); (""Nested"", ""referenced by"", ""Outer"")"
In Java a static nested class is essentially a normal class that has just been nested inside another class.,"(""Java"", ""has"", ""static nested class""); (""static nested class"", ""is"", ""normal class""); (""static nested class"", ""nested inside"", ""another class""); (""Java"", ""uses"", ""static nested class""); (""static nested class"", ""essentially is"", ""normal class""); (""normal class"", ""been nested inside"", ""another class"")"
"Being static, a static nested class can only access instance variables of the enclosing class via a reference to an instance of the enclosing class.","(""static nested class"", ""can access"", ""instance variables""); (""static nested class"", ""is part of"", ""enclosing class""); (""enclosing class"", ""has"", ""instance variables""); (""static nested class"", ""requires"", ""reference to enclosing class"")"
Inner classes are associated with an instance of the enclosing class.,"(""Inner class"", ""is associated with"", ""Enclosing class""); (""Enclosing class"", ""has instance of"", ""Inner class""); (""Inner class"", ""belongs to"", ""Enclosing class"")"
"Thus, you must first create an instance of the enclosing class to create an instance of an inner class.","(""enclosing class"", ""has"", ""inner class""); (""enclosing class"", ""creates"", ""instance of inner class""); (""instance of enclosing class"", ""required to create"", ""instance of inner class"")"
Here is how you create an instance of the Inner class:,"(""Inner"", ""is instance of"", ""class"")"
Notice how you put new after the reference to the outer class in order to create an instance of the inner class.,
"Non-static nested classes (inner classes) have access to the fields of the enclosing class, even if they are declared private.","(""Non-static nested classes"", ""have access to"", ""fields""); (""fields"", ""are declared in"", ""enclosing class""); (""Non-static nested classes"", ""are part of"", ""enclosing class"")"
Notice how the printText() method of the Inner class references the private text field of the Outer class.,"(""Inner"", ""references"", ""Outer""); (""Inner.printText()"", ""accesses"", ""Outer.text""); (""Outer"", ""contains"", ""Inner""); (""Outer"", ""has"", ""text""); (""Inner.printText()"", ""uses"", ""Outer.text"")"
"If a Java inner class declares fields or methods with the same names as field or methods in its enclosing class, the inner fields or methods are said to shadow over the outer fields or methods.","(""Java inner class"", ""declares"", ""fields""); (""Java inner class"", ""declares"", ""methods""); (""inner fields"", ""shadow"", ""outer fields""); (""inner methods"", ""shadow"", ""outer methods""); (""Java inner class"", ""has"", ""enclosing class"")"
In the above example both the Outer and Inner class contains a field named text.,"(""Outer"", ""contains"", ""text""); (""Inner"", ""contains"", ""text"")"
When the Inner class refers to text it refers to its own field.,"(""Inner class"", ""refers to"", ""text""); (""Inner class"", ""has"", ""field"")"
"Java makes it possible though, for the Inner class to refer to the text field of the Outer class.","(""Inner class"", ""refer to"", ""Outer class""); (""Outer class"", ""has"", ""text field""); (""Inner class"", ""part of"", ""Outer class"")"
To do so it has to prefix the text field reference with Outer.this.,"(""Outer"", ""has field"", ""text""); (""Outer"", ""has keyword"", ""this"")"
Now the Inner.printText() method will print both the Inner.text and Outer.text fields.,"(""Inner"", ""has method"", ""printText()""); (""Inner"", ""accesses field"", ""Inner.text""); (""Inner"", ""accesses field"", ""Outer.text""); (""Outer"", ""has field"", ""text""); (""Inner"", ""is part of"", ""Outer"")"
Local classes in Java are like inner classes (non-static nested classes) that are defined inside a method or scope block ({ ... }) inside a method.,"(""Local classes"", ""are defined in"", ""method""); (""Inner classes"", ""are similar to"", ""Local classes""); (""Inner classes"", ""are defined as"", ""non-static nested classes""); (""Non-static nested classes"", ""are defined in"", ""method""); (""Scope block"", ""contains"", ""Local classes""); (""Method"", ""contains"", ""scope block"")"
Local classes can only be accessed from inside the method or scope block in which they are defined.,"(""Local classes"", ""can be accessed from"", ""method""); (""Local classes"", ""can be accessed from"", ""scope block""); (""Method"", ""contains"", ""Local classes""); (""Scope block"", ""contains"", ""Local classes"")"
Local classes can access members (fields and methods) of its enclosing class just like regular inner classes.,"(""Local classes"", ""can access"", ""members""); (""Local classes"", ""access"", ""fields""); (""Local classes"", ""access"", ""methods""); (""Local classes"", ""are like"", ""regular inner classes""); (""Regular inner classes"", ""can access"", ""members""); (""Regular inner classes"", ""access"", ""fields""); (""Regular inner classes"", ""access"", ""methods"")"
"Local classes can also access local variables inside the same method or scope block, provided these variables are declared final.","(""Local classes"", ""can access"", ""local variables""); (""Local variables"", ""are declared"", ""final""); (""Local classes"", ""are defined in"", ""same method""); (""Local classes"", ""are defined in"", ""scope block"")"
From Java 8 local classes can also access local variables and parameters of the method the local class is declared in.,"(""Java 8"", ""has feature"", ""local classes""); (""local classes"", ""can access"", ""local variables""); (""local classes"", ""can access"", ""method parameters""); (""local class"", ""is declared in"", ""method"")"
In that case the local class only has access to the static parts of the enclosing class.,"(""local class"", ""has access to"", ""enclosing class""); (""enclosing class"", ""has"", ""static parts""); (""local class"", ""accesses"", ""static parts"")"
"Local classes cannot contain all kinds of static declarations (constants are allowed - variables declared static final), because local classes are non-static in nature - even if declared inside a static method.","(""Local classes"", ""cannot contain"", ""static declarations""); (""Local classes"", ""are"", ""non-static""); (""Static method"", ""contains"", ""local classes""); (""Local classes"", ""are declared in"", ""static method""); (""Static declarations"", ""include"", ""constants""); (""Constants"", ""are declared as"", ""static final""); (""Static declarations"", ""exclude"", ""variables"")"
The same shadowing rules apply for local classes as for inner classes.,"(""local classes"", ""have shadowing rules"", ""inner classes"")"
Anonymous classes in Java are nested classes without a class name.,"(""Anonymous classes"", ""are"", ""nested classes""); (""Java"", ""has"", ""Anonymous classes""); (""Anonymous classes"", ""are"", ""without a class name""); (""nested classes"", ""are in"", ""Java"")"
"They are typically declared as either subclasses of an existing class, or as implementations of some interface.","(""Subclass"", ""declared as"", ""ExistingClass""); (""Implementation"", ""declared as"", ""Interface"")"
Here is an example that declares an anonymous subclass of a superclass called SuperClass:,"(""SuperClass"", ""hasSubclass"", ""anonymous subclass""); (""anonymous subclass"", ""isTypeOf"", ""SuperClass""); (""SuperClass"", ""isSuperclassOf"", ""anonymous subclass"")"
Running this Java code would result in Anonymous class doIt() being printed to System.out.,"(""Anonymous"", ""has method"", ""doIt()""); (""Java"", ""uses"", ""System.out""); (""System.out"", ""prints"", ""Anonymous""); (""Anonymous"", ""has method"", ""doIt()""); (""doIt()"", ""is part of"", ""Anonymous"")"
The anonymous class subclasses (extends) SuperClass and overrides the doIt() method.,"(""anonymous class"", ""extends"", ""SuperClass""); (""anonymous class"", ""overrides"", ""SuperClass.doIt()"")"
A Java anonymous class can also implement an interface instead of extending a class.,"(""Java"", ""can use"", ""anonymous class""); (""anonymous class"", ""can implement"", ""interface""); (""anonymous class"", ""instead of"", ""extending a class""); (""interface"", ""can be implemented by"", ""anonymous class""); (""class"", ""can be extended by"", ""anonymous class"")"
"As you can see, an anonymous class implementing an interface is pretty similar to an anonymous class extending another class.","(""anonymous class"", ""implementing"", ""interface""); (""anonymous class"", ""extending"", ""class"")"
"You can declare fields and methods inside an anonymous class, but you cannot declare a constructor.","(""anonymous class"", ""has"", ""fields""); (""anonymous class"", ""has"", ""methods""); (""anonymous class"", ""cannot declare"", ""constructor"")"
"You can declare a static initializer for the anonymous class instead, though.","(""anonymous class"", ""has"", ""static initializer"")"
The same shadowing rules apply to anonymous classes as to inner classes.,"(""Anonymous Classes"", ""have shadowing rules applied to"", ""Inner Classes""); (""Inner Classes"", ""have shadowing rules applied to"", ""Anonymous Classes""); (""Anonymous Classes"", ""are compared to"", ""Inner Classes""); (""Inner Classes"", ""are compared to"", ""Anonymous Classes"")"
The benefits of Java nested classes are that you can group classes together that belong together.,"(""Java"", ""has"", ""nested classes""); (""Java nested classes"", ""group"", ""classes"")"
"You could do so already by putting them in the same package, but putting one class inside another makes an even stronger grouping.","(""class"", ""is inside"", ""package""); (""class"", ""is inside"", ""class""); (""package"", ""contains"", ""class"")"
A nested class is typically only used by or with its enclosing class.,"(""Class"", ""is typically only used by"", ""EnclosingClass""); (""NestedClass"", ""is used with"", ""EnclosingClass""); (""EnclosingClass"", ""uses"", ""NestedClass"")"
"Sometimes a nested class is only visible to the enclosing class, is only used internally, and is thus never visible outside the enclosing class.","(""nested class"", ""is used by"", ""enclosing class""); (""enclosing class"", ""contains"", ""nested class""); (""nested class"", ""is visible to"", ""enclosing class"")"
"Other times the nested class is visible outside its enclosing class, but can only be used in conjunction with the enclosing class.","(""nested class"", ""is visible outside"", ""enclosing class""); (""enclosing class"", ""has"", ""nested class""); (""nested class"", ""can only be used in conjunction with"", ""enclosing class"")"
"Inside the Cache class you might declare a CacheEntry class which can contain information about a specific cache entry (cached value, time inserted, number of times accessed etc.).","(""Cache"", ""contains"", ""CacheEntry""); (""CacheEntry"", ""contains"", ""cached value""); (""CacheEntry"", ""contains"", ""time inserted""); (""CacheEntry"", ""contains"", ""number of times accessed"")"
"Users of the Cache class may never see the CacheEntry class, if they have no need to obtain information about the CacheEntry itself, but only the cached value.","(""Users"", ""use"", ""Cache class""); (""Cache class"", ""contain"", ""CacheEntry class""); (""Users"", ""obtain information about"", ""CacheEntry class""); (""Users"", ""obtain"", ""cached value""); (""CacheEntry class"", ""have"", ""cached value"")"
"However, the Cache class may choose to make the CacheEntry class visible to the outside world, so they can access more than just the cached value (for instance information about when the value was last refreshed etc.","(""Cache"", ""may make visible"", ""CacheEntry""); (""CacheEntry"", ""contains"", ""cached value""); (""CacheEntry"", ""contains"", ""information about when the value was last refreshed"")"
The first Cache class hides its CacheEntry nested class while the second Cache class exposes it.,"(""Cache"", ""hides"", ""CacheEntry""); (""Cache"", ""exposes"", ""CacheEntry"")"
You instantiate an object of a certain class using the new keyword.,"(""Object"", ""instantiated by"", ""new keyword""); (""Class"", ""instantiated by"", ""new keyword""); (""Object"", ""created from"", ""Class"")"
"This example declares a variable of the MyClass class (custom data type), and then creates a new MyClass instance and assigns a reference to this instance to myClassInstance variable.","(""MyClass"", ""hasInstance"", ""myClassInstance""); (""myClassInstance"", ""isOfType"", ""MyClass""); (""MyClass"", ""isDataTypeOf"", ""myClassInstance"")"
"Inside the parantheses () after the for keyword, are three statements separated by semicolon (;).","(""for"", ""has"", ""keyword""); (""for"", ""contains"", ""statements""); (""statements"", ""are separated by"", ""semicolon""); (""statements"", ""are inside"", ""parentheses""); (""parentheses"", ""contain"", ""statements""); (""semicolon"", ""separates"", ""statements""); (""for"", ""uses"", ""parentheses""); (""parentheses"", ""are after"", ""for""); (""statements"", ""are after"", ""for""); (""for"", ""contains"", ""parentheses""); (""parentheses"", ""are used by"", ""for""); (""semicolon"", ""is used by"", ""for""); (""statements"", ""are used by"", ""for""); (""for"", ""has"", ""parentheses""); (""for"", ""has"", ""semicolon""); (""for"", ""has"", ""statements""); (""statements"", ""are in"", ""for""); (""parentheses"", ""are in"", ""for""); (""semicolon"", ""is in"", ""for""); (""for"", ""includes"", ""statements""); (""for"", ""includes"", ""semicolon""); (""for"", ""includes"", ""parentheses"")"
"Here is a simple example of a class that has two methods, where one method calls the other:",
"Notice how printBoth() calls the print() method two times, each time with a different of the parameters passed to the printBoth() method.","(""printBoth()"", ""calls"", ""print()""); (""printBoth()"", ""calls"", ""print()""); (""print()"", ""is called by"", ""printBoth()"")"
The print() method is thus a reusable block of code that can be called from anywhere.,"(""print"", ""is a method of"", ""reusable block of code"")"
"When the print() method is finished executing, the program jumps back to after the line that called the print() method.","(""print() method"", ""is called by"", ""program""); (""program"", ""calls"", ""print() method""); (""print() method"", ""finishes executing"", ""program"")"
"Java packages are a mechanism to group Java classes that are related to each other, into the same ""group"" (package).","(""Java packages"", ""group"", ""Java classes""); (""Java classes"", ""are related to"", ""Java classes""); (""Java packages"", ""contain"", ""Java classes"")"
"When a Java project grows bigger, for instance an app or API, it is useful to split the code into multiple Java classes, and the classes into multiple Java packages.","(""Java project"", ""has"", ""code""); (""code"", ""split into"", ""Java classes""); (""Java classes"", ""split into"", ""Java packages""); (""Java project"", ""split into"", ""Java packages""); (""Java classes"", ""part of"", ""Java packages"")"
"When you divide classes into multiple Java packages, it becomes easier to figure out where a certain class you are looking for is.","(""Java packages"", ""contain"", ""classes"")"
All Java source and class files of classes belonging to the same package are located in the same directory.,"(""Java source files"", ""belong to"", ""package""); (""class files"", ""belong to"", ""package""); (""Java source files"", ""located in"", ""directory""); (""class files"", ""located in"", ""directory""); (""package"", ""contains"", ""Java source files""); (""package"", ""contains"", ""class files""); (""directory"", ""contains"", ""Java source files""); (""directory"", ""contains"", ""class files"")"
"Its a tree of packages, subpackages and classes inside these classes.","(""packages"", ""contains"", ""subpackages""); (""packages"", ""contains"", ""classes""); (""subpackages"", ""contains"", ""classes"")"
"I have expanded two of the sublevel Java packages, so you can see the classes inside.","(""Java"", ""contains"", ""packages""); (""packages"", ""contain"", ""classes"")"
"The classes are illustrated using a little blue circle with a C inside, in the screenshot above.",
"Similarly, the fully qualified name of a Java class includes its package name.","(""Java class"", ""includes"", ""package name""); (""Java class"", ""has"", ""fully qualified name""); (""fully qualified name"", ""includes"", ""package name"")"
"For instance, the full qualified name of the ""Page"" class, is:","(""Page"", ""is full qualified name of"", ""class"")"
"In order to put add Java classes to packages, you must do two things:","(""Java classes"", ""put in"", ""packages""); (""packages"", ""have"", ""Java classes""); (""Java classes"", ""added to"", ""packages"")"
Put the class files into the directory matching the package you want to add it to.,"(""class files"", ""put into"", ""directory""); (""directory"", ""matching"", ""package"")"
"When you have put your Java source file into the correct directory (matching the package the class should belong to), you have to declare inside that class file, that it belongs to that Java package.","(""Java source file"", ""belongs to"", ""package""); (""Class file"", ""declares"", ""package""); (""Class"", ""belongs to"", ""package""); (""Package"", ""contains"", ""Java source file"")"
"Not like Java classes, where the first letter is usually a capital letter.","(""Java"", ""has characteristic"", ""capital letter"")"
"If the classes A and B are located in the same Java package, there is no problem with the code above.","(""A"", ""located in"", ""same Java package""); (""same Java package"", ""contains"", ""A""); (""same Java package"", ""contains"", ""B""); (""A"", ""located in"", ""same Java package""); (""B"", ""located in"", ""same Java package"")"
"If you need to use a lot of classes from a certain Java package, importing them one at a time results in a lot of import statements.","(""Package"", ""contains"", ""Class""); (""Class"", ""is_part_of"", ""Package""); (""Java package"", ""imports"", ""Class"")"
It is possible to import all classes of a package using the * character instead of a class name.,"(""Package"", ""contains"", ""Classes""); (""Package"", ""uses"", ""* character""); (""Class"", ""belongs to"", ""Package"")"
It is possible to use a class from another package without importing it with an import statement.,"(""class"", ""from"", ""package""); (""package"", ""imported by"", ""class""); (""class"", ""used in"", ""package"")"
You can write the fully qualified class name instead of just the name of the class itself.,"(""class"", ""has"", ""fully qualified name""); (""class"", ""has"", ""name""); (""fully qualified name"", ""is used instead of"", ""name""); (""class"", ""can be written with"", ""fully qualified name"")"
"The fully qualified class name consists of the full package path down to the subclass containing the class, and also including the class name itself.","(""class"", ""contains"", ""subclass""); (""subclass"", ""is part of"", ""package""); (""package"", ""includes"", ""class""); (""class"", ""has"", ""fully qualified class name""); (""fully qualified class name"", ""consists of"", ""package path""); (""package path"", ""includes"", ""subclass""); (""fully qualified class name"", ""includes"", ""class name"")"
The fully qualified class name is also what you would write in an import statement.,"(""class"", ""is used in"", ""import statement""); (""import statement"", ""contains"", ""fully qualified class name""); (""fully qualified class name"", ""is written in"", ""import statement"")"
"You could use this fully qualified class name to reference the TimeUtil class inside another class, like this:","(""TimeUtil"", ""referenced inside"", ""another class"")"
"You might be wondering how you decide on what Java packages to create, and how to divide your classes into these packages.","(""Java"", ""has"", ""packages""); (""packages"", ""contain"", ""classes""); (""classes"", ""belong to"", ""packages"")"
"The first method is to divide classes after what ""layer"" of the application they belong to.","(""classes"", ""belong to"", ""layer""); (""layer"", ""of"", ""application""); (""application"", ""has"", ""classes"")"
All classes involved in communication with the database would then be located in the database package.,"(""classes"", ""involved in"", ""communication""); (""classes"", ""located in"", ""database package""); (""database package"", ""involved in"", ""communication""); (""classes"", ""communicate with"", ""database"")"
The second method is to divide your classes based on what part of the application functionality they belong to.,"(""classes"", ""belong to"", ""application functionality""); (""classes"", ""divide"", ""application functionality""); (""application functionality"", ""have"", ""classes""); (""classes"", ""are divided based on"", ""application functionality"")"
"All classes involved in one way or another in the pension calculations would go into that package (or subpackages, if the number of classes in pension grow large).","(""com.example.pension"", ""contains"", ""classes""); (""classes"", ""involvedIn"", ""pension calculations""); (""pension calculations"", ""dependOn"", ""classes""); (""package"", ""has"", ""subpackages""); (""classes"", ""belongTo"", ""package""); (""package"", ""has"", ""classes""); (""subpackages"", ""belongTo"", ""package"")"
"The ""divide by application functionality"" method of dividing classes into Java packages tends to work better than ""divide by layer"", as your application grows in number of classes.","(""Java packages"", ""contains"", ""classes""); (""application"", ""grows in"", ""number of classes""); (""divide by application functionality"", ""compared to"", ""divide by layer""); (""divide by application functionality"", ""works better than"", ""divide by layer"")"
"Instead of having a fixed number of layer packages which keep growing in number of classes, you get a growing number of application functionality packages with a smaller number of classes inside.","(""layer packages"", ""has"", ""classes""); (""application functionality packages"", ""has"", ""classes""); (""application functionality packages"", ""contains"", ""classes""); (""packages"", ""have"", ""classes""); (""classes"", ""are in"", ""packages""); (""packages"", ""contain"", ""classes""); (""layer packages"", ""contain"", ""classes""); (""packages"", ""grow in"", ""classes""); (""application functionality packages"", ""grow in"", ""functionality"")"
"These packages contain classes for all kinds of purposes that programmers often need, like reading and writing files from the local hard disk, sending and receiving data over networks and the internet, connecting to databases, and many, many other things.","(""packages"", ""contain"", ""classes""); (""classes"", ""used for"", ""reading files""); (""classes"", ""used for"", ""writing files""); (""classes"", ""used for"", ""sending data""); (""classes"", ""used for"", ""receiving data""); (""classes"", ""used for"", ""connecting to databases"")"
"When you compile all the source code in the source, the compiler produces one .class file for each .java file.","(""compiler"", ""produces"", "".class file""); ("".java file"", ""compiled by"", ""compiler""); (""compiler"", ""compiles"", ""source code"")"
It is the .class files that the Java Virtual Machine can execute.,"(""Java Virtual Machine"", ""execute"", "".class files"")"
Therefore it is normal to separate the .java files from the .class files.,
This is normally done by instructing the compiler to write the .class files into a separate directory.,
"This directory is often called classes, but again, it is not a requirement, and it depends on what build tool or IDE etc.",
The *.java means the compiler should compile all files in the given directory.,
"Once the compiler has done its job, the classes directory will contain the compiled .class files.","(""compiler"", ""has done its job"", ""classes directory""); (""classes directory"", ""will contain"", "".class files""); (""compiler"", ""compiles"", "".class files"")"
The package structure (directory structure) from the source directory will be preserved under the class directory.,"(""package structure"", ""preserved under"", ""class directory""); (""package structure"", ""from"", ""source directory""); (""source directory"", ""has"", ""package structure""); (""class directory"", ""has"", ""package structure"")"
You can run any one of these .class files which have a main() method in it.,"(""class files"", ""have"", ""main() method""); (""main() method"", ""in"", ""class files""); (""class files"", ""run"", ""main() method"")"
"You can run the .class from inside your Java IDE, or from the command line.",
The -cp classes flag tells the Java Virtual Machine that all your classes are located under the directory called classes.,"(""Java Virtual Machine"", ""uses"", ""classes flag""); (""classes flag"", ""located under"", ""directory""); (""Java Virtual Machine"", ""loads classes from"", ""directory""); (""classes"", ""located under"", ""directory""); (""Java Virtual Machine"", ""has flag"", ""-cp classes"")"
The name of the class to run is the last argument in the above command - the myfirstapp.MyJavaApp part.,"(""myfirstapp"", ""contains"", ""MyJavaApp"")"
The JVM needs to know the fully qualified class name (all packages plus class name) to determine where the corresponding .class file is located.,"(""JVM"", ""needs"", ""fully qualified class name""); (""fully qualified class name"", ""consists of"", ""packages""); (""fully qualified class name"", ""consists of"", ""class name""); (""JVM"", ""determines"", "".class file location""); (""packages"", ""plus"", ""class name""); (""JVM"", ""determines"", ""corresponding .class file"")"
When you run the the class your command line will look similar to this (including the output from the Java app):,
A Java Record is a special kind of Java class which has a concise syntax for defining immutable data-only classes.,"(""Java Record"", ""is a kind of"", ""Java class""); (""Java Record"", ""has syntax for"", ""immutable data-only classes""); (""Java class"", ""has syntax for"", ""immutable data-only classes""); (""Java Record"", ""defines"", ""immutable data-only classes"")"
A Java Record consist of one or more data fields which corresponds to member variables in a regular Java class.,"(""Java Record"", ""consist of"", ""data fields""); (""Java Record"", ""corresponds to"", ""member variables""); (""Java Record"", ""compared to"", ""Java class""); (""Java class"", ""has"", ""member variables""); (""data fields"", ""part of"", ""Java Record"")"
"The Java compiler auto generates getter methods, toString(), hashcode() and equals() methods for these data fields, so you don't have to write that boilerplate code yourself.","(""Java compiler"", ""auto generates"", ""getter methods""); (""Java compiler"", ""auto generates"", ""toString()""); (""Java compiler"", ""auto generates"", ""hashcode()""); (""Java compiler"", ""auto generates"", ""equals()"")"
"The Java compiler then generates the corresponding fields, getter methods and a hashCode() and equals() method.","(""Java compiler"", ""generates"", ""fields""); (""Java compiler"", ""generates"", ""getter methods""); (""Java compiler"", ""generates"", ""hashCode() method""); (""Java compiler"", ""generates"", ""equals() method"")"
You use a Java Record just like you use other Java classes - by creating instances of the record type using the Java new keyword.,"(""Java Record"", ""used by"", ""Java classes""); (""Java Record"", ""created using"", ""Java new keyword""); (""Java classes"", ""created using"", ""Java new keyword"")"
"Notice how the Java compiler has generated a brand() method, a licensePlate() method and a toString() method for us.","(""Java compiler"", ""has generated"", ""brand() method""); (""Java compiler"", ""has generated"", ""licensePlate() method""); (""Java compiler"", ""has generated"", ""toString() method"")"
"A Record type definition is final, meaning you cannot create subclasses (subrecords) of a Java Record type.","(""Record"", ""is a"", ""Java type""); (""Record"", ""cannot be subclassed by"", ""subclasses""); (""Record"", ""is defined as"", ""type definition""); (""Java Record type"", ""has property"", ""final"")"
You can add instance methods to a Java Record definition - just like you can with a regular Java class.,"(""Java Record"", ""has"", ""instance methods""); (""Java Record"", ""compared to"", ""Java class""); (""Java class"", ""has"", ""instance methods"")"
Here is an example of the Vehicle Java Record definition from earlier sections with an instance method named brandAsLowerCase() added:,"(""Vehicle"", ""hasMethod"", ""brandAsLowerCase()""); (""Vehicle"", ""isA"", ""JavaRecord""); (""brandAsLowerCase()"", ""isMethodOf"", ""Vehicle"")"
Notice how the brandAsLowerCase() method calls the auto-generated brand() method internally.,"(""brandAsLowerCase()"", ""calls"", ""brand()"")"
"That means, that even classes from different projects compiled separately, but which are used in the same application may share constant String objects.","(""Class"", ""used in"", ""Application""); (""Class"", ""compiled by"", ""Compiler""); (""Class"", ""share"", ""String""); (""Application"", ""use"", ""Class""); (""String"", ""shared by"", ""Class"")"
"As you can see, a new StringBuilder is created, passing along the first String to its constructor, and the second String to its append() method, before finally calling the toString() method.","(""StringBuilder"", ""created"", ""StringBuilder""); (""StringBuilder"", ""passes to"", ""constructor""); (""String"", ""passed to"", ""StringBuilder constructor""); (""String"", ""passed to"", ""append() method""); (""StringBuilder"", ""calls"", ""append() method""); (""StringBuilder"", ""calls"", ""toString() method""); (""append() method"", ""called by"", ""StringBuilder""); (""toString() method"", ""called by"", ""StringBuilder"")"
This code actually creates two objects: A StringBuilder instance and a new String instance returned from the toString() method.,"(""StringBuilder"", ""creates"", ""instance""); (""StringBuilder"", ""has method"", ""toString()""); (""toString()"", ""returns"", ""String""); (""StringBuilder"", ""instance has method"", ""toString()""); (""String"", ""is type of"", ""instance"")"
"The bigger the result String grows, the longer it takes to copy the characters from it into a new StringBuilder, and again copy the characters from the StringBuilder into the temporary String created by the toString() method.","(""String"", ""grows"", ""result String""); (""String"", ""copy"", ""StringBuilder""); (""StringBuilder"", ""copy"", ""temporary String""); (""StringBuilder"", ""created by"", ""toString()""); (""String"", ""created by"", ""toString()"")"
You can obtain the length of a String using the length() method.,"(""String"", ""hasMethod"", ""length()"")"
You do so using the substring() method of the String class.,"(""String"", ""has method"", ""substring()""); (""String"", ""is a"", ""class"")"
The last character in the string has has the index String.length() - 1.,"(""String"", ""has method"", ""length()""); (""String"", ""has index"", ""String.length() - 1"")"
You can search for substrings in Strings using the indexOf() method.,"(""String"", ""has method"", ""indexOf()""); (""String"", ""uses method"", ""indexOf()""); (""indexOf()"", ""is method of"", ""String"")"
The indexOf() method returns the index of where the first character in the first matching substring is found.,"(""String"", ""hasMethod"", ""indexOf()""); (""indexOf()"", ""returns"", ""index""); (""indexOf()"", ""finds"", ""substring"")"
"If the substring is not found within the string, the indexOf() method returns -1;","(""String"", ""has method"", ""indexOf()""); (""String"", ""uses method"", ""indexOf()""); (""indexOf()"", ""returns"", ""-1"")"
There is a version of the indexOf() method that takes an index from which the search is to start.,"(""indexOf()"", ""is a version of"", ""indexOf()""); (""indexOf()"", ""takes"", ""index"")"
The Java String class also has a lastIndexOf() method which finds the last occurrence of a substring.,"(""String"", ""has method"", ""lastIndexOf()""); (""String"", ""has a"", ""lastIndexOf() method""); (""Java"", ""has class"", ""String""); (""String"", ""has method"", ""lastIndexOf()""); (""lastIndexOf()"", ""is method of"", ""String"")"
"The Java String matches() method takes a regular expression as parameter, and returns true if the regular expression matches the string, and false if not.","(""String"", ""hasMethod"", ""matches()""); (""String"", ""takesParameter"", ""regular expression""); (""matches()"", ""returns"", ""true""); (""matches()"", ""returns"", ""false""); (""matches()"", ""belongsTo"", ""String"")"
The equals() method tests if two Strings are exactly equal to each other.,"(""String"", ""hasMethod"", ""equals()""); (""equals()"", ""belongsTo"", ""String""); (""String"", ""hasMethod"", ""equals()"")"
The String class also has a method called equalsIgnoreCase() which compares two strings but ignores the case of the characters.,"(""String"", ""has method"", ""equalsIgnoreCase()""); (""String"", ""compares"", ""strings""); (""equalsIgnoreCase()"", ""ignores"", ""case""); (""String"", ""has method"", ""equalsIgnoreCase()""); (""equalsIgnoreCase()"", ""compares"", ""characters"")"
The startsWith() and endsWith() methods check if the String starts with a certain substring.,"(""String"", ""hasMethod"", ""startsWith()""); (""String"", ""hasMethod"", ""endsWith()"")"
"The compareTo() method compares the String to another String and returns an int telling whether this String is smaller, equal to or larger than the other String.","(""String"", ""hasMethod"", ""compareTo()""); (""compareTo()"", ""returns"", ""int""); (""String"", ""comparesTo"", ""String"")"
"If the String is earlier in sorting order than the other String, compareTo() returns a negative number.","(""String"", ""hasMethod"", ""compareTo()""); (""compareTo()"", ""returns"", ""negative number""); (""String"", ""usesMethod"", ""compareTo()""); (""String"", ""compareTo"", ""other String"")"
"If the String is equal in sorting order to the other String, compareTo() returns 0.","(""String"", ""hasMethod"", ""compareTo()""); (""compareTo()"", ""returns"", ""0""); (""String"", ""compareTo"", ""String"")"
"If the String is after the other String in sorting order, the compareTo() metod returns a positive number.","(""String"", ""hasMethod"", ""compareTo()""); (""compareTo()"", ""returns"", ""number""); (""String"", ""usesMethod"", ""compareTo()"")"
You should be aware that the compareTo() method may not work correctly for Strings in different languages than English.,"(""String"", ""hasMethod"", ""compareTo()""); (""compareTo()"", ""belongsTo"", ""String""); (""String"", ""usedIn"", ""compareTo()"")"
The Java String class contains a method called trim() which can trim a string object.,"(""String"", ""contains"", ""trim()""); (""String"", ""has method"", ""trim()""); (""Java"", ""has class"", ""String""); (""String"", ""has method"", ""trim()""); (""String"", ""contains"", ""trim()"")"
The trim() method can be very useful to trim text typed into input fields by a user.,"(""trim()"", ""is method of"", ""String""); (""String"", ""has method"", ""trim()"")"
The trim() method is an easy way to remove such extra white space characters.,"(""String"", ""hasMethod"", ""trim()"")"
The Java String class contains a method named replace() which can replace characters in a String.,"(""String"", ""contains"", ""replace()""); (""String"", ""has method"", ""replace()""); (""Java"", ""has class"", ""String""); (""String"", ""has method"", ""replace()""); (""String"", ""contains"", ""replace()"")"
The replace() method does not actually replace characters in the existing String.,"(""String"", ""hasMethod"", ""replace()"")"
"The replace() method will replace all character matching the character passed as first parameter to the method, with the second character passed as parameter to the replace() method.","(""String"", ""hasMethod"", ""replace()""); (""replace()"", ""takesParameter"", ""character""); (""replace()"", ""takesParameter"", ""character""); (""character"", ""isParameterOf"", ""replace()"")"
The Java String replaceFirst() method returns a new String with the first match of the regular expression passed as first parameter with the string value of the second parameter.,"(""String"", ""hasMethod"", ""replaceFirst()""); (""replaceFirst()"", ""returns"", ""String""); (""String"", ""uses"", ""regular expression"")"
The Java String replaceAll() method returns a new String with all matches of the regular expression passed as first parameter with the string value of the second parameter.,"(""String"", ""hasMethod"", ""replaceAll()""); (""replaceAll()"", ""returns"", ""String""); (""String"", ""uses"", ""regular expression""); (""replaceAll()"", ""takes"", ""regular expression""); (""replaceAll()"", ""takes"", ""String"")"
The Java String class contains a split() method which can be used to split a String into an array of String objects.,"(""String"", ""contains"", ""split()""); (""String"", ""split"", ""array of String""); (""String"", ""contains"", ""split()""); (""String"", ""has method"", ""split()""); (""String"", ""split"", ""String objects""); (""String"", ""used to split"", ""array of String""); (""split()"", ""is method of"", ""String""); (""String"", ""has method"", ""split()"")"
The parameter passed to the split() method is actually a Java regular expression.,"(""String"", ""hasMethod"", ""split()""); (""split()"", ""isTypeOf"", ""Java regular expression""); (""Java"", ""hasConcept"", ""regular expression"")"
The String split() method exists in a version that takes a limit as a second parameter.,"(""String"", ""hasMethod"", ""split()""); (""String"", ""hasMethodVersion"", ""split(int)""); (""split()"", ""hasParameter"", ""limit""); (""String"", ""hasMethodParameter"", ""limit"")"
Here is a Java String split() example using the limit parameter:,"(""String"", ""hasMethod"", ""split()""); (""String"", ""belongsTo"", ""java.lang""); (""split()"", ""isMethodOf"", ""String""); (""java.lang"", ""hasClass"", ""String"")"
The Java String class contains a set of overloaded static methods named valueOf() which can be used to convert a number to a String.,"(""String"", ""contains"", ""valueOf()""); (""String"", ""has method"", ""valueOf()""); (""Java"", ""has class"", ""String""); (""String"", ""has method"", ""valueOf()""); (""String"", ""can convert"", ""number"")"
"Since all Java classes extends (inherits from) the Object class, all objects have a toString() method.","(""Object"", ""extends"", ""Java classes""); (""Object"", ""has method"", ""toString()""); (""Java classes"", ""inherits from"", ""Object""); (""Java classes"", ""has method"", ""toString()"")"
"Note: For the toString() method to return a sane String representation of the given object, the class of the object must have overridden the toString() method.","(""Object"", ""has method"", ""toString()""); (""Class"", ""must override"", ""toString()""); (""toString()"", ""is overridden by"", ""Class""); (""Object"", ""has class"", ""Class"")"
"If not, the default toString() method (inherited from the Object class) will get called.","(""Object"", ""hasMethod"", ""toString()""); (""toString()"", ""inheritedBy"", ""default toString()""); (""Object"", ""hasDefaultMethod"", ""toString()"")"
The default toString() method does not provide that much useful information.,"(""toString()"", ""is a method of"", ""Object"")"
It is possible to get a character at a certain index in a String using the charAt() method.,"(""String"", ""hasMethod"", ""charAt()"")"
You can also get the byte representation of the String method using the getBytes() method.,"(""String"", ""hasMethod"", ""getBytes()""); (""String"", ""usesMethod"", ""getBytes()"")"
The first getBytes() call return a byte representation of the String using the default character set encoding on the machine.,"(""String"", ""has method"", ""getBytes()""); (""getBytes()"", ""returns"", ""byte representation""); (""String"", ""uses"", ""default character set encoding""); (""default character set encoding"", ""is on"", ""machine"")"
The second getBytes() call return a UTF-8 byte representation of the String.,"(""String"", ""hasMethod"", ""getBytes()""); (""getBytes()"", ""returns"", ""byte representation""); (""String"", ""hasMethod"", ""getBytes()""); (""getBytes()"", ""usesEncoding"", ""UTF-8"")"
You can convert Strings to uppercase and lowercase using the methods toUpperCase() and toLowerCase().,"(""String"", ""hasMethod"", ""toUpperCase()""); (""String"", ""hasMethod"", ""toLowerCase()"")"
From Java 13 the Java String class got a new method named formatted() which can be used to return a formatted version of the String formatted() is called on.,"(""Java String class"", ""got"", ""formatted() method""); (""formatted() method"", ""is called on"", ""Java String class""); (""Java 13"", ""introduced"", ""formatted() method""); (""formatted() method"", ""returns"", ""formatted version of the String""); (""Java String class"", ""has"", ""formatted() method"")"
"The formatted() method is only a preview feature that was added together with Java Text Blocks in Java 13, so we do not yet know if it will stay in.","(""formatted()"", ""is part of"", ""Java Text Blocks""); (""formatted()"", ""added in"", ""Java 13""); (""Java Text Blocks"", ""added in"", ""Java 13"")"
Here is an example of using the Java String formatted() method:,"(""String"", ""hasMethod"", ""formatted()""); (""Java"", ""uses"", ""String""); (""String"", ""hasMethod"", ""formatted()""); (""formatted()"", ""belongsTo"", ""String""); (""Java"", ""hasClass"", ""String"")"
The parameter values passed to formatted() will be inserted into the returned String at the %s location of the input String.,"(""String"", ""hasMethod"", ""formatted()""); (""formatted()"", ""takesParameter"", ""parameter values""); (""parameter values"", ""areInsertedInto"", ""String""); (""String"", ""contains"", ""%s location"")"
"From Java 13 the Java String class got a new method named stripIndent() which can be used to strip out indentation, similarly to how indentation is stripped out of Java Text Blocks.","(""Java String"", ""got"", ""stripIndent()""); (""stripIndent()"", ""used to strip"", ""indentation""); (""Java Text Blocks"", ""have"", ""indentation""); (""Java"", ""has"", ""Java String""); (""Java String"", ""has"", ""stripIndent()""); (""Java 13"", ""introduced"", ""stripIndent()"")"
"The stripIndent() method is a preview feature, so we don't know if it will stay in Java yet.","(""stripIndent()"", ""is a method of"", ""String""); (""String"", ""has method"", ""stripIndent()"")"
Here is an example of using the new Java String stripIndent() method:,"(""Java"", ""has method"", ""String.stripIndent()""); (""String"", ""has method"", ""stripIndent()"")"
From Java 13 the Java String class got a new method called translateEscapes() which can translate escape codes that exist inside a String in the same way the Java compiler translates them.,"(""String"", ""got"", ""method""); (""String"", ""has"", ""translateEscapes()""); (""translateEscapes()"", ""translates"", ""escape codes""); (""Java"", ""compiler"", ""translates""); (""Java"", ""has"", ""String class""); (""String class"", ""exists in"", ""Java""); (""translateEscapes()"", ""exists in"", ""String class""); (""Java"", ""version"", ""Java 13"")"
"For now, the translateEscapes() is a preview feature, so it is not yet sure that it will stay in Java.","(""translateEscapes()"", ""is a part of"", ""Java"")"
Here is an example of using the Java String translateEscapes() method:,"(""String"", ""hasMethod"", ""translateEscapes()"")"
When calling the translateEscapes() method the \n part of the text will now be interpreted as a line break escape code.,"(""translateEscapes"", ""method of"", ""unknown class""); (""translateEscapes"", ""affects"", ""text""); (""unknown class"", ""has method"", ""translateEscapes""); (""text"", ""contains"", ""\n""); (""\n"", ""interpreted as"", ""line break escape code"")"
The String class has several other useful methods than the ones described in this tutorial.,"(""String"", ""has"", ""methods"")"
"The result of this is, that execution just ""falls through"" to the operation of the next case statement ( and the next etc.)",
All Java code must reside inside a file with the extension .java .,
"Below is an example .java file that contains all of the above elements, so you can see the basic syntax of a .java file:",
The .java file should be located in a directory structure that matches the package name.,"("".java file"", ""located in"", ""directory structure""); (""directory structure"", ""matches"", ""package name"")"
"Please note, that the code example does not actually use the Java HashMap class anywhere.","(""Java"", ""uses"", ""HashMap class""); (""HashMap class"", ""is part of"", ""Java""); (""Java"", ""has class"", ""HashMap"")"
Of course you should not import classes you do not use in a real project.,
"In Java a type is either a class, an abstract class an interface, an enum or an annotation.","(""Class"", ""is a type of"", ""Type""); (""Abstract Class"", ""is a type of"", ""Type""); (""Interface"", ""is a type of"", ""Type""); (""Enum"", ""is a type of"", ""Type""); (""Annotation"", ""is a type of"", ""Type"")"
A type (class / interface / enum) can have more than one field.,"(""type"", ""can have"", ""field""); (""class"", ""can have"", ""field""); (""interface"", ""can have"", ""field""); (""enum"", ""can have"", ""field"")"
The fifth line (or block of lines) is a class initializer block.,
Inside this block you can put initialization code that is to be executed a instance of the class is created.,"(""class"", ""has"", ""initialization code""); (""class"", ""executes"", ""initialization code""); (""initialization code"", ""is executed in"", ""class"")"
"Then they are executed already when the class is loaded, and only once because the class is only loaded in the Java Virtual Machine once.","(""Java Virtual Machine"", ""loads"", ""class""); (""class"", ""is loaded"", ""once""); (""Java Virtual Machine"", ""loads"", ""class once"")"
"Constructors are similar to class initializers, except they can take parameters.","(""Constructors"", ""are similar to"", ""class initializers""); (""Constructors"", ""can take"", ""parameters""); (""class initializers"", ""are compared to"", ""Constructors"")"
"A class can have more than one constructor, although this example just shows one.","(""class"", ""can have"", ""constructor""); (""class"", ""has"", ""constructor""); (""constructor"", ""is part of"", ""class""); (""class"", ""contains"", ""constructor"")"
When you create an instance of a class (an object) the object can have methods you can execute.,"(""Class"", ""has"", ""Methods""); (""Object"", ""can have"", ""Methods""); (""Object"", ""is an instance of"", ""Class"")"
"A static method belongs to the class, not objects of the class.","(""Method"", ""belongs to"", ""Class"")"
That means that you can call a static method without having an object of the class the static method belongs to.,"(""Class"", ""has"", ""static method""); (""static method"", ""belongs to"", ""Class""); (""Class"", ""has"", ""object"")"
"In the example above, if case.equals(""uppercase"") evaluates to true then the ternary operator expression as a whole returns the String value JOHN.","(""case"", ""equals"", ""uppercase""); (""String"", ""value"", ""JOHN""); (""ternary operator"", ""returns"", ""String"")"
"If case.equals(""uppercase"") evaluates to false then the ternary operator expression as a whole returns the String value john.","(""case"", ""equals"", ""uppercase""); (""case.equals(uppercase)"", ""evaluates to"", ""false""); (""ternary operator expression"", ""returns"", ""String value""); (""ternary operator expression"", ""returns"", ""john"")"
"That means, that the String variable name will end up having the value JOHN or john depending on whether the expression case.equals(""uppercase"") evaluates to true or false.","(""String"", ""has variable"", ""name""); (""String"", ""has method"", ""equals()""); (""case"", ""has method"", ""equals()""); (""name"", ""has value"", ""JOHN""); (""name"", ""has value"", ""john""); (""String"", ""has value"", ""uppercase"")"
"As you can see, both of these code examples avoid calling object.getValue() if the object reference is null, but the first code example is a bit shorter and more elegant.","(""object"", ""hasMethod"", ""getValue()""); (""object"", ""hasReference"", ""null"")"
You can achieve the same functionality as the Java Math max() function using a Java ternary operator.,"(""Math"", ""hasFunction"", ""max()""); (""Java"", ""hasOperator"", ""ternary operator""); (""Java"", ""hasFunction"", ""Math.max()""); (""Math"", ""isPartOf"", ""Java"")"
Here is an example of achieving the Math.max() functionality using a Java ternary operator:,"(""Math"", ""uses"", ""Java""); (""Java"", ""has operator"", ""ternary operator""); (""Math"", ""has method"", ""Math.max()""); (""Java"", ""has method"", ""Math.max()""); (""Math.max()"", ""is achieved using"", ""ternary operator"")"
The Java ternary operator can also be used to achieve the same effect as the Java Math min() function.,"(""Java ternary operator"", ""can be used to achieve the same effect as"", ""Java Math min() function""); (""Java Math min() function"", ""has the same effect as"", ""Java ternary operator"")"
Here is an example of achieving the Math.min() functionality using a Java ternary operator:,"(""Math"", ""uses"", ""Java""); (""Java"", ""has operator"", ""ternary operator""); (""Math"", ""has method"", ""Math.min()"")"
The Java ternary operator can also be used to achieve the same effect as the Java Math abs() function.,"(""Java ternary operator"", ""can be used to achieve the same effect as"", ""Java Math abs() function""); (""Java Math abs() function"", ""is equivalent to"", ""Java ternary operator""); (""Java"", ""contains"", ""Java ternary operator""); (""Java"", ""contains"", ""Java Math abs() function""); (""Java Math"", ""contains"", ""Java Math abs() function"")"
Here is an example of achieving the Math.abs() functionality using a Java ternary operator:,"(""Math"", ""uses"", ""Java""); (""Java"", ""has operator"", ""ternary operator""); (""Math"", ""has method"", ""Math.abs()""); (""Java"", ""supports"", ""Math.abs()""); (""ternary operator"", ""achieves functionality of"", ""Math.abs()"")"
"If the input String is not equal to the empty String, the second ternary operator returns the value of Integer.parseInt(input) .","(""String"", ""is not equal to"", ""empty String""); (""Integer"", ""parseInt"", ""input""); (""String"", ""returns"", ""Integer"")"
"This can be any kind of information ranging from texts, codes (e.g.",
"In the code example below, the main() method contains the declaration of a single integer variable named number.","(""main"", ""contains"", ""integer variable""); (""main"", ""declares"", ""number""); (""integer variable"", ""isNamed"", ""number""); (""main"", ""methodContains"", ""variable declaration"")"
"Non-static fields are also called instance variables, because they belong to instances (objects) of a class.","(""Non-static fields"", ""belong to"", ""instances""); (""Non-static fields"", ""are called"", ""instance variables""); (""instances"", ""are objects of"", ""a class""); (""instance variables"", ""belong to"", ""instances""); (""instances"", ""are objects of"", ""a class""); (""Non-static fields"", ""are also called"", ""instance variables""); (""instance variables"", ""are also called"", ""non-static fields"")"
A static field is a variable that belongs to a class.,"(""static field"", ""belongs to"", ""class"")"
The second line assigns the floating point value 199.99 to the floating point variable named myFloat.,
"In this example, only the first System.out.println() statement is executed inside the while loop.","(""System.out"", ""hasMethod"", ""println()""); (""while loop"", ""contains"", ""System.out.println()""); (""System.out.println()"", ""isExecutedInside"", ""while loop"")"
The second System.out.println() statement is not executed until after the while loop is finished.,"(""System"", ""contains"", ""out""); (""System.out"", ""contains"", ""println""); (""while loop"", ""finishes before"", ""System.out.println""); (""System.out.println"", ""is executed after"", ""while loop"")"
"This is typically done via a command line interface (CLI), like e.g.",
On the command line you tell the JVM what Java class (bytecode) to execute.,"(""JVM"", ""execute"", ""Java class"")"
Only the full Java SDK contains the Java compiler which turns your .java source files into byte code .class files.,"(""Java SDK"", ""contains"", ""Java compiler""); (""Java compiler"", ""turns"", "".java source files""); (""Java compiler"", ""turns"", "".class files""); ("".java source files"", ""turned into"", "".class files""); (""Java compiler"", ""produces"", "".class files""); (""Java SDK"", ""includes"", ""Java compiler"")"
"Additionally, some Java servers may need some of the tools in the JDK to e.g.","(""JDK"", ""contains"", ""tools""); (""Java servers"", ""need"", ""tools""); (""JDK"", ""includes"", ""Java servers"")"
"The Java Code Conventions are a set of conventions for how to format your Java code, and how to name classes, variables, files etc.","(""Java Code Conventions"", ""are_for"", ""formatting Java code""); (""Java Code Conventions"", ""are_for"", ""naming classes""); (""Java Code Conventions"", ""are_for"", ""naming variables""); (""Java Code Conventions"", ""are_for"", ""naming files"")"
JavaFX was inspired by Flex (Flash) and Silverlight for .NET (Microsoft).,"(""JavaFX"", ""was inspired by"", ""Flex""); (""Flex"", ""is related to"", ""Flash""); (""JavaFX"", ""was inspired by"", ""Silverlight""); (""Silverlight"", ""is related to"", "".NET""); ("".NET"", ""is developed by"", ""Microsoft"")"
In this tutorial I will show you how to make your first Java app with IntelliJ IDEA community edition (free) version 2019.3.3.,"(""IntelliJ IDEA"", ""hasVersion"", ""2019.3.3""); (""IntelliJ IDEA"", ""hasEdition"", ""community edition""); (""Java"", ""usedIn"", ""app"")"
"How you do that depends on what operating system you are running (Windows, Mac, Linux etc.)",
"A Java package is just a directory inside which you can put one or more Java files (class, interface, annotation, enum etc.","(""Java package"", ""contains"", ""Java files""); (""Java files"", ""includes"", ""class""); (""Java files"", ""includes"", ""interface""); (""Java files"", ""includes"", ""annotation""); (""Java files"", ""includes"", ""enum"")"
Now you must create a new class inside your newly created package.,"(""class"", ""inside"", ""package"")"
"In the dialog that opens, type in a name for your new Java class.","(""Java"", ""has"", ""class"")"
"It is custom to have class names start with an uppercase character followed by lowercase characters, and a new uppercase character for each new word in the class name.","(""Class"", ""has naming convention"", ""UpperCaseCharacter""); (""UpperCaseCharacter"", ""followed by"", ""LowerCaseCharacters""); (""Class"", ""contains"", ""NewUpperCaseCharacter""); (""NewUpperCaseCharacter"", ""indicates"", ""NewWord"")"
"When you have typed in a name for your new Java class, click the ""OK"" button.","(""Java class"", ""has method"", ""constructor""); (""Java class"", ""has relationship"", ""OK button""); (""OK button"", ""is part of"", ""Java class creation""); (""Java class"", ""is created using"", ""Java"")"
"Once you have created the new class, it will be empty.","(""class"", ""created"", ""new class""); (""new class"", ""will be"", ""empty""); (""class"", ""have"", ""new class"")"
The part inside the /* ... */ are comments and are not part of the executed Java code.,
Before you can run your Java app you need to insert a main() method into the class.,"(""Java app"", ""has"", ""main() method""); (""main() method"", ""inserted into"", ""class""); (""class"", ""contains"", ""main() method"")"
Now your are ready to run your newly created Java class.,
"You do so by right clicking the class source code in the editor, and choose ""Run..."", like this:",
"When you click the ""Run..."" option, IntelliJ IDEA will first compile your Java class, and then run it.","(""IntelliJ IDEA"", ""compile"", ""Java class""); (""IntelliJ IDEA"", ""run"", ""Java class"")"
"After you have executed the Java class main method, you will see an output at the bottom of the IntelliJ IDEA window similar to this:","(""Java"", ""has method"", ""main""); (""main"", ""is part of"", ""Java class""); (""IntelliJ IDEA"", ""has window"", ""output window""); (""Java class"", ""has method"", ""main""); (""IntelliJ IDEA"", ""displays"", ""output"")"
"Don't worry if you don't yet understand what a main() method is, or classes, or packages.","(""main() method"", ""is part of"", ""classes""); (""classes"", ""are organized in"", ""packages""); (""main() method"", ""is part of"", ""packages"")"
The most common way of using the Java Logging API is to create a Logger in each class that needs to log.,"(""Java Logging API"", ""is used by"", ""Logger""); (""Logger"", ""is created in"", ""class""); (""Class"", ""needs to log"", ""Java Logging API""); (""Logger"", ""is part of"", ""Java Logging API"")"
"This instance is typically made static and final, meaning all instances of that class use the same Logger instance.","(""Logger"", ""isUsedBy"", ""class""); (""Logger"", ""isMade"", ""static""); (""Logger"", ""isMade"", ""final""); (""class"", ""uses"", ""Logger"")"
"As you can see from this example, it is common practice to use the class name including package name as name for the Logger.","(""Logger"", ""uses"", ""class name""); (""class name"", ""includes"", ""package name""); (""Logger"", ""uses"", ""package name"")"
The name of the Logger to create is passed as string parameter to the Logger.getLogger() method.,"(""Logger"", ""hasMethod"", ""getLogger()""); (""String"", ""passedTo"", ""Logger.getLogger()""); (""Logger"", ""createdBy"", ""Logger.getLogger()"")"
"For instance, ordinary debug trace logging calls to entering() and exiting() would be called at the beginning and end of a method call.","(""entering()"", ""called at"", ""beginning of a method call""); (""exiting()"", ""called at"", ""end of a method call"")"
The initialization of the configuration is taken care of by the java.util.logging.LogManager class.,"(""java.util.logging.LogManager"", ""takes care of"", ""initialization of the configuration"")"
You can use a Java class to configure the Java Logging API.,"(""Java"", ""uses"", ""Java Logging API""); (""Java class"", ""configures"", ""Java Logging API"")"
You do so by specifying the name of the class in the JVM parameter java.util.logging.config.class.,"(""java.util.logging.config.class"", ""specified in"", ""JVM parameter""); (""JVM parameter"", ""has class"", ""java.util.logging.config.class"")"
It is the constructor of that class that should load the configuration and apply it to the Logger's in the hierarchy.,"(""constructor"", ""loads"", ""configuration""); (""configuration"", ""is applied to"", ""Logger""); (""Logger"", ""is in"", ""hierarchy"")"
"If no configuration class is specified, you can instead specify a configuration file (but no configuration class can be specified then!","(""configuration class"", ""is specified"", ""configuration file""); (""configuration class"", ""cannot be specified with"", ""configuration file"")"
"The Java Logging API has a default logging configuration file located at ""lib/logging.properties"", inside the JRE directory.","(""Java Logging API"", ""has"", ""default logging configuration file""); (""default logging configuration file"", ""located at"", ""lib/logging.properties""); (""lib/logging.properties"", ""inside"", ""JRE directory""); (""JRE directory"", ""contains"", ""lib/logging.properties""); (""Java Logging API"", ""uses"", ""default logging configuration file"")"
You do so by setting the JVM property java.util.logging.config.file to point to this file.,"(""java.util.logging"", ""has property"", ""java.util.logging.config.file""); (""JVM"", ""has property"", ""java.util.logging.config.file""); (""java.util.logging.config.file"", ""is set to"", ""file"")"
You should double check the JavaDoc over time to see if any of this changes (e.g.,
"If the isLoggable() method returns false, the LogRecord is not logged.","(""LogRecord"", ""is logged by"", ""isLoggable()""); (""isLoggable()"", ""returns"", ""boolean""); (""LogRecord"", ""is checked by"", ""isLoggable()"")"
The Handler's in the Java Logging API use a java.util.logging.Formatter to format the LogRecord's before writing it to an external system.,"(""Handler"", ""uses"", ""Formatter""); (""Formatter"", ""formats"", ""LogRecord""); (""Handler"", ""writes to"", ""external system""); (""LogRecord"", ""is written by"", ""Handler"")"
"The various Handler's in the Java Logging API use either of these two Formatter's by default, but you can also set your own custom Formatter subclass on a Handler.","(""Handler"", ""use"", ""Formatter""); (""Formatter"", ""subclass"", ""custom Formatter""); (""Handler"", ""set"", ""custom Formatter"")"
You can create your own Formatter by subclassing the java.util.logging.Formatter class.,"(""Formatter"", ""subclassing"", ""java.util.logging.Formatter""); (""java.util.logging.Formatter"", ""is a"", ""Formatter"")"
The subclass must override the abstract format() method in the Formatter class.,"(""Formatter"", ""has method"", ""format()""); (""subclass"", ""overrides"", ""format()""); (""Formatter"", ""has subclass"", ""subclass"")"
The String returned by the format() is what is forwarded to the external system by the Handler.,"(""String"", ""returned by"", ""format()""); (""format()"", ""returned to"", ""Handler""); (""Handler"", ""forwards"", ""external system""); (""String"", ""forwarded to"", ""external system"")"
The Formatter class also contains the convenience method formatMessage() which can be used to format the message using the ResourceBundle of the LogRecord.,"(""Formatter"", ""contains"", ""formatMessage()""); (""formatMessage()"", ""uses"", ""ResourceBundle""); (""LogRecord"", ""has"", ""ResourceBundle"")"
By default the ConsoleHandler uses a SimpleFormatter to format the messages before writing them to System.err.,"(""ConsoleHandler"", ""uses"", ""SimpleFormatter""); (""ConsoleHandler"", ""writes to"", ""System.err""); (""SimpleFormatter"", ""formats"", ""messages"")"
"If no %g code has been specified and the file count of the FileHandler is greater than 1, then the generation number (file sequence number) will be appended to the end of the file name, after a dot (.)","(""FileHandler"", ""has"", ""file count""); (""FileHandler"", ""appends"", ""generation number""); (""generation number"", ""is appended to"", ""file name""); (""file name"", ""has"", ""dot (.)""); (""dot (%g code)"", ""is optional in"", ""file name""); (""FileHandler"", ""uses"", ""file sequence number""); (""generation number"", ""is same as"", ""file sequence number"")"
You must set one using the method setOutputStream() before using the handler.,"(""setOutputStream()"", ""is a method of"", ""handler"")"
You can also call the push() method to force the LogRecord's in the buffer to be flushed to the target Handler.,"(""LogRecord"", ""has method"", ""push()""); (""Handler"", ""receives"", ""LogRecord"")"
This class contains a constant for each of the above log levels.,
When you create a Logger you pass a name to the Logger.getLogger() method.,"(""Logger"", ""hasMethod"", ""Logger.getLogger()""); (""Logger.getLogger()"", ""takesParameter"", ""name"")"
(Note: These levels are different from the log levels of the messages logged.).,
If you call getParent() on that Logger you will get the Logger with the name com.,"(""Logger"", ""getParent()"", ""Logger""); (""Logger"", ""hasName"", ""com"")"
"... and call getParent() method, you will get the Logger with the name """".","(""Logger"", ""hasMethod"", ""getParent()""); (""getParent()"", ""returns"", ""Logger"")"
"The third message is being logged three times: Once by the 1.2 Logger, once by the 1 Logger, and once by the root Logger.",
"Notice though, that the message propagated up the hierarchy from the Logger named 1.2 is still logged by the middle Logger, and still forwarded up to the root Logger.","(""Logger"", ""named"", ""1.2""); (""Logger"", ""propagated up"", ""hierarchy""); (""message"", ""logged by"", ""middle Logger""); (""message"", ""forwarded up to"", ""root Logger""); (""Logger"", ""logged by"", ""middle Logger""); (""Logger"", ""forwarded up to"", ""root Logger""); (""message"", ""propagated up"", ""hierarchy"")"
"Another peculiar result of the above code is, that the INFO message passed to the bottom Logger (named 1.2) is also ignored, and not propagated.",
"In order to enable all INFO messages to be logged from the bottom Logger (named 1.2), even if the middle Logger has a log level of WARNING, we add the following to the code (in bold):",
"The result of this code is that the INFO message logged on the bottom Logger (named 1.2) is now logged, but it is still not propagated up the hierarchy.","(""Logger"", ""hasMessage"", ""INFO""); (""Logger"", ""isLocatedAt"", ""bottom""); (""INFO"", ""isLoggedBy"", ""Logger""); (""Logger"", ""hasHierarchy"", ""hierarchy"")"
The java.util.Logger class is the main access point to the Java logging API.,"(""java.util.Logger"", ""is access point to"", ""Java logging API"")"
The string passed as parameter to the getLogger() factory method is the name of the Logger to create.,"(""Logger"", ""created by"", ""getLogger()""); (""getLogger()"", ""takes parameter"", ""string""); (""Logger"", ""has name"", ""string"")"
"The two names ""myApp.user"" and ""myApp.admin"" are children of the ""myApp"" name.","(""myApp.user"", ""is child of"", ""myApp""); (""myApp.admin"", ""is child of"", ""myApp"")"
"The name ""myApp.admin.import.user"" is a branch of the name ""myApp.admin.import"", which is again a branch of the ""myApp.admin"" name.","(""myApp.admin.import.user"", ""is a branch of"", ""myApp.admin.import""); (""myApp.admin.import"", ""is a branch of"", ""myApp.admin"")"
"You can obtain the name of a Logger using the getName() method, in case you need it.","(""Logger"", ""hasMethod"", ""getName()"")"
"It is convention to use the class name of the class creating the Logger, including package name, as name for the Logger.","(""Logger"", ""is created by"", ""class""); (""class"", ""has package name"", ""package name""); (""package name"", ""is part of"", ""Logger""); (""Logger"", ""uses"", ""class name""); (""class name"", ""includes"", ""package name"")"
The log() group of methods will log a message at a certain log level.,"(""log()"", ""is part of"", ""group of methods""); (""log()"", ""logs"", ""message""); (""log()"", ""has"", ""log level"")"
"As mentioned earlier, the number inside the token refers to the index of the object parameter to insert, in the object parameter array passed to the log() message.","(""log()"", ""parameter"", ""object""); (""object"", ""array"", ""parameter""); (""log()"", ""message"", ""object""); (""object"", ""parameter"", ""array""); (""log()"", ""parameter"", ""index"")"
"The logp() methods work like the log() methods, except each method take an extra two parameters: The sourceClass and sourceMethod parameter.","(""logp()"", ""works like"", ""log()""); (""logp()"", ""takes"", ""sourceClass""); (""logp()"", ""takes"", ""sourceMethod""); (""log()"", ""takes parameters"", ""parameters""); (""logp()"", ""takes extra parameters"", ""parameters"")"
These two parameters are intended to tell from what class and method the log message originated.,"(""Class"", ""hasMethod"", ""Method""); (""Method"", ""originatesFrom"", ""Class""); (""LogMessage"", ""originatesFrom"", ""Class""); (""LogMessage"", ""originatesFrom"", ""Method"")"
"In other words, which class and method was the ""source"" of the log message.",
"The logrb() methods work like the log() methods too, except they can obtain the log messages from a resource bundle.","(""logrb()"", ""work like"", ""log()""); (""logrb()"", ""obtain from"", ""resource bundle""); (""log()"", ""work like"", ""logrb()"")"
This example looks up a message in the resource bundle named resources.myresources by the key key1.,"(""Message"", ""looks up in"", ""resources.myresources""); (""resources.myresources"", ""contains key"", ""key1"")"
"For instance, finest(), finer(), fine(), info(), warning() and severe() each corresponds to one of the log levels.","(""finest()"", ""corresponds to"", ""log levels""); (""finer()"", ""corresponds to"", ""log levels""); (""fine()"", ""corresponds to"", ""log levels""); (""info()"", ""corresponds to"", ""log levels""); (""warning()"", ""corresponds to"", ""log levels""); (""severe()"", ""corresponds to"", ""log levels"")"
Logging message using one of these methods corresponds to calling the log() method,"(""log() method"", ""corresponds to calling"", ""log() method"")"
You can add Handler's to the Logger using the addHandler() method.,"(""Logger"", ""has method"", ""addHandler()""); (""Logger"", ""uses"", ""Handler""); (""Handler"", ""is added by"", ""addHandler()"")"
"You can obtain all Handler's of a Logger using the getHandlers() method, like this:","(""Logger"", ""uses"", ""getHandlers()""); (""getHandlers()"", ""returns"", ""Handler""); (""Logger"", ""has"", ""Handler"")"
"You set the Filter on a Logger using the setFilter() method, like this:","(""Logger"", ""uses"", ""Filter""); (""Logger"", ""has method"", ""setFilter()"")"
The class MyFilterImpl should be your own implementation of the Filter interface.,"(""MyFilterImpl"", ""implements"", ""Filter"")"
"You can obtain the Filter in use by calling the getFilter() method, like this:","(""getFilter()"", ""called by"", ""Filter"")"
"This example sets the minimum log level of messages to be forwarded, to Level.INFO.","(""Level"", ""hasValue"", ""INFO""); (""Level"", ""setsMinMaxLogLevel"", ""messages"")"
You can obtain the log level of a Logger using the getLevel() method:,"(""Logger"", ""uses"", ""getLevel()""); (""Logger"", ""has method"", ""getLevel()""); (""getLevel()"", ""belongs to"", ""Logger"")"
You can obtain the parent Logger of a given Logger using the getParent() method.,"(""Logger"", ""has method"", ""getParent()""); (""Logger"", ""has parent"", ""Logger"")"
You can check if a Logger forwards log messages to its parent Logger using the method getUseParentHandlers().,"(""Logger"", ""hasMethod"", ""getUseParentHandlers()""); (""Logger"", ""uses"", ""parent Logger""); (""getUseParentHandlers()"", ""belongsTo"", ""Logger"")"
The Logger class has a few more methods that I haven't covered here.,"(""Logger"", ""has"", ""methods"")"
"The java.util.logging.LogManager manages the internal Logger hierarchy, and initiates the configuration of the Logger's, either through the configuration class or configuration file.","(""LogManager"", ""manages"", ""Logger""); (""LogManager"", ""initiates configuration of"", ""Logger""); (""LogManager"", ""uses"", ""configuration class""); (""LogManager"", ""uses"", ""configuration file""); (""Logger"", ""is configured by"", ""configuration class""); (""Logger"", ""is configured by"", ""configuration file"")"
"The first method on the LogManager simply re-reads the configuration from file (or class), in case these has changed.","(""LogManager"", ""hasMethod"", ""re-reads configuration""); (""LogManager"", ""readsFrom"", ""file""); (""LogManager"", ""readsFrom"", ""class"")"
You can also get access to an MXBean (Java Management Extensions) from the LogManager using the method getLoggingMXBean().,"(""LogManager"", ""getLoggingMXBean"", ""MXBean""); (""MXBean"", ""accessed from"", ""LogManager"")"
"The LogRecord contains the following getter methods, which can be used in e.g.","(""LogRecord"", ""contains"", ""getter methods"")"
The getLevel() method returns the log level the message represented by this LogRecord was logged with.,"(""LogRecord"", ""has method"", ""getLevel()""); (""getLevel()"", ""returns"", ""log level"")"
The getLoggerName() method returns the name of the Logger that logged this LogRecord.,"(""LogRecord"", ""hasMethod"", ""getLoggerName()""); (""getLoggerName()"", ""returns"", ""Logger""); (""LogRecord"", ""hasLogger"", ""Logger"")"
The getMillis() method returns the time in milliseconds this LogRecord was recorded.,"(""LogRecord"", ""has method"", ""getMillis()""); (""getMillis()"", ""returns"", ""time in milliseconds""); (""LogRecord"", ""was recorded at"", ""time in milliseconds"")"
The getParameters() method returns the parameters to be inserted into the message of this LogRecord.,"(""LogRecord"", ""has method"", ""getParameters()""); (""getParameters()"", ""returns"", ""parameters""); (""LogRecord"", ""contains"", ""message""); (""parameters"", ""inserted into"", ""message"")"
The getResourceBundle() method returns the ResourceBundle (if any) used to localize the message of this LogRecord.,"(""LogRecord"", ""uses"", ""ResourceBundle""); (""LogRecord"", ""has method"", ""getResourceBundle()""); (""getResourceBundle()"", ""returns"", ""ResourceBundle"")"
The getResourceBundleName() method returns the name of the ResourceBundle (if any) used to localize the message of this LogRecord.,"(""LogRecord"", ""uses"", ""ResourceBundle""); (""LogRecord"", ""has method"", ""getResourceBundleName()""); (""getResourceBundleName()"", ""returns"", ""ResourceBundle name"")"
The getSequenceNumber() method returns a sequence number generated internally in the LogRecord constructor when the LogRecord is created.,"(""LogRecord"", ""has method"", ""getSequenceNumber()""); (""LogRecord"", ""has constructor"", ""LogRecord""); (""getSequenceNumber()"", ""returns"", ""sequence number""); (""LogRecord"", ""generates"", ""sequence number"")"
The getSourceClassName() returns the class name of the class logging the message represented by this LogRecord.,"(""LogRecord"", ""has method"", ""getSourceClassName()""); (""getSourceClassName()"", ""returns"", ""class name""); (""LogRecord"", ""logs"", ""message"")"
The getSourceMethodName() returns the method name of the method logging the message represented by this LogRecord.,"(""LogRecord"", ""hasMethod"", ""getSourceMethodName()""); (""getSourceMethodName()"", ""returns"", ""method name""); (""LogRecord"", ""represents"", ""message""); (""message"", ""isLoggedBy"", ""method"")"
The getThreadID() method returns the ID of the thread logging the message represented by this LogRecord.,"(""LogRecord"", ""has method"", ""getThreadID()""); (""getThreadID()"", ""returns"", ""ID""); (""LogRecord"", ""represents"", ""message""); (""message"", ""is logged by"", ""thread""); (""LogRecord"", ""contains"", ""thread ID""); (""getThreadID()"", ""belongs to"", ""LogRecord"")"
The getThrown() method returns the Throwable that was marked thrown when logging the message represented by this LogRecord.,"(""LogRecord"", ""has method"", ""getThrown()""); (""getThrown()"", ""returns"", ""Throwable""); (""LogRecord"", ""logs"", ""message"")"
In this text I will try to give you an overview of the java.util.logging API.,"(""java.util.logging"", ""isPartOf"", ""Java""); (""Java"", ""hasAPI"", ""java.util.logging"")"
This tutorial is about Javas built-in logging API in the java.util.logging package.,"(""Java"", ""has API"", ""logging API""); (""logging API"", ""is in package"", ""java.util.logging""); (""Java"", ""has package"", ""java.util.logging"")"
"Note: This tutorial does not cover the other popular Java logging API's (Log4J, SLF4J, Apache Commons Logging, LogBack etc.).","(""Log4J"", ""is a"", ""Java logging API""); (""SLF4J"", ""is a"", ""Java logging API""); (""Apache Commons Logging"", ""is a"", ""Java logging API""); (""LogBack"", ""is a"", ""Java logging API"")"
"If you can choose your own logging API freely, you may choose one of these other, popular logging API's instead of java.util.logging.","(""java.util.logging"", ""is alternative to"", ""other logging API's""); (""other logging API's"", ""are alternatives to"", ""java.util.logging"")"
"However, if you are running your web applications on Google App Engine, like I do, then you have to use the java.util.logging API.","(""Google App Engine"", ""uses"", ""java.util.logging API""); (""java.util.logging API"", ""is used by"", ""Google App Engine"")"
Instances of this class are used together with UDP DatagramSockets and normal Socket's and ServerSocket's.,"(""Datetime"", ""used with"", ""UDP DatagramSockets""); (""Datetime"", ""used with"", ""Socket""); (""Datetime"", ""used with"", ""ServerSocket"")"
The InetAddress class has a lot of additional methods you can use.,"(""InetAddress"", ""has"", ""methods"")"
"For instance, you can obtain the IP address as a byte array by calling getAddress() etc.","(""inetAddress"", ""calling"", ""getAddress()"")"
"To learn more about these methods, it is easier to read the JavaDoc for the InetAddress class though.","(""InetAddress"", ""hasJavaDoc"", ""JavaDoc""); (""JavaDoc"", ""isReadBy"", ""developer""); (""InetAddress"", ""isPartOf"", ""Java""); (""JavaDoc"", ""describes"", ""InetAddress"")"
Java's JarURLConnection class is used to connect to a Java Jar file.,"(""JarURLConnection"", ""used to connect to"", ""Java Jar file""); (""Java"", ""has class"", ""JarURLConnection""); (""JarURLConnection"", ""connects to"", ""Java Jar file"")"
"Of course, sometimes this protocol is already have been decided for you, e.g.",
Sending the header in a separate roundtrip (the first) can be smart if the server can do some initial pre-validation of e.g.,
"In order to implement a Java server that listens for incoming connections from clients via TCP/IP, you need to use a java.net.ServerSocket .","(""ServerSocket"", ""uses"", ""TCP/IP""); (""ServerSocket"", ""listens for"", ""connections""); (""ServerSocket"", ""is part of"", ""java.net"")"
"In case you prefer to use Java NIO instead of Java Networking (standard API), then you can also use a ServerSocketChannel instead of the java.net.ServerSocket.","(""ServerSocketChannel"", ""is alternative to"", ""ServerSocket""); (""ServerSocketChannel"", ""uses"", ""Java NIO""); (""ServerSocket"", ""uses"", ""Java Networking"")"
In order to accept incoming connections you must call the ServerSocket.accept() method.,"(""ServerSocket"", ""has method"", ""accept()""); (""ServerSocket.accept()"", ""called by"", ""incoming connections""); (""ServerSocket"", ""accepts"", ""incoming connections""); (""ServerSocket.accept()"", ""is called by"", ""application""); (""application"", ""uses"", ""ServerSocket""); (""ServerSocket"", ""used for"", ""incoming connections""); (""ServerSocket.accept()"", ""handles"", ""incoming connections"")"
The accept() method returns a Socket which behaves like an ordinary Java Socket.,"(""accept()"", ""returns"", ""Socket""); (""Socket"", ""behaves like"", ""Java Socket"")"
Only one incoming connection is opened for each call to the accept() method.,"(""accept() method"", ""is called by"", ""each call""); (""each call"", ""opens"", ""one incoming connection""); (""one incoming connection"", ""is opened for"", ""each call to the accept() method""); (""accept() method"", ""is used for"", ""incoming connection""); (""incoming connection"", ""is associated with"", ""accept() method"")"
"Additionally, incoming connections can only be accepted while the thread running the server has called accept().","(""Server"", ""has method"", ""accept()""); (""Server"", ""runs on"", ""Thread""); (""Thread"", ""calls"", ""accept()""); (""Server"", ""accepts"", ""connections""); (""accept()"", ""is called by"", ""Thread"")"
"In order to connect to a server over the internet (via TCP/IP) in Java, you need to create a java.net.Socket and connect it to the server.","(""Java"", ""uses"", ""TCP/IP""); (""Java"", ""uses"", ""java.net.Socket""); (""java.net.Socket"", ""connects to"", ""server"")"
This code example connects to the server with IP address 78.46.84.171 on port 80.,
"Don't forget to call flush() when you really, really want the data sent across the internet to the server.","(""flush()"", ""called by"", ""user""); (""flush()"", ""sends data to"", ""server"")"
The getByName() method returns an InetAddress instance with the IP address matching the given host name.,"(""InetAddress"", ""returned by"", ""getByName()""); (""getByName()"", ""returns"", ""InetAddress""); (""InetAddress"", ""has"", ""IP address"")"
Receiving data via a DatagramSocket is done by first creating a DatagramPacket and then receiving data into it via the DatagramSocket's receive() method.,"(""DatagramSocket"", ""has method"", ""receive()""); (""DatagramPacket"", ""used for"", ""receiving data""); (""DatagramSocket"", ""uses"", ""DatagramPacket""); (""DatagramSocket"", ""receives"", ""data""); (""DatagramPacket"", ""receives"", ""data""); (""receive()"", ""belongs to"", ""DatagramSocket"")"
"A real server program would probably call the receive() method in a loop, and pass all received DatagramPacket's to a pool of worker threads, just like a TCP server does with incoming connections (see Java Multithreaded Servers for more details).","(""DatagramPacket"", ""received by"", ""receive()""); (""receive()"", ""called by"", ""server program""); (""server program"", ""uses"", ""worker threads""); (""worker threads"", ""handle"", ""DatagramPacket""); (""TCP server"", ""handles"", ""incoming connections"")"
The java.net package contains two interesting classes: The URL class and the URLConnection class.,"(""java.net"", ""contains"", ""URL""); (""java.net"", ""contains"", ""URLConnection"")"
These classes can be used to create client connections to web servers (HTTP servers).,"(""Client"", ""connects to"", ""Web Server""); (""Client"", ""uses"", ""HTTP""); (""HTTP"", ""is type of"", ""Web Server"")"
"If you want to send an HTTP POST request instead, call the URLConnection.setDoOutput(true) method, like this:","(""URLConnection"", ""hasMethod"", ""setDoOutput(true)""); (""URLConnection"", ""setDoOutput"", ""true""); (""URLconnection"", ""callMethod"", ""setDoOutput()"")"
The URL class can also be used to access files in the local file system.,"(""URL"", ""can be used to access"", ""files""); (""URL"", ""used to access"", ""local file system""); (""URL"", ""access"", ""local file system"")"
"Thus the URL class can be a handy way to open a file, if you need your code to not know whether the file came from the network or local file system.","(""URL"", ""can be used to open"", ""file""); (""URL"", ""can open from"", ""network""); (""URL"", ""can open from"", ""local file system"")"
Here is an example of how to open a file in the local file system using the URL class:,"(""URL"", ""uses"", ""local file system""); (""URL"", ""has method"", ""open""); (""open"", ""belongs to"", ""URL""); (""local file system"", ""is accessed by"", ""URL""); (""URL"", ""interacts with"", ""file""); (""file"", ""is located in"", ""local file system"")"
"Notice how the only difference from accessing a file on a web server via HTTP is the the URL: ""file:/c:/data/test.txt"".",
"Even though the Java Networking APIs enable you to open and close network connections via sockets, all communication happens via the Java IO classes InputStream and OutputStream.","(""Java Networking APIs"", ""enable"", ""network connections""); (""Java Networking APIs"", ""use"", ""sockets""); (""Java IO classes"", ""include"", ""InputStream""); (""Java IO classes"", ""include"", ""OutputStream""); (""InputStream"", ""handle"", ""communication""); (""OutputStream"", ""handle"", ""communication""); (""sockets"", ""establish"", ""network connections"")"
Alternatively you can use the networking classes in the Java NIO API.,"(""Java NIO API"", ""contains"", ""networking classes"")"
"These classes are similar to the classes found in the Java Networking API, except the Java NIO API can work in non-blocking mode.","(""Java Networking API"", ""similar to"", ""Java NIO API""); (""Java NIO API"", ""can work in mode"", ""non-blocking mode"")"
The first parameter to the open() method is a Path instance pointing to the file the AsynchronousFileChannel is to be associated with.,"(""AsynchronousFileChannel"", ""associated with"", ""Path""); (""Path"", ""passed to"", ""open()""); (""open()"", ""called on"", ""AsynchronousFileChannel"")"
In this example we used the StandardOpenOption.READ which means that the file will be opened for reading.,"(""StandardOpenOption"", ""hasoption"", ""READ"")"
Each way to read data call one of the read() methods of the AsynchronousFileChannel.,"(""AsynchronousFileChannel"", ""has method"", ""read()"")"
The first way to read data from an AsynchronousFileChannel is to call the read() method that returns a Future.,"(""AsynchronousFileChannel"", ""has method"", ""read()""); (""read()"", ""returns"", ""Future"")"
This version of the read() method takes ByteBuffer as first parameter.,"(""read()"", ""takes"", ""ByteBuffer"")"
"The read() method return immediately, even if the read operation has not finished.","(""read()"", ""return"", ""immediately""); (""read operation"", ""has not finished"", ""read()""); (""read()"", ""is part of"", ""read operation"")"
You can check the when the read operation is finished by calling the isDone() method of the Future instance returned by the read() method.,"(""Future"", ""has method"", ""isDone()""); (""Future"", ""returned by"", ""read()""); (""read()"", ""returns"", ""Future"")"
Here is a longer example showing how to use this version of the read() method:,
"This example creates an AsynchronousFileChannel and then creates a ByteBuffer which is passed to the read() method as parameter, along with a position of 0.","(""AsynchronousFileChannel"", ""creates"", ""ByteBuffer""); (""AsynchronousFileChannel"", ""has method"", ""read()""); (""read()"", ""takes parameter"", ""ByteBuffer""); (""read()"", ""takes parameter"", ""position"")"
After calling read() the example loops until the isDone() method of the returned Future returns true.,"(""Future"", ""has method"", ""isDone()""); (""Future"", ""returns"", ""boolean""); (""read()"", ""returns"", ""Future"")"
Once the read operation has completed the data read into the ByteBuffer and then into a String and printed to System.out .,"(""ByteBuffer"", ""read into"", ""String""); (""String"", ""printed to"", ""System.out""); (""read operation"", ""completed"", ""ByteBuffer""); (""ByteBuffer"", ""read into"", ""data""); (""data"", ""read into"", ""ByteBuffer""); (""String"", ""printed to"", ""System.out"")"
The second method of reading data from an AsynchronousFileChannel is to call the read() method version that takes a CompletionHandler as a parameter.,"(""AsynchronousFileChannel"", ""has method"", ""read()""); (""read()"", ""takes parameter"", ""CompletionHandler""); (""AsynchronousFileChannel"", ""uses"", ""CompletionHandler"")"
Once the read operation finishes the CompletionHandler's completed() method will be called.,"(""CompletionHandler"", ""has method"", ""completed()"")"
"As parameters to the completed() method are passed an Integer telling how many bytes were read, and the ""attachment"" which was passed to the read() method.","(""completed()"", ""is parameter of"", ""read()""); (""completed()"", ""has parameter"", ""Integer""); (""read()"", ""has parameter"", ""attachment""); (""completed()"", ""receives"", ""attachment""); (""read()"", ""returns"", ""bytes"")"
"If the read operation fails, the failed() method of the CompletionHandler will get called instead.","(""CompletionHandler"", ""has method"", ""failed()""); (""read operation"", ""fails"", ""CompletionHandler""); (""CompletionHandler"", ""gets called"", ""failed()"")"
Each way to write data call one of the write() methods of the AsynchronousFileChannel.,"(""AsynchronousFileChannel"", ""has method"", ""write()"")"
If the file does not exist the write() method will throw a java.nio.file.NoSuchFileException .,"(""write()"", ""throws"", ""java.nio.file.NoSuchFileException"")"
The CompletionHandler's completed() method will get called when the write operation completes.,"(""CompletionHandler"", ""has method"", ""completed()""); (""completed()"", ""is called by"", ""write operation""); (""write operation"", ""uses"", ""CompletionHandler"")"
"If the write fails for some reason, the failed() method will get called instead.","(""write"", ""fails"", ""reason""); (""reason"", ""causes"", ""failed()""); (""failed()"", ""gets called"", ""write"")"
"Once you need to read the data, you need to switch the buffer from writing mode into reading mode using the flip() method call.","(""buffer"", ""uses"", ""flip()""); (""flip()"", ""called on"", ""buffer"")"
You can do this in two ways: By calling clear() or by calling compact().,"(""clear()"", ""called by"", ""user""); (""compact()"", ""called by"", ""user""); (""clear()"", ""alternative to"", ""compact()""); (""compact()"", ""alternative to"", ""clear()"")"
The compact() method only clears the data which you have already read.,"(""compact()"", ""is method of"", ""unknown""); (""compact()"", ""clears"", ""data""); (""data"", ""is cleared by"", ""compact()"")"
Here is an example that writes data into a Buffer via the put() method:,"(""Buffer"", ""has method"", ""put()"")"
"There are many other versions of the put() method, allowing you to write data into the Buffer in many different ways.","(""put()"", ""is a method of"", ""Buffer""); (""Buffer"", ""has method"", ""put()"")"
The flip() method switches a Buffer from writing mode to reading mode.,"(""Buffer"", ""has method"", ""flip()"")"
"Calling flip() sets the position back to 0, and sets the limit to where position just was.","(""flip()"", ""sets"", ""position""); (""flip()"", ""sets"", ""limit""); (""position"", ""set back to"", ""0""); (""limit"", ""sets to"", ""position"")"
Here is an example that reads data from a Buffer using the get() method:,"(""Buffer"", ""uses"", ""get() method""); (""Buffer"", ""has method"", ""get()""); (""get() method"", ""is used by"", ""Buffer"")"
"There are many other versions of the get() method, allowing you to read data from the Buffer in many different ways.","(""Buffer"", ""has method"", ""get()"")"
"The Buffer.rewind() sets the position back to 0, so you can reread all the data in the buffer.","(""Buffer"", ""hasMethod"", ""rewind()""); (""rewind()"", ""setsPositionOf"", ""Buffer""); (""Buffer"", ""hasPosition"", ""0"")"
"The limit remains untouched, thus still marking how many elements (bytes, chars etc.)",
You can do so either by calling clear() or by calling compact().,"(""clear()"", ""called by"", ""compact()""); (""compact()"", ""called by"", ""clear()"")"
If you call clear() the position is set back to 0 and the limit to capacity.,"(""clear()"", ""calls"", ""set()""); (""clear()"", ""sets"", ""position""); (""clear()"", ""sets"", ""limit""); (""position"", ""set by"", ""clear()""); (""limit"", ""set by"", ""clear()""); (""position"", ""sets to"", ""0""); (""limit"", ""sets to"", ""capacity"")"
"If there is any unread data in the Buffer when you call clear() that data will be ""forgotten"", meaning you no longer have any markers telling what data has been read, and what has not been read.","(""Buffer"", ""has method"", ""clear()""); (""clear()"", ""affects"", ""markers""); (""Buffer"", ""contains"", ""data""); (""markers"", ""indicate"", ""read data""); (""markers"", ""indicate"", ""unread data""); (""clear()"", ""forgets"", ""unread data""); (""Buffer"", ""loses"", ""markers"")"
"If there is still unread data in the Buffer, and you want to read it later, but you need to do some writing first, call compact() instead of clear().","(""Buffer"", ""hasMethod"", ""compact()""); (""Buffer"", ""hasMethod"", ""clear()"")"
compact() copies all unread data to the beginning of the Buffer.,"(""Buffer"", ""has method"", ""compact()"")"
"The limit property is still set to capacity, just like clear() does.","(""limit"", ""is set to"", ""capacity""); (""clear()"", ""sets"", ""limit""); (""limit"", ""is set by"", ""clear()"")"
You can mark a given position in a Buffer by calling the Buffer.mark() method.,"(""Buffer"", ""has method"", ""Buffer.mark()"")"
You can then later reset the position back to the marked position by calling the Buffer.reset() method.,"(""Buffer"", ""hasMethod"", ""reset()"")"
It is possible to compare two buffers using equals() and compareTo().,"(""Buffer"", ""equals()"", ""Buffer""); (""Buffer"", ""compareTo()"", ""Buffer"")"
The FileChannel class has a transferTo() and a transferFrom() method which does this for you.,"(""FileChannel"", ""has method"", ""transferTo()""); (""FileChannel"", ""has method"", ""transferFrom()"")"
The FileChannel.transferFrom() method transfers data from a source channel into the FileChannel.,"(""FileChannel"", ""hasMethod"", ""transferFrom()""); (""FileChannel"", ""transfersDataFrom"", ""source channel""); (""FileChannel"", ""hasMethod"", ""transferFrom()""); (""transferFrom()"", ""belongsTo"", ""FileChannel"")"
The transferTo() method transfer from a FileChannel into some other channel.,"(""FileChannel"", ""hasMethod"", ""transferTo()""); (""FileChannel"", ""uses"", ""Channel""); (""transferTo()"", ""transfersFrom"", ""FileChannel""); (""transferTo()"", ""transfersTo"", ""Channel"")"
The issue with SocketChannel is also present with the transferTo() method.,"(""SocketChannel"", ""hasMethod"", ""transferTo()"")"
"You receive data from a DatagramChannel by calling its receive() method, like this:","(""DatagramChannel"", ""has method"", ""receive()"")"
The receive() method will copy the content of a received packet of data into the given Buffer.,"(""receive()"", ""is method of"", ""unknown class""); (""Buffer"", ""is parameter of"", ""receive()""); (""receive()"", ""copies data into"", ""Buffer"")"
"You can send data via a DatagramChannel by calling its send() method, like this:","(""DatagramChannel"", ""has method"", ""send()"")"
"When connected you can also use the read() and write() method, as if you were using a traditional channel.","(""read()"", ""is method of"", ""channel""); (""write()"", ""is method of"", ""channel""); (""read()"", ""used with"", ""write()""); (""channel"", ""has method"", ""read()""); (""channel"", ""has method"", ""write()"")"
The Java NIO FileChannel class is NIO's an alternative to reading files with the standard Java IO API.,"(""Java NIO"", ""has alternative"", ""Java IO API""); (""Java NIO FileChannel"", ""is part of"", ""Java NIO""); (""Java NIO FileChannel"", ""reads files with"", ""Java IO API"")"
To read data from a FileChannel you call one of the read() methods.,"(""FileChannel"", ""has method"", ""read()"")"
The int returned by the read() method tells how many bytes were written into the Buffer.,"(""read()"", ""returns"", ""int""); (""Buffer"", ""written into"", ""bytes""); (""read()"", ""tells"", ""bytes"")"
"Writing data to a FileChannel is done using the FileChannel.write() method, which takes a Buffer as parameter.","(""FileChannel"", ""uses"", ""Buffer""); (""FileChannel"", ""has method"", ""FileChannel.write()""); (""FileChannel.write()"", ""takes"", ""Buffer"")"
There is no guarantee of how many bytes the write() method writes to the FileChannel.,"(""FileChannel"", ""has method"", ""write()""); (""write()"", ""writes to"", ""FileChannel"")"
Therefore we repeat the write() call until the Buffer has no further bytes to write.,"(""Buffer"", ""has"", ""bytes""); (""write()"", ""is called on"", ""Buffer"")"
You can obtain the current position of the FileChannel object by calling the position() method.,"(""FileChannel"", ""has method"", ""position()"")"
The size() method of the FileChannel object returns the file size of the file the channel is connected to.,"(""FileChannel"", ""has method"", ""size()""); (""FileChannel"", ""is connected to"", ""file""); (""size()"", ""returns"", ""file size"")"
The FileChannel.force() method flushes all unwritten data from the channel to the disk.,"(""FileChannel"", ""hasMethod"", ""force()""); (""FileChannel.force()"", ""affects"", ""disk""); (""FileChannel"", ""interactsWith"", ""disk"")"
"An operating system may cache data in memory for performance reasons, so you are not guaranteed that data written to the channel is actually written to disk, until you call the force() method.","(""operating system"", ""may cache data in"", ""memory""); (""operating system"", ""calls"", ""force() method""); (""force() method"", ""guarantees data written to"", ""disk""); (""force() method"", ""ensures data written to"", ""channel"")"
"The force() method takes a boolean as parameter, telling whether the file meta data (permission etc.)","(""force()"", ""takes"", ""boolean""); (""force()"", ""parameter"", ""file meta data""); (""file meta data"", ""has"", ""permission"")"
The Java NIO Files class (java.nio.file.Files) provides several methods for manipulating files in the file system.,"(""java.nio.file.Files"", ""provides"", ""methods""); (""java.nio.file.Files"", ""has method"", ""java.nio.file.Files.manipulate()""); (""java.nio.file.Files"", ""used for"", ""file system""); (""java.nio.file.Files"", ""belongs to"", ""java.nio.file"")"
"The Files class contains many methods, so check the JavaDoc too, if you need a method that is not described here.","(""Files"", ""contains"", ""methods""); (""JavaDoc"", ""describes"", ""methods""); (""Files"", ""has"", ""JavaDoc"")"
The Files class just might have a method for it still.,"(""Files"", ""hasMethod"", ""method"")"
"The java.nio.file.Files class works with java.nio.file.Path instances, so you need to understand the Path class before you can work with the Files class.","(""java.nio.file.Files"", ""works with"", ""java.nio.file.Path""); (""java.nio.file.Files"", ""depends on"", ""java.nio.file.Path""); (""java.nio.file.Path"", ""used by"", ""java.nio.file.Files"")"
The Files.exists() method checks if a given Path exists in the file system.,"(""Files"", ""hasMethod"", ""exists()""); (""exists()"", ""checks"", ""Path""); (""Path"", ""existsIn"", ""file system"")"
"Since Path instances may or may not point to paths that exist in the file system, you can use the Files.exists() method to determine if they do (in case you need to check that).","(""Path"", ""uses"", ""Files.exists()""); (""Files"", ""hasMethod"", ""exists()""); (""Path"", ""mayNotPointTo"", ""file system""); (""Files.exists()"", ""checks"", ""file system""); (""Path"", ""mayPointTo"", ""file system"")"
"Second, the example calls the Files.exists() method with the Path instance as the first parameter.","(""Files"", ""calls"", ""Files.exists()""); (""Files.exists()"", ""has parameter"", ""Path"")"
This parameter is an array of options that influence how the Files.exists() determines if the path exists or not.,"(""Files"", ""hasMethod"", ""exists()""); (""exists()"", ""influences"", ""path""); (""options"", ""influences"", ""Files.exists()""); (""Files.exists()"", ""determines"", ""path"")"
In this example above the array contains the LinkOption.NOFOLLOW_LINKS which means that the Files.exists() method should not follow symbolic links in the file system to determine if the path exists.,"(""LinkOption"", ""contains"", ""NOFOLLOW_LINKS""); (""Files"", ""has method"", ""exists()""); (""exists()"", ""called with"", ""LinkOption.NOFOLLOW_LINKS"")"
The Files.createDirectory() method creates a new directory from a Path instance.,"(""Files"", ""creates"", ""directory""); (""Files.createDirectory()"", ""uses"", ""Path""); (""Path"", ""is used by"", ""Files.createDirectory()"")"
Inside the try-catch block the Files.createDirectory() method is called with the path as parameter.,"(""Files"", ""hasMethod"", ""createDirectory()""); (""createDirectory()"", ""isCalledWith"", ""path""); (""Files"", ""callsMethod"", ""createDirectory()"")"
The Files.copy() method copies a file from one path to another.,"(""Files"", ""hasMethod"", ""copy()""); (""Files.copy()"", ""locatedIn"", ""Files""); (""Files.copy()"", ""performsAction"", ""file copy"")"
"Then the example calls Files.copy(), passing the two Path instances as parameters.","(""Files"", ""calls"", ""copy()""); (""Files.copy()"", ""passes"", ""Path""); (""Path"", ""is passed to"", ""Files.copy()"")"
It is possible to force the Files.copy() to overwrite an existing file.,"(""Files"", ""hasMethod"", ""copy()""); (""Files.copy()"", ""canOverwrite"", ""existing file""); (""existing file"", ""canBeOverwrittenBy"", ""Files.copy()"")"
Here an example showing how to overwrite an existing file using Files.copy():,"(""Files"", ""copy"", ""existing file"")"
This parameter instructs the copy() method to overwrite an existing file if the destination file already exists.,"(""copy()"", ""instructs"", ""parameter""); (""parameter"", ""instructs"", ""copy()""); (""copy()"", ""overwrites"", ""file""); (""parameter"", ""controls"", ""file""); (""copy()"", ""has"", ""parameter""); (""file"", ""isOverwrittenBy"", ""copy()"")"
The Java NIO Files class also contains a function for moving files from one path to another.,"(""Java NIO Files"", ""contains"", ""function for moving files""); (""Java NIO Files"", ""has"", ""function for moving files""); (""function for moving files"", ""moves"", ""files""); (""files"", ""are moved from"", ""one path""); (""files"", ""are moved to"", ""another path"")"
"Yes, the java.io.File class could also do that with its renameTo() method, but now you have the file move functionality in the java.nio.file.Files class too.","(""java.io.File"", ""has method"", ""renameTo()""); (""java.nio.file.Files"", ""has method"", ""move()""); (""java.io.File"", ""alternative to"", ""java.nio.file.Files"")"
This parameter tells the Files.move() method to overwrite any existing file at the destination path.,"(""Files"", ""hasMethod"", ""move()""); (""Files.move()"", ""takesParameter"", ""overwrite""); (""overwrite"", ""determinesBehavior"", ""existing file""); (""existing file"", ""locatedAt"", ""destination path""); (""destination path"", ""hasFile"", ""existing file""); (""Files.move()"", ""overwrites"", ""existing file"")"
The Files.move() method may throw an IOException if moving the file fails.,"(""Files"", ""move"", ""IOException""); (""Files.move()"", ""throws"", ""IOException""); (""IOException"", ""thrown by"", ""Files.move()"")"
"For instance, if a file already exists at the destination path, and you have left out the StandardCopyOption.REPLACE_EXISTING option, or if the file to move does not exist etc.","(""StandardCopyOption"", ""has option"", ""REPLACE_EXISTING"")"
If the Files.delete() fails to delete the file for some reason (e.g.,"(""Files"", ""hasMethod"", ""delete()"")"
The Files.walkFileTree() method contains functionality for traversing a directory tree recursively.,"(""Files"", ""contains"", ""walkFileTree""); (""walkFileTree"", ""traverses"", ""directory tree""); (""Files.walkFileTree"", ""is part of"", ""Files"")"
The walkFileTree() method takes a Path instance and a FileVisitor as parameters.,"(""walkFileTree()"", ""takes"", ""Path""); (""walkFileTree()"", ""takes"", ""FileVisitor"")"
"You have to implement the FileVisitor interface yourself, and pass an instance of your implementation to the walkFileTree() method.","(""FileVisitor"", ""implemented by"", ""user implementation""); (""walkFileTree()"", ""called with"", ""FileVisitor instance""); (""FileVisitor"", ""passed to"", ""walkFileTree()"")"
"If you do not need to hook into all of these methods, you can extend the SimpleFileVisitor class, which contains default implementations of all methods in the FileVisitor interface.","(""SimpleFileVisitor"", ""extends"", ""FileVisitor""); (""FileVisitor"", ""contains"", ""methods""); (""SimpleFileVisitor"", ""contains"", ""default implementations""); (""SimpleFileVisitor"", ""implements"", ""FileVisitor"")"
The visitFile() mehtod is called for every file visited during the file walk.,"(""visitFile()"", ""is called by"", ""file walk"")"
The visitFileFailed() method is called in case visiting a file fails.,"(""visitFileFailed()"", ""is called in"", ""visiting a file"")"
Here is a walkFileTree() that extends SimpleFileVisitor to look for a file named README.txt :,"(""walkFileTree"", ""extends"", ""SimpleFileVisitor""); (""SimpleFileVisitor"", ""has method"", ""walkFileTree""); (""walkFileTree"", ""looks for"", ""README.txt"")"
The Files.walkFileTree() can also be used to delete a directory with all files and subdirectories inside it.,"(""Files"", ""hasMethod"", ""walkFileTree()"")"
The Files.delete() method will only delete a directory if it is empty.,"(""Files"", ""hasMethod"", ""delete()""); (""Files.delete()"", ""requires"", ""empty directory""); (""empty directory"", ""isRequiredBy"", ""Files.delete()"")"
"By walking through all directories and deleting all files (inside visitFile()) in each directory, and afterwards delete the directory itself (inside postVisitDirectory()) you can delete a directory with all subdirectories and files.","(""visitFile()"", ""called by"", ""postVisitDirectory()""); (""postVisitDirectory()"", ""deletes"", ""directory""); (""visitFile()"", ""deletes"", ""files""); (""postVisitDirectory()"", ""called after"", ""visitFile()"")"
"The java.nio.file.Files class contains many other useful functions, like functions for creating symbolic links, determining the file size, setting file permissions etc.","(""java.nio.file.Files"", ""contains"", ""functions for creating symbolic links""); (""java.nio.file.Files"", ""contains"", ""functions for determining the file size""); (""java.nio.file.Files"", ""contains"", ""functions for setting file permissions"")"
Check out the JavaDoc for the java.nio.file.Files class for more information about these methods.,"(""java.nio.file.Files"", ""has methods"", ""java.nio.file.Files class""); (""java.nio.file.Files"", ""is documented in"", ""JavaDoc"")"
And that is before the server has used any memory for processing the incoming messages (e.g.,
"To keep the number of threads down, many servers use a design where the server keeps a pool of threads (e.g.",
When you call select() or selectNow() on the Selector it gives you only the SelectableChannel instances that actually has data to read.,"(""Selector"", ""has method"", ""select()""); (""Selector"", ""has method"", ""selectNow()""); (""select()"", ""returns"", ""SelectableChannel""); (""selectNow()"", ""returns"", ""SelectableChannel""); (""SelectableChannel"", ""has data to read"", ""data"")"
"A data block could potentially contain a partial message (less than a message), a full message, or more than a message, for instance 1.5 or 2.5 messsages.",
The first way to implement a resizable buffer is to start with a small buffer of e.g.,
"If a message cannot fit into the 4KB buffer, a larger buffer of e.g.",
For 1.000.000 concurrent connections that results in 1.000.000 x 4KB = 4GB which is possible in most servers today (2015).,
Another workaround is to time out messages which have not been received within e.g.,
The fact that TLV encodings makes memory management easier is one of the reasons why HTTP 1.1 is such a terrible protocol.,
That is one of the problems they are trying to fix in HTTP 2.0 where data is transported in LTV encoded frames.,"(""HTTP"", ""hasVersion"", ""HTTP 2.0""); (""HTTP 2.0"", ""transportsDataIn"", ""LTV encoded frames"")"
This is also why we have designed our own network protocol for our VStack.co project that uses a TLV encoding.,"(""VStack.co"", ""uses"", ""TLV encoding""); (""VStack.co"", ""has"", ""network protocol""); (""network protocol"", ""uses"", ""TLV encoding"")"
Imagine if you have 1.000.000 connections which are mostly idle and all 1.000.000 connections were registered with the Selector.,
"Then, when you call select() most of these Channel instances would be write-ready (they are mostly idle, remember?).","(""Channel"", ""instances of"", ""Channel""); (""Channel"", ""has method"", ""select()"")"
"Java NIO has more classes and components than these, but the Channel, Buffer and Selector forms the core of the API, in my opinion.","(""Java NIO"", ""has"", ""Channel""); (""Java NIO"", ""has"", ""Buffer""); (""Java NIO"", ""has"", ""Selector""); (""Channel"", ""forms core of"", ""Java NIO""); (""Buffer"", ""forms core of"", ""Java NIO""); (""Selector"", ""forms core of"", ""Java NIO"")"
"The rest of the components, like Pipe and FileLock are merely utility classes to be used in conjunction with the three core components.","(""Pipe"", ""is_a"", ""utility class""); (""FileLock"", ""is_a"", ""utility class""); (""Pipe"", ""used_in_conjunction_with"", ""core components""); (""FileLock"", ""used_in_conjunction_with"", ""core components"")"
"There are a few interesting interfaces accompanying these classes too, but I'll keep them out of this Java NIO overview for simplicity's sake.",
"The Path interface is located in the java.nio.file package, so the fully qualified name of the Java Path interface is java.nio.file.Path.","(""Path"", ""is located in"", ""java.nio.file""); (""Path"", ""has fully qualified name"", ""java.nio.file.Path""); (""Path"", ""belongs to package"", ""java.nio.file"")"
The java.nio.file.Path interface has nothing to do with the path environment variable.,"(""java.nio.file.Path"", ""has nothing to do with"", ""path environment variable"")"
"In many ways the java.nio.file.Path interface is similar to the java.io.File class, but there are some minor differences.","(""java.nio.file.Path"", ""similar to"", ""java.io.File"")"
"In many cases though, you can replace the use of the File class with use of the Path interface.","(""File"", ""replaced by"", ""Path"")"
In order to use a java.nio.file.Path instance you must create a Path instance.,"(""java.nio.file.Path"", ""instance of"", ""java.nio.file""); (""java.nio.file.Path"", ""created by"", ""create a Path instance""); (""java.nio.file.Path"", ""has method"", ""create"")"
You create a Path instance using a static method in the Paths class (java.nio.file.Paths) named Paths.get().,"(""Paths"", ""hasMethod"", ""get()""); (""Paths"", ""isLocatedIn"", ""java.nio.file""); (""java.nio.file.Paths"", ""hasMethod"", ""get()""); (""Paths.get()"", ""returns"", ""Path""); (""Path"", ""isCreatedWith"", ""Paths.get()"")"
To use the Path interface and the Paths class we must first import them.,"(""Path"", ""used with"", ""Paths""); (""Path"", ""imported from"", ""unknown package""); (""Paths"", ""imported from"", ""unknown package"")"
It is the call to the Paths.get() method that creates the Path instance.,"(""Paths"", ""hasMethod"", ""get()""); (""Paths.get()"", ""creates"", ""Path"")"
"The Paths.get() method is a factory method for Path instances, in other words.","(""Paths"", ""hasMethod"", ""get()""); (""get()"", ""returns"", ""Path""); (""Path"", ""hasFactoryMethod"", ""get()"")"
Creating an absolute path is done by calling the Paths.get() factory method with the absolute file as parameter.,"(""Paths"", ""get"", ""absolute file""); (""Paths.get()"", ""called with"", ""absolute file""); (""absolute file"", ""used as parameter"", ""Paths.get()"")"
The Java NIO Path class can also be used to work with relative paths.,"(""Java NIO Path"", ""can be used with"", ""relative paths""); (""Java NIO Path"", ""class of"", ""Java NIO""); (""relative paths"", ""worked with by"", ""Java NIO Path"")"
The second example creates a Path instance which points to the path (file) d:\data\projects\a-project\myfile.txt .,"(""Path"", ""instance"", ""d:\data\projects\a-project\myfile.txt""); (""Path"", ""points to"", ""d:\data\projects\a-project\myfile.txt""); (""Path"", ""creates"", ""Path instance"")"
If you use the .. code in the middle of a path string it will correspond to changing one directory up at that point in the path string.,
The .. code after the a-project directory changes directory up the the parent directory projects and then the path references down into the another-project directory from there.,
and .. codes also work in combination with the two-string Paths.get() method.,"(""Paths"", ""get"", ""()""); (""Paths"", ""get"", ""two-string""); (""Paths.get()"", ""method"", ""two-string""); (""Paths"", ""method"", ""get()"")"
Here are two Java Paths.get() examples showing simple examples of that:,"(""Paths"", ""get()"", ""Java""); (""Paths.get()"", ""returns"", ""Path""); (""Java"", ""uses"", ""Paths""); (""Path"", ""returned by"", ""Paths.get()"")"
There are more ways that the Java NIO Path class can be used to work with relative paths.,"(""Java NIO Path"", ""can be used with"", ""relative paths""); (""Java NIO Path"", ""is a"", ""class""); (""Java NIO Path"", ""works with"", ""Java""); (""relative paths"", ""are used with"", ""Java NIO Path""); (""Java"", ""has"", ""Java NIO Path"")"
The Java Path method relativize() can create a new Path which represents the second Path relative to the first Path.,"(""Java Path"", ""has method"", ""relativize()""); (""relativize()"", ""returns"", ""Path""); (""Path"", ""has method"", ""relativize()"")"
"For instance, with the path /data and /data/subdata/subsubdata/myfile.txt"", the second path can be expressed as /subdata/subsubdata/myfile.txt relative to the first path.","(""data"", ""contains"", ""subdata""); (""subdata"", ""contains"", ""subsubdata""); (""subsubdata"", ""contains"", ""myfile.txt"")"
"If you add the relative path subdata/subsubdata/myfile.txt to the directory path /data, you get the full path /data/subdata/subsubdata/myfile.txt.",
If you you add the relative path ../../.. to the full file path /data/subdata/subsubdata/myfile.txt then you get /data,
The normalize() method of the Path interface can normalize a path.,"(""Path"", ""has method"", ""normalize()"")"
"and .. codes in the middle of the path string, and resolves what path the path string refers to.",
This Path example first creates a path string with a .. code in the middle.,"(""Path"", ""creates"", ""path string""); (""Path"", ""contains"", "".. code"")"
"Then the example creates a Path instance from this path string, and prints that Path instance out (actually it prints Path.toString()).","(""Path"", ""creates"", ""instance""); (""Path"", ""prints"", ""Path.toString()""); (""Path"", ""instance"", ""Path.toString()""); (""Path"", ""has method"", ""toString()"")"
"The example then calls normalize() on the created Path instance, which returns a new Path instance.","(""Path"", ""calls"", ""normalize()""); (""Path"", ""returns"", ""Path"")"
"As you can see, the normalized path does not contain the a-project\.. part, as this is redundant.",
"You write to a SinkChannel by calling it's write() method, like this:","(""SinkChannel"", ""has method"", ""write()"")"
To read from the source channel you call its read() method like this:,
The int returned by the read() method tells how many bytes were read into the buffer.,"(""read()"", ""returns"", ""int"")"
"Notice how the buffers are first inserted into an array, then the array passed as parameter to the channel.read() method.","(""channel"", ""hasMethod"", ""read()""); ("" buffers"", ""insertedInto"", ""array""); (""array"", ""passedTo"", ""channel.read()"")"
The read() method then writes data from the channel in the sequence the buffers occur in the array.,"(""read()"", ""writes data from"", ""channel""); (""read()"", ""occurs in"", ""array""); (""buffer"", ""occur in"", ""array""); (""read()"", ""writes data to"", ""sequence""); (""channel"", ""has"", ""buffer""); (""buffer"", ""stored in"", ""array""); (""read()"", ""uses"", ""buffer""); (""read()"", ""reads from"", ""channel"")"
"In other words, if you have a header and a body, and the header is fixed size (e.g.",
"The array of buffers are passed into the write() method, which writes the content of the buffers in the sequence they are encountered in the array.","(""write() method"", ""is called with"", ""array of buffers""); (""array of buffers"", ""is passed to"", ""write() method""); (""write() method"", ""writes content of"", ""buffers"")"
"The Java NIO Selector is a component which can examine one or more Java NIO Channel instances, and determine which channels are ready for e.g.","(""Java NIO Selector"", ""can examine"", ""Java NIO Channel""); (""Java NIO Channel"", ""are ready for"", ""Java NIO Selector"")"
"You create a Selector by calling the Selector.open() method, like this:","(""Selector"", ""open"", ""Selector"")"
"As you saw in the previous section, when you register a Channel with a Selector the register() method returns a SelectionKey objects.","(""Channel"", ""register"", ""Selector""); (""register"", ""returns"", ""SelectionKey""); (""Channel"", ""register"", ""SelectionKey"")"
"You can also attach an object already while registering the Channel with the Selector, in the register() method.","(""Channel"", ""register"", ""Selector""); (""Selector"", ""has method"", ""register()""); (""Channel"", ""has method"", ""register()"")"
Once you have register one or more channels with a Selector you can call one of the select() methods.,"(""Selector"", ""has method"", ""select()""); (""Selector"", ""registers"", ""channels""); (""select()"", ""is method of"", ""Selector"")"
"In other words, if you are interested in channels that are ready for reading, you will receive the channels that are ready for reading from the select() methods.","(""select()"", ""is method of"", ""unknown class""); (""unknown class"", ""has method"", ""select()""); (""select()"", ""returns"", ""channels""); (""channels"", ""are ready for"", ""reading""); (""channels"", ""are retrieved by"", ""select()"")"
select() blocks until at least one channel is ready for the events you registered for.,"(""select()"", ""blocks"", ""channel""); (""select()"", ""registers"", ""events""); (""channel"", ""is ready for"", ""events"")"
select(long timeout) does the same as select() except it blocks for a maximum of timeout milliseconds (the parameter).,"(""select(long timeout)"", ""does the same as"", ""select()""); (""select(long timeout)"", ""blocks for"", ""timeout""); (""select()"", ""has alternative"", ""select(long timeout)"")"
The int returned by the select() methods tells how many channels are ready.,"(""select()"", ""returns"", ""int""); (""select()"", ""is method of"", ""unknown""); (""int"", ""is returned by"", ""select()"")"
"That is, how many channels that became ready since last time you called select().",
"If you call select() and it returns 1 because one channel has become ready, and you call select() one more time, and one more channel has become ready, it will return 1 again.","(""select()"", ""returns"", ""1""); (""select()"", ""is called on"", ""channel""); (""channel"", ""becomes"", ""ready""); (""select()"", ""is called again on"", ""channel""); (""select()"", ""returns"", ""1""); (""channel"", ""becomes"", ""ready"")"
"If you have done nothing with the first channel that was ready, you now have 2 ready channels, but only one channel had become ready between each select() call.",
"Once you have called one of the select() methods and its return value has indicated that one or more channels are ready, you can access the ready channels via the ""selected key set"", by calling the selectors selectedKeys() method.","(""select()"", ""called"", ""select() methods""); (""select() methods"", ""return"", ""return value""); (""return value"", ""indicated"", ""channels""); (""channels"", ""are"", ""ready""); (""ready channels"", ""accessed via"", ""selected key set""); (""selected key set"", ""accessed by"", ""selectedKeys() method""); (""selectors"", ""has"", ""selectedKeys() method""); (""selectedKeys() method"", ""called on"", ""selectors"")"
When you register a channel with a Selector the Channel.register() method returns a SelectionKey object.,"(""Channel"", ""has method"", ""Channel.register()""); (""Channel.register()"", ""returns"", ""SelectionKey""); (""Channel"", ""interacts with"", ""Selector"")"
It is these keys you can access via the selectedKeySet() method.,"(""selectedKeySet"", ""is accessed via"", ""method""); (""selectedKeySet"", ""has method"", ""selectedKeySet()"")"
"The channel returned by the SelectionKey.channel() method should be cast to the channel you need to work with, e.g a ServerSocketChannel or SocketChannel etc.","(""SelectionKey"", ""channel()"", ""ServerSocketChannel""); (""SelectionKey"", ""channel()"", ""SocketChannel"")"
"A thread that has called the select() method which is blocked, can be made to leave the select() method, even if no channels are yet ready.","(""thread"", ""has called"", ""select() method""); (""select() method"", ""is blocked"", ""thread""); (""thread"", ""can be made to leave"", ""select() method""); (""select() method"", ""is waiting for"", ""channels""); (""thread"", ""leaves"", ""select() method""); (""channels"", ""are"", ""ready""); (""select() method"", ""is waiting for"", ""ready channels"")"
This is done by having a different thread call the Selector.wakeup() method on the Selector which the first thread has called select() on.,"(""Selector"", ""has method"", ""Selector.wakeup()""); (""Selector"", ""has method"", ""select()""); (""Thread"", ""calls"", ""Selector.wakeup()""); (""Thread"", ""calls"", ""select()""); (""Thread"", ""uses"", ""Selector""); (""Selector"", ""is used by"", ""Thread""); (""select()"", ""is called by"", ""Thread""); (""Selector.wakeup()"", ""is called by"", ""Thread"")"
"If a different thread calls wakeup() and no thread is currently blocked inside select(), the next thread that calls select() will ""wake up"" immediately.","(""thread"", ""calls"", ""wakeup()""); (""thread"", ""is"", ""blocked""); (""thread"", ""calls"", ""select()""); (""wakeup()"", ""and"", ""select()""); (""select()"", ""will"", ""wake""); (""thread"", ""that"", ""calls""); (""thread"", ""is"", ""blocked""); (""wakeup()"", ""and"", ""thread""); (""thread"", ""calls"", ""select()""); (""select()"", ""and"", ""thread"")"
When you are finished with the Selector you call its close() method.,"(""Selector"", ""has method"", ""close()"")"
Listening for incoming connections is done by calling the ServerSocketChannel.accept() method.,"(""ServerSocketChannel"", ""hasMethod"", ""accept()""); (""ServerSocketChannel.accept()"", ""calledBy"", ""unknown""); (""ServerSocketChannel"", ""usedFor"", ""listeningForIncomingConnections"")"
"When the accept() method returns, it returns a SocketChannel with an incoming connection.","(""accept()"", ""returns"", ""SocketChannel"")"
"Since you are typically not interested in listening just for a single connection, you call the accept() inside a while-loop.","(""accept()"", ""called by"", ""while-loop"")"
"In non-blocking mode the accept() method returns immediately, and may thus return null, if no incoming connection had arrived.","(""accept()"", ""is method of"", ""unknown class""); (""accept()"", ""returns"", ""null""); (""unknown class"", ""has method"", ""accept()"")"
You close a SocketChannel after use by calling the SocketChannel.close() method.,"(""SocketChannel"", ""has method"", ""SocketChannel.close()""); (""SocketChannel"", ""calls"", ""SocketChannel.close()""); (""SocketChannel.close()"", ""belongs to"", ""SocketChannel"")"
To read data from a SocketChannel you call one of the read() methods.,"(""SocketChannel"", ""has method"", ""read()"")"
The int returned by the read() method tells how many bytes were witten into the Buffer.,"(""read()"", ""returns"", ""int""); (""read()"", ""writes to"", ""Buffer"")"
"Writing data to a SocketChannel is done using the SocketChannel.write() method, which takes a Buffer as parameter.","(""SocketChannel"", ""uses"", ""SocketChannel.write()""); (""SocketChannel.write()"", ""takes"", ""Buffer"")"
There is no guarantee of how many bytes the write() method writes to the SocketChannel.,"(""write()"", ""is method of"", ""SocketChannel""); (""SocketChannel"", ""has method"", ""write()""); (""write()"", ""writes to"", ""SocketChannel"")"
"When you do so, you can call connect(), read() and write() in asynchronous mode.","(""connect()"", ""is called by"", ""asynchronous mode""); (""read()"", ""is called by"", ""asynchronous mode""); (""write()"", ""is called by"", ""asynchronous mode"")"
"If the SocketChannel is in non-blocking mode, and you call connect(), the method may return before a connection is established.","(""SocketChannel"", ""is in mode"", ""non-blocking mode""); (""SocketChannel"", ""call"", ""connect()""); (""connect()"", ""return before"", ""connection is established""); (""SocketChannel"", ""has method"", ""connect()"")"
"To determine whether the connection is established, you can call the finishConnect() method, like this:","(""finishConnect()"", ""is method of"", ""unknown class"")"
In non-blocking mode the write() method may return without having written anything.,"(""write()"", ""is method of"", ""non-blocking mode""); (""non-blocking mode"", ""has method"", ""write()""); (""write()"", ""returns"", ""nothing"")"
Therefore you need to call the write() method in a loop.,"(""write()"", ""called in"", ""loop"")"
In non-blocking mode the read() method may return without having read any data at all.,"(""read()"", ""is method of"", ""non-blocking mode""); (""non-blocking mode"", ""has method"", ""read()""); (""read()"", ""returns"", ""data"")"
"Also, parts of the NIO APIs are actually blocking - e.g.","(""NIO"", ""is part of"", ""APIs"")"
"A selector is an object that can monitor multiple channels for events (like: connection opened, data arrived etc.).","(""Selector"", ""monitors"", ""Channel""); (""Channel"", ""hasEvent"", ""ConnectionOpened""); (""Channel"", ""hasEvent"", ""DataArrived"")"
"That means, that when a thread invokes a read() or write(), that thread is blocked until there is some data to read, or the data is fully written.","(""thread"", ""invokes"", ""read()""); (""thread"", ""invokes"", ""write()""); (""read()"", ""blocks"", ""thread""); (""write()"", ""blocks"", ""thread""); (""thread"", ""is blocked by"", ""read()""); (""thread"", ""is blocked by"", ""write()"")"
Rather than just read the data byte for byte from e.g.,
"In other words, once the first reader.readLine() method returns, you know for sure that a full line of text has been read.","(""reader"", ""has method"", ""readLine()"")"
"The readLine() blocks until a full line is read, that's why.","(""readLine()"", ""blocks"", ""line"")"
"Similarly, when the second readLine() call returns, you know that this line contains the age etc.","(""readLine()"", ""returns"", ""line""); (""readLine()"", ""contains"", ""age"")"
"The bufferFull() method has to keep track of how much data is read into the buffer, and return either true or false, depending on whether the buffer is full.","(""bufferFull()"", ""has method"", ""bufferFull()""); (""bufferFull()"", ""returns"", ""true""); (""bufferFull()"", ""returns"", ""false""); (""bufferFull()"", ""tracks"", ""data""); (""buffer()"", ""has method"", ""bufferFull()"")"
"The bufferFull() method scans through the buffer, but must leave the buffer in the same state as before the bufferFull() method was called.","(""bufferFull()"", ""scans through"", ""buffer""); (""bufferFull()"", ""leaves"", ""buffer""); (""bufferFull()"", ""called on"", ""buffer"")"
"Similarly, if you need to keep a lot of open connections to other computers, e.g.",
"If you have fewer connections with very high bandwidth, sending a lot of data at a time, perhaps a classic IO server implementation might be the best fit.",
Using Java Reflection you can access the annotations attached to Java classes at runtime.,"(""Java Reflection"", ""uses"", ""Java classes""); (""Java classes"", ""have"", ""annotations""); (""annotations"", ""are accessed"", ""Java Reflection""); (""Java classes"", ""are accessed at"", ""runtime""); (""annotations"", ""are attached to"", ""Java classes""); (""Java Reflection"", ""accesses"", ""annotations"")"
"You can also specify METHOD or FIELD, or you can leave the target out alltogether so the annotation can be used for both classes, methods and fields.","(""METHOD"", ""is a type of"", ""target""); (""FIELD"", ""is a type of"", ""target""); (""classes"", ""can be targeted by"", ""annotation""); (""methods"", ""can be targeted by"", ""annotation""); (""fields"", ""can be targeted by"", ""annotation""); (""annotation"", ""can be used for"", ""classes""); (""annotation"", ""can be used for"", ""methods""); (""annotation"", ""can be used for"", ""fields"")"
"You can access the annotations of a class, method or field at runtime.","(""class"", ""has"", ""annotations""); (""method"", ""has"", ""annotations""); (""field"", ""has"", ""annotations"")"
"Notice how the Method.getParameterAnnotations() method returns a two-dimensional Annotation array, containing an array of annotations for each method parameter.","(""Method"", ""getParameterAnnotations"", ""Annotation""); (""Method.getParameterAnnotations"", ""returns"", ""Annotation array""); (""Annotation array"", ""contains"", ""annotations""); (""Method"", ""has"", ""parameters""); (""Method.getParameterAnnotations"", ""applied to"", ""method parameters""); (""Method.getParameterAnnotations"", ""returns"", ""two-dimensional array""); (""Method"", ""has"", ""parameters with annotations""); (""Method.getParameterAnnotations"", ""is a method of"", ""Method""); (""Method.getParameterAnnotations"", ""returns array of"", ""annotations for each method parameter"")"
This text will discuss how to both create arrays and get their class objects via Java Reflection.,"(""Java Reflection"", ""uses"", ""arrays""); (""arrays"", ""created via"", ""Java Reflection""); (""Java Reflection"", ""gets"", ""class objects"")"
Working with arrays via Java Reflection is done using the java.lang.reflect.Array class.,"(""java.lang.reflect.Array"", ""is used for"", ""Working with arrays""); (""java.lang.reflect.Array"", ""uses"", ""Java Reflection""); (""Java Reflection"", ""is done via"", ""java.lang.reflect.Array"")"
"Do not confuse this class with the java.util.Arrays class in the Java Collections suite, which contains utility methods for sorting arrays, converting them to collections etc.","(""java.util.Arrays"", ""is_in"", ""Java Collections""); (""Java Collections"", ""contains"", ""utility methods""); (""java.util.Arrays"", ""contains"", ""utility methods""); (""java.util.Arrays"", ""is_used_for"", ""sorting arrays""); (""java.util.Arrays"", ""is_used_for"", ""converting arrays to collections"")"
Creating arrays via Java Reflection is done using the java.lang.reflect.Array class.,"(""java.lang.reflect.Array"", ""uses"", ""Java Reflection""); (""Java Reflection"", ""is done using"", ""java.lang.reflect.Array""); (""java.lang.reflect.Array"", ""is part of"", ""java.lang.reflect"")"
The first parameter int.class given to the Array.newInstance() method tells what type each element in the array should be of.,"(""Array"", ""hasMethod"", ""newInstance()""); (""Array.newInstance()"", ""takesParameter"", ""int.class"")"
"For instance, you can access the primitive int array class object like this:","(""int"", ""accessed by"", ""primitive array class""); (""primitive array class"", ""has object"", ""int""); (""primitive array class object"", ""accessed through"", ""int"")"
The [ on the left means it is the class of an int array I am interested in.,
"Notice the [L to the left of the class name, and the ; to the right.","(""L"", ""to the left of"", ""class name""); (""class name"", ""has"", ""; to the right"")"
"As a side note, you cannot obtain the class object of primitives using Class.forName().","(""Class"", ""uses"", ""Class.forName()""); (""Class.forName()"", ""returns"", ""class object""); (""primitives"", ""cannot be obtained by"", ""Class.forName()"")"
I usually do something like this to obtain the class name for primitives as well as objects:,"(""Class"", ""EXTENDS"", ""Object""); (""Object"", ""HAS_METHOD"", ""getClass()""); (""Class"", ""HAS_METHOD"", ""getName()""); (""getName()"", ""RETURNS"", ""String"")"
"The solution, or workaround as you might call it, is to create an empty array of the desired type and obtain the class object from that empty array.","(""Array"", ""create"", ""empty array""); (""empty array"", ""obtain"", ""class object""); (""Class"", ""get"", ""class object""); (""Array"", ""of"", ""desired type""); (""desired type"", ""obtain"", ""class object"")"
"This presents a single, uniform method to access the array class of arrays of any type.","(""array"", ""has Method"", ""access""); (""array"", ""of Type"", ""any type""); (""uniform method"", ""to Access"", ""array class""); (""array class"", ""of Type"", ""arrays""); (""array class"", ""has Method"", ""access"")"
"To make sure that the Class object really is an array, you can call the Class.isArray() method to check:","(""Class"", ""hasMethod"", ""isArray()"")"
Once you have obtained the Class object for an array you can access its component type via the Class.getComponentType() method.,"(""Class"", ""hasMethod"", ""Class.getComponentType()""); (""Class.getComponentType()"", ""returns"", ""component type""); (""Array"", ""hasMethod"", ""Class.getComponentType()"")"
"For instance, the component type of an int[] array is the int.class Class object.","(""int"", ""component type"", ""int.class""); (""int.class"", ""is"", ""Class object""); (""int.class"", ""represents"", ""int"")"
The component type of a String[] array is the java.lang.String Class object.,"(""String"", ""component type"", ""java.lang.String""); (""String"", ""is type of"", ""java.lang.String Class"")"
"This example will print out the text ""java.lang.String"" which is the component type of the String array.","(""java.lang.String"", ""is component type of"", ""String array"")"
Inspecting classes is often the first thing you do when using Reflection.,"(""Reflection"", ""uses"", ""inspecting classes""); (""Inspecting classes"", ""is part of"", ""Reflection""); (""Reflection"", ""has action"", ""inspecting classes"")"
For a full list you should consult the JavaDoc for java.lang.Class.,"(""JavaDoc"", ""isDocumentationFor"", ""java.lang.Class""); (""java.lang.Class"", ""hasDocumentation"", ""JavaDoc"")"
Before you can do any inspection on a class you need to obtain its java.lang.Class object.,"(""Class"", ""has object"", ""java.lang.Class""); (""java.lang.Class"", ""is obtained by"", ""Class"")"
"All types in Java including the primitive types (int, long, float etc.)","(""int"", ""isA"", ""type""); (""long"", ""isA"", ""type""); (""float"", ""isA"", ""type""); (""Java"", ""hasType"", ""int""); (""Java"", ""hasType"", ""long""); (""Java"", ""hasType"", ""float"")"
If you know the name of the class at compile time you can obtain a Class object like this:,"(""Class"", ""obtained by"", ""Class object"")"
"If you don't know the name at compile time, but have the class name as a string at runtime, you can do like this:","(""Class"", ""has"", ""name""); (""String"", ""represents"", ""class name""); (""Class"", ""determined at"", ""runtime""); (""Class"", ""known at"", ""compile time"")"
String className = ... //obtain class name as string at runtime Class class = Class.forName(className);,"(""String"", ""has method"", ""forName()""); (""Class"", ""has method"", ""forName()""); (""Class"", ""is type of"", ""class""); (""className"", ""is attribute of"", ""String""); (""Class.forName()"", ""returns"", ""Class""); (""Class"", ""has static method"", ""forName()"")"
When using the Class.forName() method you must supply the fully qualified class name.,"(""Class"", ""uses"", ""forName()""); (""Class"", ""has method"", ""forName()""); (""forName()"", ""belongs to"", ""Class"")"
The Class.forName() method may throw a ClassNotFoundException if the class cannot be found on the classpath at runtime.,"(""Class.forName()"", ""may throw"", ""ClassNotFoundException""); (""Class.forName()"", ""uses"", ""classpath""); (""Class.forName()"", ""executed at"", ""runtime""); (""ClassNotFoundException"", ""thrown by"", ""Class.forName()"")"
The fully qualified class name (including package name) is obtained using the getName() method like this:,"(""Class"", ""uses"", ""Method""); (""getName()"", ""called_by"", ""Class""); (""Class"", ""has_method"", ""getName()"")"
"If you want the class name without the pacakge name you can obtain it using the getSimpleName() method, like this:","(""class"", ""hasMethod"", ""getSimpleName()""); (""getSimpleName()"", ""belongsTo"", ""class"")"
You can access the modifiers of a class via the Class object.,"(""Class"", ""has"", ""modifiers""); (""Class"", ""accessed via"", ""Class object"")"
You can check the modifiers using these methods in the class java.lang.reflect.Modifier:,"(""java.lang.reflect.Modifier"", ""contains"", ""methods""); (""java.lang.reflect.Modifier"", ""is_part_of"", ""java.lang.reflect""); (""methods"", ""are_used_in"", ""java.lang.reflect.Modifier""); (""java.lang.reflect"", ""has_class"", ""java.lang.reflect.Modifier"")"
You can also access information specified for this package in the Manifest file of the JAR file this package is located in on the classpath.,"(""Manifest"", ""is located in"", ""JAR file""); (""Package"", ""is located in"", ""JAR file""); (""JAR file"", ""is on"", ""classpath"")"
From the Class object you can access the superclass of the class.,"(""Class"", ""has superclass"", ""superclass""); (""Class"", ""access"", ""superclass""); (""Class"", ""has"", ""superclass"")"
"The superclass class object is a Class object like any other, so you can continue doing class reflection on that too.","(""class"", ""is a"", ""Class""); (""Class"", ""object"", ""class""); (""Class"", ""used for"", ""class reflection""); (""class"", ""has"", ""superclass""); (""superclass"", ""is a"", ""Class"")"
It is possible to get a list of the interfaces implemented by a given class.,"(""Class"", ""implements"", ""Interface""); (""Class"", ""gets"", ""Interface""); (""Class"", ""has"", ""Interface"")"
NOTE: Only the interfaces specifically declared implemented by a given class is returned.,"(""Class"", ""implements"", ""Interface""); (""Class"", ""declares"", ""Interface"")"
"If a superclass of the class implements an interface, but the class doesn't specifically state that it also implements that interface, that interface will not be returned in the array.","(""class"", ""implements"", ""interface""); (""superclass"", ""implements"", ""interface""); (""class"", ""does not implement"", ""interface""); (""interface"", ""is not returned by"", ""array""); (""class"", ""has"", ""superclass""); (""superclass"", ""is a"", ""class"")"
"Even if the class in practice implements that interface, because the superclass does.","(""class"", ""implements"", ""interface""); (""superclass"", ""does"", ""interface""); (""class"", ""implements"", ""interface""); (""class"", ""is subclass of"", ""superclass"")"
To get a complete list of the interfaces implemented by a given class you will have to consult both the class and its superclasses recursively.,"(""Class"", ""implements"", ""Interface""); (""Class"", ""has"", ""Superclass""); (""Superclass"", ""implements"", ""Interface"")"
You can access the fields (member variables) of a class like this:,"(""class"", ""has"", ""fields""); (""class"", ""accesses"", ""fields""); (""fields"", ""are"", ""member variables""); (""class"", ""contains"", ""member variables"")"
You can access the class annotations of a class like this:,"(""Class"", ""has method"", ""getAnnotations()""); (""Class"", ""accessed by"", ""getAnnotations()""); (""getAnnotations()"", ""returns"", ""annotations"")"
Using Java Reflection you can inspect the constructors of classes and instantiate objects at runtime.,"(""Java Reflection"", ""can inspect"", ""constructors""); (""Java Reflection"", ""can instantiate"", ""objects""); (""constructors"", ""are part of"", ""classes""); (""classes"", ""have"", ""constructors""); (""Java Reflection"", ""uses"", ""runtime""); (""objects"", ""are instantiated at"", ""runtime"")"
The Constructor[] array will have one Constructor instance for each public constructor declared in the class.,"(""Constructor"", ""declared_in"", ""class""); (""Constructor"", ""contains"", ""Constructor""); (""Constructor"", ""declared_in"", ""class""); (""Constructor"", ""contains"", ""Constructor"")"
This example returns the public constructor of the given class which takes a String as parameter:,"(""Class"", ""hasConstructor"", ""Constructor""); (""Constructor"", ""takesParameter"", ""String""); (""Class"", ""hasParameter"", ""String"")"
"If no constructor matches the given constructor arguments, in this case String.class, a NoSuchMethodException is thrown.","(""Constructor"", ""throws"", ""NoSuchMethodException""); (""String.class"", ""passed to"", ""Constructor"")"
"The Constructor.newInstance() method takes an optional amount of parameters, but you must supply exactly one parameter per argument in the constructor you are invoking.","(""Constructor"", ""hasMethod"", ""newInstance()""); (""Constructor.newInstance()"", ""takesParameter"", ""parameter""); (""parameter"", ""isPartOf"", ""constructor"")"
"It is possible to load and reload classes at runtime in Java, though it is not as straightforward as one might have hoped.","(""Java"", ""loads"", ""classes""); (""classes"", ""loaded at"", ""runtime""); (""Java"", ""has feature"", ""runtime loading"")"
This text will explain when and how you can load and reload classes in Java.,"(""Java"", ""loads"", ""classes""); (""classes"", ""are loaded by"", ""Java""); (""Java"", ""reloads"", ""classes"")"
"You can argue whether Java's dynamic class loading features are really part of Java Reflection, or a part of the core Java platform.","(""Java"", ""hasFeature"", ""dynamic class loading""); (""Java Reflection"", ""partOf"", ""Java""); (""Java"", ""hasFeature"", ""Java Reflection""); (""Java"", ""hasPart"", ""core Java platform""); (""Java Reflection"", ""partOf"", ""core Java platform""); (""dynamic class loading"", ""partOf"", ""Java"")"
All classes in a Java application are loaded using some subclass of java.lang.ClassLoader.,"(""Java application"", ""uses"", ""java.lang.ClassLoader""); (""java.lang.ClassLoader"", ""has subclasses"", ""subclass of java.lang.ClassLoader""); (""Java application"", ""loads classes using"", ""subclass of java.lang.ClassLoader"")"
Loading classes dynamically must therefore also be done using a java.lang.ClassLoader subclass.,"(""ClassLoader"", ""is subclass of"", ""java.lang.ClassLoader""); (""ClassLoader"", ""loads"", ""classes""); (""java.lang.ClassLoader"", ""is superclass of"", ""ClassLoader"")"
"When a class is loaded, all classes it references are loaded too.","(""class"", ""references"", ""classes""); (""class"", ""is loaded"", ""class""); (""classes"", ""are loaded"", ""class""); (""class"", ""is loaded"", ""classes"")"
"This class loading pattern happens recursively, until all classes needed are loaded.","(""Class"", ""loaded by"", ""Class Loader""); (""Class Loader"", ""loads"", ""Class""); (""Class"", ""needs"", ""Class"")"
Unreferenced classes are not loaded until the time they are referenced.,"(""Unreferenced classes"", ""are loaded by"", ""ClassLoader""); (""ClassLoader"", ""loads"", ""Unreferenced classes""); (""Unreferenced classes"", ""are referenced by"", ""Application""); (""Application"", ""references"", ""Unreferenced classes"")"
"If a ClassLoader is asked to load a class, it will ask its parent class loader to load it.","(""ClassLoader"", ""is asked to load"", ""class""); (""ClassLoader"", ""ask"", ""parent class loader""); (""ClassLoader"", ""load"", ""class""); (""parent class loader"", ""load"", ""class"")"
"If the parent class loader can't find the class, the child class loader then tries to load it itself.","(""parent class loader"", ""can't find"", ""class""); (""child class loader"", ""tries to load"", ""class""); (""parent class loader"", ""can load"", ""class"")"
The steps a given class loader uses when loading classes are:,"(""Class Loader"", ""uses"", ""Classes""); (""Classes"", ""loaded by"", ""Class Loader"")"
When you implement a class loader that is capable of reloading classes you will need to deviate a bit from this sequence.,"(""class loader"", ""is capable of"", ""reloading classes""); (""class loader"", ""deviates from"", ""sequence"")"
The classes to reload should not be requested loaded by the parent class loader.,"(""classes"", ""should be reloaded by"", ""parent class loader""); (""parent class loader"", ""loads"", ""classes""); (""classes"", ""are loaded by"", ""parent class loader""); (""classes"", ""should not be loaded by"", ""parent class loader""); (""parent class loader"", ""requests"", ""classes""); (""classes"", ""are requested by"", ""parent class loader"")"
All you need to do is to obtain a ClassLoader and call its loadClass() method.,"(""ClassLoader"", ""has method"", ""loadClass()"")"
Java's builtin Class loaders always checks if a class is already loaded before loading it.,"(""Class loaders"", ""checks"", ""class""); (""Class loaders"", ""loads"", ""class""); (""Java"", ""has"", ""Class loaders"")"
Reloading the class is therefore not possible using Java's builtin class loaders.,"(""Java"", ""has"", ""builtin class loaders""); (""Java's builtin class loaders"", ""do not support"", ""reloading the class""); (""Class"", ""can be"", ""reloaded""); (""Java's builtin class loaders"", ""cannot reload"", ""class"")"
To reload a class you will have to implement your own ClassLoader subclass.,"(""ClassLoader"", ""subclass"", ""ClassLoader subclass""); (""ClassLoader"", ""implement"", ""ClassLoader subclass""); (""ClassLoader subclass"", ""reload"", ""class"")"
Even with a custom subclass of ClassLoader you have a challenge.,"(""ClassLoader"", ""has subclass"", ""custom subclass of ClassLoader"")"
"This method is final, and thus cannot be overridden in your ClassLoader subclass.","(""ClassLoader"", ""has method"", ""subclass""); (""ClassLoader"", ""has method"", ""final method""); (""Classloader subclass"", ""overrides"", ""method"")"
The resolve() method will not allow any given ClassLoader instance to link the same class twice.,"(""ClassLoader"", ""instance of"", ""ClassLoader""); (""resolve()"", ""method of"", ""ClassLoader""); (""ClassLoader"", ""links"", ""Class"")"
"Therefore, everytime you want to reload a class you must use a new instance of your ClassLoader subclass.","(""ClassLoader"", ""subclass"", ""ClassLoader subclass""); (""ClassLoader"", ""has instance"", ""ClassLoader instance""); (""ClassLoader subclass"", ""loads"", ""class"")"
"This is not impossible, but necessary to know when designing for class reloading.",
As stated earlier you cannot reload a class using a ClassLoader that has already loaded that class once.,"(""ClassLoader"", ""load"", ""class""); (""Class"", ""load"", ""ClassLoader""); (""ClassLoader"", ""reload"", ""class"")"
Therefore you will have to reload the class using a different ClassLoader instance.,"(""ClassLoader"", ""instance of"", ""ClassLoader""); (""ClassLoader"", ""loads"", ""class""); (""Class"", ""loaded by"", ""ClassLoader"")"
"Every class loaded in a Java application is identified by its fully qualified name (package name + class name), and the ClassLoader instance that loaded it.","(""Class"", ""loaded by"", ""ClassLoader""); (""ClassLoader"", ""loads"", ""Class""); (""Class"", ""identified by"", ""fully qualified name""); (""fully qualified name"", ""consists of"", ""package name""); (""fully qualified name"", ""consists of"", ""class name""); (""Class"", ""has"", ""fully qualified name""); (""ClassLoader"", ""instance of"", ""ClassLoader"")"
"That means, that a class MyObject loaded by class loader A, is not the same class as the MyObject class loaded with class loader B.","(""MyObject"", ""loaded by"", ""class loader A""); (""MyObject"", ""loaded by"", ""class loader B""); (""MyObject"", ""is not the same class as"", ""MyObject"")"
"Notice how the MyObject class is referenced in the code, as the type of the object variable.","(""MyObject"", ""is type of"", ""object"")"
This causes the MyObject class to be loaded by the same class loader that loaded the class this code is residing in.,"(""MyObject"", ""loaded by"", ""class loader""); (""class loader"", ""loaded"", ""this code""); (""MyObject"", ""loaded by same class loader as"", ""this code"")"
"If the myClassReloadingFactory object factory reloads the MyObject class using a different class loader than the class the above code resides in, you cannot cast the instance of the reloaded MyObject class to the MyObject type of the object variable.","(""myClassReloadingFactory"", ""reloads"", ""MyObject""); (""MyObject"", ""is cast to"", ""MyObject""); (""myClassReloadingFactory"", ""uses"", ""class loader""); (""class loader"", ""is different from"", ""class loader""); (""MyObject"", ""is instance of"", ""MyObject"")"
"Since the two MyObject classes were loaded with different class loaders, the are regarded as different classes, even if they have the same fully qualified class name.","(""MyObject"", ""loaded with"", ""class loader""); (""MyObject"", ""has"", ""fully qualified class name""); (""class loader"", ""loads"", ""MyObject"")"
Trying to cast an object of the one class to a reference of the other will result in a ClassCastException.,"(""ClassCastException"", ""isThrownBy"", ""cast operation""); (""cast operation"", ""involves"", ""object""); (""object"", ""isInstanceOf"", ""class""); (""class"", ""hasReference"", ""reference""); (""reference"", ""isOfType"", ""class""); (""ClassCastException"", ""occursDuring"", ""casting""); (""casting"", ""involves"", ""object""); (""object"", ""isOfType"", ""class"")"
"Either of these two methods will work if the type of the variable, the interface or superclass, is not reloaded when the implementing class or subclass is reloaded.","(""interface"", ""is implemented by"", ""class""); (""superclass"", ""is extended by"", ""subclass""); (""class"", ""implements"", ""interface""); (""class"", ""extends"", ""superclass"")"
To make this work you will of course need to implement your class loader to let the interface or superclass be loaded by its parent.,"(""class loader"", ""be loaded by"", ""parent""); (""interface"", ""be loaded by"", ""parent""); (""superclass"", ""be loaded by"", ""parent""); (""class loader"", ""implement"", ""interface""); (""class loader"", ""implement"", ""superclass"")"
"When your class loader is asked to load the MyObject class, it will also be asked to load the MyObjectInterface class, or the MyObjectSuperclass class, since these are referenced from within the MyObject class.","(""MyObject"", ""references"", ""MyObjectInterface""); (""MyObject"", ""references"", ""MyObjectSuperclass""); (""MyObject"", ""loads"", ""MyObjectInterface""); (""MyObject"", ""loads"", ""MyObjectSuperclass"")"
Your class loader must delegate the loading of those classes to the same class loader that loaded the class containing the interface or superclass typed variables.,"(""class loader"", ""delegates to"", ""class loader""); (""class loader"", ""loads"", ""classes""); (""class loader"", ""contains"", ""interface""); (""class loader"", ""contains"", ""superclass""); (""class loader"", ""loads"", ""class"")"
Notice how it delegates class loading to its parent except for the one class it is intended to be able to reload.,"(""Class Loader"", ""delegates class loading to"", ""Parent""); (""Class Loader"", ""reloads"", ""Class"")"
"If the loading of this class is delegated to the parent class loader, it cannot be reloaded later.","(""class"", ""is loaded by"", ""parent class loader""); (""parent class loader"", ""delegates loading of"", ""class"")"
"Remember, a class can only be loaded once by the same ClassLoader instance.","(""Class"", ""can be loaded by"", ""ClassLoader""); (""ClassLoader"", ""loads"", ""Class"")"
It is not a production ready template for your own class loaders.,"(""class loaders"", ""is part of"", ""template""); (""template"", ""is not ready for"", ""production""); (""template"", ""is for"", ""class loaders"")"
"Your own class loaders should probably not be limited to a single class, but a collection of classes that you know you will need to reload.","(""class loaders"", ""should probably not be limited to"", ""a single class""); (""class loaders"", ""are limited to"", ""a collection of classes""); (""a single class"", ""is part of"", ""a collection of classes""); (""class loaders"", ""will need to reload"", ""a collection of classes"")"
"In addition, you should probably not hardcode the class paths either.",
Here is the reflection.MyObject class that is loaded using the class loader.,"(""MyObject"", ""loaded using"", ""class loader""); (""MyObject"", ""is a"", ""class""); (""class loader"", ""loads"", ""MyObject"")"
Notice how it both extends a superclass and implements an interface.,"(""superclass"", ""extended by"", ""subclass""); (""interface"", ""implemented by"", ""subclass"")"
The name of this class is why I refer to these dynamic interface implementations as dynamic proxies.,
As mentioned earlier you must pass an InvocationHandler implementation to the Proxy.newProxyInstance() method.,"(""InvocationHandler"", ""passed to"", ""Proxy.newProxyInstance()""); (""Proxy"", ""has method"", ""newProxyInstance()"")"
The proxy parameter passed to the invoke() method is the dynamic proxy object implementing the interface.,"(""invoke"", ""is a method of"", ""dynamic proxy object""); (""dynamic proxy object"", ""implements"", ""interface""); (""interface"", ""is implemented by"", ""dynamic proxy object""); (""proxy parameter"", ""is passed to"", ""invoke""); ("".invoke"", ""has parameter"", ""proxy parameter""); (""dynamic proxy object"", ""has method"", ""invoke"")"
The Method object passed into the invoke() method represents the method called on the interface the dynamic proxy implements.,"(""Method"", ""passed into"", ""invoke()""); (""Method"", ""called on"", ""interface""); (""interface"", ""implemented by"", ""dynamic proxy""); (""invoke()"", ""represents"", ""Method"")"
"But now you can check via the mock if the DAO uses the connection properly, for instance if the connection.close() is called (or NOT called), if you expected that.","(""DAO"", ""uses"", ""connection""); (""connection"", ""has method"", ""close()""); (""DAO"", ""checks"", ""connection.close()"")"
Thus the factory interface and your class could look something like this:,
"When the MyAction class calls methods on the IMyFactory instance injected into its constructor by the container, the method calls are translated into calls to the IContainer.instance() method, which is the method you use to obtain instances from the container.","(""MyAction"", ""calls"", ""IMyFactory""); (""IMyFactory"", ""injected into"", ""MyAction""); (""MyAction"", ""calls"", ""IContainer.instance()""); (""IContainer.instance()"", ""obtains"", ""instances""); (""MyAction"", ""uses"", ""IContainer.instance()"")"
Using Java Reflection you can inspect the fields (member variables) of classes and get / set them at runtime.,"(""Java Reflection"", ""inspects"", ""fields""); (""Java Reflection"", ""gets"", ""fields""); (""Java Reflection"", ""sets"", ""fields""); (""fields"", ""are part of"", ""classes"")"
The Field[] array will have one Field instance for each public field declared in the class.,"(""Field"", ""contains"", ""Field""); (""Field"", ""declaredIn"", ""class"")"
"If no field exists with the name given as parameter to the getField() method, a NoSuchFieldException is thrown.","(""getField()"", ""throws"", ""NoSuchFieldException"")"
"Once you have obtained a Field instance, you can get its field name using the Field.getName() method, like this:","(""Field"", ""hasMethod"", ""Field.getName()""); (""Field.getName()"", ""returns"", ""field name""); (""Field"", ""usesMethod"", ""Field.getName()"")"
"Once you have obtained a Field reference you can get and set its values using the Field.get() and Field.set()methods, like this:","(""Field"", ""hasMethod"", ""Field.get()""); (""Field"", ""hasMethod"", ""Field.set()"")"
The objectInstance parameter passed to the get and set method should be an instance of the class that owns the field.,"(""objectInstance"", ""passed to"", ""get method""); (""objectInstance"", ""passed to"", ""set method""); (""get method"", ""owned by"", ""class""); (""set method"", ""owned by"", ""class""); (""class"", ""owns"", ""field"")"
"In the above example an instance of MyObject is used, because the someField is an instance member of the MyObject class.","(""MyObject"", ""hasInstanceMember"", ""someField""); (""MyObject"", ""hasField"", ""someField""); (""someField"", ""isMemberOf"", ""MyObject"")"
"It the field is a static field (public static ...) pass null as parameter to the get and set methods, instead of the objectInstance parameter passed above.","(""Field"", ""is accessed by"", ""get methods""); (""Field"", ""is accessed by"", ""set methods""); (""get methods"", ""take parameter"", ""null""); (""set methods"", ""take parameter"", ""null""); (""Field"", ""is type of"", ""static field"")"
When you write a class or interface you can specify that it should be paramerizable.,"(""class"", ""has characteristic"", ""paramerizable""); (""class"", ""can be"", ""interface""); (""interface"", ""can be"", ""paramerizable"")"
"Rather than create a list of Object you can parameterize java.util.List to create a list of say String, like this:","(""java.util.List"", ""is parameterized by"", ""String""); (""java.util.List"", ""can create a list of"", ""Object""); (""java.util.List"", ""can be parameterized to create a list of"", ""String"")"
"When inspecting a parameterizable type itself at runtime via reflection, like java.util.List, there is no way of knowing what type is has been parameterized to.","(""java.util.List"", ""has parameterizable type"", ""runtime""); (""reflection"", ""used for inspecting"", ""java.util.List""); (""java.util.List"", ""has no way of knowing"", ""parameterized type"")"
If you have obtained a java.lang.reflect.Method object it is possible to obtain information about its generic return type.,"(""java.lang.reflect.Method"", ""has return type"", ""generic return type""); (""java.lang.reflect.Method"", ""obtains information about"", ""generic return type"")"
Here is an example class with a method having a parameterized return type:,
In this class it is possible to obtain the generic return type of the getStringList() method.,"(""class"", ""hasMethod"", ""getStringList()""); (""getStringList()"", ""returns"", ""generic return type""); (""class"", ""contains"", ""getStringList()"")"
"In other words, it is possible to detect that getStringList() returns a List<String> and not just a List.","(""List"", ""returns"", ""String""); (""String"", ""is part of"", ""List""); (""List"", ""contains"", ""String"")"
"This piece of code will print out the text ""typeArgClass = java.lang.String"".","(""typeArgClass"", ""is assigned"", ""java.lang.String"")"
The Type[] array typeArguments array will contain one item - a Class instance representing the class java.lang.String.,"(""Type"", ""contains"", ""Class""); (""Class"", ""represents"", ""java.lang.String"")"
Here is an example class with a method taking a parameterized List as parameter:,"(""List"", ""is parameter of"", ""method""); (""method"", ""is part of"", ""class""); (""class"", ""has method"", ""method""); (""List"", ""is used by"", ""method"")"
The Type[] array parameterArgTypes array will contain one item - a Class instance representing the class java.lang.String.,"(""Type"", ""contains"", ""Class""); (""Class"", ""represents"", ""java.lang.String""); (""parameterArgTypes"", ""is"", ""Type""); (""Type"", ""is"", ""array""); (""Class"", ""is"", ""instance"")"
Fields are class member variables - either static or instance variables.,"(""Field"", ""is_a"", ""class member variable""); (""Field"", ""can_be"", ""static variable""); (""Field"", ""can_be"", ""instance variable"")"
The Type[] array fieldArgTypes array will contain one item - a Class instance representing the class java.lang.String.,"(""Type"", ""contains"", ""Class""); (""Class"", ""represents"", ""java.lang.String"")"
Using Java Reflection you can inspect the methods of classes and invoke them at runtime.,"(""Java Reflection"", ""inspects"", ""methods""); (""Java Reflection"", ""inspects"", ""classes""); (""methods"", ""invoked by"", ""Java Reflection""); (""classes"", ""inspected by"", ""Java Reflection"")"
This can be used to detect what getters and setters a given class has.,"(""Class"", ""has"", ""getters""); (""Class"", ""has"", ""setters""); (""getters"", ""are part of"", ""Class""); (""setters"", ""are part of"", ""Class"")"
"You cannot ask for getters and setters explicitly, so you will have to scan through all the methods of a class and check if each method is a getter or setter.","(""class"", ""has"", ""methods""); (""method"", ""is"", ""getter""); (""method"", ""is"", ""setter""); (""class"", ""has"", ""method"")"
Here is a code example that finds getter and setters of a class:,"(""Class"", ""hasMethod"", ""getter""); (""Class"", ""hasMethod"", ""setter""); (""Class"", ""uses"", ""Reflection""); (""Reflection"", ""provides"", ""getter""); (""Reflection"", ""provides"", ""setter"")"
The Method[] array will have one Method instance for each public method declared in the class.,"(""Method"", ""contains"", ""Method""); (""Class"", ""declares"", ""Method""); (""Method"", ""isDeclaredIn"", ""Class"")"
"This example returns the public method named ""doSomething"", in the given class which takes a String as parameter:","(""Class"", ""hasMethod"", ""doSomething""); (""doSomething"", ""takesParameter"", ""String"")"
"If no method matches the given method name and arguments, in this case String.class, a NoSuchMethodException is thrown.","(""NoSuchMethodException"", ""thrown by"", ""method mismatch""); (""NoSuchMethodException"", ""has cause"", ""method name and arguments""); (""String.class"", ""used as"", ""method argument"")"
"In this example, if doSomething(String.class) is not static, you need to supply a valid MyObject instance instead of null;","(""MyObject"", ""has method"", ""doSomething(String.class)""); (""doSomething(String.class)"", ""requires instance of"", ""MyObject""); (""String"", ""is parameter type of"", ""doSomething(String.class)"")"
"The Method.invoke(Object target, Object ... parameters) method takes an optional amount of parameters, but you must supply exactly one parameter per argument in the method you are invoking.","(""Method"", ""invokes"", ""Object""); (""Method.invoke"", ""takes"", ""Object""); (""Method.invoke"", ""takes"", ""parameters""); (""Method"", ""has"", ""parameters""); (""Method.invoke"", ""requires"", ""argument""); (""parameters"", ""are supplied to"", ""Method""); (""argument"", ""is passed to"", ""Method.invoke"")"
This Java module reflection tutorial will explain how to access the Java Module a Java class belongs to via Java reflection.,"(""Java"", ""has"", ""Module""); (""Java class"", ""belongs to"", ""Java Module""); (""Java reflection"", ""accesses"", ""Java Module""); (""Java reflection"", ""accesses"", ""Java class""); (""Java"", ""uses"", ""Java reflection"")"
"Thus, each Java class belongs to a package, and the package belongs to a module.","(""Java class"", ""belongs to"", ""package""); (""package"", ""belongs to"", ""module"")"
A Java module is represented by the Java reflection class java.lang.Module in the Java module java.base.,"(""java.lang.Module"", ""is represented by"", ""Java module""); (""Java module"", ""is represented by"", ""java.lang.Module""); (""java.lang.Module"", ""is in"", ""java.base""); (""Java module"", ""is in"", ""java.base""); (""java.base"", ""contains"", ""java.lang.Module"")"
"Via this class you can interact with the Java Platform Module System to obtain information about a given module, or modify a module.","(""Java Platform Module System"", ""interact with"", ""class""); (""class"", ""obtain information about"", ""module""); (""class"", ""modify"", ""module"")"
"You can obtain an instance of the Module class via a Class instance, like this:","(""Module"", ""obtained via"", ""Class""); (""Class"", ""instance of"", ""Module"")"
You can check if a Module instance a represents a named module by calling the Module isNamed() method.,"(""Module"", ""has method"", ""isNamed()""); (""Module"", ""represents"", ""named module""); (""isNamed()"", ""is method of"", ""Module"")"
You can check if a Module is a named module via the Module isOpen() method.,"(""Module"", ""has method"", ""Module.isOpen()""); (""Module"", ""checked by"", ""Module.isOpen()""); (""Module.isOpen()"", ""belongs to"", ""Module"")"
Once you have access to a Module instance you can access its ModuleDescriptor via the getDescriptor() method.,"(""Module"", ""has method"", ""getDescriptor()""); (""Module"", ""accesses"", ""ModuleDescriptor""); (""getDescriptor()"", ""returns"", ""ModuleDescriptor"")"
Here is an example of accessing a Java Module's ModuleDescriptor via getDescriptor() :,"(""Module"", ""has method"", ""getDescriptor()""); (""getDescriptor()"", ""returns"", ""ModuleDescriptor""); (""Module"", ""has attribute"", ""ModuleDescriptor"")"
You can get the name of a named module from its module descriptor via the ModuleDescriptor name() method.,"(""ModuleDescriptor"", ""has method"", ""name()"")"
"You can read the list of packages exported by a Java module via Java reflection, via the ModuleDescriptor exports() method.","(""ModuleDescriptor"", ""exports"", ""packages""); (""Java"", ""uses"", ""Java reflection""); (""ModuleDescriptor"", ""hasMethod"", ""exports()""); (""Java module"", ""exports"", ""packages""); (""Java reflection"", ""isUsedBy"", ""ModuleDescriptor"")"
You can check if a Java module is an automatic module or not via the ModuleDescriptor isAutomatic() method.,"(""ModuleDescriptor"", ""hasMethod"", ""isAutomatic()""); (""ModuleDescriptor"", ""isAutomatic"", ""Java module""); (""Java module"", ""checkedBy"", ""ModuleDescriptor.isAutomatic()"")"
You can check if a Java module is an open module or not via the ModuleDescriptor isOpen() method.,"(""ModuleDescriptor"", ""has method"", ""isOpen()""); (""Java module"", ""described by"", ""ModuleDescriptor""); (""ModuleDescriptor"", ""provides"", ""isOpen()"")"
You can read the module service dependencies via the ModuleDescriptor uses() method.,"(""ModuleDescriptor"", ""uses"", ""module service dependencies"")"
Despite the common belief it is actually possible to access private fields and methods of other classes via Java Reflection.,"(""Java Reflection"", ""accesses"", ""private fields""); (""Java Reflection"", ""accesses"", ""private methods""); (""Java Reflection"", ""is used with"", ""private fields""); (""Java Reflection"", ""is used with"", ""private methods""); (""private fields"", ""are accessed by"", ""Java Reflection""); (""private methods"", ""are accessed by"", ""Java Reflection"")"
To access a private field you will need to call the Class.getDeclaredField(String name) or Class.getDeclaredFields() method.,"(""Class"", ""hasMethod"", ""Class.getDeclaredField(String name)""); (""Class"", ""hasMethod"", ""Class.getDeclaredFields()"")"
"The methods Class.getField(String name) and Class.getFields() methods only return public fields, so they won't work.","(""Class"", ""hasMethod"", ""getField(String name)""); (""Class"", ""hasMethod"", ""getFields()""); (""getField(String name)"", ""returns"", ""public fields""); (""getFields()"", ""returns"", ""public fields"")"
"Here is a simple example of a class with a private field, and below that the code to access that field via Java Reflection:","(""Class"", ""hasField"", ""private field""); (""Java Reflection"", ""accesses"", ""private field""); (""Class"", ""uses"", ""Java Reflection"")"
"This method only returns fields declared in that particular class, not fields declared in any superclasses.","(""Method"", ""returns"", ""fields""); (""fields"", ""declared in"", ""class""); (""class"", ""has"", ""superclasses""); (""superclasses"", ""have"", ""fields""); (""Method"", ""does not return"", ""fields declared in superclasses""); (""class"", ""has"", ""fields""); (""fields"", ""declared in"", ""class"")"
"By calling Field.setAcessible(true) you turn off the access checks for this particular Field instance, for reflection only.","(""Field"", ""hasMethod"", ""setAccessible()""); (""setAccessible()"", ""calledWith"", ""true""); (""Field"", ""usedFor"", ""reflection"")"
"To access a private method you will need to call the Class.getDeclaredMethod(String name, Class[] parameterTypes) or Class.getDeclaredMethods() method.","(""Class"", ""hasMethod"", ""getDeclaredMethod""); (""Class"", ""hasMethod"", ""getDeclaredMethods""); (""getDeclaredMethod"", ""takesParameter"", ""String""); (""getDeclaredMethod"", ""takesParameter"", ""Class""); (""getDeclaredMethods"", ""returns"", ""Method"")"
"The methods Class.getMethod(String name, Class[] parameterTypes) and Class.getMethods() methods only return public methods, so they won't work.","(""Class"", ""getMethod"", ""String""); (""Class"", ""getMethod"", ""Class""); (""Class"", ""getMethods"", """"); (""Class.getMethod"", ""returns"", ""public methods""); (""Class.getMethods"", ""returns"", ""public methods"")"
"Here is a simple example of a class with a private method, and below that the code to access that method via Java Reflection:","(""Class"", ""hasMethod"", ""private method""); (""Java Reflection"", ""accesses"", ""private method""); (""Class"", ""uses"", ""Java Reflection"")"
"This code example will print out the text ""returnValue = The Private Value"", which is the value returned by the method getPrivateString() when invoked on the PrivateObject instance created at the beginning of the code sample.","(""PrivateObject"", ""hasMethod"", ""getPrivateString()""); (""PrivateObject"", ""invokes"", ""getPrivateString()""); (""getPrivateString()"", ""returns"", ""returnValue"")"
"This method only returns methods declared in that particular class, not methods declared in any superclasses.","(""Class"", ""declares"", ""methods""); (""Superclasses"", ""declare"", ""methods""); (""Class"", ""has"", ""superclasses"")"
"By calling Method.setAcessible(true) you turn off the access checks for this particular Method instance, for reflection only.","(""Method"", ""setAcessible"", ""Method""); (""Method"", ""has instance"", ""Method""); (""Method"", ""used for"", ""reflection"")"
"Java Reflection makes it possible to inspect classes, interfaces, fields and methods at runtime, without knowing the names of the classes, methods etc.","(""Java Reflection"", ""makes possible to inspect"", ""classes""); (""Java Reflection"", ""makes possible to inspect"", ""interfaces""); (""Java Reflection"", ""makes possible to inspect"", ""fields""); (""Java Reflection"", ""makes possible to inspect"", ""methods"")"
"It will explain the basics of Java Reflection including how to work with arrays, annotations, generics and dynamic proxies, and do dynamic class loading and reloading.","(""Java Reflection"", ""includes"", ""arrays""); (""Java Reflection"", ""includes"", ""annotations""); (""Java Reflection"", ""includes"", ""generics""); (""Java Reflection"", ""includes"", ""dynamic proxies""); (""Java Reflection"", ""involves"", ""dynamic class loading""); (""Java Reflection"", ""involves"", ""dynamic class reloading"")"
"It will also show you how to do more specific Java Reflection tasks, like reading all getter methods of a class, or accessing private fields and methods of a class.","(""Java Reflection"", ""has method"", ""read""); (""Class"", ""has methods"", ""getter methods""); (""Class"", ""has fields"", ""private fields""); (""Class"", ""has methods"", ""private methods""); (""Java Reflection"", ""can access"", ""private fields""); (""Java Reflection"", ""can access"", ""private methods"")"
This example obtains the Class object from the class called MyObject.,"(""MyObject"", ""has Class object"", ""Class"")"
"Using the class object the example gets a list of the methods in that class, iterates the methods and print out their names.","(""class"", ""has"", ""methods""); (""class"", ""gets"", ""list of methods""); (""methods"", ""are iteration target"", ""class""); (""methods"", ""have"", ""names""); (""class object"", ""gets"", ""methods""); (""methods"", ""are printed"", ""class"")"
When using Java reflection the starting point is often a Class object representing some Java class you want to inspect via reflection.,"(""Class"", ""represents"", ""Java class""); (""Java reflection"", ""uses"", ""Class object""); (""Class object"", ""represents"", ""Java class"")"
"For instance, to obtain the Class object for a class named MyObject you could write:","(""MyObject"", ""has Class object"", ""Class"")"
Now you have a reference to the Class object for the MyObject class.,"(""MyObject"", ""hasClassObject"", ""Class"")"
"Once you have a reference to the Class object representing some class, you can see what fields that class contains.","(""Class"", ""contains"", ""fields""); (""Class object"", ""represents"", ""class""); (""Class object"", ""has"", ""reference"")"
Here is an example of accessing fields of a Java class:,
Using Java Reflection it is possible find out what constructors a given Java class contains and what parameters they take etc.,"(""Java Reflection"", ""contains"", ""constructors""); (""constructors"", ""take"", ""parameters""); (""Java class"", ""contains"", ""constructors""); (""Java Reflection"", ""find out"", ""Java class"")"
You can also see what methods a given class has from its Class object.,"(""Class"", ""has"", ""methods""); (""Class"", ""from"", ""Class object"")"
Here is an example of accessing the methods a given class via Java reflection:,"(""Java"", ""uses"", ""reflection""); (""reflection"", ""provides"", ""methods""); (""Class"", ""accesses"", ""methods""); (""methods"", ""belong to"", ""Class""); (""Java"", ""utilizes"", ""Class""); (""reflection"", ""is used by"", ""Java"")"
You can also use Java reflection to find out what getter and setter methods a class has.,"(""Java"", ""has"", ""reflection""); (""reflection"", ""can be used to find"", ""getter methods""); (""reflection"", ""can be used to find"", ""setter methods""); (""getter methods"", ""are part of"", ""class""); (""setter methods"", ""are part of"", ""class""); (""class"", ""has"", ""getter methods""); (""class"", ""has"", ""setter methods"")"
You can even access private fields and methods via Java reflection - even from outside the class that owns the private field or method.,"(""Java"", ""uses"", ""reflection""); (""reflection"", ""accesses"", ""private fields""); (""reflection"", ""accesses"", ""private methods""); (""private fields"", ""are accessed by"", ""reflection""); (""private methods"", ""are accessed by"", ""reflection""); (""class"", ""owns"", ""private fields""); (""class"", ""owns"", ""private methods""); (""reflection"", ""works from"", ""outside the class"")"
"In case a Java class has annotations which are available at runtime, you can access them via Java reflection too.","(""Java class"", ""has"", ""annotations""); (""annotations"", ""are available at"", ""runtime""); (""Java reflection"", ""can access"", ""annotations""); (""Java class"", ""can be accessed via"", ""Java reflection"")"
"For instance, you can determine what type of class the array is an array of.","(""Array"", ""is an array of"", ""Class"")"
"For instance, if you are introspecting a String array, you can detect that the element type is String by inspecting the array class.","(""String"", ""has element type"", ""String""); (""String"", ""is element type of"", ""array class""); (""array class"", ""has element type"", ""String"")"
"Java reflection has a special Proxy class that can implement a Java Interface dynamically at runtime, rather than at compile time.","(""Java"", ""has"", ""Proxy class""); (""Proxy class"", ""implements"", ""Java Interface""); (""Java Interface"", ""implemented at"", ""runtime""); (""Java Interface"", ""implemented at"", ""compile time""); (""Proxy class"", ""implements at"", ""runtime"")"
In Java it is possible to dynamically load and also reload classes using a Java ClassLoader.,"(""Java"", ""uses"", ""ClassLoader""); (""ClassLoader"", ""loads"", ""classes""); (""classes"", ""are loaded by"", ""ClassLoader""); (""Java ClassLoader"", ""reloads"", ""classes""); (""classes"", ""can be reloaded by"", ""Java ClassLoader"")"
"The ClassLoader class is actually not part of the Java Reflection API, but since Java Reflection is often used to achieve ""dynamic"" behaviour (behavioral changes at runtime), and dynamic class loading and reloading kind of fits into this theme, I have decided to include that tutorial in my Java Reflection tutorial.","(""ClassLoader"", ""isPartOf"", ""Java Reflection API""); (""Java Reflection"", ""isUsedFor"", ""dynamic behaviour""); (""Java Reflection"", ""includes"", ""ClassLoader""); (""ClassLoader"", ""isUsedFor"", ""dynamic class loading""); (""ClassLoader"", ""isUsedFor"", ""dynamic class reloading"")"
Dynamic class loading and reloading is explained in my Java Reflection - Dynamic Class Loading and Reloading tutorial.,"(""Java Reflection"", ""explains"", ""Dynamic Class Loading and Reloading""); (""Dynamic Class Loading and Reloading"", ""is explained in"", ""Java Reflection - Dynamic Class Loading and Reloading tutorial"")"
The Java regex API is located in the java.util.regex package which has been part of standard Java (JSE) since Java 1.4.,"(""java.util.regex"", ""is located in"", ""Java""); (""Java"", ""has package"", ""java.util.regex""); (""Java 1.4"", ""includes"", ""java.util.regex""); (""Java"", ""has version"", ""Java 1.4""); (""java.util.regex"", ""is part of"", ""Java""); (""java.util.regex"", ""is part of"", ""JSE""); (""Java"", ""has edition"", ""JSE""); (""JSE"", ""includes"", ""java.util.regex"")"
"Although Java regex has been part of standard Java since Java 1.4, this Java regex tutorial covers the Java regex API released with Java 8.","(""Java"", ""has"", ""Java regex API""); (""Java regex API"", ""released with"", ""Java 8""); (""Java regex"", ""part of"", ""standard Java""); (""standard Java"", ""since"", ""Java 1.4"")"
But first I will introduce the core classes of the Java regex API in the following section.,"(""Java regex API"", ""has classes"", ""core classes""); (""core classes"", ""are part of"", ""Java regex API"")"
The Matcher class is used to match a given regular expression (Pattern instance) against a text multiple times.,"(""Matcher"", ""uses"", ""Pattern""); (""Matcher"", ""matches"", ""text"")"
Both the Pattern and Matcher classes are covered in detail in their own texts.,"(""Pattern"", ""is covered in"", ""detail text""); (""Matcher"", ""is covered in"", ""detail text""); (""Pattern"", ""has own"", ""text""); (""Matcher"", ""has own"", ""text"")"
The third line uses the Pattern.matches() static method to check if the regular expression (pattern) matches the text.,"(""Pattern"", ""uses"", ""matches""); (""Pattern.matches"", ""checks"", ""regular expression""); (""regular expression"", ""matches"", ""text"")"
"If the regular expression matches the text, then Pattern.matches() returns true.","(""Pattern"", ""matches"", ""text""); (""Pattern.matches()"", ""returns"", ""true""); (""Pattern"", ""has method"", ""matches()"")"
If the regular expression does not match the text Pattern.matches() returns false.,"(""Pattern"", ""matches"", ""text"")"
"The example does not actually check if the found http:// string is part of a valid URL, with domain name and suffix (.com, .net etc.).",
"Here is another Java regex example which uses the Matcher class to locate multiple occurrences of the substring ""is"" inside a text:","(""Matcher"", ""uses"", ""Java regex example""); (""Matcher"", ""locate"", ""substring""); (""Java regex example"", ""uses"", ""Matcher""); (""Matcher"", ""locate"", ""occurrences""); (""Matcher"", ""inside"", ""text"")"
The special metacharacter meaning of an escaped metacharacter is ignored - only its actual literal value (e.g.,
Java regular expressions support matching any of a specified set of characters using what is referred to as character classes.,
"The character class (set of characters to match) is enclosed in the square brackets - the [ae] part of the regular expression, in other words.","(""class"", ""enclosed in"", ""square brackets""); (""regular expression"", ""contains"", ""character class""); (""character class"", ""defined by"", ""square brackets"")"
"The character class will match one of the enclosed characters regardless of which, but no mor than one.",
"For instance, the character class [a-z] will match all characters between a lowercase a and a lowercase z, both a and z included.",
You can have more than one character range within a character class.,
"For instance, the character class [a-zA-Z] will match all letters between a and z or between A and Z .",
"For instance, the character class [0-9] will match the characters between 0 and 9, both included.","(""Character"", ""isMatchedWith"", ""0-9""); (""0-9"", ""isBetween"", ""0""); (""0-9"", ""isBetween"", ""9""); (""Character"", ""matches"", ""0""); (""Character"", ""matches"", ""9"")"
"If you want to match the square brackets inside a character class, here is how that looks:",
The character class contains the two square brackets escaped (\\[ and \\]).,"(""character class"", ""contains"", ""square brackets""); (""character class"", ""escaped"", ""\\"")"
You can match digits of a number with the predefined character class with the code \d.,
Matching non-digits can be done with the predefined character class [\D] (uppercase D).,"(""\D"", ""is_a"", ""character class"")"
You can match word characters with the predefined character class with the code \w .,"(""character class"", ""has property"", ""\w""); (""predefined character class"", ""used for"", ""matching word characters""); (""matching word characters"", ""uses"", ""\w""); (""\w"", ""is type of"", ""character class"")"
You can match non-word characters with the predefined character class [\W] (uppercase W).,"(""\W"", ""is a"", ""character class""); (""character class"", ""matches"", ""non-word characters"")"
Here is a regular expression example using the non-word character class:,
The Java String class has a few regular expression methods too.,"(""String"", ""has"", ""regular expression methods""); (""Java"", ""has"", ""String class""); (""String"", ""has"", ""methods"")"
The Java String split() method splits the string into N substrings and returns a String array with these substrings.,"(""String"", ""hasMethod"", ""split()""); (""split()"", ""returns"", ""String""); (""String"", ""hasMethod"", ""split()""); (""String"", ""splitsInto"", ""String array""); (""String"", ""returns"", ""String array""); (""Java"", ""hasClass"", ""String""); (""String"", ""hasMethod"", ""split()"")"
The split() method takes a regular expression as parameter and splits the string at all positions in the string where the regular expression matches a part of the string.,"(""string"", ""hasMethod"", ""split()""); (""split()"", ""takesParameter"", ""regular expression""); (""string"", ""contains"", ""regular expression"")"
The Java Matcher class (java.util.regex.Matcher) is used to search through a text for multiple occurrences of a regular expression.,"(""java.util.regex.Matcher"", ""is_used_to_search"", ""text""); (""java.util.regex.Matcher"", ""searches_for"", ""regular_expression"")"
I will cover the core methods of the Java Matcher class in this tutorial.,"(""Java"", ""has class"", ""Matcher""); (""Matcher"", ""has methods"", ""core methods"")"
"For a full list, see the official JavaDoc for the Matcher class.","(""Matcher"", ""is part of"", ""JavaDoc"")"
Here is a quick Java Matcher example so you can get an idea of how the Matcher class works:,"(""Matcher"", ""works"", ""Matcher class""); (""Java"", ""uses"", ""Matcher""); (""Matcher class"", ""is part of"", ""Java"")"
"The matches() returns true if the regular expression matches the text, and false if not.","(""matches()"", ""returns"", ""true""); (""matches()"", ""returns"", ""false""); (""regular expression"", ""matches"", ""text"")"
You can do a whole lot more with the Matcher class.,"(""Matcher class"", ""is used by"", ""user""); (""Matcher class"", ""has methods"", ""Matcher class methods""); (""Matcher class"", ""belongs to"", ""java.util.regex package"")"
The Pattern class is covered separately in my Java Regex Pattern tutorial.,"(""Pattern"", ""is covered in"", ""Java Regex Pattern tutorial"")"
Creating a Matcher is done via the matcher() method in the Pattern class.,"(""Pattern"", ""hasMethod"", ""matcher()""); (""Pattern"", ""contains"", ""Matcher""); (""matcher()"", ""isMethodOf"", ""Pattern"")"
"The matches() method in the Matcher class matches the regular expression against the whole text passed to the Pattern.matcher() method, when the Matcher was created.","(""Matcher"", ""hasMethod"", ""matches()""); (""Matcher"", ""createdFrom"", ""Pattern.matcher()""); (""Pattern"", ""hasMethod"", ""matcher()""); (""Matcher"", ""matchesAgainst"", ""text""); (""Pattern"", ""hasMethod"", ""matcher()"")"
"If the regular expression matches the whole text, then the matches() method returns true.","(""matches()"", ""returns"", ""true"")"
You cannot use the matches() method to search for multiple occurrences of a regular expression in a text.,"(""matches()"", ""is_method_of"", ""String""); (""matches()"", ""used_for"", ""regular_expression""); (""regular_expression"", ""is_searched_in"", ""text"")"
"For that, you need to use the find(), start() and end() methods.","(""find()"", ""part of"", ""some class""); (""start()"", ""part of"", ""some class""); (""end()"", ""part of"", ""some class"")"
The Matcher lookingAt() method works like the matches() method with one major difference.,"(""Matcher"", ""has_method"", ""lookingAt()""); (""Matcher"", ""has_method"", ""matches()"")"
"The lookingAt() method only matches the regular expression against the beginning of the text, whereas matches() matches the regular expression against the whole text.","(""lookingAt()"", ""is_method_of"", ""String""); (""matches()"", ""is_method_of"", ""String""); (""lookingAt()"", ""contrasts_with"", ""matches()"")"
"In other words, if the regular expression matches the beginning of a text but not the whole text, lookingAt() will return true, whereas matches() will return false.","(""lookingAt()"", ""returns true for"", ""partial matches""); (""matches()"", ""returns false for"", ""partial matches""); (""lookingAt()"", ""contrasted with"", ""matches()"")"
Matching the regular expression against the beginning of the text (lookingAt()) will return true.,"(""lookingAt"", ""method of"", ""regular expression""); (""lookingAt"", ""returns"", ""true""); (""regular expression"", ""has method"", ""lookingAt()"")"
"Matching the regular expression against the whole text (matches()) will return false, because the text has more characters than the regular expression.","(""Regular Expression"", ""matches"", ""Text""); (""matches()"", ""returns"", ""False""); (""Regular Expression"", ""applied to"", ""Whole Text"")"
"The Matcher find() method searches for occurrences of the regular expressions in the text passed to the Pattern.matcher(text) method, when the Matcher was created.","(""Matcher"", ""hasMethod"", ""find()""); (""Pattern"", ""hasMethod"", ""matcher()""); (""Matcher"", ""createdBy"", ""Pattern.matcher()""); (""Pattern.matcher()"", ""returns"", ""Matcher"")"
"If multiple matches can be found in the text, the find() method will find the first, and then for each subsequent call to find() it will move to the next match.","(""find() method"", ""is part of"", ""text""); (""find() method"", ""finds"", ""match""); (""find() method"", ""moves to"", ""next match""); (""match"", ""is found by"", ""find() method""); (""match"", ""is in"", ""text""); (""next match"", ""is found by"", ""find() method""); (""find() method"", ""is called subsequently on"", ""text""); (""text"", ""contains"", ""match""); (""text"", ""contains"", ""next match""); (""find() method"", ""is called on"", ""text"")"
The methods start() and end() will give the indexes into the text where the found match starts and ends.,"(""start()"", ""gives"", ""index""); (""end()"", ""gives"", ""index""); (""start()"", ""relates to"", ""end()""); (""start()"", ""provides"", ""indexes""); (""end()"", ""provides"", ""indexes"")"
Actually end() returns the index of the character just after the end of the matching section.,"(""end()"", ""returns"", ""index""); (""end()"", ""is part of"", ""matching section""); (""matching section"", ""has"", ""end""); (""index"", ""is result of"", ""end()"")"
"Thus, you can use the return values of start() and end() inside a String.substring() call.","(""String"", ""has method"", ""substring()""); (""start"", ""has return value"", ""end""); (""String"", ""calls method"", ""substring""); (""start"", ""returns value to"", ""substring""); (""end"", ""returns value to"", ""substring"")"
The Matcher reset() method resets the matching state internally in the Matcher.,"(""Matcher"", ""has method"", ""reset()""); (""reset()"", ""resets"", ""matching state""); (""Matcher"", ""has internal state"", ""matching state"")"
"In case you have started matching occurrences in a string via the find() method, the Matcher will internally keep a state about how far it has searched through the input text.","(""Matcher"", ""has method"", ""find()""); (""Matcher"", ""keeps state of"", ""input text""); (""find()"", ""is method of"", ""Matcher"")"
By calling reset() the matching will start from the beginning of the text again.,"(""reset()"", ""called by"", ""unspecified class""); (""unspecified class"", ""has method"", ""reset()""); (""text"", ""has beginning"", ""beginning of the text"")"
"Of course you could do this with the start() and end() methods, but it is easier to do so with the group functions.","(""start()"", ""end()"", ""group()""); (""group"", ""is easier to use than"", ""start() and end()""); (""start()"", ""is alternative to"", ""group()""); (""end()"", ""is alternative to"", ""group()"")"
The Matcher replaceAll() and replaceFirst() methods can be used to replace parts of the string the Matcher is searching through.,"(""Matcher"", ""has method"", ""replaceAll()""); (""Matcher"", ""has method"", ""replaceFirst()"")"
"The Matcher appendReplacement() and appendTail() methods are used to replace string tokens in an input text, and append the resulting string to a StringBuffer.","(""Matcher"", ""hasMethod"", ""appendReplacement()""); (""Matcher"", ""hasMethod"", ""appendTail()""); (""appendReplacement()"", ""usedFor"", ""replacing string tokens""); (""appendTail()"", ""usedFor"", ""appending resulting string""); (""Matcher"", ""uses"", ""StringBuffer"")"
"When you have found a match using the find() method, you can call the appendReplacement().","(""find() method"", ""used by"", ""appendReplacement()""); (""appendReplacement()"", ""called after"", ""find() method""); (""find() method"", ""returns match for"", ""appendReplacement()"")"
"The appendReplacement() method keeps track of what has been copied into the StringBuffer, so you can continue searching for matches using find() until no more matches are found in the input text.","(""appendReplacement()"", ""is method of"", ""StringBuffer""); (""find()"", ""is method of"", ""undefined""); (""appendReplacement()"", ""uses"", ""find()""); (""appendReplacement()"", ""affects"", ""StringBuffer""); (""StringBuffer"", ""has method"", ""appendReplacement()"")"
By calling appendTail() you can append these last characters to the StringBuffer too.,"(""StringBuffer"", ""calls"", ""appendTail()"")"
"Notice how appendReplacement() is called inside the while(matcher.find()) loop, and appendTail() is called just after the loop.","(""matcher"", ""hasMethod"", ""find()""); (""matcher"", ""hasMethod"", ""appendReplacement()""); (""matcher"", ""hasMethod"", ""appendTail()"")"
"The Java Pattern class (java.util.regex.Pattern), is the main access point of the Java regular expression API.","(""Java Pattern class"", ""is part of"", ""Java regular expression API""); (""Java regular expression API"", ""contains"", ""java.util.regex.Pattern""); (""java.util.regex.Pattern"", ""is accessed through"", ""Java Pattern class"")"
"Whenever you need to work with regular expressions in Java, you start with Java's Pattern class.","(""Java"", ""uses"", ""Pattern class""); (""Pattern class"", ""is used for"", ""regular expressions"")"
A regular expression is also sometimes referred to as a pattern (hence the name of the Java Pattern class).,"(""Java"", ""has class"", ""Pattern"")"
You can use the Pattern.matches() method to quickly check if a text (String) matches a given regular expression.,"(""Pattern"", ""hasMethod"", ""matches()""); (""String"", ""isTypeOf"", ""text""); (""Pattern.matches()"", ""takesArgument"", ""regular expression""); (""Pattern.matches()"", ""returns"", ""match result""); (""Pattern"", ""isLocatedIn"", ""java.util.regex""); (""String"", ""isLocatedIn"", ""java.lang"")"
Or you can compile a Pattern instance using Pattern.compile() which can be used multiple times to match the regular expression against multiple texts.,"(""Pattern"", ""compile"", ""Pattern.instance""); (""Pattern.instance"", ""used to match"", ""regular expression""); (""Pattern.compile()"", ""returns"", ""Pattern.instance""); (""regular expression"", ""matched against"", ""texts"")"
The easiest way to check if a regular expression pattern matches a text is to use the static Pattern.matches() method.,"(""Pattern"", ""hasMethod"", ""matches()"")"
"This Pattern.matches() example searches the string referenced by the text variable for an occurrence of the word ""is"", allowing zero or more characters to be present before and after the word (the two .","(""Pattern"", ""matches"", ""text""); (""Pattern"", ""has method"", ""matches()""); (""text"", ""is searched by"", ""Pattern.matches()"")"
"The Pattern.matches() method is fine if you just need to check a pattern against a text a single time, and the default settings of the Pattern class are appropriate.","(""Pattern"", ""hasMethod"", ""matches()""); (""Pattern"", ""isClass"", """"); (""Pattern"", ""hasDefaultSettings"", ""default settings""); (""Pattern.matches()"", ""isIn"", ""Pattern""); (""Pattern"", ""isUsedFor"", ""checking pattern against text"")"
"If you need to match for multiple occurrences, and even access the various matches, or just need non-default settings, you need to compile a Pattern instance using the Pattern.compile() method.","(""Pattern"", ""compile"", ""Pattern.compile()""); (""Pattern"", ""has method"", ""Pattern.compile()"")"
"If you need to match a text against a regular expression pattern more than one time, you need to create a Pattern instance using the Pattern.compile() method.","(""Pattern"", ""compile"", ""Pattern instance""); (""Pattern"", ""has method"", ""compile""); (""Pattern.compile"", ""returns"", ""Pattern instance"")"
You can also use the Pattern.compile() method to compile a Pattern using special flags.,"(""Pattern"", ""compile"", ""Pattern""); (""Pattern"", ""use"", ""Pattern.compile()"")"
The Java Pattern class contains a list of flags (int constants) that you can use to make the Pattern matching behave in certain ways.,"(""Java Pattern class"", ""contains"", ""list of flags""); (""Pattern"", ""has"", ""int constants""); (""Pattern matching"", ""behave in certain ways"", ""flags"")"
"For more information of the flags you can use with the Java Pattern class, see the JavaDoc for Pattern .","(""Java Pattern class"", ""uses"", ""flags""); (""Java Pattern class"", ""has"", ""JavaDoc""); (""JavaDoc"", ""is for"", ""Pattern"")"
The Matcher class has a matches() method that tests whether the pattern matches the text.,"(""Matcher"", ""has"", ""matches()""); (""matches()"", ""tests"", ""pattern""); (""matches()"", ""tests"", ""text""); (""Matcher"", ""has"", ""pattern""); (""Matcher"", ""has"", ""text"")"
"Too keep this text short, the Matcher covered in more detail in the text about the Java Matcher class.","(""Java"", ""has class"", ""Matcher""); (""Matcher"", ""is covered in"", ""text""); (""Java Matcher"", ""is same as"", ""Matcher""); (""Matcher"", ""is part of"", ""Java""); (""Java"", ""has topic"", ""Java Matcher class""); (""Java Matcher class"", ""is about"", ""Matcher"")"
"The split() method in the Pattern class can split a text into an array of String's, using the regular expression (the pattern) as delimiter.","(""Pattern"", ""hasMethod"", ""split()""); (""split()"", ""uses"", ""regular expression""); (""Pattern"", ""belongsTo"", ""java.util.regex""); (""split()"", ""returns"", ""array of String"")"
This Pattern.split() example splits the text in the text variable into 5 separate strings.,"(""Pattern"", ""hasMethod"", ""split()""); (""split()"", ""splits"", ""text""); (""Pattern"", ""splits"", ""text""); (""Pattern.split()"", ""splits"", ""text""); (""Pattern"", ""splitsInto"", ""separate strings""); (""Pattern.split()"", ""splitsInto"", ""separate strings""); (""Pattern.split()"", ""isMethodOf"", ""Pattern""); (""separate strings"", ""areResultOf"", ""Pattern.split()""); (""separate strings"", ""areResultOf"", ""split()""); (""text"", ""isSplitBy"", ""Pattern.split()""); (""text"", ""isSplitBy"", ""split()"")"
Each of these strings are included in the String array returned by the split() method.,"(""String"", ""returned by"", ""split()""); (""String"", ""included in"", ""split()""); (""String"", ""has method"", ""split()""); (""String"", ""contains"", ""split()""); (""String array"", ""returned by"", ""split()""); (""String array"", ""contains"", ""String""); (""split()"", ""returns"", ""String array""); (""split()"", ""method of"", ""String"")"
The pattern() method of the Pattern class simply returns the pattern string (regular expression) that the Pattern instance was compiled from.,"(""Pattern"", ""hasMethod"", ""pattern()""); (""Pattern"", ""wasCompiledFrom"", ""regular expression""); (""Pattern"", ""hasMethod"", ""pattern()""); (""Pattern"", ""returns"", ""pattern string"")"
Character classes are constructst that enable you to specify a match against multiple characters instead of just one.,
"In other words, a character class matches a single character in the input text against multiple allowed characters in the character class.",
Character classes are nested inside a pair of square brackets [].,"(""Character"", ""is nested inside"", ""square brackets"")"
"The character class [Jj] will match either a J or a j, and the rest of the expression will match the characters ohn in that exact sequence.","(""class"", ""has character"", ""J""); (""class"", ""has character"", ""j""); (""expression"", ""matches characters"", ""ohn""); (""expression"", ""has sequence"", ""ohn"")"
The Java regular expression syntax has a few predefined character classes you can use.,"(""Java"", ""has"", ""regular expression syntax""); (""regular expression syntax"", ""contains"", ""character classes"")"
"For instance, the \d character class matches any digit, the \s character class matches any white space character, and the \w character matches any word character.","(""\d"", ""matches"", ""any digit""); (""\s"", ""matches"", ""any white space character""); (""\w"", ""matches"", ""any word character"")"
"The predefined character classes do not have to be enclosed in square brackets, but you can if you want to combine them.","(""Character"", ""have"", ""classes""); (""classes"", ""enclosed in"", ""square brackets""); (""classes"", ""combine with"", ""classes""); (""character classes"", ""enclosed in"", ""square brackets"")"
The predefined character classes are listed in a table later in this text.,
"The Java GZIPInputStream class (java.util.zip.GZIPInputStream) can be used to decompress files that are compressed with the GZIP compression algorithm, for instance via the GZIPOutputStream class.","(""GZIPInputStream"", ""uses"", ""GZIP compression algorithm""); (""GZIPInputStream"", ""related to"", ""GZIPOutputStream""); (""java.util.zip.GZIPInputStream"", ""is a"", ""class""); (""GZIPOutputStream"", ""related to"", ""GZIP compression algorithm""); (""java.util.zip"", ""contains"", ""GZIPInputStream""); (""java.util.zip"", ""contains"", ""GZIPOutputStream"")"
In the example above I passed it a FileInputStream connected to a file named myfile.zip.,"(""FileInputStream"", ""connected to"", ""myfile.zip"")"
When you are finished reading data from the GZIPInputStream you should close it using its close() method.,"(""GZIPInputStream"", ""has method"", ""close()"")"
The Java GZIPOutputStream class (java.util.zip.GZIPOutStream) can be used to GZIP compress data and write it to an OutputStream.,"(""GZIPOutputStream"", ""can be used to"", ""GZIP""); (""GZIPOutputStream"", ""writes to"", ""OutputStream""); (""GZIPOutputStream"", ""is in package"", ""java.util.zip"")"
This Java ZIP tutorial explains how the core classes of the Java ZIP API works.,"(""Java ZIP API"", ""works"", ""core classes""); (""Java ZIP tutorial"", ""explains"", ""Java ZIP API""); (""core classes"", ""part of"", ""Java ZIP API"")"
The Java ZipFile class is used to work with ZIP files containing multiple files.,"(""Java"", ""uses"", ""ZipFile class""); (""ZipFile class"", ""works with"", ""ZIP files""); (""ZIP files"", ""contain"", ""multiple files"")"
The Java GZIPInputStream and GZIPOutputStream classes are used to ZIP compress a single file.,"(""GZIPInputStream"", ""used with"", ""GZIPOutputStream""); (""GZIPInputStream"", ""used for"", ""ZIP compression""); (""GZIPOutputStream"", ""used for"", ""ZIP compression"")"
The above classes will be covered in detail their own tutorials (see the side menu for links).,"(""classes"", ""will be covered in"", ""tutorials""); (""classes"", ""are in"", ""side menu""); (""tutorials"", ""are in"", ""side menu""); (""side menu"", ""contains"", ""links""); (""classes"", ""have"", ""tutorials""); (""tutorials"", ""have"", ""links""); (""side menu"", ""has"", ""classes"")"
The Java ZipFile class (java.util.zip.ZipFile) can be used to read files from a ZIP file.,"(""Java"", ""uses"", ""ZipFile""); (""ZipFile"", ""belongs to"", ""java.util.zip""); (""ZipFile"", ""can be used to"", ""read files from a ZIP file""); (""ZipFile"", ""is in package"", ""java.util.zip"")"
This tutorial will show you how to use the ZipFile class.,"(""ZipFile"", ""used in"", ""tutorial"")"
In order to use the Java ZipFile class you must first create a ZipFile instance.,"(""Java"", ""uses"", ""ZipFile class""); (""ZipFile class"", ""instance created by"", ""user"")"
"As you can see, the ZipFile class takes a single parameter in its constructor.","(""ZipFile"", ""takes parameter in constructor"", ""constructor"")"
Each file in the ZIP file is represented by a ZipEntry (java.util.zip.ZipEntry).,"(""java.util.zip"", ""contains"", ""ZipEntry""); (""ZipEntry"", ""representedBy"", ""java.util.zip""); (""java.util.zip.ZipEntry"", ""isTypeOf"", ""ZipEntry"")"
To extract a file from the ZIP file you can call the method getEntry() method on the ZipFile class.,"(""ZipFile"", ""hasMethod"", ""getEntry()""); (""getEntry()"", ""calledOn"", ""ZipFile"")"
This example gets a ZipEntry representing the file file1.txt which is contained in the ZIP file.,"(""ZipEntry"", ""represents"", ""file1.txt""); (""ZIP file"", ""contains"", ""file1.txt""); (""ZipEntry"", ""retrieved from"", ""ZIP file"")"
The InputStream obtained from the getInputStream() of the ZipFile class can be read like any other Java InputStream.,"(""ZipFile"", ""has method"", ""getInputStream()""); (""getInputStream()"", ""returns"", ""InputStream""); (""InputStream"", ""can be read by"", ""Java"")"
You can list all entries contained in a ZipFile using the entries() method.,"(""ZipFile"", ""contains"", ""entries""); (""ZipFile"", ""has method"", ""entries()"")"
You can iterate the Enumeration returned by the entries() method like this:,"(""Enumeration"", ""returned by"", ""entries()""); (""entries()"", ""has method"", ""Enumeration""); (""Enumeration"", ""iterated by"", ""entries()"")"
The Zip Slip attack consists of adding entries to a ZipFile that contains relative file paths with one or more /.. sections in the path.,"(""ZipFile"", ""contains"", ""entries""); (""entries"", ""have"", ""relative file paths""); (""relative file paths"", ""include"", ""/.. sections"")"
An entry in the ZipFile has the relative path ../../../../etc/hosts .,"(""ZipFile"", ""has"", ""entry""); (""entry"", ""has"", ""relative path""); (""relative path"", ""is"", ""../../../../etc/hosts"")"
The final path of that entry becomes: /apps/myapp/data/unzipped-file/../../../../etc/hosts which is equivalent of /etc/hosts .,
"Unzipping this file could potentially overwrite hour hosts file (on a Linux OS), enabling the attacker to point e.g.",
"The Java examples in this tutorial were created with Java 8, and Acme4J Client v. 2.1 and Acme4J Utils v. 0.3.","(""Acme4J Client"", ""depends on"", ""Java 8""); (""Acme4J Utils"", ""depends on"", ""Java 8""); (""Acme4J Client"", ""used with"", ""Acme4J Utils"")"
Here is a Java class capable of creating a private key for use with Acme4J:,"(""Acme4J"", ""uses"", ""private key""); (""Java class"", ""creates"", ""private key""); (""private key"", ""used with"", ""Acme4J"")"
Here is a class that can create a Let's Encrypt account:,"(""Let's Encrypt account"", ""created by"", ""class""); (""class"", ""can create"", ""Let's Encrypt account"")"
It is the execute() method that starts the account creation process.,"(""execute()"", ""starts"", ""account creation process"")"
The fully qualified name for the Order class is org.shredzone.acme4j.Order .,"(""org.shredzone.acme4j"", ""contains"", ""Order""); (""Order"", ""belongs to"", ""org.shredzone.acme4j"")"
Calling create() results in a request being sent to Let's Encrypt.,"(""create()"", ""results in"", ""request""); (""request"", ""being sent to"", ""Let's Encrypt"")"
Once you have called the order.create() method a request is sent to Let's Encrypt.,"(""order"", ""has method"", ""create()"")"
"The above example specifically looks for an HTTP authorization object, which is then triggered by calling challenge.trigger().","(""challenge"", ""has method"", ""trigger()""); (""challenge"", ""triggers"", ""challenge.trigger()""); (""challenge.trigger()"", ""is method of"", ""challenge"")"
"Before the challenge is triggered, you must read the value from challenge.getAuthorization() and upload it in a file to your web server.","(""challenge"", ""getAuthorization"", ""challenge.getAuthorization()""); (""challenge.getAuthorization()"", ""read"", ""value""); (""value"", ""upload"", ""file""); (""file"", ""upload to"", ""web server""); (""challenge"", ""trigger"", ""challenge"")"
"... where ${domain} is the domain for which you are requesting the domain for (returned by challenge.getDomain() ), and ${token} is the value returned by challenge.getToken().","(""challenge"", ""getDomain"", ""domain""); (""challenge"", ""getToken"", ""token"")"
"If your code cannot access your web server to upload the challenge file before calling challenge.trigger(), you can run the code in your debugger, set a breakpoint before calling challenge.trigger(), pause the code at that breakpoint, read the token (file name) and authorization (file content) out of the challenge object, upload that to your web server, and then continue the code in the debugger.","(""challenge"", ""has method"", ""trigger()""); (""challenge"", ""has property"", ""token""); (""challenge"", ""has property"", ""authorization""); (""code"", ""calls method"", ""challenge.trigger()""); (""debugger"", ""pauses"", ""code""); (""debugger"", ""continues"", ""code""); (""challenge"", ""has method"", ""get token""); (""challenge"", ""has method"", ""get authorization"")"
That is what happens in the last part of the processAuth() method.,"(""processAuth()"", ""is part of"", ""method"")"
"First, the code above waits until the Order object has status Status.VALID.","(""Order"", ""has status"", ""Status.VALID""); (""Order"", ""has status"", ""Status""); (""Status"", ""has value"", ""Status.VALID"")"
The value of that Ant property will be inserted at the place of the ${...} code.,
This example first defines a property named dir.build which has its value set to build.,"(""dir.build"", ""hasValue"", ""build"")"
"Second, this example defines a property named dir.build.classes which has its value set to ${dir.build}/classes .","(""dir.build.classes"", ""has value"", ""${dir.build}/classes""); (""dir.build.classes"", ""is property of"", ""dir.build""); (""dir.build"", ""has property"", ""dir.build.classes"")"
"When Ant defines this property it will resolve the value of the referenced property dir.build, and insert its value where the property is reference.","(""Ant"", ""defines"", ""property""); (""property"", ""references"", ""dir.build""); (""dir.build"", ""has value"", ""value""); (""Ant"", ""resolves"", ""dir.build""); (""Ant"", ""inserts"", ""value"")"
"Thus, the second Ant property defined will have its final value set to build/classes because build is the value of the dir.build property referenced.","(""Ant property"", ""defined in"", ""dir.build""); (""Dir.build"", ""has value"", ""build""); (""Build"", ""contains"", ""classes"")"
"The echo task as defined here will print out the message ""This is version 1.2.3"" to the console.","(""echo task"", ""defined in"", ""console""); (""console"", ""prints"", ""message""); (""message"", ""has version"", ""version 1.2.3"")"
"Just to recap, a ""Java build tool"" is a tool which can compile Java code, run the unit tests for it, package the compiled classes into a JAR file and many, many other things.",
This Ant tutorial is based on Ant version 1.9.6 which is the newest version of Ant at the time of writing (august 2015).,
"Inside the project directory you have just created, create an empty file named build.xml.","(""project directory"", ""has"", ""build.xml""); (""project directory"", ""contains"", ""build.xml""); (""build.xml"", ""is located in"", ""project directory"")"
"By default Ant looks for a build script named build.xml in your project root directory, so you might as well call your Ant build script build.xml.","(""Ant"", ""looks for"", ""build script""); (""build script"", ""named"", ""build.xml""); (""build.xml"", ""located in"", ""project root directory""); (""Ant"", ""uses"", ""build.xml""); (""project root directory"", ""contains"", ""build.xml"")"
"You could use another name, but using build.xml makes your Ant commands shorter, and it makes it easier for other developers to find the Ant build script.",
Open the build.xml file and insert the following text (XML) into it:,"(""build.xml"", ""contains"", ""XML""); (""build.xml"", ""is edited in"", ""XML file""); (""XML"", ""is inserted into"", ""build.xml"")"
You can test this build file by opening a command prompt and change directory into the directory that contains the build.xml file and execute this command:,
"This test was performed using Java 5, Butterfly Container 1.9.11-beta, and Guice 1.0.","(""Java"", ""uses"", ""Butterfly Container""); (""Java"", ""uses"", ""Guice""); (""Butterfly Container"", ""used with"", ""Java""); (""Butterfly Container"", ""used with"", ""Guice""); (""Guice"", ""used with"", ""Java""); (""Guice"", ""used with"", ""Butterfly Container"")"
"The test performs 10.000.000 instantiations of a TestProduct class using a no-arg constructor, for each DI mechanism.","(""TestProduct"", ""uses"", ""no-arg constructor""); (""DI mechanism"", ""instantiates"", ""TestProduct""); (""TestProduct"", ""is instantiated by"", ""DI mechanism"")"
Java is a statically typed language meaning that types (primtives and classes) cannot change at runtime.,"(""Java"", ""has"", ""primitives""); (""Java"", ""has"", ""classes"")"
"It is not like you can all of a sudden let your Java class members, method parameters and variables be untyped.","(""Java class"", ""has"", ""members""); (""Java class"", ""has"", ""method parameters""); (""Java class"", ""has"", ""variables""); (""members"", ""are part of"", ""Java class""); (""method parameters"", ""are part of"", ""Java class""); (""variables"", ""are part of"", ""Java class"")"
"This is done at the beginning, by the method call BO.setDao(dao).","(""BO"", ""setDao"", ""dao"")"
"But, notice how no DI is used inside the BO.checkPersonIsValid() or the DAO.readPerson() methods.","(""BO"", ""hasMethod"", ""checkPersonIsValid()""); (""DAO"", ""hasMethod"", ""readPerson()"")"
I most likely never have to change implementation of the Person class.,"(""Person"", ""implementation of"", ""Person class"")"
In Java this will result in a class cast exception at runtime (or some similar type error exception).,"(""Java"", ""hasException"", ""ClassCastException""); (""ClassCastException"", ""isThrownAt"", ""Runtime""); (""Runtime"", ""hasError"", ""TypeError""); (""TypeError"", ""isSimilarTo"", ""ClassCastException""); (""Java"", ""hasError"", ""ClassCastException"")"
"Each factory definition states how a given instance is to be created and configured, when calling the container.instance() method.","(""container"", ""has method"", ""instance()""); (""container"", ""calls method"", ""instance()""); (""factory definition"", ""states"", ""instance creation""); (""instance"", ""is created by"", ""container.instance()""); (""factory definition"", ""configures"", ""instance"")"
"The input parameters .hashcode() and .equals() methods determine if an input parameter has an instance associated with it already, or a new one needs to be created and associated with the input parameter for succeeding calls.","(""Input parameter"", ""has method"", "".hashcode()""); (""Input parameter"", ""has method"", "".equals()""); (""Input parameter"", ""determines"", ""instance association""); ("".hashcode()"", ""determines"", ""instance creation""); ("".equals()"", ""determines"", ""instance creation""); (""Input parameter"", ""associated with"", ""instance"")"
As you can see the constructor call was chained with a call to the setValue() method.,"(""constructor"", ""chained with"", ""setValue()""); (""constructor"", ""calls"", ""setValue()""); (""constructor"", ""related to"", ""setValue()"")"
"Notice how the length() method is called on the ""value"" parameter.","(""value"", ""has method"", ""length()"")"
"If the setValue() method in the example above returns void, the factory will return the SomeObject instance the method was called on.","(""factory"", ""returns"", ""SomeObject""); (""SomeObject"", ""hasMethod"", ""setValue()""); (""setValue()"", ""returns"", ""void"")"
The factory defined by this script will return a SomeObject instance that has had the two methods setValue() and setValue2() invoked on it.,"(""SomeObject"", ""hasMethod"", ""setValue()""); (""SomeObject"", ""hasMethod"", ""setValue2()""); (""SomeObject"", ""returnedBy"", ""factory"")"
"Here is a list of classes and primitives that parameters can be converted to, automatically:","(""parameters"", ""can be converted to"", ""classes""); (""parameters"", ""can be converted to"", ""primitives"")"
Sometimes a constructor or method call in a factory definition matches more than one constructor or method in the owning class.,"(""class"", ""has"", ""constructor""); (""class"", ""has"", ""method""); (""constructor"", ""isCalledBy"", ""factory definition""); (""method"", ""isCalledBy"", ""factory definition""); (""factory definition"", ""matches"", ""constructor""); (""factory definition"", ""matches"", ""method""); (""class"", ""owns"", ""constructor""); (""class"", ""owns"", ""method"")"
You can cast to any type or class available on the classpath.,"(""classpath"", ""available on"", ""type""); (""classpath"", ""available on"", ""class"")"
"To call a static method instead of a constructor when creating an instance of some class, simply write as you would in Java:","(""Java"", ""uses"", ""static method""); (""static method"", ""called instead of"", ""constructor""); (""constructor"", ""used for"", ""creating instance""); (""instance"", ""created by"", ""Java""); (""Java"", ""creates"", ""instance"")"
Note: The container uses java.util.ArrayList and java.util.HashSet as the List and Set implementations.,"(""container"", ""uses"", ""java.util.ArrayList""); (""container"", ""uses"", ""java.util.HashSet""); (""java.util.ArrayList"", ""isImplementationOf"", ""List""); (""java.util.HashSet"", ""isImplementationOf"", ""Set"")"
From version 2.5.9 Butterfly Container Script provides a shortcut to configuring Map instances.,
First an instance of SomeObject is created and then the setValue() method is called on it.,"(""SomeObject"", ""hasMethod"", ""setValue()""); (""SomeObject"", ""createsInstance"", ""SomeObject.instance""); (""SomeObject.instance"", ""callsMethod"", ""setValue()"")"
Below is an example that register the newly created instance with a static method in the MyClass class.,"(""MyClass"", ""hasMethod"", ""register""); (""register"", ""isIn"", ""MyClass""); (""MyClass"", ""creates"", ""instance"")"
You can inject instances of classes created locally in a factory definition.,"(""classes"", ""created in"", ""factory definition""); (""instances"", ""injected"", ""factory definition""); (""factory definition"", ""creates"", ""classes"")"
"Notice how the setNewValue() method is called on the instance obtained from the bean1 factory, before it is injected into OtherObject's constructor.","(""setNewValue()"", ""called on"", ""bean1""); (""bean1"", ""instance obtained from"", ""factory""); (""bean1"", ""injected into"", ""OtherObject.constructor"")"
"Thus, the setFurtherValue() method of the someObject singleton is called for each instance of bean2 created, even if the method call is redundant.","(""someObject"", ""hasMethod"", ""setFurtherValue()""); (""bean2"", ""hasInstance"", ""someObject""); (""someObject.setFurtherValue()"", ""isCalledFor"", ""bean2"")"
"Notice how the bean2 definition obtains an instance from the bean1 factory, and calls the setValue() method on it before returning it.","(""bean2"", ""obtains instance from"", ""bean1 factory""); (""bean1 factory"", ""returns instance to"", ""bean2""); (""bean2"", ""calls method"", ""setValue()""); (""bean1 factory"", ""creates instance of"", ""bean1""); (""bean2"", ""sets value using"", ""setValue()"")"
"Input parameters can be given to the container.instance() method, like this:","(""container"", ""hasMethod"", ""instance()"")"
"The container cannot determine the type of input parameters until runtime, when the container.instance() method is called.","(""container"", ""has method"", ""container.instance()"")"
Therefore it is only possible to call methods that exists in java.lang.Object on input parameters.,"(""java.lang.Object"", ""contains"", ""methods""); (""java.lang.Object"", ""has"", ""input parameters""); (""methods"", ""exist in"", ""java.lang.Object""); (""input parameters"", ""have"", ""java.lang.Object methods"")"
"Your application will ask the container for an object, and the container will make sure that all dependencies (config parameters, collaborating objects, texts etc.)","(""application"", ""will ask"", ""container""); (""container"", ""will make sure"", ""dependencies""); (""container"", ""will provide"", ""object""); (""dependencies"", ""include"", ""config parameters""); (""dependencies"", ""include"", ""collaborating objects""); (""dependencies"", ""include"", ""texts"")"
"Rather than having to design integration mechanisms yourself, and decide on configuration formats etc., you can have the dependency injection container do all that for you.",
"The ""connectionTimeout"" factory is defined as a singleton returning whatever value the CONNECTION_TIMEOUT constant is set to in the Constants class.","(""connectionTimeout"", ""is defined in"", ""Constants class""); (""Constants class"", ""has constant"", ""CONNECTION_TIMEOUT""); (""connectionTimeout"", ""returns value of"", ""CONNECTION_TIMEOUT"")"
The simplest way to add a function is to create a static method in a Java class that performs the logic for the function.,"(""Java class"", ""contains"", ""static method""); (""static method"", ""performs"", ""logic""); (""Java class"", ""has"", ""logic"")"
Sometimes you may need to create an instance of some class and call a method on that instance.,"(""Class"", ""hasinstance"", ""Instance""); (""Instance"", ""hasmethod"", ""Method""); (""Class"", ""createmethod"", ""Instance""); (""Instance"", ""callmethod"", ""Method"")"
The beanB factory will call the beanA factory with the parameter returned from the static default() method.,"(""beanB factory"", ""will call"", ""beanA factory""); (""beanA factory"", ""has method"", ""default()""); (""default() method"", ""returns"", ""parameter""); (""beanB factory"", ""uses"", ""parameter"")"
"If input parameter 0 passed to the beanB factory is null, then the default() method will return the default value ""default value"".","(""beanB"", ""has method"", ""default()""); (""default()"", ""returns"", ""default value"")"
"If you need to call the default() method more than once you can simplify the script a bit by mapping the default method to a factory, and then call this factory whenever the function is needed.",
"The default() method has been mapped to a factory called ""default"".","(""default"", ""has been mapped to"", ""factory""); (""default method"", ""is called"", ""default""); (""default"", ""is a"", ""factory""); (""default method"", ""is a"", ""default""); (""factory"", ""is named"", ""default""); (""default method"", ""is named"", ""default""); (""default"", ""is mapped to"", ""default factory"")"
This default factory is then called from the beanB factory instead of calling the static default() method directly.,"(""beanB factory"", ""calls"", ""default factory""); (""beanB factory"", ""instead of calling"", ""default() method""); (""default factory"", ""is called from"", ""beanB factory""); (""default() method"", ""is called directly by"", ""none""); (""beanB factory"", ""calls indirectly"", ""default() method"")"
"There is no package and class name to disturb you when reading the script, and whenever you need the default function all you need to write is ""default(a, b)"", instead of ""com.myapp.util.Util.default(a, b)"".","(""Util"", ""hasMethod"", ""default()""); (""com.myapp.util"", ""containsClass"", ""Util""); (""com.myapp.util.Util"", ""hasMethod"", ""default()"")"
Defining the static max() method as a factory (and thereby a function) is done like this:,"(""static max() method"", ""is defined as"", ""factory""); (""factory"", ""is also known as"", ""function""); (""max() method"", ""is type of"", ""method"")"
"This little script defines the ""max"" factory as a call to the static max() method with input parameter 0 and 1 passed to the max() method.","(""max"", ""defines"", ""max factory""); (""max factory"", ""calls"", ""max() method""); (""max() method"", ""takes"", ""input parameter 0""); (""max() method"", ""takes"", ""input parameter 1"")"
"The max factory will call the max() method and return the value that is largest of either the input parameter 0 passed to the beanA factory, or the hard coded value 1.","(""beanA factory"", ""has method"", ""max()""); (""beanA factory"", ""calls method"", ""max()""); (""max()"", ""returns"", ""value""); (""beanA factory"", ""passes parameter"", ""0""); (""max()"", ""compares with"", ""1"")"
"This example uses the java.text.SimpleDateFormat class and defines its instance method parse() as a function called ""toDate"".",
Second the toDate factory is defined as a call to the toDateFactory and then a call to the parse() method on the instance returned from the toDateFactory.,"(""toDateFactory"", ""defined as"", ""call to parse()""); (""toDateFactory"", ""returns"", ""instance""); (""instance"", ""has method"", ""parse()"")"
The toDate factory takes a single parameter which is the string to parse into a java.util.Date instance.,"(""toDate"", ""takes parameter"", ""string""); (""toDate"", ""parses into"", ""java.util.Date"")"
"It is possible to extend Butterfly Container Script (BCS) with custom instantiation modes, if the standard modes (new instance, singleton etc.)",
"By calling the set() method with the current request as parameter, the request is associated with the thread calling the set() method.","(""set() method"", ""called with"", ""current request""); (""set() method"", ""associates"", ""request""); (""set() method"", ""called by"", ""thread""); (""thread"", ""calls"", ""set() method""); (""request"", ""associated with"", ""thread"")"
By calling the get() method the request object associated with the calling thread can be obtained.,"(""Thread"", ""has"", ""Request""); (""Request"", ""has method"", ""get()""); (""Thread"", ""calls"", ""get()"")"
"The ""request"" factory is defined as a call to the get() method on the product returned from the ""requestCache"" factory.","(""request factory"", ""is defined as"", ""get() method""); (""get() method"", ""is called on"", ""product""); (""product"", ""is returned from"", ""requestCache factory""); (""requestCache factory"", ""returns"", ""product"")"
"In other words, as a call to the get() method on the HttpRequestCache singleton.","(""HttpRequestCache"", ""has method"", ""get()"")"
"The ""session"" factory is defined as a call to the getSession() method of the product returned by the ""request"" factory.","(""session factory"", ""is defined as"", ""getSession() method""); (""getSession() method"", ""of"", ""product""); (""product"", ""returned by"", ""request factory"")"
"In other words, as a call to the getSession() method on the request object obtained from the HttpRequestCache singleton, which is the request object associated with the calling thread.","(""HttpRequestCache"", ""hasMethod"", ""getSession()""); (""HttpRequestCache"", ""returns"", ""request""); (""request"", ""hasMethod"", ""getSession()""); (""calling thread"", ""associatedWith"", ""request"")"
In order to make the the request and session factories return the correct objects you must first call the HttpRequestCache's set() method.,"(""HttpRequestCache"", ""hasMethod"", ""set()""); (""HttpRequestCache"", ""returns"", ""objects""); (""request"", ""createdWith"", ""HttpRequestCache""); (""session"", ""createdWith"", ""HttpRequestCache""); (""HttpRequestCache"", ""sets"", ""factories"")"
"Another disadvantage is that all instantiation modes (singleton, thread singleton, flyweight etc.)","(""singleton"", ""is_a"", ""instantiation mode""); (""thread singleton"", ""is_a"", ""instantiation mode""); (""flyweight"", ""is_a"", ""instantiation mode"")"
"If you use an anonymous subclass of JavaFactory, inserted instead of ""new MyFactory()"", the JavaFactoryBuilder cannot access the ""otherFactory"" field, even if it is public.","(""JavaFactory"", ""has field"", ""otherFactory""); (""JavaFactoryBuilder"", ""accesses"", ""otherFactory""); (""JavaFactory"", ""has subclass"", ""anonymous subclass""); (""JavaFactoryBuilder"", ""cannot access"", ""otherFactory""); (""MyFactory"", ""is subclass of"", ""JavaFactory"")"
"Inner classes will do just fine too, as long as they are declared ""public static"".","(""Inner classes"", ""are declared as"", ""public static"")"
"This method takes 3 parameters: The name of the factory, the return type of the factory, and a subclass of JavaFactory which implements the factory.","(""JavaFactory"", ""implements"", ""factory""); (""factory"", ""has return type"", ""return type""); (""factory"", ""has parameter"", ""name of the factory""); (""JavaFactory"", ""is subclass of"", ""factory""); (""factory"", ""takes parameter"", ""subclass of JavaFactory"")"
"The name is used when calling the container.instance(""name"") method to obtain an instance from the factory.","(""container"", ""instance"", ""factory""); (""container"", ""has method"", ""instance""); (""instance"", ""obtained from"", ""factory""); (""container.instance"", ""called with"", ""name""); (""container"", ""has method"", ""container.instance""); (""factory"", ""provides"", ""instance""); (""name"", ""used in"", ""container.instance"")"
JavaFactoryBuilder has a method that omits the return type and instead extracts that information from the return type of the JavaFactory subclass's instance method.,"(""JavaFactoryBuilder"", ""has method"", ""omit return type method""); (""JavaFactory subclass"", ""has method"", ""instance method""); (""omit return type method"", ""extracts information from"", ""instance method""); (""instance method"", ""has return type"", ""return type""); (""JavaFactoryBuilder"", ""uses"", ""JavaFactory subclass"")"
Notice how no return type is passed in the addFactory() call.,"(""addFactory"", ""call"", ""no return type"")"
Also notice how the return type of the instance() method is now MyObject.,"(""MyObject"", ""returned by"", ""instance()""); (""instance()"", ""returns"", ""MyObject"")"
By declaring a field of type IGlobalFactory in the JavaFactory subclass the JavaFactoryBuilder knows that the factory depends on another factory.,"(""JavaFactory"", ""depends on"", ""IGlobalFactory""); (""JavaFactoryBuilder"", ""knows"", ""JavaFactory""); (""JavaFactory"", ""has"", ""IGlobalFactory""); (""JavaFactory"", ""subclass of"", ""JavaFactory""); (""JavaFactoryBuilder"", ""knows"", ""IGlobalFactory""); (""IGlobalFactory"", ""is type of"", ""field""); (""JavaFactory"", ""declares"", ""field""); (""JavaFactory"", ""has"", ""JavaFactoryBuilder"")"
"You can add as many factories as you want, using the addFactory() method.","(""addFactory()"", ""is method of"", ""unknown class""); (""unknown class"", ""has method"", ""addFactory()"")"
The ScriptFactoryBuilder has a addFactories() method that takes an InputStream as parameter instead of a String.,"(""ScriptFactoryBuilder"", ""has method"", ""addFactories()""); (""addFactories()"", ""takes parameter"", ""InputStream""); (""addFactories()"", ""takes parameter"", ""String"")"
"Using this method you can load a container script from disk, over a network, from the classpath and also from inside a Jar file.","(""Container"", ""loaded from"", ""Disk""); (""Container"", ""loaded from"", ""Network""); (""Container"", ""loaded from"", ""Classpath""); (""Container"", ""loaded from"", ""Jar file"")"
"To configure the container using a script contained in a file located on the classpath (including inside a Jar file), you can do like this:",
"The init() method creates all singletons, starts services and other stuff that need to be done before the instances in the container can be used.","(""init()"", ""creates"", ""singletons""); (""init()"", ""starts"", ""services"")"
The instance() method needs the name of the object factory to get an instance from.,"(""instance() method"", ""needs"", ""object factory""); (""object factory"", ""get instance from"", ""instance()"")"
You can put as many input parameters into the instance() call as you like.,
The input parameters are defined as an optional parameter (Object ... parameters).,"(""Object"", ""is parameter type of"", ""parameters""); (""parameters"", ""is defined as"", ""optional parameter"")"
"When the dispose() method is called, the dispose life cycle phase is executed for all factories in the container, before the method call returns.","(""dispose() method"", ""is called by"", ""container""); (""container"", ""executes life cycle phase"", ""dispose life cycle phase""); (""dispose life cycle phase"", ""is executed for"", ""factories""); (""container"", ""contains"", ""factories""); (""dispose() method"", ""returns after executing"", ""dispose life cycle phase"")"
A thread calling get() will only get the object it had set itself by calling set().,"(""thread"", ""calls"", ""get()""); (""thread"", ""calls"", ""set()""); (""get()"", ""returns"", ""object""); (""set()"", ""sets"", ""object""); (""thread"", ""had set"", ""object"")"
"Then the value obtained from the container.instance(""myThreadLocal"") call will be the value the calling thread associated with itself, by calling MyClass.threadLocal.set().","(""container"", ""instance"", ""myThreadLocal""); (""MyClass"", ""threadLocal"", ""set""); (""MyClass.threadLocal"", ""set"", ""calling thread""); (""container.instance"", ""call"", ""myThreadLocal""); (""calling thread"", ""associated with"", ""myThreadLocal""); (""MyClass"", ""has"", ""threadLocal""); (""calling thread"", ""calls"", ""MyClass.threadLocal.set"")"
ThreadLocal's can be used to associate a java.util.Locale with the calling thread.,"(""ThreadLocal"", ""can be used with"", ""java.util.Locale""); (""ThreadLocal"", ""is associated with"", ""calling thread"")"
"Basically what you will do is call a ThreadLocal.set() method with the Locale to associate with the calling thread, before calling container.instance().","(""ThreadLocal"", ""has method"", ""set()""); (""ThreadLocal.set()"", ""called with"", ""Locale""); (""container"", ""has method"", ""instance()"")"
"Notice how the Locale is not obtained by the ThreadLocal.get() method, but via the static method getLocale().","(""ThreadLocal"", ""get"", ""Locale""); (""Locale"", ""obtained by"", ""getLocale()""); (""getLocale()"", ""method of"", ""ThreadLocal"")"
"The getLocale() method functions as a cast from Object to its return value Locale, enabling the container to determine the type of the returned object (Locale).","(""getLocale()"", ""returns"", ""Locale""); (""getLocale()"", ""is method of"", ""Object""); (""Locale"", ""is type of"", ""returned object""); (""getLocale()"", ""enables"", ""container""); (""container"", ""determines"", ""type of returned object""); (""returned object"", ""is of type"", ""Locale"")"
"Notice how the HttpServletRequest and HttpServletResponse are not obtained by the ThreadLocal.get() method, but via the static methods getRequest() and getResponse().","(""HttpServletRequest"", ""obtained by"", ""getRequest()""); (""HttpServletResponse"", ""obtained by"", ""getResponse()""); (""ThreadLocal"", ""has method"", ""get()""); (""getRequest()"", ""returns"", ""HttpServletRequest""); (""getResponse()"", ""returns"", ""HttpServletResponse"")"
"The getRequest() method functions as a cast from Object to its return value HttpServletRequest, enabling the container to determine the type of the returned object (HttpServletRequest).","(""getRequest()"", ""returns"", ""HttpServletRequest""); (""HttpServletRequest"", ""returned by"", ""getRequest()""); (""getRequest()"", ""cast from"", ""Object"")"
"Instantiation time localization means that you inject localized dependencies (texts, paths, number and date formatters etc.)","(""Dependencies"", ""injected into"", ""Instantiation""); (""Localized dependencies"", ""include"", ""texts""); (""Localized dependencies"", ""include"", ""paths""); (""Localized dependencies"", ""include"", ""number formatters""); (""Localized dependencies"", ""include"", ""date formatters"")"
"As you can imagine, the more resources the MyComponent needs, the larger both the class and the configuration grows.","(""MyComponent"", ""needs"", ""resources""); (""MyComponent"", ""has"", ""class""); (""MyComponent"", ""has"", ""configuration"")"
"As you can imagine, only the execute() method will grow as the number of localized dependencies grow.","(""execute()"", ""is a method of"", ""unknown class"")"
"Assuming that the MyService class implements an interface called IService, you can create a mock implementation of the IService interface using this code:","(""MyService"", ""implements"", ""IService""); (""IService"", ""is implemented by"", ""MyService""); (""MyService"", ""has mock implementation of"", ""IService"")"
This mockService factory returns a dynamic implementation of the IService interface based on Java's java.lang.reflect.Proxy class.,"(""mockService"", ""returns"", ""IService""); (""mockService"", ""uses"", ""java.lang.reflect.Proxy""); (""IService"", ""implemented by"", ""mockService""); (""java.lang.reflect.Proxy"", ""used by"", ""mockService"")"
"The serviceMock instance passed to the getMock() method should be the mock object obtained from the mockService factory, using the container.instance(""mockService"") method call.","(""serviceMock"", ""passed to"", ""getMock()""); (""container"", ""has method"", ""instance()""); (""instance()"", ""called with"", ""mockService""); (""instance()"", ""returns"", ""mock object""); (""mockService"", ""obtained from"", ""mockService factory""); (""container"", ""has method"", ""instance()""); (""getMock()"", ""takes"", ""serviceMock"")"
"In other words, the instance returned from the MockFactory.createProxy() method call.","(""MockFactory"", ""createProxy"", ""instance""); (""MockFactory"", ""createProxy"", ""MockFactory.createProxy()""); (""MockFactory.createProxy"", ""returns"", ""instance"")"
This way it is possible to detect if close() is called on the database connection after some method call that uses the connection has completed.,"(""close()"", ""is called on"", ""database connection""); (""database connection"", ""is used by"", ""some method call""); (""some method call"", ""has completed"", ""close()"")"
"A suggestion would be to have a PersonDao.getConnection() method, even though you'd probably mostly use it during testing.","(""PersonDao"", ""hasMethod"", ""getConnection()""); (""PersonDao"", ""usedIn"", ""testing""); (""getConnection()"", ""calledBy"", ""testing"")"
From version 2.1.9 it is possible to replace factories at runtime.,
"It is also possible to replace several script factories at a time, by using the ScriptFactoryBuilder.replaceFactories(InputStream) method.","(""ScriptFactoryBuilder"", ""hasMethod"", ""replaceFactories(InputStream)""); (""replaceFactories(InputStream)"", ""isMethodOf"", ""ScriptFactoryBuilder""); (""ScriptFactoryBuilder"", ""usesParameter"", ""InputStream""); (""replaceFactories(InputStream)"", ""takesParameter"", ""InputStream"")"
Rather than configuring the PersonDao by hand with dependencies (and their dependencies recursively) you just reuse the configuration of the PersonDao from the application container configuration (the file containerConfig.bcs).,"(""PersonDao"", ""depends on"", ""dependencies""); (""PersonDao"", ""configured by"", ""container configuration""); (""container configuration"", ""defined in"", ""containerConfig.bcs""); (""PersonDao"", ""configured in"", ""application container configuration""); (""dependencies"", ""depend on"", ""recursive dependencies"")"
"When designing Butterfly we considered using an XML format for configuration like several alternative DI containers do (Spring, Nano etc.).",
In this example a java.util.ArrayList() instance is created inside the call to setSomeList().,"(""ArrayList"", ""is created in"", ""setSomeList()""); (""setSomeList()"", ""takes an instance of"", ""ArrayList""); (""ArrayList"", ""is an instance of"", ""java.util.ArrayList""); (""java.util.ArrayList"", ""is used by"", ""setSomeList()"")"
As you can see the List.add() method is called twice to add the string and myDataSource factory product to the list.,"(""List"", ""hasMethod"", ""add()""); (""List"", ""callsMethod"", ""add()""); (""add()"", ""belongsTo"", ""List""); (""List"", ""contains"", ""string""); (""List"", ""contains"", ""myDataSource""); (""myDataSource"", ""isProducedBy"", ""factory"")"
The fact One of the advantages you get when designing your own language is the freedom to e.g make methods that return void chainable.,"(""Method"", ""return"", ""void""); (""Method"", ""have relationship"", ""chainable methods""); (""Language design"", ""have"", ""methods""); (""Methods"", ""return"", ""void""); (""Methods"", ""be"", ""chainable"")"
"The [] around the values in the setSomeList() call signals that the values are to be put inside a List or array, depending on the setSomeList() parameter type.","(""setSomeList()"", ""parameter type"", ""List""); (""setSomeList()"", ""parameter type"", ""array"")"
It is possible to map classes to tables and columns using annotations.,"(""annotations"", ""map to"", ""tables""); (""annotations"", ""map to"", ""columns""); (""classes"", ""map to"", ""tables""); (""classes"", ""map to"", ""columns"")"
You cannot have more than one mapping for the same class using annotation based mapping alone.,"(""annotation"", ""used for"", ""mapping""); (""annotation"", ""based on"", ""class""); (""class"", ""has"", ""mapping""); (""mapping"", ""limited to"", ""one""); (""class"", ""uses"", ""annotation"")"
Each annotation is only allowed once in the code for a given class by the Java compiler.,"(""Java compiler"", ""enforces"", ""annotation""); (""annotation"", ""is allowed"", ""class""); (""Java compiler"", ""checks"", ""code"")"
There are two types of annotations available: A class annotation Annotations for getters and setters.,"(""Annotations"", ""is type of"", ""class annotation""); (""Annotations"", ""is used for"", ""getters""); (""Annotations"", ""is used for"", ""setters"")"
AClassMapping The class annotation (AClassMapping) is used ontop of your class name for your POJO classes.,"(""AClassMapping"", ""is used on"", ""POJO classes""); (""AClassMapping"", ""is used with"", ""class annotation""); (""POJO classes"", ""have"", ""class annotation""); (""AClassMapping"", ""is a"", ""class annotation"")"
"If you set the mappingMode to ""modify"" then Butterfly Persistence will first use automatic mapping to guess as much as it can, and then look at the annotations and modify the class mapping accordingly.",
"The tableName element can be set to the name of the table the class is to be mapped to, if it cannot be guessed by the automatic mapping mechanism.","(""tableName"", ""can be set to"", ""class""); (""class"", ""is to be mapped to"", ""table""); (""automatic mapping mechanism"", ""cannot guess"", ""tableName""); (""table"", ""is guessed by"", ""automatic mapping mechanism""); (""class"", ""uses"", ""automatic mapping mechanism"")"
"If you have a database generated (e.g auto-incremented) primary key that is mapped to a getter method, you will have to mark the getter method as database generated, to avoid having Butterly Persistence try to set that value in the database.","(""Butterly Persistence"", ""uses"", ""database""); (""database"", ""has"", ""primary key""); (""primary key"", ""mapped to"", ""getter method""); (""getter method"", ""marked as"", ""database generated"")"
The class annotation (AClassMapping) is used ontop of your class name for your POJO classes.,"(""AClassMapping"", ""is used on"", ""class name""); (""AClassMapping"", ""is used for"", ""POJO classes""); (""class name"", ""has annotation"", ""AClassMapping""); (""POJO classes"", ""have annotation"", ""AClassMapping"")"
"Notice how the second class definition uses manual mapping, so the getter and setter must be fully mapped to columns in the database.","(""class definition"", ""uses"", ""manual mapping""); (""getter"", ""must be fully mapped to"", ""columns""); (""setter"", ""must be fully mapped to"", ""columns""); (""class definition"", ""has"", ""getter""); (""class definition"", ""has"", ""setter""); (""manual mapping"", ""maps to"", ""columns""); (""getter"", ""maps to"", ""columns""); (""setter"", ""maps to"", ""columns"")"
The ASetterMapping annotation is used to map setters of classes to columns in database tables or SQL queries.,"(""ASetterMapping"", ""is used to map"", ""setters""); (""setters"", ""are part of"", ""classes""); (""classes"", ""have"", ""columns""); (""columns"", ""are in"", ""database tables""); (""columns"", ""are in"", ""SQL queries""); (""ASetterMapping"", ""maps"", ""database tables""); (""ASetterMapping"", ""maps"", ""SQL queries"")"
In this example the Employee.class object is the object mapping key.,"(""Employee"", ""is key for"", ""object mapping"")"
"However, if you want Butterfly Persistence to be able to auto-map the target class to the database, the object mapping key should be either a Class object, or an IObjectMappingKey instance.",
"The IObjectMappingKey instance can contain more information about the class to be mapped, than a Class object can.","(""IObjectMappingKey"", ""contains"", ""information""); (""IObjectMappingKey"", ""can contain more information than"", ""Class""); (""Class"", ""can be mapped by"", ""IObjectMappingKey""); (""IObjectMappingKey"", ""has more information about"", ""Class"")"
"An IObjectMappingKey instance has a getObjectClass() method that returns the Class object of the class to map, so automatic mapping is possible in either case.","(""IObjectMappingKey"", ""has method"", ""getObjectClass()""); (""getObjectClass()"", ""returns"", ""Class"")"
When checking for tables with similar names to the class to map only the class name itself is used.,
The ObjectMapper generates various textual combinations based on the class name and checks the database meta data to see if any of these match.,"(""ObjectMapper"", ""generates"", ""textual combinations""); (""ObjectMapper"", ""checks"", ""database meta data""); (""database meta data"", ""contains"", ""class name"")"
"The ObjectMapper mapper breaks the class name into words, based on the uppercase letters and numbers in the class name.","(""ObjectMapper"", ""breaks"", ""class name""); (""ObjectMapper"", ""breaks based on"", ""uppercase letters""); (""ObjectMapper"", ""breaks based on"", ""numbers""); (""class name"", ""contains"", ""uppercase letters""); (""class name"", ""contains"", ""numbers"")"
Based on these combinations the PersistentObject class name would be similar to the table names PersistentObject persistentObject persistentobject PERSISTENTOBJECT Persistent_Object persistent_object PERSISTENT_OBJECT PersistentObjects persistentObjects persistentobjects PERSISTENTOBJECTS PERSISTENTOBJECTs Persistent_Objects persistent_objects PERSISTENT_OBJECTS PERSISTENT_OBJECTs As you can see there is a reasonable chance that the table name will be guessed if it is similar to the class name.,"(""PersistentObject"", ""IS_SIMILAR_TO"", ""table name""); (""PersistentObject"", ""HAS_NAME"", ""persistentObject""); (""PersistentObject"", ""HAS_NAME"", ""persistentobject""); (""PersistentObject"", ""HAS_NAME"", ""PERSISTENTOBJECT""); (""PersistentObject"", ""HAS_NAME"", ""Persistent_Object""); (""PersistentObject"", ""HAS_NAME"", ""persistent_object""); (""PersistentObject"", ""HAS_NAME"", ""PERSISTENT_OBJECT""); (""PersistentObject"", ""HAS_NAME"", ""PersistentObjects""); (""PersistentObject"", ""HAS_NAME"", ""persistentObjects""); (""PersistentObject"", ""HAS_NAME"", ""persistentobjects""); (""PersistentObject"", ""HAS_NAME"", ""PERSISTENTOBJECTS""); (""PersistentObject"", ""HAS_NAME"", ""PERSISTENTOBJECTs""); (""PersistentObject"", ""HAS_NAME"", ""Persistent_Objects""); (""PersistentObject"", ""HAS_NAME"", ""persistent_objects""); (""PersistentObject"", ""HAS_NAME"", ""PERSISTENT_OBJECTS""); (""PersistentObject"", ""HAS_NAME"", ""PERSISTENT_OBJECTs"")"
"The Object Mapper uses reflection to iterate the methods of the class to be mapped, and filters out all other methods than getters and setters.","(""Object Mapper"", ""uses"", ""reflection""); (""reflection"", ""iterates"", ""methods""); (""methods"", ""belong to"", ""class""); (""class"", ""has"", ""getters""); (""class"", ""has"", ""setters""); (""Object Mapper"", ""filters out"", ""methods""); (""Object Mapper"", ""maps"", ""class"")"
If your custom mapper implementation returns an object mapping from the getObjectMapping() method then automatic and annotation based mapping are not applied.,"(""OBJECT"", ""returns"", ""mapping""); (""custom mapper implementation"", ""has method"", ""getObjectMapping()""); (""getObjectMapping() method"", ""returns"", ""object mapping""); (""automatic mapping"", ""is not applied"", ""when getObjectMapping() returns object""); (""annotation based mapping"", ""is not applied"", ""when getObjectMapping() returns object"")"
"If a table name is returned from the getTableName() method, then Butterfly Persistence will not try to guess a table name, nor look at the class annotation for table name.","(""Butterfly Persistence"", ""uses"", ""getTableName()""); (""getTableName()"", ""returns"", ""table name""); (""Butterfly Persistence"", ""checks"", ""class annotation""); (""Class annotation"", ""contains"", ""table name"")"
If null is returned Butterfly Persistence will look at the class annotation to see if a table name is set there.,"(""Butterfly Persistence"", ""will look at"", ""class annotation""); (""class annotation"", ""has"", ""table name""); (""Butterfly Persistence"", ""looks for"", ""table name"")"
If the getObjectMapping() method returned null Butterfly Persistence will call the modify() method to allow your custom object mapper to modify the automatically generated mapping.,"(""Butterfly Persistence"", ""calls"", ""modify()""); (""modify()"", ""allows"", ""custom object mapper""); (""custom object mapper"", ""modifies"", ""automatically generated mapping""); (""getObjectMapping()"", ""returns"", ""null""); (""Butterfly Persistence"", ""calls"", ""modify()""); (""Butterfly Persistence"", ""uses"", ""custom object mapper""); (""custom object mapper"", ""implements"", ""modify()"")"
Before doing so Butterfly Persistence will have applied the annotations in the class to the mapping.,
"If you want Butterfly Persistence to manage the opening of connections, pass a javax.sql.DataSource implementation into the constructor of the PersistenceManager.","(""PersistenceManager"", ""has constructor"", ""javax.sql.DataSource""); (""PersistenceManager"", ""manages"", ""connections""); (""Butterfly Persistence"", ""manages"", ""connections""); (""javax.sql.DataSource"", ""implements"", ""javax.sql.DataSource""); (""PersistenceManager"", ""uses"", ""javax.sql.DataSource"")"
The readLong() method comes in another version too which takes an optional list of parameters.,"(""readLong()"", ""comes in version of"", ""readLong() method with parameters""); (""readLong() method with parameters"", ""takes"", ""list of parameters"")"
They will be inserted in the sequence they are passed to the readLong() method.,"(""readLong()"", ""is called by"", ""They""); (""readLong()"", ""is a method of"", ""unknown class""); (""They"", ""pass to"", ""readLong()"")"
"The string (4,5,6,7) is an id string which could be returned by the readIdString() method.","(""id string"", ""returned by"", ""readIdString()""); (""readIdString()"", ""returns"", ""id string"")"
The readIdString() method comes in a variant that takes an optional list of parameters.,"(""readIdString()"", ""comes in"", ""variant""); (""readIdString()"", ""takes"", ""list of parameters""); (""variant"", ""takes"", ""list of parameters"")"
The IJdbcDao has a few read() methods that allows you to decide what to do with each record in the ResultSet resulting from some SQL query.,"(""IJdbcDao"", ""has"", ""read()""); (""read()"", ""returns"", ""ResultSet""); (""IJdbcDao"", ""uses"", ""SQL""); (""read()"", ""processes"", ""record""); (""ResultSet"", ""contains"", ""record""); (""SQL"", ""generates"", ""ResultSet"")"
To do so you must provide the read() method with an implementation of the IResultSetProcessor interface.,"(""IResultSetProcessor"", ""implemented by"", ""read()""); (""read()"", ""requires"", ""IResultSetProcessor"")"
The init() method is called before the iteration of the ResultSet begins.,"(""init()"", ""is called before"", ""iteration of the ResultSet""); (""init()"", ""is called on"", ""ResultSet""); (""ResultSet"", ""begins iteration after"", ""init()"")"
The process() method is called for each record in the ResultSet The read() method returns an object.,"(""process()"", ""called for"", ""ResultSet""); (""read()"", ""returns"", ""object"")"
This is the object is obtained from the getResult() method of the IResultSetProcessor.,"(""IResultSetProcessor"", ""hasMethod"", ""getResult()""); (""IResultSetProcessor"", ""returns"", ""object""); (""getResult()"", ""belongsTo"", ""IResultSetProcessor""); (""object"", ""isObtainedFrom"", ""getResult()""); (""getResult()"", ""returns"", ""object"")"
Here is an example of how to use a IResultSetProcessor with the read() methods:,"(""IResultSetProcessor"", ""used with"", ""read() methods""); (""IResultSetProcessor"", ""has method"", ""read()"")"
It may be a good idea to create a base class for your IResultSetProcessor implementations with empty method implementations for init() and perhaps a default behaviour for getResult().,"(""IResultSetProcessor"", ""has method"", ""init()""); (""IResultSetProcessor"", ""has method"", ""getResult()"")"
The read() method comes in a version that takes an optional number of parameters.,"(""read()"", ""comes in"", ""version""); (""version"", ""takes"", ""parameters""); (""read()"", ""takes"", ""parameters"")"
Notice how the number 1975 is passed into the read() method at the end.,
The execute() method should execute the PreparedStatement and return the result of the execution.,"(""execute()"", ""should execute"", ""PreparedStatement""); (""execute()"", ""return"", ""result""); (""PreparedStatement"", ""execution of"", ""execute()"")"
The postProcess() method is normally used to call methods on the PreparedStatement after execution.,"(""postProcess()"", ""is used to call"", ""methods""); (""postProcess()"", ""is used on"", ""PreparedStatement""); (""methods"", ""are called after"", ""execution""); (""PreparedStatement"", ""has"", ""methods""); (""postProcess()"", ""is called after"", ""execution"")"
"To read the ids of X records returned from a query into a string of the format (id1, id2, id3, ...) you will do like this:",
"From version 5.3.9 you no longer need to cast the returned object, if you use a Class object as object mapping key.","(""Class"", ""hasVersion"", ""5.3.9""); (""Class"", ""uses"", ""object""); (""object"", ""hasMappingKey"", ""Class""); (""Class"", ""returns"", ""object"")"
You can also parameterize the SQL statement and pass the parameters to the readList() method.,"(""SQL statement"", ""parameterized by"", ""parameters""); (""parameters"", ""passed to"", ""readList() method""); (""readList() method"", ""called with"", ""parameters"")"
"This text contains a few examples of how to use the object DAO, IObjectDao, so you can get an idea about how to use the IObjectDao class:","(""IObjectDao"", ""is used by"", ""object DAO""); (""IObjectDao"", ""is an example of"", ""DAO""); (""IObjectDao"", ""is a"", ""class"")"
In addition the Person class and persons table are defined like this:,"(""Person"", ""is defined in"", ""persons table""); (""Person"", ""is a"", ""class""); (""persons table"", ""is related to"", ""Person"")"
"Thus, it doesn't matter how many fields in a class are mapped to columns in the ""items"" table.","(""class"", ""is mapped to"", ""table""); (""field"", ""is part of"", ""class""); (""class"", ""has"", ""field""); (""table"", ""has"", ""column""); (""field"", ""is mapped to"", ""column"")"
"Therefore you need to create a special object mapping for the given class, that only maps the fields you want to write to columns in the database.","(""object"", ""maps"", ""fields""); (""object"", ""created for"", ""class""); (""class"", ""has"", ""fields""); (""fields"", ""written to"", ""columns""); (""columns"", ""in"", ""database"")"
"The object mapping key could be any object you choose, but if you want help from Butterfly Persistence to map a class to the database, the object mapping key should be either a java.lang.Class object, or an ObjectMappingKey instance.","(""ObjectMappingKey"", ""is instance of"", ""Object""); (""Butterfly Persistence"", ""maps"", ""java.lang.Class""); (""ObjectMappingKey"", ""is alternative to"", ""java.lang.Class""); (""Butterfly Persistence"", ""provides help for"", ""ObjectMappingKey""); (""java.lang.Class"", ""is used by"", ""Butterfly Persistence""); (""Butterfly Persistence"", ""maps"", ""ObjectMappingKey""); (""ObjectMappingKey"", ""is used by"", ""Butterfly Persistence"")"
"For instance, Employee.class is the object mapping key in the method call below:","(""Employee"", ""is the object mapping key in"", ""method call"")"
"To enable easy, always-in-time custom object mapping Butterfly Persistence provides the ObjectMappingKey class for advanced object mapping keys.","(""Butterfly Persistence"", ""provides"", ""ObjectMappingKey class""); (""ObjectMappingKey class"", ""used for"", ""advanced object mapping keys"")"
Creating an ObjectMappingKey instance is done using the ObjectMappingKey class factory methods.,"(""ObjectMappingKey"", ""has factory methods"", ""ObjectMappingKey class"")"
"That is because the ObjectMappingKey's factory methods gives each ObjectMappingKey instance a unique id, an int, which is used by its equals() and hashCode() methods.","(""ObjectMappingKey"", ""has method"", ""equals()""); (""ObjectMappingKey"", ""has method"", ""hashCode()""); (""ObjectMappingKey"", ""has attribute"", ""id""); (""ObjectMappingKey"", ""has method"", ""factory methods"")"
"This speeds up object mapping cache lookups because the hashCode() method returns this int id, and because equals() also only compares int id's, instead of Class objects, table names etc.","(""object"", ""uses"", ""hashCode() method""); (""hashCode() method"", ""returns"", ""int id""); (""equals() method"", ""compares"", ""int id""); (""equals() method"", ""avoids comparing"", ""Class objects""); (""equals() method"", ""avoids comparing"", ""table names""); (""object"", ""utilizes"", ""equals() method""); (""hashCode() method"", ""facilitates"", ""cache lookups""); (""equals() method"", ""facilitates"", ""cache lookups"")"
Instead of the class MyCustomObjectMapper you should use your own class.,"(""MyCustomObjectMapper"", ""should use"", ""custom class"")"
The extended class CustomObjectMapperBase is an empty implementation of the ICustomObjectMapper interface.,"(""CustomObjectMapperBase"", ""extends"", ""ICustomObjectMapper"")"
Just call the IObjectMapping.removeGetterMapping(String name) or IObjectMapping.removeSetterMapping(String name) method to do so.,"(""IObjectMapping"", ""hasMethod"", ""IObjectMapping.removeGetterMapping(String name)""); (""IObjectMapping"", ""hasMethod"", ""IObjectMapping.removeSetterMapping(String name)""); (""IObjectMapping.removeGetterMapping(String name)"", ""removes"", ""GetterMapping""); (""IObjectMapping.removeSetterMapping(String name)"", ""removes"", ""SetterMapping"")"
The ObjectMappingKey class has some static shortcut factory methods to create object mapping keys that has custom object mappers for auto-generated columns.,"(""ObjectMappingKey"", ""has"", ""static shortcut factory methods""); (""ObjectMappingKey"", ""creates"", ""object mapping keys""); (""object mapping keys"", ""has"", ""custom object mappers""); (""custom object mappers"", ""used for"", ""auto-generated columns"")"
The only thing required to use Butterfly Persistence is that you add the JAR file to the classpath of your application.,
"A lot of things are cached internally in the PersistenceManager instance, like object mappings, sql etc., so you should not create a new instance everytime you need it.","(""PersistenceManager"", ""has"", ""instance""); (""PersistenceManager"", ""caches"", ""object mappings""); (""PersistenceManager"", ""caches"", ""sql"")"
Version control systems typically also makes it easier for multiple people to collaborate - e.g.,
"The Docker base image you are using may itself consist of multiple layers, and can itself be based on another base image etc., until you get down to the most basic Docker image you can create - a raw Linux container image with no special settings applied.","(""Docker"", ""consists of"", ""layers""); (""Docker base image"", ""based on"", ""base image""); (""base image"", ""consists of"", ""layers""); (""raw Linux container image"", ""has"", ""no special settings""); (""Docker image"", ""based on"", ""raw Linux container image"")"
This example copies a single file from the Docker host at /myapp/target/myapp.jar to the Docker image at /myapp/myapp.jar .,"(""Docker"", ""has host"", ""/myapp/target/myapp.jar""); (""Docker"", ""has image"", ""/myapp/myapp.jar""); (""/myapp/target/myapp.jar"", ""is copied to"", ""/myapp/myapp.jar"")"
This example copies the two files /myapp/config/prod/conf1.cfg and /myapp/conig/prod/conf2.cfg into the Docker image directory /myapp/config/ .,
"In other words, you can create a directory inside the docker image, e.g.",
"called /data which can later be mounted to a directory, e.g.",
In a Maven repository a JAR file is identified by its group name (e.g.,"(""Maven repository"", ""contains"", ""JAR file""); (""JAR file"", ""identified by"", ""group name"")"
"the organization that made it), its artifact name (the name of the project / software / tool / API), and a version number (e.g.",
"This example declares a dependency on Log4J using the group name log4j, the artifact name log4j and the version 1.2.17 .","(""Log4J"", ""uses"", ""group name""); (""Log4J"", ""has"", ""artifact name""); (""Log4J"", ""has"", ""version 1.2.17""); (""dependency"", ""declared on"", ""Log4J""); (""Log4J"", ""has"", ""group name log4j""); (""Log4J"", ""has"", ""artifact name log4j""); (""log4j"", ""is"", ""group name""); (""log4j"", ""is"", ""artifact name""); (""1.2.17"", ""is"", ""version"")"
By default the testCompile dependency configuration also includes the compiled classes and the dependencies from the compile dependency configuration.,"(""testCompile"", ""includes"", ""compiled classes""); (""testCompile"", ""includes"", ""compile dependency configuration""); (""compile dependency configuration"", ""includes"", ""compiled classes""); (""compile dependency configuration"", ""includes"", ""dependencies"")"
The build task will compile all your Java classes and create a JAR file with them in.,"(""build task"", ""compile"", ""Java classes""); (""build task"", ""create"", ""JAR file""); (""Java classes"", ""included in"", ""JAR file"")"
Gradle outputs classes and JAR file to the directory named build inside your project root directory.,"(""Gradle"", ""outputs"", ""classes""); (""Gradle"", ""outputs"", ""JAR file""); (""classes"", ""stored in"", ""build directory""); (""JAR file"", ""stored in"", ""build directory""); (""build directory"", ""located in"", ""project root directory"")"
The compiled classes are written to build/classes and the JAR file to build/libs .,"(""build/classes"", ""contains"", ""compiled classes""); (""build/libs"", ""contains"", ""JAR file"")"
"This is because the classes, jar and assemble tasks are now all UP-TO-DATE from the last run.","(""jar"", ""is"", ""task""); (""assemble"", ""is"", ""task""); (""jar"", ""is"", ""UP-TO-DATE""); (""assemble"", ""is"", ""UP-TO-DATE""); (""classes"", ""is"", ""task""); (""classes"", ""is"", ""UP-TO-DATE"")"
"Running the clean task removes the build directory, and thus all compiled classes and created JAR files.","(""clean task"", ""removes"", ""build directory""); (""build directory"", ""contains"", ""compiled classes""); (""build directory"", ""contains"", ""JAR files"")"
"Second, this example calls the myTask doFirst() method, passing along a closure as parameter.","(""myTask"", ""calls"", ""doFirst()""); (""doFirst()"", ""has parameter"", ""closure"")"
"Third, this example calls the myTask doLast() method, passing along another closure as parameter.","(""myTask"", ""hasMethod"", ""doLast()""); (""doLast()"", ""receivesParameter"", ""closure"")"
"When the task myTask is executed Gradle will first execute all closures passed as parameters the doFirst() method, and then all closures passed as parameters the doLast() method.","(""Gradle"", ""execute"", ""myTask""); (""Gradle"", ""call"", ""doFirst()""); (""doFirst()"", ""parameter"", ""closures""); (""Gradle"", ""call"", ""doLast()""); (""doLast()"", ""parameter"", ""closures"")"
"First of all you do not need the semicolon ; after the doFirst() and doLast() method calls, if the code line with the method calls ends with a new line.",
"Second, you do not need the parentheses around the closure when calling doFirst() or doLast().","(""doFirst"", ""called without parentheses"", ""closure""); (""doLast"", ""called without parentheses"", ""closure"")"
With these two syntax optimizations you can write the doFirst() and doLast() method calls like this:,"(""doFirst()"", ""is called by"", ""unknown""); (""doLast()"", ""is called by"", ""unknown"")"
Often you will not need to pass closures to both doFirst() and doLast() .,"(""doFirst()"", ""has relationship with"", ""closures""); (""doLast()"", ""has relationship with"", ""closures"")"
It is quite common to pass just a single closure to the doLast() method.,"(""doLast()"", ""method of"", ""unknown class""); (""doLast()"", ""has parameter"", ""closure""); (""closure"", ""passed to"", ""doLast()"")"
"Because this is such a common use case, Gradle has a shortcut for passing a closure to the doLast() method.","(""Gradle"", ""has method"", ""doLast()"")"
The two characters << corresponds to calling the doLast() method like this:,"(""doLast()"", ""called by"", ""<<""); (""<<"", ""corresponds to"", ""doLast()"")"
You can even define the task on the same line as you pass the closure to the doLast() method.,"(""doLast()"", ""method"", ""closure""); (""task"", ""definition"", ""same line""); (""doLast()"", ""receives"", ""closure""); (""closure"", ""passed to"", ""doLast()"")"
You can also add multiple closures using the doLast() shortcut notation.,"(""doLast()"", ""uses"", ""shortcut notation"")"
"A task could be compiling the source code, generating JavaDoc, zipping the compiled classes into a JAR file etc.","(""Task"", ""could be"", ""compiling""); (""compiling"", ""involves"", ""source code""); (""Task"", ""could be"", ""generating JavaDoc""); (""Task"", ""could be"", ""zipping""); (""zipping"", ""involves"", ""compiled classes""); (""compiled classes"", ""packaged into"", ""JAR file"")"
The build script is typically called build.gradle and is normally located in the root directory of the project you are building.,"(""build script"", ""is located in"", ""root directory""); (""build script"", ""is called"", ""build.gradle""); (""project"", ""has directory"", ""root directory""); (""build script"", ""is part of"", ""project"")"
When you specify another build script Gradle does not use its settings.gradle file.,"(""Gradle"", ""uses"", ""settings.gradle file""); (""settings.gradle file"", ""is used by"", ""Gradle""); (""Gradle"", ""ignores"", ""settings.gradle file""); (""settings.gradle file"", ""is ignored by"", ""Gradle""); (""build script"", ""is specified by"", ""user""); (""Gradle"", ""uses"", ""build script""); (""build script"", ""is used by"", ""Gradle""); (""settings.gradle file"", ""is associated with"", ""Gradle""); (""Gradle"", ""is associated with"", ""settings.gradle file"")"
Gradle will use the build.gradle file found in the project directory (subproject-dir) and will execute the build task in that build script.,"(""Gradle"", ""uses"", ""build.gradle""); (""build.gradle"", ""contains"", ""build task""); (""Gradle"", ""executes"", ""build task"")"
"Note, that the Predicate interface contains a single unimplemented method named test() which returns a boolean.","(""Predicate"", ""contains"", ""test()""); (""Predicate"", ""has method"", ""test()""); (""test()"", ""is part of"", ""Predicate"")"
"After creating the two basic functions, a third Predicate is composed, which calls the test() methods of the two first functions.","(""Predicate"", ""calls"", ""test()""); (""Predicate"", ""composed of"", ""functions""); (""functions"", ""have method"", ""test()"")"
The Predicate interface (java.util.function.Predicate) contains a few methods that help you compose new Predicate instances from other Predicate instances.,"(""Predicate"", ""contains"", ""methods""); (""Predicate"", ""is located in"", ""java.util.function""); (""Predicate"", ""helps compose"", ""Predicate instances""); (""Predicate"", ""has methods"", ""methods""); (""methods"", ""help compose"", ""Predicate instances""); (""java.util.function"", ""contains"", ""Predicate"")"
The and() method is used to combine two other Predicate functions in the same way I showed in the beginning of this Java functional composition tutorial.,"(""Predicate"", ""hasMethod"", ""and()""); (""and()"", ""combines"", ""Predicate"")"
Here is an example of functional composition with the Predicate and() method:,"(""Predicate"", ""hasMethod"", ""and()"")"
This Predicate composition example composes a new Predicate from two other Predicate instances using the and() method of one of the basic Predicate instances.,"(""Predicate"", ""composes"", ""new Predicate""); (""Predicate"", ""uses"", ""and() method""); (""and() method"", ""of"", ""basic Predicate instances""); (""Predicate"", ""instances of"", ""basic Predicate"")"
The composed Predicate will return true from it's test() method if both of the Predicate instances it was composed from also return true.,"(""Predicate"", ""has method"", ""test()""); (""Predicate"", ""composed from"", ""Predicate"")"
"The Predicate or() method is used to combine a Predicate instance with another, to compose a third Predicate instance.","(""Predicate"", ""has method"", ""or()""); (""or()"", ""combines"", ""Predicate""); (""Predicate"", ""composes"", ""Predicate"")"
"The composed Predicate will return true if either of the Predicate instances it is composed from return true, when their test() methods are called with same input parameter as the composed Predicate.","(""Predicate"", ""composed_of"", ""Predicate""); (""Predicate"", ""has_method"", ""test()""); (""Predicate"", ""calls_method"", ""test()""); (""test()"", ""belongs_to"", ""Predicate"")"
This Predicate or() functional composition example first creates two basic Predicate instances.,"(""Predicate"", ""has method"", ""or()""); (""Predicate"", ""creates"", ""Predicate instances""); (""Predicate instances"", ""are created by"", ""Predicate"")"
"Second, the example creates a third Predicate composed from the first two, by calling the or() method on the first Predicate and passing the second Predicate as parameter to the or() method.","(""Predicate"", ""hasMethod"", ""or()""); (""or()"", ""takesParameter"", ""Predicate""); (""Predicate"", ""composes"", ""Predicate"")"
The Java Function interface (java.util.function.Function) also contains a few methods that can be used to compose new Function instances from existing ones.,"(""Java"", ""contains"", ""Function interface""); (""Function interface"", ""is in"", ""java.util.function""); (""Function interface"", ""contains"", ""methods""); (""methods"", ""can be used for"", ""composing""); (""composing"", ""involves"", ""Function instances""); (""Function instances"", ""are from"", ""existing ones""); (""Java"", ""has package"", ""java.util.function"")"
"The Java Function compose() method composes a new Function instance from the Function instance it is called on, and the Function instance passed as parameter to the compose() method.","(""Function"", ""composes"", ""Function""); (""Function"", ""has method"", ""compose()""); (""compose()"", ""takes parameter"", ""Function""); (""compose()"", ""returns"", ""Function"")"
"The Function returned by compose() will first call the Function passed as parameter to compose(), and then it will call the Function which compose() was called on.","(""Function"", ""returned by"", ""compose()""); (""compose()"", ""called on"", ""Function""); (""Function"", ""passed to"", ""compose()""); (""compose()"", ""called with"", ""Function""); (""Function"", ""calls"", ""Function"")"
"This is easier to understand with an example, so here is a Java Function compose() example:","(""Function"", ""isPartOf"", ""Java""); (""compose()"", ""isA"", ""Function"")"
The Java Function andThen() method works opposite of the compose() method.,"(""Java"", ""has_method"", ""Function""); (""Function"", ""has_method"", ""andThen()""); (""Function"", ""has_method"", ""compose()"")"
"A Function composed with andThen() will first call the Function that andThen() was called on, and then it will call the Function passed as parameter to the andThen() method.","(""Function"", ""composed with"", ""andThen()""); (""andThen()"", ""called on"", ""Function""); (""Function"", ""call"", ""Function""); (""andThen()"", ""passed as parameter to"", ""Function"")"
"Then the andThen() method is called on the multiply Function to compose a new Function, passing the add Function as parameter to andThen().","(""multiply Function"", ""andThen()"", ""add Function""); (""multiply Function"", ""has method"", ""andThen()""); (""andThen()"", ""takes parameter"", ""add Function"")"
Calling the Function composed by andThen() with the value 3 will result in the following calculation 3 * 2 + 3 and the result will be 9.,"(""Function"", ""composed by"", ""andThen()""); (""andThen()"", ""called with"", ""3""); (""Function"", ""performs calculation"", ""3 * 2 + 3""); (""calculation"", ""results in"", ""9"")"
"Note: As mentioned in the beginning, andThen() works opposite of compose().","(""andThen()"", ""works opposite of"", ""compose()"")"
"Therefore, calling a.andThen(b) is actually the same as calling b.compose(a) .","(""a"", ""andThen"", ""b""); (""a"", ""compose"", ""b""); (""b"", ""compose"", ""a"")"
The Java Function interface (java.util.function.Function) interface is one of the most central functional interfaces in Java.,"(""Java"", ""has interface"", ""Function""); (""Function"", ""is in package"", ""java.util.function"")"
The only method you have to implement to implement the Function interface is the apply() method.,"(""Function"", ""has method"", ""apply()"")"
"This Function implementation implements the apply() method so it takes a Long as parameter, and returns a Long.","(""Function"", ""implements"", ""apply()""); (""apply()"", ""takes"", ""Long""); (""apply()"", ""returns"", ""Long"")"
"Second, the example calls the apply() method on the AddThree instance.","(""AddThree"", ""calls"", ""apply()""); (""AddThree"", ""has method"", ""apply()""); (""apply()"", ""is called by"", ""AddThree"")"
"As you can see, the Function interface implementation is now inlined in the declaration of the adderLambda variable, rather than in a separate class.","(""Function"", ""is implemented in"", ""adderLambda""); (""adderLambda"", ""declares"", ""Function""); (""Function"", ""is inlined in"", ""adderLambda"")"
"The Java Predicate interface, java.util.function.Predicate, represents a simple function that takes a single value as parameter, and returns true or false.","(""Java"", ""has interface"", ""Predicate""); (""Predicate"", ""is in package"", ""java.util.function""); (""Predicate"", ""represents"", ""function""); (""Predicate"", ""takes parameter"", ""value""); (""Predicate"", ""returns"", ""true""); (""Predicate"", ""returns"", ""false"")"
"The Predicate interface contains more methods than the test() method, but the rest of the methods are default or static methods which you don't have to implement.","(""Predate"", ""contains"", ""methods""); (""Predate"", ""has"", ""test() method""); (""Predate"", ""has"", ""default methods""); (""Predate"", ""has"", ""static methods"")"
"You can implement the Predicate interface using a class, like this:","(""Predicate"", ""implemented by"", ""class"")"
This lambda implementation of the Predicate interface effectively does the same as the implementation above that uses a class.,"(""Predicate"", ""implements"", ""lambda""); (""Predicate"", ""is implemented by"", ""class"")"
This Java Consumer implementation prints the value passed as parameter to it out to System.out.,"(""Consumer"", ""implements"", ""Java""); (""Consumer"", ""prints to"", ""System.out"")"
"Especially the idea of ""no side effects"" makes it hard to e.g.",
"In the functional programming paradigm, functions are first class objects in the language.","(""functions"", ""are"", ""first class objects""); (""functions"", ""are in"", ""language""); (""language"", ""has"", ""functions""); (""functions"", ""are"", ""objects"")"
Notice how the return value of the sum() function only depends on the input parameters.,
"Notice also that the sum() has no side effects, meaning it does not modify any state (variables) outside the function anywhere.","(""sum()"", ""has no side effects"", ""state""); (""sum()"", ""does not modify"", ""variables""); (""sum()"", ""is a part of"", ""function""); (""function"", ""has"", ""state""); (""function"", ""has"", ""variables""); (""sum()"", ""has no side effects"", ""function""); (""state"", ""is outside of"", ""function""); (""variables"", ""are outside of"", ""function"")"
"Notice how the method add() uses a member variable to calculate its return value, and it also modifies the state of the value member variable, so it has a side effect.","(""add()"", ""uses"", ""member variable""); (""add()"", ""modifies"", ""value member variable""); (""add()"", ""has"", ""side effect"")"
Notice how the createFactory() method returns a lambda expression as result.,"(""createFactory()"", ""returns"", ""lambda expression"")"
Notice also that the createFactory() method takes two instances as parameters which are both implementations of interfaces (IProducer and IConfigurator).,"(""IProducer"", ""implemented by"", ""createFactory() parameter""); (""IConfigurator"", ""implemented by"", ""createFactory() parameter""); (""createFactory()"", ""takes"", ""IProducer""); (""createFactory()"", ""takes"", ""IConfigurator"")"
Therefore they can be implemented by Java lambda expressions - and therefore the createFactory() method is a higher order function.,"(""Java"", ""uses"", ""lambda expressions""); (""lambda expressions"", ""implemented by"", ""createFactory() method""); (""createFactory() method"", ""is"", ""higher order function"")"
"A function may have local variables containing temporary state internally, but the function cannot reference any member variables of the class or object the function belongs to.","(""function"", ""has"", ""local variables""); (""function"", ""belongs to"", ""class""); (""function"", ""belongs to"", ""object""); (""function"", ""cannot reference"", ""member variables""); (""class"", ""has"", ""member variables""); (""object"", ""has"", ""member variables"")"
"State outside of a function refers both to member variables in the class or object the function, and member variables inside parameters to the functions, or state in external systems like file systems or databases.","(""function"", ""has"", ""member variables""); (""function"", ""belongs to"", ""class""); (""function"", ""belongs to"", ""object""); (""parameters"", ""contain"", ""member variables""); (""function"", ""interacts with"", ""external systems""); (""external systems"", ""include"", ""file systems""); (""external systems"", ""include"", ""databases"")"
"This is still a functional interface, because only run() is not implemented (abstract).","(""run"", ""is part of"", ""functional interface"")"
The first example of a higher order function is the Collections.sort() method which takes a Comparator as parameter.,"(""Collections"", ""hasMethod"", ""sort()""); (""sort()"", ""takesParameter"", ""Comparator""); (""Comparator"", ""isParameterOf"", ""sort()"")"
The lambda parameter is what makes Collections.sort() a higher order function.,"(""Collections"", ""has method"", ""sort()""); (""sort()"", ""is a"", ""higher order function""); (""Collections.sort()"", ""uses"", ""lambda parameter"")"
"Second, the example calls the reversed() method on the Comparator lambda.","(""Comparator"", ""hasMethod"", ""reversed()""); (""Comparator"", ""usesMethod"", ""reversed()""); (""reversed()"", ""isMethodOf"", ""Comparator"")"
"The reversed() method returns a new Comparator lambda, which reverse the result returned by the first Comparator implementation.","(""reversed()"", ""returns"", ""Comparator""); (""reversed()"", ""reverse"", ""Comparator""); (""Comparator"", ""returns"", ""result""); (""Comparator"", ""implements"", ""lambda"")"
"By ""reversing"" I mean that it simply returns -1 * comparator.compare(a,b)","(""comparator"", ""hasMethod"", ""compare()""); (""compare()"", ""takesParameters"", ""a""); (""compare()"", ""takesParameters"", ""b"")"
"Because the reversed() method returns a lambda (function), the reversed() method is considered a higher order function.","(""reversed() method"", ""returns"", ""lambda""); (""reversed() method"", ""is considered"", ""higher order function"")"
"Third, the example sorts the List of Strings using the Collections.sort() method.","(""example"", ""uses"", ""Collections.sort()""); (""List"", ""is sorted by"", ""Collections.sort()""); (""Strings"", ""are contained in"", ""List"")"
"In contrast, when you are using the Java Collections iteration features (e.g a Java Iterator or the Java for-each loop used with a Java Iterable) you have to implement the iteration of the elements yourself.","(""Java Iterator"", ""used with"", ""Java Iterable""); (""Java Collections"", ""includes"", ""Java Iterator""); (""Java Collections"", ""includes"", ""Java Iterable""); (""Java for-each loop"", ""used with"", ""Java Iterable"")"
"Finally, the example calls the stream() method to obtain a Stream instance.","(""example"", ""calls"", ""stream() method""); (""stream() method"", ""obtains"", ""Stream instance""); (""example"", ""obtains"", ""Stream instance"")"
The call to the map() method of the Stream interface is a non-terminal operation.,"(""Stream"", ""has method"", ""map()""); (""Stream"", ""has operation"", ""map()""); (""map()"", ""is part of"", ""Stream"")"
The map() method will be covered in more detail later on.,"(""map"", ""will be covered in"", ""more detail"")"
Notice how the second call to Stream map() is called on the Stream returned by the first map() call.,"(""Stream"", ""hasMethod"", ""map()""); (""map()"", ""returns"", ""Stream""); (""Stream"", ""hasMethod"", ""map()"")"
The Java Stream filter() can be used to filter out elements from a Java Stream.,"(""Java Stream"", ""has method"", ""filter()""); (""filter()"", ""used for"", ""Java Stream""); (""Java Stream"", ""contains"", ""elements""); (""filter()"", ""filters out"", ""elements"")"
Here is an example of calling the Java Stream filter() method:,"(""Java"", ""uses"", ""Stream""); (""Stream"", ""hasMethod"", ""filter()""); (""filter()"", ""isMethodOf"", ""Stream"")"
The Java Stream map() method converts (maps) an element to another object.,"(""Java Stream"", ""has method"", ""map()""); (""map()"", ""converts"", ""element""); (""map()"", ""maps to"", ""object"")"
The Java Stream flatMap() methods maps a single element into multiple elements.,"(""Java Stream"", ""has method"", ""flatMap()""); (""flatMap()"", ""maps"", ""element""); (""flatMap()"", ""returns"", ""elements"")"
This example should give you an idea about how flatMap() can be used to map a single element into multiple elements.,"(""flatMap()"", ""is method of"", ""unknown class""); (""unknown class"", ""has method"", ""flatMap()"")"
This Java Stream flatMap() example first creates a List with 3 strings containing book titles.,"(""Java"", ""uses"", ""Stream""); (""Stream"", ""hasMethod"", ""flatMap()""); (""List"", ""contains"", ""strings""); (""strings"", ""represent"", ""book titles"")"
"Then a Stream for the List is obtained, and flatMap() called.","(""Stream"", ""obtained from"", ""List""); (""List"", ""has method"", ""flatMap()""); (""Stream"", ""has method"", ""flatMap()"")"
The flatMap() operation called on the Stream has to return another Stream representing the flat mapped elements.,"(""Stream"", ""hasOperation"", ""flatMap()""); (""flatMap()"", ""returns"", ""Stream"")"
Note that this example finishes with a call to forEach() which is a terminal operation.,"(""forEach"", ""is a"", ""terminal operation"")"
The Java Stream distinct() method is a non-terminal operation that returns a new Stream which will only contain the distinct elements from the original stream.,"(""Java Stream"", ""hasMethod"", ""distinct()""); (""distinct()"", ""returns"", ""Stream""); (""Stream"", ""contains"", ""elements"")"
Only the first occurrence of this element will be included in the Stream returned by distinct().,"(""Stream"", ""returned by"", ""distinct()""); (""distinct()"", ""included in"", ""Stream"")"
"Thus, the resulting List (from calling collect()) will only contain one, two and three.","(""List"", ""contains"", ""one""); (""List"", ""contains"", ""two""); (""List"", ""contains"", ""three""); (""List"", ""results from"", ""collect()"")"
The Java Stream limit() method can limit the number of elements in a stream to a number given to the limit() method as parameter.,"(""Java Stream"", ""has method"", ""limit()""); (""limit()"", ""is parameterized by"", ""number of elements""); (""limit()"", ""limits"", ""stream"")"
The limit() method returns a new Stream which will at most contain the given number of elements.,"(""Stream"", ""has method"", ""limit()""); (""limit()"", ""returns"", ""Stream"")"
"This example first creates a Stream, then calls limit() on it, and then calls forEach() with a lambda that prints out the elements in the stream.","(""Stream"", ""calls"", ""limit()""); (""Stream"", ""calls"", ""forEach()""); (""forEach()"", ""uses"", ""lambda""); (""Stream"", ""has method"", ""limit()""); (""Stream"", ""has method"", ""forEach()"")"
The Java Stream peek() method is a non-terminal operation that takes a Consumer (java.util.function.Consumer) as parameter.,"(""Java Stream"", ""has method"", ""peek()""); (""peek()"", ""takes parameter"", ""Consumer""); (""Consumer"", ""is in package"", ""java.util.function"")"
The peek() method returns a new Stream which contains all the elements in the original stream.,"(""peek()"", ""returns"", ""Stream""); (""Stream"", ""contains"", ""elements""); (""elements"", ""in"", ""stream""); (""stream"", ""has"", ""peek()"")"
"The purpose of the peek() method is, as the method says, to peek at the elements in the stream, not to transform them.","(""peek()"", ""is a method of"", ""stream"")"
It is the call to count() at the end of the example that is the terminal operation.,"(""count()"", ""is terminal operation of"", ""example"")"
"Since count() returns a long, the Stream chain of non-terminal operations (the map() calls) is ended.","(""Stream"", ""hasMethod"", ""count()""); (""Stream"", ""hasMethod"", ""map()""); (""map()"", ""isNonTerminalOperation"", ""true""); (""count()"", ""returns"", ""long"")"
"The Java Stream anyMatch() method is a terminal operation that takes a single Predicate as parameter, starts the internal iteration of the Stream, and applies the Predicate parameter to each element.","(""Java Stream"", ""hasMethod"", ""anyMatch()""); (""anyMatch()"", ""takesParameter"", ""Predicate""); (""Stream"", ""hasOperation"", ""anyMatch()""); (""anyMatch()"", ""appliesTo"", ""element""); (""Predicate"", ""isParameterOf"", ""anyMatch()"")"
"If the Predicate returns true for any of the elements, the anyMatch() method returns true.","(""Predicate"", ""returns"", ""true""); (""anyMatch"", ""method returns"", ""true""); (""Predicate"", ""used in"", ""anyMatch""); (""anyMatch"", ""returns"", ""true""); (""elements"", ""checked by"", ""Predicate"")"
"In the example above, the anyMatch() method call will return true, because the first string element in the stream starts with ""One"".","(""Stream"", ""hasMethod"", ""anyMatch()""); (""String"", ""hasMethod"", ""startsWith()""); (""anyMatch()"", ""returns"", ""true""); (""String"", ""startsWith"", ""One"")"
"The Java Stream allMatch() method is a terminal operation that takes a single Predicate as parameter, starts the internal iteration of elements in the Stream, and applies the Predicate parameter to each element.","(""Java Stream"", ""hasMethod"", ""allMatch()""); (""allMatch()"", ""takesParameter"", ""Predicate""); (""allMatch()"", ""appliesTo"", ""elements""); (""Java Stream"", ""hasOperation"", ""allMatch()""); (""allMatch()"", ""isTypeOf"", ""terminal operation"")"
"If the Predicate returns true for all elements in the Stream, the allMatch() will return true.","(""Predicate"", ""returns true for"", ""elements""); (""Stream"", ""contains"", ""elements""); (""allMatch()"", ""returns"", ""true""); (""Predicate"", ""used in"", ""allMatch()"")"
"If not all elements match the Predicate, the allMatch() method returns false.","(""allMatch() method"", ""returns"", ""false""); (""Predicate"", ""is used by"", ""allMatch() method""); (""allMatch() method"", ""is called on"", ""elements"")"
"In the example above, the allMatch() method will return false, because only one of the strings in the Stream starts with ""One"".","(""Stream"", ""hasMethod"", ""allMatch()"")"
"The Java Stream noneMatch() method is a terminal operation that will iterate the elements in the stream and return true or false, depending on whether no elements in the stream matches the Predicate passed to noneMatch() as parameter.","(""Java Stream"", ""has method"", ""noneMatch()""); (""noneMatch()"", ""takes parameter"", ""Predicate""); (""noneMatch()"", ""returns"", ""true""); (""noneMatch()"", ""returns"", ""false""); (""noneMatch()"", ""is type of"", ""terminal operation""); (""Java Stream"", ""uses"", ""noneMatch()"")"
"The noneMatch() method will return true if no elements are matched by the Predicate, and false if one or more elements are matched.","(""noneMatch()"", ""is method of"", ""Predicate""); (""noneMatch()"", ""returns"", ""true""); (""noneMatch()"", ""returns"", ""false""); (""Predicate"", ""has method"", ""noneMatch()"")"
"The Java Stream collect() method is a terminal operation that starts the internal iteration of elements, and collects the elements in the stream in a collection or object of some kind.","(""Java Stream"", ""has method"", ""collect()""); (""collect()"", ""is type of"", ""terminal operation""); (""Java Stream"", ""uses"", ""collect()""); (""collect()"", ""collects elements in"", ""collection""); (""collect()"", ""collects elements in"", ""object"")"
"Luckily, the Java class java.util.stream.Collectors contains a set of pre-implemented Collector implementations you can use, for the most common operations.","(""java.util.stream.Collectors"", ""contains"", ""Collector""); (""Collector"", ""used for"", ""operations""); (""java.util.stream.Collectors"", ""provides"", ""Collector implementations""); (""Collector implementations"", ""used for"", ""common operations""); (""Java"", ""has class"", ""java.util.stream.Collectors"")"
"In the example above, it was the Collector implementation returned by Collectors.toList() that was used.","(""Collectors"", ""returned"", ""Collector""); (""Collectors"", ""has method"", ""toList()""); (""Collector"", ""implemented by"", ""Collector implementation""); (""Collectors.toList()"", ""returns"", ""Collector"")"
"The Java Stream count() method is a terminal operation which starts the internal iteration of the elements in the Stream, and counts the elements.","(""Java Stream"", ""has method"", ""count()""); (""Java Stream"", ""uses"", ""count()""); (""count()"", ""is part of"", ""Java Stream"")"
"This example first creates a List of strings, then obtain the Stream for that List, adds a flatMap() operation for it, and then finishes with a call to count().","(""List"", ""creates"", ""example""); (""List"", ""obtains"", ""Stream""); (""Stream"", ""adds"", ""flatMap()""); (""Stream"", ""finishes with"", ""count()""); (""List"", ""has"", ""Stream"")"
"The count() method will start the iteration of the elements in the Stream which will result in the string elements being split up into words in the flatMap() operation, and then counted.","(""Stream"", ""hasMethod"", ""count()""); (""Stream"", ""hasMethod"", ""flatMap()"")"
The Java Stream findAny() method can find a single element from the Stream.,"(""Java Stream"", ""has method"", ""findAny()""); (""findAny()"", ""returns"", ""element""); (""Java Stream"", ""uses method"", ""findAny()"")"
You can check if an element was found via the Optional isPresent() method.,"(""Optional"", ""hasMethod"", ""isPresent()"")"
"The Java Stream findFirst() method finds the first element in the Stream, if any elements are present in the Stream.","(""Java Stream"", ""has method"", ""findFirst()""); (""findFirst()"", ""finds"", ""element""); (""Stream"", ""contains"", ""elements""); (""Java Stream"", ""has elements"", ""elements""); (""findFirst()"", ""returns"", ""first element"")"
"The findFirst() method returns an Optional from which you can obtain the element, if present.","(""Optional"", ""returned by"", ""findFirst()""); (""findFirst()"", ""returns"", ""Optional""); (""Optional"", ""contains"", ""element""); (""findFirst()"", ""obtains"", ""element"")"
You can check if the Optional returned contains an element via its isPresent() method.,"(""Optional"", ""has method"", ""isPresent()"")"
"The Java Stream forEach() method is a terminal operation which starts the internal iteration of the elements in the Stream, and applies a Consumer (java.util.function.Consumer) to each element in the Stream.","(""Java Stream"", ""hasMethod"", ""forEach()""); (""forEach()"", ""applies"", ""Consumer""); (""Stream"", ""hasOperation"", ""forEach()""); (""forEach()"", ""isTypeOf"", ""terminal operation""); (""Stream"", ""uses"", ""Consumer""); (""Consumer"", ""isLocatedIn"", ""java.util.function""); (""forEach()"", ""isPartOf"", ""Java Stream""); (""Java Stream"", ""imports"", ""java.util.function"")"
The Java Stream min() method is a terminal operation that returns the smallest element in the Stream.,"(""Java Stream"", ""has method"", ""min()""); (""min()"", ""is a"", ""terminal operation""); (""Stream"", ""has operation"", ""min()""); (""min()"", ""returns"", ""smallest element"")"
Which element is the smallest is determined by the Comparator implementation you pass to the min() method.,"(""Comparator"", ""implementation used by"", ""min()""); (""min()"", ""method of"", ""Comparator"")"
Notice how the min() method returns an Optional which may or may not contain a result.,"(""min()"", ""returns"", ""Optional"")"
"If the Stream is empty, the Optional get() method will throw a NoSuchElementException.","(""Stream"", ""has method"", ""get()""); (""Optional"", ""has method"", ""get()""); (""get()"", ""throws"", ""NoSuchElementException"")"
The Java Stream max() method is a terminal operation that returns the largest element in the Stream.,"(""Java Stream"", ""hasMethod"", ""max()""); (""max()"", ""isTypeOf"", ""terminal operation""); (""Stream"", ""hasMethod"", ""max()"")"
Which element is the largest is determined by the Comparator implementation you pass to the max() method.,"(""Comparator"", ""passed to"", ""max()""); (""max()"", ""determines"", ""largest element""); (""Comparator"", ""implements"", ""comparison""); (""max()"", ""uses"", ""Comparator"")"
Notice how the max() method returns an Optional which may or may not contain a result.,"(""max()"", ""returns"", ""Optional"")"
The Java Stream reduce() method is a terminal operation that can reduce all elements in the stream to a single element.,"(""Java Stream"", ""has method"", ""reduce()""); (""reduce()"", ""is type of"", ""terminal operation"")"
This Optional contains the value (if any) returned by the lambda expression passed to the reduce() method.,"(""Optional"", ""contains"", ""value""); (""lambda expression"", ""passed to"", ""reduce() method""); (""reduce() method"", ""returned by"", ""lambda expression""); (""Optional"", ""returned by"", ""reduce() method"")"
"The Java Stream toArray() method is a terminal operation that starts the internal iteration of the elements in the stream, and returns an array of Object containing all the elements.","(""Java Stream"", ""hasMethod"", ""toArray()""); (""toArray()"", ""returns"", ""array""); (""toArray()"", ""isTypeOf"", ""terminal operation""); (""Java Stream"", ""usesMethod"", ""toArray()"")"
The Java Stream interface contains a static method called concat() which can concatenate two streams into one.,"(""Java Stream"", ""contains"", ""concat()""); (""concat()"", ""concatenate"", ""streams""); (""Java Stream"", ""has method"", ""concat()"")"
Here is an example of using the Java Stream concat() method:,"(""Java Stream"", ""has method"", ""concat()""); (""concat()"", ""is method of"", ""Java Stream"")"
The Java Stream interface contains a static method called of() which can be used to create a Stream from one or more objects.,"(""Java Stream"", ""contains"", ""of()""); (""Java Stream"", ""contains"", ""of()""); (""Java Stream"", ""has method"", ""of()""); (""Java Stream.of()"", ""creates"", ""Stream""); (""Stream"", ""created from"", ""objects""); (""Java Stream"", ""has method"", ""of()"")"
Here is an example of using the Java Stream of() metho:,"(""Java"", ""uses"", ""Stream""); (""Stream"", ""has method"", ""of()"")"
"A graph based stream processing API could instead support a ""sample"" operation where each node in the stream processing graph is asked for any value it may hold internally (e.g.","(""Graph"", ""has"", ""Node""); (""Node"", ""has"", ""Value""); (""Stream"", ""has"", ""Node""); (""Graph"", ""supports"", ""Operation""); (""Operation"", ""is"", ""sample"")"
Some graph based stream processing APIs are also designed to kind of hide the iteration of the elements from the user of the API (e.g.,
The full code for the command line argument parsers is listed at the end of this tutorial (it's just one class).,"(""Parser"", ""isPartOf"", ""CommandLineArgumentParsers""); (""CommandLineArgumentParsers"", ""contains"", ""Parser""); (""Parser"", ""is ListedIn"", ""Tutorial"")"
The interpretation of these command line arguments could be that the copy program should copy file.txt to a file named file2.txt and overwrite file2.txt if it already exists.,
These command line arguments consists of one switch (-overwrite) and two targets (file.txt and file.2.txt).,
"When the switch -overwrite is removed, the two arguments file.txt and file2.txt remain.",
The command line argument parser consists of a single Java class named CliArgs.,"(""CliArgs"", ""consists of"", ""Java class""); (""CliArgs"", ""is a"", ""Java class""); (""Java class"", ""has"", ""CliArgs""); (""CliArgs"", ""is named"", ""CliArgs""); (""command line argument parser"", ""consists of"", ""CliArgs""); (""CliArgs"", ""is part of"", ""command line argument parser""); (""command line argument parser"", ""has"", ""CliArgs"")"
The CliArgs class takes an array of String as argument to its constructor.,"(""CliArgs"", ""takes argument"", ""String""); (""CliArgs"", ""has constructor"", ""constructor"")"
The CliArgs class contains the following methods you can use to obtain switch information and values:,"(""CliArgs"", ""contains"", ""methods""); (""CliArgs"", ""has method"", ""obtain switch information""); (""CliArgs"", ""has method"", ""obtain values"")"
The switchPresent() method can be used to ask if a given switch is present or not.,"(""switchPresent"", ""is a method of"", ""unknown class""); (""switchPresent"", ""used to check"", ""switch"")"
"If the command line arguments contains the -overwrite switch anywhere, the switchPresent() method will return true.","(""command line arguments"", ""contains"", ""-overwrite switch""); (""-overwrite switch"", ""is checked by"", ""switchPresent() method""); (""switchPresent() method"", ""returns"", ""true"")"
The switchValue() method can be use to obtain the value of a switch.,"(""switchValue()"", ""is method of"", ""unknown""); (""switchValue()"", ""used to obtain"", ""switch value""); (""switch()"", ""has method"", ""switchValue()"")"
Here is a code example showing how to use switchValue() to read the value of the -port switch:,
If you want the value of a switch parsed into a long or double you can use the switchLongValue() and switchDoubleValue() methods.,"(""switchLongValue()"", ""is method of"", ""unknown class""); (""switchDoubleValue()"", ""is method of"", ""unknown class"")"
The switchValues() method is used to obtain multiple values for a switch.,"(""switchValues"", ""is_used_to_obtain"", ""values""); (""switchValues"", ""is_a_method_of"", ""switch"")"
The switchValues() method will return all values after the switch and until the next switch is met (next argument starting with a - character).,"(""switchValues"", ""method of"", ""unknown class""); (""switchValues"", ""returns"", ""values""); (""values"", ""filtered by"", ""switch""); (""switch"", ""identified by"", ""- character"")"
The values of the -from switch will be file1.txt and file2.txt.,
The values of the -to switch will be copy1.txt and copy2.txt.,
Instead you can create a swith POJO (Plain Old Java Object) class to hold all the switches.,"(""POJO"", ""is a type of"", ""class"")"
"You can now read all the switches from the command line directly into an instance of the CliSwitches class, using the switchPojo() method.","(""CliSwitches"", ""hasMethod"", ""switchPojo()""); (""CliSwitches"", ""usedBy"", ""command line""); (""switchPojo()"", ""belongsTo"", ""CliSwitches""); (""command line"", ""uses"", ""CliSwitches""); (""CliSwitches"", ""initializedBy"", ""command line"")"
The CliArgs switchPojo() method will use the property names inside the class to match against switches in the command line.,"(""CliArgs"", ""hasMethod"", ""switchPojo()""); (""CliArgs.switchPojo()"", ""uses"", ""property names""); (""property names"", ""arePartOf"", ""class"")"
The targets() method returns all the arguments which are not switches or switch values.,
"The CliArgs class distinguishes between switch values and targets by assuming, that all arguments which have not been ""taken"" already as switch values must be targets.","(""CliArgs"", ""distinguishes"", ""switch values""); (""CliArgs"", ""distinguishes"", ""targets""); (""CliArgs"", ""assumes"", ""arguments""); (""arguments"", ""have not been taken"", ""switch values""); (""arguments"", ""must be"", ""targets"")"
"will the method targets() as executed in the code above, return the String",
"Therefore the targets() method call will return the argument web-root , because web-root is the only argument that has not been ""taken"" yet, even if it is located in the middle of the argument list.","(""targets"", ""method call"", ""return""); (""argument"", ""has location"", ""argument list""); (""web-root"", ""is argument"", ""argument list""); (""targets"", ""returns"", ""web-root""); (""web-root"", ""is located in"", ""argument list""); (""argument list"", ""contains"", ""web-root"")"
You may need to have at least N next bytes (e.g.,
"To be able to move forth and back in the stream data, you may need to keep the next e.g.",
To solve this problem I will develop a RollingBufferInputStream class which keeps at least N bytes available in a buffer.,"(""RolingBufferInputStream"", ""has"", ""buffer""); (""RolingBufferInputStream"", ""keeps"", ""bytes"")"
"The RollingBufferInputStream class which I have developed, can be used to iterate an InputStream while at the same time making sure there is always block size bytes available in the buffer.","(""RollingBufferInputStream"", ""uses"", ""InputStream""); (""RollingBufferInputStream"", ""has"", ""buffer""); (""InputStream"", ""is used by"", ""RollingBufferInputStream"")"
"Note: Even if the class is called RollingBufferInputStream, it is not an InputStream subclass.","(""RollingBufferInputStream"", ""is not a subclass of"", ""InputStream"")"
"First you ask if the buffer has N available bytes, by calling hasAvailableBytes().","(""buffer"", ""hasAvailableBytes()"", ""hasAvailableBytes()"")"
This outline mostly serves to show you the interface of the RollingBufferInputStream class.,"(""RollingBufferInputStream"", ""is a class of"", ""interface""); (""RollingBufferInputStream"", ""has an interface of"", ""interface""); (""interface"", ""is implemented by"", ""RollingBufferInputStream"")"
"If the call to hasAvailableBytes() detects that there is not enough bytes available in the buffer, it will attempt to fill the buffer.","(""hasAvailableBytes()"", ""detects"", ""buffer""); (""hasAvailableBytes()"", ""attempts to fill"", ""buffer"")"
"Here is the full hasAvailableBytes() method implementation, so you can see how it works:","(""hasAvailableBytes()"", ""is method of"", ""unknown class"")"
"Filling data into the buffer is done by the method fillDataFromStreamIntoBuffer(), which is shown here:","(""fillDataFromStreamIntoBuffer()"", ""is method of"", ""unknown class"")"
"You could use the String.replace() method, but for large amounts of data, and high number of replacements, this performs badly.","(""String"", ""hasMethod"", ""replace()""); (""String.replace()"", ""belongsTo"", ""String"")"
The String.replace() method creates a new String instance - which is a copy of the original String with the replacements applied.,"(""String"", ""hasMethod"", ""replace()""); (""String"", ""creates"", ""String""); (""replace()"", ""belongsTo"", ""String""); (""String"", ""hasInstance"", ""String"")"
"If you have to perform 5 replacements, you have to call replace() 5 times, each time on the string returned by the last replace() call, like this:","(""replace()"", ""called on"", ""string""); (""string"", ""returns"", ""string""); (""replace()"", ""called"", ""5 times"")"
"... where N = the size of the string, and M = the number of replacements to perform.",
"Instead of using the String.replace() method I will here present a different, more scalable solution called a TokenReplacingReader.","(""String"", ""hasMethod"", ""replace()""); (""String"", ""usedIn"", ""TokenReplacingReader""); (""TokenReplacingReader"", ""isAlternativeTo"", ""String.replace()""); (""TokenReplacingReader"", ""presents"", ""scalableSolution""); (""String.replace()"", ""isReplacedBy"", ""TokenReplacingReader"")"
The token name (without the enclosing ${} ) is passed to the ITokenResolver.resolveToken(String tokenName) method.,"(""ITokenResolver"", ""hasMethod"", ""resolveToken(String tokenName)""); (""ITokenResolver.resolveToken(String tokenName)"", ""takesParameter"", ""String tokenName""); (""resolveToken(String tokenName)"", ""isMethodOf"", ""ITokenResolver"")"
"The TokenReplacingReader is itself a subclass of java.io.Reader, so any class that can use a Reader, can use a TokenReplacingReader.","(""TokenReplacingReader"", ""is a subclass of"", ""java.io.Reader""); (""TokenReplacingReader"", ""can be used by"", ""any class that can use a Reader""); (""Reader"", ""can be used by"", ""any class that can use a Reader"")"
The TokenReplacingReader does not use as much memory as the String.replace() method.,"(""TokenReplacingReader"", ""does not use"", ""String.replace()""); (""TokenReplacingReader"", ""compares to"", ""String.replace()""); (""TokenReplacingReader"", ""uses less memory than"", ""String.replace()"")"
"... where N is the size of the data to replace tokens in, and M is the number of replacements.",
This is faster than the O(N * M) of the String.replace() method.,"(""String"", ""hasMethod"", ""replace()""); (""String"", ""comparedTo"", ""O(N * M)""); (""O(N * M)"", ""isComplexityOf"", ""String.replace()""); (""String.replace()"", ""hasComplexity"", ""O(N * M)"")"
You could create a variant of the TokenReplacingReader which can replace XML entities (e.g.,"(""TokenReplacingReader"", ""can replace"", ""XML entities"")"
"Additionally, since TokenReplacingReader is a java.io.Reader, and it gets its characters from a Reader itself, you can chain it with other java.io.Reader's or InputStreams which does other things (like unzipping, decrypting, converting from UTF-8, UTF-16 etc.)","(""TokenReplacingReader"", ""extends"", ""java.io.Reader""); (""TokenReplacingReader"", ""gets characters from"", ""Reader""); (""Reader"", ""chained with"", ""InputStreams""); (""InputStreams"", ""does"", ""unzipping""); (""InputStreams"", ""does"", ""decrypting""); (""InputStreams"", ""does"", ""converting from UTF-8""); (""InputStreams"", ""does"", ""converting from UTF-16"")"
Implementing a Java web crawler is a fun and challenging task often given in university programming classes.,
That way the thread listening for incoming requests spends as much time as possible in the serverSocket.accept() call.,"(""thread"", ""listening for"", ""incoming requests""); (""thread"", ""spends time in"", ""serverSocket.accept()""); (""serverSocket"", ""has method"", ""accept()"")"
That way the risk is minimized for clients being denied access to the server because the listening thread is not inside the accept() call.,"(""Thread"", ""is inside"", ""accept()""); (""accept()"", ""call of"", ""server""); (""client"", ""access"", ""server""); (""Thread"", ""listen to"", ""server""); (""server"", ""deny access to"", ""client""); (""Thread"", ""minimize risk for"", ""client"")"
"Here is the code for the WorkerRunnable class, which is passed to the worker thread constructor:","(""WorkerRunnable"", ""is passed to"", ""worker thread constructor""); (""WorkerRunnable"", ""is used by"", ""worker thread""); (""worker thread"", ""has constructor"", ""worker thread constructor""); (""WorkerRunnable"", ""is used in"", ""worker thread constructor"")"
"As mentioned earlier the more time the thread calling serverSocket.accept() spends inside this method call, the more responsive the server will be.","(""serverSocket"", ""has method"", ""accept()""); (""serverSocket.accept()"", ""called by"", ""thread""); (""thread"", ""calls"", ""serverSocket.accept()"")"
Only when the listening thread is inside the accept() call can clients connect to the server.,"(""Thread"", ""is inside"", ""accept()""); (""accept()"", ""call allows"", ""clients to connect""); (""clients"", ""connect to"", ""server""); (""server"", ""has"", ""accept()""); (""Thread"", ""makes"", ""accept()""); (""accept()"", ""is made by"", ""Thread"")"
Clients can only connect to the server while the server is inside the serverSocket.accept() method call.,"(""Client"", ""connects to"", ""Server""); (""Server"", ""is inside"", ""serverSocket.accept()""); (""serverSocket.accept()"", ""is method of"", ""ServerSocket"")"
"The longer time the listening thread spends outside the serverSocket.accept() call, the higher the probability that the client will be denied access to the server.","(""serverSocket"", ""has method"", ""accept()""); (""serverSocket.accept()"", ""called by"", ""listening thread""); (""listening thread"", ""spends time outside"", ""serverSocket.accept()""); (""client"", ""accesses"", ""server""); (""client"", ""denied access by"", ""server""); (""server"", ""denies access to"", ""client""); (""listening thread"", ""uses"", ""serverSocket"")"
That way the listening thread spends as little time as possible outside the serverSocket.accept() call.,"(""serverSocket"", ""has method"", ""accept()"")"
"For instance, if you process 1.000 requests concurrently and each request takes 1 second, then all requests will take 1.000 seconds to complete.",
"To use IText PDF API for Java you must first download the IText JAR file from the IText website, and include it on your application class path.","(""IText PDF API"", ""uses"", ""IText JAR file""); (""IText JAR file"", ""downloaded from"", ""IText website""); (""IText JAR file"", ""included in"", ""application class path""); (""IText PDF API"", ""included in"", ""application class path""); (""IText website"", ""provides"", ""IText JAR file"")"
"The com.itextpdf.text.Anchor class in IText represents an link, either to an external website, or internally in the document.","(""com.itextpdf.text.Anchor"", ""represents"", ""link""); (""com.itextpdf.text.Anchor"", ""located in"", ""IText""); (""com.itextpdf.text.Anchor"", ""links to"", ""external website""); (""com.itextpdf.text.Anchor"", ""links to"", ""document"")"
"The com.itextpdf.text.Chunk class in IText represents the smallest possible ""chunk"" of text.","(""com.itextpdf.text.Chunk"", ""is part of"", ""IText""); (""com.itextpdf.text.Chunk"", ""represents"", ""chunk of text"")"
"If you need to generate a PDF document from scratch, you will use the Document class.","(""Document"", ""used for"", ""generating PDF document""); (""Document"", ""is a"", ""class"")"
"You can specify fonts for most text objects (Chunk, Phrase, Paragraph etc.)","(""Chunk"", ""is_a"", ""text object""); (""Phrase"", ""is_a"", ""text object""); (""Paragraph"", ""is_a"", ""text object"")"
The com.itextpdf.text.Image is used to add images to IText PDF documents.,"(""com.itextpdf.text.Image"", ""used to add"", ""IText PDF documents""); (""com.itextpdf.text.Image"", ""is used in"", ""IText PDF documents""); (""IText PDF documents"", ""have images added by"", ""com.itextpdf.text.Image"")"
You set the absolute position of an image using the setAbsolutePosition() method.,"(""image"", ""uses"", ""setAbsolutePosition()""); (""setAbsolutePosition()"", ""called on"", ""image"")"
"If you already have a finished PDF, and just want to add a header, footer or watermark to it, IText provides the com.itextpdf.pdf.PdfStamper class.","(""com.itextpdf.pdf.PdfStamper"", ""provides"", ""IText"")"
You can set the alignment of the paragraph using the setAlignment() method.,"(""paragraph"", ""uses"", ""setAlignment()"")"
"You can write text as superscript or subscript using the Chunk class, and it's setTextRise() method.","(""Chunk"", ""hasMethod"", ""setTextRise()"")"
You can add tables to a PDF document using the com.itextpdf.text.PdfPTable class in IText.,"(""com.itextpdf.text.PdfPTable"", ""used in"", ""PDF document""); (""com.itextpdf.text.PdfPTable"", ""belongs to"", ""com.itextpdf.text""); (""PDF document"", ""contains"", ""com.itextpdf.text.PdfPTable"")"
"To add cells to the table you call the addCell() method, passing PdfPCell instances, or other IText objects like Paragraph etc.","(""PdfPCell"", ""instantiated by"", ""addCell()""); (""addCell()"", ""passes"", ""PdfPCell""); (""addCell()"", ""passes"", ""Paragraph""); (""IText"", ""has objects"", ""Paragraph""); (""IText"", ""has objects"", ""PdfPCell"")"
"You can set the column widths using the setWidths() method, like this:","(""setWidths()"", ""is method of"", ""unknown class"")"
"If you need a cell to span multiple columns you can do so using the setColspan() method, like this:","(""cell"", ""uses"", ""setColspan()"")"
"In text mode the settings of the added element (Phrase, Paragraph etc.)","("" Phrase"", ""is_a"", ""element ""); ("" Paragraph"", ""is_a"", ""element "")"
Content added via the PdfCell.addElement() method is considered composite mode content.,"(""PdfCell"", ""addElement"", ""composite mode content""); (""PdfCell"", ""hasMethod"", ""addElement()"")"
"You can set the default cell settings of new cells added, using the table.addCell() methods, like this:","(""table"", ""addCell"", ""cell"")"
The method setIndent() sets the indentation of the first paragraph in the cell.,"(""setIndent()"", ""sets indentation of"", ""first paragraph""); (""setIndent()"", ""is method of"", ""cell""); (""first paragraph"", ""is part of"", ""cell"")"
The method setFollowingIndent() sets the indentation of the following paragraphs in the cell.,"(""setFollowingIndent()"", ""sets"", ""indentation""); (""setFollowingIndent()"", ""is method of"", ""cell""); (""cell"", ""has method"", ""setFollowingIndent()"")"
The method setRightIndent() sets the right indentation of the cell content.,"(""setRightIndent()"", ""sets"", ""right indentation""); (""setRightIndent()"", ""belongs to"", ""cell content""); (""cell content"", ""has"", ""right indentation"")"
"If the cell is in composite mode, just set the leading on the element added, e.g.",
The second method call sets the leading to 0 points + 1.5 x font height.,
"You can set the rotation of the cell content using the setRotation() method, like this:","(""Cell"", ""hasMethod"", ""setRotation()"")"
"You can add underline and strikethrough text using the Chunk class, and its setUnderline() method.","(""Chunk"", ""hasMethod"", ""setUnderline()""); (""Chunk"", ""usesMethod"", ""setUnderline()""); (""setUnderline"", ""isMethodOf"", ""Chunk"")"
Quite often Java applications keep objects in data structures that contain java.util.ArrayList instances.,"(""Java"", ""uses"", ""java.util.ArrayList""); (""Java applications"", ""keep objects in"", ""data structures""); (""Data structures"", ""contain"", ""java.util.ArrayList"")"
This tutorial will also look at the performance of the OpenArrayList class - a class that mimics the java.util.ArrayList but designed with performance in mind.,"(""OpenArrayList"", ""mimics"", ""java.util.ArrayList""); (""OpenArrayList"", ""designed for"", ""performance""); (""java.util.ArrayList"", ""has alternative"", ""OpenArrayList"")"
Each element is obtained from the ArrayList instance using the get() method.,"(""ArrayList"", ""uses"", ""get()""); (""ArrayList"", ""has method"", ""get()""); (""get()"", ""is method of"", ""ArrayList"")"
The third way to iterate an ArrayList is to use an java.util.Iterator obtained from the ArrayList.,"(""ArrayList"", ""uses"", ""java.util.Iterator""); (""ArrayList"", ""obtained from"", ""java.util.Iterator""); (""ArrayList"", ""iterates with"", ""java.util.Iterator"")"
The benchmarks were executed using JDK 1.8.0_u60 on a Intel Core i7-4770 Haswell server which was doing nothing but the benchmarks.,"(""JDK"", ""executed_on"", ""Intel Core i7-4770 Haswell server""); (""JDK"", ""version"", ""1.8.0_u60""); (""Intel Core i7-4770 Haswell server"", ""processed"", ""benchmarks"")"
"You can also see that iterating an ArrayList using a standard Java for loop with a counter, and obtaining each element by calling the ArrayList get() method is about 10% faster for an ArrayList with 10 elements, and around 12,5% faster when the ArrayList contains 100 elements.","(""ArrayList"", ""uses"", ""for loop""); (""ArrayList"", ""has method"", ""get()""); (""ArrayList"", ""contains"", ""elements""); (""for loop"", ""iterates"", ""ArrayList""); (""ArrayList"", ""has size"", ""10 elements""); (""ArrayList"", ""has size"", ""100 elements""); (""get()"", ""is called on"", ""ArrayList"")"
The OpenArrayList class is a very simple imitation of the ArrayList which I have implemented to see if it could iterate a collection of elements faster than an ArrayList .,"(""OpenArrayList"", ""is imitation of"", ""ArrayList""); (""OpenArrayList"", ""iterates"", ""collection""); (""ArrayList"", ""is iterated by"", ""OpenArrayList"")"
"This should be a tiny bit faster than calling the ArrayList get() method, although the JVM could optimize the get() method call away.","(""ArrayList"", ""has method"", ""get()"")"
Another advantage of making the elements array public is that you can write to it or copy from it using System.arraycopy() which is very fast.,"(""System"", ""uses"", ""System.arraycopy()""); (""System"", ""hasMethod"", ""arraycopy()"")"
The fact that the performance is so close is probably a sign that the JVM has optimized the get() call away.,"(""JVM"", ""has optimized"", ""get() call""); (""JVM"", ""optimizes"", ""get()""); (""JVM"", ""optimizes"", ""call"")"
"As you can see, the readMyData() method returns a MyData object.","(""readMyData()"", ""returns"", ""MyData"")"
What is worth noting about this read pattern is that every time you call the readMyData() method a new MyData object is returned.,"(""readMyData()"", ""returns"", ""MyData""); (""readMyData()"", ""called from"", ""unknown""); (""MyData"", ""instantiated by"", ""readMyData()"")"
If the readMyData() method is called frequently that will lead to a lot of MyData objects being created.,"(""readMyData()"", ""called frequently"", ""MyData""); (""MyData"", ""being created"", ""readMyData()"")"
Here is how the earlier readMyData() method would look using the read-into-existing pattern:,"(""readMyData()"", ""uses"", ""read-into-existing pattern"")"
"It is now up to the caller of the readMyData() method to decide if an existing MyData instance should be reused, or if a new instance should be created.","(""readMyData()"", ""is method of"", ""MyData""); (""MyData"", ""has method"", ""readMyData()""); (""readMyData()"", ""called by"", ""caller"")"
Reusing an object also means that the chance the object is located in the CPU cache is much higher than when you create a new object for each call to the readMyData() method.,"(""Object"", ""is located in"", ""CPU cache""); (""Object"", ""is reused by"", ""readMyData()""); (""readMyData()"", ""creates"", ""Object"")"
To change the previous example code to read data directly from the underlying source we need to change the implementation of the MyData class:,"(""MyData"", ""change implementation of"", ""MyData""); (""MyData"", ""has implementation"", ""underlying source""); (""underlying source"", ""provides data to"", ""MyData"")"
"To use the MyData class in its new variation, you will use code like this:","(""MyData"", ""used in"", ""code""); (""MyData"", ""has variation"", ""new variation""); (""Code"", ""uses"", ""MyData"")"
Just call setSource() when you need to read data out of a new byte array.,"(""setSource()"", ""called by"", ""user code""); (""setSource()"", ""reads from"", ""byte array"")"
"Third, only if you actually call both getVal1() and getVal2() will the corresponding data be read out of the underlying byte array.","(""getVal1()"", ""called with"", ""getVal2()""); (""getVal1()"", ""reads from"", ""byte array""); (""getVal2()"", ""reads from"", ""byte array"")"
"Assuming that each MyData object consists of 2 bytes from the underlying source, here is how the MyData class would look with a navigation method added:","(""MyData"", ""consists of"", ""bytes""); (""MyData"", ""has"", ""navigation method""); (""MyData"", ""is a"", ""class"")"
The first change is the that the setSource() method now takes an extra parameter called offset.,"(""setSource()"", ""takes"", ""offset""); (""setSource()"", ""has"", ""parameter""); (""setSource()"", ""calledWith"", ""offset"")"
The second change is that the getVal1() and getVal2() methods now use the value of the internal offset variable as index into the source array when reading values out.,"(""getVal1()"", ""uses"", ""internal offset variable""); (""getVal2()"", ""uses"", ""internal offset variable""); (""internal offset variable"", ""is used as index by"", ""getVal1()""); (""internal offset variable"", ""is used as index by"", ""getVal2()""); (""getVal1()"", ""reads from"", ""source array""); (""getVal2()"", ""reads from"", ""source array"")"
"The next() method increments the internal offset variable by 2, so that the offset variable points to the next record in the array.","(""next()"", ""increments"", ""internal offset variable""); (""internal offset variable"", ""points to"", ""next record""); (""next()"", ""updates"", ""internal offset variable""); (""internal offset variable"", ""is incremented by"", ""2"")"
The fourth change is the addition of the hasNext() method which returns true if the source byte array has more records (bytes) in it.,"(""hasNext()"", ""is method of"", ""source byte array""); (""hasNext()"", ""returns"", ""true""); (""source byte array"", ""has method"", ""hasNext()"")"
"As you can see, using the MyData class in the navigator pattern implementation is pretty straightforward.","(""MyData"", ""used in"", ""navigator pattern""); (""MyData"", ""implementation of"", ""navigator pattern""); (""navigator pattern"", ""uses"", ""MyData"")"
"Additionally, if your server works on many tasks at the same time (e.g incoming HTTP requests), the other CPUs in your server may already be busy working on their own tasks.","(""Server"", ""works on"", ""Tasks""); (""Server"", ""has"", ""CPUs""); (""CPUs"", ""work on"", ""Tasks""); (""HTTP requests"", ""are handled by"", ""Server""); (""CPUs"", ""may be busy with"", ""Tasks"")"
"My own experiences come from from a mix of Java performance experiments, as well as the design and development of VStack.co - a fully hosted application backend which I have cofounded with WorpCloud Ltd.","(""VStack.co"", ""cofounded by"", ""WorpCloud Ltd""); (""VStack.co"", ""designed by"", ""unknown""); (""VStack.co"", ""developed by"", ""unknown""); (""Java"", ""used for"", ""performance experiments""); (""VStack.co"", ""is a"", ""application backend"")"
"The Java ArrayList class only works for objects - not for primitive types (byte, int, long etc).","(""ArrayList"", ""works for"", ""objects""); (""ArrayList"", ""does not work for"", ""primitive types""); (""primitive types"", ""include"", ""byte""); (""primitive types"", ""include"", ""int""); (""primitive types"", ""include"", ""long"")"
The code consist of 3 Java classes and 2 unit tests.,"(""Java"", ""consist of"", ""classes""); (""classes"", ""tested by"", ""unit tests""); (""Java"", ""used for"", ""unit tests"")"
100.000 x 1MB = 100GB (approximately - not precisely - but you get the picture).,
"Note, that in languages with built-in garbage collection (like Java, C# etc.)","(""Java"", ""has feature"", ""garbage collection""); (""C#"", ""has feature"", ""garbage collection"")"
Even at 4GB (1.000.000 x 4KB) modern servers should be able to handle it.,
"Additionally, if you use a small block size, you may have to expand blocks more often than if you use e.g.",
"To obtain a ResizableArray instance, call the ResizableArrayBuffer's getArray() method, like this:","(""ResizableArray"", ""obtained from"", ""ResizableArrayBuffer.getArray()""); (""ResizableArrayBuffer.getArray()"", ""returns"", ""ResizableArray""); (""ResizableArrayBuffer"", ""has method"", ""ResizableArrayBuffer.getArray()"")"
The ResizableArray class in the GitHub repository only contains a single write() method which takes a ByteBuffer as parameter.,"(""ResizableArray"", ""contains"", ""write()""); (""write()"", ""takes"", ""ByteBuffer""); (""ResizableArray"", ""is in"", ""GitHub repository"")"
"It should be pretty easy to add more write() methods yourself, though.","(""write()"", ""is method of"", ""unspecified class"")"
The value returned by write() is the number of bytes copied from the ByteBuffer.,"(""ByteBuffer"", ""write"", ""bytes""); (""write"", ""returns"", ""number of bytes""); (""ByteBuffer"", ""has method"", ""write()"")"
"If the ResizableArray cannot contain all the data in the ByteBuffer after expanding itself to the max size, the write() method will return -1 and no data will have been copied at all!","(""ResizableArray"", ""cannot contain"", ""data""); (""ResizableArray"", ""has method"", ""write()""); (""write()"", ""returns"", ""-1""); (""ResizableArray"", ""expands to"", ""max size""); (""ByteBuffer"", ""contains"", ""data""); (""write()"", ""copies"", ""data"")"
"You do so simply by calling the free() method on the ResizableArray, like this:","(""ResizableArray"", ""has method"", ""free()"")"
"Calling free() takes care of returning the used block to the correct block queue, regardless of the size of the block allocated to the ResizableArray.","(""ResizableArray"", ""uses"", ""free()""); (""free()"", ""returns to"", ""block queue""); (""ResizableArray"", ""allocated from"", ""block queue"")"
I have implemented batch mode put() and take() operations for both ring buffer implementations.,"(""RingBuffer"", ""hasOperation"", ""put()""); (""RingBuffer"", ""hasOperation"", ""take()""); (""RingBuffer"", ""implements"", ""batch mode""); (""put()"", ""isOperationOf"", ""RingBuffer""); (""take()"", ""isOperationOf"", ""RingBuffer"")"
My benchmarks showed that batch put() and take() operations provides up to 4 times the throughput of putting and taking a single element at a time.,"(""put()"", ""provides"", ""throughput""); (""take()"", ""provides"", ""throughput""); (""batch put()"", ""compares"", ""single element put()""); (""batch take()"", ""compares"", ""single element take()"")"
Here is an implementation of the ring buffer that uses a fill count including the batch put() and take() operations.,"(""rings buffer"", ""uses"", ""fill count""); (""batch"", ""has operation"", ""put()""); (""batch"", ""has operation"", ""take()"")"
"Here is an implementation of the ring buffer that uses a read position and flip marker, including the batch put() and take() operations.","(""ring buffer"", ""uses"", ""read position""); (""ring buffer"", ""uses"", ""flip marker""); (""ring buffer"", ""includes"", ""batch put()""); (""ring buffer"", ""includes"", ""batch take()"")"
"The JMH Maven archetype will generate a new Java project with a single, example benchmark Java class, and a Maven pom.xml file.","(""JMH Maven archetype"", ""generates"", ""Java project""); (""JMH Maven archetype"", ""includes"", ""benchmark Java class""); (""JMH Maven archetype"", ""includes"", ""Maven pom.xml file""); (""Java project"", ""contains"", ""benchmark Java class""); (""Java project"", ""contains"", ""Maven pom.xml file""); (""Maven pom.xml file"", ""belongs to"", ""Java project""); (""Maven pom.xml file"", ""is part of"", ""JMH Maven archetype""); (""benchmark Java class"", ""belongs to"", ""Java project""); (""benchmark Java class"", ""is part of"", ""JMH Maven archetype"")"
The Maven pom.xml file contains the correct dependencies to compile and build your JMH microbenchmark suite.,"(""Maven"", ""contains"", ""pom.xml""); (""pom.xml"", ""contains"", ""dependencies""); (""dependencies"", ""used to"", ""compile""); (""dependencies"", ""used to"", ""build""); (""JMH"", ""has"", ""microbenchmark suite""); (""pom.xml"", ""used to"", ""compile JMH""); (""pom.xml"", ""used to"", ""build JMH"")"
"It is time to write your first JMH benchmark class, or at least see how it is done.","(""JMH"", ""has"", ""benchmark class""); (""JMH benchmark class"", ""is written in"", ""Java""); (""JMH"", ""includes"", ""benchmark"")"
The generated MyBenchmark class is a JMH class template which you can use to implement your JMH benchmarks.,"(""MyBenchmark"", ""is a"", ""JMH""); (""MyBenchmark"", ""uses"", ""JMH class template"")"
"You can either implement your benchmarks directly in the generated MyBenchmark class, or create a new class in the same Java package.","(""MyBenchmark"", ""is in"", ""Java package""); (""MyBenchmark"", ""has"", ""class""); (""Java package"", ""contains"", ""MyBenchmark""); (""Java package"", ""has"", ""class"")"
To make it easy for you to write your first JMH benchmark I will just use the generated class in this example.,"(""JMH"", ""uses"", ""benchmark""); (""benchmark"", ""is written in"", ""class""); (""class"", ""is generated by"", ""JMH"")"
You can put the code you want to measure inside the testMethod() method body.,"(""testMethod()"", ""has method body"", ""code""); (""testMethod()"", ""is part of"", ""test class""); (""code"", ""is placed inside"", ""testMethod()"")"
"For now, just imagine that the testMethod() body actually contained a good benchmark implementation.","(""testMethod"", ""contained in"", ""implementation"")"
"When you build your JMH benchmarks, Maven will always generate a JAR file named benchmarks.jar in the target directory (Maven's standard output directory).","(""Maven"", ""generates"", ""benchmarks.jar""); (""Maven"", ""uses"", ""target directory""); (""benchmarks.jar"", ""located in"", ""target directory"")"
It contains your compiled benchmark classes as well as all JMH classes needed to run the benchmark.,"(""benchmark classes"", ""contains"", ""compiled benchmark classes""); (""compiled benchmark classes"", ""are part of"", ""benchmark""); (""JMH classes"", ""are needed for"", ""run the benchmark""); (""benchmark"", ""runs with"", ""JMH classes"")"
"If your benchmarks has any external dependencies (JAR files from other projects needed to run your benchmarks), declare these dependencies inside the Maven pom.xml, and they will be included in the benchmarks.jar too.","(""Maven"", ""has"", ""pom.xml""); (""pom.xml"", ""declares"", ""dependencies""); (""dependencies"", ""areIncludedIn"", ""benchmarks.jar""); (""benchmarks.jar"", ""includes"", ""external dependencies""); (""Maven"", ""generates"", ""benchmarks.jar"")"
"Since benchmarks.jar is fully self contained, you can copy that JAR file to another computer to run your JMH benchmarks on that computer.",
This means that you want the output shown using the time unit minutes (e.g.,
"State variables are declared in special state classes, and an instance of that state class can then be provided as parameter to the benchmark method.","(""State variables"", ""declared in"", ""state classes""); (""state classes"", ""instance of"", ""state class""); (""state class"", ""provided as parameter to"", ""benchmark method"")"
In this example I have added a nested static class named MyState.,"(""MyState"", ""is a"", ""nested static class"")"
Notice that the testMethod() benchmark method now takes an instance of MyState as parameter.,"(""testMethod()"", ""takes"", ""MyState""); (""MyState"", ""passed to"", ""testMethod()""); (""testMethod()"", ""is a method of"", ""unspecified class"")"
Notice also that the testMethod() body has now been changed to use the MyState object when performing its sum calculation.,"(""testMethod()"", ""uses"", ""MyState"")"
Notice the two new methods in the MyState class named doSetup() and doTearDown().,"(""MyState"", ""has method"", ""doSetup()""); (""MyState"", ""has method"", ""doTearDown()"")"
"If you have any doubts about when a setup or tear down method is called, try inserting a System.out.println() statement in the method.","(""setup"", ""is called during"", ""test""); (""tear down method"", ""is called during"", ""test""); (""setup"", ""has"", ""System.out.println()""); (""tear down method"", ""has"", ""System.out.println()""); (""System.out.println()"", ""is used in"", ""setup""); (""System.out.println()"", ""is used in"", ""tear down method"")"
"If your benchmark method is calculating multiple values that might end up being eliminated as dead code, you can either combine the two values into a single, and return that value (e.g.",
Notice how the testMethod() benchmark method now takes a Blackhole object as parameter.,"(""testMethod()"", ""takes"", ""Blackhole""); (""Blackhole"", ""is passed to"", ""testMethod()""); (""testMethod()"", ""is a"", ""benchmark method"")"
Notice also how the calculated sum in the sum variable is now passed to the consume() method of the Blackhole instance.,"(""sum"", ""passed to"", ""consume()""); (""consume()"", ""method of"", ""Blackhole"")"
"If your benchmark method produces multiple results you can pass each of these results to a black hole, meaning calling consume() on the Blackhole instance for each value.","(""benchmark method"", ""produces"", ""results""); (""Blackhole"", ""has method"", ""consume()""); (""benchmark method"", ""calls"", ""consume()""); (""results"", ""passed to"", ""Blackhole""); (""Blackhole instance"", ""has method"", ""consume()"")"
"The JVM could even continue and never call the testMethod() because it knows it always returns 3, and just inline the constant 3 wherever the testMethod() was to be called.","(""JVM"", ""calls"", ""testMethod()""); (""testMethod()"", ""returns"", ""3""); (""JVM"", ""inlines"", ""3"")"
Sometimes a lot of time is even spent just allocating and freeing memory (e.g.,
"When you control object allocation, deallocation and reallocation you can make limits like e.g.",
having a maximum of 10.000 messages in memory at a time.,
"The batch size can thus vary from 1 to a maximum upper limit set by the system, e.g.",
"To achieve lower latency, yet allowing for micro batching to happen, you can loop over the input channels (inbound network connections, directories etc.)",
Therefore it can be beneficial to batch up data sent outside a process to minimize the overhead per data block (e.g.,
"Instead of traversing the whole data structure to serve just one ""request"" (task, message etc.)","(""data structure"", ""traversed by"", ""request""); (""request"", ""served by"", ""data structure""); (""data structure"", ""serves"", ""request"")"
Notice how two different DAO's were called from inside the control's execute() method.,"(""Control"", ""has method"", ""execute()""); (""execute()"", ""calls"", ""DAO"")"
"To make this happen you need to obtain a database connection (or equivalent object) inside the Control.execute() method, and pass this connection (or other object) to each DAO.","(""Control"", ""execute"", ""DAO""); (""Control.execute()"", ""uses"", ""database connection""); (""DAO"", ""uses"", ""database connection""); (""Control.execute()"", ""obtains"", ""database connection""); (""DAO"", ""receives"", ""database connection"")"
"Well, you could if you call a setConnection() method on them afterwards.","(""setConnection()"", ""is a method of"", ""unknown entity"")"
The DaoManager is a class that you put in between the Control and the DAO's.,"(""DaoManager"", ""isBetween"", ""Control""); (""DaoManager"", ""isBetween"", ""DAO's""); (""DaoManager"", ""putBetween"", ""Control""); (""DaoManager"", ""putBetween"", ""DAO's""); (""Control"", ""hasDaoManager"", ""DaoManager""); (""DAO's"", ""hasDaoManager"", ""DaoManager"")"
Once the DaoManager.executeAndClose() method finishes the database connection inside the DaoManager is closed.,"(""DaoManager"", ""hasMethod"", ""executeAndClose()""); (""DaoManager"", ""has"", ""database connection""); (""DaoManager.executeAndClose()"", ""closes"", ""database connection""); (""database connection"", ""isInside"", ""DaoManager"")"
"As you can see from the code example in the previous section, the scope of the connection when managed by the DaoManager.executeAndClose() is the boundaries of the executeAndClose() method.","(""DaoManager"", ""executeAndClose"", ""DaoManager.executeAndClose()""); (""DaoManager.executeAndClose"", ""managed by"", ""connection""); (""connection"", ""scope defined by"", ""DaoManager.executeAndClose""); (""DaoManager.executeAndClose"", ""has boundary"", ""method""); (""DaoManager"", ""has method"", ""DaoManager.executeAndClose"")"
This could be the case in a desktop application if each control is registered independently as listeners on e.g.,
It is the DaoManager's executeAndClose() method that demarcates the life span of the underlying connection.,"(""DaoManager"", ""has method"", ""executeAndClose()""); (""executeAndClose()"", ""demarcates life span of"", ""connection""); (""DaoManager"", ""manages"", ""connection"")"
"If you call this method from each control's execute() method (or whatever the central execution method in your controls is called), each control will open and close a connection separately.","(""control"", ""has method"", ""execute()""); (""control"", ""calls method"", ""execute()""); (""execute()"", ""opens"", ""connection""); (""execute()"", ""closes"", ""connection""); (""control"", ""opens"", ""connection""); (""control"", ""closes"", ""connection"")"
The ScopingDataSource will be moved to Butterfly Persistence from around version 5.2.0 or 5.4.0 which will be released in 2009.,"(""ScopingDataSource"", ""will be moved to"", ""Butterfly Persistence""); (""Butterfly Persistence"", ""will be released in"", ""2009""); (""ScopingDataSource"", ""has version"", ""5.2.0""); (""ScopingDataSource"", ""has version"", ""5.4.0"")"
The ScopingDataSource is an implementation of the standard Java interface javax.sql.DataSource.,"(""ScopingDataSource"", ""implements"", ""javax.sql.DataSource"")"
"Once this method is called, whenever the tread that called this method calls the ScopingDataSource.getConnection() method, the same connection instance is returned.","(""ScopingDataSource"", ""hasMethod"", ""getConnection()""); (""Thread"", ""callsMethod"", ""ScopingDataSource.getConnection()""); (""ScopingDataSource.getConnection()"", ""returns"", ""Connection"")"
"This ScopingConnection ignores all calls to the close() method, so the underlying connection can be reused.","(""ScopingConnection"", ""ignores"", ""close()""); (""ScopingConnection"", ""has"", ""underlying connection""); (""underlying connection"", ""can be reused by"", ""ScopingConnection"")"
"When you are ready to close the connection your control calls the ScopingDataSource.endConnectionScope(), and the currently open connection (if any) is closed.","(""ScopingDataSource"", ""calls"", ""endConnectionScope()""); (""ScopingDataSource"", ""has method"", ""endConnectionScope()""); (""ScopingDataSource"", ""closes"", ""connection""); (""connection"", ""is closed by"", ""ScopingDataSource""); (""connection"", ""is managed by"", ""ScopingDataSource""); (""ScopingDataSource"", ""manages"", ""connection""); (""ScopingDataSource"", ""has"", ""connection""); (""control"", ""calls"", ""ScopingDataSource.endConnectionScope()""); (""control"", ""uses"", ""ScopingDataSource""); (""ScopingDataSource"", ""is used by"", ""control""); (""ScopingDataSource"", ""provides"", ""endConnectionScope()""); (""control"", ""interacts with"", ""ScopingDataSource"")"
"From here on the ScopingDataSource behaves just like a regular DataSource, returning a new Connection for every call to getConnection().","(""ScopingDataSource"", ""behaves like"", ""DataSource""); (""ScopingDataSource"", ""returns"", ""Connection""); (""DataSource"", ""returns"", ""Connection""); (""ScopingDataSource"", ""has method"", ""getConnection()""); (""DataSource"", ""has method"", ""getConnection()"")"
"The calls to beginConnectionScope() and endConnectionScope() do not have to be located within the same method, nor within the same class.","(""beginConnectionScope()"", ""located within"", ""method""); (""beginConnectionScope()"", ""located within"", ""class""); (""endConnectionScope()"", ""located within"", ""method""); (""endConnectionScope()"", ""located within"", ""class"")"
"You can just extend the DBControlBase and override the doExecute() method, then all connection scoping is done for you.","(""DBControlBase"", ""extend"", ""doExecute""); (""DBControlBase"", ""has method"", ""doExecute()""); (""doExecute"", ""overridden by"", ""DBControlBase"")"
"They can be called outside the Control.execute() method too, or inside a parent control.","(""Control"", ""hasMethod"", ""execute()""); (""Control"", ""contains"", ""parent control""); (""Control.execute()"", ""canBeCalledFrom"", ""outside""); (""Control.execute()"", ""canBeCalledFrom"", ""parent control"")"
"If your Control class implements an interface, you can implement a Dynamic Proxy which implements the same interface.","(""Control"", ""implements"", ""interface""); (""Dynamic Proxy"", ""implements"", ""interface""); (""Control"", ""uses"", ""Dynamic Proxy"")"
"When the execute() method is called on the control interface, this dynamic proxy will call the beginConnectionScope(), then call your controls execute() method, and finally the endConnectionScope().","(""control interface"", ""has method"", ""execute()""); (""control interface"", ""uses"", ""dynamic proxy""); (""dynamic proxy"", ""calls"", ""beginConnectionScope()""); (""dynamic proxy"", ""calls"", ""execute()""); (""dynamic proxy"", ""calls"", ""endConnectionScope()""); (""execute()"", ""is called by"", ""dynamic proxy""); (""beginConnectionScope()"", ""is called by"", ""dynamic proxy""); (""endConnectionScope()"", ""is called by"", ""dynamic proxy"")"
The only difference is that you call beginTransactionScope() and endTransactionScope() instead.,"(""beginTransactionScope"", ""called by"", ""user""); (""endTransactionScope"", ""called by"", ""user""); (""beginTransactionScope"", ""related to"", ""endTransactionScope"")"
"When a connection is obtained from the ScopingDataSource while inside a transaction scope, connection.setAutoCommit(false) is called.","(""ScopingDataSource"", ""obtains"", ""connection""); (""connection"", ""has method"", ""setAutoCommit()""); (""transaction scope"", ""uses"", ""ScopingDataSource""); (""connection"", ""has method"", ""setAutoCommit(false)"")"
"If an exception is thrown before the endTransactionScope() method is called, you should catch that exception and call abortTransactionScope(Exception) with that exception.","(""endTransactionScope"", ""called before"", ""abortTransactionScope""); (""abortTransactionScope"", ""called with"", ""Exception""); (""Exception"", ""thrown before"", ""endTransactionScope""); (""abortTransactionScope"", ""alternative to"", ""endTransactionScope""); (""exception"", ""passed to"", ""abortTransactionScope""); (""endTransactionScope"", ""not called due to"", ""Exception"")"
The first problem you run into when designing DAO classes is connection scoping.,"(""DAO"", ""has problem"", ""connection scoping""); (""DAO"", ""is designed with"", ""connection scoping""); (""connection scoping"", ""is problem of"", ""DAO"")"
A naive implementation of a DAO class using JDBC to target a relational database might look like below (at least I have designed DAO's like this in the past).,
Notice how the readPerson() method opens its own connection and closes it again once it is done.,"(""readPerson()"", ""opens"", ""connection""); (""readPerson()"", ""closes"", ""connection"")"
You might also be able to hide connection closing from the domain logic by adding a close() method to the DAO.,"(""DAO"", ""has method"", ""close()"")"
But somewhere in the domain logic you would have to call that close() method.,"(""close()"", ""is method of"", ""unknown class"")"
The method call daoFactory.beginConnectionScope() marks the beginning of a connection scope.,"(""daoFactory"", ""has method"", ""beginConnectionScope()"")"
The method call daoFactory.endConnectionScope() ends the current connection scope and closes the connection associated with the scope.,"(""daoFactory"", ""hasMethod"", ""endConnectionScope()""); (""daoFactory.endConnectionScope()"", ""ends"", ""connection scope""); (""connection scope"", ""hasConnection"", ""connection""); (""daoFactory.endConnectionScope()"", ""closes"", ""connection"")"
This way neither of the DAO's need to have close() methods.,"(""DAO"", ""need to have"", ""close() methods""); (""DAO"", ""have"", ""close() methods"")"
The methods beginTransaction() and endTransaction() mark the beginning and end of the transaction.,"(""beginTransaction()"", ""is part of"", ""transaction""); (""endTransaction()"", ""is part of"", ""transaction""); (""beginTransaction()"", ""marks beginning of"", ""transaction""); (""endTransaction()"", ""marks end of"", ""transaction"")"
The beginTransaction() method will call connection.setAutoCommit(false) for the connection associated with the transaction scope.,"(""beginTransaction()"", ""calls"", ""setAutoCommit(false)""); (""beginTransaction()"", ""associated with"", ""transaction scope""); (""connection"", ""has method"", ""setAutoCommit(false)""); (""beginTransaction()"", ""uses"", ""connection"")"
The endTransaction() method will attempt to commit the transaction and call setAutoCommit(false) again.,"(""endTransaction"", ""will attempt to commit the transaction and call"", ""setAutoCommit""); (""endTransaction"", ""call"", ""setAutoCommit""); (""transaction"", ""will be committed by"", ""endTransaction""); (""setAutoCommit"", ""will be called by"", ""endTransaction""); (""endTransaction"", ""will call"", ""setAutoCommit""); (""setAutoCommit"", ""is set to false by"", ""endTransaction"")"
Notice the new method call in the catch-block of the transaction scope: daoFactory.abortTransaction(e).,"(""daoFactory"", ""call method"", ""abortTransaction""); (""abortTransaction"", ""is called with"", ""e""); (""daoFactory"", ""has method"", ""abortTransaction"")"
This method call rolls the transaction back if an exception is thrown from any of the dao methods or from endTransaction().,"(""dao"", ""hasMethod"", ""method""); (""dao"", ""throwsException"", ""exception""); (""transaction"", ""hasMethod"", ""endTransaction()""); (""transaction"", ""rollsBack"", ""transaction""); (""method"", ""throwsException"", ""exception""); (""exception"", ""thrownFrom"", ""dao""); (""exception"", ""thrownFrom"", ""endTransaction()""); (""transaction"", ""calledBy"", ""method""); (""endTransaction()"", ""rollsBack"", ""transaction"")"
"The DAO layer usually consists of a smaller set of classes, than the number of domain logic classes that uses it.","(""DAO layer"", ""consists of"", ""classes""); (""DAO layer"", ""used by"", ""domain logic classes""); (""domain logic classes"", ""uses"", ""DAO layer"")"
"It is also a somewhat more controlled operation, since you can search for all DAO classes, and make sure they are changed to use the new persistence mechanism.","(""DAO"", ""uses"", ""persistence mechanism""); (""DAO classes"", ""changed to use"", ""new persistence mechanism""); (""DAO classes"", ""search for"", ""all DAO classes"")"
"To solve the problems mentioned earlier, you can move some of the code to a DaoManager class.","(""DaoManager"", ""moved to"", ""code"")"
Notice that the getPersonDao() method isn't synchronized even though it returns a kind of singleton.,"(""getPersonDao()"", ""returns"", ""singleton"")"
"Rather than implementing a close() method in the DaoManager class, a template method will be added called executeAndClose().","(""DaoManager"", ""hasMethod"", ""executeAndClose()""); (""DaoManager"", ""hasMethod"", ""close()"")"
This instance then has it's execute() method invoked with the DaoManager itself as parameter.,"(""DaoManager"", ""has method"", ""execute()""); (""DaoManager"", ""invokes method"", ""execute()""); (""execute()"", ""is invoked with"", ""DaoManager"")"
Now the scope of the connection is marked by the scope of the method call executeAndClose().,"(""executeAndClose()"", ""is called by"", ""connection""); (""connection"", ""has scope marked by"", ""executeAndClose()""); (""executeAndClose()"", ""marks scope of"", ""connection"")"
"Any exception handling related to the connection.close() call can be hidden away inside the executeAndClose() method, and reused throughout the application.","(""connection"", ""has method"", ""close()""); (""executeAndClose"", ""handles exception of"", ""connection.close()""); (""executeAndClose"", ""is method of"", ""unspecified class""); (""connection"", ""is used by"", ""executeAndClose()""); (""executeAndClose"", ""is reused in"", ""application"")"
You can add a transaction() method similar to the executeAndClose() method which takes care of transaction management.,"(""transaction()"", ""similar to"", ""executeAndClose()""); (""transaction()"", ""takes care of"", ""transaction management""); (""executeAndClose()"", ""takes care of"", ""transaction management"")"
"For instance, if both commit() and rollback() throws exceptions, both of these exception are not properly preserved or handled.","(""commit()"", ""throws"", ""exceptions""); (""rollback()"", ""throws"", ""exceptions"")"
Using the transaction() method is analogous to using the executeAndClose() method:,"(""transaction()"", ""is analogous to"", ""executeAndClose()"")"
This could be done by wrapping the call to transaction() inside the call to executeAndClose().,"(""transaction"", ""inside"", ""executeAndClose""); (""executeAndClose"", ""wraps"", ""transaction"")"
"As you can see a DaoManager class can solve the problems of marking both connection life span and transaction boundaries, and automatically open and close connections and commit / rollback transactions.","(""DaoManager"", ""can solve problems of"", ""connection life span""); (""DaoManager"", ""can solve problems of"", ""transaction boundaries""); (""DaoManager"", ""can automatically"", ""open connections""); (""DaoManager"", ""can automatically"", ""close connections""); (""DaoManager"", ""can automatically"", ""commit transactions""); (""DaoManager"", ""can automatically"", ""rollback transactions""); (""DaoManager"", ""marks"", ""connection life span""); (""DaoManager"", ""marks"", ""transaction boundaries"")"
"If you implement a base event listener class that all event listeners (or actions, or whatever your framework calls them) extend, you can put the DaoManager code in that class (or a subclass of the base class).","(""base event listener class"", ""extends"", ""event listeners""); (""base event listener class"", ""has"", ""DaoManager code""); (""event listeners"", ""extend"", ""base event listener class"")"
Here is an example of a subclass that executes the persistence code marked in bold in the first code box in this section:,
Now your domain logic class only contains the persistence code that is actually interesting.,"(""domain logic class"", ""contains"", ""persistence code"")"
It may not always be possible or feasible to implement such a persistence action base class.,"(""persistence action"", ""base class"", ""class"")"
It would be tempting to put that validation code inside the doPersistenceAction() method.,"(""doPersistenceAction"", ""inside"", ""validation code"")"
"But remember, a connection has been opened already when the DaoManager is instantiated, which happens before the doPersistenceAction() method is called.","(""DaoManager"", ""is instantiated before"", ""doPersistenceAction()""); (""doPersistenceAction()"", ""is called after"", ""DaoManager""); (""DaoManager"", ""opens"", ""connection"")"
"Furthermore, if the validation fails and aborts the doPersistenceAction() method call, you have opened a connection without ever using it.","(""doPersistenceAction"", ""calls"", ""method""); (""connection"", ""is opened by"", ""doPersistenceAction""); (""validation"", ""fails and aborts"", ""doPersistenceAction"")"
"If you are using a persistence API you will inject whatever class you obtain connections or their equivalents from (sessions in Hibernate, IDaos in Butterfly Persistence).","(""persistence API"", ""uses"", ""connections""); (""persistence API"", ""uses"", ""sessions""); (""persistence API"", ""uses"", ""IDaos""); (""connections"", ""obtained from"", ""class""); (""sessions"", ""obtained from"", ""Hibernate""); (""IDaos"", ""obtained from"", ""Butterfly Persistence"")"
"This is done to avoid obtaining the connection before the DaoCommand.execute() method is called, to postpone obtaining the connection as much as possible.","(""DaoCommand"", ""hasMethod"", ""execute()"")"
"Inside the DaoCommand.execute() method the getPersonDaoTx() will be called, and then getConnectionTx() will be called, and then connection.setAutoCommit(false) will be called at that time.","(""DaoCommand"", ""hasMethod"", ""execute()""); (""execute()"", ""calls"", ""getPersonDaoTx()""); (""getPersonDaoTx()"", ""calls"", ""getConnectionTx()""); (""getConnectionTx()"", ""calls"", ""setAutoCommit()""); (""connection"", ""hasMethod"", ""setAutoCommit()"")"
"After this code is executed, you can now access the cookies in the cookieMap using the cookie names as keys (cookieMap.get(""cookieName"")).","(""cookieMap"", ""get"", ""cookieName"")"
"Second, it sets the expiration to 24 hours using the setMaxAge() method.","(""setMaxAge()"", ""method of"", ""setMaxAge() parent class""); (""setMaxAge()"", ""sets"", ""expiration""); (""expiration"", ""has value"", ""24 hours"")"
"Cookies are most often used to store user specific information, like e.g.",
The browser includes the Accept-Encoding HTTP header in requests sent to an HTTP server (e.g.,
That class is mapped to a set of URL's in the web.xml file.,"(""class"", ""is mapped to"", ""web.xml file""); (""class"", ""is associated with"", ""URL's""); (""web.xml file"", ""contains"", ""URL's""); (""class"", ""is configured in"", ""web.xml file"")"
"It does so by using a GZIPOutputStream internally, which is a standard Java class.","(""GZIPOutputStream"", ""isUsedBy"", ""Java""); (""GZIPOutputStream"", ""isA"", ""JavaClass"")"
Remember to replace the class name with the fully qualified name of your own GZip Servlet filter class.,"(""GZip Servlet"", ""has class name"", ""fully qualified name""); (""fully qualified name"", ""of"", ""GZip Servlet filter class""); (""GZip Servlet filter class"", ""has"", ""fully qualified name"")"
"In general, If no header exists with the name passed to getHeader(), null is returned.","(""getHeader()"", ""has parameter"", ""name""); (""getHeader()"", ""returns"", ""null"")"
"NOTE: You will have to call this method before calling any getParameter() method, because calling the getParameter() method on an HTTP POST request will cause the servlet engine to parse the HTTP request body for parameters.","(""getParameter()"", ""called after"", ""this method""); (""this method"", ""called before"", ""getParameter()"")"
"For instance, you can access context parameters set in the web.xml file, you can forward the request to other servlets, and you can store application wide parameters in the ServletContext too.","(""ServletContext"", ""stores"", ""application wide parameters""); (""web.xml"", ""sets"", ""context parameters""); (""ServletRequest"", ""can be forwarded to"", ""other servlets""); (""ServletContext"", ""accesses"", ""context parameters"")"
In order to write binary data back to the browser you cannot use the Writer obtained from response.getWriter().,"(""response"", ""getWriter"", ""Writer"")"
Instead you have to use the OutputStream obtained from the response.getOutputStream() method.,"(""response"", ""hasMethod"", ""getOutputStream()""); (""getOutputStream()"", ""returns"", ""OutputStream"")"
The javax.servlet.http.HttpServlet class is a slightly more advanced base class than the GenericServlet shown in the Simple Servlet example.,"(""javax.servlet.http.HttpServlet"", ""is a"", ""base class""); (""javax.servlet.http.HttpServlet"", ""is more advanced than"", ""GenericServlet""); (""GenericServlet"", ""is shown in"", ""Simple Servlet example"")"
"The HttpServlet class reads the HTTP request, and determines if the request is an HTTP GET, POST, PUT, DELETE, HEAD etc.","(""HttpServlet"", ""reads"", ""HTTP request""); (""HttpServlet"", ""determines"", ""HTTP GET""); (""HttpServlet"", ""determines"", ""HTTP POST""); (""HttpServlet"", ""determines"", ""HTTP PUT""); (""HttpServlet"", ""determines"", ""HTTP DELETE""); (""HttpServlet"", ""determines"", ""HTTP HEAD"")"
"HTTP GET requests only, you will extend the HttpServlet class, and override the doGet() method only.","(""HttpServlet"", ""extendedBy"", ""UserClass""); (""HttpServlet"", ""hasMethod"", ""doGet()""); (""UserClass"", ""overrides"", ""doGet()"")"
"The HttpServlet class has methods you can override for each HTTP method (GET, POST etc.).","(""HttpServlet"", ""has methods"", ""GET""); (""HttpServlet"", ""has methods"", ""POST"")"
A Java Servlet is just an ordinary Java class which implements the interface,"(""Java Servlet"", ""implements"", ""interface"")"
The easiest way to implement this interface is to extend either the class GenericServlet or HttpServlet.,"(""GenericServlet"", ""extends"", ""interface""); (""HttpServlet"", ""extends"", ""interface"")"
"When an HTTP request arrives at the web server, targeted for your Servlet, the web server calls your Servlet's service() method.","(""Servlet"", ""has method"", ""service()""); (""web server"", ""calls"", ""Servlet.service()""); (""HTTP request"", ""arrives at"", ""web server""); (""web server"", ""calls"", ""Servlet"")"
"The service() method then reads the request, and generates a response which is sent back to the client (e.g.","(""service"", ""reads"", ""request""); (""service"", ""generates"", ""response""); (""response"", ""sent to"", ""client"")"
"You will need to run your Java Servlets inside a Servlet compatible ""Servlet Container"" (e.g.","(""Java Servlets"", ""run inside"", ""Servlet Container""); (""Servlet Container"", ""compatible with"", ""Java Servlets"")"
"The RequestDispatcher class enables your servlet to ""call"" another servlet from inside another servlet.","(""RequestDispatcher"", ""enables"", ""servlet""); (""RequestDispatcher"", ""call"", ""servlet""); (""servlet"", ""call"", ""servlet""); (""RequestDispatcher"", ""is used in"", ""servlet"")"
The above code obtains a RequestDispatcher targeted at whatever Servlet (or JSP) that is mapped to the URL /anotherUrl.simple.,"(""RequestDispatcher"", ""obtains"", ""Servlet""); (""RequestDispatcher"", ""targeted at"", ""JSP""); (""Servlet"", ""mapped to"", ""URL""); (""JSP"", ""mapped to"", ""URL""); (""URL"", ""is mapped to"", ""/anotherUrl.simple"")"
You can call the RequestDispatcher using either its include() or forward() method:,"(""RequestDispatcher"", ""has method"", ""include()""); (""RequestDispatcher"", ""has method"", ""forward()"")"
By calling either the include() or forward() method the servlet container activates whatever Servlet is mapped to the URL the RequestDispatcher.,"(""servlet container"", ""activates"", ""Servlet""); (""servlet container"", ""maps"", ""RequestDispatcher""); (""RequestDispatcher"", ""is mapped to"", ""URL""); (""servlet container"", ""calls"", ""include()""); (""servlet container"", ""calls"", ""forward()"")"
There is a little difference between calling the forward() and include() method.,"(""forward()"", ""is compared to"", ""include()""); (""calling forward()"", ""is different from"", ""calling include()"")"
"The forward() method intended for use in forwarding the request, meaning after the response of the calling servlet has been committed.","(""servlet"", ""has method"", ""forward()""); (""forward()"", ""intended for"", ""request""); (""servlet"", ""has response"", ""response""); (""response"", ""is committed by"", ""servlet""); (""request"", ""is forwarded by"", ""forward()"")"
"The include() method merges the response written by the calling servlet, and the activated servlet.","(""servlet"", ""calls"", ""include()""); (""servlet"", ""writes"", ""response""); (""include()"", ""merges"", ""response""); (""servlet"", ""activates"", ""servlet"")"
"This way you can achieve ""server side includes"" using the include().","(""include()"", ""is a method of"", ""unspecified class"")"
The red boxes represent state (variables) that your servlet's service() method should be careful about accessing.,"(""servlet"", ""has method"", ""service()"")"
"Of course it is not only the member variables and static variables inside the servlet class itself, that you need to be careful about accessing.","(""servlet class"", ""has"", ""member variables""); (""servlet class"", ""has"", ""static variables"")"
"Static variables in any other class which are accessed by your servlet, must also be thread safe.","(""Servlet"", ""accesses"", ""StaticVariables""); (""StaticVariables"", ""must be"", ""ThreadSafe""); (""Servlet"", ""uses"", ""Class""); (""Class"", ""has"", ""StaticVariables"")"
In order to create a servlet filter you must implement the javax.servlet.Filter interface.,"(""javax.servlet.Filter"", ""implement"", ""servlet filter"")"
"When the servlet filter is loaded the first time, its init() method is called, just like with servlets.","(""servlet filter"", ""has method"", ""init()""); (""servlets"", ""has method"", ""init()""); (""servlet filter"", ""loaded by"", ""servlet"")"
"Notice how the doFilter() method checks a request parameter, myParam, to see if it equals the string ""blockTheRequest"".","(""doFilter"", ""checks"", ""request parameter""); (""request parameter"", ""equals"", ""myParam""); (""myParam"", ""equals"", ""blockTheRequest""); (""doFilter"", ""method of"", ""unknown class"")"
"If not, the request is forwarded to the target of the request, by calling the filterChain.doFilter() method.","(""filterChain"", ""has method"", ""doFilter()"")"
"You need to configure the servlet filter in the web.xml file of your web application, before it works.","(""servlet filter"", ""configured in"", ""web.xml""); (""web.xml"", ""part of"", ""web application""); (""servlet filter"", ""works in"", ""web application"")"
With this configuration all requests with URL's ending in .simple will be intercepted by the servlet filter.,"(""servlet filter"", ""intercepts"", ""requests""); (""requests"", ""have URL's ending in"", "".simple""); (""servlet filter"", ""handles"", ""URL's ending in .simple"")"
Before a servlet can be invoked the servlet container must first load its class definition.,"(""servlet"", ""can be invoked by"", ""servlet container""); (""servlet container"", ""must load"", ""class definition""); (""servlet"", ""has"", ""class definition"")"
"When the servlet class is loaded, the servlet container creates an instance of the servlet.","(""servlet class"", ""is loaded by"", ""servlet container""); (""servlet container"", ""creates instance of"", ""servlet class""); (""servlet class"", ""has instance created by"", ""servlet container"")"
"When a servlet instance is created, its init() method is invoked.","(""servlet"", ""has method"", ""init()""); (""servlet instance"", ""invokes"", ""init()""); (""servlet"", ""creates instance"", ""servlet instance""); (""servlet instance"", ""invokes method"", ""init()"")"
The init() method allows a servlet to initialize itself before the first request is processed.,"(""servlet"", ""has method"", ""init()""); (""init()"", ""is called before"", ""first request""); (""servlet"", ""processes"", ""first request"")"
You can specify init parameters to the servlet in the web.xml file.,"(""servlet"", ""specified in"", ""web.xml""); (""web.xml"", ""contains"", ""init parameters""); (""servlet"", ""has"", ""init parameters"")"
"For every request received to the servlet, the servlets service() method is called.","(""servlet"", ""has method"", ""service()"")"
"As long as the servlet is active in the servlet container, the service() method can be called.","(""servlet"", ""has method"", ""service()""); (""servlet"", ""is contained in"", ""servlet container""); (""servlet container"", ""calls"", ""service()"")"
"When a servlet is unloaded by the servlet container, its destroy() method is called.","(""servlet"", ""has method"", ""destroy()""); (""servlet container"", ""calls method"", ""destroy()""); (""servlet"", ""is unloaded by"", ""servlet container"")"
"Once the servlet has been activated via the service() method, the servlet processes the request, and generates a response.","(""servlet"", ""has method"", ""service()""); (""servlet"", ""processes"", ""request""); (""servlet"", ""generates"", ""response"")"
This is done in the web.xml file of your Java web application.,"(""web.xml"", ""is part of"", ""Java web application""); (""Java web application"", ""has"", ""web.xml"")"
"To configure a servlet in the web.xml file, you write this:","(""servlet"", ""configured in"", ""web.xml""); (""web.xml"", ""contains"", ""servlet configuration""); (""servlet configuration"", ""written in"", ""web.xml"")"
"Here you give the servlet a name, and writes the class name of the servlet.","(""servlet"", ""hasName"", ""name""); (""servlet"", ""hasClass"", ""class""); (""servlet"", ""writes"", ""class name"")"
"In the above example, all URL's ending in .html are sent to the servlet.","(""servlet"", ""handles"", ""URL""); (""URL"", ""ends with"", "".html""); (""servlet"", ""receives"", ""URL"")"
You can pass parameters to a servlet from the web.xml file.,"(""servlet"", ""defined in"", ""web.xml""); (""web.xml"", ""passes parameters to"", ""servlet""); (""servlet"", ""receives parameters from"", ""web.xml"")"
Here is how you read the init parameters from inside your servlet - in the servlets init() method:,"(""servlet"", ""has method"", ""init()""); (""init()"", ""is used to read"", ""init parameters""); (""servlet"", ""reads"", ""init parameters"")"
A servlets init() method is called when the servlet container loads the servlet for the first time.,"(""servlet"", ""has method"", ""init()""); (""servlet container"", ""loads"", ""servlet""); (""servlet"", ""has method called"", ""init()""); (""servlet container"", ""calls"", ""init()"")"
"No one can access the servlet until the servlet has been loaded, and the init() method has been called successfully.","(""servlet"", ""has method"", ""init()""); (""servlet"", ""has state"", ""loaded""); (""servlet"", ""is accessed by"", ""user""); (""servlet"", ""has method called"", ""init()"")"
"Remember, the servlets init() method is called when the servlet is loaded.","(""servlet"", ""has method"", ""init()""); (""servlet"", ""is loaded by"", ""init()""); (""servlet"", ""calls"", ""init()"")"
Here is how you access the parameter from inside an HttpServlet subclass:,"(""HttpServlet"", ""subclass"", ""parameter""); (""HttpServlet"", ""access"", ""parameter""); (""parameter"", ""inside"", ""HttpServlet"")"
In this text I will show you a simple unit test implemented using JUnit 4.8.1.,"(""JUnit"", ""uses"", ""unit test""); (""JUnit"", ""has version"", ""4.8.1"")"
First I will show you the class I want to test:,
I have kept the class very simple to make it eaiser to understand what is going on.,
To test this class I need a unit test that test each of its public methods.,"(""UnitTest"", ""tests"", ""PublicMethod""); (""Class"", ""hasMethod"", ""PublicMethod""); (""UnitTest"", ""tests"", ""Class"")"
"The class only has one public method, concatenate(), so all I need to test is this method.","(""class"", ""has method"", ""concatenate()"")"
Each test method usually tests a single method of the target class.,"(""test method"", ""tests"", ""method""); (""target class"", ""has"", ""method""); (""method"", ""is part of"", ""target class"")"
"Sometimes, a test method can test more than one method in the target class, and sometimes, if the method to test is big, you split the test into multiple test methods.","(""test method"", ""can test"", ""method""); (""test method"", ""can test"", ""target class""); (""target class"", ""has"", ""method""); (""method"", ""is part of"", ""target class""); (""test method"", ""is split into"", ""test methods""); (""method"", ""is split into"", ""test methods"")"
Here is the JUnit unit test that test that the concatenate() method:,"(""JUnit"", ""has method"", ""test""); (""concatenate()"", ""is method of"", ""unspecified class""); (""unspecified class"", ""has method"", ""concatenate()"")"
"The unit test class is an ordinary class, with one method, testConcatenate().","(""unit test class"", ""has method"", ""testConcatenate()"")"
In this method we compare the output of the called method (concatenate()) with the expected output.,"(""concatenate()"", ""called by"", ""method""); (""concatenate()"", ""compared to"", ""expected output""); (""method"", ""calls"", ""concatenate()""); (""expected output"", ""compared to"", ""concatenate()"")"
"In other words, we compare ""onetwo"" (expected output) with the value returned by the concatenate() method, which is kept in the variable result.","(""concatenate() method"", ""is kept in"", ""result variable""); (""concatenate() method"", ""returns"", ""value""); (""expected output"", ""is compared with"", ""result variable""); (""concatenate() method"", ""is called on"", ""unknown entity"")"
"The assertEquals() method is a statically imported method, which normally resides in the org.junit.Assert class.","(""org.junit.Assert"", ""contains"", ""assertEquals()""); (""assertEquals()"", ""resides in"", ""org.junit.Assert""); (""org.junit.Assert"", ""has method"", ""assertEquals()"")"
Notice the static import of this class at the top of MyUnitTest.,"(""MyUnitTest"", ""imports"", ""static class"")"
Using the static import of the method is shorter than writing Assert.assertEquals().,"(""Assert"", ""hasMethod"", ""assertEquals()"")"
You can have as many test methods in a unit test class as you want.,"(""unit test class"", ""has"", ""test methods""); (""test methods"", ""are in"", ""unit test class""); (""unit test class"", ""contains"", ""test methods"")"
This is how simple a unit test can be with JUnit 4.8.2 .,"(""JUnit"", ""hasVersion"", ""4.8.2"")"
"As you may have figured out from the simple test, most of the secret of implementing JUnit unit tests, is in the use of the assert methods in the class org.junit.Assert.","(""org.junit.Assert"", ""contains"", ""assert methods""); (""JUnit"", ""uses"", ""org.junit.Assert""); (""org.junit.Assert"", ""has"", ""assert methods"")"
In this text I will take a closer look at what assert methods are available in this class.,"(""assert"", ""is available in"", ""class"")"
"The code for this class is not shown, but you don't really need the code in order to understand how to test it.",
The assertArrayEquals() method will test whether two arrays are equal to each other.,"(""assertArrayEquals()"", ""is a method of"", ""junit framework""); (""assertArrayEquals()"", ""tests equality of"", ""arrays""); (""arrays"", ""are tested by"", ""assertArrayEquals()"")"
"To check for element equality, the elements in the array are compared using their equals() method.","(""array"", ""has method"", ""equals()""); (""equals()"", ""is method of"", ""array""); (""elements"", ""are compared using"", ""equals()""); (""array"", ""contains"", ""elements""); (""elements"", ""have method"", ""equals()"")"
"More specifically, the elements of each array are compared one by one using their equals() method.","(""array"", ""has method"", ""equals()"")"
"Second the myUnit.getTheStringArray() method is called, which is the method we want to test.","(""myUnit"", ""hasMethod"", ""getTheStringArray()"")"
"Third, the result of the myUnit.getTheStringArray() method call is compared to the expected array.","(""myUnit"", ""getTheStringArray()"", ""theStringArray""); (""myUnit.getTheStringArray()"", ""compared to"", ""expected array""); (""myUnit"", ""has method"", ""getTheStringArray()""); (""getTheStringArray()"", ""returns"", ""theStringArray""); (""myUnit"", ""calls method"", ""getTheStringArray()"")"
"If the arrays are equal, the assertArrayEquals() will proceed without errors.","(""assertArrayEquals()"", ""is a method of"", ""junit framework""); (""assertArrayEquals()"", ""proceeds without errors when"", ""arrays are equal""); (""assertArrayEquals()"", ""compares"", ""arrays""); (""arrays"", ""are compared by"", ""assertArrayEquals()""); (""assertArrayEquals()"", ""throws error when"", ""arrays are not equal"")"
"The assertEquals() method compares two objects for equality, using their equals() method.","(""Assert.assertEquals()"", ""compares"", ""objects""); (""Assert.assertEquals()"", ""uses"", ""equals()""); (""objects"", ""have"", ""equals()""); (""Assert.assertEquals()"", ""uses"", ""objects.equals()"")"
"First the myUnit.concatenate() method is called, and the result is stored in the variable result.","(""myUnit"", ""concatenate"", ""result""); (""myUnit"", ""hasMethod"", ""concatenate()"")"
"Second, the result value is compared to the expected value ""onetwo"", using the assertEquals() method.","(""assertEquals"", ""is method of"", ""junit framework""); (""assertEquals"", ""compares"", ""result value""); (""assertEquals"", ""compares"", ""expected value""); (""expected value"", ""has value"", ""onetwo""); (""result value"", ""is compared by"", ""assertEquals"")"
"If the two objects are equal according to their implementation of their equals() method, the assertEquals() method will return normally.","(""Object"", ""has method"", ""equals()""); (""assertEquals()"", ""is method of"", ""UNKNOWN""); (""Object"", ""has method"", ""equals()""); (""assertEquals()"", ""returns normally when"", ""equals() returns true""); (""Object"", ""implements"", ""equals()"")"
"Otherwise the assertEquals() method will throw an exception, and the test will stop there.","(""assertEquals()"", ""is a method of"", ""TestCase""); (""assertEquals()"", ""will throw"", ""exception""); (""testCase"", ""has method"", ""assertEquals()"")"
"This example compared to String objects, but the assertEquals() method can compare any two objects to each other.",
The assertEquals() method also come in versions which compare primitive types like int and float to each other.,"(""assertEquals()"", ""compares"", ""int""); (""assertEquals()"", ""compares"", ""float"")"
"The assertTrue() and assertFalse() methods tests a single variable to see if its value is either true, or false.","(""Assert"", ""contains"", ""assertTrue()""); (""Assert"", ""contains"", ""assertFalse()""); (""assertTrue()"", ""tests"", ""variable""); (""assertFalse()"", ""tests"", ""variable"")"
"As you can see, the method call to myUnit.getTheBollean() is inlined inside the assertTrue() assertFalse() calls.","(""myUnit"", ""getTheBollean"", ""Boolean""); (""myUnit.getTheBollean"", ""called by"", ""assertTrue""); (""myUnit.getTheBollean"", ""called by"", ""assertFalse""); (""assertTrue"", ""uses"", ""myUnit.getTheBollean""); (""assertFalse"", ""uses"", ""myUnit.getTheBollean"")"
"If the getTheBoolean() method returns true, the assertTrue() method will return normally.","(""getTheBoolean()"", ""returns"", ""true""); (""assertTrue()"", ""returns"", ""normally""); (""getTheBoolean()"", ""affects"", ""assertTrue()"")"
"If the getTheBoolean() method returns false, the assertFalse() method will return normally.","(""getTheBoolean()"", ""returns"", ""false""); (""assertFalse()"", ""returns"", ""normally""); (""getTheBoolean()"", ""compared to"", ""assertFalse()"")"
"Of course the above test will fail in either the assertTrue() or assertFalse() call, if the getTheBoolean() method returns the same value in both calls.","(""assertTrue"", ""call"", ""test""); (""assertFalse"", ""call"", ""test""); (""getTheBoolean"", ""returns"", ""value""); (""getTheBoolean"", ""method of"", ""test""); (""assertTrue"", ""fails in"", ""test""); (""assertFalse"", ""fails in"", ""test"")"
The assertNull() and assertNotNull() methods test a single variable to see if it is null or not null.,"(""assertNull()"", ""tests"", ""variable""); (""assertNotNull()"", ""tests"", ""variable"")"
The call to myUnit.getTheObject() is inlined in the assertNull() and assertNotNull() calls.,"(""myUnit"", ""getTheObject"", ""theObject""); (""assertNull"", ""call"", ""myUnit.getTheObject()""); (""assertNotNull"", ""call"", ""myUnit.getTheObject()"")"
"If the myUnit.getTheObject() returns null, the assertNull() method will return normally.","(""myUnit"", ""getTheObject"", ""theObject""); (""assertNull"", ""returns"", ""normally""); (""myUnit.getTheObject"", ""returns"", ""null"")"
"If a non-null value is returned, the assertNull() method will throw an exception, and the test will be aborted here.","(""assertNull()"", ""method of"", ""test""); (""assertNull()"", ""will throw"", ""exception""); (""exception"", ""thrown by"", ""assertNull()""); (""test"", ""aborted by"", ""exception""); (""assertNull()"", ""used in"", ""test"")"
"The assertNotNull() method works oppositely of the assertNull() method, throwing an exception if a null value is passed to it, and returning normally if a non-null value is passed to it.",
The assertSame() and assertNotSame() methods tests if two object references point to the same object or not.,"(""assertSame()"", ""is method of"", ""JUnit""); (""assertNotSame()"", ""is method of"", ""JUnit""); (""assertSame()"", ""tests"", ""object references""); (""assertNotSame()"", ""tests"", ""object references"")"
It is not enough that the two objects pointed to are equals according to their equals() methods.,"(""Object"", ""pointed to"", ""equals()""); (""equals()"", ""methods of"", ""Object""); (""Object"", ""are equals according to"", ""equals()"")"
The calls to myUnit.getTheSameObject() are inlined into the assertSame() and assertNotSame() method calls.,"(""myUnit"", ""hasMethod"", ""getTheSameObject()""); (""assertSame"", ""isCalledWith"", ""myUnit.getTheSameObject()""); (""assertNotSame"", ""isCalledWith"", ""myUnit.getTheSameObject()"")"
"If the two references points to the same object, the assertSame() method will return normally.","(""assertSame()"", ""is a method of"", ""AssertionError""); (""assertSame()"", ""is used with"", ""references""); (""references"", ""are compared by"", ""assertSame()"")"
"If the two objects do not poin to the same object, the assertNotSame() method will return normally.","(""assertNotSame"", ""method of"", ""unknown class""); (""assertNotSame"", ""returns"", ""normally""); (""unknown class"", ""has method"", ""assertNotSame()"")"
The assertThat() method compares an object to an org.hamcrest.Matcher to see if the given object matches whatever the Matcher requires it to match.,"(""assertThat"", ""compares"", ""org.hamcrest.Matcher""); (""org.hamcrest.Matcher"", ""matches"", ""object""); (""assertThat"", ""requires"", ""match""); (""object"", ""matches"", ""org.hamcrest.Matcher"")"
"If you are testing a component that uses a database, e.g.",
"a DAO class, you may want to test that the component really inserts data into the database, updates it etc.","(""DAO"", ""inserts data into"", ""database""); (""DAO"", ""updates"", ""database""); (""component"", ""inserts data into"", ""database"")"
It is just a standard Java class - nothing secret about it.,
"Exactly what methods you will put in your own TestData class, depends on the data used by your application.","(""TestData"", ""depends on"", ""application""); (""TestData"", ""contains"", ""methods"")"
"Also, you may want some of the methods to take parameters, rather than e.g.",
"Once you have such a TestData class, you can use and reuse it in your unit tests.","(""TestData"", ""used in"", ""unit tests""); (""TestData"", ""reused in"", ""unit tests"")"
"The TestData class can contain all kinds of business wise complex test data setups, which are then easy to setup in the database, once they have been programmed once.","(""TestData"", ""can contain"", ""test data setups""); (""TestData"", ""setups in"", ""database""); (""TestData"", ""have been programmed"", ""test data setups"")"
"Below is a diagram illustrating a unit test, a unit (which is being tested), and a dependency which is some class used by the unit.","(""UnitTest"", ""tests"", ""Unit""); (""Unit"", ""uses"", ""Dependency""); (""Unit"", ""isTestedIn"", ""UnitTest""); (""Dependency"", ""isUsedBy"", ""Unit"")"
"If a method or field is private, only instances of that class can access that method or field.","(""Class"", ""has"", ""Method""); (""Class"", ""has"", ""Field""); (""Class"", ""accesses"", ""Method""); (""Class"", ""accesses"", ""Field""); (""Method"", ""is accessed by"", ""Class""); (""Field"", ""is accessed by"", ""Class""); (""Instance"", ""accesses"", ""Method""); (""Instance"", ""accesses"", ""Field""); (""Method"", ""is"", ""private""); (""Field"", ""is"", ""private"")"
"A protected method or field, on the other hand, is also accessible to other classes in the same package, and for subclasses of the unit too.","(""protected method"", ""is accessible to"", ""other classes""); (""protected method"", ""is accessible to"", ""subclasses""); (""protected field"", ""is accessible to"", ""other classes""); (""protected field"", ""is accessible to"", ""subclasses""); (""protected method"", ""is part of"", ""same package""); (""protected field"", ""is part of"", ""same package""); (""subclasses"", ""are in"", ""same package""); (""other classes"", ""are in"", ""same package"")"
"By encapsulating calls to external dependencies (components) in protected methods, you can create a subclass mock of the unit to test, and override these protected methods, to make them record information about whether they were called or not.","(""Class"", ""hasMethod"", ""protected methods""); (""protected methods"", ""areOverriddenBy"", ""subclass mock""); (""subclass mock"", ""overrides"", ""protected methods""); (""Class"", ""canCreate"", ""subclass mock""); (""subclass mock"", ""recordsInformationAbout"", ""calls to external dependencies""); (""protected methods"", ""recordInformationAbout"", ""whether they were called or not"")"
"By ""boundary class"" I mean classes that plug into some framework.","(""boundary class"", ""plug into"", ""framework"")"
You may need the whole framework running in order to test your boundary class.,"(""framework"", ""running in"", ""test""); (""boundary class"", ""test"", ""framework""); (""class"", ""test"", ""framework"")"
"Examples of boundary classes are Servlets, Struts actions, custom Swing components, EJB's etc.","(""Servlets"", ""is_a"", ""boundary class""); (""Struts actions"", ""is_a"", ""boundary class""); (""custom Swing components"", ""is_a"", ""boundary class""); (""EJB"", ""is_a"", ""boundary class"")"
Each of these boundary classes need a larger framework or server running in order to test them.,"(""boundary classes"", ""need"", ""framework""); (""boundary classes"", ""need"", ""server"")"
"A way to get around that is to move the business logic out of the boundary class, and into it's own component.","(""boundary class"", ""has"", ""business logic""); (""boundary class"", ""moves"", ""business logic""); (""business logic"", ""is moved to"", ""component"")"
Make sure that the business logic component does not know anything about the boundary classes.,"(""business logic component"", ""does not know"", ""boundary classes"")"
"For instance, if your boundary class is a servlet, your business logic class should not know anything about the HttpRequest or HttpResponse interfaces.","(""servlet"", ""is boundary class of"", ""HttpRequest""); (""servlet"", ""is boundary class of"", ""HttpResponse""); (""business logic class"", ""should not know about"", ""HttpRequest""); (""business logic class"", ""should not know about"", ""HttpResponse"")"
"Preferably, the business logic class only takes the parameters it needs, as the types it needs.","(""business logic class"", ""takes"", ""parameters""); (""parameters"", ""are of type"", ""types""); (""business logic class"", ""needs"", ""types""); (""business logic class"", ""needs"", ""parameters"")"
"When your business logic class is separated from the boundary class, you can test the business logic class separately.","(""business logic class"", ""is separated from"", ""boundary class""); (""business logic class"", ""can be tested separately"", ""business logic class""); (""business logic class"", ""is separated from"", ""boundary class"")"
"When the boundary classes are minimized to dispatch logic, the risk of errors in them are a lot smaller, in case you choose not to unit test them.",
"For an example of this, see the Servlet Unit Testing text, in which I show how to unit test the business logic of a servlet, by moving the business logic to a separate class.",
In this text I will give a few suggestions to how you can test such classes.,
Let's look at how to write a unit test for this class.,
The ByteArrayInputStream is then used as input into the MyIOUnitTest.read() method.,"(""ByteArrayInputStream"", ""used as input into"", ""MyIOUnitTest.read()""); (""MyIOUnitTest"", ""has method"", ""MyIOUnitTest.read()"")"
Here is the unit test which uses a ByteArrayOutputStream to collect the data written to the OutputStream passed to the MyIOUnit.write() method:,"(""MyIOUnit"", ""uses"", ""ByteArrayOutputStream""); (""MyIOUnit"", ""has method"", ""write()""); (""write()"", ""writes to"", ""OutputStream""); (""ByteArrayOutputStream"", ""collects data from"", ""OutputStream"")"
"Notice how the output.toByteArray() method is called, and passed into a String.",
"If your input or output component uses a Reader or Writer instead of an InputStream or OutputStream, you can use the classes CharArrayReader and CharArrayWriter instead of ByteArrayInputStream and ByteArrayOutputStream.","(""Reader"", ""uses"", ""InputStream""); (""Writer"", ""uses"", ""OutputStream""); (""CharArrayReader"", ""instead of"", ""ByteArrayInputStream""); (""CharArrayWriter"", ""instead of"", ""ByteArrayOutputStream""); (""CharArrayReader"", ""uses"", ""Reader""); (""CharArrayWriter"", ""uses"", ""Writer"")"
You may also be able to use the StringReader and StringWriter classes in your unit tests.,"(""StringReader"", ""used in"", ""unit tests""); (""StringWriter"", ""used in"", ""unit tests"")"
"Unit testing means testing the smaller units of your application, like classes and methods.","(""Unit testing"", ""tests"", ""classes""); (""Unit testing"", ""tests"", ""methods"")"
"JUnit 4.8.2 ships with Hamcrest internally, so you don't have to download it, and add it yourself.","(""Junit"", ""ships with"", ""Hamcrest""); (""Junit"", ""has version"", ""4.8.2""); (""Hamcrest"", ""is included in"", ""Junit"")"
"Matchers are used with the org.junit.Assert.assertThat() method, which looks like this:","(""org.junit.Assert"", ""has_method"", ""assertThat()""); (""assertThat()"", ""is_used_with"", ""Matchers"")"
"The assertThat() method just takes care of the ""plumming"" - meaning calling the Matcher with the given object.","(""assertThat"", ""takes care of"", ""Matcher""); (""assertThat"", ""calling with"", ""object""); (""Matcher"", ""called by"", ""assertThat"")"
"In the example above, the org.hamcrest.CoreMatchers.is() method is used to create a Matcher.","(""org.hamcrest.CoreMatchers"", ""is"", ""Matcher"")"
"The Matcher returned by is() returns true, if the two values compared are equal, and false if not.","(""Matcher"", ""returned by"", ""is()""); (""is()"", ""returns"", ""true""); (""is()"", ""returns"", ""false""); (""Matcher"", ""compares"", ""values"")"
"The is() method returns one matcher, and the not() method returns another.","(""is()"", ""returns"", ""matcher""); (""not()"", ""returns"", ""matcher"")"
The matcher returned by not() negates the matcher output of the matcher given as input.,"(""not()"", ""returns"", ""matcher""); (""matcher"", ""given as input to"", ""not()""); (""matcher"", ""output negated by"", ""not()"")"
"In this case, it is the output of the matcher returned by the is() method, that is negated.","(""matcher"", ""returned by"", ""is()""); (""is()"", ""has method"", ""matcher""); (""matcher"", ""is output of"", ""is()"")"
You can write your own matchers and plug into the assertThat() method.,"(""assertThat()"", ""method of"", ""Matcher""); (""Matcher"", ""plugged into"", ""assertThat()""); (""assertThat()"", ""has method"", ""matcher"")"
The static method matches() creates a new matcher and returns it.,"(""matches()"", ""creates"", ""matcher"")"
You just embed the call to the static method matches() inside the assertThat() method.,"(""assertThat"", ""contains"", ""matches""); (""matches"", ""called by"", ""assertThat"")"
In several situations mock testing is easier than testing with the real collaborators of a class.,
When testing a DAO you may use a mock java.sql.Connection and java.sql.ResultSet object with the DAO to check that the DAO makes the correct JDBC calls.,"(""DAO"", ""uses"", ""java.sql.Connection""); (""DAO"", ""uses"", ""java.sql.ResultSet""); (""DAO"", ""makes"", ""JDBC calls"")"
It is not visible from the value returned by the DAO if it remembered to call ResultSet.close() and Connection.close() before returning.,"(""DAO"", ""uses"", ""ResultSet""); (""DAO"", ""uses"", ""Connection""); (""ResultSet"", ""has method"", ""close()""); (""Connection"", ""has method"", ""close()"")"
The above situation was exactly the case for the GenericDao class in Mr. Persister.,"(""GenericDao"", ""is a class in"", ""Mr. Persister"")"
Ideally the JDBC driver would detect that when calling the PreparedStatement.executeUpdate() method.,"(""PreparedStatement"", ""hasMethod"", ""executeUpdate()""); (""PreparedStatement.executeUpdate()"", ""calledBy"", ""JDBC driver""); (""JDBC driver"", ""callsMethod"", ""PreparedStatement.executeUpdate()"")"
Therefore we decided to compare the PreparedStatement.getParameterMetaData().getParameterCount() with parameters.length before calling PreparedStatement.executeUpdate().,"(""PreparedStatement"", ""getParameterMetaData"", ""getParameterMetaData()""); (""getParameterMetaData"", ""getParameterCount"", ""Integer""); (""PreparedStatement"", ""executeUpdate"", ""void""); (""parameters"", ""length"", ""Integer""); (""PreparedStatement"", ""getParameterMetaData().getParameterCount"", ""parameters.length"")"
"This works with the HSQLDB driver, but the MySQL driver haven't implemented the PreparedStatement.getParameterMetaData() method.","(""HSQLDB"", ""implements"", ""PreparedStatement.getParameterMetaData()""); (""MySQL"", ""does not implement"", ""PreparedStatement.getParameterMetaData()""); (""PreparedStatement"", ""has method"", ""getParameterMetaData()"")"
Fortunately the MySQL driver does throw an exception if the ?-signs and the parameters set doesn't match when calling PreparedStatement.executeUpdate().,"(""MySQL driver"", ""throws"", ""exception""); (""PreparedStatement"", ""has method"", ""executeUpdate()""); (""executeUpdate()"", ""requires"", ""parameters""); (""parameters"", ""must match"", ""?-signs"")"
"In the classpath element I add the output locations of my project code, and test code.","(""classpath"", ""contains"", ""project code""); (""classpath"", ""contains"", ""test code""); (""project code"", ""is located in"", ""classpath""); (""test code"", ""is located in"", ""classpath"")"
In the test element I declare which unit test class to execute.,"(""test"", ""declares"", ""unit test class""); (""test"", ""executes"", ""unit test class""); (""unit test class"", ""is declared in"", ""test element""); (""unit test class"", ""is executed by"", ""test"")"
The classpath stuff is the same as in the first example.,"(""classpath"", ""is the same as"", ""first example"")"
"In this example I execute all files that has the text ""Test"" and "".java"" in their file name, regardless of what directory they are located in, recursively.",
"What I usually do instead, is to ""move the code out of the boundary class"", as I have described in the text Design for Testability.",
"Basically, I would try to push the main business logic in the servlet into a separate class which has no dependencies on the Servlet API's, if possible.","(""servlet"", ""has"", ""business logic""); (""servlet"", ""depends on"", ""Servlet API""); (""business logic"", ""pushed to"", ""separate class""); (""separate class"", ""has no dependencies on"", ""Servlet API"")"
"So, I will take the concatenation logic and move into a separate class, which can be tested independent from the MyServlet class.","(""MyServlet"", ""has logic"", ""concatenation logic""); (""concatenation logic"", ""moved to"", ""separate class""); (""separate class"", ""is independent from"", ""MyServlet"")"
Notice how the concatenation logic has been moved to a class called MyConcatenator.,"(""MyConcatenator"", ""contains"", ""concatenation logic"")"
Notice how the concatenate() method only refers to a string array.,"(""string array"", ""has method"", ""concatenate()"")"
Notice again how it was not necessary to reference any servlet classes or interfaces in this unit test.,"(""servlet"", ""referenced in"", ""unit test"")"
By real objects I mean the objects the tested unit (class) will be using in the real application.,"(""unit"", ""uses"", ""objects""); (""class"", ""is"", ""unit"")"
"If you have a class Calculator, that needs a dao (Data Access Object) object to load the data it needs from a database, then the dao object is a ""real object"".","(""Calculator"", ""needs"", ""dao""); (""Calculator"", ""uses"", ""Data Access Object""); (""Data Access Object"", ""loads"", ""data""); (""dao"", ""is"", ""Data Access Object""); (""Calculator"", ""interacts with"", ""database"")"
In order to test the Calculator class you will have to provide it with a dao object that has a valid connection to the database.,"(""Calculator"", ""uses"", ""dao""); (""dao"", ""has"", ""connection""); (""connection"", ""belongs to"", ""database"")"
Instead you can provide the Calculator instance with a fake dao class which just returns the data you need for the test.,"(""Calculator"", ""has"", ""dao""); (""Calculator"", ""uses"", ""fake dao class""); (""dao"", ""used by"", ""Calculator""); (""Calculator"", ""instance of"", ""Calculator class""); (""dao"", ""returns"", ""data""); (""Calculator"", ""provided with"", ""fake dao class""); (""fake dao class"", ""returns"", ""data"")"
The fake dao class will not actually read the data from the database.,"(""dao"", ""will not read from"", ""database""); (""dao class"", ""is fake"", ""dao""); (""dao class"", ""will not read data from"", ""database"")"
A replacement for a real object which makes it easier to test the Calculator class.,"(""Calculator"", ""is replaced by"", ""replacement object""); (""Calculator"", ""is tested with"", ""replacement object""); (""replacement object"", ""replaces"", ""Calculator"")"
Nor can you see if the connection.close() method was called before returning the value.,"(""connection"", ""has method"", ""close()"")"
"If you add a String ""myReturnValue"" as return value to the stub and then call connection.prepareStatement(""select * from houses"") which returns a PreparedStatement, you will get an exception.","(""connection"", ""hasMethod"", ""prepareStatement()""); (""prepareStatement()"", ""returns"", ""PreparedStatement""); (""PreparedStatement"", ""throws"", ""exception""); (""exception"", ""isThrownBy"", ""prepareStatement()"")"
"The String return value cannot be returned from the connection.prepareStatement(""...""); You will have to make sure yourself that the return values and called methods on the stub match.","(""String"", ""return value of"", ""connection.prepareStatement()""); (""connection.prepareStatement()"", ""returns"", ""String""); (""stub"", ""has methods"", ""called methods""); (""return values"", ""match"", ""called methods on stub"")"
If the connection.close() method has not been called a java.lang.AssertionError is thrown.,"(""connection"", ""has method"", ""close()""); (""connection.close()"", ""throws"", ""java.lang.AssertionError"")"
You just provide the real collaborator to the MockFactory instead of an interface (class object).,"(""MockFactory"", ""uses"", ""collaborator"")"
You can even turn the proxyConnection into a stub temporarily by adding a return value to the proxy via the mock.addReturnValue(...).,"(""proxyConnection"", ""turned into"", ""stub""); (""proxy"", ""has method"", ""addReturnValue()""); (""mock"", ""has method"", ""addReturnValue()"")"
"Subclass mock objects is a mock object that is created by subclassing the class you want to test, and overriding some of its methods.","(""Subclass"", ""is a"", ""mock objects""); (""Subclass"", ""created by"", ""subclassing""); (""Mock objects"", ""created by"", ""subclassing""); (""Class"", ""subclassed by"", ""Subclass""); (""Subclass"", ""overrides"", ""methods"")"
The class MyUnit is the class I am trying to unit test.,"(""MyUnit"", ""is"", ""class"")"
"In this unit test, I want to check if the MyUnit class calls the MyDependency class correctly.","(""MyUnit"", ""calls"", ""MyDependency"")"
"The first thing to do is to refactory the MyUnit class, so that all calls to the MyDependency class are encapsulated in their own methods.","(""MyUnit"", ""uses"", ""MyDependency""); (""MyUnit"", ""encapsulates"", ""MyDependency""); (""MyUnit"", ""refactors"", ""MyDependency"")"
"Notice how the two calls to MyDependency.callOne() and MyDependency.callTwo() are now encapsulated in two protected methods, callOne() and callTwo().","(""MyDependency"", ""hasMethod"", ""callOne()""); (""MyDependency"", ""hasMethod"", ""callTwo()""); (""MyDependency"", ""encapsulates"", ""callOne()""); (""MyDependency"", ""encapsulates"", ""callTwo()"")"
The second step is to create a subclass mock of the MyUnit class.,"(""MyUnit"", ""is subclass of"", ""mock""); (""MyUnit"", ""has subclass"", ""mock"")"
Here is a unit test method that uses the MyUnitMock class:,"(""MyUnitMock"", ""uses"", ""unit test method"")"
"Third, assertions are made about whether the callOne() and callTwo() method were invoked.","(""callOne()"", ""is invoked by"", ""test class""); (""callTwo()"", ""is invoked by"", ""test class"")"
"As you can see, it is possible to test almost all of a class by using subclass mocks, as described above.","(""class"", ""is tested by"", ""subclass mocks""); (""subclass mocks"", ""are used to test"", ""class""); (""class"", ""can be tested by"", ""subclass mocks"")"
"There are, however, situations where it works better to use a completely separate mock dependency object with the original class instead.",
"If the throwIllegalArgumentException() method returns normall, then this fail() call is executed, causing the test to fail.","(""throwIllegalArgumentException()"", ""returns"", ""normally""); (""fail()"", ""is executed by"", ""throwIllegalArgumentException()""); (""fail()"", ""causes"", ""test""); (""throwIllegalArgumentException()"", ""returns"", ""normally""); (""throwIllegalArgumentException()"", ""method of"", ""test""); (""fail()"", ""method of"", ""test"")"
"Correspondingly, if the throwIllegalArgumentException() method throws the expected IllegalArgumentException, it is caught in the catch-clause, and ignored.","(""throwIllegalArgumentException()"", ""throws"", ""IllegalArgumentException""); (""catch-clause"", ""catches"", ""IllegalArgumentException""); (""throwIllegalArgumentException()"", ""is caught in"", ""catch-clause"")"
"Instead you want users trying to access your web app to see a nice ""This web app is down for maintenance..."" page.",
"A ""This web app is down for maintenance..."" page lets them know that the down time is controlled and expected.",
Here is how the web.xml configuration looks for such a setup:,
"For instance, imagine that a user sends a request that takes 1 minute to process (e.g.",
"I've posted the full solution including the servlet filter Java code, the web.xml configuration, the maintenance message page and the maintenance GUI page, for your convenience below.","(""servlet filter"", ""included in"", ""Java code""); (""Java code"", ""part of"", ""full solution""); (""web.xml"", ""part of"", ""full solution""); (""web.xml"", ""used for"", ""configuration""); (""maintenance message page"", ""part of"", ""full solution""); (""maintenance GUI page"", ""part of"", ""full solution"")"
"Apparently the field name ""comment"" caused the text (""Comment..."") in the textarea not to show up in Firefox... weird, right...?!",
"In order to get a Java web server or servlet container to run your Java web application, you need to package the resources inside it (servlets, JSP's etc.)","(""Java web server"", ""run"", ""Java web application""); (""Java web application"", ""contain"", ""servlets""); (""Java web application"", ""contain"", ""JSP's""); (""servlet container"", ""run"", ""Java web application"")"
... then the index.jsp page will be accessible at the URL,"(""index.jsp"", ""accessible at"", ""URL"")"
"For instance, if you create a subdirectory called layout, and put a file inside it called theLayout.jsp, then you could access that file from the outside, via this URL:",
"Inside the WEB-INF directory there are two important directories (classes and lib, and one important file (web.xml).","(""WEB-INF"", ""contains"", ""classes""); (""WEB-INF"", ""contains"", ""lib""); (""WEB-INF"", ""contains"", ""web.xml"")"
"The web.xml file contains information about the web application, which is used by the Java web server / servlet container in order to properly deploy and execute the web application.","(""web.xml"", ""contains"", ""web application""); (""Java web server"", ""uses"", ""web.xml""); (""Java web server"", ""deploys"", ""web application""); (""servlet container"", ""uses"", ""web.xml""); (""servlet container"", ""executes"", ""web application"")"
"For instance, the web.xml contains information about which servlets a web application should deploy, and what URL's they should be mapped to.","(""web.xml"", ""contains"", ""servlets""); (""web.xml"", ""contains"", ""URL mappings""); (""web application"", ""deploy"", ""servlets""); (""web application"", ""map"", ""URL's""); (""servlets"", ""mapped to"", ""URL's"")"
I will not get into more detail about the web.xml file here.,
The classes directory contains all compiled Java classes that are part of your web application.,"(""classes directory"", ""contains"", ""Java classes""); (""Java classes"", ""are part of"", ""web application"")"
"The classes should be located in a directory structure matching their package structure, just like if you were to run them directly from the commandline, or package them in a JAR file.","(""classes"", ""located in"", ""directory structure""); (""directory structure"", ""matching"", ""package structure""); (""package structure"", ""used in"", ""JAR file""); (""classes"", ""run from"", ""commandline""); (""classes"", ""packaged in"", ""JAR file"")"
"You could, however, also put your own classes into a JAR file, and locate it here, rather than putting those classes in the classes directory.","(""Classes"", ""put into"", ""JAR file""); (""JAR file"", ""located in"", ""classes directory""); (""Classes"", ""put in"", ""classes directory"")"
Perl or C. A Servlet is an ordinary Java class that implements a special Servlet interface.,"(""Servlet"", ""implements"", ""Servlet interface""); (""Servlet"", ""is a"", ""Java class"")"
"Here is a small servlet and JSP example to better illustrate the difference: public void service(ServletRequest request, ServletResponse response){ PrintWriter writer = ((HttpServletResponse) response)).getWriter(); writer.write(""<html>""); writer.write(""<body>""); writer.write(""<table>""); for(int i=0; i<10; i++){ writer.write(""<tr><td>""); writer.write("""" + i); writer.write(""</td></tr>""); } writer.write(""</table>""); writer.write(""</body>""); writer.write(""</html>""); } <html> <body> <table> <% for(int i=0; i<10; i++){ %><tr><td><%=i%></td></tr><% } %> </table> </body> </html> As you can see, the JSP example is much shorter than the Servlet example, and it is much easier to get an overview of the HTML.","(""ServletRequest"", ""is passed to"", ""service()""); (""ServletResponse"", ""is passed to"", ""service()""); (""HttpServletResponse"", ""extends"", ""ServletResponse""); (""PrintWriter"", ""is obtained from"", ""HttpServletResponse""); (""PrintWriter"", ""has method"", ""write()""); (""service()"", ""uses"", ""PrintWriter""); (""service()"", ""writes to"", ""HttpServletResponse"")"
This is illustrated below: component.control --> component.control --> component.control --> component.control --> component.control component.view --> component.view --> component.view --> component.view --> component.view First all components in the hierarchy executes their control logic (domain logic).,"(""component.control"", ""executes"", ""domain logic""); (""component.view"", ""executes"", ""component.view""); (""component.control"", ""contained in"", ""component""); (""component.view"", ""contained in"", ""component""); (""component"", ""has"", ""component.control""); (""component"", ""has"", ""component.view"")"
A Servlet is an ordinary Java class that implements a special Servlet interface.,"(""Servlet"", ""implements"", ""Servlet interface""); (""Servlet"", ""is a"", ""Java class"")"
JCTools is an open source toolkit and is released under the Apache License 2.0.,"(""JCTools"", ""is"", ""toolkit""); (""JCTools"", ""released under"", ""Apache License 2.0"")"
"A Fat JAR is a single JAR file that contains all the compiled Java classes from your project, and all compiled Java classes from all JAR files your project depends on (see Maven Dependencies).","(""Fat JAR"", ""contains"", ""Java classes""); (""Java classes"", ""from"", ""project""); (""project"", ""depends on"", ""JAR files""); (""JAR files"", ""from"", ""Maven Dependencies"")"
"Fat JARs are handy when you need to build an executable JAR file, e.g.","(""Fat JARs"", ""are handy when"", ""building an executable JAR file""); (""JAR file"", ""is built by"", ""executable""); (""Fat JARs"", ""need to"", ""build executable JAR file"")"
"This makes execution much easier, because you don't have to list all the JAR files your microservice depends on, on the classpath.","(""JAR"", ""depends on"", ""microservice""); (""microservice"", ""has"", ""classpath""); (""JAR"", ""located on"", ""classpath"")"
"When you execute Maven package phase with the maven-assembly-plugin configuration shown earlier, Maven will output a Fat JAR in the target directory, into which Maven outputs all of its other build products (e.g.","(""Maven"", ""uses"", ""maven-assembly-plugin""); (""Maven"", ""outputs"", ""Fat JAR""); (""maven-assembly-plugin"", ""configures"", ""Maven""); (""Maven"", ""outputs to"", ""target directory"")"
"The list contains more than 1.300 Maven archetypes, so it is not really that easy to find the archetype you need.","(""Maven"", ""contains"", ""archetypes""); (""archetypes"", ""are found in"", ""list""); (""list"", ""contains"", ""Maven archetypes"")"
"Too look at the list of available Maven archetypes, you can pipe the output into a file, and open that file in e.g.",
"Keep in mind, that when you execute the clean goal of Maven, the target directory is removed, meaning you lose all compiled classes from previous builds.","(""Maven"", ""has goal"", ""clean""); (""Maven"", ""executes"", ""clean goal""); (""clean goal"", ""removes"", ""target directory""); (""target directory"", ""contains"", ""compiled classes"")"
"That means, that Maven will have to build all of your project again from scratch, rather than being able to just compile the classes that were changed since last build.","(""Maven"", ""will have to build"", ""project""); (""Maven"", ""build"", ""classes""); (""project"", ""have"", ""classes""); (""Maven"", ""compile"", ""classes"")"
"However, sometimes it can be nice to have a clean, fresh build, e.g.",
The pom.xml file is the Maven POM file (Project Object Model).,"(""pom.xml"", ""is"", ""Maven POM file""); (""Maven POM file"", ""represents"", ""Project Object Model"")"
The .mvn directory is a directory where you can put some Maven configuration files.,
One of these Maven configuration files is the jvm.config file which can be used to configure the Java VM that is used by Maven to build your project.,"(""Maven"", ""uses"", ""Java VM""); (""jvm.config"", ""configures"", ""Java VM""); (""Maven"", ""uses"", ""jvm.config""); (""Java VM"", ""built by"", ""Maven""); (""Maven"", ""builds"", ""project""); (""jvm.config"", ""belongs to"", ""Maven"")"
The resource files will be available for loading via the classpath.,"(""Resource files"", ""loaded via"", ""Classpath"")"
The default Java compiler version used by Maven is Java 1.5 .,"(""Maven"", ""uses"", ""Java 1.5"")"
"To make Maven compile your Java code with a newer version of the Java compiler, you need to specify the Java compiler explicitly in your project's POM file (pom.xml).","(""Maven"", ""uses"", ""Java""); (""Java"", ""has"", ""compiler""); (""Maven"", ""compiles"", ""Java code""); (""Project"", ""has"", ""POM file""); (""POM file"", ""is"", ""pom.xml"")"
Notice also that the version of the Maven Java compiler plugin has changed from 3.6.1 to 3.8.0 .,"(""Maven Java compiler plugin"", ""has version"", ""3.6.1""); (""Maven Java compiler plugin"", ""has version"", ""3.8.0""); (""Maven Java compiler plugin"", ""changed version from"", ""3.6.1""); (""Maven Java compiler plugin"", ""changed version to"", ""3.8.0"")"
The first version of this Maven tutorial is based on Maven 3.6.3.,"(""Maven"", ""hasVersion"", ""Maven 3.6.3"")"
The POM file is named pom.xml and should be located in the root directory of your project.,"(""pom.xml"", ""located in"", ""root directory""); (""root directory"", ""contains"", ""pom.xml"")"
"This command first executes the clean build life cycle, which removes compiled classes from the Maven output directory, and then it executes the install build phase.","(""Maven"", ""executes"", ""clean build life cycle""); (""clean build life cycle"", ""removes"", ""compiled classes""); (""compiled classes"", ""removed from"", ""Maven output directory""); (""Maven"", ""executes"", ""install build phase""); (""clean build life cycle"", ""followed by"", ""install build phase"")"
These JAR files are needed on the classpath when you compile your project code.,"(""JAR files"", ""needed on"", ""classpath""); (""project code"", ""compile"", ""classpath""); (""classpath"", ""used during"", ""compilation"")"
"The example above needs the org.jsoup group's jsoup artifact in version 1.7.1, and the junit group's junit artifact in version 4.8.1.","(""org.jsoup"", ""hasArtifact"", ""jsoup""); (""org.jsoup"", ""hasVersion"", ""1.7.1""); (""junit"", ""hasArtifact"", ""junit""); (""junit"", ""hasVersion"", ""4.8.1"")"
"Thus Maven only needs to download the dependencies once, even if multiple projects depends on them (e.g.","(""Maven"", ""depends on"", ""dependencies""); (""Maven"", ""downloads"", ""dependencies""); (""dependencies"", ""are used by"", ""projects""); (""projects"", ""depend on"", ""dependencies""); (""Maven"", ""manages"", ""dependencies"")"
Your Maven settings file is also located in your user-home/.m2 directory and is called settings.xml.,"(""Maven"", ""hasSettingsFile"", ""settings.xml""); (""settings.xml"", ""locatedIn"", "".m2 directory""); (""Maven"", ""usesDirectory"", "".m2 directory""); ("".m2 directory"", ""locatedIn"", ""user-home"")"
"The clean life cycle handles everything related to removing temporary files from the output directory, including generated source files, compiled classes, previous JAR files etc.","(""clean life cycle"", ""handles"", ""temporary files""); (""clean life cycle"", ""removes"", ""generated source files""); (""clean life cycle"", ""removes"", ""compiled classes""); (""clean life cycle"", ""removes"", ""JAR files""); (""output directory"", ""contains"", ""temporary files""); (""output directory"", ""contains"", ""generated source files""); (""output directory"", ""contains"", ""compiled classes""); (""output directory"", ""contains"", ""JAR files"")"
One way to choose what profile is being executed is in the settings.xml file.,"(""settings.xml"", ""contains"", ""profile"")"
"You do so by creating a simple Java class that extends a special Maven class, and then create a POM for the project.","(""Java"", ""extends"", ""Maven""); (""Maven"", ""has"", ""POM""); (""Java class"", ""creates"", ""POM""); (""Project"", ""has"", ""POM""); (""Java class"", ""extends"", ""Maven class"")"
It is the argument -Dmaven.test.skip=true that makes Maven skip the tests completely.,"(""Maven"", ""hasArgument"", ""-Dmaven.test.skip=true""); (""-Dmaven.test.skip=true"", ""controlsBehavior"", ""Maven""); (""Maven"", ""skipsTests"", ""tests"")"
To configure the Maven Surefire plugin to enable Java preview features you need the following configuration in your Maven POM file - in the <build><plugins>...</plugins></build> section:,"(""Maven Surefire plugin"", ""has configuration in"", ""Maven POM file""); (""Maven POM file"", ""contains section"", ""<build>""); (""<build>"", ""contains section"", ""<plugins>""); (""Maven Surefire plugin"", ""is configured in"", ""<plugins>"")"
To publish a JAR file with compiled Java classes to the Maven central repository you need to go through set of steps.,"(""JAR file"", ""published to"", ""Maven central repository""); (""compiled Java classes"", ""contained in"", ""JAR file""); (""Maven central repository"", ""requires"", ""set of steps"")"
You can find more information about creating and publishing a public key / priate key pair from the Sonatype producers page: https://central.sonatype.org/pages/producers.html.,
"For a full POM file, check out the pom.xml in this github repository: RION Ops for Java GitHub Repository","(""RION Ops"", ""contains"", ""pom.xml""); (""RION Ops"", ""located in"", ""github repository""); (""pom.xml"", ""part of"", ""RION Ops""); (""RION Ops"", ""available on"", ""GitHub Repository"")"
From Maven 3.3 and forward you can set the memory limits in a file called jvm.config located in the .mvn directory inside your project directory.,"(""Maven"", ""hasDirectory"", "".mvn""); ("".mvn"", ""containsFile"", ""jvm.config""); (""Maven"", ""hasVersion"", ""3.3""); (""jvm.config"", ""locatedIn"", "".mvn""); (""Maven"", ""usesFile"", ""jvm.config"")"
Inside the jvm.config file you need the following settings to be able to control the memory limits of Maven during a Maven build:,"(""jvm.config"", ""has setting"", ""Maven""); (""Maven"", ""has build"", ""build process""); (""Maven build"", ""has memory limits"", ""memory limits""); (""jvm.config"", ""controls"", ""memory limits"")"
"Once you have created the project root directory, create a file called pom.xml inside the directory.","(""pom.xml"", ""created inside"", ""project root directory""); (""project root directory"", ""contains"", ""pom.xml""); (""pom.xml"", ""located in"", ""project root directory"")"
"When you have created the pom.xml file inside the project root directory it is a good idea to just test that Maven works, and that Maven understands the pom.xml file.","(""pom.xml"", ""isLocatedIn"", ""project root directory""); (""pom.xml"", ""isUsedBy"", ""Maven""); (""Maven"", ""understands"", ""pom.xml"")"
"To test the pom.xml file, open a command prompt and change directory (cd) into the project root directory.",
Inside the helloworld directory (java package) insert a file named HelloWorld.java.,"(""helloworld"", ""contains"", ""HelloWorld.java""); (""HelloWorld.java"", ""is_in"", ""helloworld""); (""helloworld"", ""is_a"", ""package""); (""HelloWorld.java"", ""is_a"", ""class"")"
Maven will compile the Java source file and create a JAR file containing the compiled Java class.,"(""Maven"", ""compile"", ""Java source file""); (""Java source file"", ""create"", ""JAR file""); (""JAR file"", ""contain"", ""Java class"")"
"Inside the target directory you will find the finished JAR file, as well as lots of temporary files (e.g.",
The Mem Ops Bytes class represents a sequence of bytes from a byte array.,"(""Mem Ops Bytes"", ""represents"", ""byte array""); (""Mem Ops Bytes"", ""is a"", ""sequence of bytes""); (""byte array"", ""contains"", ""sequence of bytes""); (""Mem Ops Bytes"", ""is a"", ""class"")"
"To avoid fragmenting the Java heap with Bytes instances, the Bytes class is designed to be obtained from an ObjectPool .","(""Bytes"", ""is obtained from"", ""ObjectPool""); (""Bytes"", ""is designed to avoid"", ""Java heap""); (""Bytes"", ""is designed to be obtained from"", ""ObjectPool""); (""Java heap"", ""is avoided by"", ""Bytes""); (""ObjectPool"", ""provides"", ""Bytes"")"
"To use the Bytes class effectively you should create a BytesAllocatorAutoDefrag, a BytesFactory and an ObjectPool .","(""Bytes"", ""uses"", ""BytesAllocatorAutoDefrag""); (""Bytes"", ""uses"", ""BytesFactory""); (""Bytes"", ""uses"", ""ObjectPool"")"
To obtain a Bytes instance from the ObjectPool you simply call the ObjectPool instance() method.,"(""ObjectPool"", ""hasMethod"", ""instance()""); (""ObjectPool"", ""returns"", ""Bytes""); (""Bytes"", ""obtainedFrom"", ""ObjectPool"")"
Calling free() will free the Bytes instance back to the ObjectPool and the allocated bytes back to the BytesAllocatorAutoDefrag.,"(""Bytes"", ""has method"", ""free()""); (""free()"", ""uses"", ""ObjectPool""); (""free()"", ""uses"", ""BytesAllocatorAutoDefrag""); (""Bytes"", ""is allocated by"", ""BytesAllocatorAutoDefrag""); (""Bytes"", ""is managed by"", ""ObjectPool"")"
"In this section I will try to give you a few visual use case examples that shows how to use the Bytes class, and its fields.","(""Bytes"", ""has"", ""fields"")"
"The use cases are actually quite similar in how they use the Bytes class, even if they are doing different things.","(""Bytes"", ""used by"", ""use cases"")"
The Mem Ops BytesAllocatorAutoDefrag class is capable of allocating smaller sections (blocks) of a bigger byte array.,"(""MemOpsBytesAllocatorAutoDefrag"", ""is capable of allocating"", ""byte array""); (""MemOpsBytesAllocatorAutoDefrag"", ""allocates"", ""smaller sections""); (""smaller sections"", ""are part of"", ""bigger byte array"")"
"When you free a byte array section, the BytesAllocatorAutoDefrag class will automatically defragment its internal big byte array so the freed section is joined with adjacent free sections to form a larger free section from which future sections can be allocated.","(""BytesAllocatorAutoDefrag"", ""has method"", ""free""); (""BytesAllocatorAutoDefrag"", ""defragments"", ""big byte array""); (""BytesAllocatorAutoDefrag"", ""allocates"", ""byte array section""); (""big byte array"", ""has"", ""free sections""); (""free sections"", ""are joined to form"", ""larger free section""); (""BytesAllocatorAutoDefrag"", ""manages"", ""internal big byte array"")"
To use the BytesAllocatorAutoDefrag class you must first create an instance of it.,"(""BytesAllocatorAutoDefrag"", ""create instance of"", ""BytesAllocatorAutoDefrag"")"
"In order to allocate a block (section) of bytes from the underlying byte array, you call the allocate() method.","(""byte array"", ""has method"", ""allocate()"")"
"Once allocated, no other allocate() call can allocate the same block until it has been freed.","(""allocate()"", ""is called on"", ""block""); (""allocate()"", ""allocates"", ""block""); (""allocate()"", ""cannot be called on"", ""allocated block""); (""block"", ""is freed by"", ""free()""); (""allocate()"", ""is restricted by"", ""previous allocation""); (""block"", ""is allocated by"", ""allocate()""); (""free()"", ""frees"", ""block"")"
"The allocate() method returns the offset into the big, underlying byte array where the allocated block starts.","(""allocate()"", ""returns"", ""offset""); (""allocate()"", ""uses"", ""byte array""); (""byte array"", ""contains"", ""allocated block""); (""allocate()"", ""determines"", ""offset""); (""allocated block"", ""starts at"", ""offset"")"
You can get a reference to the underlying byte array via the getData() method.,"(""getData()"", ""is method of"", ""underlying byte array""); (""getData()"", ""returns"", ""byte array""); (""underlying byte array"", ""has method"", ""getData()"")"
"Once you have allocated a block of bytes from the BytesAllocatorAutoDefrag you can access it via the data array, from the offset returned by allocate() and until offset + length - 1.","(""BytesAllocatorAutoDefrag"", ""hasMethod"", ""allocate()""); (""allocate()"", ""returns"", ""offset""); (""BytesAllocatorAutoDefrag"", ""hasField"", ""data""); (""data"", ""isAccessibleFrom"", ""offset""); (""BytesAllocatorAutoDefrag"", ""uses"", ""offset""); (""BytesAllocatorAutoDefrag"", ""uses"", ""length"")"
The free() method takes the start and end offset of the block to free.,"(""free"", ""takes"", ""start offset""); (""free"", ""takes"", ""end offset""); (""free"", ""is a method of"", ""unknown class""); (""free"", ""has parameter"", ""start offset""); (""free"", ""has parameter"", ""end offset""); (""block"", ""has"", ""start offset""); (""block"", ""has"", ""end offset""); (""free"", ""frees"", ""block"")"
The Mem Ops BytesAllocatorManualDefrag class is capable of allocating smaller sections (blocks) of a bigger byte array.,"(""MemOpsBytesAllocatorManualDefrag"", ""is capable of allocating"", ""byte array""); (""MemOpsBytesAllocatorManualDefrag"", ""allocates"", ""smaller sections""); (""MemOpsBytesAllocatorManualDefrag"", ""allocates"", ""blocks"")"
"When you free a byte array section, the ByteArrayAllocatorAutoDefrag class will mark it as free, but will not defragment the underlying byte array until you explicitly to tell it to.","(""ByteArrayAllocatorAutoDefrag"", ""will mark as free"", ""byte array section""); (""ByteArrayAllocatorAutoDefrag"", ""will defragment"", ""underlying byte array"")"
To use the BytesAllocatorManualDefrag class you must first create an instance of it.,"(""BytesAllocatorManualDefrag"", ""instance of"", ""BytesAllocatorManualDefrag"")"
"Once you have allocated a block of bytes from the BytesAllocatorManualDefrag you can access it via the data array, from the offset returned by allocate() and until offset + length - 1.","(""BytesAllocatorManualDefrag"", ""allocate"", ""offset""); (""BytesAllocatorManualDefrag"", ""allocate"", ""length""); (""BytesAllocatorManualDefrag"", ""access"", ""data array""); (""data array"", ""accessed from"", ""offset""); (""data array"", ""accessed until"", ""offset + length - 1""); (""BytesAllocatorManualDefrag"", ""returns"", ""offset"")"
To defragment the free blocks you call the defragment() method of the BytesAllocatorManualDefrag .,"(""BytesAllocatorManualDefrag"", ""has method"", ""defragment()"")"
It is during such idle times you should call defragment() .,
"If your system is constantly very busy, there may never be an idle period during which to call defragment().","(""system"", ""is constantly very busy"", ""idle period""); (""system"", ""call"", ""defragment()""); (""system"", ""have"", ""idle period""); (""idle period"", ""during which to call"", ""defragment()"")"
Calling defragment() will most likely result in a longer pause than if you immediately defragment free blocks like the ByteArrayAllocatorAutoDefrag does.,"(""ByteArrayAllocatorAutoDefrag"", ""uses"", ""defragment""); (""defragment"", ""called by"", ""ByteArrayAllocatorAutoDefrag"")"
"Systems that need to create high numbers of objects at a rapid pace, but do not need all of these objects at the same time, can benefit from using object pools rather than instantiating the objects using the Java new XYZObject() .","(""Java"", ""uses"", ""object pools""); (""object pools"", ""alternative to"", ""Java new XYZObject()""); (""Systems"", ""use"", ""object pools""); (""Java new XYZObject()"", ""contrasted with"", ""object pools"")"
The Bytes class represents a byte sequence allocated from a shared byte array.,"(""Bytes"", ""represents"", ""byte sequence""); (""Bytes"", ""allocated from"", ""shared byte array""); (""byte sequence"", ""allocated from"", ""shared byte array"")"
The Mem Ops ObjectPool class is capable of pooling instances of objects which can be reused.,"(""Mem Ops ObjectPool"", ""is capable of pooling instances of"", ""objects""); (""Mem Ops ObjectPool"", ""is a"", ""class""); (""objects"", ""can be reused by"", ""Mem Ops ObjectPool"")"
To use the Mem Ops ObjectPool you must first create an instance of the com.nanosai.memops.objects.ObjectPool class.,"(""com.nanosai.memops.objects.ObjectPool"", ""instance of"", ""com.nanosai.memops.objects""); (""com.nanosai.memops.objects.ObjectPool"", ""used by"", ""Mem Ops""); (""com.nanosai.memops.objects.ObjectPool"", ""created by"", ""user"")"
Notice that the ObjectPool class constructor takes two parameters: The capacity and an IObjectFactory implementation.,"(""ObjectPool"", ""has constructor parameter"", ""capacity""); (""ObjectPool"", ""has constructor parameter"", ""IObjectFactory"")"
"As you can see, the IObjectFactory only contains a single method named instance().","(""IObjectFactory"", ""contains"", ""instance()"")"
The type returned from the instance() method is decided by you when you implement the IObjectFactory interface.,"(""IObjectFactory"", ""implements"", ""instance()""); (""IObjectFactory"", ""has method"", ""instance()""); (""instance()"", ""returns"", ""type""); (""IObjectFactory"", ""decides"", ""type"")"
You free an object instance for reuse by calling the ObjectPool free() method.,"(""ObjectPool"", ""has method"", ""free()""); (""ObjectPool"", ""calls method"", ""free()""); (""Object"", ""is managed by"", ""ObjectPool""); (""free()"", ""is method of"", ""ObjectPool"")"
"You just tell what module that contains the main class to run, and ModRun resolves and loads all its dependencies too.","(""ModRun"", ""resolves"", ""main class""); (""ModRun"", ""loads"", ""dependencies""); (""module"", ""contains"", ""main class""); (""main class"", ""has"", ""dependencies"")"
"By loading the classes of a module with its own ClassLoader, ModRun can control what classes are visible to each module.","(""ModRun"", ""loads"", ""ClassLoader""); (""ClassLoader"", ""loads"", ""classes""); (""Module"", ""has"", ""ClassLoader""); (""Module"", ""has"", ""classes""); (""ModRun"", ""controls"", ""classes""); (""ClassLoader"", ""controls"", ""visibility""); (""Module"", ""has"", ""visibility"")"
A module can only see the classes from itself or from its dependencies (modules) and transitive dependencies.,"(""module"", ""can see"", ""classes""); (""module"", ""has"", ""dependencies""); (""dependencies"", ""has"", ""transitive dependencies""); (""module"", ""can see"", ""dependencies""); (""module"", ""can see"", ""transitive dependencies"")"
"A module cannot see classes from modules ""above"" itself in the dependency graph.","(""module"", ""cannot see"", ""classes""); (""classes"", ""are from"", ""modules""); (""modules"", ""are in"", ""dependency graph""); (""dependency graph"", ""contains"", ""modules""); (""module"", ""is in"", ""dependency graph"")"
The JVM will consider classes loaded from the two different versions of the API as different classes because they are loaded with different ClassLoader instances.,"(""JVM"", ""considers"", ""classes""); (""classes"", ""loaded from"", ""API""); (""API"", ""has"", ""versions""); (""ClassLoader"", ""loads"", ""classes""); (""ClassLoader"", ""instances"", ""differ""); (""versions"", ""of API"", ""differ""); (""JVM"", ""uses"", ""ClassLoader instances""); (""classes"", ""loaded by"", ""ClassLoader instances""); (""ClassLoader instances"", ""are"", ""different"")"
Each instance of the module have the classes loaded from its dependency graph isolated from the other instances of the same module (at least it can - if you want to).,"(""module"", ""have"", ""classes""); (""module"", ""have"", ""dependency graph""); (""classes"", ""loaded from"", ""dependency graph""); (""module"", ""isolated from"", ""module""); (""dependency graph"", ""isolated from"", ""dependency graph"")"
Loading the classes from each module with its own ClassLoader makes application multi tenancy easier.,"(""ClassLoader"", ""loads"", ""classes""); (""application"", ""uses"", ""ClassLoader""); (""module"", ""has"", ""ClassLoader"")"
"ModRun can load multiple applications into the same JVM at the same time, and have their classes be completely isolated from each other, so one application cannot access the classes of another application.","(""ModRun"", ""load"", ""applications""); (""applications"", ""have"", ""classes""); (""classes"", ""be isolated from"", ""classes""); (""application"", ""access"", ""classes""); (""applications"", ""run in"", ""JVM""); (""JVM"", ""contain"", ""applications"")"
"Here is an example that creates a module from a Maven repository, loads a class from the module, creates an instance of the class and calls a method on the instance via reflection:","(""Module"", ""creates"", ""Maven repository""); (""Module"", ""loads"", ""Class""); (""Class"", ""creates instance of"", ""Instance""); (""Instance"", ""calls method on"", ""Method""); (""Method"", ""is called via"", ""Reflection"")"
Installing Netty in your Java project only requires that you download the Netty JAR files and include them on the classpath.,"(""Netty"", ""requires"", ""Java project""); (""Netty JAR files"", ""included in"", ""classpath""); (""Java project"", ""has"", ""classpath"")"
"A Netty EventLoop is a loop that keeps looking for new events, e.g.","(""Netty"", ""has"", ""EventLoop""); (""EventLoop"", ""looks for"", ""events"")"
"Third, the NioServerSocketChannel class instance is set on the ServerBootstrap instance.","(""NioServerSocketChannel"", ""is set on"", ""ServerBootstrap""); (""ServerBootstrap"", ""has instance"", ""NioServerSocketChannel""); (""NioServerSocketChannel"", ""is instance of"", ""ServerBootstrap"")"
Its method initChannel() is called whenever a new incoming TCP connection is accepted by the TCP server.,"(""TCP server"", ""has method"", ""initChannel()""); (""TCP server"", ""accepts"", ""TCP connection""); (""TCP connection"", ""triggers"", ""initChannel()"")"
"As you can see, the ChannelInitializer is added to the ServerBootstrap using the childHandler() method.","(""ServerBootstrap"", ""childHandler()"", ""ChannelInitializer"")"
The serverBootstrap.bind() method returns a ChannelFuture which can be used to know when the binding of the server (binding to local address and TCP port) is done.,"(""serverBootstrap"", ""bind"", ""ChannelFuture""); (""serverBootstrap"", ""bind"", ""local address""); (""serverBootstrap"", ""bind"", ""TCP port""); (""ChannelFuture"", ""used to know"", ""binding of the server"")"
"By calling sync() on the ChannelFuture the main thread that creates the server waits until the server has started, before continuing.","(""ChannelFuture"", ""has method"", ""sync()""); (""main thread"", ""calls"", ""sync()""); (""server"", ""starts"", ""ChannelFuture""); (""main thread"", ""waits for"", ""server""); (""main thread"", ""creates"", ""server""); (""ChannelFuture"", ""belongs to"", ""server"")"
The channelRead() method is called whenever data is received from the SocketChannel the HelloServerHandler instance is attached to.,"(""HelloServerHandler"", ""has method"", ""channelRead()""); (""SocketChannel"", ""has method"", ""channelRead()""); (""HelloServerHandler"", ""attached to"", ""SocketChannel""); (""SocketChannel"", ""receives"", ""data"")"
"As you can see, the channelRead() responds with ""Hello "" + whatever the client sent to the server.","(""channelRead"", ""responds with"", ""client""); (""channelRead"", ""sends to"", ""server""); (""client"", ""sends to"", ""server""); (""server"", ""receives from"", ""client""); (""channelRead"", ""includes"", ""Hello"")"
The channelReadComplete() method is called when there is no more data to read from the SocketChannel.,"(""SocketChannel"", ""has method"", ""channelReadComplete()""); (""SocketChannel"", ""has relationship with"", ""channelReadComplete()""); (""channelReadComplete()"", ""is called on"", ""SocketChannel"")"
The exceptionCaught() method is called if an exception is thrown while receiving or sending data from the SocketChannel.,"(""exceptionCaught"", ""is called by"", ""SocketChannel""); (""SocketChannel"", ""throws exception to"", ""exceptionCaught""); (""exceptionCaught"", ""handles exception from"", ""SocketChannel"")"
That means that you create a Java application with a class with a main() method and inside that application you create one of the Netty servers.,"(""Java application"", ""has"", ""class""); (""class"", ""has"", ""main() method""); (""application"", ""creates"", ""Netty servers""); (""Netty servers"", ""is created by"", ""Java application"")"
The RION Ops RionObjectReader class can read a RION Object field into a Java object.,"(""RION Ops RionObjectReader"", ""can read"", ""RION Object""); (""RION Ops RionObjectReader"", ""reads into"", ""Java object"")"
The easiest way to create an instance of the RionObjectReader is via the RionObjectReaderBuilder class.,"(""RionObjectReader"", ""created via"", ""RionObjectReaderBuilder""); (""RionObjectReaderBuilder"", ""creates"", ""RionObjectReader"")"
This class makes it easier to configure and create a RionObjectReader instance.,"(""RionObjectReader"", ""instance of"", ""This class""); (""RionObjectReader"", ""configured by"", ""This class""); (""This class"", ""creates"", ""RionObjectReader instance"")"
Here is an example of creating a RionObjectReader via the RionObjectReaderBuilder class:,"(""RionObjectReader"", ""created via"", ""RionObjectReaderBuilder""); (""RionObjectReaderBuilder"", ""creates"", ""RionObjectReader"")"
The RionObjectReader readCyclic() method reads a cyclic object graph stored as RION in a byte array.,"(""RionObjectReader"", ""has method"", ""readCyclic()""); (""RionObjectReader"", ""reads"", ""cyclic object graph""); (""readCyclic()"", ""reads"", ""RION""); (""readCyclic()"", ""stored in"", ""byte array""); (""RION"", ""stored in"", ""byte array""); (""RionObjectReader"", ""reads"", ""RION"")"
The RION Ops RionObjectWriter class makes it easy to write Java objects as a RION field to a byte array.,"(""RION Ops RionObjectWriter"", ""makes use of"", ""Java objects""); (""RION Ops RionObjectWriter"", ""writes to"", ""byte array""); (""RION Ops RionObjectWriter"", ""represents"", ""RION field"")"
"To use the RionObjectWriter you must first create an instance of the RionObjectWriter class, com.nanosai.rionops.rion.object.RionObjectWriter.","(""RionObjectWriter"", ""is instantiated from"", ""com.nanosai.rionops.rion.object.RionObjectWriter""); (""RionObjectWriter"", ""belongs to package"", ""com.nanosai.rionops.rion.object"")"
The easiest way to create a RionObjectWriter instance is via the RionObjectWriterBuilder class.,"(""RionObjectWriter"", ""created via"", ""RionObjectWriterBuilder""); (""RionObjectWriterBuilder"", ""creates"", ""RionObjectWriter"")"
"These examples build a RionObjectWriter which will serialize all fields (private, protected, default and public) found in the Pojo class to RION.","(""RionObjectWriter"", ""will serialize"", ""Pojo""); (""RionObjectWriter"", ""serialize to"", ""RION""); (""Pojo"", ""has fields"", ""fields""); (""Pojo"", ""has fields type"", ""private""); (""Pojo"", ""has fields type"", ""protected""); (""Pojo"", ""has fields type"", ""default""); (""Pojo"", ""has fields type"", ""public""); (""RION"", ""is serialization target of"", ""RionObjectWriter"")"
"Once created, the RionObjectWriter instance then only serialize objects of the given class.","(""RionObjectWriter"", ""instance of"", ""RionObjectWriter""); (""RionObjectWriter"", ""serialize"", ""objects""); (""RionObjectWriter"", ""given class"", ""class"")"
To serialize objects of multiple classes you will have to create a RionObjectWriter for each class.,"(""RionObjectWriter"", ""created for"", ""class""); (""RionObjectWriter"", ""serializes"", ""objects""); (""class"", ""has"", ""RionObjectWriter"")"
Note: You only need one RionObjectWriter per root class you want to serialize.,"(""RionObjectWriter"", ""per"", ""root class"")"
"If a given class represents an object graph consisting of other classes referenced from within the root class (or any of its field's classes recursively), all of these classes will be serialized too.","(""Class"", ""represents"", ""Object Graph""); (""Root Class"", ""has"", ""Field""); (""Field"", ""has"", ""Classes""); (""Class"", ""references"", ""Classes""); (""Class"", ""is serialized with"", ""Classes"")"
"To elaborate, in the example above, if the Pojo class contained fields of class Pojo2 and Pojo3 internally, these would be serialized too because they are part of an object graph rooted by a Pojo object.","(""Pojo"", ""contains"", ""Pojo2""); (""Pojo"", ""contains"", ""Pojo3""); (""Pojo"", ""has"", ""object graph"")"
The RionObjectWriter contains an writeAcyclic() and writeCyclic() method for these purposes.,"(""RionObjectWriter"", ""contains"", ""writeAcyclic()""); (""RionObjectWriter"", ""contains"", ""writeCyclic()"")"
The RionObjectWriter writeAcyclic() can write an acyclic object graph as RION into a byte array.,"(""RionObjectWriter"", ""has method"", ""writeAcyclic()""); (""RionObjectWriter"", ""writes"", ""acyclic object graph""); (""RionObjectWriter"", ""writes to"", ""byte array""); (""writeAcyclic()"", ""returns"", ""RION""); (""RION"", ""is written to"", ""byte array"")"
"If the object is part of a cyclic (not acyclic) object graph, the writeAcyclic() method will enter an infinite recursion and eventually crash.","(""object"", ""has method"", ""writeAcyclic()""); (""writeAcyclic()"", ""part of"", ""object graph""); (""object graph"", ""is"", ""cyclic""); (""object graph"", ""is not"", ""acyclic""); (""writeAcyclic()"", ""enters"", ""infinite recursion"")"
Here is an example of writing an object using the RionObjectWriter writeAcyclic() method:,"(""RionObjectWriter"", ""has method"", ""writeAcyclic()"")"
The RionObjectWriter writeCyclic() method can write a cyclic object graph as RION to a byte array.,"(""RionObjectWriter"", ""hasMethod"", ""writeCyclic()""); (""RionObjectWriter.writeCyclic()"", ""writes"", ""cyclic object graph""); (""RionObjectWriter.writeCyclic()"", ""writesTo"", ""byte array"")"
Here is an example of writing a cyclic object graph to RION using the RionObjectWriter writeCyclic() method.,"(""RionObjectWriter"", ""hasMethod"", ""writeCyclic()"")"
"The RION Ops RionReader class, com.nanosai.rionops.rion.read.RionReader makes it easy to write RION fields from a Java byte array.","(""RionReader"", ""is part of"", ""com.nanosai.rionops.rion.read""); (""RionReader"", ""reads from"", ""Java byte array""); (""RionReader"", ""belongs to package"", ""com.nanosai.rionops.rion.read"")"
Setting a source byte array is done via the method setSource().,"(""setSource()"", ""is a method of"", ""unknown class""); (""unknown class"", ""has method"", ""setSource()"")"
Here is an example of setting the source byte array on a RionReader via its setSource() method:,"(""RionReader"", ""has method"", ""setSource()""); (""RionReader"", ""uses method"", ""setSource()""); (""RionReader"", ""setSource()"", ""source byte array"")"
"Third, the example loops as long as hasNext() returns true, and iterates through all the RION fields in the source byte array, one by one.","(""hasNext()"", ""returns"", ""true""); (""example"", ""loops"", ""hasNext()""); (""example"", ""iterates"", ""RION fields""); (""RION fields"", ""located in"", ""source byte array"")"
You can read a RION Bytes field using the RionReader readBytes() method.,"(""RionReader"", ""has_method"", ""readBytes()""); (""RionReader"", ""uses"", ""RION Bytes""); (""RION Bytes"", ""is_read_by"", ""RionReader.readBytes()"")"
The readBytes() method will read the bytes of the RION Bytes field into this byte array.,"(""readBytes()"", ""is method of"", ""RION""); (""RION"", ""has field"", ""Bytes""); (""readBytes()"", ""reads"", ""Bytes""); (""Bytes"", ""is field of"", ""RION""); (""readBytes()"", ""belongs to"", ""RION"")"
Here is an example of reading a RION Bytes field with the readBytes() method:,"(""RION Bytes field"", ""has method"", ""readBytes()"")"
The value returned by the readBytes() method is the number of bytes read into the destination byte array.,"(""readBytes()"", ""returns"", ""number of bytes""); (""readBytes()"", ""is method of"", ""unspecified class""); (""destination byte array"", ""is parameter of"", ""readBytes()"")"
"The readBytes() method also comes in a version where you can specify the offset into the destination byte array to start writing the Bytes field value, and a maximal length (number of bytes) to read.","(""readBytes()"", ""comes in a version"", ""readBytes() with offset and length""); (""readBytes() with offset and length"", ""has parameters"", ""offset""); (""readBytes() with offset and length"", ""has parameters"", ""length""); (""readBytes()"", ""reads"", ""Bytes field value""); (""Bytes field value"", ""is written to"", ""destination byte array""); (""destination byte array"", ""has"", ""offset""); (""readBytes() with offset and length"", ""reads up to"", ""maximal length"")"
Here is an example of reading a RION Bytes field using that readBytes() method:,"(""RION Bytes field"", ""uses"", ""readBytes() method""); (""readBytes() method"", ""belongs to"", ""unknown class""); (""RION Bytes field"", ""read by"", ""readBytes() method"")"
"This example tells the readBytes() method to start writing the Bytes field value into the destination array from offset 2, and to maximally read 10 bytes.","(""readBytes()"", ""starts writing into"", ""destination array""); (""readBytes()"", ""reads"", ""Bytes field value""); (""readBytes()"", ""has offset"", ""2""); (""readBytes()"", ""has maximum read"", ""10 bytes"")"
To read a RION Boolean field you can use the RionReader readBoolean() method.,"(""RionReader"", ""has_method"", ""readBoolean()""); (""RionReader"", ""uses"", ""readBoolean()""); (""RionReader.readBoolean()"", ""belongs_to"", ""RionReader"")"
Here is an example of reading RION Boolean field using the RionReader readBoolean() method:,"(""RionReader"", ""has method"", ""readBoolean()"")"
Here is an example of reading a Java Boolean object using the RionReader readBooleanObj() method:,"(""RionReader"", ""hasMethod"", ""readBooleanObj()""); (""readBooleanObj()"", ""returns"", ""Boolean""); (""RionReader"", ""reads"", ""Boolean"")"
To read a RION Int64 field you can use the RionReader readInt64() method.,"(""RionReader"", ""has method"", ""readInt64()""); (""RION Int64 field"", ""can be read by"", ""RionReader.readInt64()""); (""RionReader.readInt64()"", ""reads"", ""RION Int64 field"")"
Here is an example of reading a RION Int64 field using the RionReader readInt64() method:,"(""RionReader"", ""has method"", ""readInt64()""); (""RionReader"", ""reads"", ""RION Int64 field""); (""readInt64()"", ""is method of"", ""RionReader""); (""RION Int64 field"", ""is read by"", ""readInt64()""); (""RION Int64 field"", ""is accessed through"", ""RionReader"")"
Here is an example of reading a RION Int64 field into a Java Long object using the RionReader readInt64Obj() method:,"(""RionReader"", ""hasMethod"", ""readInt64Obj()""); (""RionReader"", ""reads"", ""RION Int64 field""); (""readInt64Obj()"", ""returns"", ""Java Long object"")"
These methods are named readFloat32() and readFloat64() Here are two examples of reading a RION Float field into a Java float and double variable:,"(""readFloat32()"", ""isMethodOf"", ""RION Float field""); (""readFloat64()"", ""isMethodOf"", ""RION Float field""); (""readFloat32()"", ""returns"", ""Java float""); (""readFloat64()"", ""returns"", ""Java double"")"
Use the readFloat32Obj() or readFloat64Obj() methods if the RION Float field can be set to null in your concrete use case.,"(""RION Float field"", ""has method"", ""readFloat32Obj()""); (""RION Float field"", ""has method"", ""readFloat64Obj()"")"
The RionReader class has a method named readUtf8String() which can read a RION UTF-8 field into a Java String.,"(""RionReader"", ""has method"", ""readUtf8String()""); (""RionReader"", ""reads"", ""RION UTF-8 field""); (""readUtf8String()"", ""returns"", ""Java String""); (""RionReader"", ""uses"", ""Java String"")"
Here is an example of reading a RION UTF-8 field into a Java String with readUtf8String() :,"(""RION"", ""contains"", ""UTF-8 field""); (""Java"", ""uses"", ""readUtf8String()""); (""readUtf8String()"", ""returns"", ""Java String"")"
The readUtcCalendar() method of the RionReader class can read a RION UTC field as a Java Calendar instance.,"(""RionReader"", ""hasMethod"", ""readUtcCalendar()""); (""RionReader"", ""reads"", ""RION UTC field""); (""readUtcCalendar()"", ""returns"", ""Java Calendar instance""); (""RionReader"", ""uses"", ""Java Calendar"")"
When reading a composite RION field you need to use the RionReader moveInto() and moveOutOf() methods.,"(""RionReader"", ""hasMethod"", ""moveInto()""); (""RionReader"", ""hasMethod"", ""moveOutOf()"")"
"The moveInto() method will move the RionReader's internal state ""into"" the given RION field.","(""RionReader"", ""hasMethod"", ""moveInto()""); (""RionReader"", ""uses"", ""RION""); (""moveInto()"", ""affects"", ""RION field""); (""RionReader"", ""hasInternalState"", ""internal state"")"
"That means, that the hasNext() method now returns true as long as the RION field you moved into has more nested fields.","(""RION"", ""has"", ""nested fields""); (""hasNext()"", ""returns"", ""true""); (""RION field"", ""has"", ""nested fields"")"
"The moveOutOf() method moves the RionReader's internal state ""out of"" the given RION field.","(""RionReader"", ""has method"", ""moveOutOf()""); (""RionReader"", ""uses"", ""RION field""); (""RION field"", ""is used by"", ""RionReader""); (""RionReader"", ""has internal state"", ""internal state""); (""moveOutOf()"", ""is method of"", ""RionReader"")"
Now the hasNext() method will return true if the parent scope (parent RION field or the total source byte array for the RionReader) has more RION fields.,"(""RionReader"", ""has method"", ""hasNext()""); (""RION field"", ""has parent"", ""parent RION field""); (""RionReader"", ""reads"", ""total source byte array""); (""RionReader"", ""has"", ""parent scope""); (""parent scope"", ""is"", ""parent RION field""); (""parent scope"", ""is"", ""total source byte array""); (""RION field"", ""is in"", ""parent scope"")"
"At the outer nesting level (top level) of the above RION field sequence, the RionReader hasNext() will return true, as long as there are RION fields at this nesting level.","(""RionReader"", ""has method"", ""hasNext()""); (""RION field sequence"", ""has nesting level"", ""top level""); (""RionReader"", ""operates on"", ""RION fields""); (""RION fields"", ""are at"", ""nesting level""); (""RionReader.hasNext()"", ""returns"", ""true"")"
"Now the RionReader hasNext() method returns true 2 times, because there are 2 nested RION fields inside the RION Object field.","(""RionReader"", ""has method"", ""hasNext()""); (""RION Object"", ""contains"", ""RION fields""); (""RION fields"", ""are nested"", ""RION fields""); (""RionReader"", ""reads"", ""RION Object"")"
"Once the hasNext() method returns false, you ""move out of"" the composite RION field again.","(""RION"", ""has method"", ""hasNext()"")"
You can improve on the above code in various ways - e.g.,
"To read a RION Table field, you have to ""move into"" it with moveInto(), then read the first field which is an Int64 RION field representing the row count, and then 1 to N Key or Key Short fields representing the column headers (column names / keys) of the table, and then finally 1 to N fields per row.","(""RION Table"", ""has field"", ""Int64 RION field""); (""RION Table"", ""has field"", ""Key field""); (""RION Table"", ""has field"", ""Key Short field""); (""RION Table"", ""accessed by"", ""moveInto()""); (""Int64 RION field"", ""represents"", ""row count""); (""Key field"", ""represents"", ""column header""); (""Key Short field"", ""represents"", ""column header""); (""RION Table"", ""contains"", ""column headers""); (""RION Table"", ""contains"", ""row"")"
The RionReader class contains a method named isNull() which will tell you if the current RION field pointed to by the RionReader has the field value null.,"(""RionReader"", ""contains"", ""isNull()""); (""RionReader"", ""has method"", ""isNull()""); (""RionReader"", ""points to"", ""RION field""); (""RION field"", ""has value"", ""null""); (""RionReader"", ""uses"", ""isNull()""); (""RionReader"", ""has method"", ""isNull()"")"
Here is an example of checking if a given RION field is null via the RionReader isNull() method:,"(""RionReader"", ""hasMethod"", ""isNull()""); (""RionReader"", ""checks"", ""RION field""); (""isNull()"", ""belongsTo"", ""RionReader"")"
"The RION Ops RionWriter class, com.nanosai.rionops.rion.write.RionWriter, enables you to write RION fields easily and efficiently.","(""RionWriter"", ""enables"", ""writing RION fields""); (""RionWriter"", ""belongs to"", ""com.nanosai.rionops.rion.write""); (""com.nanosai.rionops.rion.write"", ""contains"", ""RionWriter"")"
You set the destination byte array of the RionWriter using the setDestination() method.,"(""RionWriter"", ""uses"", ""setDestination()""); (""RionWriter"", ""has method"", ""setDestination()""); (""setDestination()"", ""sets"", ""destination byte array"")"
The RionWriter contains a method named writeBytes() which can be used to write a RION Bytes field to the destination byte array.,"(""RionWriter"", ""contains"", ""writeBytes()""); (""RionWriter"", ""uses"", ""writeBytes()""); (""writeBytes()"", ""writes"", ""RION Bytes""); (""RionWriter"", ""writes to"", ""destination byte array"")"
Here is a Java example of writing a RION Bytes field from a byte array using the RionWriter writeBytes() method:,"(""RionWriter"", ""hasMethod"", ""writeBytes()""); (""RionWriter"", ""writes"", ""byte array""); (""byte array"", ""isWrittenBy"", ""RionWriter.writeBytes()"")"
The writeBytes() method also exists in a version that takes a source offset and source length which specifies from what offset and how many bytes forward in the source byte array to write to the RION Bytes field in the destination byte array.,"(""writeBytes()"", ""exists in"", ""version""); (""version"", ""takes"", ""source offset""); (""version"", ""takes"", ""source length""); (""source offset"", ""specifies"", ""offset""); (""source length"", ""specifies"", ""bytes""); (""writeBytes()"", ""writes to"", ""RION Bytes field""); (""RION Bytes field"", ""located in"", ""destination byte array""); (""destination byte array"", ""receives"", ""bytes""); (""source byte array"", ""provides"", ""bytes""); (""writeBytes()"", ""uses"", ""source byte array""); (""writeBytes()"", ""uses"", ""destination byte array"")"
The RionWriter method writeBoolean() writes a boolean value (true / false) as a RION Boolean field to the destination byte array.,"(""RionWriter"", ""hasMethod"", ""writeBoolean()""); (""RionWriter"", ""writesTo"", ""destination byte array""); (""writeBoolean()"", ""writes"", ""RION Boolean field"")"
Here is a Java example of writing a RION Boolean field using the RionWriter writeBoolean() method:,"(""RionWriter"", ""has method"", ""writeBoolean()""); (""RionWriter"", ""uses"", ""Boolean""); (""writeBoolean()"", ""is method of"", ""RionWriter"")"
The RionWriter method writeInt64() will write a 64 bit integer as a RION IntPos or IntNeg field to the destination byte array.,"(""RionWriter"", ""hasMethod"", ""writeInt64()""); (""RionWriter"", ""writesTo"", ""destination byte array""); (""writeInt64()"", ""writes"", ""64 bit integer""); (""64 bit integer"", ""isTypeOf"", ""RION IntPos""); (""64 bit integer"", ""isTypeOf"", ""RION IntNeg"")"
"Here are two examples of writing int64 values (long values) as RION IntPos and IntNeg fields to the destination byte array, using the RionWriter writeInt64() method:","(""RionWriter"", ""uses"", ""writeInt64()""); (""RionWriter"", ""writes"", ""IntPos""); (""RionWriter"", ""writes"", ""IntNeg""); (""RionWriter"", ""has method"", ""writeInt64()"")"
The RionWriter methods writeFloat32() and writeFloat64() writes a 32 bit and 64 bit floating point number as a RION Float field to the destination byte array.,"(""RionWriter"", ""hasMethod"", ""writeFloat32()""); (""RionWriter"", ""hasMethod"", ""writeFloat64()""); (""writeFloat32()"", ""writes"", ""RION Float""); (""writeFloat64()"", ""writes"", ""RION Float""); (""RION Float"", ""isWrittenTo"", ""destination byte array"")"
"Here are two examples of writing a 32 bit and 64 bit floating point number as RION Float fields to the destination byte array, using the RionWriter writeFloat32() and writeFloat64() methods:","(""RionWriter"", ""uses"", ""writeFloat32()""); (""RionWriter"", ""uses"", ""writeFloat64()""); (""RionWriter"", ""writes"", ""Float""); (""writeFloat32()"", ""writes"", ""32 bit floating point number""); (""writeFloat64()"", ""writes"", ""64 bit floating point number"")"
The RionWriter method writeUtf8() writes a Java String as a RION UTF-8 or UTF-8-Short field to the destination byte array.,"(""RionWriter"", ""hasMethod"", ""writeUtf8()""); (""RionWriter"", ""writesTo"", ""byte array""); (""writeUtf8()"", ""isMethodOf"", ""RionWriter""); (""Java String"", ""isWrittenBy"", ""writeUtf8()""); (""writeUtf8()"", ""writes"", ""RION UTF-8 field""); (""writeUtf8()"", ""writes"", ""RION UTF-8-Short field"")"
Here is an example of writing a RION UTF-8 field to a byte array using the RionWriter writeUtf8() method:,"(""RionWriter"", ""hasMethod"", ""writeUtf8()""); (""RionWriter"", ""writesTo"", ""byte array""); (""writeUtf8()"", ""isMethodOf"", ""RionWriter""); (""RionWriter"", ""usesEncoding"", ""RION UTF-8"")"
The RionWriter method writeUtc() method writes a date and time in the shape of a Java Calendar as a RION UTC field (UTC date-time) to the destination byte array.,"(""RionWriter"", ""hasMethod"", ""writeUtc()""); (""RionWriter"", ""writes"", ""RION UTC field""); (""writeUtc()"", ""writes"", ""Java Calendar""); (""writeUtc()"", ""outputsTo"", ""destination byte array"")"
Here is an example of writing a Java Calendar as a RION UTC field to the destination byte array using the RionWriter writeUtc() method:,"(""RionWriter"", ""has method"", ""writeUtc()""); (""Java Calendar"", ""written by"", ""RionWriter.writeUtc()""); (""RionWriter.writeUtc()"", ""writes"", ""Java Calendar"")"
The RionWriter class has functionality that helps you reserve length bytes for composite RION fields and jump back up and fill them in correctly later.,"(""RionWriter"", ""has"", ""functionality""); (""RionWriter"", ""helps"", ""reserve length bytes""); (""RionWriter"", ""jump back"", ""fill them in""); (""RION fields"", ""filled in"", ""RionWriter""); (""RionWriter"", ""reserve"", ""RION fields"")"
One of the mechanisms in the RionWriter class that helps you reserve length bytes and set their value correctly later requires an internal stack to keep track of where the reserved length bytes are located.,"(""RionWriter"", ""has mechanism"", ""internal stack""); (""RionWriter"", ""requires"", ""internal stack""); (""internal stack"", ""keeps track of"", ""reserved length bytes"")"
Here is an example of setting the nested field stack for a RionWriter via its setNestedFieldStack() method:,"(""RionWriter"", ""has method"", ""setNestedFieldStack()"")"
"However, it is possible for all RION fields to take the value null, so it is possible to include e.g.",
"The writeObjectBeginPush() method writes the beginning of the RION Object field, and reserves and reserve as many length bytes as you pass to it as parameter (2 in the example above).","(""writeObjectBeginPush()"", ""is a method of"", ""unknown class""); (""writeObjectBeginPush()"", ""writes"", ""RION Object field""); (""writeObjectBeginPush()"", ""reserves"", ""length bytes""); (""unknown class"", ""has method"", ""writeObjectBeginPush()""); (""RION Object field"", ""is written by"", ""writeObjectBeginPush()""); (""length bytes"", ""is reserved by"", ""writeObjectBeginPush()"")"
"The writeObjectEndPop() method pops the RION Object field start index off the nested field stack, calculates the total length of the Object field and writes the total Object field length into its reserved length bytes.","(""writeObjectEndPop"", ""pops"", ""RION Object field start index""); (""writeObjectEndPop"", ""calculates"", ""total length of the Object field""); (""writeObjectEndPop"", ""writes"", ""total Object field length""); (""total Object field length"", ""is written to"", ""reserved length bytes""); (""RION Object field start index"", ""is stored in"", ""nested field stack"")"
There are also versions of the writeObjectBegin() and writeObjectEnd() method that does not use the internal nested field stack.,"(""writeObjectBegin()"", ""is version of"", ""writeObjectEnd()""); (""writeObjectBegin()"", ""uses"", ""internal nested field stack""); (""writeObjectEnd()"", ""uses"", ""internal nested field stack"")"
The String arguments passed to the main() method are the command line arguments passed to the application when it is executed.,"(""String"", ""passed to"", ""main()""); (""String"", ""passed to"", ""application""); (""main()"", ""executed by"", ""application""); (""command line arguments"", ""passed to"", ""application""); (""command line arguments"", ""passed to"", ""main()""); (""String"", ""are"", ""command line arguments"")"
The Main argument is the name of the object to run the main() method of.,"(""Main"", ""has method"", ""main()""); (""main()"", ""is method of"", ""Main""); (""Main"", ""runs"", ""main()"")"
"The arguments ""arg1"" and ""arg2"" are passed in the String array to the main() method.","(""String array"", ""passed to"", ""main()""); (""main()"", ""receives"", ""arg1""); (""main()"", ""receives"", ""arg2""); (""String array"", ""contains"", ""arg1""); (""String array"", ""contains"", ""arg2"")"
The until keyword makes sure to only iterate until myArray.length - 1.,"(""myArray"", ""has property"", ""length"")"
"If you had needed i to also take the value of myArray.length in the final iteration, you could have used the to keyword instead of the until keyword.",
"This means that you can define classes in Scala, and instantiate objects of these classes.","(""Scala"", ""defines"", ""classes""); (""classes"", ""are instantiated as"", ""objects"")"
"That means, that a class defines what information objects of that class holds, and what behaviour (methods) it exposes.","(""class"", ""defines"", ""information""); (""class"", ""exposes"", ""methods""); (""class"", ""holds"", ""objects"")"
The other aspects of Scala classes will be covered in separate texts.,"(""Scala"", ""hasAspects"", ""classes""); (""classes"", ""areCoveredIn"", ""separateTexts""); (""separateTexts"", ""cover"", ""Scalaclasses"")"
Here I have just shown you how to declare a method inside a class.,"(""class"", ""has"", ""method""); (""method"", ""declared in"", ""class""); (""class"", ""contains"", ""method"")"
"Notice how this addToMyField() method does not have the equals sign, and no return type specified.",
"When an exception is thrown from inside the throwsException() method, the execution is interrupted and the execution jumps to the catch clause surrounding the code that threw the exception.","(""throwsException()"", ""is part of"", ""exception""); (""catch clause"", ""surrounds"", ""code""); (""exception"", ""is thrown by"", ""throwsException()""); (""execution"", ""jumps to"", ""catch clause""); (""throwsException()"", ""interrupts"", ""execution"")"
"In the example above, when the throwsException() method is called, and it throws an exception, the statement below the throwsException() method call is never executed.","(""throwsException()"", ""is called by"", ""unknown""); (""throwsException()"", ""throws"", ""exception"")"
"In the example above, only one exception is caught, Exception which is the superclass of most exceptions.","(""Exception"", ""is superclass of"", ""most exceptions"")"
"Rather than compute the .toUpperCase() value twice, by nesting them inside each if-statement, the uppercase version of aString is computed just once, and assigned to the variable aStringUC.","(""aString"", ""has method"", ""toUpperCase()""); (""aString"", ""assigned to"", ""aStringUC""); (""toUpperCase()"", ""called on"", ""aString"")"
"You can thus use all the classes of the Java SDK's in Scala, and also your own, custom Java classes, or your favourite Java open source projects.","(""Java SDK"", ""contains"", ""classes""); (""Scala"", ""uses"", ""Java SDK""); (""Custom Java classes"", ""used by"", ""Scala""); (""Java open source projects"", ""used by"", ""Scala"")"
"Instead a Scala class can have what is called a singleton object, or sometime a companion object.","(""Scala class"", ""can have"", ""singleton object""); (""Scala class"", ""can have"", ""companion object"")"
"When a singleton object is named the same as a class, it is called a companion object.","(""Singleton"", ""isNamedAs"", ""Class""); (""CompanionObject"", ""isCalled"", ""Singleton""); (""CompanionObject"", ""hasName"", ""Class""); (""Class"", ""hasCompanionObject"", ""CompanionObject""); (""Singleton"", ""isTypeOf"", ""Object""); (""Class"", ""hasSingleton"", ""Singleton"")"
A companion object must be defined inside the same source file as the class.,"(""Companion object"", ""defined inside"", ""Class""); (""Class"", ""has"", ""Companion object""); (""Companion object"", ""belongs to"", ""Source file""); (""Class"", ""belongs to"", ""Source file"")"
"In this class you can both instantiate Main and call sayHelloWorld() or call the sayHi() method on the companion object directly, like this:","(""Main"", ""hasMethod"", ""sayHelloWorld()""); (""Main"", ""hasCompanionObject"", ""Main Companion""); (""Main Companion"", ""hasMethod"", ""sayHi()"")"
This also means that you can use all Java classes in your Scala code.,"(""Java"", ""used in"", ""Scala""); (""Java classes"", ""used in"", ""Scala code"")"
The Scala version used in the examples in this tutorial is Scala 2.8.0 .,"(""Scala"", ""version"", ""Scala 2.8.0"")"
"The Stream Ops StreamOps class, com.nanosai.streamops.StreamOps, provides a convenient facade for the Stream Ops API.","(""StreamOps"", ""provides"", ""Stream Ops API""); (""com.nanosai.streamops.StreamOps"", ""is"", ""StreamOps"")"
The StreamOps class can create the most commonly used components of the Stream Ops API.,"(""StreamOps"", ""can create"", ""Stream Ops API"")"
"Thus, the StreamOps class is a good place to start, both when using Stream Ops, but also when exploring what you can do with Stream Ops and how it works.","(""StreamOps"", ""is a part of"", ""Stream Ops""); (""StreamOps"", ""used for"", ""exploring Stream Ops""); (""StreamOps"", ""provides"", ""information on how Stream Ops works"")"
In this tutorial we will only go over the components the StreamOps and related factory classes can create.,"(""StreamOps"", ""can create"", ""components""); (""factory classes"", ""can create"", ""components""); (""StreamOps"", ""is related to"", ""factory classes"")"
"You can create instances of these classes via the new operator, or you can use a StreamStorageFactory.","(""StreamStorageFactory"", ""creates"", ""instances of classes""); (""StreamStorageFactory"", ""uses"", ""new operator""); (""classes"", ""created via"", ""new operator""); (""classes"", ""created by"", ""StreamStorageFactory"")"
You can create a StreamStorageFS instance via the StreamStorageFactory createStreamStorageFS() method.,"(""StreamStorageFactory"", ""createStreamStorageFS"", ""StreamStorageFS"")"
Here is an example of creating a StreamStorageFS instance via the createStreamStorageFS() method:,"(""StreamStorageFS"", ""created via"", ""createStreamStorageFS()"")"
You can create a StreamStorageRootFS instance via the StreamStorageFactory createStreamStorageRootFS() method.,"(""StreamStorageFactory"", ""createStreamStorageRootFS"", ""StreamStorageRootFS"")"
"The Stream Ops StreamStorageFS class, com.nanosai.streamops.storage.file.StreamStorageFS, provides disk storage for a data stream.","(""StreamStorageFS"", ""provides"", ""disk storage""); (""StreamStorageFS"", ""is part of"", ""com.nanosai.streamops.storage.file""); (""com.nanosai.streamops.storage.file"", ""contains"", ""StreamStorageFS"")"
"More specifically, the StreamStorageFS class can write an ordered sequence of records to disk, and later read the records from disk again in the exact same order.","(""StreamStorageFS"", ""can write to"", ""disk""); (""StreamStorageFS"", ""can read from"", ""disk""); (""StreamStorageFS"", ""writes"", ""records""); (""StreamStorageFS"", ""reads"", ""records"")"
The StreamStorageFS class is one of the core classes of the Stream Ops data storage engine.,"(""StreamStorageFS"", ""is part of"", ""Stream Ops data storage engine"")"
Many of the other classes in the Stream Ops data storage engine revolve around this class.,"(""Stream Ops"", ""contains"", ""class""); (""class"", ""is central to"", ""Stream Ops data storage engine"")"
To use the StreamStorageFS class you must first create a StreamStorageFS instance.,"(""StreamStorageFS"", ""has instance"", ""StreamStorageFS instance""); (""StreamStorageFS"", ""used by"", ""user""); (""StreamStorageFS instance"", ""created by"", ""user""); (""StreamStorageFS"", ""requires"", ""StreamStorageFS instance"")"
"Once a StreamStorageFS instance is open for appending records, you can append a record to the stream via the append() method.","(""StreamStorageFS"", ""has method"", ""append()""); (""StreamStorageFS"", ""uses method"", ""append()""); (""append()"", ""is method of"", ""StreamStorageFS"")"
You can obtain a list of StreamStorageBlockFS instances from a StreamStorageFS by calling getStorageBlocks().,"(""StreamStorageFS"", ""getStorageBlocks()"", ""StreamStorageBlockFS"")"
The StreamStorageFS class contains a method to read bytes from a stream block file.,"(""StreamStorageFS"", ""contains"", ""method to read bytes from a stream block file""); (""StreamStorageFS"", ""has method"", ""read bytes from a stream block file""); (""StreamStorageFS"", ""contains"", ""read bytes from a stream block file""); (""StreamStorageFS"", ""has"", ""method""); (""method"", ""belongs to"", ""StreamStorageFS""); (""read bytes from a stream block file"", ""is part of"", ""StreamStorageFS""); (""StreamStorageFS"", ""includes"", ""read bytes from a stream block file method"")"
"The readBytes() method reads bytes from the file represented by the given StreamStorageBlockFS instance, into the byte[] array passed as parameter.","(""StreamStorageBlockFS"", ""hasMethod"", ""readBytes()""); (""readBytes()"", ""readsFrom"", ""StreamStorageBlockFS""); (""readBytes()"", ""writesTo"", ""byte"")"
The readBytes() method will start fromByte bytes into the block file.,"(""readBytes()"", ""is method of"", ""block file""); (""block file"", ""has method"", ""readBytes()""); (""readBytes()"", ""starts from"", ""fromByte"")"
The Stream Ops for Java class named StreamStorageRootFS (com.nanosai.streamops.engine.storage.file.StreamStorageRootFS) class represents the root of a file based stream storage system.,"(""StreamStorageRootFS"", ""is part of"", ""com.nanosai.streamops.engine.storage.file""); (""StreamStorageRootFS"", ""represents"", ""stream storage system""); (""StreamStorageRootFS"", ""is located in"", ""com.nanosai.streamops.engine.storage.file"")"
You can always obtain the root directory path a StreamStorageRootFS was created with via its getRootDirPath() method.,"(""StreamStorageRootFS"", ""has method"", ""getRootDirPath()"")"
Here is an example of obtaining the root directory path of a StreamStorageRootFS via its getRootDirPath() method:,"(""StreamStorageRootFS"", ""has method"", ""getRootDirPath()"")"
"When you write records to a stream via the StreamStorageFS instance, the StreamStorageFS class will divide the records into multiple files.","(""StreamStorageFS"", ""has instance"", ""StreamStorageFS instance""); (""StreamStorageFS instance"", ""writes to"", ""stream""); (""StreamStorageFS"", ""divides records into"", ""files""); (""StreamStorageFS"", ""has method"", ""write records""); (""records"", ""are written to"", ""stream""); (""stream"", ""is accessed via"", ""StreamStorageFS instance""); (""StreamStorageFS"", ""manages"", ""stream"")"
Creating a Buffer is done using the static buffer() method in the Buffer interface.,"(""Buffer"", ""has method"", ""buffer()""); (""Buffer"", ""is accessed through"", ""Buffer.interface""); (""buffer()"", ""is a method of"", ""Buffer"")"
If you want the bytes stored in the Buffer to be encoded using a special encoding (e.g.,
"you can specify the encoding as the second parameter to the buffer() method, like this:","(""buffer()"", ""hasParameter"", ""encoding"")"
You can read the length of a Buffer using its length() method.,"(""Buffer"", ""has method"", ""length()"")"
You can write to a specific position inside a buffer using one of the set...() methods.,"(""buffer"", ""has method"", ""set...()"")"
You can also write data to a Buffer using one of the append...() methods.,"(""Buffer"", ""has method"", ""append...()"")"
You can read the data stored in a Buffer using the many get...() methods.,"(""Buffer"", ""has methods"", ""get...()"")"
After the vertx run part of the command you must write the fully qualified class name of the verticle to deploy.,"(""vertx"", ""run"", ""verticle""); (""verticle"", ""deploy"", ""class""); (""class"", ""has"", ""fully qualified name"")"
To deploy a verticle class you must run the vertx run classname command from the root directory of the compiled classes for the verticle to deploy.,"(""Vertx"", ""run"", ""Classname""); (""Classname"", ""deploy"", ""Verticle""); (""Verticle"", ""deploy from"", ""Root Directory""); (""Root Directory"", ""contain"", ""Compiled Classes""); (""Compiled Classes"", ""belong to"", ""Verticle"")"
"Thus, the root directory of your classes becomes the classpath for deploying the verticle.","(""root directory"", ""becomes"", ""classpath""); (""classpath"", ""for"", ""deploying""); (""deploying"", ""of"", ""verticle"")"
Whatever directory you run the vertx run command from is automatically added to the classpath when looking for the verticle class.,"(""vertx"", ""run"", ""classpath""); (""vertx"", ""has"", ""verticle class""); (""classpath"", ""looks for"", ""verticle class""); (""vertx run command"", ""executed from"", ""directory""); (""directory"", ""added to"", ""classpath"")"
You can also run a Java verticle class which is located inside a JAR file.,"(""Java"", ""has"", ""verticle class""); (""verticle class"", ""located inside"", ""JAR file"")"
Sometimes you need a classpath which contains more than one directory or JAR file.,"(""classpath"", ""contains"", ""directory""); (""classpath"", ""contains"", ""JAR file"")"
In those situations you can provide a normal classpath string as the -cp argument value.,"(""classpath"", ""isProvidedAs"", ""-cp argument""); (""-cp argument"", ""hasValue"", ""classpath string"")"
Each entry (directory or JAR file) in the classpath string must be separated by either a semicolon (on Windows) or a colon (on Unix / Linux).,"(""classpath"", ""contains"", ""directory""); (""classpath"", ""contains"", ""JAR file""); (""Windows"", ""uses"", ""semicolon""); (""Unix"", ""uses"", ""colon""); (""Linux"", ""uses"", ""colon""); (""classpath"", ""separated by"", ""semicolon""); (""classpath"", ""separated by"", ""colon"")"
This example contains two JAR files in the classpath separated by a semicolon.,"(""classpath"", ""contains"", ""JAR files""); (""JAR files"", ""separated by"", ""semicolon"")"
"If you have a very long classpath your command line may get very long, and thus be hard to read in a text editor.","(""classpath"", ""has"", ""command line""); (""command line"", ""may get"", ""very long""); (""classpath"", ""is"", ""long""); (""command line"", ""is"", ""hard to read""); (""text editor"", ""is used to read"", ""command line"")"
"Instead you can build the classpath up as an environment variable, one entry per line, and use that environment variable in the command line.","(""classpath"", ""isPartOf"", ""environment variable""); (""environment variable"", ""usedIn"", ""command line""); (""classpath"", ""builtAs"", ""environment variable"")"
run.cmd and you can execute it from a Windows command line.,"(""run.cmd"", ""executed from"", ""Windows command line"")"
Notice the use of / as directory separator and the use of : as classpath entry separator.,
That might be useful if you deploy a class file that is written in Groovy or Scala (but which are compiled into Java classes).,"(""Java"", ""compiled into"", ""Groovy""); (""Java"", ""compiled into"", ""Scala"")"
The first parameter to the getNow() method is the TCP port to connect to the remote HTTP server on.,"(""getNow()"", ""has parameter"", ""TCP port"")"
The getNow() method exists in a version where you can leave the port out.,"(""getNow()"", ""exists in"", ""version""); (""version"", ""has method"", ""getNow()""); (""getNow()"", ""can leave out"", ""port"")"
The second parameter to the getNow() method is the domain name of the remote HTTP server to connect to.,"(""getNow()"", ""has parameter"", ""domain name""); (""getNow()"", ""belongs to"", ""HTTP server""); (""HTTP server"", ""has"", ""domain name"")"
The third parameter to the getNow() method is the URI to the resource to retrieve.,"(""getNow()"", ""has parameter"", ""URI""); (""getNow()"", ""is method of"", ""unknown class""); (""URI"", ""is parameter of"", ""getNow()"")"
The Handler implementation passed to the getNow() method is called when the headers of the HTTP response are received.,"(""Handler"", ""passed to"", ""getNow()""); (""getNow()"", ""called with"", ""Handler""); (""Handler"", ""called when"", ""headers of HTTP response are received""); (""HTTP response"", ""has"", ""headers""); (""getNow()"", ""receives"", ""headers of HTTP response"")"
"However, if you do need to access the body of the HTTP response, you need to register another handler on the HttpClientResponse that is passed as parameter to the first Handler's handle() method.","(""HttpClientResponse"", ""passed to"", ""Handler.handle()""); (""Handler"", ""has method"", ""handle()""); (""HttpClientResponse"", ""has handler"", ""Handler"")"
The Handler implementation passed to the bodyHandler() method of the HttpClientResponse is called when the full HTTP response body is received.,"(""HttpClientResponse"", ""has method"", ""bodyHandler()""); (""bodyHandler()"", ""is called with"", ""Handler""); (""Handler"", ""implementation is passed to"", ""bodyHandler()""); (""HttpClientResponse"", ""receives"", ""HTTP response body""); (""HTTP response body"", ""is received by"", ""HttpClientResponse""); (""bodyHandler()"", ""receives"", ""HTTP response body"")"
"Once you have created the HTTP server, you can start it using its listen() method.","(""HTTP server"", ""has method"", ""listen()"")"
"The HttpServer class has more versions of the listen() method too, which gives you different options for starting the HTTP server.","(""HttpServer"", ""has"", ""listen()""); (""listen()"", ""has versions of"", ""HttpServer""); (""HttpServer"", ""starts"", ""HTTP server"")"
"Every time an HTTP request arrives at the HTTP server, the handle() method of the Handler object is called.","(""Handler"", ""has method"", ""handle()""); (""HTTP server"", ""receives"", ""HTTP request""); (""Handler"", ""called by"", ""HTTP server""); (""Handler"", ""has method called"", ""handle()""); (""HTTP request"", ""arrives at"", ""HTTP server""); (""handle()"", ""called by"", ""HTTP server""); (""Handler"", ""handles"", ""HTTP request""); (""HTTP server"", ""calls"", ""handle()"")"
Inside the handle() method you can execute the code needed to handle the HTTP request.,"(""handle()"", ""is a method of"", ""HTTP request"")"
You can access HTTP headers and parameters from the HttpServerRequest object passed as parameter to the handle() method.,"(""HttpServerRequest"", ""hasMethod"", ""handle()""); (""handle()"", ""uses"", ""HttpServerRequest""); (""HttpServerRequest"", ""providesAccessTo"", ""HTTP headers""); (""HttpServerRequest"", ""providesAccessTo"", ""parameters"")"
"After writing the headers back you can write the response body back via the write() method, like this:","(""write() method"", ""is called via"", ""response body""); (""response body"", ""is written by"", ""write() method""); (""write() method"", ""is used for"", ""writing response"")"
You can call write() multiple times to add more data to the response body.,"(""write()"", ""called by"", ""user""); (""response body"", ""has method"", ""write()""); (""write()"", ""adds data to"", ""response body"")"
The write() method is asynchronous and returns immediately after queuing up the string or buffer.,"(""write()"", ""is_method_of"", ""unknown_class""); (""write()"", ""returns"", ""string""); (""write()"", ""returns"", ""buffer"")"
This is done by calling the end() method as shown in the previous example.,"(""end"", ""method called by"", ""previous example"")"
The end() method can take either a String or Buffer as parameter.,"(""end()"", ""takes"", ""String""); (""end()"", ""takes"", ""Buffer"")"
To close an HTTP server you simply call its close() method like this:,"(""HTTP server"", ""call"", ""close() method"")"
"The close() method executes asynchronously, so the HTTP server may not be fully closed by the time the close() method returns.","(""HTTP server"", ""has method"", ""close()""); (""close() method"", ""executes"", ""asynchronously""); (""close() method"", ""returns"", """")"
"You can pass a close handler as parameter to the close() method, to be notified when the HTTP server is fully closed.","(""HTTP server"", ""has method"", ""close()""); (""close()"", ""has parameter"", ""close handler""); (""close handler"", ""notified by"", ""close()""); (""HTTP server"", ""closes using"", ""close()"")"
"You can just unzip the zip file and add these JAR files to the classpath of your Java application, and you are good to go.","(""JAR files"", ""added to"", ""classpath""); (""Java application"", ""has"", ""classpath""); (""JAR files"", ""part of"", ""Java application"")"
As long as the JAR files are available on the classpath of your application.,"(""JAR"", ""available on"", ""classpath""); (""JAR"", ""are part of"", ""application""); (""application"", ""has"", ""classpath"")"
You connect to a remote server by calling the connect() method.,"(""connect() method"", ""called by"", ""unknown entity""); (""unknown entity"", ""calls"", ""connect() method"")"
You obtain a reference to the NetSocket connected to the remote server via the AsyncResult instance passed to the handler's handle() method.,"(""NetSocket"", ""connected to"", ""remote server""); (""AsyncResult"", ""passed to"", ""handler""); (""handler"", ""has method"", ""handle()""); (""AsyncResult"", ""instance passed to"", ""handler.handle()"")"
You can write data to the TCP connection via the NetSocket write() method.,"(""NetSocket"", ""has method"", ""write()"")"
The data may not be sent by the time the write() method returns.,"(""write() method"", ""returns"", ""time""); (""time"", ""is related to"", ""write() method""); (""write() method"", ""sends"", ""data""); (""data"", ""is sent by"", ""write() method""); (""write() method"", ""returns before"", ""data is sent""); (""data"", ""may not be sent by"", ""write() method"")"
The Handler's handle() method will get called when data is received from the remote server.,"(""Handler"", ""has method"", ""handle()""); (""handle()"", ""is called by"", ""remote server""); (""Handler"", ""receives data from"", ""remote server""); (""handle()"", ""is part of"", ""Handler"")"
You close the TCP client by calling the close() method of the NetClient instance.,"(""NetClient"", ""closes with"", ""close()""); (""NetClient"", ""has method"", ""close()""); (""close()"", ""is method of"", ""NetClient""); (""NetClient"", ""instance of"", ""NetClient""); (""TCP client"", ""closed by"", ""close()""); (""NetClient"", ""closes"", ""TCP client"")"
"Again, the NetClient's close() method is asynchronous, so the underlying TCP connection may not yet be closed by the time the close() method returns.","(""NetClient"", ""has method"", ""close()""); (""close()"", ""is type of"", ""asynchronous method""); (""TCP connection"", ""is closed by"", ""close()""); (""close()"", ""returns before"", ""TCP connection"")"
"Once you have created the TCP server, you can start it using its listen() method.","(""TCP server"", ""has method"", ""listen()"")"
This example starts the server and instructs it to listen on TCP port 10.000 .,
The NetServer class contains more versions of the listen() method which gives you different options for starting the TCP server.,"(""NetServer"", ""contains"", ""listen()""); (""listen()"", ""gives"", ""options""); (""NetServer"", ""has"", ""listen() method""); (""listen() method"", ""provides"", ""options for starting TCP server""); (""NetServer"", ""starts"", ""TCP server"")"
The handle() method of the connect handler is called whenever a new TCP connection is created by a client of the TCP server.,"(""connect handler"", ""has method"", ""handle()""); (""connect handler"", ""handles"", ""TCP connection""); (""TCP server"", ""creates"", ""TCP connection""); (""TCP server"", ""has client"", ""client""); (""client"", ""creates"", ""TCP connection""); (""connect handler"", ""is part of"", ""TCP server"")"
The NetSocket object passed as parameter to the handle() method gives access to the incoming connection (socket etc.,"(""NetSocket"", ""passed to"", ""handle()""); (""handle()"", ""gives access to"", ""connection""); (""NetSocket"", ""provides access to"", ""socket"")"
You can do so via the NetSocket instance passed to the connect handler's handle() method.,"(""NetSocket"", ""passed to"", ""connect handler""); (""connect handler"", ""has method"", ""handle()""); (""NetSocket"", ""used by"", ""handle()"")"
The NetSocket class contains more versions of the write() method which enables you to write e.g.,"(""NetSocket"", ""contains"", ""write()""); (""write()"", ""is version of"", ""write()""); (""NetSocket"", ""has method"", ""write()"")"
When you are finished with the TCP server you can close it using its close() method.,"(""TCP server"", ""has method"", ""close()"")"
"Closing the TCP server is an asynchronous actions, so the close() method may exit before the TCP server is actually closed.","(""TCP server"", ""has method"", ""close()""); (""close()"", ""is type of"", ""asynchronous action""); (""TCP server"", ""performs action"", ""close()"")"
"If you need to be notified of when the TCP server has shut down, you can pass a Handler to the close() method.","(""TCP server"", ""has method"", ""close()""); (""close()"", ""uses"", ""Handler""); (""Handler"", ""passed to"", ""close()"")"
"The setTimer() method takes a time interval in milliseconds as first parameter, and a Handler implementation as second parameter.","(""setTimer()"", ""takes"", ""time interval""); (""setTimer()"", ""takes"", ""Handler""); (""Handler"", ""is implemented by"", ""Handler implementation"")"
The Handler's handle() method is called when the time interval has elapsed.,"(""Handler"", ""has method"", ""handle()"")"
This timer ID is also passed as parameter to the Handler's handle() method.,"(""Handler"", ""has method"", ""handle()"")"
"The setPeriodic() method takes a time interval in milliseconds as first parameter, and a Handler implementation as second parameter.","(""setPeriodic"", ""takes"", ""time interval""); (""setPeriodic"", ""takes"", ""Handler"")"
The Handler's handle() method is called every time the time interval has elapsed.,"(""Handler"", ""has method"", ""handle()"")"
This timer ID is also passed to the Handler's handle() method whenever it is called.,"(""Handler"", ""has method"", ""handle()"")"
Support for Scala and Clojure should be arriving soon (it was originally planned for v. 3.0 but I am not sure if they got it in).,
You don't have to learn both a language and a new platform (e.g.,
You will see later in this tutorial how to use both versions of the start() method.,"(""start"", ""has method"", ""start()"")"
Here is an example of overriding the stop() method in your own verticle:,"(""Verticle"", ""overrides"", ""stop()""); (""stop()"", ""is overridden in"", ""Verticle""); (""Verticle"", ""has method"", ""stop()"")"
Sending messages via the event bus can be done via either the send() or publish() method on the event bus.,"(""event bus"", ""has method"", ""send()""); (""event bus"", ""has method"", ""publish()"")"
The send() method sends the message to just one of the listening verticles.,"(""send()"", ""is_method_of"", ""unknown""); (""verticles"", ""listens_to"", ""message""); (""send()"", ""sends_to"", ""verticles""); (""message"", ""is_sent_by"", ""send()"")"
This is useful for distributing work load over multiple verticles (e.g.,
"The first message is sent via the publish() method, so both consumers receive the message.","(""Message"", ""is sent via"", ""publish()""); (""_consumers"", ""receive"", ""Message"")"
"The second message is sent via the send() method, so only one of the consumers will receive the message.","(""Message"", ""is sent via"", ""send() method""); (""send() method"", ""is used by"", ""consumers""); (""consumers"", ""receive"", ""message"")"
A verticle has a start() and a stop() method which are called when the verticle is deployed and when it is undeployed.,"(""verticle"", ""has"", ""start()""); (""verticle"", ""has"", ""stop()""); (""verticle"", ""is deployed by"", ""start()""); (""verticle"", ""is undeployed by"", ""stop()"")"
"You should perform any necessary initialization work inside the start() method, and any necessary cleanup work inside the stop() method.","(""start()"", ""contains"", ""initialization work""); (""start()"", ""performs"", ""initialization work""); (""stop()"", ""contains"", ""cleanup work""); (""stop()"", ""performs"", ""cleanup work"")"
"For instance, you can specify how many verticle instances of a given verticle class to deploy.","(""verticle class"", ""to deploy"", ""verticle instances""); (""verticle instances"", ""of"", ""verticle class""); (""verticle class"", ""has"", ""verticle instances"")"
The startsWith() and endsWith() methods check if the String starts with a certain substring,"(""String"", ""hasMethod"", ""startsWith()""); (""String"", ""hasMethod"", ""endsWith()"")"
In the above example the two methods getTime() and setTime() can access the time member variable,"(""getTime()"", ""can access"", ""time""); (""setTime()"", ""can access"", ""time"")"
The convertToInt() method has the same signature as the deserialize() method of the Deserializer deserialize() method,"(""convertToInt()"", ""has same signature as"", ""deserialize()""); (""convertToInt()"", ""is part of"", ""Deserializer""); (""Deserializer"", ""has method"", ""deserialize()"")"
Deque.removeLast() is different from pollLast() which returns null if the Deque is empty,"(""Deque"", ""hasMethod"", ""removeLast()""); (""Deque"", ""hasMethod"", ""pollLast()""); (""removeLast()"", ""differentFrom"", ""pollLast()""); (""Deque"", ""returns"", ""element""); (""pollLast()"", ""returns"", ""null"")"
The floor() method does the opposite of the ceiling() method meaning it returns the greatest element that is less than or equal to the given parameter value,"(""floor() method"", ""is opposite of"", ""ceiling() method""); (""floor() method"", ""returns"", ""greatest element""); (""ceiling() method"", ""returns"", ""greatest element""); (""floor() method"", ""takes"", ""parameter value""); (""ceiling() method"", ""takes"", ""parameter value"")"
You can also specify METHOD or FIELD or you can leave the target out alltogether so the annotation can be used for both classes methods and fields,"(""METHOD"", ""is a type of"", ""target""); (""FIELD"", ""is a type of"", ""target""); (""classes"", ""can be annotated with"", ""annotation""); (""methods"", ""can be annotated with"", ""annotation""); (""fields"", ""can be annotated with"", ""annotation"")"
For instance finest() finer() fine() info() warning() and severe() each corresponds to one of the log levels,"(""finest"", ""corresponds to"", ""log level""); (""finer"", ""corresponds to"", ""log level""); (""fine"", ""corresponds to"", ""log level""); (""info"", ""corresponds to"", ""log level""); (""warning"", ""corresponds to"", ""log level""); (""severe"", ""corresponds to"", ""log level"")"
You can encrypt or decrypt data into an existing byte array by passing the destination byte array as parameter to the update() and or doFinal() method,"(""update()"", ""called by"", ""doFinal()""); (""update()"", ""passes parameter"", ""byte array""); (""doFinal()"", ""passes parameter"", ""byte array""); (""byte array"", ""passed to"", ""update()""); (""byte array"", ""passed to"", ""doFinal()"")"
Second if the lock is locked the threads are blocked in the wait() call inside the while(isLocked) loop in the lock() method,"(""lock"", ""has method"", ""wait()""); (""lock"", ""has method"", ""lock()""); (""thread"", ""calls method"", ""wait()""); (""thread"", ""calls method"", ""lock()""); (""lock"", ""is used by"", ""thread""); (""lock"", ""has state"", ""locked""); (""lock"", ""blocked by"", ""while loop""); (""while loop"", ""contains method"", ""wait()""); (""while loop"", ""contains condition"", ""isLocked""); (""lock"", ""has condition"", ""isLocked"")"
Deque.removeFirst() is different from pollFirst() which returns null if the Deque is empty,"(""Deque"", ""hasMethod"", ""removeFirst()""); (""Deque"", ""hasMethod"", ""pollFirst()""); (""removeFirst()"", ""differsFrom"", ""pollFirst()""); (""pollFirst()"", ""returns"", ""null""); (""Deque"", ""hasState"", ""empty"")"
The peek() works like the element() method except it does not throw an exception if the Queue is empty,"(""Queue"", ""hasMethod"", ""peek()""); (""Queue"", ""hasMethod"", ""element()""); (""peek()"", ""similarTo"", ""element()"")"
The addAll() method takes a Collection as parameter so you can pass either a List or Java Set as parameter,"(""addAll()"", ""takes"", ""Collection""); (""addAll()"", ""takes"", ""List""); (""addAll()"", ""takes"", ""Java Set"")"
The Java Properties class java.util.Properties is like a Java Map of Java String key and value pairs,"(""Java Properties"", ""is like"", ""Java Map""); (""Java Properties"", ""has key type"", ""Java String""); (""Java Properties"", ""has value type"", ""Java String""); (""Java Properties"", ""is in package"", ""java.util"")"
java.io.InputStream means that you use the Java FileInputStream as an InputStream (FileInputStream behaves like an InputStream),"(""FileInputStream"", ""behaves like"", ""InputStream""); (""FileInputStream"", ""is a"", ""InputStream""); (""Java"", ""has package"", ""java.io""); (""InputStream"", ""is in package"", ""java.io""); (""FileInputStream"", ""is in package"", ""java.io"")"
Since PipedInputStream is a subclass of InputStream PipedInputStream has the same basic methods and use patterns as an InputStream,"(""PipedInputStream"", ""is a subclass of"", ""InputStream""); (""PipedInputStream"", ""has methods"", ""InputStream"")"
Choice.select(int pos) is done by having a different thread call the Selector.wakeup() method on the Selector which the first thread has called select() on,"(""Choice"", ""hasMethod"", ""select(int pos)""); (""Selector"", ""hasMethod"", ""wakeup()""); (""Selector"", ""hasMethod"", ""select()""); (""Thread"", ""calls"", ""Choice.select(int pos)""); (""Thread"", ""calls"", ""Selector.wakeup()""); (""Thread"", ""calls"", ""Selector.select()""); (""Selector"", ""isCalledBy"", ""Thread""); (""Choice"", ""isCalledBy"", ""Thread"")"
While isLocked is true the thread calling lock() is parked waiting in the wait() call,"(""Thread"", ""calls"", ""lock()""); (""Thread"", ""waits in"", ""wait()""); (""lock()"", ""is called by"", ""Thread""); (""wait()"", ""is called by"", ""Thread""); (""Thread"", ""is parked in"", ""wait()"")"
The AtomicInteger class is located in the java.util.concurrent.atomic package so the full class name is java.util.concurrent.atomic.AtomicInteger,"(""AtomicInteger"", ""is located in"", ""java.util.concurrent.atomic""); (""AtomicInteger"", ""has full class name"", ""java.util.concurrent.atomic.AtomicInteger""); (""java.util.concurrent.atomic"", ""contains"", ""AtomicInteger"")"
But no thread can actually execute unlock() until the thread waiting in lock() leaves the outer synchronized block,"(""thread"", ""execute"", ""unlock()""); (""unlock()"", ""called by"", ""thread""); (""lock()"", ""waited by"", ""thread""); (""thread"", ""leaves"", ""outer synchronized block""); (""outer synchronized block"", ""contains"", ""lock()"")"
The System class also has a getProperty() and setProperty() method which are shortcuts to the Properties getProperty() and setProperty() methods of the System Properties instance.,"(""System"", ""has method"", ""getProperty()""); (""System"", ""has method"", ""setProperty()""); (""Properties"", ""has method"", ""getProperty()""); (""Properties"", ""has method"", ""setProperty()""); (""System"", ""has instance"", ""Properties""); (""Properties"", ""has method"", ""getProperty()""); (""Properties"", ""has method"", ""setProperty()""); (""System.getProperty"", ""is shortcut to"", ""Properties.getProperty""); (""System.setProperty"", ""is shortcut to"", ""Properties.setProperty""); (""System"", ""hasMethod"", ""getProperty()""); (""System"", ""hasMethod"", ""setProperty()""); (""System"", ""hasInstance"", ""System Properties""); (""Properties"", ""hasMethod"", ""getProperty()""); (""Properties"", ""hasMethod"", ""setProperty()""); (""System.getProperty"", ""isShortcutFor"", ""Properties.getProperty()""); (""System.setProperty"", ""isShortcutFor"", ""Properties.setProperty()"")"
Closeable.close() closes the Selector and invalidates all SelectionKey instances registered with this Selector,"(""Closeable.close()"", ""closes"", ""Selector""); (""Selector"", ""has"", ""SelectionKey""); (""Closeable.close()"", ""invalidates"", ""SelectionKey"")"
Any.stream() is similar to how you obtain an Iterator by calling the items.iterator() method but a Stream is a different animal than an Iterator,"(""Any"", ""stream()"", ""Stream""); (""items"", ""iterator()"", ""Iterator"")"
An interesting aspect to note about the BufferedInputStream is that is supports the mark() and reset() methods inherited from the InputStream,"(""BufferedInputStream"", ""supports"", ""mark()""); (""BufferedInputStream"", ""supports"", ""reset()""); (""BufferedInputStream"", ""inherited from"", ""InputStream""); (""InputStream"", ""has method"", ""mark()""); (""InputStream"", ""has method"", ""reset()"")"
"You can search for an object on the stack to get it's index, using the search() method. The object's equals() method is called on every object on the Stack to determine if the searched-for object is present on the Stack.",
Actually java.sql.Timestamp extends java.util.Date so anything you can do with a java.util.Date you can also do with a java.sql.Timestamp,"(""java.sql.Timestamp"", ""extends"", ""java.util.Date""); (""java.util.Date"", ""is extended by"", ""java.sql.Timestamp"")"
"If the Deque is empty, removeFirst() will throw an exception. This is different from pollFirst() which returns null if the Deque is empty.","(""Deque"", ""hasMethod"", ""removeFirst()""); (""removeFirst()"", ""throws"", ""exception""); (""Deque"", ""hasMethod"", ""pollFirst()""); (""pollFirst()"", ""returns"", ""null"")"
You read bytes from a Java ByteArrayInputStream just like you would from a regular InputStream via its read() method,"(""ByteArrayInputStream"", ""has method"", ""read()""); (""InputStream"", ""has method"", ""read()""); (""ByteArrayInputStream"", ""inherits from"", ""InputStream"")"
You create a DateFormat using the getDateInstance() and getTimeInstance() method of the DateFormat class,"(""DateFormat"", ""uses"", ""getDateInstance()""); (""DateFormat"", ""uses"", ""getTimeInstance()""); (""DateFormat"", ""has method"", ""getDateInstance()""); (""DateFormat"", ""has method"", ""getTimeInstance()"")"
You can use addBatch() and executeBatch() methods to execute batch updates.,"(""addBatch()"", ""used with"", ""executeBatch()""); (""addBatch()"", ""method of"", ""unknown class""); (""executeBatch()"", ""method of"", ""unknown class""); (""addBatch()"", ""related to"", ""batch updates""); (""executeBatch()"", ""related to"", ""batch updates"")"
The Java FileOutputStream class is a subclass of Java OutputStream meaning you can use a FileOutputStream as an OutputStream,"(""FileOutputStream"", ""is a subclass of"", ""OutputStream""); (""FileOutputStream"", ""can be used as"", ""OutputStream"")"
In the example above I passed it a FileInputStream connected to a file named myfile.zip,"(""FileInputStream"", ""connected to"", ""myfile.zip"")"
java.util.logging.LogRecord Throwable is either passed as parameter to a Logger log method or set directly on a LogRecord which is then passed to a Logger,"(""Logger"", ""log"", ""LogRecord""); (""LogRecord"", ""set"", ""Throwable""); (""Logger"", ""log"", ""Throwable""); (""Throwable"", ""passed to"", ""Logger""); (""Throwable"", ""set on"", ""LogRecord""); (""LogRecord"", ""passed to"", ""Logger"")"
As you can see a new StringBuilder is created passing along the first String to its constructor and the second String to its append() method before finally calling the toString() method,"(""StringBuilder"", ""constructor"", ""String""); (""StringBuilder"", ""append()"", ""String""); (""StringBuilder"", ""toString()"", ""String"")"
A thread cannot call wait() notify() or notifyAll() without holding the lock on the object the method is called on,"(""thread"", ""calls"", ""wait()""); (""thread"", ""calls"", ""notify()""); (""thread"", ""calls"", ""notifyAll()""); (""object"", ""has"", ""lock""); (""thread"", ""holds"", ""lock""); (""method"", ""is called on"", ""object"")"
The AtomicReferenceArray in the java.util.concurrent.atomic package is an array of object references which can be updated atomically,"(""AtomicReferenceArray"", ""is part of"", ""java.util.concurrent.atomic""); (""AtomicReferenceArray"", ""updates"", ""object references""); (""java.util.concurrent.atomic"", ""contains"", ""AtomicReferenceArray"")"
Spin locks and the methods wait() and notify() are covered in more detail in the text Thread Signaling,"(""Spin locks"", ""covered in"", ""Thread Signaling""); (""wait()"", ""covered in"", ""Thread Signaling""); (""notify()"", ""covered in"", ""Thread Signaling"")"
The AtomicLong class is located in the java.util.concurrent.atomic package so the full class name is java.util.concurrent.atomic.AtomicLong,"(""AtomicLong"", ""is located in"", ""java.util.concurrent.atomic""); (""java.util.concurrent.atomic"", ""contains"", ""AtomicLong""); (""AtomicLong"", ""has full name"", ""java.util.concurrent.atomic.AtomicLong"")"
"The Arrays class contains a set of methods called binarySearch(). This method helps you perform a binary search in an array. The array must first be sorted. You can do so yourself, or via the Arrays.sort() method covered earlier in this text.","(""Arrays"", ""contains"", ""binarySearch()""); (""Arrays"", ""contains"", ""sort()""); (""binarySearch()"", ""performed in"", ""array""); (""sort()"", ""sorts"", ""array""); (""Arrays"", ""provides"", ""binarySearch()""); (""Arrays"", ""provides"", ""sort()"")"
The Java Reader (java.io.Reader) and Java Writer class (java.io.Writer) in Java IO work much like the InputStream and OutputStream with the exception that Reader and Writer are character based,"(""java.io.Reader"", ""is similar to"", ""InputStream""); (""java.io.Writer"", ""is similar to"", ""OutputStream""); (""java.io.Reader"", ""works with"", ""java.io.Writer""); (""InputStream"", ""is related to"", ""OutputStream""); (""java.io.Reader"", ""is part of"", ""Java IO""); (""java.io.Writer"", ""is part of"", ""Java IO"")"
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicInteger,"(""AtomicInteger"", ""hasMethod"", ""getAndIncrement()""); (""AtomicInteger"", ""hasMethod"", ""incrementAndGet()""); (""AtomicInteger"", ""hasMethod"", ""getAndAdd()""); (""AtomicInteger"", ""hasMethod"", ""addAndGet()"")"
"The tailSet() method works the same way as the headSet() method, except it returns all elements that are equal to or higher than the given parameter element","(""tailSet()"", ""works the same way as"", ""headSet()""); (""tailSet()"", ""returns"", ""elements""); (""headSet()"", ""works the same way as"", ""tailSet()""); (""headSet()"", ""returns"", ""elements"")"
If a different thread calls wakeup() and no thread is currently blocked inside select() the next thread that calls select() will wake up immediately,"(""thread"", ""calls"", ""wakeup()""); (""thread"", ""calls"", ""select()""); (""thread"", ""is blocked inside"", ""select()""); (""wakeup()"", ""wakes up"", ""thread""); (""select()"", ""is called by"", ""thread""); (""thread"", ""wakes up immediately after"", ""select()"")"
HashMap maps a key and a value. It does not guarantee any order of the elements stored internally in the map.TreeMap also maps a key and a value. Furthermore it guarantees the order in which keys or values are iterated - which is the sort order of the keys or values.,"(""HashMap"", ""maps"", ""key""); (""HashMap"", ""maps"", ""value""); (""TreeMap"", ""maps"", ""key""); (""TreeMap"", ""maps"", ""value""); (""TreeMap"", ""guarantees"", ""order""); (""TreeMap"", ""iterates"", ""keys""); (""TreeMap"", ""iterates"", ""values""); (""TreeMap"", ""sorts"", ""keys""); (""TreeMap"", ""sorts"", ""values"")"
It is worth noting that both unlockRead() and unlockWrite() calls notifyAll() rather than notify(),"(""unlockRead()"", ""calls"", ""notifyAll()""); (""unlockWrite()"", ""calls"", ""notifyAll()""); (""notifyAll()"", ""is alternative to"", ""notify()"")"
Notice the call to update() and then doFinal() for these two blocks of data,"(""update()"", ""called by"", ""unspecified class""); (""doFinal()"", ""called by"", ""unspecified class""); (""update()"", ""related to"", ""doFinal()"")"
You simply pass an offset and length to the update() and or doFinal() method,"(""update()"", ""called by"", ""user""); (""doFinal()"", ""called by"", ""user""); (""update()"", ""related to"", ""doFinal()"")"
The Java Collections addAll() method can add a variable number of elements to a Collection (typically either a List or a Set,"(""Java Collections"", ""has method"", ""addAll()""); (""Collection"", ""can be"", ""List""); (""Collection"", ""can be"", ""Set""); (""addAll()"", ""adds to"", ""Collection"")"
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block,"(""thread"", ""calls"", ""wait()""); (""thread"", ""is awakened by"", ""notify()""); (""notify()"", ""is called by"", ""thread""); (""thread"", ""exits"", ""synchronized block""); (""notify()"", ""is in"", ""synchronized block"")"
java.lang.ThreadLocal is possible to set an initial value for a Java ThreadLocal which will get used the first time get() is called before set() has been called with a new value,"(""ThreadLocal"", ""has method"", ""get()""); (""ThreadLocal"", ""has method"", ""set()""); (""ThreadLocal"", ""is in package"", ""java.lang"")"
The Reader and Writer classes are stream oriented classes that enable a Java application to read and write streams of characters,"(""Reader"", ""is_a"", ""stream oriented class""); (""Writer"", ""is_a"", ""stream oriented class""); (""Java application"", ""uses"", ""Reader""); (""Java application"", ""uses"", ""Writer""); (""Reader"", ""enables"", ""reading streams of characters""); (""Writer"", ""enables"", ""writing streams of characters"")"
If the doNotify() method had called notifyAll() instead of notify() all waiting threads had been awakened and checked for signals in turn,"(""doNotify()"", ""called"", ""notifyAll()""); (""doNotify()"", ""called"", ""notify()""); (""notifyAll()"", ""awakens"", ""threads""); (""notify()"", ""awakens"", ""thread""); (""threads"", ""checked for"", ""signals"")"
The run() method is what is executed by the thread after you call start(),"(""thread"", ""has method"", ""run()""); (""run()"", ""is executed by"", ""thread""); (""thread"", ""calls"", ""start()""); (""thread"", ""has method"", ""start()"")"
You can convert Strings to uppercase and lowercase using the methods toUpperCase() and toLowerCase(),"(""String"", ""hasMethod"", ""toUpperCase()""); (""String"", ""hasMethod"", ""toLowerCase()"")"
To make the Calculator class thread safe you could have declared the getValue() setValue() and add() methods synchronized,"(""Calculator"", ""hasMethod"", ""getValue()""); (""Calculator"", ""hasMethod"", ""setValue()""); (""Calculator"", ""hasMethod"", ""add()"")"
"If the call to take() happens before the call to release() the thread calling release() will still know that take() was called, because the signal is stored internally in the signal variable.","(""Thread"", ""calls"", ""take()""); (""Thread"", ""calls"", ""release()""); (""take()"", ""happens before"", ""release()""); (""release()"", ""knows"", ""take()""); (""signal"", ""is stored in"", ""signal variable""); (""Thread"", ""uses"", ""signal variable""); (""take()"", ""sets"", ""signal variable""); (""release()"", ""checks"", ""signal variable"")"
The getAndAdd() method does the same as the addAndGet() method except the getAndAdd() method returns the value of the element before a value is added to it,"(""getAndAdd()"", ""is similar to"", ""addAndGet()""); (""getAndAdd()"", ""returns"", ""element value""); (""addAndGet()"", ""returns"", ""element value"")"
Adding and getting elements to a generic Map is done using the put() and get() methods just like you have always done,"(""Map"", ""uses"", ""put()""); (""Map"", ""uses"", ""get()"")"
When guarding a critical section with a ReadWriteLock and the critical section may throw exceptions it is important to call the readUnlock() and writeUnlock() methods from inside a finallyclause,"(""ReadWriteLock"", ""hasMethod"", ""readUnlock()""); (""ReadWriteLock"", ""hasMethod"", ""writeUnlock()""); (""readUnlock()"", ""calledFrom"", ""finally""); (""writeUnlock()"", ""calledFrom"", ""finally"")"
The FileChannel class has a transferTo() and a transferFrom() method which does this for you,"(""FileChannel"", ""has"", ""transferTo()""); (""FileChannel"", ""has"", ""transferFrom()"")"
To generate a KeyPair with a KeyPairGenerator you call the generateKeyPair() method,"(""KeyPairGenerator"", ""call"", ""generateKeyPair()""); (""KeyPairGenerator"", ""use to generate"", ""KeyPair""); (""generateKeyPair()"", ""method of"", ""KeyPairGenerator""); (""KeyPair"", ""generated by"", ""KeyPairGenerator"")"
You can convert a OutputStream to a character based Writer using the Java OutputStreamWriter class,"(""OutputStream"", ""can be converted to"", ""Writer""); (""OutputStream"", ""uses"", ""OutputStreamWriter""); (""OutputStreamWriter"", ""converts"", ""OutputStream"")"
If you created your SortedSet with a Comparator you can obtain that Comparator via the SortedSet comparator() method,"(""SortedSet"", ""has method"", ""comparator()""); (""comparator()"", ""is returned by"", ""SortedSet.comparator()""); (""SortedSet"", ""uses"", ""Comparator""); (""Comparator"", ""is obtained via"", ""SortedSet.comparator()"")"
"In order to update the database you need to use a Statement. But, instead of calling the executeQuery() method, you call the executeUpdate() method.","(""Statement"", ""use"", ""database""); (""Statement"", ""call"", ""executeUpdate()""); (""executeUpdate()"", ""instead of"", ""executeQuery()"")"
Instances of this class are used together with UDP DatagramSockets and normal Socket and ServerSocket,"(""DatagramSockets"", ""used with"", ""this class""); (""Socket"", ""used with"", ""this class""); (""ServerSocket"", ""used with"", ""this class"")"
The Java InputStreamReader class java.io.InputStreamReader wraps a Java InputStream thereby turning the byte based InputStream into a character based Reader,"(""Java InputStreamReader"", ""wraps"", ""Java InputStream""); (""Java InputStream"", ""turned into"", ""Reader""); (""Java InputStreamReader"", ""extends"", ""Reader""); (""Java InputStreamReader"", ""located in"", ""java.io""); (""Java InputStream"", ""located in"", ""java.io""); (""Reader"", ""located in"", ""java.io"")"
The Math is located in the java.lang package and not in the java.math package,"(""Math"", ""is located in"", ""java.lang""); (""Math"", ""is not located in"", ""java.math"")"
The Java StringReader class enables you to turn an ordinary String into a Reader,"(""StringReader"", ""enables"", ""String""); (""StringReader"", ""turns into"", ""Reader""); (""StringReader"", ""is a"", ""Java class""); (""Java"", ""has class"", ""StringReader""); (""String"", ""is turned into"", ""Reader"")"
All elements inserted into the PriorityBlockingQueue must implement the java.lang.Comparable interface,"(""PriorityBlockingQueue"", ""implements"", ""java.lang.Comparable"")"
As mentioned earlier the DataInputStream class is often used together with a DataOutputStream,"(""DataInputStream"", ""used together with"", ""DataOutputStream"")"
java.io.FileReader works much like the FileInputStream except the FileInputStream reads bytes whereas the FileReader reads characters,"(""FileReader"", ""works like"", ""FileInputStream""); (""FileInputStream"", ""reads"", ""bytes""); (""FileReader"", ""reads"", ""characters""); (""FileReader"", ""contrasted with"", ""FileInputStream""); (""FileInputStream"", ""contrasted with"", ""FileReader""); (""java.io.FileReader"", ""is part of"", ""java.io""); (""java.io.FileInputStream"", ""is part of"", ""java.io"")"
Deque.pollLast() is different than removeLast() which throws an exception if the Deque is empty,"(""Deque"", ""hasMethod"", ""pollLast()""); (""Deque"", ""hasMethod"", ""removeLast()""); (""removeLast()"", ""throwsExceptionWhen"", ""Deque.isEmpty""); (""Deque"", ""hasState"", ""isEmpty"")"
The java.util.concurrent.locks package has the following implementations of the Lock interface,"(""java.util.concurrent.locks"", ""has"", ""Lock""); (""Lock"", ""implemented by"", ""java.util.concurrent.locks"")"
The methods start() and end() will give the indexes into the text where the found match starts and ends,"(""start()"", ""gives"", ""indexes""); (""end()"", ""gives"", ""indexes""); (""start()"", ""related to"", ""end()""); (""start()"", ""returns"", ""indexes""); (""end()"", ""returns"", ""indexes"")"
The tailSet() method works the same way as the headSet() method except it returns all elements that are equal to or higher than the given parameter element,"(""tailSet()"", ""works the same way as"", ""headSet()""); (""NavigableSet"", ""contains method"", ""tailSet()""); (""headSet()"", ""returns elements less than"", ""tailSet()""); (""tailSet()"", ""returns elements greater than or equal to"", ""given parameter element"")"
A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object,"(""thread"", ""calls"", ""wait()""); (""wait()"", ""on"", ""object""); (""thread"", ""becomes"", ""inactive""); (""thread"", ""calls"", ""notify()""); (""notify()"", ""on"", ""object""); (""object"", ""has"", ""wait()""); (""object"", ""has"", ""notify()"")"
Here is an example of listing all files in a directory via the Java File list() and listFiles() methods,"(""File"", ""has method"", ""list()""); (""File"", ""has method"", ""listFiles()"")"
You can peek at the element at the head of a Queue without taking the element out of the Queue. This is done via the Queue element() or peek() methods.,"(""Queue"", ""has method"", ""element()""); (""Queue"", ""has method"", ""peek()"")"
The methods Class.getField(String name) and Class.getFields() methods only return public fields so they wont work,"(""Class"", ""hasMethod"", ""getField()""); (""Class"", ""hasMethod"", ""getFields()""); (""getField()"", ""returns"", ""public fields""); (""getFields()"", ""returns"", ""public fields""); (""Class.getField()"", ""isTypeOf"", ""Class.getFields()"")"
When you do so you can call connect() read() and write() in asynchronous mode,"(""connect()"", ""called by"", ""asynchronous mode""); (""read()"", ""called by"", ""asynchronous mode""); (""write()"", ""called by"", ""asynchronous mode"")"
"if you are writing a component that needs to read input from a stream, try to make our component depend on an InputStream, rather than any of it's subclasses (e.g. FileInputStream).","(""Component"", ""depends on"", ""InputStream""); (""InputStream"", ""has subclass"", ""FileInputStream""); (""Component"", ""may depend on"", ""FileInputStream"")"
For inexplicable reasons it is possible for threads to wake up even if notify() and notifyAll() has not been called,"(""Thread"", ""uses"", ""notify()""); (""Thread"", ""uses"", ""notifyAll()"")"
The applyLocalizedPattern() does the same as applyPattern() except it interpretes the characters in the pattern according to the Locale the DecimalFormat was created with,"(""DecimalFormat"", ""has method"", ""applyLocalizedPattern()""); (""DecimalFormat"", ""has method"", ""applyPattern()""); (""applyLocalizedPattern()"", ""uses"", ""Locale""); (""DecimalFormat"", ""created with"", ""Locale"")"
"You can access these two parts of the duration using the Duration methods:getNano(),getSeconds()","(""Duration"", ""has method"", ""getNano()""); (""Duration"", ""has method"", ""getSeconds()"")"
If you look back at the doSynchronized() method you will notice that the comment between lock() and unlock() states that the code in between these two calls take a long time to execute,"(""dosSynchronized"", ""has method"", ""lock""); (""dosSynchronized"", ""has method"", ""unlock"")"
When the thread calling lock() right after calls queueObject.wait() it will remain blocked until some other thread calls unlock() which may never happen,"(""Thread"", ""calls"", ""lock()""); (""Thread"", ""calls"", ""queueObject.wait()""); (""queueObject"", ""wait"", ""Thread""); (""Thread"", ""calls"", ""unlock()""); (""unlock()"", ""called by"", ""Thread"")"
Creating a pipe using Java IO is done via the PipedOutputStream and PipedInputStream classes. A PipedInputStream should be connected to a PipedOutputStream. The data written to the PipedOutputStream by one thread can be read from the connected PipedInputStream by another thread.,"(""PipedOutputStream"", ""connected to"", ""PipedInputStream""); (""PipedOutputStream"", ""written to by"", ""thread""); (""PipedInputStream"", ""read from by"", ""thread""); (""PipedOutputStream"", ""used for"", ""Java IO""); (""PipedInputStream"", ""used for"", ""Java IO"")"
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block.,"(""Thread"", ""calls"", ""wait()""); (""Thread"", ""exits"", ""wait()""); (""Thread"", ""calls"", ""notify()""); (""Thread"", ""leaves"", ""synchronized block""); (""synchronized block"", ""contains"", ""notify()""); (""thread"", ""calls"", ""wait()""); (""thread"", ""exit"", ""wait()""); (""thread"", ""calls"", ""notify()""); (""notify()"", ""is called by"", ""thread""); (""thread"", ""leaves"", ""synchronized block""); (""synchronized block"", ""is left by"", ""thread"")"
"TreeSet also guarantees the order of the elements when iterated, but the order is the sorting order of the elements. In other words, the order in which the elements whould be sorted if you used a Collections.sort() on a List or array containing these elements. This order is determined either by their natural order (if they implement Comparable), or by a specific Comparator implementation","(""TreeSet"", ""guarantees order of"", ""elements""); (""TreeSet"", ""iterates in"", ""sorting order""); (""elements"", ""are sorted by"", ""Collections.sort()""); (""Collections.sort()"", ""sorts"", ""List""); (""Collections.sort()"", ""sorts"", ""array""); (""elements"", ""have natural order"", ""Comparable""); (""elements"", ""have custom order"", ""Comparator""); (""Comparable"", ""determines natural order"", ""elements""); (""Comparator"", ""determines custom order"", ""elements"")"
"You can also obtain an Iterator from many of the Java Collection data structures, e.g. a List, Set, Map, Queue, Deque or Map.","(""Iterator"", ""obtained from"", ""List""); (""Iterator"", ""obtained from"", ""Set""); (""Iterator"", ""obtained from"", ""Map""); (""Iterator"", ""obtained from"", ""Queue""); (""Iterator"", ""obtained from"", ""Deque""); (""Iterator"", ""obtained from"", ""Map"")"
Instead the critical section is guarded by the lock.lock() and lock.unlock() calls,"(""lock"", ""has method"", ""lock.lock()""); (""lock"", ""has method"", ""lock.unlock()"")"
The methods mark() and reset() methods are typically used when implementing parsers,"(""mark()"", ""used with"", ""reset()""); (""mark()"", ""typically used when implementing"", ""parsers""); (""reset()"", ""typically used when implementing"", ""parsers""); (""reset()"", ""used with"", ""mark()"")"
Once you have obtained a Field reference you can get and set its values using the Field.get() and Field.set()methods like this,"(""Field"", ""hasMethod"", ""Field.get()""); (""Field"", ""hasMethod"", ""Field.set()"")"
The poll() and remove() both removes the first element in the Queue,"(""Queue"", ""hasMethod"", ""poll()""); (""Queue"", ""hasMethod"", ""remove()""); (""poll()"", ""removesElementFrom"", ""Queue""); (""remove()"", ""removesElementFrom"", ""Queue"")"
Any other thread calling lock() will be blocked until the thread that locked the lock calls unlock(),"(""lock"", ""calls"", ""unlock""); (""Thread"", ""calls"", ""lock()""); (""lock"", ""blocks"", ""Thread""); (""Thread"", ""calls"", ""unlock()"")"
The java.text.DateFormat class is used to format dates as strings according to a specific Locale,"(""java.text.DateFormat"", ""is used with"", ""Locale""); (""java.text.DateFormat"", ""formats"", ""dates""); (""Locale"", ""is used with"", ""java.text.DateFormat"")"
The InputStream class has two methods called mark() and reset() which subclasses of InputStream may or may not support,"(""InputStream"", ""has method"", ""mark()""); (""InputStream"", ""has method"", ""reset()""); (""InputStream"", ""has subclasses"", ""subclasses of InputStream"")"
java.nio.channels.Selector is not the Channel that pushes the data into the Selector and from there into the component even if that is what the above diagram suggests,"(""Selector"", ""is not"", ""Channel""); (""Channel"", ""pushes data into"", ""Selector""); (""Selector"", ""pushes data into"", ""component"")"
When connected you can also use the read() and write() method as if you were using a traditional channel,"(""read()"", ""is method of"", ""channel""); (""write()"", ""is method of"", ""channel""); (""read()"", ""used with"", ""write()""); (""channel"", ""has method"", ""read()""); (""channel"", ""has method"", ""write()"")"
"The mark() sets a mark internally in the InputStream which marks the point in the stream to which data has been read so far. The code using the InputStream can then continue reading data from it. If the code using the InputStream wants to go back to the point in the stream where the mark was set, the code calls reset() on the InputStream.",
These two types of tasks are represented by the RecursiveAction and RecursiveTask classes,"(""RecursiveAction"", ""isrepresentedby"", ""tasks""); (""RecursiveTask"", ""isrepresentedby"", ""tasks"")"
The java.util.concurrent package has the following implementations of the BlockingQueue interface,"(""java.util.concurrent"", ""has"", ""BlockingQueue""); (""BlockingQueue"", ""is_in"", ""java.util.concurrent"")"
If the objects in the Java List do not implement the Comparable interface or if you want to sort the objects in another order than their compare() implementation then you need to use a Comparator implementation (java.util.Comparator),"(""List"", ""does not implement"", ""Comparable""); (""Comparator"", ""implementation of"", ""java.util.Comparator""); (""Comparable"", ""has method"", ""compare()""); (""Java"", ""has package"", ""java.util""); (""Comparator"", ""is in package"", ""java.util""); (""List"", ""is in package"", ""java.util"")"
The Java SimpleDateFormat class is also capable of formatting a Date object into a StringBuffer instead of returning an individual String with the date formatted,"(""SimpleDateFormat"", ""is capable of formatting"", ""Date""); (""SimpleDateFormat"", ""formats into"", ""StringBuffer""); (""SimpleDateFormat"", ""formats into"", ""String"")"
If the markSupported() method returns false then mark() and reset() are not supported,"(""markSupported()"", ""returns"", ""false""); (""mark()"", ""is_supported_by"", ""markSupported()""); (""reset()"", ""is_supported_by"", ""markSupported()""); (""mark()"", ""is_related_to"", ""reset()""); (""markSupported()"", ""determines_support_for"", ""mark()""); (""markSupported()"", ""determines_support_for"", ""reset()"")"
The Matcher replaceAll() and replaceFirst() methods can be used to replace parts of the string the Matcher is searching through,"(""Matcher"", ""hasMethod"", ""replaceAll()""); (""Matcher"", ""hasMethod"", ""replaceFirst()"")"
In that way the PrintWriter is a bit different from other Writer subclasses which tend to have mostly constructors that can take other Writer instances as parameters (except for a few like OutputStreamWriter),"(""PrintWriter"", ""is a subclass of"", ""Writer""); (""OutputStreamWriter"", ""is a subclass of"", ""Writer""); (""Writer"", ""has subclasses"", ""PrintWriter""); (""Writer"", ""has subclasses"", ""OutputStreamWriter""); (""PrintWriter"", ""has different characteristics than"", ""Writer subclasses""); (""OutputStreamWriter"", ""has constructors that take"", ""Writer instances""); (""Writer subclasses"", ""have constructors that take"", ""Writer instances"")"
The reduce() method can be combined with the filter() method too,"(""reduce()"", ""can be combined with"", ""filter()"")"
In case you prefer to use Java NIO instead of Java Networking (standard API) then you can also use a ServerSocketChannel instead of the java.net.ServerSocket,"(""Java NIO"", ""uses instead of"", ""Java Networking""); (""ServerSocketChannel"", ""used instead of"", ""java.net.ServerSocket""); (""Java NIO"", ""prefers"", ""ServerSocketChannel""); (""Java Networking"", ""includes"", ""java.net.ServerSocket"")"
The problem is that since the doNotify() call only calls notify() and not notifyAll() only one thread is awakened even if 4 threads are waiting on the same string instance (the empty string),"(""doNotify"", ""calls"", ""notify""); (""notify"", ""awakens"", ""thread""); (""thread"", ""waits on"", ""string instance""); (""string instance"", ""is"", ""empty string"")"
You can convert a FileOutputStream to a character based Writer using the Java OutputStreamWriter class,"(""FileOutputStream"", ""converted to"", ""Writer""); (""FileOutputStream"", ""uses"", ""OutputStreamWriter""); (""OutputStreamWriter"", ""is a"", ""Writer"")"
The channel returned by the SelectionKey.channel() method should be cast to the channel you need to work with a ServerSocketChannel or SocketChannel etc,"(""SelectionKey"", ""channel()"", ""ServerSocketChannel""); (""SelectionKey"", ""channel()"", ""SocketChannel""); (""ServerSocketChannel"", ""cast to"", ""channel""); (""SocketChannel"", ""cast to"", ""channel""); (""SelectionKey"", ""method"", ""channel()""); (""ServerSocketChannel"", ""used with"", ""SelectionKey""); (""SocketChannel"", ""used with"", ""SelectionKey"")"
java.io.Writer works just like combining the Reader with InputStream or the Writer with OutputStream,"(""java.io.Writer"", ""works with"", ""Reader""); (""java.io.Writer"", ""works with"", ""InputStream""); (""java.io.Writer"", ""works with"", ""OutputStream""); (""Reader"", ""combined with"", ""InputStream""); (""Writer"", ""combined with"", ""OutputStream"")"
Object.wait(long timeout) means that the majority of the time waited to be able to lock the lock and enter the critical section is spent waiting in the wait() call inside the lock() method not being blocked trying to enter the lock() method,"(""Object"", ""hasMethod"", ""wait()""); (""wait()"", ""takesParameter"", ""long""); (""lock()"", ""hasMethod"", ""wait()""); (""lock()"", ""isCalledBy"", ""wait()""); (""wait()"", ""isCalledBy"", ""lock()""); (""lock()"", ""isBlockedBy"", ""lock()""); (""wait()"", ""waitsToEnter"", ""lock()""); (""lock()"", ""isEnteredBy"", ""wait()"")"
Remember that even if the 4 threads call wait() and notify() on the same shared string instance the signals from the doWait() and doNotify() calls are stored individually in the two MyWaitNotify instances,"(""MyWaitNotify"", ""has method"", ""wait()""); (""MyWaitNotify"", ""has method"", ""notify()""); (""MyWaitNotify"", ""stores signals from"", ""doWait()""); (""MyWaitNotify"", ""stores signals from"", ""doNotify()""); (""Thread"", ""calls method"", ""wait()""); (""Thread"", ""calls method"", ""notify()"")"
The rest of the components like Pipe and FileLock are merely utility classes to be used in conjunction with the three core components,"(""Pipe"", ""used with"", ""core components""); (""FileLock"", ""used with"", ""core components""); (""Pipe"", ""is"", ""utility class""); (""FileLock"", ""is"", ""utility class"")"
java.io.PrintStream example first creates a PrintStream which is connected to an OutputStream,"(""PrintStream"", ""connected to"", ""OutputStream""); (""java.io.PrintStream"", ""creates"", ""PrintStream"")"
"If the Deque is empty, pollLast() returns null. This is different than removeLast() which throws an exception if the Deque is empty.","(""Deque"", ""hasMethod"", ""pollLast()""); (""Deque"", ""hasMethod"", ""removeLast()""); (""pollLast()"", ""returns"", ""null""); (""removeLast()"", ""throws"", ""exception"")"
The Map computeIfAbsent() method works similarly to the compute() method but the lambda expression is only called if no entry exists already for the given key,"(""Map"", ""hasMethod"", ""computeIfAbsent()""); (""computeIfAbsent()"", ""similarTo"", ""compute()""); (""computeIfAbsent()"", ""uses"", ""lambda expression""); (""Map"", ""hasMethod"", ""compute()""); (""compute()"", ""uses"", ""lambda expression""); (""lambda expression"", ""calledBy"", ""computeIfAbsent()""); (""lambda expression"", ""calledBy"", ""compute()"")"
You can get and set the nanoseconds using the getNanos() and setNanos(),"(""getNanos()"", ""used with"", ""nanoseconds""); (""setNanos()"", ""used with"", ""nanoseconds""); (""getNanos()"", ""related to"", ""setNanos()"")"
This OutputStream write() example first creates a FileOutputStream to which the data will be written. Then the example enters a while loop. The condition to exit the while loop is the return value of the method hasMoreData().,"(""OutputStream"", ""uses"", ""FileOutputStream""); (""OutputStream"", ""has method"", ""write()""); (""FileOutputStream"", ""is used by"", ""OutputStream""); (""while loop"", ""uses method"", ""hasMoreData()""); (""hasMoreData()"", ""is method of"", ""unknown class"")"
Since the BufferedWriter collects the characters written internally in a buffer before writing them to the underlying Writer the speedup is not as noticeable as with other Writer classes (that do not use buffering),"(""BufferedWriter"", ""collects"", ""characters""); (""BufferedWriter"", ""writes"", ""Writer""); (""BufferedWriter"", ""uses"", ""buffering""); (""Writer"", ""is underlying"", ""BufferedWriter"")"
The Java compiler then generates the corresponding fields getter methods and a hashCode() and equals() method,"(""Java compiler"", ""generates"", ""fields""); (""Java compiler"", ""generates"", ""getter methods""); (""Java compiler"", ""generates"", ""hashCode() method""); (""Java compiler"", ""generates"", ""equals() method"")"
The bigger the result String grows the longer it takes to copy the characters from it into a new StringBuilder and again copy the characters from the StringBuilder into the temporary String created by the toString() method,"(""StringBuilder"", ""uses"", ""String""); (""String"", ""has method"", ""toString()""); (""StringBuilder"", ""copies characters from"", ""String""); (""String"", ""creates"", ""temporary String""); (""String"", ""has method"", ""toString()""); (""StringBuilder"", ""copies characters into"", ""String"")"
"Instead of calling the stop() method you will have to implement your thread code so it can be stopped, you can implements Runnable which contains an extra method called doStop() which signals to the Runnable to stop.","(""Thread"", ""contains"", ""Runnable""); (""Runnable"", ""contains"", ""stop()""); (""Runnable"", ""contains"", ""doStop()"")"
The logp() methods work like the log() methods except each method take an extra two parameters The sourceClass and sourceMethod parameter,"(""logp()"", ""is similar to"", ""log()""); (""logp()"", ""takes extra parameters"", ""sourceClass""); (""logp()"", ""takes extra parameters"", ""sourceMethod""); (""log()"", ""has variation"", ""logp()"")"
But since the thread waiting in lock() has not yet called queueObject.wait() the call to queueObject.notify() passes into oblivion,"(""lock"", ""has"", ""queueObject""); (""queueObject"", ""wait"", ""thread""); (""thread"", ""called"", ""queueObject.wait()""); (""queueObject"", ""notify"", ""oblivion"")"
It is possible to compare two buffers using equals() and compareTo(),"(""Buffer"", ""equals()"", ""Buffer""); (""Buffer"", ""compareTo()"", ""Buffer"")"
The names take() and release() may seem a bit odd when using a semaphore for signaling,"(""semaphore"", ""has method"", ""take()""); (""semaphore"", ""has method"", ""release()"")"
If you need to read and write the date and time to a database use the java.sql.Date and java.sql.Timestamp classes,"(""java.sql.Date"", ""used_with"", ""database""); (""java.sql.Timestamp"", ""used_with"", ""database""); (""java.sql.Date"", ""related_to"", ""java.sql.Timestamp""); (""database"", ""uses"", ""java.sql.Date""); (""database"", ""uses"", ""java.sql.Timestamp"")"
Since PipedOutputStream is a subclass of OutputStream PipedOutputStream has the same basic methods and use patterns as an OutputStream,"(""PipedOutputStream"", ""is a subclass of"", ""OutputStream""); (""PipedOutputStream"", ""has methods"", ""OutputStream"")"
In the following sections I will explain how to use the ReentrantLock class as a Lock,"(""ReentrantLock"", ""is a"", ""Lock"")"
In contrast to the signaling use case the methods take() and release() are now called by the same thread,"(""signaling use case"", ""has methods"", ""take()""); (""signaling use case"", ""has methods"", ""release()""); (""methods"", ""are called by"", ""same thread""); (""take()"", ""is called by"", ""same thread""); (""release()"", ""is called by"", ""same thread"")"
The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called,"(""notify()"", ""called by"", ""threads""); (""notifyAll()"", ""called by"", ""threads""); (""notify()"", ""related to"", ""notifyAll()""); (""threads"", ""wait on"", ""notify()""); (""threads"", ""wait on"", ""notifyAll()"")"
The Matcher appendReplacement() and appendTail() methods are used to replace string tokens in an input text and append the resulting string to a StringBuffer,"(""Matcher"", ""hasMethod"", ""appendReplacement()""); (""Matcher"", ""hasMethod"", ""appendTail()""); (""appendReplacement()"", ""usedTo"", ""replaceStringTokens""); (""appendTail()"", ""usedTo"", ""appendString""); (""Matcher"", ""operatesOn"", ""StringBuffer"")"
The Java BufferedReader class is a subclass of the Java Reader class so you can use a BufferedReader anywhere a Reader is required,"(""BufferedReader"", ""is a subclass of"", ""Reader""); (""BufferedReader"", ""can be used in place of"", ""Reader"")"
You can convert a Java Set to a Java List by creating a List and calling its addAll() method passing the Set as parameter to the addAll() method,"(""Java Set"", ""converted to"", ""Java List""); (""Java List"", ""has method"", ""addAll()""); (""addAll()"", ""takes parameter"", ""Java Set"")"
The add() and offer() methods differ in how the behave if the Queue is full so no more elements can be added,"(""Queue"", ""hasMethod"", ""add()""); (""Queue"", ""hasMethod"", ""offer()""); (""add()"", ""differsFrom"", ""offer()"")"
The Collections binarySearch() method can search a Java List for an element using a binary search algorithm. The List must be sorted in ascending order before you search it using binarySearch() .,"(""Collections"", ""hasMethod"", ""binarySearch()""); (""List"", ""mustBeSortedBy"", ""binarySearch()""); (""binarySearch()"", ""usesAlgorithm"", ""binary search algorithm""); (""List"", ""mustBeInOrder"", ""ascending order"")"
If unlockWrite() was not called from inside a finallyclause and an exception was thrown from the critical section the ReadWriteLock would remain write locked forever causing all threads calling lockRead() or lockWrite() on that ReadWriteLock instance to halt indefinately,"(""ReadWriteLock"", ""has method"", ""unlockWrite()""); (""ReadWriteLock"", ""has method"", ""lockRead()""); (""ReadWriteLock"", ""has method"", ""lockWrite()""); (""unlockWrite()"", ""called from"", ""finally clause""); (""ReadWriteLock"", ""remains in state"", ""write locked""); (""lockRead()"", ""blocks on"", ""ReadWriteLock""); (""lockWrite()"", ""blocks on"", ""ReadWriteLock"")"
Third the characters written to the StringWriter are obtained via the two methods toString() and getBuffer(),"(""StringWriter"", ""hasMethod"", ""toString()""); (""StringWriter"", ""hasMethod"", ""getBuffer()"")"
The decrementAndGet() subtracts 1 from the AtomicInteger value and returns its value after the subtraction. The getAndDecrement() also subtracts 1 from the AtomicInteger value but returns the value the AtomicInteger had before the subtraction.,"(""AtomicInteger"", ""hasMethod"", ""decrementAndGet()""); (""AtomicInteger"", ""hasMethod"", ""getAndDecrement()""); (""decrementAndGet()"", ""subtractsFrom"", ""AtomicInteger""); (""getAndDecrement()"", ""subtractsFrom"", ""AtomicInteger""); (""decrementAndGet()"", ""returns"", ""AtomicInteger.value""); (""getAndDecrement()"", ""returns"", ""AtomicInteger.value"")"
"If the Deque is empty, removeLast() will throw an exception. This is different from pollLast() which returns null if the Deque is empty.","(""Deque"", ""hasMethod"", ""removeLast()""); (""Deque"", ""hasMethod"", ""pollLast()""); (""removeLast()"", ""throwsExceptionWhen"", ""Deque""); (""pollLast()"", ""returnsWhen"", ""Deque"")"
You may be familiar with these two wellknown PrintStream instances in Java System.out and System.err,"(""PrintStream"", ""is_instance_of"", ""System.out""); (""PrintStream"", ""is_instance_of"", ""System.err""); (""System"", ""contains"", ""System.out""); (""System"", ""contains"", ""System.err"")"
"If adding the element fails, for instance if the Deque is full, the push() method will throw an exception. This is similar to how the addFirst() method works.","(""Deque"", ""has method"", ""push()""); (""Deque"", ""has method"", ""addFirst()""); (""push()"", ""throws"", ""exception""); (""addFirst()"", ""throws"", ""exception"")"
Finally you can access the localized values in the ResourceBundle via its different getString() and getObject() etc,"(""ResourceBundle"", ""hasMethod"", ""getString()""); (""ResourceBundle"", ""hasMethod"", ""getObject()"")"
"The tailMap() method is similar to the headMap() method, except that tailMap() returns all elements that are equal to or higher than the given parameter element.","(""tailMap"", ""similar to"", ""headMap""); (""tailMap"", ""returns"", ""elements""); (""headMap"", ""compared to"", ""tailMap""); (""tailMap"", ""returns elements that are"", ""equal to or higher than parameter element"")"
That you would not call wait() and notify() on an internal monitor object but rather on the This is probably true,"(""Object"", ""has method"", ""wait()""); (""Object"", ""has method"", ""notify()"")"
You can parse a String into a java.util.Date instance using the parse() method of the SimpleDateFormat instance,"(""String"", ""parsed into"", ""java.util.Date""); (""java.util.Date"", ""parsed by"", ""SimpleDateFormat""); (""SimpleDateFormat"", ""has method"", ""parse()""); (""String"", ""used with"", ""SimpleDateFormat"")"
"If the Deque is empty, peekFirst() returns null. This is similar to how peek() works","(""Deque"", ""hasMethod"", ""peekFirst()""); (""Deque"", ""hasMethod"", ""peek()"")"
When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start() like this,"(""Thread"", ""hasMethod"", ""run()""); (""Thread"", ""hasMethod"", ""start()"")"
java.util.logging.Handler is not a Filter even though it has the same effect,"(""java.util.logging.Handler"", ""has effect of"", ""Filter"")"
The Java PrintStream class contains the powerful format() and printf() methods (they do exactly the same but the name printf is more familiar to Cprogrammers),"(""Java PrintStream"", ""contains"", ""format()""); (""Java PrintStream"", ""contains"", ""printf()""); (""format()"", ""is equivalent to"", ""printf()""); (""printf()"", ""is similar to"", ""C printf()"")"
java.util.TreeSet Comparator will then decide the ordering of the elements in the TreeSet,"(""TreeSet"", ""uses"", ""Comparator""); (""Comparator"", ""decides"", ""ordering""); (""TreeSet"", ""has"", ""elements"")"
Exactly how to handle the calls to commit() and or rollback() is covered in the JDBC Transactions Tutorial,"(""JDBC"", ""hasTransactionMethod"", ""commit()""); (""JDBC"", ""hasTransactionMethod"", ""rollback()"")"
You may be tempted then to always call notifyAll() instead notify() but this is a bad idea performance wise,"(""notifyAll()"", ""is alternative to"", ""notify()""); (""notify()"", ""has alternative"", ""notifyAll()""); (""notifyAll()"", ""affects"", ""performance""); (""notify()"", ""affects"", ""performance"")"
The File class contains the method mkdir() and mkdirs() for that purpose,"(""File"", ""contains"", ""mkdir()""); (""File"", ""contains"", ""mkdirs()"")"
The lock() method locks the Lock instance so that all threads calling lock() are blocked until unlock() is executed,"(""Lock"", ""hasMethod"", ""lock()""); (""lock()"", ""blocks"", ""threads""); (""Lock"", ""hasMethod"", ""unlock()""); (""unlock()"", ""unblocks"", ""threads""); (""lock()"", ""isBlockedUntil"", ""unlock()"")"
The call to read() reads a character from the PushbackReader just like from any other Reader,"(""PushbackReader"", ""reads from"", ""Reader""); (""PushbackReader"", ""has method"", ""read()""); (""Reader"", ""has method"", ""read()"")"
java.io.BufferedInputStream is typically much faster than reading a single byte at a time from an InputStream especially for disk access and larger data amounts,"(""java.io.BufferedInputStream"", ""is faster than"", ""InputStream""); (""InputStream"", ""is used for"", ""disk access""); (""InputStream"", ""is used for"", ""larger data amounts""); (""java.io.BufferedInputStream"", ""is used for"", ""disk access""); (""java.io.BufferedInputStream"", ""is used for"", ""larger data amounts"")"
Even though the Java Networking APIs enable you to open and close network connections via sockets all communication happens via the Java IO classes InputStream and OutputStream,"(""Java Networking APIs"", ""enable"", ""network connections""); (""Java Networking APIs"", ""use"", ""sockets""); (""Java IO classes"", ""include"", ""InputStream""); (""Java IO classes"", ""include"", ""OutputStream""); (""InputStream"", ""handle"", ""communication""); (""OutputStream"", ""handle"", ""communication""); (""sockets"", ""facilitate"", ""communication""); (""Java Networking APIs"", ""use"", ""Java IO classes"")"
The tailMap() method is similar to the headMap() method except that tailMap() returns all elements that are equal to or higher than the given parameter element,"(""Map"", ""hasMethod"", ""tailMap()""); (""Map"", ""hasMethod"", ""headMap()""); (""tailMap()"", ""returns"", ""elements""); (""headMap()"", ""returns"", ""elements""); (""tailMap()"", ""similarto"", ""headMap()"")"
Again here the first() and next() methods return the unicode index of the found word boundary,"(""first()"", ""returns"", ""unicode index""); (""next()"", ""returns"", ""unicode index""); (""first()"", ""is_method_of"", ""String""); (""next()"", ""is_method_of"", ""String"")"
"The `getAndIncrement()` method does the same as the `incrementAndGet()` method, except the `getAndIncrement()` method returns the value of the element *before* it is incremented.","(""getAndIncrement()"", ""is same as"", ""incrementAndGet()""); (""getAndIncrement()"", ""returns"", ""element value""); (""incrementAndGet()"", ""returns"", ""element value"")"
When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start(),"(""Thread"", ""has method"", ""run()""); (""Thread"", ""has method"", ""start()""); (""Thread"", ""calls"", ""run()""); (""Thread"", ""calls"", ""start()"")"
Obviously if the input parameter to contains() is null the contains() method will not use the equals() method to compare against each element but rather use the == operator,"(""contains()"", ""uses"", ""equals()""); (""equals()"", ""compared by"", ""==""); (""contains()"", ""compares against"", ""element"")"
Thus you can use the return values of start() and end() inside a String.substring() call,"(""String"", ""contains"", ""start""); (""String"", ""contains"", ""end""); (""String"", ""contains"", ""substring""); (""start"", ""isMethodOf"", ""unknown""); (""end"", ""isMethodOf"", ""unknown""); (""substring"", ""isMethodOf"", ""String"")"
The PrintWriter class has all the same methods as the PrintStream except for the methods to write raw bytes,"(""PrintWriter"", ""has methods"", ""PrintStream""); (""PrintStream"", ""has methods"", ""PrintWriter""); (""PrintWriter"", ""does not have methods"", ""write raw bytes""); (""PrintStream"", ""has methods"", ""write raw bytes"")"
"The Java SortedMap interface, java.util.SortedMap, is a subtype of the java.util.Map interface, with the addition that the elements stored in a Java SortedMap map are sorted internally. This means you can iterate the elements stored in a SortedMap in the sort order.","(""java.util.SortedMap"", ""is a subtype of"", ""java.util.Map""); (""java.util.Map"", ""has elements"", ""java.util.SortedMap""); (""java.util.SortedMap"", ""stores"", ""elements""); (""elements"", ""are sorted in"", ""java.util.SortedMap""); (""java.util.SortedMap"", ""can be iterated in"", ""sort order"")"
Similarly the compareTo() method should throw a ClassCastException if the input parameter is not of the same class as the class of the object compareTo() is called on,"(""compareTo()"", ""is called on"", ""object""); (""object"", ""has method"", ""compareTo()""); (""ClassCastException"", ""is thrown by"", ""compareTo()""); (""compareTo()"", ""throws exception if input parameter is not of same class as"", ""class of object""); (""class of object"", ""has method"", ""compareTo()""); (""input parameter"", ""is not of same class as"", ""class of object""); (""compareTo()"", ""takes input parameter of"", ""class of object"")"
The class java.lang.Object defines three methods wait() notify() and notifyAll() to facilitate this,"(""java.lang.Object"", ""defines"", ""wait()""); (""java.lang.Object"", ""defines"", ""notify()""); (""java.lang.Object"", ""defines"", ""notifyAll()"")"
Both Java File and FileChannel works but in case you want a pure Java NIO solution use the Java NIO FileChannel class,"(""Java File"", ""works with"", ""FileChannel""); (""Java NIO"", ""uses"", ""FileChannel""); (""FileChannel"", ""is part of"", ""Java NIO"")"
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicLong,"(""AtomicLong"", ""hasMethod"", ""getAndIncrement()""); (""AtomicLong"", ""hasMethod"", ""incrementAndGet()""); (""AtomicLong"", ""hasMethod"", ""getAndAdd()""); (""AtomicLong"", ""hasMethod"", ""addAndGet()""); (""getAndIncrement()"", ""similarTo"", ""getAndAdd()""); (""getAndIncrement()"", ""similarTo"", ""addAndGet()""); (""incrementAndGet()"", ""similarTo"", ""getAndAdd()""); (""incrementAndGet()"", ""similarTo"", ""addAndGet()"")"
"celingEntry(), floorEntry(), higherEntry(), lowerEntry(),The NavigableMap also has methods to get the entry for a given key, rather than the key itself. These methods behave like the ceilingKey() etc. methods, except they return a Map.Entry instead of the key object itself.","(""NavigableMap"", ""has method"", ""ceilingKey()""); (""NavigableMap"", ""has method"", ""floorEntry()""); (""NavigableMap"", ""has method"", ""higherEntry()""); (""NavigableMap"", ""has method"", ""lowerEntry()""); (""NavigableMap"", ""has method"", ""ceilingEntry()""); (""ceilingKey()"", ""returns"", ""key object""); (""floorEntry()"", ""returns"", ""Map.Entry""); (""higherEntry()"", ""returns"", ""Map.Entry""); (""lowerEntry()"", ""returns"", ""Map.Entry""); (""ceilingEntry()"", ""returns"", ""Map.Entry"")"
The Java GZIPOutputStream class (java.util.zip.GZIPOutStream) can be used to GZIP compress data and write it to an OutputStream,"(""GZIPOutputStream"", ""is part of"", ""java.util.zip""); (""GZIPOutputStream"", ""uses"", ""OutputStream""); (""GZIPOutputStream"", ""provides"", ""GZIP compression""); (""java.util.zip"", ""contains"", ""GZIPOutputStream"")"
Object.wait(long timeout) allows other threads to call wait() or notify() too since these methods must be called from inside a synchronized block,"(""Object"", ""hasMethod"", ""wait()""); (""wait()"", ""calledFrom"", ""synchronized block""); (""Object"", ""hasMethod"", ""notify()""); (""notify()"", ""calledFrom"", ""synchronized block""); (""wait()"", ""relatedTo"", ""notify()"")"
The java.util.TimeZone class is used in conjunction with the java.util.Calendar class,"(""java.util.TimeZone"", ""used in conjunction with"", ""java.util.Calendar"")"
You do so by calling the Cipher update() or doFinal() methods,"(""Cipher"", ""has method"", ""update()""); (""Cipher"", ""has method"", ""doFinal()"")"
The BlockingDeque interface in the java.util.concurrent class represents a deque which is thread safe to put into and take instances from,"(""BlockingDeque"", ""is part of"", ""java.util.concurrent""); (""BlockingDeque"", ""represents"", ""deque""); (""deque"", ""is"", ""thread safe""); (""BlockingDeque"", ""allows"", ""put""); (""BlockingDeque"", ""allows"", ""take"")"
Here are two examples of taking an element from a Java Queue using its poll() and remove() methods,"(""Java Queue"", ""has method"", ""poll()""); (""Java Queue"", ""has method"", ""remove()"")"
If you need an integer value use the round() floor() or ceil() method,"(""round()"", ""is a method of"", ""integer value""); (""floor()"", ""is a method of"", ""integer value""); (""ceil()"", ""is a method of"", ""integer value"")"
Notice how it is possible to change that reference through both the setValue() and add() methods,"(""setValue()"", ""is method of"", ""unknown class""); (""add()"", ""is method of"", ""unknown class""); (""unknown class"", ""has method"", ""setValue()""); (""unknown class"", ""has method"", ""add()"")"
a given date is or convert dates and times between time zones use the java.util.Calendar and java.util.GregorianCalendar classes,"(""java.util.Calendar"", ""uses"", ""java.util.GregorianCalendar""); (""java.util.GregorianCalendar"", ""extends"", ""java.util.Calendar""); (""java.util.Calendar"", ""used for"", ""date conversion""); (""java.util.GregorianCalendar"", ""used for"", ""time conversion""); (""java.util.Calendar"", ""used for"", ""time zones""); (""java.util.GregorianCalendar"", ""used for"", ""time zones"")"
If the call to take() happens before the call to release() the thread calling release() will still know that take() was called because the signal is stored internally in the signal variable,"(""Thread"", ""calls"", ""take()""); (""Thread"", ""calls"", ""release()""); (""take()"", ""happens before"", ""release()""); (""release()"", ""stores signal in"", ""signal variable""); (""Thread"", ""uses"", ""signal variable"")"
The compareAndSet() method can compare the reference stored in the AtomicReference instance with an expected reference and if they two references are the same (not equal as in equals() but same as in ==) then a new reference can be set on the AtomicReference instance,"(""AtomicReference"", ""has method"", ""compareAndSet()""); (""compareAndSet()"", ""compares"", ""reference""); (""reference"", ""is stored in"", ""AtomicReference""); (""compareAndSet()"", ""sets"", ""new reference""); (""AtomicReference"", ""uses"", ""equals()"")"
Anders Hejlsberg on checked vs. unchecked exceptions httpwww.artima.comintvhandcuffs.html James Gosling on checked exceptions httpwww.artima.comintvsolid.html Bill Venners on Exceptions httpwww.artima.cominterfacedesignexceptions.html Bruce Eckel on checked exceptions httpwww.artima.comintvtypingP.html Designing with Exceptions (Bill Venners www.artima.com) httpwww.artima.comdesigntechniquesdesexcept.html Effective Java (Joshua Bloch Addison Wesley 2001) Daniel Pietraru in favor of checked exceptions Exceptional Java Checked exceptions are priceless?For everything else there is the RuntimeException,"(""unchecked exceptions"", ""discussed by"", ""Anders Hejlsberg""); (""checked exceptions"", ""discussed by"", ""James Gosling""); (""Exceptions"", ""discussed by"", ""Bill Venners""); (""checked exceptions"", ""discussed by"", ""Bruce Eckel""); (""Exceptions"", ""discussed in"", ""Designing with Exceptions""); (""Effective Java"", ""written by"", ""Joshua Bloch""); (""checked exceptions"", ""supported by"", ""Daniel Pietraru""); (""RuntimeException"", ""used for"", ""everything else"")"
But the thread waiting in the lock() method will not leave that block until the isLocked is set to false and a monitorObject.notify() is executed as it happens in unlock(),"(""lock()"", ""is part of"", ""thread""); (""lock()"", ""waits for"", ""isLocked""); (""isLocked"", ""set to"", ""false""); (""monitorObject"", ""has method"", ""notify()""); (""unlock()"", ""executes"", ""monitorObject.notify()""); (""lock()"", ""blocked by"", ""isLocked"")"
As you saw in the previous section when you register a Channel with a Selector the register() method returns a SelectionKey objects,"(""Channel"", ""register"", ""Selector""); (""register"", ""returns"", ""SelectionKey""); (""Channel"", ""register"", ""SelectionKey"")"
By walking through all directories and deleting all files (inside visitFile()) in each directory and afterwards delete the directory itself (inside postVisitDirectory()) you can delete a directory with all subdirectories and files,"(""visitFile()"", ""inside"", ""delete files""); (""postVisitDirectory()"", ""inside"", ""delete directory""); (""visitFile()"", ""called in"", ""walking through directories""); (""postVisitDirectory()"", ""called after"", ""visiting files""); (""walking through directories"", ""includes"", ""visitFile()""); (""walking through directories"", ""includes"", ""postVisitDirectory()"")"
The lower() method does the opposite of the higher() method meaning it returns the highest element that is less than (not equal to) the given parameter,"(""lower()"", ""is opposite of"", ""higher()"")"
In many cases though you can replace the use of the File class with use of the Path interface,"(""File"", ""replaced by"", ""Path"")"
Once the Mac instance is initialized you can calculate a MAC from data by calling the update() and doFinal() method,"(""Mac"", ""has method"", ""update()""); (""Mac"", ""has method"", ""doFinal()"")"
Deque.offerFirst(E e) is different from the addFirst() method which will throw an exception is adding an element to the beginning of the Deque fails,"(""Deque"", ""has method"", ""offerFirst()""); (""Deque"", ""has method"", ""addFirst()""); (""offerFirst()"", ""differs from"", ""addFirst()""); (""addFirst()"", ""throws exception when"", ""adding element to beginning of Deque""); (""Deque"", ""has operation"", ""adding element to beginning"")"
The main difference between the Runnable run() method and the Callable call() method is that the call() method can return an Object from the method call,"(""Runnable"", ""has method"", ""run()""); (""Callable"", ""has method"", ""call()""); (""call()"", ""returns"", ""Object"")"
The toNanos() is different from the getNano() in that the getNano() only returns the part of the Duration which is less than one second,"(""Duration"", ""hasMethod"", ""toNanos()""); (""Duration"", ""hasMethod"", ""getNano()""); (""getNano()"", ""returnsPartOf"", ""Duration""); (""toNanos()"", ""returns"", ""Duration"")"
Collection.add(E e) is different from the offer() method which will return false if it cannot insert the element,"(""Collection"", ""has method"", ""add()""); (""Collection"", ""has method"", ""offer()""); (""add()"", ""returns"", ""boolean""); (""offer()"", ""returns"", ""boolean""); (""Collection"", ""contains method"", ""add()""); (""Collection"", ""contains method"", ""offer()"")"
To take an element from a Java Queue you can call either its poll() or remove() method,"(""Java Queue"", ""has method"", ""poll()""); (""Java Queue"", ""has method"", ""remove()"")"
java.util.TreeMap Comparator will then be used to sort the keys of the key value pairs stored in the SortedMap,"(""Comparator"", ""used to sort"", ""keys""); (""TreeMap"", ""stores"", ""key value pairs""); (""SortedMap"", ""stores"", ""key value pairs""); (""Comparator"", ""used in"", ""TreeMap""); (""TreeMap"", ""implements"", ""SortedMap"")"
If a thread calls lock() twice without calling unlock() in between the second call to lock() will block,"(""thread"", ""calls"", ""lock()""); (""lock()"", ""is called by"", ""thread""); (""lock()"", ""blocks"", ""thread""); (""thread"", ""calls"", ""lock() twice""); (""lock()"", ""is called twice by"", ""thread""); (""second call to lock()"", ""blocks"", ""thread""); (""lock()"", ""requires"", ""unlock()""); (""thread"", ""must call"", ""unlock()""); (""unlock()"", ""is called by"", ""thread""); (""unlock()"", ""unblocks"", ""lock()"")"
The start() call will return as soon as the thread is started. It will not wait until the run() method is done.,"(""thread"", ""has method"", ""start()""); (""thread"", ""has method"", ""run()""); (""start()"", ""returns"", ""thread""); (""run()"", ""is method of"", ""thread"")"
"If the Deque is empty, peekFirst() returns null. This is similar to how peek() works, but the method name peekFirst() is a bit more saying about which end of the Deque you peek at.","(""Deque"", ""hasMethod"", ""peekFirst()""); (""Deque"", ""hasMethod"", ""peek()"")"
If isLocked is true however the thread calling lock() is parked waiting in the monitorObject.wait() call,"(""lock()"", ""is called by"", ""thread""); (""monitorObject"", ""has method"", ""wait()""); (""lock()"", ""waits in"", ""monitorObject.wait()""); (""thread"", ""calls"", ""lock()""); (""lock()"", ""is affected by"", ""isLocked"")"
The remove() method will use the o.equals() to decide if the object o passed as parameter matches a given element in the BlockingQueue.,"(""remove()"", ""uses"", ""o.equals()""); (""remove()"", ""parameter"", ""o""); (""BlockingQueue"", ""contains"", ""element""); (""o"", ""passed to"", ""remove()""); (""o.equals()"", ""called by"", ""remove()"")"
"In general you can call the?markSupported()?method to find out if?mark()?and?reset()are supported on a given?InputStream?or not, but the?BufferedInputStream?supports them.","(""InputStream"", ""hasMethod"", ""markSupported()""); (""InputStream"", ""hasMethod"", ""mark()""); (""InputStream"", ""hasMethod"", ""reset()""); (""BufferedInputStream"", ""supports"", ""mark()""); (""BufferedInputStream"", ""supports"", ""reset()""); (""BufferedInputStream"", ""isSubclassOf"", ""InputStream"")"
If you compare the Lock and FairLock classes you will notice that there is somewhat more going on inside the lock() and unlock() in the FairLock class,"(""Lock"", ""hasMethod"", ""lock()""); (""Lock"", ""hasMethod"", ""unlock()""); (""FairLock"", ""hasMethod"", ""lock()""); (""FairLock"", ""hasMethod"", ""unlock()""); (""Lock"", ""comparedTo"", ""FairLock"")"
The third variant of getConnection() takes a database URL and a Properties object as parameter,"(""getConnection()"", ""takes"", ""database URL""); (""getConnection()"", ""takes"", ""Properties object""); (""getConnection()"", ""parameter"", ""database URL""); (""getConnection()"", ""parameter"", ""Properties object"")"
"You can get the current line number from the?LineNumberReader?by calling the?getLineNumber()method. You can also set the current line number, should you need to, by calling the?setLineNumber()?method","(""LineNumberReader"", ""has method"", ""getLineNumber()""); (""LineNumberReader"", ""has method"", ""setLineNumber()""); (""getLineNumber()"", ""belongs to"", ""LineNumberReader""); (""setLineNumber()"", ""belongs to"", ""LineNumberReader"")"
Executing unlock() sets isLocked back to false and notifies (awakens) one of the threads waiting in the wait() call in the lock() method if any,"(""lock()"", ""has method"", ""wait()""); (""lock()"", ""has method"", ""unlock()""); (""unlock()"", ""sets"", ""isLocked""); (""wait()"", ""is called in"", ""lock()""); (""unlock()"", ""notifies"", ""threads""); (""threads"", ""are waiting in"", ""wait()"")"
The SimpleDateFormat class does this via a version of the format() method that takes the Date StringBuffer and a FieldPosition instance as parameters,"(""SimpleDateFormat"", ""has method"", ""format()""); (""format()"", ""takes parameter"", ""Date""); (""format()"", ""takes parameter"", ""StringBuffer""); (""format()"", ""takes parameter"", ""FieldPosition"")"
The getAndIncrement() method does the same as the incrementAndGet() method except the getAndIncrement() method returns the value of the element before it is incremented,"(""getAndIncrement()"", ""is similar to"", ""incrementAndGet()""); (""getAndIncrement()"", ""returns"", ""value""); (""incrementAndGet()"", ""returns"", ""value""); (""getAndIncrement()"", ""increments"", ""element""); (""incrementAndGet()"", ""increments"", ""element"")"
java.util.TreeMap Comparator will then be used to sort the keys of the key value pairs stored in the NavigableMap,"(""Comparator"", ""used to sort"", ""keys""); (""TreeMap"", ""stores"", ""key value pairs""); (""TreeMap"", ""implements"", ""NavigableMap""); (""NavigableMap"", ""has"", ""keys""); (""Comparator"", ""sorts"", ""keys in NavigableMap"")"
In other words the calling thread must call wait() or notify() from inside a synchronized block,"(""Thread"", ""calls"", ""wait()""); (""Thread"", ""calls"", ""notify()""); (""wait()"", ""is called from"", ""synchronized block""); (""notify()"", ""is called from"", ""synchronized block"")"
As you can see both the waiting and notifying thread calls wait() and notify() from within a synchronized block,"(""Thread"", ""calls"", ""wait()""); (""Thread"", ""calls"", ""notify()""); (""wait()"", ""within"", ""synchronized block""); (""notify()"", ""within"", ""synchronized block"")"
However unless you need to specify all these parameters explicitly for your ThreadPoolExecutor it is often easier to use one of the factory methods in the java.util.concurrent.Executors class as shown in the ExecutorService text,"(""ThreadPoolExecutor"", ""uses"", ""Executors""); (""Executors"", ""has"", ""factory methods""); (""ExecutorService"", ""is related to"", ""java.util.concurrent.Executors""); (""ThreadPoolExecutor"", ""is type of"", ""ExecutorService""); (""Executors"", ""is in"", ""java.util.concurrent"")"
"You can choose between the following Deque implementations in the Java Collections API:java.util.LinkedList,java.util.ArrayDeque","(""java.util.LinkedList"", ""is_a"", ""Deque""); (""java.util.ArrayDeque"", ""is_a"", ""Deque""); (""Deque"", ""is_implemented_by"", ""java.util.LinkedList""); (""Deque"", ""is_implemented_by"", ""java.util.ArrayDeque"")"
Put shortly the thread waiting in lock() needs an unlock() call to execute successfully for it to exit lock() and the synchronized blocks inside it,"(""thread"", ""needs"", ""unlock()""); (""lock()"", ""has"", ""synchronized blocks""); (""thread"", ""waits in"", ""lock()""); (""lock()"", ""requires"", ""unlock()""); (""synchronized blocks"", ""are inside"", ""lock()"")"
Java NIO has more classes and components than these but the Channel Buffer and Selector forms the core of the API in my opinion,"(""Java NIO"", ""has"", ""Channel""); (""Java NIO"", ""has"", ""Buffer""); (""Java NIO"", ""has"", ""Selector""); (""Channel"", ""forms core of"", ""Java NIO API""); (""Buffer"", ""forms core of"", ""Java NIO API""); (""Selector"", ""forms core of"", ""Java NIO API"")"
The DateTimeFormatter is located in the java.time.format package so the fully qualified class name is java.time.format.DateTimeFormatter,"(""DateTimeFormatter"", ""is located in"", ""java.time.format""); (""DateTimeFormatter"", ""has fully qualified class name"", ""java.time.format.DateTimeFormatter""); (""java.time.format"", ""contains"", ""DateTimeFormatter"")"
The ceilingEntry() is thus similar to the ceilingKey() method except the ceilingKey() method only returns the key and ceilingKey() returns a Map.Entry object containing both the key and value,"(""ceilingEntry"", ""similar to"", ""ceilingKey""); (""ceilingKey"", ""returns"", ""key""); (""ceilingEntry"", ""returns"", ""Map.Entry""); (""Map.Entry"", ""contains"", ""key""); (""Map.Entry"", ""contains"", ""value"")"
"unless you need to specify all these parameters explicitly for your ThreadPoolExecutor, it is often easier to use one of the factory methods in the java.util.concurrent.Executors class","(""ThreadPoolExecutor"", ""uses"", ""Executors""); (""Executors"", ""has"", ""factory methods""); (""ThreadPoolExecutor"", ""created by"", ""Executors""); (""Executors"", ""is in"", ""java.util.concurrent""); (""ThreadPoolExecutor"", ""is in"", ""java.util.concurrent"")"
Once the read operation has completed the data read into the ByteBuffer and then into a String and printed to System.out,"(""ByteBuffer"", ""has operation"", ""read operation""); (""read operation"", ""completes into"", ""String""); (""String"", ""is printed to"", ""System.out"")"
javax.lang.model.util.Elements is possible to specify generic types for most (if not all) of the components in the Java Collections API,"(""javax.lang.model.util.Elements"", ""uses"", ""Java Collections API""); (""Java Collections API"", ""contains"", ""components""); (""javax.lang.model.util.Elements"", ""specifies"", ""generic types""); (""components"", ""are part of"", ""Java Collections API""); (""javax.lang.model.util.Elements"", ""is part of"", ""Java API"")"
The Java PrintWriter class contains the powerful format() and printf() methods,"(""Java PrintWriter"", ""contains"", ""format()""); (""Java PrintWriter"", ""contains"", ""printf()"")"
If an InputStream subclass supports the mark() and reset() methods then that subclass should override the markSupported() to return true,"(""InputStream"", ""supports"", ""mark()""); (""InputStream"", ""supports"", ""reset()""); (""mark() and reset()"", ""overridden by"", ""markSupported()""); (""markSupported()"", ""returns"", ""true""); (""InputStream subclass"", ""overrides"", ""markSupported()"")"
Not until a thread has called release() will the thread calling take() be allowed to deliver its signal,"(""thread"", ""calls"", ""release()""); (""thread"", ""calls"", ""take()""); (""take()"", ""is allowed after"", ""release()"")"
The poll() and remove() both removes the first element in the Queue. They differ in how they behave if the Queue is empty. The poll() method returns null if the Queue is empty. The remove() method throws an exception if the Queue is empty.,"(""Queue"", ""hasMethod"", ""poll()""); (""Queue"", ""hasMethod"", ""remove()""); (""poll()"", ""returns"", ""null""); (""remove()"", ""throws"", ""exception""); (""Queue"", ""contains"", ""element"")"
Notice how the execute() method will throw an IllegalStateException if execute() is called after stop() has been called,"(""execute()"", ""throws"", ""IllegalStateException""); (""execute()"", ""called after"", ""stop()""); (""stop()"", ""called before"", ""execute()"")"
The methods hashCode() and equals() play a distinct role in the objects you insert into Java collections,"(""Java collections"", ""contain"", ""objects""); (""objects"", ""use"", ""hashCode()""); (""objects"", ""use"", ""equals()""); (""hashCode()"", ""play role in"", ""Java collections""); (""equals()"", ""play role in"", ""Java collections"")"
Notice the two synchronized blocks inside the set() and get() method,"(""set()"", ""contains"", ""synchronized blocks""); (""get()"", ""contains"", ""synchronized blocks""); (""set()"", ""inside"", ""method""); (""get()"", ""inside"", ""method""); (""set()"", ""has"", ""synchronized blocks""); (""get()"", ""has"", ""synchronized blocks"")"
Therefore if a thread calls notify() before the thread to signal has called wait() the signal will be missed by the waiting thread,"(""thread"", ""calls"", ""notify()""); (""thread"", ""calls"", ""wait()""); (""notify()"", ""is called before"", ""wait()""); (""thread to signal"", ""has called"", ""wait()""); (""waiting thread"", ""misses"", ""signal""); (""signal"", ""is missed by"", ""waiting thread""); (""thread"", ""waits on"", ""wait()""); (""thread to signal"", ""signals"", ""waiting thread"")"
"celingEntry(), floorEntry(), higherEntry(), lowerEntry(),These methods behave like the ceilingKey() etc. methods, except they return a Map.Entry instead of the key object itself.","(""ceilingKey"", ""similar to"", ""ceilingEntry""); (""ceilingEntry"", ""returns"", ""Map.Entry""); (""floorKey"", ""similar to"", ""floorEntry""); (""floorEntry"", ""returns"", ""Map.Entry""); (""higherKey"", ""similar to"", ""higherEntry""); (""higherEntry"", ""returns"", ""Map.Entry""); (""lowerKey"", ""similar to"", ""lowerEntry""); (""lowerEntry"", ""returns"", ""Map.Entry"")"
By default the ConsoleHandler uses a SimpleFormatter to format the messages before writing them to System.err,"(""ConsoleHandler"", ""uses"", ""SimpleFormatter""); (""ConsoleHandler"", ""writes to"", ""System.err""); (""SimpleFormatter"", ""formats"", ""messages"")"
The hashCode() method of objects is used when you insert them into a HashTable HashMap or HashSet,"(""objects"", ""has method"", ""hashCode()""); (""hashCode()"", ""used in"", ""HashTable""); (""hashCode()"", ""used in"", ""HashMap""); (""hashCode()"", ""used in"", ""HashSet""); (""HashTable"", ""uses"", ""hashCode()""); (""HashMap"", ""uses"", ""hashCode()""); (""HashSet"", ""uses"", ""hashCode()"")"
So as you can see a combination of the hashCode() and equals() methods are used when storing and when looking up objects in a hashtable,"(""hashCode()"", ""used with"", ""equals()""); (""hashCode()"", ""used for"", ""storing objects""); (""equals()"", ""used for"", ""storing objects""); (""hashCode()"", ""used for"", ""looking up objects""); (""equals()"", ""used for"", ""looking up objects""); (""hashCode()"", ""used in"", ""hashtable""); (""equals()"", ""used in"", ""hashtable"")"
Here is a modified version of MySignal called MyWaitNotify that uses wait() and notify(),"(""MySignal"", ""called"", ""MyWaitNotify""); (""MyWaitNotify"", ""uses"", ""wait()""); (""MyWaitNotify"", ""uses"", ""notify()"")"
To set a new System stream use one of th emethods System.setIn() System.setOut() or System.setErr(),"(""System"", ""hasMethod"", ""System.setIn()""); (""System"", ""hasMethod"", ""System.setOut()""); (""System"", ""hasMethod"", ""System.setErr()"")"
"The add() and offer() methods differ in how the behave if the Queue is full, so no more elements can be added. The add() method throws an exception in that case, whereas the offer() method just returns false.","(""Queue"", ""hasMethod"", ""add()""); (""Queue"", ""hasMethod"", ""offer()""); (""add()"", ""throwsException"", ""Exception""); (""offer()"", ""returns"", ""false"")"
Both the Pattern and Matcher classes are covered in detail in their own texts,"(""Pattern"", ""is covered in"", ""detail""); (""Matcher"", ""is covered in"", ""detail""); (""Pattern"", ""has own"", ""text""); (""Matcher"", ""has own"", ""text"")"
The Java Set interface as a method called removeAll() which removes all elements in the Set which are also present in another Collection,"(""Java Set"", ""has method"", ""removeAll()""); (""removeAll()"", ""removes elements from"", ""Set""); (""Set"", ""contains elements from"", ""Collection"")"
The Map compute() method takes a key object and a lambda expression as parameters. The lambda expression must implement the java.util.function.BiFunction interface.,"(""Map"", ""hasMethod"", ""compute()""); (""compute()"", ""takesParameter"", ""key""); (""compute()"", ""takesParameter"", ""lambda expression""); (""lambda expression"", ""implements"", ""java.util.function.BiFunction"")"
java.text.CollationKey is faster than the stringwise comparison the RuleBasedCollator uses normally,"(""CollationKey"", ""is faster than"", ""RuleBasedCollator""); (""RuleBasedCollator"", ""uses"", ""stringwise comparison""); (""CollationKey"", ""compares strings"", ""stringwise comparison""); (""RuleBasedCollator"", ""uses"", ""CollationKey""); (""CollationKey"", ""is part of"", ""java.text""); (""RuleBasedCollator"", ""is part of"", ""java.text"")"
The ForkJoinPool located in the java.util.concurrent package so the full class name is java.util.concurrent.ForkJoinPool,"(""java.util.concurrent"", ""contains"", ""ForkJoinPool""); (""ForkJoinPool"", ""located in"", ""java.util.concurrent""); (""java.util.concurrent.ForkJoinPool"", ""is"", ""ForkJoinPool"")"
Notice how notifyAll() is only called from enqueue() and dequeue() if the queue size is equal to the size bounds (0 or limit),"(""notifyAll()"", ""called from"", ""enqueue()""); (""notifyAll()"", ""called from"", ""dequeue()""); (""enqueue()"", ""checks"", ""queue size""); (""dequeue()"", ""checks"", ""queue size""); (""queue size"", ""has bounds"", ""0""); (""queue size"", ""has bounds"", ""limit"")"
In other words you can add all elements from a List or Set into a List with addAll(),"(""List"", ""hasMethod"", ""addAll()""); (""List"", ""usesMethod"", ""addAll()""); (""Set"", ""usesMethod"", ""addAll()""); (""List"", ""containsElement"", ""Set"")"
Since only one thread is allowed to take the semaphore all other threads calling take() will be blocked until release() is called,"(""Semaphore"", ""hasMethod"", ""take()""); (""Semaphore"", ""hasMethod"", ""release()""); (""Thread"", ""callsMethod"", ""take()""); (""Thread"", ""callsMethod"", ""release()"")"
The format() and printf() methods allow you to mix text and data in very advanced ways using a formatting string,"(""format()"", ""allows"", ""mix text and data""); (""printf()"", ""allows"", ""mix text and data""); (""format()"", ""uses"", ""formatting string""); (""printf()"", ""uses"", ""formatting string"")"
The Collections replaceAll() method uses the equals() method of each element to determine if the element is equal to the element to replace or not,"(""Collections"", ""uses"", ""equals()""); (""replaceAll()"", ""uses"", ""equals()""); (""Collections"", ""has method"", ""replaceAll()""); (""equals()"", ""is used by"", ""replaceAll()"")"
The call to unread() pushes a character back into the PushbackReader. The next time read() is called the pushed back characters will be read first.,"(""PushbackReader"", ""calls"", ""unread()""); (""unread()"", ""pushes back"", ""character""); (""read()"", ""reads"", ""character""); (""PushbackReader"", ""calls"", ""read()"")"
java.sql.ResultSet ResultSet has 3 different columns (Name Age Gender) and 3 records with different values for each column,"(""ResultSet"", ""has"", ""columns""); ("" columns"", ""include"", ""Name""); ("" columns"", ""include"", ""Age""); ("" columns"", ""include"", ""Gender""); (""ResultSet"", ""has"", ""records""); (""records"", ""have"", ""values"")"
First the ResourceBundle class will look for a ListResourceBundle and then for a PropertyResourceBundle,"(""ResourceBundle"", ""will look for"", ""ListResourceBundle""); (""ResourceBundle"", ""will look for"", ""PropertyResourceBundle"")"
The returned long value can be used to initialize java.util.Date java.sql.Date java.sql.Timestamp and java.util.GregorianCalendar objects,"(""java.util.Date"", ""used to initialize"", ""long value""); (""java.sql.Date"", ""used to initialize"", ""long value""); (""java.sql.Timestamp"", ""used to initialize"", ""long value""); (""java.util.GregorianCalendar"", ""used to initialize"", ""long value"")"
In fact the implementation of the ExecutorService interface present in the java.util.concurrent package is a thread pool implementation,"(""ExecutorService"", ""is implemented in"", ""java.util.concurrent""); (""ExecutorService"", ""is a type of"", ""thread pool""); (""java.util.concurrent"", ""contains"", ""ExecutorService"")"
Notice how the Collections.sort() method now takes a java.util.Comparator as parameter in addition to the List,"(""Collections"", ""takes"", ""java.util.Comparator""); (""Collections"", ""takes"", ""List""); (""Collections"", ""has method"", ""sort()""); (""java.util.Comparator"", ""is parameter of"", ""Collections.sort()""); (""List"", ""is parameter of"", ""Collections.sort()"")"
For instance ordinary debug trace logging calls to entering() and exiting() would be called at the beginning and end of a method call,"(""entering()"", ""called at"", ""beginning of a method call""); (""exiting()"", ""called at"", ""end of a method call"")"
Each of the methods ceilingEntry() floorEntry() higherEntry() and lowerEntry() will be covered in the following sections,"(""ceilingEntry()"", ""isMethodOf"", ""unknown""); (""floorEntry()"", ""isMethodOf"", ""unknown""); (""higherEntry()"", ""isMethodOf"", ""unknown""); (""lowerEntry()"", ""isMethodOf"", ""unknown"")"
java.text.SimpleDateFormat is not exactly clear how the FieldPosition instance is used,"(""SimpleDateFormat"", ""uses"", ""FieldPosition""); (""SimpleDateFormat"", ""isPartOf"", ""java.text""); (""FieldPosition"", ""isPartOf"", ""java.text"")"
The LocalDate Java class is located in the java.time package so its fully qualified class name is java.time.LocalDate,"(""LocalDate"", ""is located in"", ""java.time""); (""LocalDate"", ""has fully qualified name"", ""java.time.LocalDate""); (""java.time"", ""contains"", ""LocalDate"")"
If there is no more data to read from the underlying Reader then the BufferedReader readLine() method will return null,"(""BufferedReader"", ""has method"", ""readLine()""); (""readLine()"", ""returns"", ""null""); (""BufferedReader"", ""uses"", ""Reader"")"
java.util.List is different from a Java Set where each element can occur only once,"(""java.util.List"", ""is different from"", ""Java Set""); (""Java Set"", ""has elements"", ""element""); (""Java Set"", ""restricts"", ""element occurrence"")"
Deque.addLast(E e) is different from the offerLast() method which will return false if the element cannot be added to the Deque,"(""Deque"", ""hasMethod"", ""addLast()""); (""Deque"", ""hasMethod"", ""offerLast()""); (""addLast()"", ""differFrom"", ""offerLast()""); (""offerLast()"", ""returns"", ""false""); (""Deque"", ""containsMethod"", ""offerLast()""); (""Deque"", ""containsMethod"", ""addLast()"")"
Do not confuse this class with the java.util.Arrays class in the Java Collections suite which contains utility methods for sorting arrays converting them to collections etc,"(""java.util.Arrays"", ""contains"", ""utility methods""); (""java.util.Arrays"", ""in"", ""Java Collections suite""); (""Java Collections suite"", ""contains"", ""utility methods"")"
You obtain a Collection of the values stored in a Map via the values() method,"(""Map"", ""has method"", ""values()""); (""Collection"", ""is returned by"", ""values()""); (""values()"", ""is method of"", ""Map"")"
Unfortunately if an exception is thrown during the write() call in the example above that exception will cause the program flow to break before the close() method is called,"(""write()"", ""is called before"", ""close()""); (""close()"", ""is called after"", ""write()""); (""exception"", ""is thrown during"", ""write()""); (""program flow"", ""is broken by"", ""exception""); (""write()"", ""throws"", ""exception""); (""close()"", ""is affected by"", ""exception"")"
Being a subclass of Hashtable you can actually use the get() and put() method of the Hashtable class which allow the use of nonstring keys and values,"(""Hashtable"", ""has method"", ""get()""); (""Hashtable"", ""has method"", ""put()""); (""Hashtable"", ""allows use of"", ""nonstring keys""); (""Hashtable"", ""allows use of"", ""nonstring values"")"
"A Java Properties instance clearly is as Hashtable, but it should not share the Hashtable interface. So - the ""Is a"" part of this rule should be interpreted as ""Should be usable as a"" instead. Using that formulation, Properties would not have been made a subclass of Hashtable, because Properties should not be usable as a Hashtable .","(""Properties"", ""is a"", ""Hashtable""); (""Properties"", ""should be usable as a"", ""Hashtable""); (""Properties"", ""should not be usable as a"", ""Hashtable""); (""Hashtable"", ""is a"", ""Properties"")"
"I mean, only the same, single thread is ever allowed to call inc(). Multiple threads can call count().",
"If the Deque is empty, poll() returns null. This is different than remove() which throws an exception if the Deque is empty.",
The peek() works like the element() method except it does not throw an exception if the Queue is empty. Instead it just returns null.,"(""peek()"", ""works like"", ""element()""); (""peek()"", ""does not throw"", ""exception""); (""Queue"", ""is"", ""empty""); (""peek()"", ""returns"", ""null""); (""Queue"", ""has method"", ""peek()""); (""Queue"", ""has method"", ""element()"")"
Notice the doStop() and keepRunning() methods. The doStop() is intended to be called from another thread than the thread executing the MyRunnable's run() method. The keepRunning() method is called internally by the thread executing the MyRunnable's run() method. As long as doStop() has not been called the keepRunning() method will return true - meaning the thread executing the run() method will keep running.,"(""MyRunnable"", ""hasMethod"", ""doStop()""); (""MyRunnable"", ""hasMethod"", ""keepRunning()""); (""MyRunnable"", ""hasMethod"", ""run()""); (""doStop()"", ""calledBy"", ""another thread""); (""keepRunning()"", ""calledBy"", ""MyRunnable's thread""); (""keepRunning()"", ""returns"", ""true""); (""run()"", ""calls"", ""keepRunning()""); (""doStop()"", ""affects"", ""keepRunning()"")"
System.err works like System.out except it is normally only used to output error texts,"(""System.err"", ""works like"", ""System.out""); (""System.err"", ""used to output"", ""error texts"")"
To do so set the upper bound to 1 and have the call to take() and release() guard the critical section,
java.io.InputStream method is useful if you need to read all bytes from a file via a FileInputStream into a byte array,"(""InputStream"", ""is useful in"", ""FileInputStream""); (""FileInputStream"", ""reads from"", ""file""); (""InputStream"", ""reads into"", ""byte array"")"
Notice how the getMonth() and getDayOfWeek() methods return an enum instead of an int,"(""getMonth()"", ""returns"", ""enum""); (""getDayOfWeek()"", ""returns"", ""enum"")"
java.io.InputStreamReader example first creates a FileInputStream and then wraps it in an InputStreamReader,"(""FileInputStream"", ""wraps"", ""InputStreamReader""); (""InputStreamReader"", ""creates"", ""FileInputStream""); (""FileInputStream"", ""used in"", ""java.io.InputStreamReader""); (""InputStreamReader"", ""part of"", ""java.io"")"
Deque.offerLast(E e) is different from the addLast() method which will throw an exception is adding an element to the end of the Deque fails,"(""Deque"", ""hasMethod"", ""offerLast()""); (""Deque"", ""hasMethod"", ""addLast()""); (""offerLast()"", ""differsFrom"", ""addLast()""); (""addLast()"", ""throwsException"", ""whenAddingFails""); (""Deque"", ""hasMethod"", ""addLast()""); (""Deque"", ""containsMethod"", ""offerLast()"")"
Java has 3 streams called System.in System.out and System.err which are commonly used to provide input to and output from Java applications,"(""Java"", ""has"", ""System.in""); (""Java"", ""has"", ""System.out""); (""Java"", ""has"", ""System.err""); (""System.in"", ""used for"", ""input""); (""System.out"", ""used for"", ""output""); (""System.err"", ""used for"", ""error output""); (""Java applications"", ""provide input to"", ""System.in""); (""Java applications"", ""provide output from"", ""System.out""); (""Java applications"", ""provide error output from"", ""System.err"")"
To access a private field you will need to call the Class.getDeclaredField(String name) or Class.getDeclaredFields() method,"(""Class"", ""hasMethod"", ""Class.getDeclaredField(String name)""); (""Class"", ""hasMethod"", ""Class.getDeclaredFields()"")"
"If the Deque is empty, pollFirst() returns null. This is different than removeFirst() which throws an exception if the Deque is empty.","(""Deque"", ""hasMethod"", ""pollFirst()""); (""Deque"", ""hasMethod"", ""removeFirst()""); (""pollFirst()"", ""returns"", ""null""); (""removeFirst()"", ""throwsException"", ""exception""); (""Deque"", ""uses"", ""exception"")"
Once you have opened a socket (network connection) though you read and write data to and from it via Java IO InputStream and OutputStream classes,"(""Java IO"", ""contains"", ""InputStream""); (""Java IO"", ""contains"", ""OutputStream""); (""InputStream"", ""used for"", ""reading data""); (""OutputStream"", ""used for"", ""writing data"")"
java.util.Set is different from a Java List where each element can occur more than once,"(""Java List"", ""is different from"", ""java.util.Set""); (""Java List"", ""allows"", ""element""); (""element"", ""can occur"", ""more than once"")"
Keep in mind that if some of the operations in the transaction fail you would most likely want to call the rollback() method instead of commit(),"(""transaction"", ""has method"", ""rollback()""); (""transaction"", ""has method"", ""commit()"")"
The min() and max() methods return an Optional instance which has a get() method on which you use to obtain the value,"(""Optional"", ""has method"", ""get()""); (""Optional"", ""returns instance of"", ""min()""); (""Optional"", ""returns instance of"", ""max()"")"
Only one thread can execute inside any of the two add() and subtract() methods at any given time,"(""add()"", ""executed by"", ""thread""); (""subtract()"", ""executed by"", ""thread"")"
A Java Callable is different from a Runnable in that the Runnable interface run() method does not return a value and it cannot throw checked exceptions (only RuntimeExceptions),"(""Java Callable"", ""is different from"", ""Runnable""); (""Runnable interface"", ""has method"", ""run()""); (""run() method"", ""does not return"", ""value""); (""run() method"", ""cannot throw"", ""checked exceptions""); (""run() method"", ""can throw"", ""RuntimeExceptions"")"
The ConcurrentHashMap is very similar to the java.util.HashTable class except that ConcurrentHashMap offers better concurrency than HashTable does,"(""ConcurrentHashMap"", ""similar to"", ""java.util.HashTable""); (""ConcurrentHashMap"", ""offers"", ""concurrency""); (""HashTable"", ""has"", ""concurrency"")"
You shut down a ScheduledExecutorService using the shutdown() or shutdownNow() methods which are inherited from the ExecutorService interface,"(""ScheduledExecutorService"", ""uses"", ""shutdown()""); (""ScheduledExecutorService"", ""uses"", ""shutdownNow()""); (""ScheduledExecutorService"", ""inherits from"", ""ExecutorService""); (""shutdown()"", ""inherited by"", ""ScheduledExecutorService""); (""shutdownNow()"", ""inherited by"", ""ScheduledExecutorService""); (""ScheduledExecutorService"", ""shutdown"", ""ExecutorService""); (""ScheduledExecutorService"", ""shutdownNow"", ""ExecutorService"")"
It is the last line of this example that calls the List stream() method to obtain the Stream representing the elements in the List.Once you have obtained a Stream from a List you can iterate the Stream by calling its forEach() method.,"(""List"", ""has method"", ""stream()""); (""List"", ""returns"", ""Stream""); (""Stream"", ""has method"", ""forEach()""); (""Stream"", ""iterated by"", ""forEach()""); (""List"", ""used to obtain"", ""Stream"")"
Using that formulation Properties would not have been made a subclass of Hashtable because Properties should not be usable as a Hashtable,"(""Properties"", ""subclass of"", ""Hashtable""); (""Properties"", ""should not be usable as"", ""Hashtable"")"
Many of the core components in the Java Collection API rely on the correct implementation of the `hashCode()` and `equals()` methods.,"(""Java Collection API"", ""relies on"", ""hashCode()""); (""Java Collection API"", ""relies on"", ""equals()""); (""hashCode()"", ""implemented by"", ""Java Collection API""); (""equals()"", ""implemented by"", ""Java Collection API"")"
System.in System.out and System.err are initialized by the Java runtime when a Java VM starts up so you dont have to instantiate any streams yourself (although you can exchange them at runtime),"(""System.in"", ""initialized by"", ""Java runtime""); (""System.out"", ""initialized by"", ""Java runtime""); (""System.err"", ""initialized by"", ""Java runtime""); (""Java VM"", ""starts up"", ""Java runtime""); (""Java runtime"", ""instantiates"", ""streams""); (""streams"", ""exchanged at"", ""runtime"")"
"In case the write() method throws an exception, the close() method will never get called.","(""write() method"", ""throws"", ""exception""); (""write() method"", ""prevents call to"", ""close() method""); (""close() method"", ""never gets called"", ""write() method"")"
You create a Path instance using a static method in the Paths class (java.nio.file.Paths) named Paths.get(),"(""Paths"", ""has method"", ""get()""); (""Paths"", ""is in package"", ""java.nio.file""); (""Paths.get()"", ""returns"", ""Path""); (""Path"", ""is instance of"", ""Paths.get()""); (""Paths"", ""is used to create"", ""Path"")"
"If no permits are available, the acquire() call will block until a permit is released by another thread. Similarly, a release() calls is blocked if no more permits can be released into this semaphore.","(""acquire()"", ""is blocked by"", ""release()""); (""release()"", ""is blocked by"", ""acquire()""); (""acquire()"", ""calls"", ""release()""); (""release()"", ""calls"", ""acquire()""); (""Permit"", ""is released by"", ""Thread""); (""Thread"", ""releases"", ""Permit""); (""acquire()"", ""waits for"", ""Permit""); (""Permit"", ""is acquired by"", ""acquire()""); (""release()"", ""releases"", ""Permit"")"
The submaps are the maps returned by various methods like headMap() subMap() and tailMap(),"(""headMap()"", ""returned by"", ""submaps""); (""subMap()"", ""returned by"", ""submaps""); (""tailMap()"", ""returned by"", ""submaps"")"
If your Java SortedMap was created using a Comparator you can obtain the Comparator used via the SortedMap comparator() method,"(""SortedMap"", ""has method"", ""comparator()""); (""SortedMap"", ""uses"", ""Comparator""); (""Comparator"", ""is obtained by"", ""comparator()"")"
You can change this pattern later using the applyPattern() or applyLocalizedPattern() method,"(""applyPattern()"", ""is method of"", ""unknown class""); (""applyLocalizedPattern()"", ""is method of"", ""unknown class"")"
The AtomicBoolean class is located in the java.util.concurrent.atomic package so the full class name is java.util.concurrent.atomic.AtomicBoolean,"(""AtomicBoolean"", ""is located in"", ""java.util.concurrent.atomic""); (""java.util.concurrent.atomic"", ""contains"", ""AtomicBoolean""); (""AtomicBoolean"", ""has full class name"", ""java.util.concurrent.atomic.AtomicBoolean"")"
java.io.InputStreamReader example creates a FileInputStream and wraps it in a InputStreamReader,"(""FileInputStream"", ""wraps in"", ""InputStreamReader""); (""InputStreamReader"", ""creates"", ""FileInputStream""); (""FileInputStream"", ""is wrapped by"", ""InputStreamReader""); (""InputStreamReader"", ""is created by"", ""java.io""); (""FileInputStream"", ""is part of"", ""java.io""); (""InputStreamReader"", ""is part of"", ""java.io"")"
When the process() method of the subclass is called the full process is executed including the stepBefore() and stepAfter() of the abstract superclass and the action() method of the subclass,"(""subclass"", ""has method"", ""process()""); (""process()"", ""calls"", ""stepBefore()""); (""process()"", ""calls"", ""stepAfter()""); (""process()"", ""calls"", ""action()""); (""abstract superclass"", ""has method"", ""stepBefore()""); (""abstract superclass"", ""has method"", ""stepAfter()""); (""subclass"", ""has method"", ""action()"")"
If you want to set a different offset for the dest byte array there is a version of update() and doFinal() which takes an offset parameter extra,"(""update()"", ""takes"", ""offset parameter""); (""doFinal()"", ""takes"", ""offset parameter""); (""update()"", ""has"", ""version""); (""doFinal()"", ""has"", ""version""); (""byte array"", ""has"", ""offset""); (""update()"", ""updates"", ""byte array""); (""doFinal()"", ""updates"", ""byte array"")"
java.security.cert.X509Certificate class represents an X.509 certificate which is used as identity certificate in HTTPS and TLS,"(""java.security.cert.X509Certificate"", ""represents"", ""X.509 certificate""); (""X.509 certificate"", ""used in"", ""HTTPS""); (""X.509 certificate"", ""used in"", ""TLS"")"
java.io.PrintWriter example first creates a PrintWriter instance which is connected to a FileWriter,"(""PrintWriter"", ""creates"", ""instance""); (""PrintWriter"", ""connected to"", ""FileWriter""); (""PrintWriter"", ""instance of"", ""java.io.PrintWriter""); (""FileWriter"", ""connected to"", ""PrintWriter"")"
The Java CharArrayReader is handy when you have data in a char array but need to pass that data to some component which can only read from a Reader (or a Reader subclass),"(""CharArrayReader"", ""is a"", ""Reader""); (""CharArrayReader"", ""is a"", ""Reader subclass""); (""Reader"", ""has subclass"", ""Reader subclass""); (""CharArrayReader"", ""reads from"", ""char array""); (""Component"", ""reads from"", ""Reader""); (""Component"", ""reads from"", ""Reader subclass"")"
The compareAndSet() method can compare the reference stored in the AtomicStampedReference instance with an expected reference and the stored stamp with an expected stamp and if they two references and stamps are the same (not equal as in equals() but same as in ==) then a new reference can be set on the AtomicStampedReference instance,"(""AtomicStampedReference"", ""has method"", ""compareAndSet()""); (""compareAndSet()"", ""compares"", ""reference""); (""compareAndSet()"", ""compares"", ""stamp""); (""AtomicStampedReference"", ""stores"", ""reference""); (""AtomicStampedReference"", ""stores"", ""stamp""); (""compareAndSet()"", ""sets"", ""reference"")"
The BoundedSemaphore class shown below has two testandset methods take() and release(),"(""BoundedSemaphore"", ""has method"", ""take()""); (""BoundedSemaphore"", ""has method"", ""release()""); (""BoundedSemaphore"", ""has methods"", ""testandset""); (""take()"", ""is part of"", ""BoundedSemaphore""); (""release()"", ""is part of"", ""BoundedSemaphore""); (""testandset"", ""includes"", ""take()""); (""testandset"", ""includes"", ""release()"")"
For a 100% precise description of how to implement equals() and hashCode() you should check out the official JavaDoc,"(""JavaDoc"", ""describes"", ""equals()""); (""JavaDoc"", ""describes"", ""hashCode()"")"
You could view the LocalDateTime as a combination of the LocalDate and LocalTime classes of the Java 8 date time API,"(""LocalDateTime"", ""combines"", ""LocalDate""); (""LocalDateTime"", ""combines"", ""LocalTime""); (""LocalDate"", ""partOf"", ""Java 8 date time API""); (""LocalTime"", ""partOf"", ""Java 8 date time API""); (""LocalDateTime"", ""partOf"", ""Java 8 date time API"")"
InputStream.read() example creates an AsynchronousFileChannel and then creates a ByteBuffer which is passed to the read() method as parameter along with a position of 0,"(""InputStream"", ""hasMethod"", ""read()""); (""AsynchronousFileChannel"", ""creates"", ""ByteBuffer""); (""read()"", ""takesParameter"", ""ByteBuffer""); (""read()"", ""takesParameter"", ""position""); (""InputStream"", ""uses"", ""AsynchronousFileChannel""); (""AsynchronousFileChannel"", ""uses"", ""ByteBuffer"")"
When the thread that locked the Lock in the first place tries to unlock it by calling unlock() it will be blocked trying to enter the synchronized(this) block in the unlock() method,"(""Lock"", ""has method"", ""unlock()""); (""unlock()"", ""is called by"", ""thread""); (""unlock()"", ""is blocked by"", ""synchronized(this)""); (""Lock"", ""is locked by"", ""thread""); (""thread"", ""tries to call"", ""unlock()""); (""unlock()"", ""contains"", ""synchronized(this)""); (""synchronized(this)"", ""blocks"", ""thread"")"
Of course you could do this with the start() and end() methods but it is easier to do so with the group functions,"(""start()"", ""is related to"", ""end()""); (""start()"", ""is alternative to"", ""group functions""); (""end()"", ""is related to"", ""start()""); (""end()"", ""is alternative to"", ""group functions""); (""group functions"", ""is easier than"", ""start()""); (""group functions"", ""is easier than"", ""end()"")"
java.lang.StringBuffer text explains how to use the SimpleDateFormat class to format dates,"(""StringBuffer"", ""uses"", ""SimpleDateFormat""); (""StringBuffer"", ""is_in_package"", ""java.lang""); (""SimpleDateFormat"", ""is_in_package"", ""java.text""); (""StringBuffer"", ""formats"", ""dates""); (""SimpleDateFormat"", ""formats"", ""dates"")"
The Java?ExecutorService?submit(Callable)?method is similar to the?submit(Runnable)?method except it takes a?Java Callable?instead of a?Runnable.?,"(""ExecutorService"", ""hasMethod"", ""submit(Callable)""); (""ExecutorService"", ""hasMethod"", ""submit(Runnable)""); (""submit(Callable)"", ""takes"", ""Callable""); (""submit(Runnable)"", ""takes"", ""Runnable""); (""Callable"", ""isSimilarTo"", ""Runnable"")"
Just to make it clear You should NOT use the put() and get() method of the Properties class!,"(""Properties"", ""has method"", ""put()""); (""Properties"", ""has method"", ""get()"")"
The Java compiler auto generates getter methods toString() hashcode() and equals() methods for these data fields so you dont have to write that boilerplate code yourself,"(""Java compiler"", ""generates"", ""getter methods""); (""Java compiler"", ""generates"", ""toString()""); (""Java compiler"", ""generates"", ""hashcode()""); (""Java compiler"", ""generates"", ""equals()"")"
java.nio.channels.Selector means that you cannot use FileChannel with a Selector since FileChannel cannot be switched into nonblocking mode,"(""FileChannel"", ""cannot be used with"", ""Selector""); (""FileChannel"", ""cannot be switched into"", ""nonblocking mode""); (""Selector"", ""requires"", ""nonblocking mode"")"
Just set a new InputStream for System.in or a new OutputStream for System.out or System.err and all further data will be read written to the new stream,"(""System.in"", ""set"", ""InputStream""); (""System.out"", ""set"", ""OutputStream""); (""System.err"", ""set"", ""OutputStream""); (""InputStream"", ""read"", ""data""); (""OutputStream"", ""written"", ""data"")"
Creating a pipe using Java IO is done via the PipedOutputStream and PipedInputStream classes,"(""PipedOutputStream"", ""uses"", ""Java IO""); (""PipedInputStream"", ""uses"", ""Java IO""); (""PipedOutputStream"", ""related to"", ""PipedInputStream"")"
The biggest difference between java.sql.Date and java.sql.Timestamp is that the java.sql.Date only keeps the date not the time of the date it represents,"(""java.sql.Date"", ""represents"", ""date""); (""java.sql.Timestamp"", ""represents"", ""date""); (""java.sql.Date"", ""keeps"", ""date""); (""java.sql.Timestamp"", ""keeps"", ""time""); (""java.sql.Date"", ""differs from"", ""java.sql.Timestamp"")"
Since the parameters of the Finder.find() and MyClass.doFind() methods match it is possible to create a lambda expression that implements Finder.find() and references the MyClass.doFind() method,"(""Finder"", ""hasMethod"", ""find()""); (""MyClass"", ""hasMethod"", ""doFind()""); (""Finder.find()"", ""implementedBy"", ""lambda expression""); (""MyClass.doFind()"", ""referencedBy"", ""lambda expression""); (""Finder.find()"", ""matches"", ""MyClass.doFind()"")"
Here is an example of obtaining the Comparator used by a SortedMap via its comparator() method,"(""SortedMap"", ""has method"", ""comparator()""); (""SortedMap"", ""uses"", ""Comparator""); (""comparator()"", ""returns"", ""Comparator"")"
"The getAndDecrement() method does the same as the decrementAndGet() method, except the getAndDecrement() method returns the value of the element before it is decremented.","(""getAndDecrement()"", ""is similar to"", ""decrementAndGet()""); (""getAndDecrement()"", ""returns"", ""element value""); (""decrementAndGet()"", ""returns"", ""element value"")"
The Matcher lookingAt() method works like the matches() method with one major difference,"(""Matcher"", ""hasMethod"", ""lookingAt()""); (""Matcher"", ""hasMethod"", ""matches()""); (""lookingAt()"", ""similarTo"", ""matches()"")"
In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not but the BufferedInputStream supports them,"(""InputStream"", ""hasMethod"", ""markSupported()""); (""InputStream"", ""hasMethod"", ""mark()""); (""InputStream"", ""hasMethod"", ""reset()""); (""BufferedInputStream"", ""supports"", ""mark()""); (""BufferedInputStream"", ""supports"", ""reset()"")"
Lock.lock() result is that any thread calling either lock() or unlock() will become blocked indefinately,"(""Lock"", ""hasMethod"", ""lock()""); (""Lock"", ""hasMethod"", ""unlock()""); (""lock()"", ""blocks"", ""thread""); (""unlock()"", ""blocks"", ""thread""); (""Lock"", ""affects"", ""thread"")"
The getAndDecrement() method does the same as the decrementAndGet() method except the getAndDecrement() method returns the value of the element before it is decremented,"(""getAndDecrement()"", ""is same as"", ""decrementAndGet()""); (""getAndDecrement()"", ""returns"", ""value""); (""decrementAndGet()"", ""decrements"", ""element""); (""getAndDecrement()"", ""decrements"", ""element"")"
The Collection interface has two methods to check if a Collection contains one or more certain elements. These are the contains() and containsAll() methods.,"(""Collection"", ""has method"", ""contains()""); (""Collection"", ""has method"", ""containsAll()"")"
"The newLine() method which can write a new-line character to the underlying Writer. In addition, you may need to call flush() if you need to be absolutely sure that the characters written until now is flushed out of the buffer and onto the network or disk.","(""Writer"", ""hasMethod"", ""newLine()""); (""Writer"", ""hasMethod"", ""flush()""); (""flush()"", ""affects"", ""buffer""); (""buffer"", ""isFlushedTo"", ""network""); (""buffer"", ""isFlushedTo"", ""disk"")"
To calculate a MAC value you call the Mac update() or doFinal() method,"(""Mac"", ""has method"", ""update()""); (""Mac"", ""has method"", ""doFinal()"")"
The java.util.concurrent package has the following implementations of the BlockingDeque interface,"(""java.util.concurrent"", ""has"", ""BlockingDeque""); (""BlockingDeque"", ""is implemented in"", ""java.util.concurrent"")"
Notice how the calculate() method both locks the Calculator instance Lock before performing any calculations and also call the add() and subtract() methods which also locks the lock,"(""Calculator"", ""has method"", ""calculate()""); (""calculate()"", ""calls"", ""add()""); (""calculate()"", ""calls"", ""subtract()""); (""Calculator"", ""uses"", ""Lock""); (""add()"", ""uses"", ""Lock""); (""subtract()"", ""uses"", ""Lock"")"
After calling read() the example loops until the isDone() method of the returned Future returns true,"(""Future"", ""has method"", ""isDone()""); (""Future"", ""returns"", ""boolean""); (""read()"", ""returns"", ""Future"")"
Deque.pollFirst() is different than removeFirst() which throws an exception if the Deque is empty,"(""Deque"", ""hasMethod"", ""pollFirst()""); (""Deque"", ""hasMethod"", ""removeFirst()""); (""removeFirst()"", ""throwsExceptionWhen"", ""Deque.isEmpty"")"
Adding and getting elements to a generic Map is done using the put() and get() methods,"(""Map"", ""uses"", ""put()""); (""Map"", ""uses"", ""get()"")"
Java IO contains many subclasses of the InputStream OutputStream Reader and Writer classes,"(""Java IO"", ""contains"", ""InputStream""); (""Java IO"", ""contains"", ""OutputStream""); (""Java IO"", ""contains"", ""Reader""); (""Java IO"", ""contains"", ""Writer""); (""InputStream"", ""is superclass of"", ""many subclasses""); (""OutputStream"", ""is superclass of"", ""many subclasses""); (""Reader"", ""is superclass of"", ""many subclasses""); (""Writer"", ""is superclass of"", ""many subclasses"")"
Even if you can get get() and put() to work I would recommend that you do not use these methods,"(""get()"", ""is_method_of"", ""unknown""); (""put()"", ""is_method_of"", ""unknown"")"
Lock.unlock() will remain blocked until the thread waiting in lock() leaves the synchronized(this) block,"(""Lock"", ""hasMethod"", ""unlock()""); (""Lock"", ""hasMethod"", ""lock()""); (""Thread"", ""waitsIn"", ""lock()""); (""synchronized(this)"", ""blocks"", ""Thread""); (""Lock"", ""isUsedBy"", ""synchronized(this)"")"
The Path interface is located in the java.nio.file package so the fully qualified name of the Java Path interface is java.nio.file.Path,"(""Path"", ""is located in"", ""java.nio.file""); (""java.nio.file.Path"", ""is the fully qualified name of"", ""Path""); (""Path"", ""is part of"", ""java.nio.file"")"
Here are two examples of adding elements to a Java Queue via its add() and offer() methods,"(""Java Queue"", ""has method"", ""add()""); (""Java Queue"", ""has method"", ""offer()"")"
The methods Class.getMethod(String name Class[] parameterTypes) and Class.getMethods() methods only return public methods so they wont work,"(""Class"", ""hasMethod"", ""getMethod""); (""Class"", ""hasMethod"", ""getMethods""); (""getMethod"", ""returns"", ""public methods""); (""getMethods"", ""returns"", ""public methods"")"
"BlockingQueue.offer(E e, long timeout, TimeUnit unit) is different from the add() method which will throw an exception is adding an element to the end of the Deque fails","(""BlockingQueue"", ""hasMethod"", ""offer()""); (""offer()"", ""differentFrom"", ""add()""); (""add()"", ""throwsException"", ""Exception""); (""BlockingQueue"", ""hasMethod"", ""add()""); (""Deque"", ""hasMethod"", ""add()"")"
The ByteArrayInputStream class is a subclass of the InputStream class so you can use a ByteArrayInputStream as an InputStream,"(""ByteArrayInputStream"", ""is a subclass of"", ""InputStream""); (""ByteArrayInputStream"", ""can be used as"", ""InputStream"")"
If you need to set a date on a java.sql.PreparedStatement or get a date from a java.sql.ResultSet you will interact with java.sql.Date,"(""java.sql.PreparedStatement"", ""interact with"", ""java.sql.Date""); (""java.sql.ResultSet"", ""interact with"", ""java.sql.Date""); (""java.sql.Date"", ""used by"", ""java.sql.PreparedStatement""); (""java.sql.Date"", ""used by"", ""java.sql.ResultSet"")"
The java.nio.file.Files class works with java.nio.file.Path instances so you need to understand the Path class before you can work with the Files class,"(""java.nio.file.Files"", ""works with"", ""java.nio.file.Path""); (""java.nio.file.Path"", ""is used by"", ""java.nio.file.Files""); (""java.nio.file.Files"", ""depends on"", ""java.nio.file.Path"")"
Both PipedInputStream and PipedOutputStream has a connect() method that can connect one to the other,"(""PipedInputStream"", ""has method"", ""connect()""); (""PipedOutputStream"", ""has method"", ""connect()""); (""connect()"", ""connects"", ""PipedInputStream""); (""connect()"", ""connects"", ""PipedOutputStream"")"
java.awt.List is the last line of this example that calls the List stream() method to obtain the Stream representing the elements in the List,"(""java.awt.List"", ""calls"", ""stream()""); (""java.awt.List"", ""has method"", ""stream()""); (""List"", ""returns"", ""Stream"")"
Queue.poll() is different than remove() which throws an exception if the Deque is empty,"(""Queue"", ""hasMethod"", ""poll()""); (""Queue"", ""hasMethod"", ""remove()""); (""Deque"", ""hasMethod"", ""remove()""); (""remove()"", ""throwsExceptionWhen"", ""Deque""); (""Queue"", ""differsFrom"", ""remove()""); (""remove()"", ""behavesDifferentlyThan"", ""poll()"")"
java.util.Collection represents an ordered sequence of objects just like a Java List but its intended use is slightly different,"(""java.util.Collection"", ""represents"", ""ordered sequence of objects""); (""java.util.Collection"", ""compared to"", ""Java List"")"
Another difference between call() and run() is that call() can throw an exception whereas run() cannot (except for unchecked exceptions subclasses of RuntimeException),"(""call()"", ""can throw"", ""exception""); (""run()"", ""cannot throw"", ""exception""); (""RuntimeException"", ""is subclass of"", ""Exception""); (""call()"", ""throws"", ""unchecked exceptions""); (""run()"", ""throws"", ""unchecked exceptions""); (""call()"", ""throws"", ""subclasses of RuntimeException""); (""run()"", ""throws"", ""subclasses of RuntimeException"")"
As you can see the key Iterator returns every key stored in a Java Map one by one (one for each call to next()),"(""Iterator"", ""returns"", ""key""); (""Java Map"", ""stores"", ""key""); (""Iterator"", ""calls"", ""next()""); (""Java Map"", ""has"", ""key""); (""Iterator"", ""iterates over"", ""Java Map"")"
The awaitTermination() method is typically called after calling shutdown() or shutdownNow(),"(""shutdown()"", ""called before"", ""awaitTermination()""); (""awaitTermination()"", ""called after"", ""shutdown()""); (""awaitTermination()"", ""called after"", ""shutdownNow()""); (""shutdownNow()"", ""called before"", ""awaitTermination()"")"
Collection.remove(Object o) is different from poll() which returns null if the Deque is empty,"(""Collection"", ""hasMethod"", ""remove(Object o)""); (""Collection"", ""hasMethod"", ""poll()""); (""Deque"", ""hasMethod"", ""poll()""); (""remove(Object o)"", ""differentFrom"", ""poll()""); (""Collection"", ""isTypeOf"", ""Deque"")"
The Java GZIPInputStream and GZIPOutputStream classes are used to ZIP compress a single file,"(""GZIPInputStream"", ""used_with"", ""GZIPOutputStream""); (""GZIPInputStream"", ""used_for"", ""ZIP compression""); (""GZIPOutputStream"", ""used_for"", ""ZIP compression"")"
The java.util.concurrent package contains the following implementations of the ConcurrentMap interface,"(""java.util.concurrent"", ""contains"", ""ConcurrentMap""); (""ConcurrentMap"", ""is implemented by"", ""java.util.concurrent"")"
Receiving data via a DatagramSocket is done by first creating a DatagramPacket and then receiving data into it via the DatagramSocket receive() method,"(""DatagramSocket"", ""has method"", ""receive()""); (""DatagramPacket"", ""used by"", ""DatagramSocket""); (""DatagramSocket"", ""receives data into"", ""DatagramPacket"")"
"Notice how the while loop continues until a -1 value is read from the ByteArrayInputStream read() method. After that, the while loop exits, and the ByteArrayInputStream close() method is called.","(""ByteArrayInputStream"", ""has method"", ""read()""); (""ByteArrayInputStream"", ""has method"", ""close()""); (""while loop"", ""uses"", ""ByteArrayInputStream.read()""); (""while loop"", ""uses"", ""ByteArrayInputStream.close()"")"
Notice how we can call the addAndReturn() method using both String and Integer and their corresponding collections,"(""String"", ""used with"", ""addAndReturn()""); (""Integer"", ""used with"", ""addAndReturn()""); (""String"", ""has collection"", ""corresponding collections""); (""Integer"", ""has collection"", ""corresponding collections""); (""addAndReturn()"", ""called with"", ""String""); (""addAndReturn()"", ""called with"", ""Integer"")"
"As you can see, the DecimalFormat is created with a formatting pattern. You can change this pattern later using the applyPattern() or applyLocalizedPattern() method.","(""DecimalFormat"", ""created with"", ""formatting pattern""); (""DecimalFormat"", ""has method"", ""applyPattern()""); (""DecimalFormat"", ""has method"", ""applyLocalizedPattern()"")"
For that you need to use the find() start() and end() methods,"(""find()"", ""is used with"", ""start()""); (""find()"", ""is used with"", ""end()""); (""find()"", ""is related to"", ""start()""); (""find()"", ""is related to"", ""end()""); (""start()"", ""is related to"", ""end()""); (""start()"", ""is used with"", ""find()""); (""end()"", ""is used with"", ""find()""); (""find()"", ""has relationship with"", ""start()""); (""find()"", ""has relationship with"", ""end()"")"
The Java Stack class actually implements the Java List interface but you rarely use a Stack as a List except perhaps if you need to inspect all elements currently stored on the stack,"(""Stack"", ""implements"", ""List""); (""Stack"", ""used as"", ""List""); (""Stack"", ""stores"", ""elements""); (""List"", ""used for"", ""inspecting elements""); (""Stack"", ""has"", ""elements"")"
In Java 6 to 13 there is only one implementation of the NavigableSet interface in the java.util package The java.util.TreeSet class,"(""NavigableSet"", ""implements"", ""java.util""); (""TreeSet"", ""implements"", ""NavigableSet""); (""TreeSet"", ""is_in"", ""java.util""); (""NavigableSet"", ""is_in"", ""java.util"")"
In many ways the java.nio.file.Path interface is similar to the java.io.File class but there are some minor differences,"(""java.nio.file.Path"", ""similar to"", ""java.io.File"")"
java.io.CharArrayReader is also possible to write data to an ByteArrayOutputStream or CharArrayWriter,"(""java.io.CharArrayReader"", ""is also possible to write data to"", ""ByteArrayOutputStream""); (""ByteArrayOutputStream"", ""is related to"", ""CharArrayWriter""); (""CharArrayReader"", ""is comparable to"", ""CharArrayWriter"")"
"The first method, addAndGet() adds a number to the AtomicInteger and returns its value after the addition. The second method, getAndAdd() also adds a number to the AtomicInteger but returns the value the AtomicInteger had before the value was added.",
Here is an example of obtaining the Comparator used by a SortedSet via the comparator() method,"(""SortedSet"", ""has method"", ""comparator()"")"
You will call take() instead of notify() and release() instead of wait(),"(""notify()"", ""replaced by"", ""take()""); (""wait()"", ""replaced by"", ""release()"")"
The problem with calling wait() and notify() on the empty string or any other constant string is that the JVMCompiler internally translates constant strings into the same object,"(""JVMCompiler"", ""translates"", ""constant strings""); (""JVMCompiler"", ""uses"", ""wait()""); (""JVMCompiler"", ""uses"", ""notify()""); (""constant strings"", ""are translated to"", ""object""); (""wait()"", ""is called on"", ""constant strings""); (""notify()"", ""is called on"", ""constant strings""); (""JVMCompiler"", ""optimizes"", ""constant strings""); (""constant strings"", ""are optimized by"", ""JVMCompiler"")"
"if the Deque is full, the offerFirst() method returns false. This is different from the addFirst() method which will throw an exception is adding an element to the beginning of the Deque fails.",
You read characters from a Java PushbackReader just like you do from a Java Reader because PushbackReader is a Java Reader subclass,"(""PushbackReader"", ""is a"", ""Reader""); (""PushbackReader"", ""subclass of"", ""Reader""); (""Reader"", ""has subclass"", ""PushbackReader"")"
Since the Map does not contain any object stored by the key E the given default value will be returned which is the String default value passed as the last parameter to the getOrDefault() method,"(""Map"", ""contains"", ""key""); (""Map"", ""has method"", ""getOrDefault()""); (""getOrDefault()"", ""returns"", ""default value""); (""getOrDefault()"", ""takes parameter"", ""String""); (""getOrDefault()"", ""takes parameter"", ""key"")"
When you call select() or selectNow() on the Selector it gives you only the SelectableChannel instances that actually has data to read,"(""Selector"", ""has method"", ""select()""); (""Selector"", ""has method"", ""selectNow()""); (""select()"", ""returns"", ""SelectableChannel""); (""selectNow()"", ""returns"", ""SelectableChannel""); (""SelectableChannel"", ""has data to read"", ""data"")"
"For the SortedSet to be able to determine the natural order of the elements, the elements must implement the java.lang.Comparable interface.","(""SortedSet"", ""uses"", ""java.lang.Comparable""); (""elements"", ""implement"", ""java.lang.Comparable""); (""SortedSet"", ""determines"", ""natural order""); (""elements"", ""have"", ""natural order""); (""java.lang.Comparable"", ""provides"", ""natural order"")"
For the SortedSet to be able to determine the natural order of the elements the elements must implement the java.lang.Comparable interface,"(""SortedSet"", ""implements"", ""java.lang.Comparable""); (""elements"", ""must implement"", ""java.lang.Comparable"")"
java.util.concurrent.RecursiveTask example is similar to the RecursiveAction example except it returns a result,
Notice the two synchronized blocks inside the set() and get() method. Notice how the blocks are placed last and first in the two methods.,"(""set()"", ""contains"", ""synchronized blocks""); (""get()"", ""contains"", ""synchronized blocks""); (""set()"", ""has"", ""synchronized blocks""); (""get()"", ""has"", ""synchronized blocks""); (""set()"", ""inside"", ""synchronized blocks""); (""get()"", ""inside"", ""synchronized blocks"")"
This Keytool delete command will remove the KeyStore entry with the alias testkey from the KeyStore stored in the file keystore.jks,"(""Keytool"", ""delete"", ""KeyStore""); (""KeyStore"", ""stored in"", ""keystore.jks""); (""Keytool"", ""remove"", ""KeyStore entry""); (""KeyStore entry"", ""has alias"", ""testkey""); (""KeyStore"", ""stored in"", ""file"")"
Deque.addFirst(E e) is different from the offerFirst() method which will return false if an element cannot be inserted in the beginning of the Deque,"(""Deque"", ""hasMethod"", ""addFirst()""); (""addFirst()"", ""differsFrom"", ""offerFirst()""); (""offerFirst()"", ""returns"", ""false""); (""Deque"", ""hasMethod"", ""offerFirst()"")"
To access a private method you will need to call the Class.getDeclaredMethod(String name Class[] parameterTypes) or Class.getDeclaredMethods() method,"(""Class"", ""hasMethod"", ""getDeclaredMethod""); (""Class"", ""hasMethod"", ""getDeclaredMethods""); (""getDeclaredMethod"", ""takesParameter"", ""String""); (""getDeclaredMethod"", ""takesParameter"", ""Class""); (""getDeclaredMethods"", ""returns"", ""Method"")"
There are several overridden versions of both update() and doFinal() which takes different parameters,"(""update()"", ""overridden by"", ""doFinal()""); (""update()"", ""has parameter"", ""parameters""); (""doFinal()"", ""has parameter"", ""parameters""); (""update()"", ""overridden by"", ""doFinal()""); (""update()"", ""is version of"", ""update()""); (""doFinal()"", ""is version of"", ""doFinal()"")"
If you look at the example in the previous section imagine what happens if an exception is thrown between the call to lock.lock() and lock.unlock(),"(""lock"", ""hasMethod"", ""lock.lock()""); (""lock"", ""hasMethod"", ""lock.unlock()"")"
"The replace() method will only insert the new value if there is already an existing value mapped to the key. If no existing value is mapped to the given key, no value is inserted. This is different from how put() works, which always insert the value no matter what.","(""replace()"", ""is different from"", ""put()""); (""replace()"", ""will only insert"", ""value""); (""put()"", ""always inserts"", ""value""); (""replace()"", ""requires"", ""existing value""); (""put()"", ""does not require"", ""existing value"")"
The logrb() methods work like the log() methods too except they can obtain the log messages from a resource bundle,"(""logrb()"", ""work like"", ""log()""); (""logrb()"", ""obtain from"", ""resource bundle""); (""log()"", ""work like"", ""logrb()"")"
a stop() or pause() method too) then you can no longer create your Runnable implementation with a Java lambda expression,"(""Runnable"", ""has method"", ""stop()""); (""Runnable"", ""has method"", ""pause()""); (""Runnable"", ""implemented by"", ""Java lambda expression"")"
java.security.KeyStore example loads the KeyStore file located in the keystore.ks file,"(""KeyStore"", ""loads"", ""keystore.ks""); (""KeyStore"", ""located in"", ""keystore.ks""); (""keystore.ks"", ""file of"", ""KeyStore"")"
The queueObject.doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout so another thread can actually call unlock() when no thread is executing inside the synchronized(this) block in lock() method,"(""queueObject"", ""hasMethod"", ""doWait()""); (""queueObject"", ""hasMethod"", ""unlock()""); (""lock()"", ""isMethodOf"", ""queueObject""); (""synchronized(this)"", ""contains"", ""lock()""); (""lock()"", ""contains"", ""synchronized(this)"")"
The read() and write() calls on the streams are blocking meaning if you try to use the same thread to both read and write this may result in the thread deadlocking itself,"(""streams"", ""hasMethod"", ""read()""); (""streams"", ""hasMethod"", ""write()"")"
"mutiple blocks from a large file, you call the update() once for each block of data, and finish with a call to doFinal() with the last data loce","(""update()"", ""called by"", ""multiple blocks""); (""update()"", ""followed by"", ""doFinal()""); (""doFinal()"", ""called with"", ""last data"")"
That means that when a thread invokes a read() or write() that thread is blocked until there is some data to read or the data is fully written,"(""thread"", ""invokes"", ""read()""); (""thread"", ""invokes"", ""write()""); (""read()"", ""is blocked by"", ""data""); (""write()"", ""is blocked by"", ""data""); (""thread"", ""is blocked by"", ""data"")"
You can convert a Java List to a Java Array using the List toArray() method,"(""List"", ""hasMethod"", ""toArray()""); (""List"", ""usesMethod"", ""toArray()""); (""Java"", ""hasType"", ""List""); (""Java"", ""hasType"", ""Array""); (""List"", ""convertsTo"", ""Array""); (""toArray()"", ""belongsTo"", ""List"")"
When the thread is done with the code in the critical section (the code between lock() and unlock()) the thread calls unlock(),"(""thread"", ""calls"", ""unlock()""); (""critical section"", ""is between"", ""lock()""); (""critical section"", ""is between"", ""unlock()""); (""thread"", ""is done with"", ""critical section""); (""thread"", ""calls"", ""lock()"")"
The LinkedList class is a pretty standard Deque and Queue implementation,"(""LinkedList"", ""is a"", ""Deque""); (""LinkedList"", ""is a"", ""Queue"")"
The System class also has a getProperty() and setProperty() method which are shortcuts to the Properties getProperty() and setProperty() methods of the System Properties instance,"(""System"", ""has method"", ""getProperty()""); (""System"", ""has method"", ""setProperty()""); (""Properties"", ""has method"", ""getProperty()""); (""Properties"", ""has method"", ""setProperty()""); (""System"", ""has instance"", ""System Properties""); (""Properties"", ""has method"", ""getProperty()""); (""Properties"", ""has method"", ""setProperty()""); (""System.getProperty"", ""is shortcut to"", ""Properties.getProperty""); (""System.setProperty"", ""is shortcut to"", ""Properties.setProperty"")"
The Handler in the Java Logging API use a java.util.logging.Formatter to format the LogRecord before writing it to an external system,"(""Handler"", ""use"", ""Formatter""); (""Formatter"", ""format"", ""LogRecord""); (""Handler"", ""write to"", ""external system""); (""Handler"", ""in"", ""Java Logging API""); (""Formatter"", ""in"", ""java.util.logging""); (""LogRecord"", ""in"", ""Java Logging API"")"
The compare() method returns an int with the same meaning as the String.compareTo() method,"(""compare()"", ""returns"", ""int""); (""compare()"", ""similar to"", ""String.compareTo()""); (""String.compareTo()"", ""returns"", ""int"")"
The method getBuffer() returns the StringBuffer used by the StringWriter to build the string from the written characters,"(""StringWriter"", ""uses"", ""StringBuffer""); (""StringWriter"", ""has method"", ""getBuffer()""); (""getBuffer()"", ""returns"", ""StringBuffer"")"
java.io.Writer is faster to write an array of characters to a Java BufferedWriter than writing one character at a time,"(""java.io.Writer"", ""is faster than"", ""Java BufferedWriter""); (""Java BufferedWriter"", ""writes"", ""array of characters""); (""Java BufferedWriter"", ""writes"", ""one character at a time"")"
java.util.Stack Java example pushes a Java String with the text 1 onto the Stack,"(""Stack"", ""pushes"", ""String""); (""Java"", ""uses"", ""Stack""); (""String"", ""is pushed onto"", ""Stack""); (""Stack"", ""is part of"", ""java.util""); (""Java"", ""utilizes"", ""java.util"")"
Deque.peekFirst() is similar to how peek() works but the method name peekFirst() is a bit more saying about which end of the Deque you peek at,"(""Deque"", ""hasMethod"", ""peekFirst()""); (""Deque"", ""hasMethod"", ""peek()"")"
To sort a collection of strings according to the rules of a certain Locale you use a java.text.Collator instance created for that specific Locale,"(""java.text.Collator"", ""created for"", ""Locale""); (""Locale"", ""has rules for"", ""string collection""); (""java.text.Collator"", ""sorts"", ""string collection""); (""Locale"", ""used by"", ""java.text.Collator"")"
