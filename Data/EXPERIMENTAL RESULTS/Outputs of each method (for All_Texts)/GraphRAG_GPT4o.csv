The Java Collection interface (java.util.Collection) is one of the root interfaces of the Java Collection API.,"(""Java Collection"", ""The Java Collection class is part of the java.util.Collection package, as indicated by the package name."", ""java.util.Collection"")"
Adding an element to a Collection is done via the add() method.,"(""Collection"", ""The add() method is used to add an element to a Collection."", ""add"")"
"The add() method adds the given element to the collection, and returns true if the Collection changed as a result of calling the add() method.","(""Add"", ""The Add method is used to add an element to the Collection class."", ""Collection"")"
"On the other hand, if you called add() on a List and the List already contained that element, the element would then exist twice in the List.","(""Add"", ""The method 'Add' is called on the class 'List' to add an element."", ""List"")"
"The remove() method removes the given element from the Collection and returns true if the removed element was present in the Collection, and was removed.","(""Remove"", ""The remove() method is used to remove an element from the Collection class."", ""Collection"")"
"If the element was not present, the remove() method returns false.","(""Remove"", ""The remove() method returns false if the element was not present."", ""False"")"
You can also add a collection of objects to a Java Collection using the addAll().,"(""Collection"", ""The addAll method is used to add a collection of objects to a Collection class."", ""addAll""); (""addAll"", ""The addAll method is part of the Java package."", ""Java"")"
The Java Collection addAll() adds all elements found in the Collection passed as parameter to the method.,"(""addAll"", ""The addAll method is part of the Java Collection class."", ""Java Collection""); (""addAll"", ""The addAll method takes a Collection as a parameter."", ""Collection"")"
"If you had called add() with the Collection as parameter instead, the Collection object itself would have been added, not its elements.","(""add"", ""The method 'add' is related to the class 'Collection' because it is mentioned as being called with a 'Collection' as a parameter."", ""Collection"")"
Exactly how the addAll() method behaves depends on the Collection subtype.,"(""addAll"", ""The addAll method is a function that operates on the Collection class, indicating a functional relationship between the method and the class."", ""Collection"")"
The Java Collection removeAll() removes all elements found the Collection passed as parameter to the method.,"(""removeAll"", ""The method removeAll() is a part of the Java Collection class."", ""Java Collection""); (""removeAll"", ""The method removeAll() operates on a Collection, as it removes elements found in the Collection passed as a parameter."", ""Collection"")"
"contains() returns true if the collection contains the element, and false if not.","(""CONTAINS"", ""The method 'contains' is used to check if the collection includes a specific element."", ""COLLECTION""); (""CONTAINS"", ""The method 'contains' checks for the presence of a specific element within the collection."", ""ELEMENT"")"
"containsAll() returns true if the collection contains all the elements in the parameter collection, and false if not.","(""containsAll"", ""The method containsAll is related to the collection because it checks if the collection contains all elements in the parameter collection."", ""collection""); (""containsAll"", ""The method containsAll is related to the parameter collection as it verifies if all elements in the parameter collection are present in the collection."", ""parameter collection"")"
You can check the size of a collection using the size() method.,"(""Size"", ""The size() method is used to check the size of a collection."", ""Collection"")"
The Java Stream API provides a more functional programming approach to iterating and processing elements of e.g.,"(""Java Stream API"", ""The Java Stream API is a package that provides a functional programming approach to iterating and processing elements."", ""Java Stream API"")"
You obtain a stream from a collection by calling the stream() method of the given collection.,"(""Collection"", ""The Stream() method is called on a Collection to obtain a Stream."", ""Stream()""); (""Stream()"", ""The Stream() method is used to create or obtain a Stream."", ""Stream"")"
Then a Stream of strings is obtained by calling the items.stream() method.,"(""items.stream()"", ""The method items.stream() is used to obtain a Stream of strings."", ""Stream"")"
"This is similar to how you obtain an Iterator by calling the items.iterator() method, but a Stream is a different animal than an Iterator.","(""items.iterator()"", ""The method items.iterator() is used to obtain an Iterator."", ""Iterator""); (""items.iterator()"", ""The method items.iterator() is mentioned in the context of obtaining a Stream, indicating a relationship."", ""Stream"")"
The Predicate interface contains a function called test() which the lambda expression passed as parameter above is matched against.,"(""Predicate"", ""The test method is a function contained within the Predicate interface."", ""test"")"
"If you look at the lambda expression above, you can see that it takes a single parameter item and returns a boolean - the result of the item.startsWith(""o"") method call.","(""item"", ""The method 'startsWith' is called on the parameter 'item' to check if it begins with the letter 'o'."", ""startsWith"")"
"When you call the filter() method on a Stream, the filter passed as parameter to the filter() method is stored internally.","(""Filter"", ""The filter() method is called on a Stream, indicating a relationship where the method operates on the class."", ""Stream""); (""Filter"", ""The filter passed as a parameter to the filter() method suggests a relationship where the method uses the filter."", ""Filter"")"
"The parameter passed to the filter() function determines what items in the stream should be processed, and which that should be excluded from the processing.","(""FILTER"", ""The FILTER method processes items in the STREAM."", ""STREAM"")"
"If the Predicate.test() method of the parameter passed to filter() returns true for an item, that means it should be processed.","(""Predicate"", ""The test method belongs to the Predicate class."", ""test""); (""filter"", ""The filter method uses the Predicate class to determine if an item should be processed."", ""Predicate"")"
The collect() method is one of the stream processing methods on the Stream interface.,"(""Collect"", ""The collect() method is a stream processing method on the Stream interface, indicating that it is a method associated with the Stream class."", ""Stream"")"
"The min() and max() methods return an Optional instance which has a get() method on, which you use to obtain the value.","(""Min"", ""The Min method returns an Optional instance."", ""Optional""); (""Max"", ""The Max method returns an Optional instance."", ""Optional""); (""Optional"", ""The Optional class has a Get method to obtain the value."", ""Get"")"
In case the stream has no elements the get() method will return null.,"(""GET"", ""The GET method returns NULL when the stream has no elements."", ""NULL"")"
The Comparator.comparing() method creates a Comparator based on the lambda expression passed to it.,"(""comparing"", ""The comparing method is a part of the Comparator class, as it is used to create a Comparator based on a lambda expression."", ""Comparator"")"
"In fact, the comparing() method takes a Function which is a functional interface suited for lambda expressions.","(""comparing"", ""The comparing() method takes a Function as a parameter, indicating a direct relationship where Function is used by comparing()."", ""Function""); (""Function"", ""Function is a functional interface suited for lambda expressions, indicating that lambda expressions can be used with Function."", ""lambda expressions"")"
The count() method simply returns the number of elements in the stream after filtering has been applied.,"(""Count"", ""The Count method returns the number of elements in the Stream after filtering."", ""Stream"")"
The count() method returns a long which is the count of elements in the stream after filtering etc.,"(""Count"", ""The count() method is used to count elements in the stream."", ""Stream"")"
The reduce() method can reduce the elements of a stream to a single value.,"(""Reduce"", ""The reduce() method operates on the elements of a stream to reduce them to a single value."", ""Stream"")"
"The reduce() method takes a BinaryOperator as parameter, which can easily be implemented using a lambda expression.","(""Reduce"", ""The reduce() method takes a BinaryOperator as a parameter."", ""BinaryOperator"")"
The BinaryOperator.apply() method is the method implemented by the lambda expression above.,"(""BinaryOperator"", ""The apply method is a method of the BinaryOperator class."", ""apply"")"
"Thus, the value created by the reduce() function is the accumulated value after processing the last element in the stream.","(""reduce"", ""The reduce method processes elements in the stream to accumulate a value."", ""stream"")"
The reduce() method taking a BinaryOperator as parameter returns an Optional .,"(""Reduce"", ""The Reduce method takes a BinaryOperator as a parameter."", ""BinaryOperator""); (""Reduce"", ""The Reduce method returns an Optional."", ""Optional"")"
"In case the stream contains no elements, the Optional.get() returns null.","(""Optional"", ""The method 'get' is a member of the class 'Optional', as it is invoked on an instance of 'Optional'."", ""get"")"
"This version of the reduce() method returns the accumulated value directly, and not an Optional.","(""Reduce"", ""The Reduce method returns the accumulated value directly."", ""Accumulated Value"")"
The reduce() method can be combined with the filter() method too.,"(""Reduce"", ""Both are methods that can be combined in functional programming."", ""Filter"")"
"The Java Collections class, java.util.Collections, contains a long list of utility methods for working with collections in Java.","(""Java Collections"", ""The Java Collections class is part of the java.util.Collections package."", ""java.util.Collections""); (""Java Collections"", ""The Java Collections class contains utility methods for working with collections."", ""utility methods"")"
The Java Collections addAll() method can add a variable number of elements to a Collection (typically either a List or a Set .,"(""Java Collections"", ""The addAll method is part of the Java Collections package."", ""addAll""); (""addAll"", ""The addAll method can add elements to a Collection."", ""Collection""); (""Collection"", ""A List is a type of Collection."", ""List""); (""Collection"", ""A Set is a type of Collection."", ""Set"")"
Here is a java code example of calling the Collections addAll() method:,"(""Collections"", ""The addAll method is a method of the Collections class."", ""addAll"")"
The Collections binarySearch() method can search a Java List for an element using a binary search algorithm.,"(""Collections"", ""The binarySearch method is a part of the Collections class."", ""binarySearch""); (""Java"", ""The List class is part of the Java package."", ""List"")"
The List must be sorted in ascending order before you search it using binarySearch() .,"(""List"", ""The binarySearch method is used to search within the List class."", ""binarySearch"")"
Here is an example of searching a List using the Collections binarySearch() method:,"(""Collections"", ""The binarySearch method is part of the Collections package."", ""binarySearch""); (""List"", ""The binarySearch method is used to search a List."", ""binarySearch"")"
The Collections copy() method can copy all elements of a List into another List.,"(""Collections"", ""The copy method is part of the Collections class."", ""copy""); (""copy"", ""The copy method operates on List objects to copy elements."", ""List"")"
Here is a Java example of calling the Collections copy() method:,"(""Collections"", ""The copy() method is a method of the Collections class."", ""copy()"")"
The Collections reverse() method can reverse the elements in a Java List.,"(""Collections"", ""The reverse method is a part of the Collections class."", ""reverse""); (""Java"", ""The List class is part of the Java package."", ""List"")"
The Collections shuffle() method can shuffle the elements of a List.,"(""Collections"", ""The shuffle method is a part of the Collections class."", ""shuffle""); (""shuffle"", ""The shuffle method operates on the elements of a List."", ""List"")"
Here is an example of shuffling a list with the Collections shuffle() method:,"(""Collections"", ""The shuffle method is part of the Collections package, which provides utility methods for collection operations."", ""shuffle"")"
Here is an example of sorting a Java List using Collections sort() method:,"(""Collections"", ""The sort method is a part of the Collections class."", ""sort""); (""List"", ""The sort method is used to sort a List."", ""sort"")"
The Java Collections copy() method can copy one List into another.,"(""copy"", ""The copy method is part of the Java Collections package."", ""Java Collections""); (""copy"", ""The copy method is used to copy one List into another."", ""List"")"
You provide the source and destination List instances as parameters to the copy() method.,"(""copy"", ""The copy() method uses List instances as parameters, indicating a relationship where the method operates on the class."", ""List"")"
The Collections min() method can find the minimum element in a List according to the natural ordering of the elements (see my Java List sorting tutorial).,"(""Collections"", ""The min method is part of the Collections package."", ""min""); (""min"", ""The min method operates on a List to find the minimum element."", ""List""); (""Collections"", ""The Collections package provides utilities for working with the List class."", ""List"")"
Here is an example of finding the minimum element in a Java List using Collections min() method:,"(""Collections"", ""The min method is a part of the Collections class, which provides utility methods for collection operations."", ""min""); (""List"", ""The min method is used to find the minimum element in a List, indicating a functional relationship between the List class and the min method."", ""min"")"
The Collections max() method can find the maximum element in a List according to the natural order of the elements (see my Java List sorting tutorial).,"(""Collections"", ""The max method is part of the Collections package."", ""max""); (""max"", ""The max method operates on a List to find the maximum element."", ""List"")"
The Java Collections replaceAll() method can replace all occurrences of one element with another element.,"(""Java Collections"", ""The replaceAll() method is part of the Java Collections package."", ""replaceAll"")"
You pass the element to replace and the element to replace it with as parameters to the replaceAll() method.,"(""replaceAll"", ""The replaceAll method uses the element as a parameter to perform its operation"", ""element"")"
"The Collections replaceAll() method returns true if any elements were replaced, and false if not.","(""Collections"", ""The replaceAll method is a part of the Collections class."", ""replaceAll"")"
The Collections replaceAll() method uses the equals() method of each element to determine if the element is equal to the element to replace or not.,"(""Collections"", ""The replaceAll method is a part of the Collections class."", ""replaceAll""); (""replaceAll"", ""The replaceAll method uses the equals method to determine if an element is equal to the element to replace."", ""equals"")"
I have a written a few more details about how the equals() method works in my section about the Java equals() method.,"(""EQUALS"", ""The equals() method is part of the Java package, as it is a method commonly used in Java programming."", ""JAVA"")"
The unmodifiableSet() method in the Java Collections class can create an immutable (unmodifiable) Set from a normal Java Set .,"(""UnmodifiableSet"", ""The unmodifiableSet() method is part of the Java Collections class."", ""Java Collections""); (""UnmodifiableSet"", ""The unmodifiableSet() method creates an immutable Set from a normal Java Set."", ""Set"")"
"The Java Comparable interface,java.lang.Comparable, represents an object which can be compared to other objects.","(""Java Comparable"", ""The Java Comparable class is part of the java.lang.Comparable package."", ""java.lang.Comparable"")"
Several of the built-in classes in Java implements the Java Comparable interface.,"(""Java"", ""Java implements the Comparable interface, indicating a relationship between these two classes."", ""Comparable"")"
"You can also implement the Java Comparable interface yourself, to make your own classes comparable.","(""Java Comparable"", ""The Java Comparable is an interface that can be implemented."", ""interface""); (""interface"", ""The interface can be implemented by classes to make them comparable."", ""classes"")"
"When a class implements the Java Comparable interface, this means that instances (objects) of that class can be compared to each other, as mentioned above.","(""Java Comparable"", ""The class implements the Java Comparable interface, allowing instances of the class to be compared to each other."", ""Java Comparable"")"
Please keep in mind that the Comparable interface is intended for comparison of objects of the same class.,"(""Comparable"", ""The Comparable interface is a type of class used for comparison purposes."", ""interface""); (""Comparable"", ""The Comparable interface is used for comparison of objects within the same class."", ""class"")"
In the following section I will explain how the compareTo() method works.,"(""CompareTo"", ""Method"")"
The Java Comparable compareTo() method takes a single object as parameter and returns an int value.,"(""Comparable"", ""The compareTo method is a member of the Comparable class."", ""compareTo"")"
"The int returned signal whether the object the compareTo() method is called on is larger than, equal to or smaller than the parameter object.","(""CompareTo"", ""The CompareTo method returns an int to signal the comparison result."", ""Int""); (""CompareTo"", ""The CompareTo method is called on an object to compare it with the parameter object."", ""Object""); (""CompareTo"", ""The CompareTo method compares the object it is called on with the parameter object."", ""Parameter Object"")"
"The Java Integer class implements the Comparable interface, so you can call compareTo() Here is an example:","(""Integer"", ""The compareTo method is associated with the Integer class as it is a method that can be called on Integer objects."", ""compareTo"")"
Since the value 45 is smaller than 99 - the first comparison ( valA.compareTo(valB) = 45.compareTo(99) ) results in the value -1 being returned.,"(""VALA"", ""VALA is using the COMPARETO method to compare its value with another entity."", ""COMPARETO""); (""VALB"", ""VALB is being compared using the COMPARETO method."", ""COMPARETO""); (""VALA"", ""VALA and VALB are being compared to each other using the COMPARETO method."", ""VALB"")"
"In the second comparison, when 99 is compared to 45 ( valB.compareTo(valA) = 99.compareTo(45) ) the result is 1 - because 99 is larger than 45.","(""compareTo"", ""The method compareTo is used to compare the value 99."", ""99""); (""compareTo"", ""The method compareTo is used to compare the value 45."", ""45"")"
Here is an example of a Spaceship class which can compare itself to other Spaceship instances:,"(""Spaceship"", ""The Spaceship class can compare itself to other instances of the same class, indicating a relationship between the class and its instances."", ""Spaceship"")"
This way you can implement compareTo() to compare base on multiple factors.,"(""compareTo"", ""method"")"
"By specifying a type parameter when implementing the Comparable interface, the compareTo() method parameter changes from Object to whatever type you have specified.","(""Comparable"", ""The compareTo method is part of the Comparable interface, as it is used to define the natural ordering of objects that implement this interface."", ""compareTo"")"
"Notice how there is no type parameter specified after the ""implements Comparable"" interface in the class declaration.","(""class"", ""The class implements the Comparable interface, indicating a relationship where the class uses the interface for comparison functionality."", ""Comparable"")"
"Notice also, how the parameter type of the compareTo() object is no longer Spaceship, but Object.","(""compareTo"", ""The compareTo method originally had a parameter of type Spaceship."", ""Spaceship""); (""compareTo"", ""The compareTo method now has a parameter of type Object."", ""Object"")"
"Finally, also notice how it is now necessary to cast the parameter of the compareTo() method to Spaceship explicitly.","(""compareTo"", ""The compareTo method is used to compare instances of the Spaceship class."", ""Spaceship"")"
"Notice too, that the compareTo() method should throw a NullPointerException if the parameter object is null.","(""CompareTo"", ""The CompareTo method should throw a NullPointerException if the parameter object is null, indicating a relationship where the method uses the class."", ""NullPointerException"")"
"Similarly, the compareTo() method should throw a ClassCastException if the input parameter is not of the same class as the class of the object compareTo() is called on.","(""compareTo"", ""The compareTo method should throw a ClassCastException if the input parameter is not of the same class."", ""ClassCastException""); (""compareTo"", ""The compareTo method is called on an object of a certain class."", ""class"")"
You can just cast to the desired class (as in the example above).,"(""Class"", ""class"")"
"If the classes do not match, the Java VM will throw a ClassCastException.","(""Java VM"", ""The Java VM throws a ClassCastException when classes do not match."", ""ClassCastException"")"
"The Java Comparator interface, java.util.Comparator, represents a component that can compare two objects so they can be sorted using sorting functionality in Java.","(""Java Comparator"", ""The Java Comparator class is part of the java.util.Comparator package, which provides sorting functionality."", ""java.util.Comparator"")"
When sorting e.g a Java List you can pass a Java Comparator to the sorting method.,"(""Java List"", ""The sorting method can be applied to a Java List to sort its elements."", ""sorting""); (""Java Comparator"", ""A Java Comparator is used by the sorting method to determine the order of elements."", ""sorting"")"
"This method, the compare() method, takes two objects which the Comparator implementation is intended to compare.","(""COMPARE"", ""The COMPARE method is used by the COMPARATOR class to compare two objects."", ""COMPARATOR"")"
The compare() method returns an int which signals which of the two objects was larger.,"(""COMPARE"", ""The compare() method returns an int, indicating a relationship where the method's output is of type int."", ""INT"")"
Imagine you have the following Spaceship class that you would like to be able to compare instances of:,"(""Spaceship"", ""The text suggests comparing instances of the Spaceship class, indicating a relationship between the class and its instances."", ""Spaceship"")"
"Notice that the Spaceship class already implements the Comparable interface which compares Spaceship objects on spaceshipClass first, and then registrationNo.","(""Spaceship"", ""The Spaceship class implements the Comparable interface, indicating a relationship where Spaceship uses Comparable for comparison purposes."", ""Comparable"")"
"First, notice how the SpaceshipComparator class implements the Comparator interface with the type Spaceship specified inside the < > characters ( implements Comparator<Spaceship> ).","(""SpaceshipComparator"", ""SpaceshipComparator class implements the Comparator interface."", ""Comparator""); (""Comparator"", ""Comparator interface is implemented with the type Spaceship."", ""Spaceship"")"
"Setting the generic type of the Comparator implementation to Spaceship means that the parameter types of the compare() method can be set to Spaceship, and not Object as it would have been - if no generic type had been specified ( implements Comparator ).","(""Comparator"", ""The compare method is part of the Comparator class, as it is a method that needs to be implemented when a class implements Comparator."", ""compare""); (""Spaceship"", ""The compare method uses Spaceship as its parameter type, indicating a relationship where Spaceship is the type being compared."", ""compare""); (""Spaceship"", ""The Comparator implementation is set to use Spaceship as its generic type, indicating a relationship where Spaceship is the type being compared by the Comparator."", ""Comparator"")"
"A Java Comparator implementation is pretty much always specialized to be able to compare objects of a specific type (class), so specifying a generic type in your Comparator implementation almost always makes sense.","(""Comparator"", ""The Comparator is a class that is specialized to compare objects of a specific type, which is also referred to as a class."", ""class"")"
"Second, notice how the compare() method returns the registrationNo of the first Spaceship parameter compared to the registrationNo of the second Spaceship parameter.","(""Compare"", ""The compare method operates on Spaceship objects by comparing their registration numbers."", ""Spaceship""); (""Spaceship"", ""The compare method compares the registration numbers of two Spaceship instances."", ""Spaceship"")"
"Imagine if the registrationNo variable of the Spaceship class was an int instead, so getRegistrationNo() would return an int.","(""Spaceship"", ""The method getRegistrationNo is associated with the Spaceship class as it is likely a method that retrieves the registration number of a Spaceship."", ""getRegistrationNo"")"
"The Java Deque interface, java.util.Deque, represents a double ended queue, meaning a queue where you can add and remove elements to and from both ends of the queue.","(""Java Deque"", ""The Java Deque class is part of the java.util.Deque package, which provides the interface for a double-ended queue."", ""java.util.Deque"")"
The LinkedList class is a pretty standard Deque and Queue implementation.,"(""LinkedList"", ""The LinkedList class is a standard implementation of the Deque class."", ""Deque""); (""LinkedList"", ""The LinkedList class is a standard implementation of the Queue class."", ""Queue"")"
The Java ArrayDeque class stores its elements internally in an array.,"(""ArrayDeque"", ""The ArrayDeque class is part of the Java package."", ""Java"")"
Before you can use a Java Deque you must create an instance of one of the classes that implements the Deque interface.,"(""Java Deque"", ""Java Deque is an instance of a class that implements the Deque interface."", ""Deque"")"
You add elements to the beginning end of a Deque using the add() method.,"(""Deque"", ""The add() method is used to add elements to a Deque."", ""add"")"
"If the element cannot be inserted into the Deque, the add() method will throw an exception.","(""Deque"", ""The add method is used to insert elements into the Deque class."", ""add"")"
"This is different from the offer() method, which will return false if it cannot insert the element.","(""OFFER"", ""The text specifies that 'offer()' is a method."", ""METHOD"")"
The addLast() method also adds an element to the end (tail) of a Java Deque.,"(""AddLast"", ""The AddLast method is a function that operates on the Deque class to add an element to its end."", ""Deque"")"
This is the Deque interface's equivalent of the add() method inherited from the Queue interface.,"(""Deque"", ""The add() method is associated with the Deque class as its equivalent method."", ""add""); (""add"", ""The add() method is inherited from the Queue class."", ""Queue""); (""Deque"", ""The Deque class is related to the Queue class through inheritance."", ""Queue"")"
Here is an example of adding an element to a Java Deque instance using the addLast() method:,"(""Deque"", ""The addLast method is used to add an element to a Deque instance."", ""addLast"")"
"If the element cannot be inserted into the Deque, the addLast() method will throw an exception.","(""addLast"", ""The addLast method is a function that operates on the Deque class to insert an element."", ""Deque"")"
This is different from the offerLast() method which will return false if the element cannot be added to the Deque.,"(""OfferLast"", ""The OfferLast method is used to add elements to the Deque class."", ""Deque"")"
To add an element at the beginning (head) instead of the end of a Java Deque you call the addFirst() method instead.,"(""addFirst"", ""The addFirst method is used to add an element at the beginning of a Java Deque."", ""Java Deque"")"
"If the element cannot be added to the beginning of the Deque, the addFirst() method will throw an exception.","(""Deque"", ""The addFirst method is a function that operates on the Deque class, allowing elements to be added to the beginning of the Deque."", ""addFirst"")"
This is different from the offerFirst() method which will return false if an element cannot be inserted in the beginning of the Deque.,"(""OfferFirst"", ""The OfferFirst method is used to insert an element at the beginning of the Deque class."", ""Deque"")"
The offer() method adds an element to the end (tail) of the Deque.,"(""Offer"", ""The offer() method is used to add an element to the Deque, indicating a functional relationship between the method and the class."", ""Deque"")"
This is different from the add() method which will throw an exception is adding an element to the end of the Deque fails.,"(""Add"", ""The Add method is used to add an element to the Deque class."", ""Deque"")"
Here is an example of how to add an element to the end of a Java Deque using the offer() method:,"(""Deque"", ""The offer method is used to add an element to the end of a Deque."", ""offer"")"
"The offerLast() method adds an element to the end (tail) of the Deque, just like offer().","(""OfferLast"", ""The OfferLast method is used to add an element to the Deque class."", ""Deque""); (""Offer"", ""The Offer method is used to add an element to the Deque class."", ""Deque""); (""OfferLast"", ""The OfferLast method functions similarly to the Offer method."", ""Offer"")"
The method name offerLast() is just a bit more saying about where the element is added to the Deque.,"(""offerLast"", ""The method offerLast() is related to the class Deque as it is a method that operates on or is part of the Deque class."", ""Deque"")"
This is different from the addLast() method which will throw an exception is adding an element to the end of the Deque fails.,"(""addLast"", ""The addLast method is used to add an element to the end of the Deque class."", ""Deque"")"
Here is an example of how to add an element to the end of a Java Deque using the offerLast() method:,"(""Deque"", ""The offerLast method is used to add an element to the end of a Deque."", ""offerLast"")"
The offerFirst() method adds an element to the beginning (head) of the Deque.,"(""OfferFirst"", ""The OfferFirst method is used to add an element to the Deque class."", ""Deque"")"
This is different from the addFirst() method which will throw an exception is adding an element to the beginning of the Deque fails.,"(""ADDFIRST"", ""The addFirst method is associated with the Deque class as it is used to add an element to the beginning of a Deque."", ""DEQUE"")"
Here is an example of how to add an element to the beginning of a Java Deque using the offerFirst() method:,"(""Deque"", ""The offerFirst method is used to add an element to the beginning of a Deque."", ""offerFirst"")"
The push() method adds an element to the beginning (head) of a Java Deque method.,"(""Push"", ""The Push method is used to add an element to the Deque class."", ""Deque"")"
"If adding the element fails, for instance if the Deque is full, the push() method will throw an exception.","(""Deque"", ""The push() method is a function that operates on the Deque class."", ""push()"")"
Here is an example of adding an element to the beginning of a Java Deque using the push() method:,"(""push()"", ""The push() method is used to add an element to the beginning of a Java Deque."", ""Deque"")"
The peek() method returns the first element from the beginning (head) of a Java Deque without removing it.,"(""Peek"", ""The peek() method is a function that operates on the Deque class to return the first element without removing it."", ""Deque"")"
Here is an example of peeking at the first element of a Java Deque using the peek() method:,"(""Deque"", ""The peek method is used to access the first element of the Deque class."", ""peek"")"
The peekFirst() method returns the first element from the beginning (head) of a Java Deque without removing it.,"(""PEEKFIRST"", ""The peekFirst() method is a function that operates on a Java Deque class to return the first element without removing it."", ""DEQUE"")"
"This is similar to how peek() works, but the method name peekFirst() is a bit more saying about which end of the Deque you peek at.","(""PEEKFIRST"", ""The method peekFirst() is related to the class Deque as it operates on it to peek at one end."", ""DEQUE""); (""PEEK"", ""The method peek() is similar to the method peekFirst(), indicating a functional relationship."", ""PEEKFIRST"")"
Here is an example of peeking at the first element of a Java Deque using the peekFirst() method:,"(""Deque"", ""The peekFirst method is used to access the first element of the Deque class."", ""peekFirst"")"
To peek at the last element of a Java Deque you can use the peekLast() method.,"(""Deque"", ""The peekLast method is used to access the last element of a Deque class in Java."", ""peekLast"")"
Here is an example of peeking at the last element of a Java Deque using the peekLast() method:,"(""Deque"", ""The peekLast method is used to access the last element of the Deque class."", ""peekLast"")"
The getFirst() method returns the first element from the beginning (head) of a Java Deque without removing it.,"(""GetFirst"", ""The GetFirst method operates on the Deque class to return the first element."", ""Deque""); (""GetFirst"", ""The GetFirst method is part of the Java package."", ""Java"")"
Here is an example of peeking at the first element of a Java Deque using the getFirst() method:,"(""Deque"", ""The getFirst method is used to access the first element of a Deque."", ""getFirst"")"
To peek at the last element of a Java Deque you can use the getLast() method.,"(""Deque"", ""The getLast method is used to peek at the last element of a Deque."", ""getLast"")"
Here is an example of peeking at the last element of a Java Deque using the getLast() method:,"(""Deque"", ""The getLast method is used to peek at the last element of a Deque class in Java."", ""getLast"")"
The remove() method removes the first element of a Java Deque.,"(""Remove"", ""The remove() method is a function that operates on the Deque class to remove its first element."", ""Deque"")"
The remove() method returns the element that is removed from the Deque.,"(""Remove"", ""The remove() method operates on the Deque class to remove an element."", ""Deque"")"
Here is an example of removing the first element a Java Deque using the remove() method:,"(""remove"", ""The remove method is used to remove the first element from the Deque class."", ""Deque"")"
This is different from poll() which returns null if the Deque is empty.,"(""Poll"", ""The method Poll is associated with the class Deque as it operates on it to check if it is empty."", ""Deque"")"
The removeFirst() method also removes the first element from a Deque - the element at the head of the Deque.,"(""RemoveFirst"", ""The RemoveFirst method is related to the Deque class because it operates on a Deque to remove the first element."", ""Deque"")"
Here is an example of removing the first element of a Java Deque using the removeFirst() method:,"(""Deque"", ""The removeFirst method is used to remove the first element of a Deque class in Java."", ""removeFirst"")"
This is different from pollFirst() which returns null if the Deque is empty.,"(""pollFirst"", ""The method pollFirst is associated with the class Deque as it operates on it."", ""Deque"")"
The removeLast() method removes the last element of a Deque - meaning the element at the tail of the Deque.,"(""RemoveLast"", ""The RemoveLast method is a function that operates on the Deque class to remove the last element."", ""Deque"")"
Here is an example of removing the last element of a Java Deque using the removeLast() method:,"(""Deque"", ""The removeLast method is used to remove the last element from a Deque."", ""removeLast"")"
After running this Java example the removedElement variable will point to the String object element 2 - since that element was the last element of the Deque when removeLast() was called.,"(""removeLast"", ""The method removeLast() is called on the Deque class."", ""Deque""); (""Java"", ""The Deque class is part of the Java package."", ""Deque"")"
This is different from pollLast() which returns null if the Deque is empty.,"(""PollLast"", ""PollLast is a method that operates on the Deque class"", ""Deque"")"
The poll() method removes an element from the beginning of the Deque.,"(""Poll"", ""The Poll method is used to remove an element from the Deque class."", ""Deque"")"
This is different than remove() which throws an exception if the Deque is empty.,"(""remove"", ""The method 'remove' is associated with the class 'Deque' as it operates on it."", ""Deque"")"
Here is an example of removing the first element from a Java Deque using the poll() method:,"(""poll()"", ""The poll() method is used to remove the first element from a Deque class in Java."", ""Deque"")"
"The pollFirst() method removes an element from the beginning of the Deque, just like poll().","(""PollFirst"", ""The PollFirst method operates on the Deque class by removing an element from its beginning."", ""Deque""); (""Poll"", ""The Poll method operates on the Deque class similarly to PollFirst, by removing an element."", ""Deque"")"
The method name pollFirst() is just a bit more saying about from where the method removes elements.,"(""PollFirst"", ""PollFirst is identified as a method because the text explicitly refers to it as a method."", ""method"")"
This is different than removeFirst() which throws an exception if the Deque is empty.,"(""removeFirst"", ""The method removeFirst is associated with the class Deque as it operates on it."", ""Deque"")"
Here is an example of removing the first element from a Java Deque using the pollFirst() method:,"(""Deque"", ""The pollFirst method is used to remove the first element from a Deque class in Java."", ""pollFirst"")"
The pollLast() method removes an element from the end (tail) of the Deque.,"(""PollLast"", ""The PollLast method is used to remove an element from the Deque class."", ""Deque"")"
This is different than removeLast() which throws an exception if the Deque is empty.,"(""removeLast"", ""The method removeLast is associated with the class Deque as it operates on it."", ""Deque"")"
Here is an example of removing the last element from a Java Deque using the pollLast() method:,"(""Deque"", ""The pollLast method is used to remove the last element from a Deque."", ""pollLast"")"
The pop() method removes an element from the beginning (head) of a Java Deque.,"(""Pop"", ""The Pop method is used to remove an element from the Deque class."", ""Deque"")"
"If removing the element fails, for instance if the Deque is empty, the pop() method will throw an exception.","(""Deque"", ""The pop() method is used on the Deque class to remove an element."", ""pop"")"
Here is an example of removing the first element from a Java Deque using the pop() method:,"(""Deque"", ""The pop method is used to remove the first element from a Deque."", ""pop"")"
You can use the Java Deque contains() method to check if a Deque contains a given element.,"(""Deque"", ""The contains() method is used to check if a Deque contains a given element."", ""contains()""); (""Java"", ""Deque is a class that is part of the Java package."", ""Deque"")"
"The contains() method will return true if the Deque contains the element, and false if not.","(""Contains"", ""The contains() method is used to check if the Deque contains a specific element."", ""Deque"")"
Here is an example of checking if a Java Deque contains a specific element using the contains() method:,"(""Deque"", ""The contains method is used to check if a Deque contains a specific element."", ""contains"")"
The Java Deque size() method returns the number of elements stored in the Java Deque at the time you invoke the method.,"(""size()"", ""The size() method is a function that operates on the Java Deque class to return the number of elements stored in it."", ""Java Deque"")"
Here is an example of obtaining the number of elements in a Java Deque using its size() method:,"(""Deque"", ""The size() method is used to obtain the number of elements in a Deque."", ""size()"")"
After running this code the size variable will contain the value 2 because the Deque contains 2 element at the time size() is called.,NULL
"When you have specified a generic type for a Java collection, that generic type also works for the Iterator returned by the iterator() method.","(""iterator()"", ""The iterator() method returns an Iterator object."", ""Iterator""); (""Java"", ""The iterator() method is part of the Java class."", ""iterator()"")"
Notice how it is not necessary to cast the String returned from the iterator.next() method call.,"(""iterator.next()"", ""The method 'iterator.next()' returns a 'String', indicating a relationship where the method's output is of the 'String' class."", ""String"")"
"Because the Iterator has its generic type set to String, the Java compiler already knows that next() will return a String.","(""Iterator"", ""The method next() is associated with the Iterator class as it is a common method used to retrieve elements from an iterator."", ""next()""); (""String"", ""The method next() is expected to return a String, indicating a relationship between the method and the String class."", ""next()""); (""Java"", ""The Iterator class is part of the Java package, which provides the context for its usage."", ""Iterator"")"
The methods hashCode() and equals() play a distinct role in the objects you insert into Java collections.,"(""HashCode"", ""Both methods are used to define equality and hash code behavior for objects in Java collections."", ""Equals""); (""HashCode"", ""HashCode is a method used in Java programming."", ""Java""); (""Equals"", ""Equals is a method used in Java programming."", ""Java"")"
equals() is used in most collections to determine if a collection contains a given element.,"(""equals()"", ""The method 'equals()' is used in collections to determine if a collection contains a given element."", ""collections"")"
"The ArrayList iterates all its elements and execute ""123"".equals(element) to determine if the element is equal to the parameter object ""123"".","(""ArrayList"", ""The method 'equals' is used within the context of the 'ArrayList' class to compare elements."", ""equals"")"
It is the String.equals() implementation that determines if two strings are equal.,"(""String"", ""The equals method is a part of the String class, used to determine if two strings are equal."", ""equals"")"
"The ArrayList again iterates all its elements and execute ""123"".equals(element) to determine if the element is equal to the parameter object ""123"".","(""ArrayList"", ""The ArrayList class uses the equals method to compare its elements with the parameter object."", ""equals"")"
"As you can see, a proper implementation of .equals() is essential for your own classes to work well with the Java Collection classes.","(""EQUALS"", ""The method EQUALS is essential for the proper functioning of the CLASS."", ""CLASS""); (""CLASS"", ""The CLASS is intended to work well with the JAVA COLLECTION package."", ""JAVA COLLECTION"")"
"That depends on your application, the classes, and what you are trying to do.","(""Application"", ""The application may use or interact with the classes to perform certain tasks."", ""Classes"")"
"The hashCode() method of objects is used when you insert them into a HashTable, HashMap or HashSet.","(""hashCode()"", ""The hashCode() method is used when objects are inserted into a HashTable."", ""HashTable""); (""hashCode()"", ""The hashCode() method is used when objects are inserted into a HashMap."", ""HashMap""); (""hashCode()"", ""The hashCode() method is used when objects are inserted into a HashSet."", ""HashSet"")"
"If you do not know the theory of how a hashtable works internally, you can read about hastables on Wikipedia.org.",NULL
The hashtable then iterates this area (all keys with the same hash code) and uses the key's equals() method to find the right key.,"(""Hashtable"", ""The Hashtable class uses the Equals method to find the right key."", ""Equals"")"
"So, as you can see, a combination of the hashCode() and equals() methods are used when storing and when looking up objects in a hashtable.","(""hashCode"", ""Both methods are used together for storing and looking up objects in a hashtable."", ""equals""); (""hashCode"", ""The hashCode method is used in the process of storing and looking up objects in a hashtable."", ""hashtable""); (""equals"", ""The equals method is used in the process of storing and looking up objects in a hashtable."", ""hashtable"")"
"Here are two rules that are good to know about implementing the hashCode() method in your own classes, if the hashtables in the Java Collections API are to work correctly:","(""hashCode"", ""The hashCode method is related to the Java Collections API because it is used to ensure that hashtables within the API work correctly."", ""Java Collections API"")"
Here are two example implementation of the hashCode() method matching the equals() methods shown earlier:,"(""hashCode"", ""The hashCode method is related to the equals method as they are often implemented together to ensure consistent behavior in collections."", ""equals"")"
For a 100% precise description of how to implement equals() and hashCode() you should check out the official JavaDoc's.,"(""equals()"", ""Both are methods that are often implemented together to ensure proper functioning of objects in collections."", ""hashCode()""); (""equals()"", ""The JavaDoc provides official documentation on how to implement the equals() method."", ""JavaDoc""); (""hashCode()"", ""The JavaDoc provides official documentation on how to implement the hashCode() method."", ""JavaDoc"")"
The purpose of this text was mostly to explain how they are used by the Java Collection classes.,"(""Java Collection"", ""The text explains how Java Collection is used by classes."", ""class"")"
"This means, that a class that implements the Java Iterable interface can have its elements iterated.","(""Java Iterable"", ""The class Java Iterable is mentioned as implementing an interface, which implies it is a class."", ""Java Iterable"")"
"You can iterate the objects of a Java Iterable in three ways: Via the , by obtaining a Java Iterator from the Iterable, or by calling the Java Iterable forEach() method.","(""Java Iterable"", ""A Java Iterator can be obtained from a Java Iterable."", ""Java Iterator""); (""Java Iterable"", ""The forEach() method can be called on a Java Iterable."", ""forEach"")"
"Then it uses a for-each loop to iterate the elements of the List, and print out the toString() value of each element.","(""List"", ""The toString method is called on each element of the List to get its string representation."", ""toString"")"
The second way you can iterate the elements of a Java Iterable is by obtaining a Java Iterator from it by calling the Iterable iterator() method.,"(""Java Iterable"", ""A Java Iterator can be obtained from a Java Iterable."", ""Java Iterator""); (""Java Iterable"", ""The iterator() method is called on a Java Iterable to obtain a Java Iterator."", ""iterator()"")"
The third way to iterate the elements of a Java Iterable is via its forEach() method.,"(""Iterable"", ""The forEach method is used to iterate over the elements of the Iterable class."", ""forEach"")"
Here is an example of iterating the elements of an Iterable via its forEach() method:,"(""Iterable"", ""The forEach method is used to iterate over the elements of the Iterable class."", ""forEach"")"
The Java Iterable interface (java.lang.Iterable) is one of the root interfaces of the Java Collections API.,"(""Iterable"", ""The Iterable class is part of the java.lang.Iterable package, as indicated by the package name."", ""java.lang.Iterable""); (""Iterable"", ""The Iterable class is a root interface of the Java Collections API, indicating a relationship between the class and the package."", ""Collections"")"
"Therefore, there are several classes in Java that implements the Java Iterable interface.","(""Java"", ""Java implements the Iterable interface, indicating a relationship between the two classes."", ""Iterable"")"
You can obtain a Java Spliterator from a Java Iterable via its spliterator() method.,"(""Iterable"", ""The spliterator() method is a function of the Iterable class."", ""spliterator""); (""Spliterator"", ""A Spliterator can be obtained from an Iterable using the spliterator() method."", ""Iterable"")"
"If you are writing some code that needs to iterate a collection lots of times in a tight loop, let's say iterate a Java List thousands of times per second, iterating the List via the Java for-each loop is slower than iterating the list via a standard for-loop as seen here: () .","(""Java"", ""The List class is part of the Java package."", ""List""); (""for-each loop"", ""The for-each loop is a method used to iterate over a List."", ""List""); (""for-loop"", ""The for-loop is another method used to iterate over a List."", ""List"")"
"The reason the for-each loop is slower is, that each iteration will call the List iterator() method, which will create a new Iterator object.","(""iterator()"", ""The iterator() method is called on the List class."", ""List""); (""iterator()"", ""The iterator() method creates a new Iterator object."", ""Iterator"")"
The standard Java collection interface Collection contains a method called iterator().,"(""Collection"", ""The method iterator() is part of the Collection class."", ""iterator()"")"
By calling iterator() you can obtain an iterator from the given Collection.,"(""Iterator()"", ""The method iterator() is used to obtain an instance of the Iterator class."", ""Iterator""); (""Iterator()"", ""The method iterator() is called on a Collection to obtain an Iterator."", ""Collection"")"
"You can also obtain an Iterator from many of the Java Collection data structures, e.g.","(""Iterator"", ""The Iterator class is often used to traverse elements in Java Collection data structures."", ""Java Collection"")"
The first method is the Iterator hasNext() method which returns true if the Iterator contains more elements.,"(""Iterator"", ""The hasNext method is a function of the Iterator class."", ""hasNext"")"
"In other words, if the Iterator has not yet iterated over all of the elements in the collection the Iterator was obtained from - the hasNext() method will return true.","(""Iterator"", ""The hasNext method is a function that belongs to the Iterator class, used to check if there are more elements to iterate over."", ""hasNext"")"
If the Iterator has iterated over all elements in the underlying collection - the hasNext() method returns false.,"(""Iterator"", ""The hasNext method is used to check if the Iterator has more elements to iterate over."", ""hasNext"")"
The second method to pay attention to is the next() method.,"(""Next"", ""The text specifies that 'next()' is a method."", ""Method"")"
The next() method returns the next element of the collection the Iterator is iterating over.,"(""Next"", ""The next() method is used to retrieve the next element from the collection that the Iterator class is iterating over."", ""Iterator"")"
In that case you will get a ConcurrentModificationException the next time you call the Iterator next() method.,"(""Iterator"", ""The next() method is called on the Iterator class."", ""next()"")"
The Java Iterator interface has a remove() method which lets you remove the element just returned by next() from the underlying collection.,"(""Java Iterator"", ""The remove() method is part of the Java Iterator class."", ""remove()""); (""Java Iterator"", ""The next() method is part of the Java Iterator class."", ""next()""); (""remove()"", ""The remove() method operates on the element returned by the next() method."", ""next()"")"
"The Java Iterator forEachRemaining() method can iterate over all of the elements remaining in the Iterator internally, and for each element call a Java Lambda Expression passed as parameter to forEachRemaining() .","(""Iterator"", ""The forEachRemaining method is a part of the Iterator class, used to iterate over elements."", ""forEachRemaining""); (""forEachRemaining"", ""The forEachRemaining method can call a Lambda Expression for each element."", ""Lambda Expression""); (""Java"", ""The Iterator class is part of the Java package."", ""Iterator"")"
Here is an example of using the Java Iterator forEachRemaining() method:,"(""Java Iterator"", ""The forEachRemaining() method is a method of the Java Iterator class."", ""forEachRemaining"")"
"The Java List interface, java.util.List, represents an ordered sequence of objects.","(""Java List"", ""The Java List class is part of the java.util.List package, indicating a hierarchical relationship where the class is contained within the package."", ""java.util.List"")"
"If the List is not typed, using Java Generics, then you can even mix objects of different types (classes) in the same List.","(""List"", ""The List class can use Java Generics to enforce type safety."", ""Java Generics"")"
These List implementations are explained in more detail in my java.util.concurrent tutorial .,"(""List"", ""The List class is likely part of the java.util.concurrent package, as it is mentioned in the context of a tutorial about this package."", ""java.util.concurrent"")"
You create a List instance by creating an instance of one of the classes that implements the List interface.,"(""List"", ""The List class is related to the List interface because the class implements the interface."", ""List"")"
"Remember, most often you will use the ArrayList class, but there can be cases where using one of the other implementations might make sense.","(""ArrayList"", ""ArrayList is explicitly mentioned as a class in the text."", ""class"")"
"Thus, you need to cast them to the concrete class (or interface) that you know the object to be of.","(""Class"", ""class"")"
You insert elements (objects) into a Java List using its add() method.,"(""Java List"", ""The add() method is used to insert elements into a Java List."", ""add"")"
Here is an example of adding elements to a Java List using the add() method:,"(""add"", ""The add method is used to add elements to the List class."", ""List"")"
The first three add() calls add a String instance to the end of the list.,"(""Add"", ""The method 'Add' is used to add a 'String' instance to the list."", ""String"")"
"The List interface has a version of the add() method that takes an index as first parameter, and the element to insert as the second parameter.","(""List"", ""The add method is a function that belongs to the List class, allowing elements to be added to a list."", ""add"")"
"The addAll() method takes a Collection as parameter, so you can pass either a List or Java Set as parameter.","(""addAll"", ""The addAll method takes a Collection as a parameter."", ""Collection""); (""addAll"", ""The addAll method can take a List as a parameter."", ""List""); (""addAll"", ""The addAll method can take a Java Set as a parameter."", ""Java Set"")"
"In other words, you can add all elements from a List or Set into a List with addAll() .","(""addAll"", ""The method addAll is used to add elements into a List."", ""List""); (""addAll"", ""The method addAll can add elements from a Set."", ""Set""); (""addAll"", ""The method addAll can add elements from a List."", ""List"")"
The indexOf() method finds the index of the first occurrence in the List of the given element.,"(""indexOf"", ""The indexOf method is used to find the index of an element within the List class."", ""List"")"
The lastIndexOf() method finds the index of the last occurrence in the List of a given element.,"(""lastIndexOf"", ""The lastIndexOf method is used to find the index of the last occurrence of an element in the List class."", ""List"")"
You can check if a Java List contains a given element using the List contains() method.,"(""List"", ""The 'contains' method is used to check if a 'List' contains a given element."", ""contains"")"
Here is an example of checking if a Java List contains an element using the contains() method:,"(""List"", ""The contains method is used to check if a List contains a specific element."", ""contains"")"
"Obviously, if the input parameter to contains() is null, the contains() method will not use the equals() method to compare against each element, but rather use the == operator.","(""CONTAINS"", ""The CONTAINS method is related to the EQUALS method because it mentions using EQUALS for comparison unless the input is null."", ""EQUALS""); (""CONTAINS"", ""The CONTAINS method uses the == operator for comparison when the input parameter is null."", ""=="")"
The Java List interface contains a clear() method which removes all elements from the list when called.,"(""List"", ""The clear() method is a function that operates on the List class to remove all elements from the list."", ""clear"")"
Here is simple example of removing all elements from a List (clearing) with the clear() method:,"(""clear"", ""The clear() method is used to remove all elements from a List, indicating a functional relationship between the method and the class."", ""List"")"
"After the clear() method has been called, the List will be completely empty.","(""CLEAR"", ""The CLEAR method is called on the LIST class to empty it."", ""LIST"")"
The Java List interface has a method called retainAll() which is capable of retaining all elements from one List which are also present in another List.,"(""Java List"", ""The retainAll method is a function of the Java List class."", ""retainAll"")"
"In other words, the retain() method removes all the elements from the target List which are not found in the other List.","(""Retain"", ""The Retain method operates on the List class by removing elements not found in another List."", ""List"")"
Here is a Java example of calling the List retainAll() method:,"(""List"", ""The retainAll() method is called on the List class in the Java example."", ""retainAll"")"
"Third, the retainAll() method is called on list, passing otherList as parameter.","(""RetainAll"", ""The RetainAll method is called on the List class."", ""List""); (""RetainAll"", ""The RetainAll method uses OtherList as a parameter."", ""OtherList"")"
"After list.retainAll(otherList) has finished executing, the list will only contain those elements which were both present in list and otherList before retainAll() was called.","(""List"", ""The method RetainAll is called on the class List to modify its contents."", ""RetainAll""); (""List"", ""The class List is compared with the class OtherList to retain common elements."", ""OtherList""); (""RetainAll"", ""The method RetainAll uses OtherList to determine which elements to retain in List."", ""OtherList"")"
You can obtain the number of elements in the List by calling the size() method.,"(""List"", ""The size() method is used to obtain the number of elements in the List class."", ""size"")"
The Java List interface has a method called subList() which can create a new List with a subset of the elements from the original List.,"(""List"", ""The subList method is a function of the List class, allowing it to create a new List with a subset of elements."", ""subList"")"
The subList() method takes 2 parameters: A start index and and end index.,"(""SUBLIST"", ""The subList() method takes a start index as a parameter."", ""START INDEX""); (""SUBLIST"", ""The subList() method takes an end index as a parameter."", ""END INDEX"")"
Here is a Java example of creating a sublist of elements from another List using the subList() method:,"(""List"", ""The subList method is used to create a sublist from a List class."", ""subList"")"
"After executing the list.subList(1,3) instruction the sublist will contain the elements at index 1 and 2.","(""List"", ""The Sublist method is called on the List class to create a sublist of elements."", ""Sublist"")"
"The list.subList(1,3) call will include index 1, but exclude index 3, thereby keeping the elements at index 1 and 2.","(""LIST"", ""The method SUBLIST is called on the class LIST to create a sublist from the original list."", ""SUBLIST"")"
You can convert a Java List to a Java Array using the List toArray() method.,"(""List"", ""The toArray() method is used to convert a List to an Array."", ""toArray""); (""toArray"", ""The toArray() method converts a List into an Array."", ""Array"")"
"Note that even if we pass a String array of size 0 to the toArray(), the array returned will have all the elements in the List in it.",NULL
It is the Arrays.asList() method that converts the array to a List.,"(""Arrays"", ""The asList method is a member of the Arrays class."", ""asList"")"
You can sort a Java List using the Collections sort() method.,"(""Collections"", ""The sort() method is part of the Collections package."", ""sort()""); (""Java List"", ""The sort() method is used to sort a Java List."", ""sort()"")"
"If the List contains objects that implement the Comparable interface (java.lang.Comparable), then the objects can compare themselves to each other.","(""List"", ""The List class contains objects that implement the Comparable interface, allowing the objects to compare themselves to each other."", ""Comparable""); (""Comparable"", ""The Comparable interface is part of the java.lang.Comparable package."", ""java.lang.Comparable"")"
"The Java String class implements the Comparable interface, you can sort them in their natural order, using the Collections sort() method.","(""Java String"", ""The Java String class implements the Comparable interface, indicating a relationship between them."", ""Comparable""); (""Collections"", ""The sort() method is part of the Collections package, indicating a relationship between them."", ""sort()"")"
"If the objects in the Java List do not implement the Comparable interface, or if you want to sort the objects in another order than their compare() implementation, then you need to use a Comparator implementation (java.util.Comparator).","(""Java List"", ""Java List objects can implement the Comparable interface to define a natural ordering."", ""Comparable""); (""Comparator"", ""Comparator is a class that can be implemented using the java.util.Comparator package."", ""java.util.Comparator""); (""compare()"", ""The compare() method is part of the Comparable interface."", ""Comparable"")"
You obtain an Iterator by calling the iterator() method of the List interface.,"(""iterator()"", ""The iterator() method is called on the List interface to obtain an Iterator."", ""List""); (""Iterator"", ""The iterator() method returns an Iterator."", ""iterator()"")"
Once you have obtained an Iterator you can keep calling its hasNext() method until it returns false.,"(""Iterator"", ""The hasNext method is called on an instance of the Iterator class to check if there are more elements to iterate over."", ""hasNext"")"
Calling hasNext() is done inside a while loop as you can see.,"(""hasNext"", ""The method hasNext() is typically used within a while loop to check for more elements in a collection."", ""while loop"")"
Inside the while loop you call the Iterator next() method of the Iterator interface to obtain the next element pointed to by the Iterator.,"(""Iterator"", ""The next method is called on the Iterator class to obtain the next element."", ""next""); (""Iterator"", ""The Iterator interface is implemented by the Iterator class."", ""Iterator"")"
"Inside the for loop the example accesses the elements in the List via its get() method, passing the incrementing variable i as parameter.","(""List"", ""The get method is used to access elements in the List class."", ""get"")"
"Again, if the List is typed using Java Generics to e.g.","(""List"", ""The List class is typed using Java Generics, indicating a relationship where Java Generics is used to define the type of elements in the List."", ""Java Generics"")"
"Hence, the compiler knows that only a String can be returned from the get() method.","(""get"", ""The get method returns a String, indicating a relationship between the method and the class."", ""String"")"
Therefore you do not need to cast the element returned by get() to String.,"(""get"", ""The method 'get' returns an element that is expected to be of type 'String', indicating a relationship between the method and the class."", ""String"")"
Obtaining a Stream from a List in Java is done by calling the List stream() method.,"(""List"", ""The stream() method is called on a List to obtain a Stream."", ""stream()""); (""Java"", ""List is a class in the Java package."", ""List""); (""Java"", ""Stream is a class in the Java package."", ""Stream"")"
It is the last line of this example that calls the List stream() method to obtain the Stream representing the elements in the List.,"(""List"", ""The stream() method is called on the List class to obtain a Stream."", ""stream()""); (""stream()"", ""The stream() method is used to obtain a Stream representing the elements."", ""Stream"")"
Once you have obtained a Stream from a List you can iterate the Stream by calling its forEach() method.,"(""Stream"", ""The forEach method is called on the Stream class to iterate over its elements."", ""forEach""); (""List"", ""A Stream is obtained from a List, indicating a relationship where the List is the source of the Stream."", ""Stream"")"
Here is an example of iterating the elements of a List using the Stream forEach() method:,"(""Stream"", ""The forEach method is a part of the Stream class, used to iterate over elements."", ""forEach""); (""List"", ""The Stream class is used to iterate over elements of a List."", ""Stream"")"
"Calling the forEach() method will make the Stream iterate all the element of the Stream internally, and call the Consumer passed as parameter to the forEach() method for each element in the Stream.","(""forEach"", ""The forEach method is used to iterate over elements of the Stream class."", ""Stream""); (""forEach"", ""The forEach method calls the Consumer class for each element in the Stream."", ""Consumer"")"
"The Java Map interface, java.util.Map, represents a mapping between a key and a value.","(""Java Map"", ""The Java Map class is part of the java.util.Map package, indicating a package-class relationship."", ""java.util.Map"")"
To create a Java Map you must create an instance of one the classes that implement the Java Map interface.,"(""Java Map"", ""Java Map is an instance of a class that implements the Java Map interface"", ""Java Map interface"")"
To add elements to a Map you call its put() method.,"(""Map"", ""The put method is used to add elements to the Map class."", ""put"")"
The three put() calls maps a string value to a string key.,"(""PUT"", ""The method PUT is used to map a string value to a key."", ""STRING VALUE""); (""PUT"", ""The method PUT is used to map a string key to a value."", ""STRING KEY"")"
Here is an example of auto-boxing primitive parameters passed to the put() method:,"(""Put"", ""The text explicitly mentions the 'put()' method, indicating that 'Put' is a method."", ""Method"")"
The value passed to the put() method in the above example is a primitive int.,"(""put"", ""The put method takes an int as a parameter, indicating a relationship where the method uses the class."", ""int"")"
"Java auto-boxes it inside an Integer instance though, because the put() method requires an Oject instance as both key and value.","(""put"", ""The put method requires an Oject instance as both key and value, indicating a dependency or usage relationship."", ""Oject""); (""Integer"", ""The Integer class is mentioned in the context of the put method, suggesting it is used or involved in the method's operation."", ""put"")"
Auto-boxing would also happen if you passed a primitive as key to the put() method.,"(""Auto-boxing"", ""Auto-boxing is related to the put method as it involves the conversion of primitives to objects when passed as a key to the method."", ""put"")"
"If you call put() more than once with the same key, the latest value passed to put() for that key will overwrite what is already stored in the Map for that key.","(""Put"", ""The method Put is used to store values in the Map class."", ""Map"")"
To obtain the value stored by the null key you call the get() method with null as parameter value.,"(""GET"", ""The text describes calling the get() method to obtain a value."", ""METHOD"")"
Just keep in mind that you will get a null out when you call get() later with that key - so this will return null:,"(""get"", ""The method 'get' returns 'null' when called with a key that has no associated value."", ""null"")"
The Java Map interface has a method called putAll() which can copy all key + value pairs (entries) from another Map instance into itself.,"(""Java Map"", ""The putAll method is a function of the Java Map class."", ""putAll"")"
Here is an example of copying all entries from one Java Map into another via putAll():,"(""putAll"", ""The method putAll is used to copy all entries from one Java Map to another."", ""Java Map"")"
"Calling mapB.putAll(mapA) will only copy entries from mapA into mapB, not from mapB into mapA.","(""putAll"", ""The method putAll is called on the class mapB to copy entries."", ""mapB""); (""putAll"", ""The method putAll uses mapA as a source to copy entries into mapB."", ""mapA"")"
"To copy entries the other way, you would have to execute the code mapA.putAll(mapB).","(""putAll"", ""The method putAll is used to copy entries into the class mapA."", ""mapA""); (""putAll"", ""The method putAll takes entries from the class mapB."", ""mapB"")"
"To get a specific element stored in a Java Map you call its get() method, passing along the key for that element as parameter.","(""Map"", ""The get method is used to retrieve elements from the Map class."", ""get"")"
"Notice that the get() method returns a Java Object, so we have to cast it to a String (because we know the value is a String).","(""GET"", ""The get() method returns a Java Object, indicating a functional relationship where the method's output is of the class type Java Object."", ""JAVA OBJECT""); (""JAVA OBJECT"", ""The Java Object is cast to a String, indicating a type conversion relationship where the object is expected to be of the class type String."", ""STRING"")"
"If we had specified a generic type for the key and value of the Map, then it would not have been necessary to cast the object returned by get() method.","(""Map"", ""The get method is used to retrieve values from the Map class."", ""get"")"
The Java Map interface has a getOrDefault() method which can return a default value supplied by you - in case no value is stored in the Map by the given key.,"(""Java Map"", ""The getOrDefault method is a function provided by the Java Map class."", ""getOrDefault"")"
"This example creates a Map and stores three values in it using the keys A, B and C. Then the example calls the Map getOrDefault() method, passing the String E as key, along with a default value - the String default value.","(""Map"", ""The getOrDefault method is called on the Map class."", ""getOrDefault""); (""getOrDefault"", ""The getOrDefault method uses a String as a key and a default value."", ""String"")"
Since the Map does not contain any object stored by the key E the given default value will be returned - which is the String default value passed as the last parameter to the getOrDefault() method.,"(""getOrDefault"", ""The getOrDefault method is used to retrieve values from the Map class."", ""Map""); (""String"", ""The String class is related to the getOrDefault method as it is the type of the default value parameter."", ""getOrDefault"")"
You can check if a Java Map contains a specific key using the containsKey() method.,"(""Java Map"", ""The containsKey() method is used to check if a Java Map contains a specific key."", ""containsKey"")"
You can iterate all the keys of a Java Map via its keySet() method.,"(""Java Map"", ""The keySet method is a function that belongs to the Java Map class, allowing iteration over its keys."", ""keySet"")"
"As you can see, the key Iterator returns every key stored in a Java Map, one by one (one for each call to next()).","(""Iterator"", ""The Iterator class uses the next() method to return each key stored in a Java Map."", ""next""); (""Iterator"", ""The Iterator class is used to iterate over the keys stored in a Java Map."", ""Map"")"
"Once you have the key, you can obtain the element stored for that key using the Map get() method.","(""Map"", ""The get() method is used to obtain elements stored in the Map class."", ""get"")"
"In the example above, the Iterator next() method returns an Object - and so does the get() method.","(""Iterator"", ""The next method is associated with the Iterator class as it is a method that operates on or is defined within the Iterator class."", ""next""); (""get"", ""The get method returns an Object, indicating a relationship where the method's output is of the Object class type."", ""Object""); (""next"", ""The next method returns an Object, indicating a relationship where the method's output is of the Object class type."", ""Object"")"
Notice how a generic type is now also specified for the Iterator obtained from map.keySet().iterator().,"(""map"", ""The method keySet is called on the map class to obtain a set of keys."", ""keySet""); (""keySet"", ""The method iterator is called on the result of keySet to obtain an Iterator."", ""iterator""); (""Iterator"", ""The iterator method returns an instance of the Iterator class."", ""iterator"")"
You obtain a Collection of the values stored in a Map via the values() method.,"(""values"", ""The values() method is used to obtain the values stored in a Map."", ""Map""); (""Collection"", ""The values() method returns a Collection of the values."", ""values"")"
Notice how the key and value can be obtained from each Map.Entry instance.,"(""Map.Entry"", ""The key can be obtained from each Map.Entry instance, indicating a relationship between the class and the key."", ""key""); (""Map.Entry"", ""The value can be obtained from each Map.Entry instance, indicating a relationship between the class and the value."", ""value"")"
You can remove all entries in a Java Map using the clear() method.,"(""Java Map"", ""The clear() method is used to remove all entries in a Java Map."", ""clear"")"
It is possible to replace an element in a Java Map using the replace() method.,"(""replace()"", ""The replace() method is used to replace an element in a Java Map."", ""Java Map"")"
The replace() method will only insert the new value if there is already an existing value mapped to the key.,"(""Replace"", ""The text describes 'replace()' as a method, indicating its function in the context."", ""Method"")"
"This is different from how put() works, which always insert the value no matter what.","(""put"", ""The method 'put' is described in the context of how it functions or operates."", ""works"")"
Here is an example of replacing one value with another using the Java Map replace() method:,"(""Map"", ""The replace method is used to replace values in the Map class."", ""replace""); (""replace"", ""The replace method is part of the Java package."", ""Java"")"
You can read the number of entries in a Java Map using the size() method.,"(""Map"", ""The size() method is used to read the number of entries in a Map, indicating a functional relationship between the class and the method."", ""size"")"
The number of entries in a Java Map is also referred to as the Map size - hence the method name size() .,"(""Map"", ""The method size() is used to determine the number of entries in a Map, hence they are related."", ""size"")"
Here is an example of reading the number of entries in a Map using the size() method:,"(""Map"", ""The size() method is used to read the number of entries in a Map, indicating a functional relationship between the class and the method."", ""size"")"
This method is called isEmpty() and it returns either true or false.,"(""isEmpty"", ""The method isEmpty() returns a boolean value, which can be true."", ""true""); (""isEmpty"", ""The method isEmpty() returns a boolean value, which can be false."", ""false"")"
The isEmpty() method will return false if the Map instance contains 1 or more entries.,"(""ISEMPTY"", ""The isEmpty() method is related to the Map class because it operates on instances of the Map class to determine if they contain entries."", ""MAP"")"
The Map compute() method takes a key object and a lambda expression as parameters.,"(""Map"", ""The compute method is a part of the Map class."", ""compute"")"
Here is an example of calling the Java Map compute() method:,"(""Map"", ""The compute() method is a function that belongs to the Map class in Java."", ""compute"")"
"The compute() method will call the lambda expression internally, passing the key object and whatever value is stored in the Map for that key object, as parameters to the lambda expression.","(""Compute"", ""The compute() method interacts with the Map class by using the key object and its associated value stored in the Map."", ""Map"")"
"In the example above you can see that the lambda expression checks if the value mapped to the given key is null or not, before calling toString().toUpperCase() on it.","(""lambda expression"", ""The lambda expression calls the toString method."", ""toString""); (""toString"", ""The toString method is followed by the toUpperCase method."", ""toUpperCase"")"
"The Map computeIfAbsent() method works similarly to the compute() method, but the lambda expression is only called if no entry exists already for the given key.","(""computeIfAbsent"", ""Both are methods that perform computations on map entries."", ""compute""); (""Map"", ""computeIfAbsent is a method of the Map class."", ""computeIfAbsent""); (""Map"", ""compute is a method of the Map class."", ""compute"")"
"However, the lambda expression could have calculated the value in any way it needed to - e.g.",NULL
"The Map merge() method takes a key, a value, and a lambda expression implementing the BiFunction interface as parameters.","(""Map"", ""The merge method is a function of the Map class."", ""merge""); (""merge"", ""The merge method uses a lambda expression implementing the BiFunction interface."", ""BiFunction"")"
"If the Map does not have an entry for the key, or if the value for the key is null, the value passed as parameter to the merge() method is inserted for the given key.","(""Map"", ""The merge method is used to insert a value for a key in the Map class if certain conditions are met."", ""merge"")"
"The Java NavigableMap interface, java.util.NavigableMap, is a sub-interface of the Java SortedMap interface.","(""NavigableMap"", ""NavigableMap is a sub-interface of the SortedMap interface"", ""SortedMap""); (""NavigableMap"", ""java.util.NavigableMap is the package containing the NavigableMap class"", ""java.util.NavigableMap"")"
The java.util package only has one implementation of the NavigableMap interface: The java.util.TreeMap class.,"(""Java.Util"", ""The Java.Util package contains the Java.Util.TreeMap class."", ""Java.Util.TreeMap""); (""Java.Util.TreeMap"", ""The Java.Util.TreeMap class is an implementation of the NavigableMap interface."", ""NavigableMap"")"
"There is a Java NavigableMap implementation in the java.util.concurrent package too, but that is outside the scope of this tutorial.","(""NavigableMap"", ""NavigableMap is a class that is implemented within the java.util.concurrent package"", ""java.util.concurrent"")"
To create a Java NavigableMap you must create an instance of one of the classes that implements the NavigableMap interface.,"(""NavigableMap"", ""The text mentions creating an instance of a class that implements the NavigableMap interface, indicating a relationship between the class and the interface."", ""NavigableMap"")"
Here is an example of creating an instance of the Java TreeMap class which implements the NavigableMap interface:,"(""TreeMap"", ""TreeMap implements the NavigableMap interface"", ""NavigableMap"")"
The first interesting navigation method of NavigableMap is the descendingKeySet() method.,"(""NavigableMap"", ""The descendingKeySet() method is a navigation method of the NavigableMap class."", ""descendingKeySet"")"
The descendingKeySet() method returns a NavigableSet in which the order of the elements is reversed compared to the original key set.,"(""descendingKeySet"", ""The descendingKeySet() method returns a NavigableSet, indicating a relationship where the method produces an instance of the class."", ""NavigableSet"")"
The descendingMap() method returns a NavigableMap which is a view of the original Map.,"(""descendingMap"", ""The descendingMap() method returns a NavigableMap, indicating a relationship where the method provides or manipulates the class."", ""NavigableMap""); (""descendingMap"", ""The descendingMap() method is a view of the original Map, showing a relationship where the method interacts with the class."", ""Map"")"
"The headMap() method returns a view of the original NavigableMap which only contains elements that are ""less than"" the given element.","(""headMap"", ""The headMap method is a function that operates on the NavigableMap class, providing a view of its elements."", ""NavigableMap"")"
"The tailMap() method is similar to the headMap() method, except that tailMap() returns all elements that are equal to or higher than the given parameter element.","(""TailMap"", ""Both TailMap and HeadMap are methods that deal with elements based on a given parameter, with TailMap returning elements equal to or higher than the parameter."", ""HeadMap"")"
"The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys ""c"", ""d"" and ""e"", as these keys are considered equal to or larger than the parameter value ""c"" passed to the tailMap() method.","(""tailMap"", ""The tailMap method returns a SortedMap containing key-value pairs."", ""SortedMap""); (""tailMap"", ""The tailMap method operates on a NavigableMap to filter keys."", ""NavigableMap"")"
The subMap() allows you to pass two parameters demarcating the boundaries of the view map to return.,"(""subMap"", ""The subMap method allows you to pass two parameters to define the boundaries of the view map to return."", ""parameters"")"
The ceilingKey() method returns the least (smallest) key in this map that is greater than or equal to the element passed as parameter to the ceilingKey() method.,"(""CeilingKey"", ""The CeilingKey method is mentioned twice in the text, indicating its function and usage."", ""CeilingKey"")"
"Thus, floorKey() returns the greatest key which is less than or equal to the parameter value passed to ceilingKey().","(""floorKey"", ""Both methods are used to find keys in a collection based on a parameter value, with floorKey() finding the greatest key less than or equal to the parameter, and ceilingKey() presumably finding the smallest key greater than or equal to the parameter."", ""ceilingKey"")"
The higherKey() method returns the least (smallest) element in this map that is greater than (not equal too) the element passed as parameter to the higherKey() method.,"(""HigherKey"", ""The method is mentioned twice in the text, indicating its functionality and usage."", ""HigherKey"")"
"Thus, lowerKey() returns the greatest key which is lower than the parameter value passed to the lowerKey() method.","(""lowerKey"", ""The text describes the behavior of the lowerKey() method, indicating that it is a method."", ""lowerKey"")"
"In the example above, the returned lowerKey will be ""1"", as this is the highest key which is lower than the parameter value ""2"" passed to the lowerKey() method.","(""lowerKey"", ""The lowerKey method is mentioned in the context of returning a key value."", ""lowerKey"")"
"methods, except they return a Map.Entry instead of the key object itself.","(""Map.Entry"", ""Map.Entry is related to key object because it returns a Map.Entry instead of the key object itself."", ""key object"")"
"Each of the methods ceilingEntry(), floorEntry(), higherEntry() and lowerEntry() will be covered in the following sections.","(""CeilingEntry"", ""Both are methods mentioned together in the text, indicating they are related in functionality or usage."", ""FloorEntry""); (""CeilingEntry"", ""Both are methods mentioned together in the text, indicating they are related in functionality or usage."", ""HigherEntry""); (""CeilingEntry"", ""Both are methods mentioned together in the text, indicating they are related in functionality or usage."", ""LowerEntry""); (""FloorEntry"", ""Both are methods mentioned together in the text, indicating they are related in functionality or usage."", ""HigherEntry""); (""FloorEntry"", ""Both are methods mentioned together in the text, indicating they are related in functionality or usage."", ""LowerEntry""); (""HigherEntry"", ""Both are methods mentioned together in the text, indicating they are related in functionality or usage."", ""LowerEntry"")"
The ceilingEntry() method returns the key + value stored for the least (smallest) key in the NavigableMap which is higher than or equal to the parameter value passed to the ceilingEntry() method.,"(""CeilingEntry"", ""The CeilingEntry method operates on the NavigableMap class to find the least key greater than or equal to a given value."", ""NavigableMap"")"
"The ceilingEntry() is thus similar to the ceilingKey() method, except the ceilingKey() method only returns the key, and ceilingKey() returns a Map.Entry object containing both the key and value.","(""CeilingEntry"", ""CeilingEntry is similar to CeilingKey as both are methods dealing with ceiling operations."", ""CeilingKey""); (""CeilingKey"", ""CeilingKey returns a Map.Entry object, indicating a relationship between the method and the class."", ""Map.Entry"")"
"In the example above the returned ceilingEntry will contain the key ""c"" and the value ""3"", since the key ""c"" is the smallest key that is greater than or equal to the parameter value ""c"" passed to ceilingEntry() .","(""CeilingEntry"", ""The method CeilingEntry is mentioned in the context of its functionality, indicating its role in returning a specific entry based on the parameter value."", ""CeilingEntry"")"
The floorEntry() method returns the key + value for the greatest key which is equal to or lower than the parameter value passed to the floorEntry() method.,"(""FloorEntry"", ""The method is mentioned twice in the text, indicating its usage and functionality."", ""FloorEntry"")"
"The floorEntry returned in the example above will contain the key + value pair ""c"" + ""3"" , because key ""c"" is the greatest key which is lower than or equal to the parameter value ""c"" passed to the floorEntry() method.","(""floorEntry"", ""The method floorEntry is used to find the greatest key which is lower than or equal to the parameter value 'c'."", ""c"")"
The higherEntry() method returns the key + value stored for the smallest key that is higher than the parameter value passed to the higherEntry() method.,"(""HigherEntry"", ""The method is mentioned twice, indicating a self-referential relationship where the method calls itself with a parameter."", ""HigherEntry"")"
"The higherEntry returned in the example above will contain the key + value pair ""d"" + ""4"" because the key ""d"" is the lowest key which is higher than the parameter value ""c"" passed to the higherEntry() method.","(""higherEntry"", ""The higherEntry is related to the higherEntry() method as it is the method being described."", ""higherEntry()""); (""key"", ""The key is related to the higherEntry() method because the method returns a key-value pair."", ""higherEntry()""); (""value"", ""The value is related to the higherEntry() method because the method returns a key-value pair."", ""higherEntry()"")"
The lowerEntry() method in the NavigableMap interface returns the key + value pair for the highest key which is lower than the parameter value passed to the lowerEntry() method.,"(""LowerEntry"", ""The LowerEntry method is part of the NavigableMap interface."", ""NavigableMap"")"
"The lowerEntry returned in this example will be the key + value pair ""a"" + ""1"" since ""a"" is the highest key which is lower than the parameter value ""b"" passed to the lowerEntry() method.","(""lowerEntry"", ""The lowerEntry method is mentioned in the text as being used to find the highest key lower than a given parameter."", ""lowerEntry"")"
"The pollFirstEntry() method returns and removes the ""first"" entry (key + value) in the NavigableMap or null if the map is empty.","(""PollFirstEntry"", ""The PollFirstEntry method operates on the NavigableMap class by returning and removing the first entry from it."", ""NavigableMap"")"
"The pollLastEntry() returns and removes the ""last"" element in the map or null if the map is empty.","(""pollLastEntry"", ""The method pollLastEntry returns and removes the last element in the map."", ""last element""); (""pollLastEntry"", ""The method pollLastEntry operates on the map."", ""map"")"
"The Java NavigableSet interface, java.util.NavigableSet, is a subtype of the Java SortedSet interface.","(""NavigableSet"", ""NavigableSet is a subtype of the SortedSet class"", ""SortedSet""); (""NavigableSet"", ""NavigableSet is part of the java.util.NavigableSet package"", ""java.util.NavigableSet"")"
In Java 6 to 13 there is only one implementation of the NavigableSet interface in the java.util package: The java.util.TreeSet class.,"(""java.util.TreeSet"", ""The java.util.TreeSet class is an implementation of the NavigableSet interface."", ""NavigableSet""); (""java.util.TreeSet"", ""The java.util.TreeSet class is part of the java.util package."", ""java.util"")"
There is an implementation in the java.util.concurrent package called ConcurrentSkipListSet but that is outside the scope of this trail.,"(""ConcurrentSkipListSet"", ""ConcurrentSkipListSet is a class that is implemented within the java.util.concurrent package."", ""java.util.concurrent"")"
To create a Java NavigableSet you must create an instance of one of the classes implementing the NavigableSet interface.,"(""NavigableSet"", ""The NavigableSet is both a class and an interface in the context of Java collections."", ""NavigableSet"")"
Here is an example of creating an instance of the class TreeSet which implements the NavigableSet interface:,"(""TreeSet"", ""TreeSet implements the NavigableSet interface"", ""NavigableSet"")"
The descendingSet() method returns a NavigableSet in which the order of the elements is reversed compared to this one.,"(""DescendingSet"", ""The DescendingSet method returns a NavigableSet."", ""NavigableSet"")"
"The descendingIterator() method allows you to iterate the elements of the NavigableSet (which is also a SortedSet) in reverse order, without changing the order of the elements internally.","(""DescendingIterator"", ""The DescendingIterator method is used to iterate over the elements of the NavigableSet in reverse order."", ""NavigableSet""); (""NavigableSet"", ""NavigableSet is a type of SortedSet."", ""SortedSet"")"
"The headSet() method returns a view of the original NavigableSet which only contains elements that are ""less than"" the given element.","(""headSet"", ""The headSet method is a function that operates on the NavigableSet class, providing a view of its elements."", ""NavigableSet"")"
"The tailSet() method works the same way as the headSet() method, except it returns all elements that are equal to or higher than the given parameter element.","(""TailSet"", ""Both methods are related as they perform similar operations, with TailSet returning elements equal to or higher than a given parameter, while HeadSet returns elements lower than a given parameter."", ""HeadSet"")"
The subSet() method allows you to pass two parameters demarcating the boundaries of the view set to return.,"(""SUBSET"", ""The subSet() is a method that allows you to pass two parameters demarcating the boundaries of the view set to return."", ""METHOD"")"
The ceiling() method returns the least (smallest) element in this set that is greater than or equal to the element passed as parameter to the ceiling() method.,"(""Ceiling"", ""The Ceiling method is mentioned twice in the text, indicating its role in returning the least element greater than or equal to the parameter."", ""Ceiling"")"
"The floor() method does the opposite of the ceiling() method, meaning it returns the greatest element that is less than or equal to the given parameter value.","(""Floor"", ""The Floor method is related to the Ceiling method as they perform opposite operations."", ""Ceiling"")"
The higher() method returns the least (smallest) element in this set that is greater than (not equal too) the element passed as parameter to the higher() method.,"(""Higher"", ""The method is mentioned twice in the text, indicating its functionality and usage."", ""Higher"")"
"The lower() method does the opposite of the higher() method, meaning it returns the highest element that is less than (not equal to) the given parameter.","(""Lower"", ""The Lower method is related to the Higher method as they perform opposite operations."", ""Higher"")"
"The pollFirst() method returns and removes the ""first"" element in the NavigableSet or null if the set is empty.","(""PollFirst"", ""The PollFirst method operates on the NavigableSet class by returning and removing its first element."", ""NavigableSet"")"
"The pollLast() method returns and removes the ""last"" element in the NavigableSet.","(""PollLast"", ""The PollLast method operates on the NavigableSet class by returning and removing the last element."", ""NavigableSet"")"
"The Java Properties class, java.util.Properties, is like a Java Map of Java String key and value pairs.","(""Properties"", ""The Properties class is part of the java.util.Properties package."", ""java.util.Properties""); (""Properties"", ""The Properties class is described as being like a Map."", ""Map""); (""Properties"", ""The Properties class deals with String key and value pairs."", ""String"")"
"The Java Properties class can write the key, value pairs to a properties file on disk, and read the properties back in again.","(""Java Properties"", ""The write method is a functionality provided by the Java Properties class to write key-value pairs to a file."", ""write""); (""Java Properties"", ""The read method is a functionality provided by the Java Properties class to read properties from a file."", ""read"")"
To use the Java Properties class you must first create a Properties instance.,"(""Properties"", ""The text indicates that a Properties instance is created, which implies a relationship between the Properties class and its instance."", ""Properties"")"
To set properties in a Java Properties instance you use the setProperty() method.,"(""Properties"", ""The setProperty() method is used to set properties in a Java Properties instance."", ""setProperty"")"
"To get properties from a Java Properties object you use the getProperty() method, passing the key of the property to get as parameter.","(""Properties"", ""The getProperty method is used to retrieve properties from a Properties object."", ""getProperty"")"
"You can remove a property from a Java Properties instance using its remove() method, passing as parameter to remove() the key for the property to remove.","(""Java Properties"", ""The remove() method is used to remove a property from a Java Properties instance."", ""remove"")"
You store the contents of a Properties object via its store() method.,"(""Properties"", ""The store() method is used to store the contents of a Properties object."", ""store"")"
Notice the first line of the properties file is actually the comment that was passed as second parameter to the store() method call in the code example in the previous section about storing properties to a property file.,"(""STORE"", ""The text mentions the 'store()' method call, indicating that 'STORE' is a method."", ""METHOD"")"
You can also load properties stored in a property file back into a Java Properties object via its load() method.,"(""Java Properties"", ""The load method is used to load properties into a Java Properties object."", ""load"")"
By default the load() method will assume that the loaded file is encoded using ISO-8859-1 (Latin-1).,"(""LOAD"", ""The LOAD method assumes that the loaded file is encoded using ISO-8859-1."", ""ISO-8859-1"")"
The Java Properties class can also write the key-value pairs stored in it to an XML file via its storeToXML().,"(""Properties"", ""The storeToXML method is a function of the Properties class, allowing it to write key-value pairs to an XML file."", ""storeToXML"")"
"Notice how the comment passed to the storeToXML() method is enclosed in a comment XML element, and not in an XML comment (<!-- -->) .","(""STORETOXML"", ""The STORETOXML method is mentioned in relation to the comment being passed to it."", ""COMMENT"")"
You can load properties from an XML property file into a Java Properties object via its loadFromXML() method.,"(""Properties"", ""The loadFromXML method is used to load properties into a Properties object."", ""loadFromXML"")"
By default the loadFromXML() method will assume that the XML file is stored using the UTF-8 encoding.,"(""LOADFROMXML"", ""The loadFromXML method assumes that the XML file is stored using the UTF-8 encoding."", ""UTF-8"")"
It is possible to load properties into a Java Properties from a file that is available on the classpath.,"(""Java Properties"", ""Java Properties can load properties from a file available on the classpath"", ""classpath"")"
"That file could thus be located inside the same JAR file as the application loading the properties, or inside another JAR file or directory available on the Java classpath when your Java application is executed.","(""JAR File"", ""JAR File is located on the Java Classpath when the Java application is executed."", ""Java Classpath"")"
To load properties from a file available on the classpath you need to obtain a Class instance first.,"(""Class"", ""The Class instance is used to load properties from a file available on the classpath."", ""classpath"")"
In the example below I obtain it from the class that contains the main() method of my application:,"(""Application"", ""The Main method is contained within the Application class."", ""Main"")"
Once I have the Class instance I can call its getResourceAsStream() method which returns a Java InputStream referencing the file.,"(""Class"", ""The getResourceAsStream method is called on the Class instance."", ""getResourceAsStream""); (""getResourceAsStream"", ""The getResourceAsStream method returns an InputStream."", ""InputStream"")"
Here is an example of obtaining a reference to a file from the classpath:,"(""Classpath"", ""class"")"
The file would have to be located in the root directory of the classpath.,"(""CLASSPATH"", ""PACKAGE"")"
"If you put it into a subdirectory, the path passed to getResourceAsStream() should reflect that.","(""getResourceAsStream"", ""The method getResourceAsStream is used to access resources, which may be located in a subdirectory."", ""subdirectory"")"
"Using the InputStream you can load the file into a Java Properties instance, using either the load() or loadFromXML() methods explained earlier in this Java Properties tutorial.","(""InputStream"", ""The InputStream class is used to load data into a Java Properties instance."", ""Java Properties""); (""load"", ""The load method is used to load data into a Java Properties instance."", ""Java Properties""); (""loadFromXML"", ""The loadFromXML method is used to load data into a Java Properties instance."", ""Java Properties""); (""Java Properties tutorial"", ""The Java Properties tutorial explains how to use the Java Properties class."", ""Java Properties"")"
"The ResourceBundle class is covered as part of that tutorial, in the Java ResourceBundle tutorial.","(""ResourceBundle"", ""The ResourceBundle class is part of the Java package as indicated by the tutorial context."", ""Java"")"
The Java Properties class has the ability to provide default property values for properties that do not have any key registered in the Properties instance.,"(""Properties"", ""The Properties class is mentioned as having the ability to provide default property values."", ""Properties"")"
The getProperty() method comes in a version that takes an extra parameter which is the default value to return in case the Properties instance does not contain a value for the given key.,"(""getProperty"", ""The getProperty method is used to retrieve values from a Properties instance."", ""Properties"")"
Here is an example of calling getProperty() with a default value:,"(""getProperty"", ""The method getProperty is being called with a default value as an argument."", ""default value"")"
"If the Properties instance does not contain a property for the key preferredLanguage, then the value Danish will be returned - instead of returning null which would have been returned if no default value had been passed to getProperty().","(""Properties"", ""The getProperty method is used to retrieve a property from the Properties class."", ""getProperty"")"
The Java Properties class can be instantiated with another Properties instance containing default values to use when the newly created Properties instance does not contain a value for a requested property key.,"(""Properties"", ""The Properties class can be instantiated with another Properties instance, indicating a relationship between the class and its instances."", ""Properties"")"
The System class also has a getProperty() and setProperty() method which are shortcuts to the Properties getProperty() and setProperty() methods of the System Properties instance.,"(""System"", ""The getProperty method is a part of the System class."", ""getProperty""); (""System"", ""The setProperty method is a part of the System class."", ""setProperty""); (""Properties"", ""The getProperty method is a part of the Properties class."", ""getProperty""); (""Properties"", ""The setProperty method is a part of the Properties class."", ""setProperty""); (""System Properties"", ""System Properties is an instance of the Properties class."", ""Properties"")"
"The Java Properties class is a subclass of the Java Hashtable class, and as I will show you - this is actually a design mistake!","(""Java Properties"", ""Java Properties is a subclass of Java Hashtable"", ""Java Hashtable"")"
"It is a great example of when the classic ""Is a / Has a"" OOP rule about when to use inheritance vs. composition fails.",NULL
"Being a subclass of Hashtable, you can actually use the get() and put() method of the Hashtable class, which allow the use of non-string keys and values.","(""Hashtable"", ""The get method is used in the context of the Hashtable class."", ""get""); (""Hashtable"", ""The put method is used in the context of the Hashtable class."", ""put"")"
"This defeats the purpose of the Properties class, which is to function as a string,string map.","(""Properties"", ""The Properties class is described as functioning as a string,string map."", ""string,string map"")"
Notice how it is possible to call put() with non-string values.,"(""put"", ""The method 'put' can be called with non-string values, indicating a relationship between the method and the type of values it accepts."", ""non-string values"")"
Just to make it clear: You should NOT use the put() and get() method of the Properties class!,"(""PUT"", ""The PUT method is a method of the PROPERTIES class."", ""PROPERTIES""); (""GET"", ""The GET method is a method of the PROPERTIES class."", ""PROPERTIES"")"
"If instead the value passed to put() had been two strings, then it would have worked as expected.","(""PUT"", ""The text refers to 'put()' as a method, indicating its role in the context."", ""METHOD"")"
Notice how the second value passed to put() is now also a string.,"(""put"", ""The method 'put' takes a string as its second argument, indicating a relationship between the method and the data type."", ""string"")"
"Even if you can get get() and put() to work, I would recommend that you do not use these methods.","(""GET"", ""Both are methods mentioned in the text that are related to each other as they are used in similar contexts."", ""PUT"")"
"Using that formulation, Properties would not have been made a subclass of Hashtable, because Properties should not be usable as a Hashtable .","(""Properties"", ""Properties is described as a subclass of Hashtable, indicating a class inheritance relationship."", ""Hashtable"")"
"Instead, the Properties class should have just had an internal Hashtable to keep the property key,value pairs in.","(""Properties"", ""The Properties class uses an internal Hashtable to store property key-value pairs."", ""Hashtable"")"
"The Java Queue interface, java.util.Queue represents a data structure designed to have elements inserted at the end of the queue, and elements removed from the beginning of the queue.","(""Queue"", ""The Queue class is part of the java.util.Queue package, indicating its location within the Java library."", ""java.util.Queue"")"
"There are also Queue implementations in the java.util.concurrent package, but I will leave the concurrency utilities out of this tutorial.","(""Queue"", ""Queue is a class that is implemented within the java.util.concurrent package"", ""java.util.concurrent"")"
"The add() and offer() methods differ in how the behave if the Queue is full, so no more elements can be added.","(""Add"", ""The Add method is related to the Queue class as it is a method that operates on a Queue."", ""Queue""); (""Offer"", ""The Offer method is related to the Queue class as it is a method that operates on a Queue."", ""Queue"")"
"The add() method throws an exception in that case, whereas the offer() method just returns false.","(""Add"", ""Both are methods that handle cases differently when an operation cannot be completed."", ""Offer"")"
Here are two examples of adding elements to a Java Queue via its add() and offer() methods:,"(""Queue"", ""The add() method is used to add elements to the Queue class."", ""add()""); (""Queue"", ""The offer() method is used to add elements to the Queue class."", ""offer()"")"
To take an element from a Java Queue you can call either its poll() or remove() method.,"(""Queue"", ""The poll method is a function that can be called on a Queue class to take an element from it."", ""poll""); (""Queue"", ""The remove method is a function that can be called on a Queue class to take an element from it."", ""remove"")"
The poll() and remove() both removes the first element in the Queue.,"(""Poll"", ""The method Poll is used to remove the first element from the Queue."", ""Queue""); (""Remove"", ""The method Remove is used to remove the first element from the Queue."", ""Queue"")"
The remove() method throws an exception if the Queue is empty.,"(""Remove"", ""The remove method is associated with the Queue class as it operates on it."", ""Queue"")"
Here are two examples of taking an element from a Java Queue using its poll() and remove() methods:,"(""Queue"", ""The poll() method is used to take an element from a Java Queue."", ""poll()""); (""Queue"", ""The remove() method is used to take an element from a Java Queue."", ""remove()"")"
"The call to poll() will remove the first element of the Queue - which is the first Java String instance added - ""element 1"".","(""Poll"", ""The method Poll is used to remove the first element from the Queue."", ""Queue""); (""Java String"", ""The Java String instance is an element within the Queue."", ""Queue"")"
"The call to rmove() will remove the second element of the Queue - which after the first poll() call is now the String instance added - ""element 2"".","(""Rmove"", ""The method rmove() is used to remove an element from the Queue class."", ""Queue""); (""Poll"", ""The method poll() is called on the Queue class."", ""Queue""); (""String"", ""The String instance is an element within the Queue class."", ""Queue"")"
"If the Queue is empty, the element() method throws a NoSuchElementException.","(""Queue"", ""The element() method is a function that operates on the Queue class."", ""element()""); (""element()"", ""The element() method throws a NoSuchElementException when the Queue is empty."", ""NoSuchElementException"")"
Here is an example of peeking at the first element of a Java Queue using the element() method:,"(""Queue"", ""The element() method is used to peek at the first element of a Java Queue."", ""element"")"
The peek() works like the element() method except it does not throw an exception if the Queue is empty.,"(""PEEK"", ""The PEEK method works like the ELEMENT method, indicating a functional similarity or equivalence."", ""ELEMENT""); (""PEEK"", ""The PEEK method is used in the context of a QUEUE, as it checks elements within it."", ""QUEUE""); (""ELEMENT"", ""The ELEMENT method is used in the context of a QUEUE, as it retrieves elements from it."", ""QUEUE"")"
Here is an example of peeking at the first element of a Queue using the peek() method:,"(""Queue"", ""The peek method is used to access the first element of the Queue class."", ""peek"")"
"To remove elements from a Java Queue, you call the remove() method.","(""Queue"", ""The remove method is used to remove elements from the Queue class."", ""remove"")"
You can remove all elements from a Java Queue using its clear() method.,"(""Java Queue"", ""The clear() method is used to remove all elements from a Java Queue."", ""clear()"")"
Here is an example of removing all elements from a Java Queue via its clear() method:,"(""Queue"", ""The clear method is used to remove all elements from the Queue class."", ""clear"")"
You can read the number of elements stored in a Java Queue via its size() method.,"(""Queue"", ""The size method is used to read the number of elements stored in a Queue class."", ""size"")"
Here is an example of obtaining the size of a Java Queue via its size() method:,"(""Queue"", ""The size() method is used to obtain the size of the Queue class."", ""size()"")"
After running this code the size variable should contain the value 3 - because the Queue contains 3 elements at the time size() is called.,"(""Queue"", ""The size method is called on the Queue class to determine the number of elements it contains."", ""size"")"
You can check if a Java Queue contains a certain element via its contains() method.,"(""Queue"", ""The 'contains' method is used to check if a 'Queue' contains a certain element."", ""contains"")"
"The contains() method will return true if the Queue contains the given element, and false if not.","(""Contains"", ""The Contains method is used to check if the Queue class contains a given element."", ""Queue"")"
"The contains() method is actually inherited from the Collection interface, but in practice that doesn't matter.","(""Contains"", ""The Contains method is inherited from the Collection class, indicating a relationship between the method and the class."", ""Collection"")"
"The Java Set interface, java.util.Set, represents a collection of objects where each object in the Java Set is unique.","(""Java Set"", ""The Java Set class is part of the java.util.Set package, indicating a package-class relationship."", ""java.util.Set"")"
"If the Set is not typed, using Java Generics, then you can even mix objects of different types (classes) in the same Set.","(""Set"", ""The Set class can be used with Java Generics to enforce type safety."", ""Java Generics"")"
This example creates a HashSet which is one of the classes in the Java APIs that implement the Set interface.,"(""HashSet"", ""HashSet is a class that implements the Set interface."", ""Set""); (""HashSet"", ""HashSet is a class within the Java APIs."", ""Java"")"
"In other words, the order in which the elements whould be sorted if you used a Collections.sort() on a List or array containing these elements.","(""Collections"", ""The sort method is a member of the Collections class, used for sorting elements."", ""sort""); (""List"", ""Both List and array are data structures that can contain elements to be sorted."", ""array""); (""Collections"", ""Collections can operate on List objects, such as sorting them."", ""List""); (""Collections"", ""Collections can operate on arrays, such as sorting them."", ""array"")"
"There are also Set implementations in the java.util.concurrent package, but I will leave the concurrency utilities out of this tutorial.","(""Set"", ""The Set class is implemented within the java.util.concurrent package."", ""java.util.concurrent"")"
The Java Set static factory methods are called of() and take either zero or more parameters.,"(""Set"", ""The method of() is a static factory method of the Set class."", ""of()"")"
"Here is first an example of creating an empty, immutable Set using Set.of() :","(""Set"", ""Set.of() is a method used to create an instance of the Set class"", ""Set.of()"")"
Specifying a generic type of the Set returned by Set.of() looks like this:,"(""Set.of()"", ""The method Set.of() returns an instance of the class Set."", ""Set"")"
Here is an example of how creating a Set containing elements using the Set.of() method looks:,"(""Set"", ""The Set.of() method is used to create a Set containing elements."", ""Set.of()"")"
To add elements to a Set you call its add() method.,"(""Set"", ""The add method is used to add elements to the Set class."", ""add"")"
The three add() calls add a String instance to the set.,"(""Add"", ""The method Add is used to add a String instance to the set."", ""String"")"
You obtain an Iterator from a Set by calling the iterator() method.,"(""Set"", ""The iterator() method is called on a Set to obtain an Iterator."", ""iterator""); (""iterator"", ""The iterator() method returns an Iterator."", ""Iterator"")"
You can remove all elements from a Java Set using the clear() method.,"(""Java Set"", ""The clear() method is used to remove all elements from a Java Set."", ""clear()"")"
The Java List interface has a method called addAll() which adds all elements from another Collection (List or Set) to the Set.,"(""Java List"", ""The addAll method is a function of the Java List class."", ""addAll""); (""addAll"", ""The addAll method adds elements from a Collection."", ""Collection""); (""addAll"", ""The addAll method can add elements to a Set."", ""Set""); (""Collection"", ""The Collection can be a source of elements for the Set."", ""Set"")"
The Java Set interface as a method called removeAll() which removes all elements in the Set which are also present in another Collection.,"(""Set"", ""The removeAll method is a function that operates on the Set class."", ""removeAll""); (""removeAll"", ""The removeAll method removes elements from the Set that are also present in another Collection."", ""Collection"")"
"The element three has been removed, because it was present in set2, which was given as parameter to set.removeAll(set2) .","(""RemoveAll"", ""Set2 is a parameter for the RemoveAll method"", ""Set2""); (""Set"", ""RemoveAll is a method that operates on the Set class"", ""RemoveAll"")"
You can check the size of a Java Set using the size() method.,"(""Set"", ""The size() method is used to check the size of a Set class in Java."", ""size()"")"
"You can check if a Java Set is empty, meaning it contains no elements, by calling the isEmpty() method on the Set.","(""Set"", ""The isEmpty method is called on the Set class to check if it contains no elements."", ""isEmpty"")"
You can also check if a Set is empty by comparing the value returned by the size() method with 0.,"(""Set"", ""The size() method is used to check if a Set is empty by comparing its return value with 0."", ""size"")"
"After running this Java code the isEmpty variable will contain the value true, because the Set size() method returns 0 - because the Set in the example contains no elements.","(""Set"", ""The size method is used to determine the number of elements in the Set class."", ""size""); (""Set"", ""The isEmpty variable is determined by the size of the Set class."", ""isEmpty"")"
You can check if a Java Set contains a given element (object) by calling the contains() method.,"(""Set"", ""The contains method is used to check if a Set contains a given element."", ""contains"")"
"You can convert a Java Set to a Java List by creating a List and calling its addAll() method, passing the Set as parameter to the addAll() method.","(""List"", ""The addAll method is a method of the List class."", ""addAll""); (""Set"", ""The addAll method is used to add elements from a Set to a List."", ""addAll""); (""Set"", ""A Set can be converted to a List by using the addAll method."", ""List"")"
"The Java SortedMap interface, java.util.SortedMap, is a subtype of the java.util.Map interface, with the addition that the elements stored in a Java SortedMap map are sorted internally.","(""SortedMap"", ""SortedMap is a subtype of Map"", ""Map""); (""java.util.SortedMap"", ""java.util.SortedMap is a subtype of java.util.Map"", ""java.util.Map"")"
Java comes with a built-in implementation of the Java SortedMap interface called TreeMap (java.util.TreeMap).,"(""TreeMap"", ""TreeMap is an implementation of the SortedMap interface."", ""SortedMap""); (""java.util.TreeMap"", ""java.util.TreeMap is the fully qualified name of the TreeMap class."", ""TreeMap""); (""Java"", ""java.util.TreeMap is part of the Java package."", ""java.util.TreeMap"")"
"The order of the sorting in a Java SortedMap is either the natural sorting order of the elements (if they implement java.lang.Comparable), or the order determined by a Comparator that you can give to the SortedSet.","(""SortedMap"", ""SortedMap can use the natural sorting order of elements if they implement java.lang.Comparable."", ""java.lang.Comparable""); (""SortedMap"", ""SortedMap can use a Comparator to determine the order of elements."", ""Comparator""); (""SortedSet"", ""A Comparator can be given to a SortedSet to determine the order."", ""Comparator"")"
But it is also possible to iterate the elements in descending order using the method TreeMap.descendingKeySet().,"(""TreeMap"", ""The method descendingKeySet() is a member of the class TreeMap, allowing iteration of elements in descending order."", ""descendingKeySet"")"
"You iterate the keys of a SortedMap by calling its keySet() method, like this:","(""SortedMap"", ""The keySet method is called on the SortedMap class to iterate its keys."", ""keySet"")"
"Remember, if you want to iterate the keys in descending order rather than ascending order, use the sortedMap.descendingKeySet().iterator() method, like this:","(""sortedMap"", ""The descendingKeySet method is called on the sortedMap class to get the keys in descending order."", ""descendingKeySet""); (""descendingKeySet"", ""The iterator method is used on the result of descendingKeySet to iterate over the keys."", ""iterator"")"
"If your Java SortedMap was created using a Comparator, you can obtain the Comparator used via the SortedMap comparator() method.","(""SortedMap"", ""The SortedMap class can be created using a Comparator, indicating a relationship between the two entities."", ""Comparator""); (""SortedMap"", ""The comparator() method is used to obtain the Comparator from a SortedMap, showing a functional relationship."", ""comparator"")"
Here is an example of obtaining the Comparator used by a SortedMap via its comparator() method:,"(""SortedMap"", ""The comparator() method is used by the SortedMap to obtain the Comparator."", ""comparator"")"
Here is an example of obtaining the first key of a SortedMap via its firstKey() method:,"(""SortedMap"", ""The firstKey() method is used to obtain the first key of a SortedMap, indicating a functional relationship between the class and the method."", ""firstKey"")"
Here is an example of obtaining the last key of a SortedMap via its lastKey() method:,"(""SortedMap"", ""The lastKey() method is used to obtain the last key of a SortedMap, indicating a functional relationship between the class and the method."", ""lastKey"")"
The SortedMap interface has a method named headMap() which returns a new Map which contains the first elements of the SortedMap according to the sort order used.,"(""SortedMap"", ""The headMap method is a part of the SortedMap interface."", ""headMap""); (""headMap"", ""The headMap method returns a new Map."", ""Map"")"
The headMap() method takes a parameter that acts as a delimiter for what elements gets included in the returned head map.,"(""headMap"", ""The headMap method takes a parameter, indicating a relationship where the parameter is used by the method."", ""parameter"")"
All elements with a key that is smaller than / earlier than the parameter passed to the headMap() method.,"(""headMap"", ""The headMap method uses the parameter to determine which elements are smaller or earlier."", ""parameter"")"
Here is an example of obtaining a head map from a SortedMap via its headMap() method:,"(""SortedMap"", ""The headMap method is used to obtain a head map from a SortedMap, indicating that headMap is a method belonging to the SortedMap class."", ""headMap"")"
The SortedMap interface has a method named tailMap() which returns a new Map which contains the last elements of the SortedMap according to the sort order used.,"(""SortedMap"", ""The method tailMap() is a part of the SortedMap interface."", ""tailMap""); (""tailMap"", ""The method tailMap() returns a new Map."", ""Map"")"
The tailMap() method takes a parameter that acts as a delimiter for what elements gets included in the returned tail map.,"(""tailMap"", ""The tailMap method takes a parameter that acts as a delimiter for what elements get included in the returned tail map."", ""parameter"")"
All elements with a key that is equal to or larger than the parameter passed to the tailMap() method.,"(""tailMap"", ""The tailMap method uses the parameter to determine the starting point for the elements it returns."", ""parameter"")"
Here is an example of obtaining a tail map from a SortedMap via its tailMap() method:,"(""SortedMap"", ""The tailMap method is used to obtain a tail map from a SortedMap, indicating a functional relationship between the class and the method."", ""tailMap"")"
"The tail map returned will contain the key, value pairs (""c"", ""3""), (""d"", ""4"") and (""e"", ""5""), since ""c"", ""d"" and ""e"" are larger than or equal to the ""c"" passed as parameter to tailMap() .","(""tailMap"", ""The method tailMap() uses 'c' as a parameter to determine the elements in the returned map."", ""c"")"
The Java SortedMap also has a method named subMap() which can return a new Map which is a submap of the SortedMap.,"(""SortedMap"", ""The method subMap() is a part of the SortedMap class."", ""subMap"")"
The subMap() method takes two parameters which act as delimiters for what elements are included in the returned submap.,"(""subMap"", ""The subMap method takes two parameters as delimiters for the elements included in the returned submap."", ""parameters"")"
Here is an example of obtaining a submap from a Java SortedMap via its subMap() method:,"(""SortedMap"", ""The subMap() method is used to obtain a submap from a SortedMap, indicating a functional relationship between the class and the method."", ""subMap"")"
"The Java SortedSet interface, java.util.SortedSet, is a subtype of the java.util.Set interface.","(""SortedSet"", ""The SortedSet class is part of the java.util.SortedSet package."", ""java.util.SortedSet""); (""Set"", ""The Set class is part of the java.util.Set package."", ""java.util.Set""); (""SortedSet"", ""The SortedSet class is a subtype of the Set class."", ""Set"")"
The Java Collections API only has one implementation of the Java SortedSet interface - the java.util.TreeSet class.,"(""Java Collections API"", ""The Java Collections API includes the Java SortedSet interface."", ""Java SortedSet""); (""Java SortedSet"", ""The java.util.TreeSet class is an implementation of the Java SortedSet interface."", ""java.util.TreeSet"")"
"The java.util.concurrent package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail.","(""Java.util.concurrent"", ""The Java.util.concurrent package contains concurrency utilities."", ""Concurrency utilities"")"
"It it possible to pass a Comparator, java.util.Comparator implementation to the constructor of the TreeSet.","(""Comparator"", ""Comparator is an implementation of the java.util.Comparator package."", ""java.util.Comparator""); (""Comparator"", ""Comparator can be passed to the constructor of the TreeSet class."", ""TreeSet"")"
"For the SortedSet to be able to determine the natural order of the elements, the elements must implement the java.lang.Comparable interface.","(""SortedSet"", ""The SortedSet class requires elements to implement the java.lang.Comparable interface to determine their natural order."", ""java.lang.Comparable"")"
But it is also possible to iterate the elements in descending order using the method TreeSet.descendingIterator().,"(""TreeSet"", ""The method descendingIterator() is a member of the class TreeSet, allowing iteration over its elements in descending order."", ""descendingIterator"")"
"If you created your SortedSet with a Comparator, you can obtain that Comparator via the SortedSet comparator() method.","(""SortedSet"", ""SortedSet can be created with a Comparator to define the order of elements."", ""Comparator""); (""SortedSet"", ""The comparator() method is used to obtain the Comparator associated with the SortedSet."", ""comparator"")"
Here is an example of obtaining the Comparator used by a SortedSet via the comparator() method:,"(""comparator"", ""The comparator() method is used to obtain the Comparator class."", ""Comparator""); (""comparator"", ""The comparator() method is used by a SortedSet to obtain its Comparator."", ""SortedSet"")"
You add elements to a Java SortedSet in the same way you do with a normal Java Set - via its add() method.,"(""SortedSet"", ""The add() method is used to add elements to a SortedSet."", ""add""); (""Set"", ""The add() method is used to add elements to a Set."", ""add"")"
"To remove an element from a SortedSet you call its remove() method, passing the element to remove as parameter.","(""SortedSet"", ""The remove method is used to remove an element from the SortedSet class."", ""remove"")"
You can get the first element of a SortedSet according to its sort order by calling the first() method of the SortedSet.,"(""SortedSet"", ""The first() method is a function of the SortedSet class, used to retrieve the first element according to its sort order."", ""first"")"
You can get the last element of a SortedSet according to its sort order by calling the last() method of the SortedSet.,"(""SortedSet"", ""The last() method is a function that can be called on the SortedSet class to retrieve the last element according to its sort order."", ""last"")"
"You call the SortedSet iterator() method which returns an Iterator, and then you can iterate the elements via that.","(""SortedSet"", ""The iterator() method is called on the SortedSet class."", ""iterator()""); (""iterator()"", ""The iterator() method returns an Iterator class."", ""Iterator"")"
"The Java SortedSet interface has a method named headSet() which returns another SortedSet with all elements that are smaller than (ahead of) a given parameter value, according to the sort order used by the SortedSet.","(""SortedSet"", ""The headSet method is a part of the SortedSet class, as it is described as a method of the SortedSet interface."", ""headSet""); (""SortedSet"", ""The headSet method returns another instance of the SortedSet class."", ""SortedSet"")"
Here is an example of obtaining a head set from a Java SortedSet via its headSet() method:,"(""SortedSet"", ""The headSet() method is used to obtain a head set from a SortedSet class."", ""headSet"")"
"After running this code the headSet will contain the elements ""a"" and ""b"" since these two elements are smaller than (ahead of) the parameter value ""c"" that was passed to the headSet() method.","(""headSet"", ""The headSet is related to headSet() as it is a method that operates on the headSet."", ""headSet()""); (""headSet()"", ""The headSet() method is used to create or manipulate the headSet."", ""headSet"")"
"The Java SortedSet interface has a method named setSet() which returns another SortedSet with all elements that are greater than or equal to (tailing) a given parameter value, according to the sort order used by the SortedSet.","(""SortedSet"", ""The method setSet() is part of the SortedSet class."", ""setSet""); (""SortedSet"", ""The method setSet() returns another instance of the SortedSet class."", ""SortedSet"")"
Here is an example of obtaining a tail set from a Java SortedSet via its tailSet() method:,"(""SortedSet"", ""The tailSet method is used to obtain a tail set from the SortedSet class."", ""tailSet"")"
"After running this code the tailSet will contain the elements ""c"", ""d"" and ""e"", since these three elements are greater than or equal to (tailing) the parameter value ""c"" that was passed to the tailSet() method.","(""tailSet"", ""The tailSet is a method, and tailSet() is the invocation of this method."", ""tailSet()""); (""tailSet()"", ""The tailSet() method is being used to modify or interact with the tailSet."", ""tailSet"")"
The Java SortedSet interface has a method named subSet() method which will return a new SortedSet which is a subset of the SortedSet the subSet() method is called on.,"(""SortedSet"", ""The subSet() method is a function of the SortedSet class, allowing operations on its instances."", ""subSet""); (""subSet"", ""The subSet() method returns a new instance of the SortedSet class."", ""SortedSet"")"
The subSet() method takes two parameter values which specify what elements the returned SortedSet should contain.,"(""subSet"", ""The subSet method is related to SortedSet because it specifies what elements the returned SortedSet should contain."", ""SortedSet"")"
Here is an example of obtaining a subset of a Java SortedSet via its subSet() method:,"(""SortedSet"", ""The subSet method is a function that operates on the SortedSet class to obtain a subset."", ""subSet"")"
Notice how there is no longer a cast of the object returned from iterator.next() needed.,"(""iterator"", ""The method 'next' is called on the 'iterator' object, indicating a functional relationship where 'next' is a method of 'iterator'."", ""next"")"
"Because the generic type of the SortedSet is String, the compiler knows that the iterator is an Iterato<String>, so next() return String objects.","(""SortedSet"", ""The iterator is associated with the SortedSet class as it is used to iterate over its elements."", ""iterator""); (""iterator"", ""The next() method is used in conjunction with the iterator to retrieve the next element."", ""next""); (""SortedSet"", ""The SortedSet is parameterized with the generic type String, indicating it stores String objects."", ""String""); (""next"", ""The next() method returns objects of type String, as indicated by the generic type of the SortedSet."", ""String"")"
You can sort a Java List collections using the java.util.Collections.sort() method.,"(""sort"", ""The sort method is used to sort a Java List."", ""Java List""); (""sort"", ""The sort method is part of the java.util.Collections package."", ""java.util.Collections"")"
For objects to have a natural order they must implement the interface java.lang.Comparable.,"(""java.lang.Comparable"", ""Objects must implement the java.lang.Comparable interface to have a natural order."", ""objects"")"
"The compareTo() method should compare this object to another object, return an int value.","(""CompareTo"", ""The term 'compareTo()' is identified as a method because it is described as a method in the text."", ""Method"")"
"So, if a string is less than another string by alphabetic comparison it will return a negative number from the compareTo() method.","(""CompareTo"", ""The CompareTo method is used to compare two String objects alphabetically."", ""String"")"
When you implement the compareTo() method in your own classes you will have to decide how these objects should be compared to each other.,"(""compareTo"", ""The compareTo method is implemented in classes to define how objects of these classes should be compared to each other."", ""classes"")"
Notice how the Collections.sort() method now takes a java.util.Comparator as parameter in addition to the List.,"(""Collections.sort()"", ""The Collections.sort() method takes a java.util.Comparator as a parameter."", ""java.util.Comparator""); (""Collections.sort()"", ""The Collections.sort() method takes a List as a parameter."", ""List"")"
The compare() method compares two objects to each other and should:,"(""Compare"", ""The compare() method is used to compare two objects to each other."", ""Objects"")"
"There are a few more requirements to the implementation of the compare() method, but these are the primary requirements.","(""COMPARE"", ""The text refers to the 'compare()' as a method, indicating a relationship between the name 'compare' and its classification as a method."", ""METHOD"")"
"If you want to compare objects by more than one factor, start by comparing by the first factor (e.g first name).",NULL
"Then, if the first factors are equal, compare by the second factor (e.g.",NULL
"The Java Stack class, java.util.Stack, is a classical stack data structure.","(""Stack"", ""The Stack class is part of the java.util.Stack package."", ""java.util.Stack"")"
"The Java Stack class actually implements the Java List interface, but you rarely use a Stack as a List - except perhaps if you need to inspect all elements currently stored on the stack.","(""Stack"", ""The Stack class implements the List interface."", ""List"")"
"Please note, that the Java Stack class is a subclass of Vector, an older Java class which is synchronized.","(""Stack"", ""The Stack class is a subclass of the Vector class, indicating an inheritance relationship."", ""Vector"")"
"Additionally, the Vector class uses several older (no longer recommended) parts of Java, like the Enumeration which is superseded by the Iterator interface.","(""Vector"", ""The Vector class uses the Enumeration class, indicating a relationship where Vector relies on Enumeration for certain functionalities."", ""Enumeration""); (""Enumeration"", ""The Enumeration class is superseded by the Iterator class, indicating a relationship where Iterator is the modern replacement for Enumeration."", ""Iterator""); (""Vector"", ""The Vector class is a part of the Java package, indicating a relationship where Vector is a component of Java."", ""Java"")"
To use a Java Stack you must first create an instance of the Stack class.,"(""Stack"", ""The text indicates that an instance of the Stack class needs to be created, suggesting a relationship between the concept of a Java Stack and the Stack class."", ""Stack"")"
You push elements onto a Java Stack using its push() method.,"(""Java Stack"", ""The push() method is used to add elements to the Java Stack class."", ""push()"")"
You pop an element off a Java Stack using the pop() method.,"(""Stack"", ""The pop method is used to remove an element from the Stack class."", ""pop"")"
Here is an example of popping an element off a Stack using the pop() method:,"(""Stack"", ""The pop method is used to remove an element from the Stack class."", ""pop"")"
"The Java Stack class has a method called peek() which enables you to see what the top element on the Stack is, without popping off the element.","(""Stack"", ""The method peek() is a function of the Stack class, allowing interaction with its elements."", ""peek()"")"
After running this Java example the topElement variable will contain the String object 1 which was pushed onto the Stack just before peek() was called.,"(""Stack"", ""The method peek() is called on the Stack class."", ""peek()"")"
The String object is still present on the Stack after calling peek().,"(""peek()"", ""The method peek() is called on the Stack class."", ""Stack""); (""String"", ""The String object is present on the Stack."", ""Stack"")"
"You can search for an object on the stack to get it's index, using the search() method.","(""SEARCH"", ""The term 'search()' is explicitly referred to as a method in the text."", ""METHOD"")"
The object's equals() method is called on every object on the Stack to determine if the searched-for object is present on the Stack.,"(""Equals"", ""The Equals method is used to determine if an object is present on the Stack class."", ""Stack"")"
"You can obtain the size of a Java Stack, meaning the number of elements currently stored on the Stack, via the Stack size() method.","(""Stack"", ""The size() method is used to obtain the number of elements currently stored in the Stack class."", ""size()"")"
Here is an example of obtaining the size of a Java Stack via its size() method:,"(""Stack"", ""The size() method is used to obtain the size of a Stack, indicating a functional relationship between the class and the method."", ""size()"")"
"After running this code the size variable will contain the value 3, since the Stack in the example contains 3 elements at the time its size() method is called.","(""Stack"", ""The size() method is called on the Stack class to determine the number of elements it contains."", ""size"")"
You do so by first obtaining a Stream from the Stack via the stream() method.,"(""Stack"", ""The stream() method is a function of the Stack class, used to obtain a Stream."", ""stream""); (""stream"", ""The stream() method is used to obtain a Stream object."", ""Stream"")"
"Notice, that this example uses a Java Lambda as parameter to the Stream.forEach() method.","(""Stream"", ""The forEach method is a member of the Stream class."", ""forEach""); (""Java Lambda"", ""Java Lambda is used as a parameter to the forEach method."", ""forEach"")"
The non-parallelizable part of the programs is 40% which out of a total time of 1 is equal to 0.4 .,NULL
The parallelizable part is thus equal to 1 - 0.4 = 0.6 .,NULL
"If B is 0.4, O is 2 and N is 5, then the calculation looks like this:",NULL
"With B = 0.4, O = 2 and N = 5, the calculation becomes:",NULL
"That means, that if you optimize the non-parallelizable (sequential) part by a factor of 2, and paralellize the parallelizable part by a factor of 5, the new optimized version of the program or algorithm would run a maximum of 2.77777 times faster than the old version.",NULL
Note: The content of this text is a part result of a M.Sc.,NULL
Once a thread want to notify the waiting threads it calls notifyAll() on the object the waiting threads called wait() on.,"(""NotifyAll"", ""NotifyAll is related to Wait because NotifyAll is called to notify all threads that are waiting, which have previously called Wait."", ""Wait"")"
Just have the notifying thread call notify() on the object the waiting threads have called wait() on.,"(""Notify"", ""Notify and Wait are related because Notify is called to wake up threads that are waiting, which have previously called Wait."", ""Wait"")"
"To achive this each waiting thread must call wait() on its own, separate object.","(""wait()"", ""The method wait() is called by each waiting thread."", ""thread"")"
When the notifying thread wants to notify a specific waiting thread it will call notify() on the object this specific thread has called wait() on.,"(""Notify"", ""The Notify method is used to wake up a thread that is waiting on the object's monitor, which was put to wait by the Wait method."", ""Wait"")"
The lockWrite() method of a ReadWriteLock class shown below is an example of a test-and-set method.,"(""LOCKWRITE"", ""The LOCKWRITE method is a part of the READWRITELOCK class."", ""READWRITELOCK"")"
Threads calling lockWrite() first sets the state before the test (writeRequests++).,"(""LockWrite"", ""LockWrite method sets the State before the test."", ""State""); (""LockWrite"", ""LockWrite method increments WriteRequests."", ""WriteRequests"")"
Then it tests the internal state against the access condition in the canGrantWriteAccess() method.,"(""Cangrantwriteaccess"", ""The method 'canGrantWriteAccess()' is mentioned in the text as being used to test the internal state against the access condition."", ""Cangrantwriteaccess"")"
The BoundedSemaphore class shown below has two test-and-set methods: take() and release().,"(""BoundedSemaphore"", ""The method 'take' is a test-and-set method of the 'BoundedSemaphore' class."", ""take""); (""BoundedSemaphore"", ""The method 'release' is a test-and-set method of the 'BoundedSemaphore' class."", ""release"")"
A typical example of a set method is the unlock() method of a Lock class.,"(""UNLOCK"", ""The UNLOCK method is a function that belongs to the LOCK class, indicating that it is used to perform an action related to the LOCK class."", ""LOCK"")"
Java 5 comes with blocking queue implementations in the java.util.concurrent package.,"(""Blocking Queue"", ""Blocking Queue is implemented in the java.util.concurrent package"", ""java.util.concurrent"")"
Notice how notifyAll() is only called from enqueue() and dequeue() if the queue size is equal to the size bounds (0 or limit).,"(""notifyAll"", ""The method notifyAll() is called from the method enqueue()."", ""enqueue""); (""notifyAll"", ""The method notifyAll() is called from the method dequeue()."", ""dequeue""); (""enqueue"", ""The method enqueue() is related to the class queue as it operates on it."", ""queue""); (""dequeue"", ""The method dequeue() is related to the class queue as it operates on it."", ""queue"")"
"If the queue size is not equal to either bound when enqueue() or dequeue() is called, there can be no threads waiting to either enqueue or dequeue items.","(""Enqueue"", ""Both methods are involved in the process of adding or removing items from the queue."", ""Dequeue"")"
"As you can see, the lock() method first checks if the locked member variable is equal to false (check), and if it is it ses locked to true (then act).","(""LOCK"", ""The lock() method first checks if the locked member variable is equal to false."", ""CHECK""); (""LOCK"", ""If the locked member variable is false, the lock() method sets it to true, which is an action."", ""ACT"")"
"If multiple threads had access to the same MyLock instance, the above lock() function would not be guaranteed to work.","(""MyLock"", ""The lock method is associated with the MyLock class, as it is mentioned in the context of accessing the MyLock instance."", ""lock"")"
Here is the code example from earlier with the lock() method turned into an atomic block of code using the synchronized keyword:,"(""LOCK"", ""The LOCK method is related to the SYNCHRONIZED keyword because the method is turned into an atomic block of code using this keyword."", ""SYNCHRONIZED"")"
Now the lock() method is synchronized so only one thread can executed it at a time on the same MyLock instance.,"(""Lock"", ""The Lock method is executed on an instance of the MyLock class, indicating a relationship between the method and the class."", ""MyLock"")"
"The atomic lock() method is actually an example of ""compare and swap"".","(""Lock"", ""The Lock method is an example of the Compare and Swap concept."", ""Compare and Swap"")"
"The lock() method compares the variable locked to the expected value false and if locked is equal to this expected value, it swaps the variable's value to true .","(""LOCK"", ""The lock() method interacts with the variable locked by comparing its value and potentially changing it."", ""LOCKED""); (""LOCK"", ""The lock() method compares the variable locked to the expected value false."", ""EXPECTED VALUE""); (""LOCK"", ""The lock() method swaps the variable's value to true if the condition is met."", ""TRUE"")"
From Java 5 you can get access to these functions in the CPU via some of the new atomic classes in the java.util.concurrent.atomic package.,"(""Atomic"", ""The Atomic class is part of the java.util.concurrent.atomic package"", ""Java.util.concurrent.atomic""); (""Java 5"", ""Java 5 introduced new atomic classes"", ""Atomic"")"
Here is an example showing how to implement the lock() method shown earlier using the AtomicBoolean class:,"(""LOCK"", ""The LOCK method is implemented using the ATOMICBOOLEAN class."", ""ATOMICBOOLEAN"")"
"This class has a compareAndSet() function which will compare the value of the AtomicBoolean instance to an expected value, and if has the expected value, it swaps the value with a new value.","(""CompareAndSet"", ""The CompareAndSet method is a function that operates on an instance of the AtomicBoolean class."", ""AtomicBoolean"")"
"The compareAndSet() method returns true if the value was swapped, and false if not.","(""compareAndSet"", ""The text explicitly mentions compareAndSet as a method."", ""method"")"
Many of the concurrency utilities in the java.util.concurrent Java package are designed for use with this model.,"(""Java"", ""The concurrency utilities are part of the Java package, specifically java.util.concurrent."", ""concurrency utilities"")"
Non-blocking IO means that when a worker starts an IO operation (e.g.,"(""Non-blocking IO"", ""Non-blocking IO is a class that involves performing IO operations without blocking the worker."", ""IO operation"")"
"When the IO operation finishes, the result of the IO operation ( e.g.",NULL
It just needs to know what channel to forward the job to (or send the message to etc.).,NULL
"The main disadvantage of the assembly line concurrency model is that the execution of a job is often spread out over multiple workers, and thus over multiple classes in your project.","(""ASSEMBLY LINE CONCURRENCY MODEL"", ""The assembly line concurrency model involves the execution of a job."", ""JOB""); (""JOB"", ""A job is executed by multiple workers in the assembly line concurrency model."", ""WORKERS""); (""WORKERS"", ""Workers are part of the project, as they execute jobs within it."", ""PROJECT""); (""ASSEMBLY LINE CONCURRENCY MODEL"", ""The assembly line concurrency model is implemented within a project."", ""PROJECT"")"
"Of course parallel worker code may also be spread over many different classes, but the execution sequence is often easier to read from the code.","(""Parallel Worker Code"", ""The execution sequence is often easier to read from the parallel worker code."", ""Execution Sequence"")"
With Java 7 we got the java.util.concurrent package contains the ForkAndJoinPool which can help you implement something similar to functional parallelism.,"(""java.util.concurrent"", ""The ForkAndJoinPool class is part of the java.util.concurrent package."", ""ForkAndJoinPool""); (""Java 7"", ""The java.util.concurrent package was introduced in Java 7."", ""java.util.concurrent"")"
"However, if the system is concurrently executing multiple other tasks (like e.g.",NULL
when a Java application is started its main() method is executed by the main thread - a special thread that is created by the Java VM to run your application.,"(""Java"", ""The main() method is a standard entry point for Java applications."", ""main()""); (""Java VM"", ""The Java VM executes the main() method when a Java application starts."", ""main()"")"
"Threads are instances of class java.lang.Thread, or instances of subclasses of this class.","(""Java.Lang.Thread"", ""Threads are instances of the class Java.Lang.Thread."", ""Java.Lang.Thread"")"
"To start the Java thread you will call its start() method, like this:","(""Thread"", ""The Start method is called on the Thread class to initiate the thread execution."", ""Start""); (""Java"", ""The Thread class is part of the Java package."", ""Thread"")"
The first is to create a subclass of Thread and override the run() method.,"(""Thread"", ""The run method is overridden in the subclass of the Thread class."", ""run"")"
The second method is to pass an object that implements Runnable (java.lang.Runnable to the Thread constructor.,"(""Runnable"", ""Runnable is part of the java.lang package"", ""java.lang""); (""Runnable"", ""Runnable is used as a parameter in the Thread constructor"", ""Thread""); (""Thread"", ""Thread is part of the java.lang package"", ""java.lang"")"
"The first way to specify what code a thread is to run, is to create a subclass of Thread and override the run() method.","(""Thread"", ""The run method is overridden in the Thread class to specify the code a thread should execute."", ""run"")"
The run() method is what is executed by the thread after you call start().,"(""Run"", ""The run() method is executed by the thread after the start() method is called."", ""Start"")"
The start() call will return as soon as the thread is started.,"(""START"", ""The method 'start()' is related to 'thread' as it initiates the thread's execution."", ""THREAD"")"
The run() method will execute as if executed by a different CPU.,"(""Run"", ""The run() method is executed as if by a different CPU, indicating a relationship between the method and the CPU."", ""CPU"")"
"When the run() method executes it will print out the text ""MyThread running"".","(""RUN"", ""The text mentions the run() method, indicating that 'run' is a method."", ""METHOD"")"
You can also create an anonymous subclass of Thread like this:,"(""Thread"", ""The text mentions creating an anonymous subclass of the class Thread."", ""subclass"")"
"This example will print out the text ""Thread running"" once the run() method is executed by the new thread.","(""Run"", ""The run() method is executed by the new thread, indicating a relationship between the method and the thread."", ""Thread"")"
The second way to specify what code a thread should run is by creating a class that implements the java.lang.Runnable interface.,"(""Thread"", ""The Thread class implements the Java.lang.Runnable interface, indicating a relationship where Thread uses Runnable to define its behavior."", ""Java.lang.Runnable""); (""Java.lang.Runnable"", ""The Java.lang.Runnable class is part of the Java.lang package, indicating a containment relationship."", ""Java.lang"")"
Whatever the thread is supposed to do when it executes must be included in the implementation of the run() method.,"(""RUN"", ""The run method is what the thread executes, indicating a functional relationship between the two."", ""THREAD"")"
The first way to implement the Java Runnable interface is by creating your own Java class that implements the Runnable interface.,"(""Java class"", ""The Java class implements the Runnable interface, indicating a relationship between the two entities."", ""Runnable""); (""Java"", ""The Java class is part of the Java package, showing a hierarchical relationship."", ""Java class"")"
Here is an example of a custom Java class that implements the Runnable interface:,"(""Java"", ""Java class implements the Runnable interface"", ""Runnable"")"
"After printing that text, the run() method exits, and the thread running the run() method will stop.","(""RUN"", ""The THREAD is executing the RUN method, indicating a direct relationship between the two."", ""THREAD"")"
Here is an example of an anonymous Java class that implements the Runnable interface:,"(""Java"", ""Java is an example of a class that implements the Runnable interface"", ""Runnable"")"
"Apart from being an anononymous class, this example is quite similar to the example that used a custom class to implement the Runnable interface.","(""Runnable"", ""class"")"
"To have the run() method executed by a thread, pass an instance of a class, anonymous class or lambda expression that implements the Runnable interface to a Thread in its constructor.","(""RUN"", ""The run() method is executed by a thread."", ""THREAD""); (""RUNNABLE"", ""An instance of a class implementing the Runnable interface is passed to a Thread."", ""THREAD"")"
When the thread is started it will call the run() method of the MyRunnable instance instead of executing it's own run() method.,"(""MYRUNNABLE"", ""The run() method is called on the MyRunnable instance when the thread is started."", ""RUN"")"
Sometimes you may have to implement Runnable as well as subclass Thread.,"(""Runnable"", ""Runnable is implemented and Thread is subclassed, indicating a relationship between these two classes in terms of inheritance and implementation."", ""Thread"")"
"For instance, if creating a subclass of Thread that can execute more than one Runnable.","(""Thread"", ""Thread is a class that can execute instances of the Runnable class"", ""Runnable"")"
"When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start(), like this:","(""Thread"", ""The run method is a function that can be called on a Thread class instance."", ""run""); (""Thread"", ""The start method is a function that can be called on a Thread class instance."", ""start"")"
At first you may not notice anything because the Runnable's run() method is executed like you expected.,"(""Runnable"", ""The run method is executed by the Runnable class."", ""run"")"
Instead the run() method is executed by the thread that created the thread.,"(""RUN"", ""The run() method is executed by the thread, indicating a relationship between the method and the thread."", ""THREAD""); (""THREAD"", ""The thread that created the thread suggests a relationship between two thread entities."", ""THREAD"")"
"To have the run() method of the MyRunnable instance called by the new created thread, newThread, you MUST call the newThread.start() method.","(""Run"", ""The run() method is a part of the MyRunnable class."", ""MyRunnable""); (""Start"", ""The start() method is called on the newThread instance."", ""NewThread"")"
"For instance, if multiple threads write to System.out it can be handy to see which thread wrote the text.","(""System.out"", ""System.out is used by threads to write text, indicating a relationship between the class and the threads."", ""thread"")"
"Notice however, that since the MyRunnable class is not a subclass of Thread, it does not have access to the getName() method of the thread executing it.","(""MyRunnable"", ""MyRunnable is mentioned as not being a subclass of Thread."", ""Thread""); (""getName"", ""getName is a method of the Thread class."", ""Thread"")"
The Thread.currentThread() method returns a reference to the Thread instance executing currentThread() .,"(""Thread"", ""The currentThread method is associated with the Thread class as it returns a reference to the Thread instance executing currentThread."", ""currentThread"")"
First it prints out the name of the thread executing the main() method.,"(""Main"", ""The main() method is executed by a thread, indicating a relationship between the method and the class."", ""Thread"")"
"Note that even if the threads are started in sequence (1, 2, 3 etc.)",NULL
"they may not execute sequentially, meaning thread 1 may not be the first thread to write its name to System.out.","(""System.out"", ""System.out is mentioned as the output stream where threads write their names."", ""System.out"")"
A thread can pause itself by calling the static method Thread.sleep() .,"(""Thread"", ""The method 'sleep' is a static method of the class 'Thread', allowing a thread to pause itself."", ""sleep"")"
The sleep() method will attempt to sleep that number of milliseconds before resuming execution.,"(""Sleep"", ""The term 'sleep()' is described as a method in the text."", ""Method"")"
"The Thread sleep() is not 100% precise, but it is pretty good still.","(""Thread"", ""The method sleep() is associated with the class Thread as it is a method used to pause the execution of a thread."", ""sleep"")"
Here is an example of pausing a Java thread for 3 seconds (3.000 millliseconds) by calling the Thread sleep() method:,"(""Thread"", ""The sleep method is called on the Thread class to pause its execution."", ""sleep"")"
"The thread executing the Java code above, will sleep for approximately 10 seconds (10.000 milliseconds).","(""Thread"", ""The Thread class is executing Java code, indicating a relationship between the two."", ""Java"")"
"The Java Thread class contains a stop() method, but it is deprecated.","(""Thread"", ""The stop() method is a member of the Thread class."", ""stop"")"
The original stop() method would not provide any guarantees about in what state the thread was stopped.,"(""Stop"", ""The term 'stop()' is directly referred to as a method in the text."", ""Method"")"
Instead of calling the stop() method you will have to implement your thread code so it can be stopped.,"(""Stop"", ""The text refers to 'stop()' as a method that can be called, indicating that 'Stop' is a method entity."", ""Method"")"
Here is an example of a class that implements Runnable which contains an extra method called doStop() which signals to the Runnable to stop.,"(""Runnable"", ""The method doStop() is part of the Runnable class, signaling it to stop."", ""doStop"")"
The doStop() is intended to be called from another thread than the thread executing the MyRunnable's run() method.,"(""doStop"", ""The doStop method is intended to be called from another thread than the thread executing the run method."", ""run""); (""run"", ""The run method is part of the MyRunnable class."", ""MyRunnable"")"
The keepRunning() method is called internally by the thread executing the MyRunnable's run() method.,"(""KeepRunning"", ""The KeepRunning method is called internally by the thread executing the Run method."", ""Run""); (""Run"", ""The Run method is part of the MyRunnable class."", ""MyRunnable"")"
As long as doStop() has not been called the keepRunning() method will return true - meaning the thread executing the run() method will keep running.,"(""doStop"", ""The doStop method affects the behavior of the keepRunning method by determining when it should return false."", ""keepRunning""); (""keepRunning"", ""The keepRunning method influences the execution of the run method by controlling whether the thread continues running."", ""run"")"
"Here is an example of starting a Java thread that executes an instance of the above MyRunnable class, and stopping it again after a delay:","(""MyRunnable"", ""The MyRunnable class is used to create an instance that is executed by the Java thread."", ""Java thread"")"
"Then the thread executing the main() method (the main thread) sleeps for 10 seconds, and then calls the doStop() method of the MyRunnable instance.","(""MAIN"", ""The MAIN method calls the DOSTOP method."", ""DOSTOP""); (""DOSTOP"", ""The DOSTOP method is a part of the MYRUNNABLE class."", ""MYRUNNABLE""); (""MAIN"", ""The MAIN method interacts with an instance of the MYRUNNABLE class."", ""MYRUNNABLE"")"
"This will cause the thread executing the MyRunnable method to stop, because the keepRunning() will return false after doStop() has been called.","(""MyRunnable"", ""The MyRunnable method is related to keepRunning because it is mentioned that the thread executing MyRunnable will stop when keepRunning returns false."", ""keepRunning""); (""keepRunning"", ""The keepRunning method is related to doStop because keepRunning will return false after doStop has been called."", ""doStop"")"
Please keep in mind that if your Runnable implementation needs more than just the run() method (e.g.,"(""Runnable"", ""The run method is a part of the Runnable class, as it is typically implemented when creating a Runnable."", ""run"")"
"a stop() or pause() method too), then you can no longer create your Runnable implementation with a Java lambda expression.","(""Runnable"", ""Runnable is a class that can be implemented using Java, which is a programming language package."", ""Java""); (""stop"", ""The stop method can be used within a Runnable implementation."", ""Runnable""); (""pause"", ""The pause method can be used within a Runnable implementation."", ""Runnable"")"
"Instead you must use a custom class, or a custom interface that extends Runnable which has the extra methods, and which is implemented by an anonymous class.","(""Runnable"", ""Runnable is a class that can have extra methods when extended by a custom interface."", ""methods""); (""Runnable"", ""Runnable is mentioned as a class that can be extended by a custom interface."", ""class"")"
You will have to create a custom lock class or use one of the Java 5 concurrency constructs in the java.util.concurrency package.,"(""Custom Lock"", ""The Custom Lock class can be implemented using constructs from the java.util.concurrency package."", ""Java.util.concurrency""); (""Java 5 Concurrency Constructs"", ""The Java 5 Concurrency Constructs are part of the java.util.concurrency package."", ""Java.util.concurrency"")"
"Every time a thread takes a lock it is noted in a data structure (map, graph etc.)","(""Thread"", ""A thread takes a lock, indicating a relationship where the thread interacts with the lock."", ""Lock""); (""Lock"", ""The lock is noted in a data structure, showing a relationship where the lock is recorded or managed within the data structure."", ""Data Structure"")"
Here is an example of a TreeNode class that call synchronized methods in different instances:,"(""TreeNode"", ""The TreeNode class calls synchronized methods."", ""synchronized"")"
"If a thread (1) calls the parent.addChild(child) method at the same time as another thread (2) calls the child.setParent(parent) method, on the same parent and child instances, a deadlock can occur.","(""ADDCHILD"", ""Both methods are called on the same parent and child instances, potentially causing a deadlock."", ""SET_PARENT"")"
Here is some pseudo code that illustrates this: Thread 1: parent.addChild(child); //locks parent --> child.setParentOnly(parent); Thread 2: child.setParent(parent); //locks child --> parent.addChildOnly() First thread 1 calls parent.addChild(child).,"(""parent"", ""The method addChild is called on parent with child as an argument, indicating a relationship between parent and child."", ""child""); (""child"", ""The method setParentOnly is called on child with parent as an argument, indicating a relationship between child and parent."", ""parent""); (""child"", ""The method setParent is called on child with parent as an argument, indicating a relationship between child and parent."", ""parent""); (""parent"", ""The method addChildOnly is called on parent, indicating a relationship between parent and child."", ""child"")"
Since addChild() is synchronized thread 1 effectively locks the parent object for access from other treads.,"(""addChild"", ""The method addChild is related to the parent object because it locks the parent object for access from other threads."", ""parent object"")"
Since setParent() is synchronized thread 2 effectively locks the child object for acces from other threads.,"(""setParent"", ""The method setParent is described as being synchronized, indicating a relationship where setParent is a synchronized method."", ""synchronized"")"
"Next thread 1 tries to call child.setParentOnly() method, but the child object is locked by thread 2, so the method call just blocks.","(""Child"", ""The method SetParentOnly is being called on the Child class."", ""SetParentOnly"")"
"Thread 2 also tries to call parent.addChildOnly() but the parent object is locked by thread 1, causing thread 2 to block on that method call.","(""Thread 2"", ""Thread 2 is trying to call the addChildOnly method."", ""addChildOnly""); (""parent"", ""The addChildOnly method is associated with the parent class."", ""addChildOnly""); (""Thread 1"", ""Thread 1 has locked the parent object, indicating a relationship between them."", ""parent""); (""Thread 2"", ""Thread 2 is blocked by Thread 1, indicating a relationship between them."", ""Thread 1"")"
"Note: The two threads must call parent.addChild(child) and child.setParent(parent) at the same time as described above, and on the same two parent and child instances for a deadlock to occur.","(""parent.addChild(child)"", ""Both methods need to be called simultaneously on the same parent and child instances to potentially cause a deadlock."", ""child.setParent(parent)""); (""parent"", ""The parent and child are related as they are involved in the method calls that need to be synchronized to avoid deadlock."", ""child"")"
Thread 1: parent.addChild(child); //locks parent --> child.setParentOnly(parent); Thread 2: child.setParent(parent); //locks child --> parent.addChildOnly() First thread 1 calls parent.addChild(child).,"(""Thread 1"", ""Thread 1 interacts with the parent class by calling methods on it."", ""parent""); (""Thread 1"", ""Thread 1 interacts with the child class by calling methods on it."", ""child""); (""Thread 2"", ""Thread 2 interacts with the child class by calling methods on it."", ""child""); (""Thread 2"", ""Thread 2 interacts with the parent class by calling methods on it."", ""parent""); (""parent"", ""The addChild method is called on the parent class."", ""addChild""); (""child"", ""The setParentOnly method is called on the child class."", ""setParentOnly""); (""child"", ""The setParent method is called on the child class."", ""setParent""); (""parent"", ""The addChildOnly method is called on the parent class."", ""addChildOnly"")"
By far the best book on the java.util.concurrent package in Java 5 and forward.,"(""Java.util.concurrent"", ""The Java.util.concurrent package is part of the Java class library, indicating a direct relationship between the package and the Java class."", ""Java"")"
"https://lmax-exchange.github.io/disruptor/ The LMAX Disrupter concurrent data structure (a single reader, single writer queue-like structure with high concurrency).","(""LMAX Disrupter"", ""The LMAX Disrupter is described as a concurrent data structure."", ""concurrent data structure"")"
In the following code example I have created an example of such a communication mechanism - a Java class called FrameExchanger.,"(""FrameExchanger"", ""FrameExchanger is a class implemented in the Java programming language."", ""Java"")"
It is not important how this class looks in order to understand how the FrameExchanger works.,"(""FrameExchanger"", ""FrameExchanger is mentioned as a class in the text."", ""class"")"
"The producing thread will call storeFrame() continuously, and the drawing thread will call takeFrame() continuously.","(""STOREFRAME"", ""Both methods are called continuously by different threads, indicating they are part of a process involving frame handling."", ""TAKEFRAME"")"
Notice how the three instructions inside the storeFrame() method seem like they do not depend on each other.,"(""storeFrame"", ""The text explicitly mentions storeFrame as a method."", ""method"")"
"That means, that if the drawing thread is waiting in the while-loop in the takeFrame() method, the drawing thread could exit that while-loop, and take the old Frame object.","(""TakeFrame"", ""The method TakeFrame is interacting with the Frame class by taking a Frame object."", ""Frame"")"
Notice that the first instruction is a read of a volatile variable (other.volatileVarC).,"(""volatileVarC"", ""volatileVarC is described as a volatile variable"", ""volatile"")"
"When other.volatileVarC is read in from main memory, the other.nonVolatileB and other.nonVolatileA are also read in from main memory.","(""volatileVarC"", ""volatileVarC and nonVolatileB are read together from main memory, indicating a relationship in their access pattern."", ""nonVolatileB""); (""volatileVarC"", ""volatileVarC and nonVolatileA are read together from main memory, indicating a relationship in their access pattern."", ""nonVolatileA"")"
"To illustrate why this guarantee is necessary, let us modify the FrameExchanger class from earlier in this tutorial to have the hasNewFrame variable be declared volatile:","(""FrameExchanger"", ""The hasNewFrame variable is a member of the FrameExchanger class, as it is being modified within the class."", ""hasNewFrame"")"
"Additionally, every time the drawing thread reads the hasNewFrame variable in the while-loop inside the takeFrame() method, the frame and framesStoredCount will also be refreshed from main memory.","(""Drawing Thread"", ""The drawing thread reads the hasNewFrame variable inside the takeFrame() method."", ""TakeFrame""); (""TakeFrame"", ""The hasNewFrame variable is read inside the takeFrame() method."", ""HasNewFrame""); (""TakeFrame"", ""The frame is refreshed inside the takeFrame() method."", ""Frame""); (""TakeFrame"", ""The framesStoredCount is refreshed inside the takeFrame() method."", ""FramesStoredCount""); (""Frame"", ""The frame is refreshed from main memory."", ""Main Memory""); (""FramesStoredCount"", ""The framesStoredCount is refreshed from main memory."", ""Main Memory"")"
"Imagine if the Java VM reordered the instructions inside the storeFrame() method, like this:","(""Java VM"", ""The storeFrame method is likely a method that can be executed or managed by the Java VM class."", ""storeFrame"")"
"This means, that the drawing thread executing the takeFrame() method may exit the while-loop before the new value is assigned to the frame variable.","(""takeFrame"", ""The takeFrame method is related to the frame variable as it is involved in assigning a new value to the frame variable."", ""frame"")"
"As you can see, the reordering of the instructions inside storeFrame() method may make the application malfunction.","(""storeFrame"", ""The term 'storeFrame' is followed by 'method', indicating that 'storeFrame' is a method."", ""method"")"
"In the case of the storeFrame() method that means that the two first write instructions cannot be reordered to happen after the last write to hasNewFrame, since hasNewFrame is a volatile variable.","(""storeFrame"", ""The storeFrame method involves operations on the hasNewFrame variable, indicating a direct interaction between the method and the variable."", ""hasNewFrame"")"
"This reordering does not break the code in the takeFrame() method, as the frame variable is still written to before the hasNewFrame variable is written to.","(""takeFrame"", ""The takeFrame method involves operations on the frame variable."", ""frame""); (""takeFrame"", ""The takeFrame method involves operations on the hasNewFrame variable."", ""hasNewFrame"")"
"Because of the volatile read visibility guarantee, when this.volatileVarA is read from main memory, so are all other variables visible to the thread at that time.","(""volatileVarA"", ""volatileVarA is read from main memory, indicating a relationship between the variable and the memory source"", ""main memory""); (""volatileVarA"", ""volatileVarA is visible to the thread, indicating a relationship between the variable and the thread"", ""thread"")"
"Thus, this.nonVolatileVarB and this.nonVolatileVarC are also read in from main memory at the same time.",NULL
"With regards to the takeFrame() method, the first read of a volatile variable is the read of the hasNewFrame field inside the while-loop.","(""takeFrame"", ""The takeFrame method reads the hasNewFrame field, indicating a relationship where the method utilizes the class field."", ""hasNewFrame"")"
Notice the two synchronized blocks inside the set() and get() method.,"(""Set"", ""Both are methods mentioned in the text and are likely related as they are part of the same context of synchronized blocks."", ""Get"")"
In the set() method the synchronized block at the end of the method will force all the variables to be synchronized to main memory after being updated.,"(""SET"", ""The set() is a method being described in the text."", ""METHOD"")"
In the get() method the synchronized block is placed at the beginning of the method.,"(""GET"", ""The text describes the 'get()' as a method, indicating its function within the code."", ""METHOD"")"
"When the thread calling get() enters the synchronized block, all variables are re-read in from main memory.","(""Get"", ""The method 'Get' is called within a synchronized block, indicating a relationship where 'Get' is executed in a thread-safe manner."", ""Synchronized Block"")"
"To illustrate why, I will use the get() method of the ValueExchanger shown earlier:","(""Get"", ""The Get method is used in the context of the ValueExchanger class, indicating that it is a method belonging to or interacting with this class."", ""ValueExchanger"")"
"As you can see, the synchronized block at the beginning of the method will guarantee that all of the variables this.valC, this.valB and this.valA are refreshed (read in) from main memory.","(""synchronized block"", ""The synchronized block ensures that the variable this.valC is refreshed from main memory."", ""this.valC""); (""synchronized block"", ""The synchronized block ensures that the variable this.valB is refreshed from main memory."", ""this.valB""); (""synchronized block"", ""The synchronized block ensures that the variable this.valA is refreshed from main memory."", ""this.valA"")"
"To illustrate why, I will use the set() method of the ValueExchanger shown earlier:","(""Set"", ""The set() method is a function that belongs to the ValueExchanger class, indicating a method-class relationship."", ""ValueExchanger"")"
"As you can see, the synchronized block at the end of the method will guarantee that all of the changed variables this.valA, this.valB and this.valC will be written back to (flushed) to main memory when the thread calling set() exits the synchronized blocks.","(""set"", ""The synchronized block is part of the method set, ensuring thread safety by writing variables back to main memory when the method exits."", ""synchronized block"")"
"The original Java memory model was insufficient, so the Java memory model was revised in Java 1.5.","(""Java Memory Model"", ""The Java Memory Model was revised in Java 1.5, indicating a relationship between the class and the package."", ""Java 1.5"")"
Static class variables are also stored on the heap along with the class definition.,"(""Static Class Variables"", ""Static class variables are stored on the heap."", ""Heap""); (""Static Class Variables"", ""Static class variables are stored along with the class definition."", ""Class Definition"")"
If two threads were executing the run() method then the diagram shown earlier would be the outcome.,"(""RUN"", ""The term 'run()' is identified as a method in the context of threading."", ""METHOD"")"
methodOne() declares a primitive local variable (localVariable1 of type int) and an local variable which is an object reference (localVariable2).,"(""methodOne"", ""methodOne declares a primitive local variable named localVariable1"", ""localVariable1""); (""methodOne"", ""methodOne declares a local variable which is an object reference named localVariable2"", ""localVariable2"")"
Each thread executing methodOne() will create its own copy of localVariable1 and localVariable2 on their respective thread stacks.,"(""methodOne"", ""localVariable1 is a local variable used within the methodOne method"", ""localVariable1""); (""methodOne"", ""localVariable2 is a local variable used within the methodOne method"", ""localVariable2"")"
Each thread executing methodOne() will also create their own copy of localVariable2.,"(""methodOne"", ""Each thread executing methodOne() creates its own copy of localVariable2, indicating a relationship where the method interacts with the class."", ""localVariable2"")"
The localVariable1 reference will be stored in one copy per thread executing methodTwo().,"(""methodTwo"", ""The localVariable1 reference is stored per thread executing methodTwo, indicating a relationship between the method and the variable."", ""localVariable1"")"
The Integer objects created inside methodTwo() correspond to Object 1 and Object 5 in the diagram above.,"(""methodTwo"", ""The method methodTwo() creates Integer objects."", ""Integer"")"
Notice also the two member variables in the class MySharedObject of type long which is a primitive type.,"(""MySharedObject"", ""The class MySharedObject contains member variables of type long, indicating a relationship between the class and the primitive type."", ""long"")"
That is why Java 5 got a whole set of concurrency utility classes to help developers implement more fine grained concurrency control than what you get with synchronized.,"(""Java 5"", ""Java 5 includes a set of concurrency utility classes to aid developers in implementing concurrency control."", ""concurrency utility classes"")"
Notice the use of the synchronized keyword in the add() method declaration.,"(""Add"", ""The 'add' method uses the 'synchronized' keyword, indicating a relationship where 'synchronized' is a modifier or characteristic of the 'add' method."", ""Synchronized"")"
Also here the synchronized keyword tells Java that the add() method is synchronized.,"(""Synchronized"", ""The synchronized keyword is used to indicate that the add() method is synchronized."", ""Add""); (""Java"", ""The add() method is a part of the Java package."", ""Add"")"
Synchronized static methods are synchronized on the class object of the class the synchronized static method belongs to.,"(""Synchronized Static Methods"", ""Synchronized static methods are synchronized on the class object of the class they belong to."", ""Class Object"")"
"Since only one class object exists in the Java VM per class, only one thread can execute inside a static synchronized method in the same class.","(""Class"", ""A static synchronized method is a type of method that belongs to a class."", ""Method""); (""Class"", ""A class object exists in the Java VM, indicating a relationship between the class and the Java VM."", ""Java VM"")"
"In case a class contains more than one static synchronized method, only one thread can execute inside any of these methods at the same time.","(""Class"", ""A class can contain multiple methods, including static synchronized methods."", ""Method""); (""Method"", ""Static synchronized methods within a class are related because only one thread can execute inside any of these methods at the same time."", ""Method"")"
Only one thread can execute inside any of the two add() and subtract() methods at any given time.,"(""Add"", ""Both methods are mentioned as being mutually exclusive in terms of execution by a single thread."", ""Subtract"")"
If Thread A is executing add() then Thread B cannot execute neither add() nor subtract() until Thread A has exited add().,"(""Thread A"", ""Thread A is executing the add() method."", ""add""); (""Thread B"", ""Thread B cannot execute the add() method while Thread A is executing it."", ""add""); (""Thread B"", ""Thread B cannot execute the subtract() method while Thread A is executing add()."", ""subtract"")"
"If the static synchronized methods are located in different classes, then one thread can execute inside the static synchronized methods of each class.","(""Static Synchronized Methods"", ""Static synchronized methods are located within classes, indicating a relationship where methods belong to classes."", ""Classes"")"
One thread per class regardless of which static synchronized method it calls.,"(""Class"", ""A class can have multiple methods, and the text refers to a static synchronized method being called by a class."", ""Method"")"
These methods are synchronized on the class object of the class the methods belong to:,"(""METHODS"", ""Methods are synchronized on the class object they belong to"", ""CLASS OBJECT"")"
"Had the second synchronized block been synchronized on a different object than MyClass.class, then one thread could execute inside each method at the same time.","(""MyClass"", ""The text implies that methods are associated with the MyClass class, as it discusses synchronization within methods of MyClass."", ""method"")"
It is even possible to use synchronized blocks inside a Java Lambda Expression as well as inside anonymous classes.,"(""Java Lambda Expression"", ""Both Java Lambda Expression and anonymous classes can contain synchronized blocks."", ""anonymous classes"")"
Notice that the synchronized block is synchronized on the class object of the class containing the lambda expression.,"(""Synchronized Block"", ""The synchronized block is synchronized on the class object."", ""Class Object""); (""Class Object"", ""The class object contains the lambda expression."", ""Lambda Expression"")"
"It could have been synchronized on another object too, if that would have made more sense (given a specific use case), but using the class object is fine for this example.","(""class"", ""class"")"
"Here are the two classes used in the example above, Counter and CounterThread.","(""Counter"", ""CounterThread is likely related to Counter as it may use or extend the functionality of the Counter class."", ""CounterThread"")"
"The Counter.add() method is synchronized on the instance, because the add method is an instance method, and marked as synchronized.","(""Counter"", ""The add method belongs to the Counter class."", ""add""); (""add"", ""The add method is synchronized, indicating a relationship with itself regarding thread safety."", ""add"")"
Therefore only one of the threads can call the add() method at a time.,"(""Threads"", ""The threads can call the add() method, indicating a relationship between the threads and the method."", ""Add"")"
"The other thread will wait until the first thread leaves the add() method, before it can execute the method itself.","(""Add"", ""The text describes the 'add()' as a method, indicating a relationship between the name 'Add' and the entity type 'Method'."", ""Method"")"
"If the two threads had referenced two separate Counter instances, there would have been no problems calling the add() methods simultaneously.","(""Counter"", ""The add method is likely a method of the Counter class, as it is mentioned in the context of calling methods on instances of Counter."", ""add"")"
Calling add() on counterA will thus not block a call to add() on counterB.,"(""add"", ""The method 'add' is called on the class 'counterA'."", ""counterA""); (""add"", ""The method 'add' is called on the class 'counterB'."", ""counterB"")"
Without the use of the synchronized keyword (or the Java volatile keyword) there is no guarantee that when one thread changes the value of a variable shared with other threads (e.g.,"(""Synchronized"", ""Both are Java keywords used for thread safety and memory consistency."", ""Volatile"")"
"If you call Integer.valueOf(1) multiple times, it might actually return the same wrapper object instance for the same input parameter values.","(""Integer"", ""The method 'valueOf' is a static method of the class 'Integer'."", ""valueOf"")"
"That means, that if you are synchronizing multiple blocks on the same primitive wrapper object (e.g.",NULL
"use Integer.valueOf(1) multiple times as monitor object), then you risk that those synchronized blocks all get synchronized on the same object.","(""Integer"", ""The method 'valueOf' is a static method of the class 'Integer'."", ""valueOf"")"
"To be on the safe side, synchronize on this - or on a new Object() .","(""synchronize"", ""The method 'synchronize' is used to lock the 'Object' to ensure thread safety."", ""Object"")"
Java actually comes with a built in ReadWriteLock class you can use.,"(""ReadWriteLock"", ""ReadWriteLock is a class that is part of the Java programming language."", ""Java"")"
Java actually comes with a built-in Java Semaphore class you can use.,"(""Java Semaphore"", ""The Java Semaphore class is part of the Java programming language."", ""Java"")"
Just focus on how inside the synchronized block inside the count() method calls the count() method recursively.,"(""Count"", ""The count() method is called recursively within itself."", ""Count"")"
"Thus, the thread calling count() may eventually enter the same synchronized block multiple times.","(""count"", ""The method 'count' is called by the 'thread'."", ""thread"")"
The Java ThreadLocal class enables you to create variables that can only be read and written by the same thread.,"(""ThreadLocal"", ""The ThreadLocal class is related to threads as it allows variables to be read and written by the same thread."", ""Thread"")"
"Thus, the Java ThreadLocal class provides a simple way to make code thread safe that would not otherwise be so.","(""ThreadLocal"", ""The ThreadLocal class is part of the Java programming language."", ""Java"")"
Once a ThreadLocal has been created you can set the value to be stored in it using its set() method.,"(""ThreadLocal"", ""The set method is used to store a value in the ThreadLocal class."", ""set"")"
You read the value stored in a ThreadLocal using its get() method.,"(""ThreadLocal"", ""The get() method is used to read the value stored in a ThreadLocal class."", ""get"")"
"Additionally, you do not have to typecast the value returned by get().","(""GET"", ""The text refers to 'get()' as a method that returns a value, indicating its function as a method."", ""METHOD"")"
It is possible to set an initial value for a Java ThreadLocal which will get used the first time get() is called - before set() has been called with a new value.,NULL
The first way to specify an initial value for a Java ThreadLocal variable is to create a subclass of ThreadLocal which overrides its initialValue() method.,"(""ThreadLocal"", ""The initialValue method is overridden in a subclass of the ThreadLocal class to specify an initial value for a ThreadLocal variable."", ""initialValue"")"
"The easiest way to create a subclass of ThreadLocal is to simply create an anonymous subclass, right where you create the ThreadLocal variable.","(""subclass"", ""A subclass is a specialized version of the ThreadLocal class."", ""ThreadLocal""); (""ThreadLocal"", ""ThreadLocal can have subclasses, which are derived from it."", ""subclass"")"
Here is an example of creating an anonymous subclass of ThreadLocal which overrides the initialValue() method:,"(""ThreadLocal"", ""The initialValue method is overridden in an anonymous subclass of the ThreadLocal class."", ""initialValue"")"
"Only if you return the exact same object from the initialValue() method, will all threads see the same object.","(""INITIALVALUE"", ""The text refers to the initialValue() as a method, indicating its role in returning an object."", ""METHOD"")"
"Here is an example of creating a ThreadLocal using its withInitial() static factory method, passing a simple Supplier implementation as parameter:","(""ThreadLocal"", ""The method withInitial is a static factory method used to create an instance of the class ThreadLocal."", ""withInitial""); (""withInitial"", ""The method withInitial takes a Supplier implementation as a parameter."", ""Supplier"")"
Here is how providing a Supplier implementation as a lambda expression to withInitial() looks:,"(""Supplier"", ""The Supplier class is used as an argument to the withInitial() method, indicating a functional relationship where Supplier provides the initial value."", ""withInitial"")"
Notice how the format() method calls the getThreadLocalSimpleDateFormat() method to obtain a Java SimpleDatFormat instance.,"(""FORMAT"", ""The format() method calls the getThreadLocalSimpleDateFormat() method."", ""GETTHREADLOCALSIMPLEDATEFORMAT""); (""GETTHREADLOCALSIMPLEDATEFORMAT"", ""The getThreadLocalSimpleDateFormat() method obtains a SimpleDatFormat instance."", ""SIMPLEDATFORMAT"")"
"The SimpleDateFormat class is not thread safe, so multiple threads cannot use it at the same time.","(""SimpleDateFormat"", ""The SimpleDateFormat class is not thread safe, indicating a relationship with threads."", ""thread"")"
"To solve this problem, the MyDateFormatter class above creates a SimpleDateFormat per thread, so each thread calling the format() method will use its own SimpleDateFormat instance.","(""MyDateFormatter"", ""The format method is a part of the MyDateFormatter class, as it is mentioned that each thread calling this method will use its own SimpleDateFormat instance."", ""format""); (""MyDateFormatter"", ""The MyDateFormatter class creates a SimpleDateFormat instance per thread, indicating a relationship where MyDateFormatter utilizes SimpleDateFormat."", ""SimpleDateFormat"")"
"Both threads execute the run() method, and thus sets different values on the ThreadLocal instance.","(""Run"", ""The run() method is executed by threads and interacts with the ThreadLocal instance to set different values."", ""ThreadLocal"")"
"If the access to the set() call had been synchronized, and it had not been a ThreadLocal object, the second thread would have overridden the value set by the first thread.","(""Set"", ""The method 'Set' is being discussed in the context of a 'ThreadLocal' object, indicating a relationship where 'Set' might be used or affected by 'ThreadLocal'."", ""ThreadLocal"")"
"The udpate() method writes three variables, of which only days is volatile.","(""Update"", ""The update() method writes to the days variable, indicating a direct interaction between them."", ""Days"")"
Notice the totalDays() method starts by reading the value of days into the total variable.,"(""totalDays"", ""The totalDays method reads the value of days into the total variable."", ""total"")"
Let us look at the MyClass class from the example earlier in this Java volatile tutorial:,"(""MyClass"", ""MyClass is a class mentioned in the context of a Java tutorial."", ""Java"")"
"Once the update() method writes a value to days, the newly written values to years and months are also written to main memory.","(""UPDATE"", ""The update() method writes a value to the days class."", ""DAYS""); (""UPDATE"", ""The update() method writes values to the years class."", ""YEARS""); (""UPDATE"", ""The update() method writes values to the months class."", ""MONTHS""); (""YEARS"", ""The newly written values to years are also written to main memory."", ""MAIN MEMORY""); (""MONTHS"", ""The newly written values to months are also written to main memory."", ""MAIN MEMORY"")"
As an alternative to a synchronized block you could also use one of the many atomic data types found in the java.util.concurrent package.,"(""Java.util.concurrent"", ""The atomic data types are found within the java.util.concurrent package."", ""Atomic data types"")"
"From Java 5 the package java.util.concurrent.locks contains several lock implementations, so you may not have to implement your own locks.","(""java.util.concurrent.locks"", ""The package java.util.concurrent.locks is part of the Java 5 release, indicating a direct relationship between the package and the version of Java."", ""Java 5"")"
"The Counter class could have been written like this instead, using a Lock instead of a synchronized block:","(""Counter"", ""The Counter class uses a Lock instead of a synchronized block, indicating a relationship where Lock is used within Counter."", ""Lock"")"
The lock() method locks the Lock instance so that all threads calling lock() are blocked until unlock() is executed.,"(""lock"", ""The lock() method is a function that operates on the Lock class to lock the instance."", ""Lock""); (""unlock"", ""The unlock() method is a function that operates on the Lock class to unlock the instance."", ""Lock""); (""lock"", ""The lock() method is related to the unlock() method as they are complementary operations on the Lock class."", ""unlock"")"
Spin locks and the methods wait() and notify() are covered in more detail in the text Thread Signaling.,"(""Spin Locks"", ""The method Wait is likely used within the context of Spin Locks for thread synchronization."", ""Wait""); (""Spin Locks"", ""The method Notify is likely used within the context of Spin Locks for thread synchronization."", ""Notify""); (""Wait"", ""The method Wait is discussed in the context of Thread Signaling, indicating its role in thread communication."", ""Thread Signaling""); (""Notify"", ""The method Notify is discussed in the context of Thread Signaling, indicating its role in thread communication."", ""Thread Signaling"")"
"While isLocked is true, the thread calling lock() is parked waiting in the wait() call.","(""lock"", ""The lock() method is related to the isLocked class because it checks the lock status."", ""isLocked""); (""wait"", ""The wait() method is related to the lock() method because it is used to park the thread while waiting for the lock."", ""lock"")"
"In case the thread should return unexpectedly from the wait() call without having received a notify() call (AKA a Spurious Wakeup) the thread re-checks the isLocked condition to see if it is safe to proceed or not, rather than just assume that being awakened means it is safe to proceed.","(""wait"", ""The wait() method is related to the notify() method as they are often used together in thread synchronization, where wait() pauses the thread until notify() is called."", ""notify""); (""wait"", ""The wait() method is related to the isLocked method because after a spurious wakeup, the thread checks the isLocked condition to determine if it should proceed."", ""isLocked""); (""notify"", ""The notify() method is related to the isLocked method because notify() is used to signal a change in state, which may involve checking the isLocked condition."", ""isLocked"")"
"If isLocked is false, the thread exits the while(isLocked) loop, and sets isLocked back to true, to lock the Lock instance for other threads calling lock().","(""isLocked"", ""The isLocked class is used in a loop condition to control the execution of the thread class."", ""thread""); (""lock"", ""The lock method is called on the Lock class instance to manage thread synchronization."", ""Lock"")"
"When the thread is done with the code in the critical section (the code between lock() and unlock()), the thread calls unlock().","(""Lock"", ""The methods Lock and Unlock are related as they are used to manage access to a critical section of code, with Lock being called before entering and Unlock after exiting."", ""Unlock"")"
"Executing unlock() sets isLocked back to false, and notifies (awakens) one of the threads waiting in the wait() call in the lock() method, if any.","(""UNLOCK"", ""The unlock() method sets the isLocked class back to false."", ""ISLOCKED""); (""UNLOCK"", ""The unlock() method notifies (awakens) one of the threads waiting in the wait() method."", ""WAIT""); (""WAIT"", ""The wait() method is called within the lock() method."", ""LOCK"")"
"Notice how both outer() and inner() are declared synchronized, which in Java is equivalent to a synchronized(this) block.","(""OUTER"", ""Both OUTER and INNER are methods declared as synchronized in the given Java context."", ""INNER"")"
"If a thread calls outer() there is no problem calling inner() from inside outer(), since both methods (or blocks) are synchronized on the same monitor object (""this"").","(""OUTER"", ""INNER is called from inside OUTER, indicating a direct relationship between the two methods."", ""INNER"")"
"However, even if synchronized blocks are reentrant, the Lock class shown earlier is not reentrant.","(""Lock"", ""The Lock class is mentioned in the context of synchronized blocks, indicating a relationship in terms of concurrency control."", ""synchronized blocks"")"
"If we rewrite the Reentrant class like below, the thread calling outer() will be blocked inside the lock.lock() in the inner() method.","(""Reentrant"", ""The method outer() is likely a part of the Reentrant class."", ""outer""); (""Reentrant"", ""The method inner() is likely a part of the Reentrant class."", ""inner""); (""inner"", ""The method inner() uses the lock class, as indicated by the lock.lock() call."", ""lock"")"
Inside the inner() method the thread will again try to lock the Lock instance.,"(""INNER"", ""The INNER method interacts with the LOCK class by attempting to lock an instance of it."", ""LOCK"")"
"This will fail (meaning the thread will be blocked), since the Lock instance was locked already in the outer() method.","(""outer"", ""The outer method is related to the Lock class because it involves locking an instance of Lock."", ""Lock""); (""Lock"", ""The Lock class is related to the outer method as it is used within this method to lock an instance."", ""outer"")"
"The reason the thread will be blocked the second time it calls lock() without having called unlock() in between, is apparent when we look at the lock() implementation:","(""Lock"", ""The Lock method is related to the Unlock method because calling Lock without calling Unlock in between can cause a thread to be blocked."", ""Unlock"")"
It is the condition inside the while loop (spin lock) that determines if a thread is allowed to exit the lock() method or not.,"(""Lock"", ""The spin lock is a condition inside the lock method that determines if a thread can exit."", ""Spin Lock"")"
To make the Lock class reentrant we need to make a small change:,"(""Lock"", ""The text discusses making the Lock class reentrant, indicating a relationship between the class and the concept of reentrancy."", ""reentrant"")"
"If either the lock is unlocked (isLocked = false) or the calling thread is the thread that locked the Lock instance, the while loop will not execute, and the thread calling lock() will be allowed to exit the method.","(""Lock"", ""The method 'lock' is associated with the 'Lock' class, as it is a common method used to control access to the Lock instance."", ""lock"")"
"Otherwise, a single call to unlock() will unlock the lock, even if the lock has been locked multiple times.","(""UNLOCK"", ""The method UNLOCK is used to unlock the LOCK class."", ""LOCK"")"
"We don't want the lock to be unlocked until the thread that locked it, has executed the same amount of unlock() calls as lock() calls.","(""LOCK"", ""The UNLOCK method is used to release the LOCK."", ""UNLOCK""); (""THREAD"", ""The THREAD interacts with the LOCK by calling the LOCK method."", ""LOCK""); (""THREAD"", ""The THREAD interacts with the LOCK by calling the UNLOCK method."", ""UNLOCK"")"
"When guarding a critical section with a Lock, and the critical section may throw exceptions, it is important to call the unlock() method from inside a finally-clause.","(""Lock"", ""The unlock method is used in conjunction with the Lock class to release the lock after a critical section is executed."", ""unlock"")"
"If unlock() was not called from inside a finally-clause, and an exception was thrown from the critical section, the Lock would remain locked forever, causing all threads calling lock() on that Lock instance to halt indefinately.","(""Unlock"", ""method""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class""); (""Lock"", ""class"")"
"If you click a button that starts a long task, and the thread executing the task is the thread updating the windows, buttons etc., then the application will appear unresponsive while the task executes.",NULL
"Imagine then, that one of the clients sends a request that takes a long time to process - e.g.",NULL
"Notice how the lock() method first synchronizes on ""this"", then synchronizes on the monitorObject member.","(""LOCK"", ""The lock method synchronizes on the monitorObject member, indicating a relationship where the method uses the class."", ""MONITOROBJECT"")"
"If isLocked is true however, the thread calling lock() is parked waiting in the monitorObject.wait() call.","(""lock"", ""The method lock() is related to the method wait() because the thread calling lock() is parked waiting in the monitorObject.wait() call."", ""wait""); (""monitorObject"", ""The class monitorObject is related to the method wait() because the wait() method is called on the monitorObject."", ""wait"")"
"The problem with this is, that the call to monitorObject.wait() only releases the synchronization monitor on the monitorObject member, and not the synchronization monitor associated with ""this"".","(""MonitorObject"", ""The method Wait is called on the class MonitorObject."", ""Wait"")"
When the thread that locked the Lock in the first place tries to unlock it by calling unlock() it will be blocked trying to enter the synchronized(this) block in the unlock() method.,"(""unlock"", ""The unlock method is related to the synchronized package because it involves entering a synchronized block."", ""synchronized""); (""Lock"", ""The Lock class is related to the unlock method because the method is used to unlock the Lock."", ""unlock"")"
It will remain blocked until the thread waiting in lock() leaves the synchronized(this) block.,"(""LOCK"", ""The LOCK method is related to the SYNCHRONIZED method as it involves waiting for a thread to leave the synchronized block."", ""SYNCHRONIZED"")"
"But the thread waiting in the lock() method will not leave that block until the isLocked is set to false, and a monitorObject.notify() is executed, as it happens in unlock().","(""Lock"", ""The Lock method is related to the IsLocked method because the thread waits in the Lock method until IsLocked is set to false."", ""IsLocked""); (""MonitorObject"", ""The MonitorObject class is related to the Notify method because the notify() method is executed on a MonitorObject."", ""Notify""); (""Lock"", ""The Lock method is related to the Unlock method because the unlock() method is responsible for setting conditions that allow the lock to be released."", ""Unlock"")"
"Put shortly, the thread waiting in lock() needs an unlock() call to execute successfully for it to exit lock() and the synchronized blocks inside it.","(""Lock"", ""The Lock method requires an Unlock call to allow the thread to exit the Lock method."", ""Unlock""); (""Lock"", ""The Lock method contains synchronized blocks inside it."", ""Synchronized Blocks"")"
"But, no thread can actually execute unlock() until the thread waiting in lock() leaves the outer synchronized block.","(""LOCK"", ""The UNLOCK method is related to the LOCK method as it cannot execute until the LOCK method's thread leaves the synchronized block."", ""UNLOCK"")"
This result is that any thread calling either lock() or unlock() will become blocked indefinately.,"(""lock"", ""Both methods are related as they are likely part of a synchronization mechanism, where lock() is used to acquire a lock and unlock() is used to release it."", ""unlock"")"
"That you would not call wait() and notify() on an internal monitor object, but rather on the This is probably true.",NULL
"When doing so you want each thread to call wait() on each their own queue object, so that you can notify the threads one at a time.","(""wait()"", ""The method 'notify' is used to wake up threads that are waiting by calling 'wait()'."", ""notify"")"
"At first glance this implementation may look fine, but notice how the lock() method calls queueObject.wait(); from inside two synchronized blocks.","(""Lock"", ""The Lock method calls the Wait method."", ""Wait""); (""QueueObject"", ""The Wait method is called on the QueueObject class."", ""Wait"")"
"When a thread calls queueObject.wait()it releases the lock on the QueueObject instance, but not the lock associated with ""this"".","(""QueueObject"", ""The method 'wait' is called on an instance of the class 'QueueObject'."", ""wait"")"
"Notice too, that the unlock() method is declared synchronized which equals a synchronized(this) block.","(""UNLOCK"", ""The UNLOCK method is declared as SYNCHRONIZED, indicating a relationship where the method is synchronized."", ""SYNCHRONIZED"")"
"This means, that if a thread is waiting inside lock() the monitor object associated with ""this"" will be locked by the waiting thread.","(""LOCK"", ""The method LOCK is used to lock the MONITOR OBJECT, which is associated with the current thread."", ""MONITOR OBJECT"")"
"All threads calling unlock() will remain blocked indefinately, waiting for the waiting thread to release the lock on ""this"".","(""UNLOCK"", ""The method UNLOCK is related to THIS because it involves releasing a lock on THIS."", ""THIS"")"
"But this will never happen, since this only happens if a thread succeeds in sending a signal to the waiting thread, and this can only be sent by executing the unlock() method.","(""UNLOCK"", ""The text mentions executing the unlock() method, indicating that UNLOCK is a method."", ""METHOD"")"
"For instance, the different implementations of the java.util.concurrent.BlockingQueue interface are all blocking data structures.","(""Java.util.concurrent.BlockingQueue"", ""The Java.util.concurrent.BlockingQueue is described as a type of blocking data structure."", ""Blocking data structures"")"
"Other threads will read the value of the volatile from main memory every time, instead of from e.g.",NULL
"Thus, this code may still lead to race conditions if performed by more than one thread: volatile myVar = 0; ... int temp = myVar; temp++; myVar = temp; First the value of the volatile variable myVar is read from main memory into a temp variable.","(""myVar"", ""The variable myVar is read into the temp variable, indicating a relationship where myVar's value is assigned to temp."", ""temp"")"
"If two threads execute this code and both of them read the value of myVar, add one to it and write the value back to main memory, then you risk that instead of 2 being added to the myVar variable, only 1 will be added (e.g.","(""myVar"", ""myVar is a variable whose value is read from and written back to main memory"", ""main memory"")"
"Here is a single writer counter which does not use synchronization but is still concurrent: public class SingleWriterCounter { private volatile long count = 0; /** * Only one thread may ever call this method, * or it will lead to race conditions.","(""SingleWriterCounter"", ""The method is part of the SingleWriterCounter class."", ""SingleWriterCounter"")"
"I mean, only the same, single thread is ever allowed to call inc().","(""INC"", ""The method INC is called by a single THREAD, indicating a relationship where the THREAD executes the method."", ""THREAD"")"
"Here is a simple double writer counter class that shows how that could look: public class DoubleWriterCounter { private volatile long countA = 0; private volatile long countB = 0; /** * Only one (and the same from thereon) thread may ever call this method, * or it will lead to race conditions.","(""DoubleWriterCounter"", ""countA is a method within the DoubleWriterCounter class."", ""countA""); (""DoubleWriterCounter"", ""countB is a method within the DoubleWriterCounter class."", ""countB"")"
"*/ public void incA() { this.countA++; } /** * Only one (and the same from thereon) thread may ever call this method, * or it will lead to race conditions.","(""INCA"", ""The text describes 'incA' as a method that can be called, indicating its function as a method."", ""METHOD"")"
"*/ public void incB() { this.countB++; } /** * Many reading threads may call this method */ public long countA() { return this.countA; } /** * Many reading threads may call this method */ public long countB() { return this.countB; } } As you can see, the DoubleWriterCounter now contains two volatile variables, and two pairs of incrementation and read methods.","(""incB"", ""The method 'incB' increments the variable 'countB'."", ""countB""); (""countA"", ""The method 'countA' returns the value of the variable 'countA'."", ""countA""); (""countB"", ""The method 'countB' returns the value of the variable 'countB'."", ""countB"")"
"Only a single thread may ever call incA(), and only a single thread may ever call incB().","(""incA"", ""Both incA and incB are methods that are called by a single thread."", ""incB"")"
This is how such exclusive access could look using a synchronized block in Java: public class SynchronizedCounter { long count = 0; public void inc() { synchronized(this) { count++; } } public long count() { synchronized(this) { return this.count; } } } Notice how the inc() and count() methods both contain a synchronized block.,"(""SynchronizedCounter"", ""The method 'inc' is a member of the class 'SynchronizedCounter'."", ""inc""); (""SynchronizedCounter"", ""The method 'count' is a member of the class 'SynchronizedCounter'."", ""count""); (""inc"", ""Both 'inc' and 'count' methods contain a synchronized block, indicating they are related in terms of thread safety operations within the 'SynchronizedCounter' class."", ""count"")"
This is what we want to avoid - synchronized blocks and wait() - notify() calls etc.,"(""Synchronized Blocks"", ""Synchronized Blocks and Wait are related as they are both methods used in thread synchronization."", ""Wait""); (""Synchronized Blocks"", ""Synchronized Blocks and Notify are related as they are both methods used in thread synchronization."", ""Notify""); (""Wait"", ""Wait and Notify are related as they are both methods used in thread synchronization."", ""Notify"")"
What is interesting about this version is the implementation of the inc() method.,"(""INC"", ""The text explicitly mentions the 'inc()' as a method."", ""METHOD"")"
"Instead it contains these lines: boolean updated = false; while(!updated){ long prevCount = this.count.get(); updated = this.count.compareAndSet(prevCount, prevCount + 1); } These lines are not an atomic operation.","(""COUNT"", ""The method COMPAREANDSET is called on the COUNT class to update its value."", ""COMPAREANDSET"")"
"That means, that it is possible for two different threads to call the inc() method and execute the long prevCount = this.count.get() statement, and thus both obtain the previous count for the counter.","(""Inc"", ""The text mentions the inc() method, indicating that 'Inc' is a method entity."", ""Method"")"
The compareAndSet() method is typically supported by compare-and-swap instructions directly in the CPU.,"(""compareAndSet"", ""The compareAndSet method is related to compare-and-swap instructions as it is typically supported by these instructions in the CPU."", ""compare-and-swap"")"
"Since compareAndSet() is an atomic operation, the threads will execute this method sequentially (one at a time).","(""compareAndSet"", ""The text describes compareAndSet() as a method, indicating its role in executing operations atomically."", ""method"")"
"If no other thread has called inc() in the meantime, the second iteration will succeed in updating the AtomicLong to 22.","(""INC"", ""The method INC is used to update the value of the class ATOMICLONG."", ""ATOMICLONG"")"
Instead Java provides the AtomicStampedReference class which can swap a reference and a stamp atomically using a compare-and-swap operation.,"(""AtomicStampedReference"", ""The AtomicStampedReference class uses the compare-and-swap operation to swap a reference and a stamp atomically."", ""compare-and-swap operation"")"
"import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicStampedReference; public class NonblockingTemplate { public static class IntendedModification { public AtomicBoolean completed = new AtomicBoolean(false); } private AtomicStampedReference<IntendedModification> ongoingMod = new AtomicStampedReference<IntendedModification>(null, 0); //declare the state of the data structure here.","(""NonblockingTemplate"", ""IntendedModification is a nested class within NonblockingTemplate."", ""IntendedModification""); (""IntendedModification"", ""completed is a method within the IntendedModification class."", ""completed""); (""NonblockingTemplate"", ""ongoingMod is a field within the NonblockingTemplate class, using AtomicStampedReference."", ""ongoingMod""); (""AtomicStampedReference"", ""AtomicStampedReference is used to reference IntendedModification."", ""IntendedModification"")"
"public void modify() { while(!attemptModifyASR()); } public boolean attemptModifyASR(){ boolean modified = false; IntendedModification currentlyOngoingMod = ongoingMod.getReference(); int stamp = ongoingMod.getStamp(); if(currentlyOngoingMod == null){ //copy data structure state - for use //in intended modification //prepare intended modification IntendedModification newMod = new IntendedModification(); boolean modSubmitted = ongoingMod.compareAndSet(null, newMod, stamp, stamp + 1); if(modSubmitted){ //complete modification via a series of compare-and-swap operations.","(""MODIFY"", ""The method MODIFY calls the method ATTEMPTMODIFYASR within its implementation."", ""ATTEMPTMODIFYASR""); (""ONGOINGMOD"", ""ONGOINGMOD is used to create a new instance of the INTENDEDMODIFICATION class and manage its state."", ""INTENDEDMODIFICATION"")"
"Multiple threads can access the same instance of this counter, as long as only one thread calls inc().","(""Counter"", ""The method Inc is called on an instance of the class Counter."", ""Inc"")"
Here is a simple double writer counter class that shows how that could look:,"(""Double Writer Counter"", ""The text describes 'Double Writer Counter' as a class, indicating its role in the context."", ""class"")"
Notice how the inc() and count() methods both contain a synchronized block.,"(""INC"", ""Both INC and COUNT are methods mentioned in the text that contain a synchronized block, indicating they are related by their functionality."", ""COUNT"")"
Here is how the same counter class could look using an AtomicLong instead:,"(""Counter"", ""The Counter class could be implemented using the AtomicLong class for atomic operations."", ""AtomicLong"")"
"The check-then-act pattern means, that two or more threads check a given condition, for instance if a Map contains a given value, and then go on to act based on that information, e.g.",NULL
"Imagine if two threads, A and B, are executing the add method on the same instance of the Counter class.","(""ADD"", ""The ADD method is being executed on an instance of the COUNTER class."", ""COUNTER"")"
The code in the add() method is not executed as a single atomic instruction by the Java virtual machine.,"(""Add"", ""The add() method is executed by the Java virtual machine."", ""Java Virtual Machine"")"
"Instead of 5, the value left in this.count will be the value written by the last thread to write its value.","(""this.count"", ""The value in this.count is determined by the last thread to write its value."", ""value"")"
The code in the add() method in the example earlier contains a critical section.,"(""Add"", ""The term 'add()' is explicitly referred to as a method in the text."", ""Method"")"
"If two or more threads call the checkThenAct() method on the same CheckThenActExample object, then two or more threads may execute the if-statement at the same time, evaluate sharedMap.containsKey(""key"") to true, and thus move into the body code block of the if-statement.","(""CheckThenActExample"", ""The method checkThenAct is called on the CheckThenActExample class."", ""checkThenAct"")"
Thread synchronization can also be achieved using other synchronization constructs like locks or atomic variables like java.util.concurrent.atomic.AtomicInteger.,"(""java.util.concurrent.atomic.AtomicInteger"", ""java.util.concurrent.atomic.AtomicInteger is an example of atomic variables used for synchronization"", ""atomic variables""); (""Thread synchronization"", ""Locks are used as a construct for achieving thread synchronization"", ""locks""); (""Thread synchronization"", ""Atomic variables are used as a construct for achieving thread synchronization"", ""atomic variables"")"
Notice how the add() method adds values to two different sum member variables.,"(""Add"", ""The Add method is responsible for adding values to the Sum member variables."", ""Sum"")"
Now two threads can execute the add() method at the same time.,"(""Threads"", ""The add() method can be executed by two threads at the same time, indicating a relationship between the threads and the method."", ""Add"")"
This way threads will have to wait less for each other to execute the add() method.,"(""Threads"", ""Threads need to wait for each other to execute the add() method, indicating a relationship between threads and the method."", ""Add"")"
Java 5 comes with read / write lock implementations in the java.util.concurrent package.,"(""read / write lock implementations"", ""The read / write lock implementations are part of the java.util.concurrent package."", ""java.util.concurrent"")"
The rules for read access are implemented in the lockRead() method.,"(""LOCKREAD"", ""The lockRead() method is responsible for implementing the rules for read access."", ""READ ACCESS"")"
The rules for write access are implemented in the lockWrite() method.,"(""LOCKWRITE"", ""The LOCKWRITE method is responsible for implementing the rules for WRITE ACCESS."", ""WRITE ACCESS"")"
It is worth noting that both unlockRead() and unlockWrite() calls notifyAll() rather than notify().,"(""UNLOCKREAD"", ""The method UNLOCKREAD calls the method NOTIFYALL."", ""NOTIFYALL""); (""UNLOCKWRITE"", ""The method UNLOCKWRITE calls the method NOTIFYALL."", ""NOTIFYALL"")"
"If a thread awakened by notify() was a read access thread, it would be put back to waiting because there are threads waiting for write access.","(""Notify"", ""The method Notify is used to awaken a thread."", ""Thread""); (""Thread"", ""The text discusses the interaction between threads, specifically read access and write access threads."", ""Thread"")"
By calling noftifyAll() all waiting threads are awakened and check if they can get the desired access.,"(""notifyAll"", ""The method notifyAll() is related to threads as it awakens all waiting threads."", ""threads"")"
"If multiple threads are waiting for read access and none for write access, and unlockWrite() is called, all threads waiting for read access are granted read access at once - not one by one.","(""UnlockWrite"", ""The method unlockWrite() is related to read access because it grants read access to all waiting threads when called."", ""read access""); (""UnlockWrite"", ""The method unlockWrite() is related to write access as it is called when there is no thread waiting for write access."", ""write access"")"
Here is how the lockRead() and unlockRead() methods looks after that change:,"(""LOCKREAD"", ""Both are methods mentioned in the context of a change."", ""UNLOCKREAD"")"
Here is how the lockWrite() and unlockWrite() methods look after that change:,"(""lockWrite"", ""Both are methods mentioned in the context of a change."", ""unlockWrite"")"
To achieve this the writeLock() method should be changed a bit.,"(""WriteLock"", ""The term 'writeLock()' is identified as a method due to its naming convention and context within the text."", ""method"")"
Here is how the canGrantReadAccess() method will look with that change:,"(""CanGrantReadAccess"", ""The text explicitly mentions 'canGrantReadAccess()' as a method."", ""method"")"
"When guarding a critical section with a ReadWriteLock, and the critical section may throw exceptions, it is important to call the readUnlock() and writeUnlock() methods from inside a finally-clause.","(""ReadWriteLock"", ""The readUnlock method is used in conjunction with the ReadWriteLock class to release a read lock."", ""readUnlock""); (""ReadWriteLock"", ""The writeUnlock method is used in conjunction with the ReadWriteLock class to release a write lock."", ""writeUnlock"")"
"If unlockWrite() was not called from inside a finally-clause, and an exception was thrown from the critical section, the ReadWriteLock would remain write locked forever, causing all threads calling lockRead() or lockWrite() on that ReadWriteLock instance to halt indefinately.","(""unlockWrite"", ""The method unlockWrite is mentioned in the context of being called from inside a finally-clause."", ""finally-clause""); (""exception"", ""An exception is mentioned as being thrown from the critical section."", ""critical section""); (""lockRead"", ""The method lockRead is called on the ReadWriteLock instance."", ""ReadWriteLock""); (""lockWrite"", ""The method lockWrite is called on the ReadWriteLock instance."", ""ReadWriteLock""); (""ReadWriteLock"", ""The ReadWriteLock is involved in the critical section as it remains write locked if an exception occurs."", ""critical section"")"
"The only thing that could unlock the ReadWriteLockagain would be if the ReadWriteLock is reentrant, and the thread that had it locked when the exception was thrown, later succeeds in locking it, executing the critical section and calling unlockWrite() again afterwards.","(""ReadWriteLock"", ""The method unlockWrite is related to the class ReadWriteLock as it is a method that operates on instances of this class to unlock the write lock."", ""unlockWrite"")"
Calling unlockWrite() from a finally-clause is a much more robust solution.,"(""finally-clause"", ""The method unlockWrite is called from within a finally-clause, indicating a relationship where the finally-clause is the context or location from which the method is invoked."", ""unlockWrite"")"
"If a thread calls lock() twice without calling unlock() in between, the second call to lock() will block.","(""Lock"", ""The methods Lock and Unlock are related because they are typically used together in threading to manage access to resources."", ""Unlock"")"
Java 5 comes with semaphore implementations in the java.util.concurrent package so you don't have to implement your own semaphores.,"(""semaphore"", ""The semaphore class is implemented within the java.util.concurrent package."", ""java.util.concurrent"")"
"You can read more about it in the java.util.concurrent.Semaphore text, in my java.util.concurrent tutorial.","(""Java.util.concurrent.Semaphore"", ""Java.util.concurrent.Semaphore is a class within the Java.util.concurrent package"", ""Java.util.concurrent"")"
The take() method sends a signal which is stored internally in the Semaphore.,"(""Take"", ""The take() method is associated with the Semaphore class as it sends a signal stored internally within it."", ""Semaphore"")"
"When received the signal flag is cleared again, and the release() method exited.","(""RELEASE"", ""The term 'release()' is followed by 'method', indicating that 'release' is a method."", ""METHOD"")"
You will call take() instead of notify() and release() instead of wait().,"(""take"", ""The method 'take' is related to 'notify' as it is called instead of 'notify'."", ""notify""); (""release"", ""The method 'release' is related to 'wait' as it is called instead of 'wait'."", ""wait"")"
"If the call to take() happens before the call to release() the thread calling release() will still know that take() was called, because the signal is stored internally in the signal variable.","(""take"", ""The methods take() and release() are related because the call to take() must happen before the call to release()."", ""release""); (""release"", ""The method release() is related to the signal variable because the signal is stored internally when release() is called."", ""signal""); (""take"", ""The method take() is related to the signal variable because the signal is stored internally when take() is called."", ""signal"")"
The names take() and release() may seem a bit odd when using a semaphore for signaling.,"(""TAKE"", ""The method TAKE is used in the context of a SEMAPHORE for signaling."", ""SEMAPHORE""); (""RELEASE"", ""The method RELEASE is used in the context of a SEMAPHORE for signaling."", ""SEMAPHORE"")"
The Semaphore implementation in the previous section does not count the number of signals sent to it by take() method calls.,"(""Semaphore"", ""The take() method is used to send signals to the Semaphore class."", ""take"")"
Notice how the take() method now blocks if the number of signals is equal to the upper bound.,"(""Take"", ""The take() method blocks if the number of signals is equal to the upper bound, indicating a dependency or condition between the method and the upper bound."", ""Upper Bound"")"
"Not until a thread has called release() will the thread calling take() be allowed to deliver its signal, if the BoundedSemaphore has reached its upper signal limit.","(""RELEASE"", ""The methods RELEASE and TAKE are related as they are both involved in the signaling mechanism of a thread."", ""TAKE""); (""BOUNDEDSEMAPHORE"", ""The method RELEASE is associated with the BOUNDEDSEMAPHORE class as it is used to manage the semaphore's signal limit."", ""RELEASE""); (""BOUNDEDSEMAPHORE"", ""The method TAKE is associated with the BOUNDEDSEMAPHORE class as it is used to manage the semaphore's signal limit."", ""TAKE"")"
"To do so, set the upper bound to 1, and have the call to take() and release() guard the critical section.","(""take"", ""Both methods are used to guard the critical section, indicating they are related in managing access to shared resources."", ""release"")"
In contrast to the signaling use case the methods take() and release() are now called by the same thread.,"(""TAKE"", ""Both methods are called by the same thread, indicating a sequential or related operation."", ""RELEASE"")"
"Since only one thread is allowed to take the semaphore, all other threads calling take() will be blocked until release() is called.","(""Take"", ""The methods 'take' and 'release' are related because 'take' blocks threads until 'release' is called."", ""Release"")"
The call to release() will never block since there has always been a call to take() first.,"(""RELEASE"", ""The method RELEASE is related to the method TAKE because the text indicates that RELEASE is called after TAKE."", ""TAKE"")"
The relase() method is called from inside a finally-block to make sure it is called even if an exception is thrown from the critical section.,"(""Release"", ""The Release method is called from inside a finally-block to ensure it executes even if an exception occurs."", ""Finally-block"")"
In a classic multi-threaded architecture you will typically assign each task to a separate thread for execution.,NULL
A classic multi-threaded architecture can also sometimes lead to congestion when multiple threads try to access the same data structure at the same time.,NULL
The alternative to a classic multithreaded architecture is a single-threaded or same-threaded.,NULL
"This kind of thread loop is both used in server applications (web services, services etc.)","(""Thread Loop"", ""Thread Loop is used in server applications for handling tasks in web services and other services."", ""Server Applications"")"
"For instance, the task executor could keep the tasks in different lists internally, and e.g.",NULL
"If a one-off task is waiting for some asynchronous operation to finish, e.g.",NULL
"Imagine that isLocked is false, and two threads call lock() at the same time.","(""isLocked"", ""The method lock() is likely related to the class isLocked as it suggests a locking mechanism that might change the state of isLocked."", ""lock"")"
"Notice how the synchronized(queueObject) with its queueObject.wait() call is nested inside the synchronized(this) block, resulting in the nested monitor lockout problem.","(""Synchronized"", ""The synchronized method is used with the QueueObject class to manage access to the queue."", ""QueueObject""); (""QueueObject"", ""The wait method is called on the QueueObject class to pause the thread until a condition is met."", ""Wait""); (""Synchronized"", ""The synchronized method is used with the This class to ensure that the block of code is accessed by only one thread at a time."", ""This""); (""Synchronized"", ""The wait method is nested inside the synchronized block, indicating a relationship where wait is used within a synchronized context."", ""Wait"")"
"Note: Only the lock() method is shown, since it is the only method I have changed.","(""LOCK"", ""The text explicitly mentions that lock() is a method."", ""METHOD"")"
The first synchronized(this) block checks the condition by setting mustWait = isLocked || waitingThreads.get(0) != queueObject.,"(""synchronized"", ""The synchronized block is a method that operates on the 'this' class instance."", ""this""); (""mustWait"", ""The variable 'mustWait' is set based on the value of 'isLocked'."", ""isLocked""); (""mustWait"", ""The variable 'mustWait' is set based on the value of 'waitingThreads'."", ""waitingThreads""); (""waitingThreads"", ""The 'get' method is called on the 'waitingThreads' variable."", ""get""); (""get"", ""The 'get' method checks if the first element is not equal to 'queueObject'."", ""queueObject"")"
Imagine what will happen if two threads call lock() at the same time when the lock is unlocked.,"(""THREADS"", ""The THREADS call the LOCK method."", ""LOCK"")"
Imagine that the FairLock instance is locked when a thread calls lock().,"(""FairLock"", ""The method lock() is called on an instance of the FairLock class, indicating a relationship where lock() is a method of the FairLock class."", ""lock"")"
"Then imagine that the thread calling lock() is preempted, and the thread that locked the lock calls unlock().","(""lock"", ""The lock method is related to the unlock method as they are typically used together to manage access to a shared resource in a multithreading context."", ""unlock"")"
"If you look at the unlock() implementation shown earlier, you will notice that it calls queueObject.notify().","(""UNLOCK"", ""The method UNLOCK calls the method NOTIFY."", ""NOTIFY""); (""NOTIFY"", ""The method NOTIFY is called on the class QUEUEOBJECT."", ""QUEUEOBJECT"")"
"But, since the thread waiting in lock() has not yet called queueObject.wait(), the call to queueObject.notify() passes into oblivion.","(""lock"", ""The method lock is related to queueObject.wait because the thread is waiting in lock before calling queueObject.wait."", ""queueObject.wait""); (""queueObject.wait"", ""The method queueObject.wait is related to queueObject.notify because queueObject.notify is intended to signal or notify the waiting thread in queueObject.wait."", ""queueObject.notify"")"
"When the thread calling lock() right after calls queueObject.wait() it will remain blocked until some other thread calls unlock(), which may never happen.","(""Lock"", ""The method Lock is called on the QueueObject class."", ""QueueObject""); (""Wait"", ""The method Wait is called on the QueueObject class."", ""QueueObject""); (""Unlock"", ""The method Unlock is called on the QueueObject class."", ""QueueObject"")"
The missed signals problems is the reason that the FairLock implementation shown in the text Starvation and Fairness has turned the QueueObject class into a semaphore with two methods: doWait() and doNotify().,"(""QueueObject"", ""The method doWait() is part of the QueueObject class."", ""doWait""); (""QueueObject"", ""The method doNotify() is part of the QueueObject class."", ""doNotify""); (""FairLock"", ""The FairLock class uses the QueueObject class as a semaphore in its implementation."", ""QueueObject"")"
"That way the signal is not missed, even if doNotify() is called before doWait().","(""doNotify"", ""doNotify and doWait are related because they are both methods that likely interact in a signaling mechanism."", ""doWait"")"
The notify() method makes no guarantee about what thread is awakened if multiple thread have called wait() on the object notify() is called on.,"(""Notify"", ""The Notify method is related to the Wait method because Notify is used to awaken a thread that has called Wait on the object."", ""Wait"")"
"If more than one thread call the doSynchronized() method, some of them will be blocked until the first thread granted access has left the method.","(""doSynchronized"", ""The doSynchronized is a method that can be called by multiple threads."", ""method"")"
Instead the critical section is guarded by the lock.lock() and lock.unlock() calls.,"(""lock"", ""The method lock.lock() is a method call on the lock class, indicating that it is a method belonging to or associated with the lock class."", ""lock.lock()""); (""lock"", ""The method lock.unlock() is a method call on the lock class, indicating that it is a method belonging to or associated with the lock class."", ""lock.unlock()"")"
A simple implementation of the Lock class could look like this:,"(""Lock"", ""class"")"
"If you look at the Synchronizer class above and look into this Lock implementation you will notice that threads are now blocked trying to access the lock() method, if more than one thread calls lock() simultanously.","(""Synchronizer"", ""The lock() method is part of the Synchronizer class, as it is mentioned in the context of the Synchronizer class."", ""lock""); (""Lock"", ""The lock() method is part of the Lock class implementation, as it is mentioned in the context of this Lock implementation."", ""lock"")"
"Second, if the lock is locked, the threads are blocked in the wait() call inside the while(isLocked) loop in the lock() method.","(""Lock"", ""The Wait method is called when the Lock is locked, causing threads to be blocked."", ""Wait""); (""Lock"", ""The IsLocked method is used within the Lock method to check the lock status."", ""IsLocked""); (""Lock"", ""The Lock method is part of the Lock class, managing the locking mechanism."", ""Lock"")"
"Remember that a thread calling wait() releases the synchronization lock on the Lock instance, so threads waiting to enter lock() can now do so.","(""Thread"", ""The method wait() is called by a thread, indicating a relationship where the thread uses the wait method."", ""Wait""); (""Lock"", ""The method lock() is associated with the Lock class, indicating that lock() is a method of the Lock class."", ""Lock""); (""Thread"", ""A thread interacts with the Lock class by releasing the synchronization lock, indicating a relationship between the thread and the Lock class."", ""Lock"")"
The result is that multiple threads can end up having called wait() inside lock().,"(""Wait"", ""The method Wait is called inside the class Lock, indicating a functional relationship where Wait is used within Lock."", ""Lock"")"
"If you look back at the doSynchronized() method you will notice that the comment between lock() and unlock() states, that the code in between these two calls take a ""long"" time to execute.","(""doSynchronized"", ""The doSynchronized method likely calls the lock method as part of its execution process."", ""lock""); (""doSynchronized"", ""The doSynchronized method likely calls the unlock method as part of its execution process."", ""unlock""); (""lock"", ""The lock and unlock methods are related as they are used in conjunction to manage synchronization, with lock being called before unlock."", ""unlock"")"
Let us further assume that this code takes long time to execute compared to entering the lock() method and calling wait() because the lock is locked.,"(""LOCK"", ""The LOCK method is related to the WAIT method as both are involved in synchronization, where LOCK is used to acquire a lock and WAIT is used to pause execution until a condition is met."", ""WAIT"")"
"This means that the majority of the time waited to be able to lock the lock and enter the critical section is spent waiting in the wait() call inside the lock() method, not being blocked trying to enter the lock() method.","(""WAIT"", ""The WAIT method is called inside the LOCK method, indicating a direct relationship where WAIT is used within LOCK."", ""LOCK""); (""LOCK"", ""The LOCK method is mentioned in the context of entering a critical section, suggesting its role in managing access to shared resources."", ""LOCK"")"
Nor does wait() make any guarantees about what thread is awakened when notify() is called.,"(""WAIT"", ""The methods WAIT and NOTIFY are related as they are often used together in thread synchronization, where WAIT pauses a thread and NOTIFY awakens it."", ""NOTIFY"")"
"So, the current version of the Lock class makes no different guarantees with respect to fairness than synchronized version of doSynchronized().","(""Lock"", ""The Lock class is compared to the synchronized version of the doSynchronized() method in terms of fairness guarantees."", ""doSynchronized"")"
The current version of the Lock class calls its own wait() method.,"(""Lock"", ""The wait method is called by the Lock class."", ""wait"")"
"If instead each thread calls wait() on a separate object, so that only one thread has called wait() on each object, the Lock class can decide which of these objects to call notify() on, thereby effectively selecting exactly what thread to awaken.","(""Lock"", ""The Lock class is related to the wait() method as it is mentioned in the context of threads calling wait() on objects managed by the Lock class."", ""wait()""); (""Lock"", ""The Lock class is related to the notify() method as it is responsible for deciding which object to call notify() on."", ""notify()""); (""wait()"", ""The wait() and notify() methods are related as they are both part of the mechanism for managing thread synchronization."", ""notify()"")"
Below is shown the previous Lock class turned into a fair lock called FairLock.,"(""Lock"", ""The FairLock class is a modified version of the Lock class, indicating a direct relationship between the two classes."", ""FairLock"")"
You will notice that the implementation has changed a bit with respect to synchronization and wait() / notify() compared to the Lock class shown earlier.,"(""Lock"", ""The method wait() is typically used in synchronization contexts, which is relevant to the Lock class."", ""wait()""); (""Lock"", ""The method notify() is often used alongside wait() in synchronization, which is relevant to the Lock class."", ""notify()"")"
"Exactly how I arrived at this design beginning from the previous Lock class is a longer story involving several incremental design steps, each fixing the problem of the previous step: Nested Monitor Lockout, Slipped Conditions, and Missed Signals.","(""Lock"", ""The Lock class is related to Nested Monitor Lockout as it is mentioned as part of the design steps to fix this problem."", ""Nested Monitor Lockout""); (""Lock"", ""The Lock class is related to Slipped Conditions as it is mentioned as part of the design steps to fix this problem."", ""Slipped Conditions""); (""Lock"", ""The Lock class is related to Missed Signals as it is mentioned as part of the design steps to fix this problem."", ""Missed Signals"")"
"What is important is, that every thread calling lock() is now queued, and only the first thread in the queue is allowed to lock the FairLock instance, if it is unlocked.","(""LOCK"", ""The method LOCK is used to control access to the FAIRLOCK class, ensuring that threads are queued and only the first in line can proceed when the FAIRLOCK instance is unlocked."", ""FAIRLOCK"")"
First you might notice that the lock() method is no longer declared synchronized.,"(""LOCK"", ""The lock() method is mentioned in the context of not being declared synchronized, indicating a relationship between the method and the synchronized keyword."", ""SYNCHRONIZED"")"
FairLock creates a new instance of QueueObject and enqueue it for each thread calling lock().,"(""FairLock"", ""FairLock creates a new instance of QueueObject."", ""QueueObject""); (""FairLock"", ""FairLock enqueues QueueObject for each thread calling lock()."", ""lock()"")"
"The thread calling unlock() will take the top QueueObject in the queue and call doNotify() on it, to awaken the thread waiting on that object.","(""Unlock"", ""The method Unlock interacts with the QueueObject by taking the top object from the queue."", ""QueueObject""); (""Unlock"", ""The method Unlock calls the method DoNotify to awaken the thread."", ""DoNotify""); (""QueueObject"", ""The method DoNotify is called on the QueueObject to awaken the thread waiting on it."", ""DoNotify"")"
The doWait() and doNotify() methods store the signal internally in the QueueObject.,"(""doWait"", ""The doWait method interacts with the QueueObject by storing the signal internally."", ""QueueObject""); (""doNotify"", ""The doNotify method interacts with the QueueObject by storing the signal internally."", ""QueueObject"")"
"This is done to avoid missed signals caused by a thread being preempted just before calling queueObject.doWait(), by another thread which calls unlock() and thereby queueObject.doNotify().","(""QueueObject"", ""The method DoWait is called on the class QueueObject."", ""DoWait""); (""QueueObject"", ""The method DoNotify is called on the class QueueObject."", ""DoNotify""); (""Unlock"", ""The method Unlock is related to DoNotify as it is mentioned in the context of thread operations."", ""DoNotify"")"
"The queueObject.doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout, so another thread can actually call unlock() when no thread is executing inside the synchronized(this) block in lock() method.","(""QueueObject"", ""The method DoWait is called on the QueueObject class."", ""DoWait""); (""QueueObject"", ""The method Unlock can be called on the QueueObject class."", ""Unlock""); (""QueueObject"", ""The method Lock is associated with the QueueObject class."", ""Lock""); (""Lock"", ""The DoWait method is mentioned in the context of the Lock method."", ""DoWait""); (""Lock"", ""The Unlock method is mentioned in the context of the Lock method."", ""Unlock"")"
"Finally, notice how the queueObject.doWait() is called inside a try - catch block.","(""queueObject"", ""The method doWait is called on the class queueObject, indicating a relationship where doWait is a method belonging to or used by queueObject."", ""doWait"")"
"In case an InterruptedException is thrown the thread leaves the lock() method, and we need to dequeue it.","(""InterruptedException"", ""The InterruptedException class is related to the lock method because it is mentioned that the exception is thrown when the thread leaves the lock method."", ""lock"")"
If you compare the Lock and FairLock classes you will notice that there is somewhat more going on inside the lock() and unlock() in the FairLock class.,"(""FairLock"", ""The method lock() is part of the FairLock class."", ""lock""); (""FairLock"", ""The method unlock() is part of the FairLock class."", ""unlock""); (""Lock"", ""Both are classes being compared in the context."", ""FairLock"")"
Threads waiting on an object (called wait() on it) remain waiting indefinitely,"(""Threads"", ""The method wait() is called on the Threads class, indicating a relationship where Threads can invoke the wait() method."", ""wait()"")"
"In a desktop app the foreground thread (UI thread) could be responding to the user events - a.g. opening a file, or downloading a file, or saving a file etc.",NULL
"Each thread consumes a certain amount of computer resources, such as memory (RAM), so if you have too many threads active at the same time, the total amount of resources (e.g.","(""Thread"", ""A thread consumes memory resources, indicating a relationship between the two entities."", ""Memory"")"
RAM) that is consumed may cause the computer to slow down - e.g.,NULL
"Java comes with built in thread pools in the java.util.concurrent package, so you don't have to implement your own thread pool.","(""Java.Util.Concurrent"", ""The Java.Util.Concurrent package provides built-in thread pools."", ""Thread Pools"")"
You can read more about it in my text on the java.util.concurrent.ExecutorService.,"(""ExecutorService"", ""ExecutorService is a class within the java.util.concurrent package"", ""java.util.concurrent"")"
"Below here is the PoolThreadRunnable class which implements the Runnable interface, so it can be executed by a Java thread:","(""PoolThreadRunnable"", ""PoolThreadRunnable implements the Runnable interface, indicating a relationship where PoolThreadRunnable is a type of Runnable."", ""Runnable"")"
"A ThreadPool class which is the public interface to the thread pool, and a PoolThread class which implements the threads that execute the tasks.","(""ThreadPool"", ""The ThreadPool class is the public interface to the thread pool, which likely manages or utilizes PoolThread instances to execute tasks."", ""PoolThread"")"
To execute a task the method ThreadPool.execute(Runnable r) is called with a Runnable implementation as parameter.,"(""ThreadPool"", ""The method 'execute' is a function of the 'ThreadPool' class."", ""execute""); (""execute"", ""The 'execute' method takes a 'Runnable' implementation as a parameter."", ""Runnable"")"
Then each thread in the pool is stopped by calling doStop() on each thread.,"(""doStop"", ""The method doStop is called on each thread to stop it."", ""thread"")"
Notice how the execute() method will throw an IllegalStateException if execute() is called after stop() has been called.,"(""Execute"", ""The Execute method will throw an IllegalStateException if it is called after the Stop method has been called."", ""IllegalStateException""); (""Execute"", ""The Execute method is related to the Stop method because calling Execute after Stop leads to an IllegalStateException."", ""Stop"")"
"This makes sure that a thread blocked in a wait() call inside the taskQueue.dequeue() call breaks out of the wait() call, and leaves the dequeue() method call with an InterruptedException thrown.","(""Thread"", ""A thread can be blocked in a wait() call."", ""Wait""); (""TaskQueue"", ""The dequeue() method is called on the taskQueue object."", ""Dequeue""); (""Dequeue"", ""The dequeue() method call can throw an InterruptedException."", ""InterruptedException"")"
"This exception is caught in the PoolThread.run() method, reported, and then the isStopped variable is checked.","(""PoolThread"", ""The run method is a part of the PoolThread class, as indicated by the PoolThread.run() notation."", ""run""); (""run"", ""The run method checks the isStopped variable, indicating a relationship between the method and the variable."", ""isStopped"")"
"Since isStopped is now true, the PoolThread.run() will exit and the thread dies.","(""PoolThread"", ""The method run() is a part of the PoolThread class, as indicated by the notation PoolThread.run()."", ""run""); (""isStopped"", ""The class isStopped is related to PoolThread as it influences the behavior of the PoolThread.run() method."", ""PoolThread"")"
"Notice how the add() method returns a new ImmutableValue instance with the result of the add operation, rather than adding the value to itself.","(""Add"", ""The Add method returns a new instance of the ImmutableValue class."", ""ImmutableValue"")"
Notice how it is possible to change that reference through both the setValue() and add() methods.,"(""SETVALUE"", ""Both are methods that can change a reference."", ""ADD"")"
"Therefore, even if the Calculator class uses an immutable object internally, it is not itself immutable, and therefore not thread safe.","(""Calculator"", ""The Calculator class uses an immutable object internally."", ""immutable object""); (""Calculator"", ""The Calculator class is not thread safe because it is not immutable."", ""thread safe"")"
"In other words: The ImmutableValue class is thread safe, but the use of it is not.","(""ImmutableValue"", ""The ImmutableValue class is described as being thread safe."", ""thread safe"")"
"To make the Calculator class thread safe you could have declared the getValue(), setValue(), and add() methods synchronized.","(""Calculator"", ""The getValue method is a part of the Calculator class."", ""getValue""); (""Calculator"", ""The setValue method is a part of the Calculator class."", ""setValue""); (""Calculator"", ""The add method is a part of the Calculator class."", ""add"")"
"The LocalObject instance in this example is not returned from the method, nor is it passed to any other objects that are accessible from outside the someMethod() method.","(""someMethod"", ""The LocalObject class is used within the someMethod method, indicating a relationship where the method interacts with the class."", ""LocalObject"")"
Each thread executing the someMethod() method will create its own LocalObject instance and assign it to the localObject reference.,"(""SomeMethod"", ""The method SomeMethod creates an instance of the class LocalObject."", ""LocalObject""); (""SomeMethod"", ""The method SomeMethod assigns the instance to the reference LocalObject."", ""LocalObject"")"
"Even if the LocalObject instance is passed as parameter to other methods in the same class, or in other classes, the use of it is thread safe.","(""LocalObject"", ""LocalObject is passed as a parameter to other methods, indicating a relationship between the class and the method."", ""parameter""); (""LocalObject"", ""LocalObject is mentioned as being used in the same class, indicating a relationship between the class and itself."", ""class"")"
If two threads call the add() method simultaneously on the same NotThreadSafe instance then it leads to race conditions.,"(""Add"", ""The Add method is a function that can be called on an instance of the NotThreadSafe class."", ""NotThreadSafe"")"
"Therefore, when they call the add() method on the NotThreadSafe instance it leads to race condition.","(""Add"", ""The Add method is called on the NotThreadSafe class, indicating a functional relationship where the method is part of the class's behavior."", ""NotThreadSafe"")"
"However, if two threads call the add() method simultaneously on different instances then it does not lead to race condition.","(""Add"", ""The add() method is called by threads, indicating a relationship between the method and the threads."", ""Threads""); (""Add"", ""The add() method is called on different instances, showing a relationship between the method and the instances."", ""Instances"")"
"In other words, it is waiting for a signal from thread A which causes hasDataToProcess() to return true.","(""thread A"", ""The method hasDataToProcess() is waiting for a signal from thread A to return true."", ""hasDataToProcess"")"
Notice how the while loop keeps executing until hasDataToProcess() returns true.,"(""While Loop"", ""The While Loop uses the HasDataToProcess method to determine when to stop executing."", ""HasDataToProcess"")"
"The class java.lang.Object defines three methods, wait(), notify(), and notifyAll(), to facilitate this.","(""Java.lang.Object"", ""The method Wait() is defined within the class Java.lang.Object."", ""Wait()""); (""Java.lang.Object"", ""The method Notify() is defined within the class Java.lang.Object."", ""Notify()""); (""Java.lang.Object"", ""The method NotifyAll() is defined within the class Java.lang.Object."", ""NotifyAll()"")"
A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object.,"(""Wait"", ""The Wait method becomes inactive until the Notify method is called on the same object."", ""Notify"")"
In order to call either wait() or notify the calling thread must first obtain the lock on that object.,"(""WAIT"", ""Both WAIT and NOTIFY are methods that require the calling thread to obtain a lock on the object before they can be called."", ""NOTIFY"")"
"In other words, the calling thread must call wait() or notify() from inside a synchronized block.","(""Wait"", ""Both Wait and Notify are methods that are typically used together in synchronized blocks for thread communication."", ""Notify"")"
Here is a modified version of MySignal called MyWaitNotify that uses wait() and notify().,"(""MyWaitNotify"", ""The class MyWaitNotify uses the method wait()."", ""wait()""); (""MyWaitNotify"", ""The class MyWaitNotify uses the method notify()."", ""notify()"")"
"The waiting thread would call doWait(), and the notifying thread would call doNotify().","(""DOWAIT"", ""The methods DOWAIT and DONOTIFY are related as they are both called by different threads for waiting and notifying purposes."", ""DONOTIFY"")"
"When a thread calls notify() on an object, one of the threads waiting on that object are awakened and allowed to execute.","(""Notify"", ""The method Notify is called by a Thread to awaken another thread waiting on an object."", ""Thread"")"
There is also a notifyAll() method that will wake all threads waiting on a given object.,"(""notifyAll"", ""The notifyAll is a method that wakes all threads waiting on a given object."", ""method"")"
As you can see both the waiting and notifying thread calls wait() and notify() from within a synchronized block.,"(""WAIT"", ""Both methods are used in thread synchronization and are called within a synchronized block."", ""NOTIFY"")"
"A thread cannot call wait(), notify() or notifyAll() without holding the lock on the object the method is called on.","(""wait()"", ""Both are methods that a thread can call related to object synchronization."", ""notify()""); (""wait()"", ""Both are methods that a thread can call related to object synchronization."", ""notifyAll()""); (""notify()"", ""Both are methods that a thread can call related to object synchronization."", ""notifyAll()"")"
Will the waiting thread not block the notifying thread from ever entering the synchronized block in doNotify()?,"(""DoNotify"", ""The method DoNotify is related to the concept of threads as it involves synchronization and notification, which are thread operations."", ""Thread"")"
Once a thread calls wait() it releases the lock it holds on the monitor object.,"(""Thread"", ""The method wait() is called by the Thread class."", ""Wait""); (""Wait"", ""The method wait() releases the lock on the Monitor class."", ""Monitor"")"
"This allows other threads to call wait() or notify() too, since these methods must be called from inside a synchronized block.","(""WAIT"", ""Both WAIT and NOTIFY are methods that are called from inside a synchronized block."", ""NOTIFY"")"
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block.,"(""Thread"", ""A thread uses the wait() method to pause execution until it is notified."", ""Wait""); (""Thread"", ""A thread uses the notify() method to resume execution after being paused."", ""Notify""); (""Wait"", ""The wait() method is used in conjunction with the notify() method to manage thread execution."", ""Notify"")"
"In other words: The awakened thread must reobtain the lock on the monitor object before it can exit the wait() call, because the wait call is nested inside a synchronized block.","(""Wait"", ""The wait method is used within a synchronized block, indicating a relationship where the wait method is dependent on the synchronized block for its execution context."", ""Synchronized Block"")"
"If multiple threads are awakened using notifyAll() only one awakened thread at a time can exit the wait() method, since each thread must obtain the lock on the monitor object in turn before exiting wait().","(""NotifyAll"", ""NotifyAll is related to Wait because NotifyAll is used to awaken threads that are waiting, which involves the Wait method."", ""Wait"")"
The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called.,"(""Notify"", ""Both are methods that deal with thread notification."", ""NotifyAll"")"
"Therefore, if a thread calls notify() before the thread to signal has called wait(), the signal will be missed by the waiting thread.","(""Notify"", ""Notify and Wait are related because Notify is used to signal a thread that is waiting, which is done using the Wait method."", ""Wait"")"
To avoid losing signals they should be stored inside the signal class.,"(""Signal"", ""The text suggests that signals should be stored inside the signal class, indicating a relationship between the concept of signals and the Signal class."", ""Signal"")"
Notice how the doNotify() method now sets the wasSignalled variable to true before calling notify().,"(""doNotify"", ""The doNotify method sets the wasSignalled variable to true."", ""wasSignalled""); (""doNotify"", ""The doNotify method calls the notify method."", ""notify"")"
"Also, notice how the doWait() method now checks the wasSignalled variable before calling wait().","(""doWait"", ""The doWait method calls the wait method."", ""wait""); (""doWait"", ""The doWait method checks the wasSignalled variable."", ""wasSignalled"")"
In fact it only calls wait() if no signal was received in between the previous doWait() call and this.,"(""doWait"", ""The method doWait calls the method wait if no signal was received between the previous doWait call and the current context."", ""wait"")"
For inexplicable reasons it is possible for threads to wake up even if notify() and notifyAll() has not been called.,"(""notify"", ""Both are methods that can be used to wake up threads."", ""notifyAll"")"
If a spurious wakeup occurs in the MyWaitNofity2 class's doWait() method the waiting thread may continue processing without having received a proper signal to do so!,"(""MyWaitNofity2"", ""The doWait method is a part of the MyWaitNofity2 class."", ""doWait"")"
Notice how the wait() call is now nested inside a while loop instead of an if-statement.,"(""wait()"", ""The wait() method is used within a while loop to repeatedly check a condition before proceeding."", ""while loop"")"
"The while loop is also a nice solution if you have multiple threads waiting, which are all awakened using notifyAll(), but only one of them should be allowed to continue.","(""While Loop"", ""The While Loop can use the NotifyAll method to awaken multiple threads."", ""NotifyAll"")"
"Only one thread at a time will be able to obtain the lock on the monitor object, meaning only one thread can exit the wait() call and clear the wasSignalled flag.","(""Wait"", ""The method Wait is related to the class WasSignalled because the wait() call is mentioned in the context of clearing the wasSignalled flag, indicating an interaction between the method and the class."", ""WasSignalled"")"
"Once this thread then exits the synchronized block in the doWait() method, the other threads can exit the wait() call and check the wasSignalled member variable inside the while loop.","(""DoWait"", ""The DoWait method contains a synchronized block that affects the behavior of the Wait method."", ""Wait""); (""Wait"", ""The Wait method checks the WasSignalled member variable inside a while loop."", ""WasSignalled"")"
"An earlier version of this text had an edition of the MyWaitNotify example class which used a constant string ( """" ) as monitor object.","(""MyWaitNotify"", ""The MyWaitNotify class uses a constant string as a monitor object."", ""constant string"")"
"The problem with calling wait() and notify() on the empty string, or any other constant string is, that the JVM/Compiler internally translates constant strings into the same object.","(""WAIT"", ""Both WAIT and NOTIFY are methods that are often used together in synchronization contexts."", ""NOTIFY""); (""JVM"", ""The JVM and COMPILER are related as they both play roles in the execution and translation of Java code."", ""COMPILER"")"
This also means that threads calling doWait() on the first MyWaitNotify instance risk being awakened by doNotify() calls on the second MyWaitNotify instance.,"(""doWait"", ""Both methods are related as they are likely part of the MyWaitNotify class, handling wait and notify operations."", ""doNotify""); (""doWait"", ""The method doWait is part of the MyWaitNotify class, as it is called on its instance."", ""MyWaitNotify""); (""doNotify"", ""The method doNotify is part of the MyWaitNotify class, as it is called on its instance."", ""MyWaitNotify"")"
"Remember, that even if the 4 threads call wait() and notify() on the same shared string instance, the signals from the doWait() and doNotify() calls are stored individually in the two MyWaitNotify instances.","(""WAIT"", ""The method doWait() likely calls or is related to the wait() method."", ""DOWAIT""); (""NOTIFY"", ""The method doNotify() likely calls or is related to the notify() method."", ""DONOTIFY""); (""DOWAIT"", ""The method doWait() is associated with the MyWaitNotify class, as it is mentioned in the context of MyWaitNotify instances."", ""MYWAITNOTIFY""); (""DONOTIFY"", ""The method doNotify() is associated with the MyWaitNotify class, as it is mentioned in the context of MyWaitNotify instances."", ""MYWAITNOTIFY"")"
"A doNotify() call on the MyWaitNotify 1 may wake threads waiting in MyWaitNotify 2, but the signal will only be stored in MyWaitNotify 1.","(""DONOTIFY"", ""The method doNotify() is called on the class MyWaitNotify 1."", ""MYWAITNOTIFY 1""); (""MYWAITNOTIFY 1"", ""Threads waiting in MyWaitNotify 2 may be woken by a signal stored in MyWaitNotify 1."", ""MYWAITNOTIFY 2"")"
"After all, if doNotify() is called on the second MyWaitNotify instance all that can really happen is that Thread A and B are awakened by mistake.","(""doNotify"", ""The method doNotify is called on an instance of the class MyWaitNotify."", ""MyWaitNotify""); (""Thread"", ""Thread A and B are associated with the MyWaitNotify instance as they are awakened by it."", ""MyWaitNotify"")"
"This awakened thread (A or B) will check its signal in the while loop, and go back to waiting because doNotify() was not called on the first MyWaitNotify instance, in which they are waiting.","(""doNotify"", ""The method doNotify is likely a method of the class MyWaitNotify, as it is mentioned in the context of being called on an instance of MyWaitNotify."", ""MyWaitNotify"")"
"The problem is, that since the doNotify() call only calls notify() and not notifyAll(), only one thread is awakened even if 4 threads are waiting on the same string instance (the empty string).","(""doNotify"", ""The doNotify() method calls the notify() method."", ""notify""); (""doNotify"", ""The doNotify() method does not call the notifyAll() method, which is relevant to the problem described."", ""notifyAll"")"
"If the doNotify() method had called notifyAll() instead of notify(), all waiting threads had been awakened and checked for signals in turn.","(""doNotify"", ""The doNotify method calls the notifyAll method."", ""notifyAll""); (""doNotify"", ""The doNotify method calls the notify method."", ""notify"")"
"Thread A and B would have gone back to waiting, but one of either C or D would have noticed the signal and left the doWait() method call.","(""Thread A"", ""Thread A is involved in the doWait() method call."", ""doWait""); (""Thread B"", ""Thread B is involved in the doWait() method call."", ""doWait""); (""Thread C"", ""Thread C may notice the signal and leave the doWait() method call."", ""doWait""); (""Thread D"", ""Thread D may notice the signal and leave the doWait() method call."", ""doWait"")"
"The other of C and D would go back to waiting, because the thread discovering the signal clears it on the way out of doWait().","(""doWait"", ""The method doWait is likely associated with the class C as it is mentioned in the context of thread signaling and waiting."", ""C""); (""doWait"", ""The method doWait is likely associated with the class D as it is mentioned in the context of thread signaling and waiting."", ""D"")"
"You may be tempted then to always call notifyAll() instead notify(), but this is a bad idea performance wise.","(""Notifyall"", ""Both are methods related to notifying threads in a concurrent environment."", ""Notify"")"
"For instance, each MyWaitNotify3 (example from earlier sections) instance has its own MonitorObject instance rather than using the empty string for wait() / notify() calls.","(""MyWaitNotify3"", ""Each MyWaitNotify3 instance has its own MonitorObject instance."", ""MonitorObject""); (""wait"", ""The methods wait() and notify() are mentioned together as part of the same functionality."", ""notify"")"
"The AtomicBoolean class provides you with a boolean variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().","(""AtomicBoolean"", ""The compareAndSet method is an advanced atomic operation provided by the AtomicBoolean class."", ""compareAndSet"")"
"The AtomicBoolean class is located in the java.util.concurrent.atomic package, so the full class name is java.util.concurrent.atomic.AtomicBoolean .","(""AtomicBoolean"", ""The AtomicBoolean class is part of the java.util.concurrent.atomic package."", ""java.util.concurrent.atomic"")"
You can get the value of an AtomicBoolean using the get() method.,"(""AtomicBoolean"", ""The get() method is used to retrieve the value of an AtomicBoolean."", ""get"")"
You can set the value of an AtomicBoolean using the set() method.,"(""AtomicBoolean"", ""The set method is used to set the value of an AtomicBoolean."", ""set"")"
You can swap the value of an AtomicBoolean using the getAndSet() method.,"(""AtomicBoolean"", ""The getAndSet() method is used to swap the value of an AtomicBoolean."", ""getAndSet"")"
"The getAndSet() method returns the AtomicBoolean's current value, and sets a new value for it.","(""getAndSet"", ""The getAndSet method is related to the AtomicBoolean class because it operates on its current value and sets a new value for it."", ""AtomicBoolean"")"
"The method compareAndSet() allows you to compare the current value of the AtomicBoolean to an expected value, and if current value is equal to the expected value, a new value can be set on the AtomicBoolean.","(""CompareAndSet"", ""The method CompareAndSet is used to operate on the AtomicBoolean class by comparing and setting its value."", ""AtomicBoolean"")"
"The compareAndSet() method is atomic, so only a single thread can execute it at the same time.","(""CompareAndSet"", ""The CompareAndSet method is described as atomic, indicating its operation is indivisible and thread-safe."", ""Atomic"")"
"Thus, the compareAndSet() method can be used to implemented simple synchronizers like locks.","(""CompareAndSet"", ""The compareAndSet() method can be used to implement simple synchronizers like locks."", ""Locks"")"
"The AtomicInteger class provides you with a int variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().","(""AtomicInteger"", ""The method compareAndSet is an advanced atomic operation provided by the AtomicInteger class."", ""compareAndSet"")"
"The AtomicInteger class is located in the java.util.concurrent.atomic package, so the full class name is java.util.concurrent.atomic.AtomicInteger .","(""AtomicInteger"", ""The AtomicInteger class is part of the java.util.concurrent.atomic package."", ""java.util.concurrent.atomic"")"
You can get the value of an AtomicInteger instance via the get() method.,"(""AtomicInteger"", ""The get() method is used to retrieve the value of an AtomicInteger instance."", ""get"")"
You can set the value of an AtomicInteger instance via the set() method.,"(""AtomicInteger"", ""The set() method is used to set the value of an AtomicInteger instance."", ""set"")"
The AtomicInteger class contains a few methods you can use to add a value to the AtomicInteger and get its value returned.,"(""AtomicInteger"", ""The add method is used to add a value to the AtomicInteger class."", ""add""); (""AtomicInteger"", ""The get method is used to retrieve the value from the AtomicInteger class."", ""get"")"
"The first method, addAndGet() adds a number to the AtomicInteger and returns its value after the addition.","(""addAndGet"", ""The method addAndGet is used to add a number to the AtomicInteger class and return its value after the addition."", ""AtomicInteger"")"
"The second method, getAndAdd() also adds a number to the AtomicInteger but returns the value the AtomicInteger had before the value was added.","(""getAndAdd"", ""The method getAndAdd is used to add a number to the AtomicInteger class."", ""AtomicInteger"")"
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicInteger.,"(""GETANDINCREMENT"", ""The method getAndIncrement() operates on the AtomicInteger class."", ""ATOMICINTEGER""); (""INCREMENTANDGET"", ""The method incrementAndGet() operates on the AtomicInteger class."", ""ATOMICINTEGER""); (""GETANDADD"", ""The method getAndAdd() operates on the AtomicInteger class."", ""ATOMICINTEGER""); (""ADDANDGET"", ""The method addAndGet() operates on the AtomicInteger class."", ""ATOMICINTEGER"")"
The AtomicInteger class also contains a few methods for subtracting values from the AtomicInteger value atomically.,"(""AtomicInteger"", ""The AtomicInteger class contains methods for subtracting values atomically."", ""subtracting"")"
The decrementAndGet() subtracts 1 from the AtomicInteger value and returns its value after the subtraction.,"(""DecrementAndGet"", ""The method DecrementAndGet operates on the AtomicInteger class by subtracting 1 from its value and returning the result."", ""AtomicInteger"")"
The getAndDecrement() also subtracts 1 from the AtomicInteger value but returns the value the AtomicInteger had before the subtraction.,"(""getAndDecrement"", ""The method getAndDecrement is related to the class AtomicInteger because it operates on the AtomicInteger value."", ""AtomicInteger"")"
The Java AtomicIntegerArray class (java.util.concurrent.atomic.AtomicIntegerArray) represents an array of int .,"(""AtomicIntegerArray"", ""The AtomicIntegerArray class is part of the java.util.concurrent.atomic package."", ""java.util.concurrent.atomic"")"
You can get the value of a given element using the get() method on the AtomicIntegerArray.,"(""GET"", ""The GET method is used on the ATOMICINTEGERARRAY class to retrieve the value of a given element."", ""ATOMICINTEGERARRAY"")"
Here is an example showing how calling the get() method looks:,"(""GET"", ""The text explicitly mentions the 'get()' method, indicating it is a method entity."", ""METHOD"")"
You can set the value of a given element using the set() method on the AtomicIntegerArray.,"(""Set"", ""The set() method is used on the AtomicIntegerArray class to set the value of a given element."", ""AtomicIntegerArray"")"
Here is an example showing how calling the set() method looks:,"(""Set"", ""The text refers to 'set()' as a method, indicating that 'Set' is a method."", ""Method"")"
"The compareAndSet() method is used to compare the value of a given element with a specified value, and if the two values are equal, set a new value for that element.","(""COMPAREANDSET"", ""COMPAREANDSET is a method as indicated by the text."", ""METHOD"")"
Only one thread at a time can execute the compareAndSet() method.,"(""CompareAndSet"", ""The CompareAndSet method is related to thread execution as it specifies that only one thread can execute it at a time."", ""Thread"")"
"The compareAndSet() method returns a boolean with the value true if the element had a new value set, and false if not (if the element did not have the expected value).","(""COMPAREANDSET"", ""The compareAndSet method returns a boolean value indicating the success of setting a new value."", ""BOOLEAN"")"
Calling addAndGet() is also an atomic operation (like all operations on the AtomicIntegerArray).,"(""addAndGet"", ""The method addAndGet is an operation that can be performed on the class AtomicIntegerArray."", ""AtomicIntegerArray"")"
"The getAndAdd() method does the same as the addAndGet() method, except the getAndAdd() method returns the value of the element before a value is added to it.","(""getAndAdd"", ""Both are methods that perform similar operations, with the difference being in the return value."", ""addAndGet"")"
The incrementAndGet() method increments (adds 1) to the value of a given element and returns the new value of that element.,"(""INCREMENTANDGET"", ""The incrementAndGet is a method that performs an operation on a given element."", ""METHOD"")"
"The getAndIncrement() method does the same as the incrementAndGet() method, except the getAndIncrement() method returns the value of the element before it is incremented.","(""GetAndIncrement"", ""Both methods perform similar operations, with a difference in the order of increment and return value."", ""IncrementAndGet"")"
The decrementAndGet() method decrements (subtracts 1) to the value of a given element and returns the new value of that element.,"(""DecrementAndGet"", ""The text describes 'decrementAndGet()' as a method."", ""Method"")"
"The getAndDecrement() method does the same as the decrementAndGet() method, except the getAndDecrement() method returns the value of the element before it is decremented.","(""GetAndDecrement"", ""Both methods perform a decrement operation, but GetAndDecrement returns the value before decrementing, while DecrementAndGet returns the value after."", ""DecrementAndGet"")"
You should check out the JavaDoc for the AtomicIntegerArray class to learn more about those methods.,"(""AtomicIntegerArray"", ""The JavaDoc package provides documentation for the AtomicIntegerArray class."", ""JavaDoc"")"
"The AtomicLong class provides you with a long variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().","(""AtomicLong"", ""The compareAndSet method is an advanced atomic operation provided by the AtomicLong class."", ""compareAndSet"")"
"The AtomicLong class is located in the java.util.concurrent.atomic package, so the full class name is java.util.concurrent.atomic.AtomicLong .","(""AtomicLong"", ""The AtomicLong class is located in the java.util.concurrent.atomic package."", ""java.util.concurrent.atomic"")"
You can get the value of an AtomicLong instance via the get() method.,"(""AtomicLong"", ""The get method is used to retrieve the value of an AtomicLong instance."", ""get"")"
You can set the value of an AtomicLong instance via the set() method.,"(""AtomicLong"", ""The set() method is used to set the value of an AtomicLong instance."", ""set"")"
The AtomicLong class contains a few methods you can use to add a value to the AtomicLong and get its value returned.,"(""AtomicLong"", ""The add method is used to add a value to the AtomicLong class."", ""add""); (""AtomicLong"", ""The get method is used to retrieve the value from the AtomicLong class."", ""get"")"
"The first method, addAndGet() adds a number to the AtomicLong and returns its value after the addition.","(""AddAndGet"", ""The method AddAndGet is used to add a number to the AtomicLong class and return its value after the addition."", ""AtomicLong"")"
"The second method, getAndAdd() also adds a number to the AtomicLong but returns the value the AtomicLong had before the value was added.","(""getAndAdd"", ""The method getAndAdd is related to the class AtomicLong because it operates on instances of AtomicLong by adding a number to it."", ""AtomicLong"")"
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicLong.,"(""getAndIncrement"", ""Both methods are similar in functionality, adding 1 to the value."", ""incrementAndGet""); (""getAndAdd"", ""Both methods are similar in functionality, adding a specified value."", ""addAndGet""); (""getAndIncrement"", ""The method getAndIncrement operates on the AtomicLong class."", ""AtomicLong""); (""incrementAndGet"", ""The method incrementAndGet operates on the AtomicLong class."", ""AtomicLong""); (""getAndAdd"", ""The method getAndAdd operates on the AtomicLong class."", ""AtomicLong""); (""addAndGet"", ""The method addAndGet operates on the AtomicLong class."", ""AtomicLong"")"
The AtomicLong class also contains a few methods for subtracting values from the AtomicLong value atomically.,"(""AtomicLong"", ""The method 'subtracting' is used to perform operations on the 'AtomicLong' class."", ""subtracting"")"
The decrementAndGet() subtracts 1 from the AtomicLong value and returns its value after the subtraction.,"(""DecrementAndGet"", ""The method DecrementAndGet operates on the AtomicLong class by subtracting 1 from its value and returning the result."", ""AtomicLong"")"
The getAndDecrement() also subtracts 1 from the AtomicLong value but returns the value the AtomicLong had before the subtraction.,"(""getAndDecrement"", ""The method getAndDecrement operates on the AtomicLong class by subtracting 1 from its value and returning the previous value."", ""AtomicLong"")"
The Java AtomicLongArray class (java.util.concurrent.atomic.AtomicLongArray) represents an array of long .,"(""AtomicLongArray"", ""The AtomicLongArray class is part of the java.util.concurrent.atomic package."", ""java.util.concurrent.atomic"")"
You can get the value of a given element using the get() method on the AtomicLongArray.,"(""Get"", ""The get() method is used on the AtomicLongArray class to retrieve the value of a given element."", ""AtomicLongArray"")"
You can set the value of a given element using the set() method on the AtomicLongArray.,"(""Set"", ""The set() method is used on the AtomicLongArray class to set the value of a given element."", ""AtomicLongArray"")"
Calling addAndGet() is also an atomic operation (like all operations on the AtomicLongArray).,"(""addAndGet"", ""The method addAndGet is an operation that can be performed on the AtomicLongArray class."", ""AtomicLongArray"")"
You should check out the JavaDoc for the AtomicLongArray class to learn more about those methods.,"(""AtomicLongArray"", ""The AtomicLongArray class contains or is associated with various methods."", ""methods""); (""JavaDoc"", ""The JavaDoc package provides documentation for the AtomicLongArray class."", ""AtomicLongArray"")"
The AtomicReference class provides an object reference variable which can be read and written atomically.,"(""AtomicReference"", ""The AtomicReference class provides an object reference variable which can be read and written atomically."", ""object reference variable"")"
By atomic is meant that multiple threads attempting to change the same AtomicReference (e.g.,"(""AtomicReference"", ""The text refers to AtomicReference as a class that supports atomic operations, indicating its role in concurrent programming."", ""AtomicReference"")"
"AtomicReference even has an advanced compareAndSet() method which lets you compare the reference to an expected value (reference) and if they are equal, set a new reference inside the AtomicReference object.","(""AtomicReference"", ""The compareAndSet method is a function provided by the AtomicReference class."", ""compareAndSet"")"
You can get the reference stored in an AtomicReference using the AtomicReference's get() method.,"(""AtomicReference"", ""The get() method is used to retrieve the reference stored in an AtomicReference class."", ""get"")"
If you have an untyped AtomicReference then the get() method returns an Object reference.,"(""AtomicReference"", ""The get() method is a function of the AtomicReference class, used to retrieve the current value."", ""get""); (""get"", ""The get() method returns an Object reference, indicating the type of value it retrieves."", ""Object"")"
If you have a typed AtomicReference then get() returns a reference to the type you declared on the AtomicReference variable when you created it.,"(""AtomicReference"", ""The method 'get' is used to retrieve the reference from an instance of the class 'AtomicReference'."", ""get"")"
Notice how it is necessary to cast the reference returned by get() to a String because get() returns an Object reference when the AtomicReference is untyped.,"(""Get"", ""The method 'get()' needs to be cast to 'String' because it returns an 'Object' reference."", ""String""); (""Get"", ""The method 'get()' returns an 'Object' reference when the 'AtomicReference' is untyped."", ""Object""); (""Get"", ""The method 'get()' is associated with 'AtomicReference', which is untyped in this context."", ""AtomicReference"")"
Notice how it is no longer necessary to cast the referenced returned by get() because the compiler knows it will return a String reference.,"(""GET"", ""The method GET returns a reference of type STRING, indicating a relationship between the method and the class."", ""STRING"")"
You can set the reference stored in an AtomicReference instance using its set() method.,"(""AtomicReference"", ""The set() method is used to set the reference stored in an AtomicReference instance."", ""set"")"
In an untyped AtomicReference instance the set() method takes an Object reference as parameter.,"(""AtomicReference"", ""The set() method is a member of the AtomicReference class."", ""set"")"
In a typed AtomicReference the set() method takes whatever type as parameter you declared as its type when you declared the AtomicReference.,"(""AtomicReference"", ""The set() method is a function of the AtomicReference class, allowing it to set a value of the declared type."", ""set"")"
There is no difference to see in the use of the set() method for an untyped or typed reference.,"(""set"", ""The set method can be used with an untyped reference."", ""untyped reference""); (""set"", ""The set method can be used with a typed reference."", ""typed reference"")"
"The compareAndSet() method can compare the reference stored in the AtomicReference instance with an expected reference, and if they two references are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicReference instance.","(""compareAndSet"", ""The compareAndSet method is used to compare and set references within an AtomicReference instance."", ""AtomicReference"")"
If compareAndSet() sets a new reference in the AtomicReference the compareAndSet() method returns true.,"(""CompareAndSet"", ""The CompareAndSet method is used to set a new reference in the AtomicReference class."", ""AtomicReference"")"
"Then it calls comparesAndSet() two times to compare the stored reference to the initial reference, and set a new reference if the stored reference is equal to the initial reference.","(""comparesAndSet"", ""The method comparesAndSet is called two times in the text to perform operations on references."", ""comparesAndSet"")"
"The second time the stored reference is the new reference just set in the call to compareAndSet() before, so the stored reference is of course not equal to the initial reference.","(""COMPAREANDSET"", ""COMPAREANDSET is identified as a method in the text."", ""METHOD"")"
"Thus, a new reference is not set on the AtomicReference and the compareAndSet() method returns false.","(""AtomicReference"", ""The compareAndSet method is a function that operates on the AtomicReference class."", ""compareAndSet"")"
The AtomicReferenceArray in the java.util.concurrent.atomic package is an array of object references which can be updated atomically.,"(""AtomicReferenceArray"", ""The class AtomicReferenceArray is part of the java.util.concurrent.atomic package."", ""java.util.concurrent.atomic"")"
"The second constructor takes a E[] array as parameter, where E is the type (class) of the object references.","(""constructor"", ""The constructor takes an array of type E as a parameter, indicating a relationship between the constructor and the class E."", ""E"")"
The get() method returns the value of the element with the given index.,"(""Get"", ""The get() method returns the value of the element with the given index."", ""Value"")"
"If the AtomicReferenceArray has a generic type, the get() method returns objects of that type.","(""AtomicReferenceArray"", ""The get() method is a function that operates on the AtomicReferenceArray class."", ""get"")"
"For instance, if the generic type is String, then you can call get() like this:","(""String"", ""The method 'get' can be called on the generic type 'String'."", ""get"")"
The set() method sets the value of an element with a specific index.,"(""Set"", ""The Set method is used to set the value of an element with a specific index."", ""Element"")"
The index and value is passed as parameters to the set() method.,"(""INDEX"", ""The index is passed as a parameter to the set() method."", ""SET""); (""VALUE"", ""The value is passed as a parameter to the set() method."", ""SET"")"
"The compareAndSet() method of the AtomicReferenceArray can compare the current reference stored in a given element with an expected reference, and if the references are the same, swap the current reference with a new reference.","(""CompareAndSet"", ""The CompareAndSet method is a function that belongs to the AtomicReferenceArray class, as it operates on elements within this class."", ""AtomicReferenceArray"")"
You should check out the JavaDoc for the AtomicReferenceArray class to learn more about those methods.,"(""AtomicReferenceArray"", ""The AtomicReferenceArray class contains or is associated with various methods."", ""methods""); (""JavaDoc"", ""The JavaDoc package provides documentation for the AtomicReferenceArray class."", ""AtomicReferenceArray"")"
The AtomicStampedReference class provides an object reference variable which can be read and written atomically.,"(""AtomicStampedReference"", ""The AtomicStampedReference class provides an object reference variable which can be read and written atomically."", ""object reference variable"")"
"The reference and stamp can be swapped using a single atomic compare-and-swap operation, via the compareAndSet() method.","(""COMPAREANDSET"", ""The compareAndSet() method is mentioned as a way to perform a compare-and-swap operation."", ""COMPAREANDSET"")"
You can get the reference stored in an AtomicStampedReference using the AtomicStampedReference's getReference() method.,"(""AtomicStampedReference"", ""The getReference method is a function provided by the AtomicStampedReference class to retrieve the stored reference."", ""getReference"")"
If you have an untyped AtomicStampedReference then the getReference() method returns an Object reference.,"(""AtomicStampedReference"", ""The getReference() method is a member of the AtomicStampedReference class."", ""getReference"")"
If you have a typed AtomicStampedReference then getReference() returns a reference to the type you declared on the AtomicStampedReference variable when you created it.,"(""AtomicStampedReference"", ""The method getReference() is used to retrieve a reference from an AtomicStampedReference object."", ""getReference"")"
Notice how it is necessary to cast the reference returned by getReference() to a String because getReference() returns an Object reference when the AtomicStampedReference is untyped.,"(""GETREFERENCE"", ""The method getReference() is associated with the class AtomicStampedReference as it is mentioned in the context of its return type."", ""ATOMICSTAMPEDREFERENCE"")"
Notice how it is no longer necessary to cast the referenced returned by getReference() because the compiler knows it will return a String reference.,"(""getReference"", ""The method getReference is related to the class String because it returns a String reference."", ""String"")"
The AtomicStampedReference also contains a getStamp() method which can be used to obtain the internally stored stamp.,"(""AtomicStampedReference"", ""The getStamp method is a part of the AtomicStampedReference class."", ""getStamp"")"
"You can obtain both reference and stamp from an AtomicStampedReference in a single, atomic operation using the get() method.","(""AtomicStampedReference"", ""The get() method is used to obtain reference and stamp from an AtomicStampedReference in a single, atomic operation."", ""get"")"
The get() method returns the reference as return value from the method.,"(""Get"", ""The text describes 'get()' as a method."", ""Method"")"
The stamp is inserted into an int[] array that is passed as parameter to the get() method.,"(""int[] array"", ""The int[] array is passed as a parameter to the get() method."", ""get"")"
You can set the reference stored in an AtomicStampedReference instance using its set() method.,"(""AtomicStampedReference"", ""The set() method is used to set the reference stored in an AtomicStampedReference instance."", ""set"")"
In an untyped AtomicStampedReference instance the set() method takes an Object reference as first parameter.,"(""AtomicStampedReference"", ""The set method is a function that belongs to the AtomicStampedReference class."", ""set"")"
In a typed AtomicStampedReference the set() method takes whatever type as parameter you declared as its type when you declared the AtomicStampedReference.,"(""AtomicStampedReference"", ""The set method is a function that operates on the AtomicStampedReference class."", ""set"")"
"The compareAndSet() method can compare the reference stored in the AtomicStampedReference instance with an expected reference, and the stored stamp with an expected stamp, and if they two references and stamps are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicStampedReference instance.","(""compareAndSet()"", ""The compareAndSet() method is used to compare and set references within an AtomicStampedReference instance."", ""AtomicStampedReference""); (""compareAndSet()"", ""The compareAndSet() method uses a comparison similar to the equals() method, but checks for reference identity (==) rather than equality."", ""equals()""); (""compareAndSet()"", ""The compareAndSet() method uses the == operator to compare references for identity."", ""==""); (""equals()"", ""The equals() method is contrasted with the == operator in the context of reference comparison."", ""=="")"
If compareAndSet() sets a new reference in the AtomicStampedReference the compareAndSet() method returns true.,"(""CompareAndSet"", ""The CompareAndSet method is used to set a new reference in the AtomicStampedReference class."", ""AtomicStampedReference"")"
This example first creates an AtomicStampedReference and then uses compareAndSet() to swap the reference and stamp.,"(""AtomicStampedReference"", ""The method compareAndSet() is used to operate on the AtomicStampedReference class."", ""compareAndSet"")"
After the first compareAndSet() call the example attempts to swap the reference and stamp two times without success.,"(""compareAndSet"", ""The compareAndSet method is used in an attempt to swap the reference and stamp."", ""swap""); (""compareAndSet"", ""The compareAndSet method is involved in operations related to the reference."", ""reference""); (""compareAndSet"", ""The compareAndSet method is involved in operations related to the stamp."", ""stamp"")"
"The first time the initialRef is passed as expected reference, but the internally stored reference is newRef at this time, so the compareAndSet() call fails.","(""compareAndSet"", ""The method compareAndSet is related to initialRef as it is used to compare the initial reference."", ""initialRef""); (""compareAndSet"", ""The method compareAndSet is related to newRef as it is used to compare the internally stored reference."", ""newRef"")"
"The second time the initialStamp is passed as the expected stamp, but the internally stored stamp is newStamp at this time, so the compareAndSet() call fails.","(""compareAndSet"", ""The compareAndSet method uses initialStamp as the expected stamp in its operation."", ""initialStamp""); (""compareAndSet"", ""The compareAndSet method fails because the internally stored stamp is newStamp, which does not match the expected stamp."", ""newStamp"")"
"The final compareAndSet() call will succeed, because the expected reference is newRef and the expected stamp is newStamp.","(""compareAndSet"", ""The method compareAndSet uses newRef as the expected reference."", ""newRef""); (""compareAndSet"", ""The method compareAndSet uses newStamp as the expected stamp."", ""newStamp"")"
Thread 1 can copy the reference and stamp out of the AtomicStampedReference atomically using get().,"(""Thread 1"", ""Thread 1 interacts with AtomicStampedReference to perform operations."", ""AtomicStampedReference""); (""get"", ""The get method is used to retrieve data from AtomicStampedReference."", ""AtomicStampedReference"")"
"If another thread changes the reference from A to B and then back to A, then the stamp will have changed (provided threads update the stamp sensibly - e.g increment it).","(""A"", ""The text describes a scenario where a reference changes from A to B, indicating a relationship between these two classes."", ""B""); (""B"", ""The text describes a scenario where a reference changes back from B to A, indicating a relationship between these two classes."", ""A"")"
"The BlockingDeque interface in the java.util.concurrent class represents a deque which is thread safe to put into, and take instances from.","(""BlockingDeque"", ""The BlockingDeque class is part of the java.util.concurrent package, which provides concurrency utilities."", ""java.util.concurrent"")"
"The BlockingDeque class is a Deque which blocks threads tring to insert or remove elements from the deque, in case it is either not possible to insert or remove elements from the deque.","(""BlockingDeque"", ""BlockingDeque is a type of Deque that blocks threads when inserting or removing elements."", ""Deque"")"
The java.util.concurrent package has the following implementations of the BlockingDeque interface:,"(""Java.util.concurrent"", ""The BlockingDeque class is implemented within the Java.util.concurrent package"", ""BlockingDeque"")"
The java.util.concurrent.ConcurrentMap interface represents a Map which is capable of handling concurrent access (puts and gets) to it.,"(""ConcurrentMap"", ""The ConcurrentMap class is part of the java.util.concurrent package, which provides utilities for concurrent programming."", ""java.util.concurrent"")"
"The ConcurrentMap has a few extra atomic methods in addition to the methods it inherits from its superinterface, java.util.Map.","(""ConcurrentMap"", ""ConcurrentMap contains methods, including atomic ones."", ""methods""); (""ConcurrentMap"", ""ConcurrentMap inherits methods from the java.util.Map package."", ""java.util.Map"")"
The java.util.concurrent package contains the following implementations of the ConcurrentMap interface:,"(""Java.util.concurrent"", ""The Java.util.concurrent package contains implementations of the ConcurrentMap interface."", ""ConcurrentMap"")"
"The ConcurrentHashMap is very similar to the java.util.HashTable class, except that ConcurrentHashMap offers better concurrency than HashTable does.","(""ConcurrentHashMap"", ""ConcurrentHashMap is compared to java.util.HashTable in terms of concurrency features."", ""java.util.HashTable""); (""ConcurrentHashMap"", ""ConcurrentHashMap offers better concurrency than HashTable."", ""HashTable""); (""java.util.HashTable"", ""java.util.HashTable is part of the java.util package."", ""java.util""); (""HashTable"", ""HashTable is part of the java.util package."", ""java.util"")"
"The java.util.concurrent.ConcurrentNavigableMap class is a java.util.NavigableMap with support for concurrent access, and which has concurrent access enabled for its submaps.","(""ConcurrentNavigableMap"", ""ConcurrentNavigableMap is a subclass of NavigableMap."", ""NavigableMap""); (""ConcurrentNavigableMap"", ""ConcurrentNavigableMap is part of the java.util.concurrent package."", ""java.util.concurrent""); (""NavigableMap"", ""NavigableMap is part of the java.util package."", ""java.util"")"
"The ""submaps"" are the maps returned by various methods like headMap(), subMap() and tailMap().","(""submaps"", ""The method headMap() returns a submap, indicating a relationship between the submaps class and the headMap method."", ""headMap""); (""submaps"", ""The method subMap() returns a submap, indicating a relationship between the submaps class and the subMap method."", ""subMap""); (""submaps"", ""The method tailMap() returns a submap, indicating a relationship between the submaps class and the tailMap method."", ""tailMap"")"
Here is an example illustrating the use of the headMap() method.,"(""headMap"", ""The text explicitly mentions the use of the headMap() method, indicating that headMap is a method."", ""method"")"
Here is an example illustrating the use of the tailMap() method:,"(""TailMap"", ""The text explicitly mentions the use of the tailMap() method, indicating that TailMap is a method."", ""Method"")"
"The subMap() method returns a view of the original map which contains all keys from (including), to (excluding) two keys given as parameters to the method.","(""subMap"", ""The subMap method returns a view of the original map."", ""map"")"
A java.util.concurrent.CountDownLatch is a concurrency construct that allows one or more threads to wait for a given set of operations to complete.,"(""CountDownLatch"", ""CountDownLatch is a class within the java.util.concurrent package"", ""java.util.concurrent"")"
Threads waiting for this count to reach zero can call one of the await() methods.,"(""Threads"", ""The await() method is called by threads waiting for a count to reach zero."", ""await()"")"
"After the Decrementer has called countDown() 3 times on the CountDownLatch, the waiting Waiter is released from the await() call.","(""Decrementer"", ""The Decrementer class calls the countDown method."", ""countDown""); (""CountDownLatch"", ""The countDown method is called on the CountDownLatch class."", ""countDown""); (""Waiter"", ""The Waiter class is released from the await method call."", ""await""); (""CountDownLatch"", ""The await method is associated with the CountDownLatch class."", ""await"")"
The java.util.concurrent.CyclicBarrier class is a synchronization mechanism that can synchronize threads progressing through some algorithm.,"(""CyclicBarrier"", ""The CyclicBarrier class is part of the java.util.concurrent package, which provides concurrency utilities."", ""java.util.concurrent"")"
The threads wait for each other by calling the await() method on the CyclicBarrier.,"(""Await"", ""The await() method is called on the CyclicBarrier class, indicating a relationship where the method is a function of the class."", ""CyclicBarrier"")"
The value returned by the getDelay() method should be the delay remaining before this element can be released.,"(""getDelay"", ""The getDelay method returns the delay remaining before the element can be released."", ""delay"")"
"If 0 or a negative value is returned, the delay will be considered expired, and the element released at the next take() etc.","(""take()"", ""The method 'take()' is related to 'delay' as it is mentioned in the context of when the delay is considered expired."", ""delay"")"
The TimeUnit instance passed to the getDelay() method is an Enum that tells which time unit the delay should be returned in.,"(""TimeUnit"", ""The TimeUnit class is used as a parameter in the getDelay method to specify the time unit for the delay."", ""getDelay"")"
"The Delayed interface also extends the java.lang.Comparable interface, as you can see, which means that Delayed objects can be compared to each other.","(""Delayed"", ""The Delayed class extends the java.lang.Comparable class, indicating an inheritance relationship."", ""java.lang.Comparable"")"
You will have to create your own implementation of the Delayed interface to use the DelayQueue class.,"(""Delayed"", ""The Delayed interface is used in conjunction with the DelayQueue class, indicating that the interface must be implemented to utilize the class."", ""DelayQueue"")"
The java.util.concurrent.Exchanger class represents a kind of rendezvous point where two threads can exchange objects.,"(""Exchanger"", ""The Exchanger class is part of the java.util.concurrent package."", ""java.util.concurrent"")"
Exchanging objects is done via one of the two exchange() methods.,"(""Exchange"", ""The text mentions the exchange of objects being done via the exchange() methods, indicating a relationship between the concept of exchange and the method itself."", ""Exchange"")"
"The Java BlockingQueue interface, java.util.concurrent.BlockingQueue, represents a queue which is thread safe to put elements into, and take elements out of from.","(""BlockingQueue"", ""BlockingQueue is part of the java.util.concurrent package, as indicated by its full name java.util.concurrent.BlockingQueue."", ""java.util.concurrent"")"
The java.util.concurrent package has the following implementations of the BlockingQueue interface:,"(""Java.util.concurrent"", ""The BlockingQueue class is implemented within the Java.util.concurrent package."", ""BlockingQueue"")"
"First, the BlockingQueueExample class which starts a Producer and a Consumer in separate threads.","(""BlockingQueueExample"", ""The BlockingQueueExample class starts a Producer in a separate thread."", ""Producer""); (""BlockingQueueExample"", ""The BlockingQueueExample class starts a Consumer in a separate thread."", ""Consumer"")"
"It just takes out the objects from the queue, and prints them to System.out.","(""System"", ""The 'out' is a field of the 'System' class, commonly used for output operations."", ""out"")"
The Java BlockingQueue add() method will add the element passed as parameter to this method if the BlockingQueue has space for it internally.,"(""BlockingQueue"", ""The add() method is a function that operates on the BlockingQueue class to add elements to it."", ""add"")"
"If the BlockingQueue does not have space internally for this new element, the add() method throws an IllegalStateException.","(""add()"", ""The add() method throws an IllegalStateException when the BlockingQueue does not have space for a new element."", ""IllegalStateException""); (""BlockingQueue"", ""The add() method is used with the BlockingQueue to add new elements."", ""add()"")"
The BlockingQueue offer() method will add the element passed as parameter to this method if the BlockingQueue has space for it internally.,"(""BlockingQueue"", ""The offer method is a function of the BlockingQueue class."", ""offer"")"
"If the BlockingQueue does not have space internally for this new element, the offer() method return false.","(""BlockingQueue"", ""The offer method is a function that operates on the BlockingQueue class."", ""offer"")"
The BlockingQueue offer() method exists in a version which takes a time out as parameter.,"(""BlockingQueue"", ""The offer method is a function that belongs to the BlockingQueue class."", ""offer"")"
"This version of the offer() method will add the element passed as parameter if the BlockingQueue has space for it internally, or space becomes available.","(""Offer"", ""The offer() method is a function that operates on the BlockingQueue class to add elements."", ""BlockingQueue"")"
"If the BlockingQueue does not have or get space internally for this new element within the time out, this version of the offer() method returns false.","(""BlockingQueue"", ""The offer() method is a function that operates on the BlockingQueue class."", ""offer()"")"
The BlockingQueue put() method inserts the element into the BlockingQueue if it has space for it internally.,"(""put"", ""The put method is a function that operates on the BlockingQueue class to insert elements."", ""BlockingQueue"")"
"If the BlockingQueue does not have space for the new element, the put() method will block the thread calling the put() method until the BlockingQueue as space internally for the new element.","(""BlockingQueue"", ""The put() method is a function that operates on the BlockingQueue class, as it is used to add elements to the BlockingQueue."", ""put()"")"
The Java BlockingQueue take() method will remove the first element in the BlockingQueue.,"(""BlockingQueue"", ""The take() method is a function that operates on the BlockingQueue class to remove the first element."", ""take()"")"
"If the BlockingQueue does not contain any elements, the take() method will block the thread calling take() until an element is inserted into the BlockingQueue.","(""BlockingQueue"", ""The take() method is used to retrieve elements from the BlockingQueue class."", ""take()"")"
The BlockingQueue poll() method will remove the first element in the BlockingQueue.,"(""poll"", ""The poll method is a function that operates on the BlockingQueue class to remove the first element."", ""BlockingQueue"")"
"If the BlockingQueue does not contain any elements, the poll() method will return null.","(""BlockingQueue"", ""The poll() method is a function that operates on the BlockingQueue class."", ""poll()"")"
"If the BlockingQueue does not contain any elements, this version of the poll() method will wait for an element to become available for the given amount of time passed to it as parameter.","(""BlockingQueue"", ""The poll() method is associated with the BlockingQueue class as it operates on it to retrieve elements."", ""poll()"")"
The remove() method will use the o.equals(element) to decide if the object o passed as parameter matches a given element in the BlockingQueue.,"(""Remove"", ""The remove() method uses the equals() method to compare objects."", ""Equals""); (""Remove"", ""The remove() method is used in the context of the BlockingQueue class."", ""BlockingQueue"")"
"The remove() method will return true if an element was removed, and false if not.","(""Remove"", ""The term 'remove()' is described as a method in the text."", ""Method"")"
The BlockingQueue peek() method will return the first element of the BlockingQueue without removing it.,"(""BlockingQueue"", ""The peek method is a function of the BlockingQueue class, allowing access to its first element without removal."", ""peek"")"
"If the BlockingQueue does not contain any elements, the peek() method will return null.","(""BlockingQueue"", ""The peek() method is used to interact with the BlockingQueue class to check its elements."", ""peek()"")"
The BlockingQueue element() method will return the first element of the BlockingQueue without removing it.,"(""BlockingQueue"", ""The element() method is a function that operates on the BlockingQueue class, returning the first element without removing it."", ""element"")"
"If the BlockingQueue does not contain any elements, the element() method will throw a NoSuchElementException.","(""BlockingQueue"", ""The element() method is used with the BlockingQueue class to retrieve elements."", ""element()""); (""element()"", ""The element() method throws a NoSuchElementException if the BlockingQueue is empty."", ""NoSuchElementException"")"
The BlockingQueue contains(Object o) method will return true if the BlockingQueue contains an object matching the object passed as parameter to the contains() method.,"(""BlockingQueue"", ""The contains method is a function of the BlockingQueue class."", ""contains"")"
"The Objects.equals(o, element) statement is used to check if the parameter object o matches a given element in the BlockingQueue.","(""Objects"", ""The method 'equals' is a part of the 'Objects' class."", ""equals""); (""equals"", ""The 'equals' method is used to compare an object with an element in the 'BlockingQueue'."", ""BlockingQueue"")"
The BlockingQueue size() method returns the number of elements stored in BlockingQueue.,"(""BlockingQueue"", ""The size() method is a function of the BlockingQueue class, used to return the number of elements stored in it."", ""size"")"
The BlockingQueue remainingCapacity() method returns the remaining (unused) capacity of the BlockingQueue.,"(""BlockingQueue"", ""The remainingCapacity method is a function of the BlockingQueue class, indicating it operates on or is associated with this class."", ""remainingCapacity"")"
"The Java Callable interface, java.util.concurrent.Callable, represents an asynchronous task which can be executed by a separate thread.","(""Java Callable"", ""The Java Callable is represented by the java.util.concurrent.Callable class."", ""java.util.concurrent.Callable""); (""java.util.concurrent.Callable"", ""The class java.util.concurrent.Callable is part of the java.util.concurrent package."", ""java.util.concurrent"")"
The call() method is called in order to execute the asynchronous task.,"(""Call"", ""The Call method is used to execute the asynchronous task."", ""Asynchronous Task"")"
The call() method can also thrown an Exception in case the task fails during execution.,"(""Call"", ""The Call method can throw an Exception if the task fails during execution."", ""Exception"")"
The result of that is that the call() method will return a String.,"(""CALL"", ""The CALL method returns a STRING, indicating a functional relationship where the method's output is of type STRING."", ""STRING"")"
The call() implementation just returns a String representation of the current time in milliseconds.,"(""CALL"", ""The method CALL returns a STRING representation."", ""STRING"")"
"A Java Callable is different from a Runnable in that the Runnable interface's run() method does not return a value, and it cannot throw checked exceptions (only RuntimeExceptions).","(""Java Callable"", ""Java Callable is compared to Runnable in terms of functionality and behavior."", ""Runnable""); (""Runnable interface"", ""The run() method is part of the Runnable interface."", ""run()"")"
"Additionally, a Runnable was originally designed for long running concurrent execution, e.g.","(""Runnable"", ""class"")"
"Java 5 added a new Java package to the Java platform, the java.util.concurrent package.","(""Java.util.concurrent"", ""The Java.util.concurrent package is a part of the Java package."", ""Java""); (""Java.util.concurrent"", ""The Java.util.concurrent package was added to the Java Platform."", ""Java Platform"")"
This package contains a set of classes that makes it easier to develop concurrent (multithreaded) applications in Java.,"(""package"", ""The package contains a set of classes."", ""classes"")"
"Before this package was added, you would have to program your utility classes yourself.","(""package"", ""The package likely contains or is related to utility classes, as it is mentioned in the context of programming utility classes."", ""utility classes"")"
"In this tutorial I will take you through the new java.util.concurrent classes, one by one, so you can learn how to use them.","(""Java.util.concurrent"", ""The package Java.util.concurrent contains the classes being discussed in the tutorial."", ""Classes"")"
Here is a list of the topics covered in this java.util.concurrent trail.,"(""java.util.concurrent"", ""package"")"
"If you disagree with anything I write here about the java.util.concurrent utilities, or just have comments, questions, etc, feel free to send me an email.","(""Java.util.concurrent"", ""Package"")"
"The Java ExecutorService interface, java.util.concurrent.ExecutorService, represents an asynchronous execution mechanism which is capable of executing tasks concurrently in the background.","(""ExecutorService"", ""ExecutorService is part of the java.util.concurrent package, as indicated by the package name prefix."", ""java.util.concurrent"")"
First an ExecutorService is created using the Executors newFixedThreadPool() factory method.,"(""Executors"", ""The method newFixedThreadPool is a factory method provided by the Executors class."", ""newFixedThreadPool""); (""ExecutorService"", ""The newFixedThreadPool method is used to create an instance of the ExecutorService class."", ""newFixedThreadPool"")"
"Second, an anonymous implementation of the Runnable interface is passed to the execute() method.","(""Runnable"", ""Runnable is implemented and passed to the execute method as an argument."", ""execute"")"
"In fact, the implementation of the ExecutorService interface present in the java.util.concurrent package is a thread pool implementation.","(""ExecutorService"", ""The ExecutorService class is implemented within the java.util.concurrent package."", ""java.util.concurrent"")"
"However, you can use the Executors factory class to create ExecutorService instances too.","(""Executors"", ""The Executors class is used to create instances of the ExecutorService class."", ""ExecutorService"")"
"The Java ExecutorService execute(Runnable) method takes a java.lang.Runnable object, and executes it asynchronously.","(""ExecutorService"", ""The execute method is a part of the ExecutorService class."", ""execute""); (""execute"", ""The execute method takes a Runnable object as a parameter."", ""Runnable""); (""Runnable"", ""The Runnable class is part of the java.lang package."", ""java.lang"")"
The submit() method returns a Java Future object which can be used to check when the Runnable has completed.,"(""Submit"", ""The Submit method returns a Future object."", ""Future""); (""Future"", ""The Future object is used to check when the Runnable has completed."", ""Runnable"")"
"The invokeAny() method takes a collection of Callable objects, or subinterfaces of Callable.","(""InvokeAny"", ""The InvokeAny method takes a collection of Callable objects, indicating a functional relationship where InvokeAny operates on Callable instances."", ""Callable"")"
"If one Callable finishes, so that a result is returned from invokeAny(), then the rest of the Callable instances are cancelled.","(""invokeAny"", ""The method invokeAny() operates on instances of the class Callable, as it returns a result from one of the Callable instances."", ""Callable"")"
The invokeAll() method invokes all of the Callable objects you pass to it in the collection passed as parameter.,"(""InvokeAll"", ""The InvokeAll method is used to invoke all of the Callable objects passed to it."", ""Callable"")"
The invokeAll() returns a list of Future objects via which you can obtain the results of the executions of each Callable.,"(""invokeAll"", ""The method invokeAll returns a list of Future objects."", ""Future""); (""invokeAll"", ""The method invokeAll executes each Callable."", ""Callable"")"
The main difference between the Runnable run() method and the Callable call() method is that the call() method can return an Object from the method call.,"(""Runnable"", ""The run() method is associated with the Runnable class."", ""run()""); (""Callable"", ""The call() method is associated with the Callable class."", ""call()""); (""run()"", ""Both run() and call() are methods that are compared in terms of their functionality."", ""call()"")"
"Another difference between call() and run() is that call() can throw an exception, whereas run() cannot (except for unchecked exceptions - subclasses of RuntimeException).","(""Call"", ""Call and Run are both methods being compared in terms of exception handling."", ""Run""); (""Call"", ""Call can throw exceptions, including unchecked exceptions which are subclasses of RuntimeException."", ""RuntimeException""); (""Run"", ""Run cannot throw exceptions, except for unchecked exceptions which are subclasses of RuntimeException."", ""RuntimeException"")"
You can cancel a task (Runnable or Callable) submitted to a Java ExecutorService by calling the cancel() method on the Future returned when the task is submitted.,"(""ExecutorService"", ""A Future object is returned when a task is submitted to an ExecutorService."", ""Future""); (""Future"", ""The cancel() method is called on a Future object to cancel a task."", ""cancel"")"
Here is an example of cancelling a task by calling the Future.cancel() method:,"(""Future"", ""The cancel method is called on the Future class to cancel a task."", ""cancel"")"
"If your application is started via a main() method and your main thread exits your application, the application will keep running if you have an active ExexutorService in your application.","(""Main"", ""The main method can start an application that uses an ExecutorService to manage threads."", ""ExecutorService"")"
To terminate the threads inside the ExecutorService you call its shutdown() method.,"(""ExecutorService"", ""The shutdown method is called on the ExecutorService class to terminate its threads."", ""shutdown"")"
"All tasks submitted to the ExecutorService before shutdown() is called, are executed.","(""ExecutorService"", ""The method 'shutdown' is called on the class 'ExecutorService' to stop accepting new tasks."", ""shutdown"")"
"If you want to shut down the ExecutorService immediately, you can call the shutdownNow() method.","(""ExecutorService"", ""The shutdownNow method is used to shut down the ExecutorService immediately."", ""shutdownNow"")"
"The ExecutorService awaitTermination() method will block the thread calling it until either the ExecutorService has shutdown completely, or until a given time out occurs.","(""ExecutorService"", ""The awaitTermination method is a function that operates on the ExecutorService class, blocking the thread until the ExecutorService has shut down or a timeout occurs."", ""awaitTermination"")"
The awaitTermination() method is typically called after calling shutdown() or shutdownNow().,"(""AwaitTermination"", ""The awaitTermination() method is typically called after calling the shutdown() method."", ""Shutdown""); (""AwaitTermination"", ""The awaitTermination() method is typically called after calling the shutdownNow() method."", ""ShutdownNow"")"
"The ForkJoinPool located in the java.util.concurrent package, so the full class name is java.util.concurrent.ForkJoinPool.","(""ForkJoinPool"", ""ForkJoinPool is a class located within the java.util.concurrent package."", ""java.util.concurrent"")"
These two types of tasks are represented by the RecursiveAction and RecursiveTask classes.,"(""RECURSIVEACTION"", ""Both are types of tasks represented by classes in the context provided."", ""RECURSIVETASK"")"
"If the workLoad is above a certain threshold, the work is split into subtasks which are also scheduled for execution (via the .fork() method of the subtasks.","(""FORK"", ""The FORK method is used to schedule the execution of SUBTASKS."", ""SUBTASKS"")"
The class MyRecursiveTask extends RecursiveTask<Long> which means that the result returned from the task is a Long .,"(""MyRecursiveTask"", ""MyRecursiveTask is a subclass of RecursiveTask, indicating inheritance."", ""RecursiveTask"")"
"The MyRecursiveTask example also breaks the work down into subtasks, and schedules these subtasks for execution using their fork() method.","(""MyRecursiveTask"", ""The fork() method is used by the MyRecursiveTask class to schedule subtasks for execution."", ""fork"")"
"Additionally, this example then receives the result returned by each subtask by calling the join() method of each subtask.","(""join"", ""The join method is called on each subtask to receive the result returned by it."", ""subtask"")"
Notice how you get the final result out from the ForkJoinPool.invoke() method call.,"(""ForkJoinPool"", ""The invoke method is called on the ForkJoinPool class to get the final result."", ""invoke"")"
"A Java Future, java.util.concurrent.Future, represents the result of an asynchronous computation.","(""Future"", ""The class Future is part of the package java.util.concurrent, indicating it is defined within this package."", ""java.util.concurrent"")"
"To obtain the result, you call one of the two get() methods on the Future.","(""Future"", ""The get() method is called on the Future class to obtain the result."", ""get"")"
"The get() methods both return an Object, but the return type can also be a generic return type (meaning an object of a specific class, and not just an Object).","(""GET"", ""The GET method returns an Object, indicating a relationship where the method outputs an instance of the class."", ""OBJECT"")"
Here is an example of obtaining the result from a Java Future via its get() method:,"(""Future"", ""The get method is used to obtain the result from a Future object."", ""get"")"
"If you call the get() method before the asynchronous task has completed, the get() method will block until the result is ready.","(""GET"", ""The GET method is mentioned twice in the text, indicating its repeated use or importance in the context of blocking until the result is ready."", ""GET"")"
There is a version of the get() method which can time out after an amount of time has passed which you can specify via method parameters.,"(""Get"", ""The text describes a version of the get() method, indicating that 'get' is a method."", ""Method"")"
You can cancel the asynchronous task represented by a Java Future instance by calling the Future cancel() method.,"(""Future"", ""The cancel method is called on a Future instance to cancel the asynchronous task it represents."", ""cancel"")"
Here is an example of canceling a task via the Java Future cancel() method:,"(""Future"", ""The cancel method is used to cancel a task associated with the Future class."", ""cancel""); (""Java"", ""The Future class is part of the Java package."", ""Future"")"
You can check if the asynchronous task is done (and a result available) by calling the Future isDone() method.,"(""Future"", ""The isDone method is called on the Future class to check if the asynchronous task is completed."", ""isDone"")"
Here is an example of calling the Java Future isDone() method:,"(""Future"", ""The isDone method is a member of the Future class, indicating it is a method that can be called on instances of Future."", ""isDone"")"
"The Java Lock interface, java.util.concurrent.locks.Lock, represents a concurrent lock which can be used to guard against race conditions inside critical sections.","(""Lock"", ""The Lock class is part of the java.util.concurrent.locks package, indicating it is defined within this package."", ""java.util.concurrent.locks"")"
You must create an instance of a class that implements the Lock interface.,"(""Lock"", ""The text implies that the Lock is an interface, which is a type of class in object-oriented programming."", ""Lock"")"
The java.util.concurrent.locks package has the following implementations of the Lock interface:,"(""Java.util.concurrent.locks"", ""The Lock class is implemented within the Java.util.concurrent.locks package."", ""Lock"")"
In the following sections I will explain how to use the ReentrantLock class as a Lock.,"(""ReentrantLock"", ""ReentrantLock is a class that is used as a Lock."", ""Lock"")"
"To create an instance of the ReentrantLock class you simply use the new operator, like this:","(""ReentrantLock"", ""The new operator is used to create an instance of the ReentrantLock class."", ""new operator"")"
To lock the Lock instance you must call its lock() method.,"(""Lock"", ""The lock() method is a function that belongs to the Lock class, indicating that it is used to perform an action on instances of the Lock class."", ""lock()"")"
To unlock the Lock instance you must call its unlock() method.,"(""Lock"", ""The unlock method is used to unlock the Lock class instance."", ""unlock"")"
Any other thread calling lock() will be blocked until the thread that locked the lock calls unlock().,"(""Lock"", ""The Lock method is related to the Unlock method because a thread that calls Lock will block other threads until it calls Unlock."", ""Unlock"")"
"Finally unlock() is called, and the Lock is now unlocked so other threads can lock it.","(""Unlock"", ""The method Unlock is called on the class Lock to change its state to unlocked."", ""Lock"")"
"If you look at the example in the previous section, imagine what happens if an exception is thrown between the call to lock.lock() and lock.unlock() .","(""LOCK"", ""The method lock() is called on the class Lock, indicating a relationship between the method and the class."", ""LOCK""); (""LOCK"", ""The methods lock() and unlock() are related as they are typically used together to manage locking mechanisms."", ""UNLOCK"")"
"The exception would interrupt the program flow, and the call to lock.unlock() would never be executed.","(""lock"", ""The method 'unlock' is related to 'lock' as it is called on the 'lock' object to release it."", ""unlock"")"
"To better understand how using a Lock looks different from using a synchronized block, I have created two simple concurrent Counter classes which protects their internal count in different ways.","(""Lock"", ""The Lock class is used to protect the internal count in the Counter class, indicating a relationship where Lock provides synchronization functionality to Counter."", ""Counter"")"
"The first class uses a synchronized block, and the second class uses a Java Lock:","(""First Class"", ""The First Class uses a Synchronized Block."", ""Synchronized Block""); (""Second Class"", ""The Second Class uses a Java Lock."", ""Java Lock"")"
Notice that the CounterLock class is longer than the CounterSynchronized class.,"(""CounterLock"", ""Both are classes being compared in terms of length."", ""CounterSynchronized"")"
"Notice how the calculate() method both locks the Calculator instance's Lock before performing any calculations, and also call the add() and subtract() methods which also locks the lock.","(""Calculate"", ""The Calculate method is associated with the Calculator class as it operates on its instance."", ""Calculator""); (""Calculate"", ""The Calculate method locks the Lock class instance before performing calculations."", ""Lock""); (""Add"", ""The Add method locks the Lock class instance when called."", ""Lock""); (""Subtract"", ""The Subtract method locks the Lock class instance when called."", ""Lock"")"
The ReentrantLock class has a constructor that takes a boolean parameter specifying whether the ReentrantLock should provide fairness or not to waiting threads.,"(""ReentrantLock"", ""The ReentrantLock class has a constructor that initializes it."", ""constructor"")"
"Please note, that the method tryLock() (covered later in this Java Lock tutorial) with no parameters does not respect the fairness mode of the ReentrantLock.","(""tryLock"", ""The method tryLock is a part of the ReentrantLock class."", ""ReentrantLock"")"
"If the Lock instance is already locked, the thread calling lock() is blocked until the Lock is unlocked.","(""Lock"", ""The method lock() is associated with the Lock class as it is used to lock the Lock instance."", ""lock""); (""Lock"", ""The Lock class is mentioned in the context of being locked and unlocked, indicating its role in the locking mechanism."", ""Lock"")"
The lockInterruptibly() method locks the Lock unless the thread calling the method has been interrupted.,"(""LockInterruptibly"", ""The LockInterruptibly method is used to lock the Lock class unless the calling thread is interrupted."", ""Lock"")"
"The tryLock(long timeout, TimeUnit timeUnit) works like the tryLock() method, except it waits up the given timeout before giving up trying to lock the Lock.","(""tryLock"", ""The tryLock method is used to attempt to lock the Lock class."", ""Lock""); (""tryLock"", ""The tryLock method uses the TimeUnit class to specify the timeout duration."", ""TimeUnit"")"
The Java ReentrantLock getHoldCount() method returns the number of times a given thread has locked this Lock instance.,"(""ReentrantLock"", ""The getHoldCount() method is a member of the ReentrantLock class."", ""getHoldCount""); (""getHoldCount"", ""The getHoldCount() method operates on a Lock instance."", ""Lock"")"
The ReentrantLock getQueueLength() method returns the number of threads waiting to lock the Lock.,"(""ReentrantLock"", ""The getQueueLength method is a part of the ReentrantLock class."", ""getQueueLength""); (""getQueueLength"", ""The getQueueLength method returns the number of threads waiting to lock the Lock class."", ""Lock"")"
"The ReentrantLock hasQueuedThreads() method returns true if any threads are queued up waiting to lock this Lock, and false if not.","(""ReentrantLock"", ""The hasQueuedThreads method is a member of the ReentrantLock class."", ""hasQueuedThreads""); (""ReentrantLock"", ""ReentrantLock is a type of Lock."", ""Lock"")"
"The ReentrantLock isFair() method returns true if this Lock guarantees fairness among threads waiting to lock it, and false if not.","(""ReentrantLock"", ""The isFair method is a part of the ReentrantLock class."", ""isFair""); (""ReentrantLock"", ""ReentrantLock is a type of Lock."", ""Lock"")"
"The ReentrantLock isHeldByCurrentThread() method returns true if the Lock is held (locked) by the thread calling isHeldByCurrentThread(), and false if not.","(""ReentrantLock"", ""The method isHeldByCurrentThread() is a part of the ReentrantLock class."", ""isHeldByCurrentThread""); (""isHeldByCurrentThread"", ""The method isHeldByCurrentThread() checks if the Lock is held by the current thread."", ""Lock"")"
"The ReentrantLock isLocked() method returns true if the Lock is currently locked, and false if not.","(""isLocked"", ""The isLocked method is a part of the ReentrantLock class."", ""ReentrantLock""); (""isLocked"", ""The isLocked method checks if the Lock is currently locked."", ""Lock"")"
"If no upper bound is specified, Integer.MAX_VALUE is used as the upper bound.","(""Integer.MAX_VALUE"", ""Integer.MAX_VALUE is used as the default upper bound when no upper bound is specified."", ""upper bound"")"
All elements inserted into the PriorityBlockingQueue must implement the java.lang.Comparable interface.,"(""PriorityBlockingQueue"", ""Elements in PriorityBlockingQueue must implement the java.lang.Comparable interface"", ""java.lang.Comparable"")"
Notice that the PriorityBlockingQueue does not enforce any specific behaviour for elements that have equal priority (compare() == 0).,"(""PriorityBlockingQueue"", ""PriorityBlockingQueue is a class that uses the compare() method to determine the priority of its elements."", ""compare()"")"
"The java.util.concurrent.ScheduledExecutorService is an ExecutorService which can schedule tasks to run after a delay, or to execute repeatedly with a fixed interval of time in between each execution.","(""ScheduledExecutorService"", ""ScheduledExecutorService is a type of ExecutorService, as it extends its functionality to schedule tasks."", ""ExecutorService""); (""ScheduledExecutorService"", ""ScheduledExecutorService is part of the java.util.concurrent package."", ""java.util.concurrent"")"
Then an anonymous implementation of the Callable interface is created and passed to the schedule() method.,"(""Callable"", ""The Callable class is used as an argument to the schedule() method, indicating a relationship where Callable is utilized by schedule."", ""schedule"")"
"Since ScheduledExecutorService is an interface, you will have to use its implementation in the java.util.concurrent package, in order to use it.","(""ScheduledExecutorService"", ""ScheduledExecutorService is implemented in the java.util.concurrent package."", ""java.util.concurrent"")"
"However, you can use the Executors factory class to create ScheduledExecutorService instances too.","(""Executors"", ""The Executors class is used to create instances of the ScheduledExecutorService class."", ""ScheduledExecutorService"")"
"This method works like the method version taking a Callable as parameter, except a Runnable cannot return a value, so the ScheduledFuture.get() method returns null when the task is finished.","(""Method"", ""The method version takes a Callable as a parameter."", ""Callable""); (""Method"", ""The method version can also take a Runnable as a parameter."", ""Runnable""); (""ScheduledFuture.get"", ""The ScheduledFuture.get() method is related to the method as it returns null when the task is finished."", ""Method"")"
This method works very much like scheduleAtFixedRate() except that the period is interpreted differently.,"(""method"", ""The text describes how the method works similarly to scheduleAtFixedRate, indicating a functional relationship."", ""scheduleAtFixedRate"")"
"In the scheduleAtFixedRate() method the period is interpreted as a delay between the start of the previous execution, until the start of the next execution.","(""scheduleAtFixedRate"", ""The text describes the scheduleAtFixedRate as a method, indicating its function and behavior."", ""method"")"
You shut down a ScheduledExecutorService using the shutdown() or shutdownNow() methods which are inherited from the ExecutorService interface.,"(""ScheduledExecutorService"", ""The shutdown() method is used to shut down a ScheduledExecutorService."", ""shutdown()""); (""ScheduledExecutorService"", ""The shutdownNow() method is used to shut down a ScheduledExecutorService."", ""shutdownNow()""); (""ScheduledExecutorService"", ""ScheduledExecutorService inherits methods from the ExecutorService interface."", ""ExecutorService"")"
For each call to acquire() a permit is taken by the calling thread.,"(""acquire"", ""The method 'acquire' is related to 'permit' as it involves taking a permit by the calling thread."", ""permit"")"
For each call to release() a permit is returned to the semaphore.,"(""RELEASE"", ""The method RELEASE is used to return a permit to the SEMAPHORE class."", ""SEMAPHORE"")"
"Thus, at most N threads can pass the acquire() method without any release() calls, where N is the number of permits the semaphore was initialized with.","(""Acquire"", ""Acquire and Release are methods related to semaphore operations, where Acquire is used to obtain a permit and Release is used to free a permit."", ""Release"")"
"If you use a semaphore to send signals between threads, then you would typically have one thread call the acquire() method, and the other thread to call the release() method.","(""Semaphore"", ""The Acquire method is used in conjunction with the Semaphore class to manage thread synchronization."", ""Acquire""); (""Semaphore"", ""The Release method is used in conjunction with the Semaphore class to manage thread synchronization."", ""Release"")"
"If no permits are available, the acquire() call will block until a permit is released by another thread.","(""acquire"", ""The acquire() method is related to permits as it blocks until a permit is released."", ""permit"")"
"Similarly, a release() calls is blocked if no more permits can be released into this semaphore.","(""release"", ""The method 'release' is related to the class 'semaphore' because it is a function that operates on or is part of the semaphore class."", ""semaphore"")"
"For instance, if acquire was called after Thread 1 had inserted an object in a shared list, and Thread 2 had called release() just before taking an object from that list, you had essentially created a blocking queue.","(""acquire"", ""The method 'acquire' is likely used within the context of a 'Thread' to manage synchronization."", ""Thread""); (""release"", ""The method 'release' is likely used within the context of a 'Thread' to manage synchronization."", ""Thread""); (""acquire"", ""The methods 'acquire' and 'release' are related as they are both used for synchronization purposes, likely in a threading context."", ""release"")"
"That is, there is no guarantee that the first thread to call acquire() is also the first thread to obtain a permit.","(""Acquire"", ""The method 'Acquire' is related to 'Permit' as it is used to obtain a permit."", ""Permit"")"
"If you want to enforce fairness, the Semaphore class has a constructor that takes a boolean telling if the semaphore should enforce fairness.","(""Semaphore"", ""The constructor is a method of the Semaphore class used to initialize it."", ""constructor"")"
Calling this class a queue is a bit of an overstatement.,"(""Queue"", ""The text refers to 'this class' as a queue, indicating that 'Queue' is the name of the class being discussed."", ""Queue"")"
"However, unless you need to specify all these parameters explicitly for your ThreadPoolExecutor, it is often easier to use one of the factory methods in the java.util.concurrent.Executors class, as shown in the ExecutorService text.","(""java.util.concurrent.Executors"", ""The factory methods are part of the java.util.concurrent.Executors package."", ""factory methods""); (""ThreadPoolExecutor"", ""The factory methods can be used to create or configure a ThreadPoolExecutor."", ""factory methods""); (""ExecutorService"", ""The factory methods are used in the context of ExecutorService."", ""factory methods"")"
"A Java Certificate class instance contains name plus other details of the entity it identifies, plus possibly a digital signature from a Certificate Authority (CA).","(""Certificate"", ""A Certificate may contain a digital signature from a Certificate Authority, indicating a relationship between the two entities."", ""Certificate Authority"")"
"The Java Certificate class is an abstract class, so while you may use Certificate as variable type, your variable will always point to a subclass of Certificate.","(""Certificate"", ""Certificate is an abstract class, implying it has subclasses."", ""subclass"")"
The Java Certificate class has one subclass - the X509Certificate class.,"(""Java Certificate"", ""The X509Certificate class is a subclass of the Java Certificate class."", ""X509Certificate"")"
This class represents an X.509 certificate which is used as identity certificate in HTTPS and TLS.,"(""X.509 Certificate"", ""X.509 Certificate is used as an identity certificate in HTTPS."", ""HTTPS""); (""X.509 Certificate"", ""X.509 Certificate is used as an identity certificate in TLS."", ""TLS"")"
The Java Certificate getEncoded() method returns an encoded version of the Certificate as a byte array.,"(""getEncoded"", ""The getEncoded method is a function that operates on the Certificate class to return an encoded version of it."", ""Certificate""); (""Certificate"", ""The Certificate class is part of the Java package."", ""Java"")"
"For instance, if the Certificate is an X509Certificate the returned byte array will contain an X.590 (ASN.1 DER) encoded version of the Certificate instance.","(""Certificate"", ""The Certificate class can be an instance of the X509Certificate class."", ""X509Certificate""); (""Certificate"", ""The Certificate instance is converted into a byte array."", ""byte array"")"
The Java Certificate getPublicKey() method returns the PublicKey of this Certificate instance.,"(""getPublicKey"", ""The getPublicKey method returns an instance of the PublicKey class."", ""PublicKey""); (""getPublicKey"", ""The getPublicKey method is a method of the Certificate class."", ""Certificate""); (""Certificate"", ""The Certificate class contains a method that returns a PublicKey instance."", ""PublicKey"")"
The Java Certificate getType() method returns the type of the Certificate instance.,"(""getType"", ""The getType method is a function that operates on the Certificate class to return its type."", ""Certificate""); (""Java"", ""The Certificate class is part of the Java package."", ""Certificate"")"
The Java CertificateFactory class (java.security.cert.CertificateFactory) is capable of creating Java Certificate instances from binary certificate encodings like X.509 (ASN.1 DER).,"(""CertificateFactory"", ""The CertificateFactory class is part of the java.security.cert.CertificateFactory package."", ""java.security.cert.CertificateFactory""); (""CertificateFactory"", ""The CertificateFactory class is capable of creating Certificate instances."", ""Certificate"")"
"To read more about the Java Certificate class, see the Java Certificate tutorial.","(""Java Certificate"", ""The Java Certificate tutorial likely contains information or instructions related to the Java Certificate class."", ""Java Certificate tutorial"")"
See the Java CertPath tutorial for more information about the CertPath class.,"(""CertPath"", ""The text mentions the CertPath class in the context of a Java tutorial, indicating that CertPath is a class related to Java."", ""CertPath"")"
This example creates a CertificateFactory instance capable of creating X.509 certificate instances (X509Certificate - a subclass of Certificate).,"(""X509Certificate"", ""X509Certificate is a subclass of Certificate, indicating an inheritance relationship."", ""Certificate""); (""CertificateFactory"", ""CertificateFactory is capable of creating instances of X509Certificate, indicating a creation relationship."", ""X509Certificate"")"
You create a CertPath instance by calling the CertificateFactory generateCertPath() method.,"(""CertificateFactory"", ""The generateCertPath method is called on the CertificateFactory class to create a CertPath instance."", ""generateCertPath""); (""generateCertPath"", ""The generateCertPath method is used to create an instance of the CertPath class."", ""CertPath"")"
"The Java CertPath class (java.security.cert.CertPath represents a chain of cryptographic identity certificates (Java Certificate objects), where each certificate is the digital signer of the next certificate in the chain.","(""CertPath"", ""CertPath is a class within the java.security.cert package"", ""java.security.cert"")"
The Java CertPath class is typically used to verify an identity certificate along with the certificates of the Certificate Authorities (CAs) that signed the certificate.,"(""CertPath"", ""CertPath is used to verify certificates, which are signed by Certificate Authorities"", ""Certificate Authorities""); (""CertPath"", ""CertPath is used to verify an identity certificate"", ""certificate"")"
Once you have a Java CertPath instance you can obtain the Certificate instances the CertPath consists of by calling the CertPath getCertificates() method.,"(""CertPath"", ""The getCertificates method is called on a CertPath instance to obtain Certificate instances."", ""getCertificates""); (""CertPath"", ""The CertPath consists of Certificate instances."", ""Certificate"")"
The CertPath getType() method returns a string telling what type of certificates (e.g.,"(""CertPath"", ""The getType method is a function that belongs to the CertPath class, indicating it operates on or is associated with CertPath."", ""getType"")"
Here is an example of obtaining the CertPath type via getType():,"(""CertPath"", ""The method getType() is used to obtain the CertPath type."", ""getType"")"
That is why the Java class is called Cipher and not e.g.,"(""Java"", ""Java is the class that contains or is related to the Cipher class."", ""Cipher"")"
This Java Cipher tutorial will explain how the Cipher class of the Java Cryptography API works.,"(""Cipher"", ""The Cipher class is part of the Java Cryptography API package."", ""Java Cryptography API"")"
Before you can use a Java Cipher you just create an instance of the Cipher class.,"(""Cipher"", ""The Cipher method is used to create an instance of the Cipher class."", ""Cipher"")"
You create a Cipher instance by calling its getInstance() method with a parameter telling what type of encryption algorithm you want to use.,"(""Cipher"", ""The getInstance method is used to create an instance of the Cipher class."", ""getInstance"")"
There are several overridden versions of both update() and doFinal() which takes different parameters.,"(""UPDATE"", ""Both UPDATE and DOFINAL are methods mentioned in the context of having overridden versions."", ""DOFINAL"")"
"If you have to encrypt or decrypt a single block of data, just call the doFinal() with the data to encrypt or decrypt.","(""doFinal"", ""The method doFinal is used to encrypt or decrypt the data."", ""data"")"
"If you have to encrypt or decrypt multiple blocks of data, e.g.",NULL
"multiple blocks from a large file, you call the update() once for each block of data, and finish with a call to doFinal() with the last data block.","(""UPDATE"", ""The methods UPDATE and DOFINAL are related because they are both called in sequence to process data blocks, with UPDATE handling each block and DOFINAL finalizing the process."", ""DOFINAL"")"
"The reason a call to doFinal() is needed for the last block of data is, that some encryption algorithms need to pad the the data to fit a certain cipher block size (e.g.","(""doFinal"", ""The method doFinal is related to encryption algorithms as it is used for processing the last block of data, which may require padding to fit a certain cipher block size."", ""encryption algorithms"")"
"Hence the calls to update() for intermediate blocks of data, and the call to doFinal() for the last block of data.","(""UPDATE"", ""Both methods are used in sequence to process blocks of data, with update() handling intermediate blocks and doFinal() handling the last block."", ""DOFINAL"")"
"When decrypting multiple blocks of data you also call the Cipher update() method for intermediate data blocks, and the doFinal() method for the last block.","(""Cipher"", ""The update method is called on the Cipher class for processing intermediate data blocks."", ""update""); (""Cipher"", ""The doFinal method is called on the Cipher class for processing the last data block."", ""doFinal"")"
The Java Cipher class encryption and decryption methods can encrypt or decrypt part of the data stored in a byte array.,"(""Cipher"", ""The Cipher class includes the encryption method for processing data."", ""encryption""); (""Cipher"", ""The Cipher class includes the decryption method for processing data."", ""decryption"")"
You simply pass an offset and length to the update() and / or doFinal() method.,"(""UPDATE"", ""Both UPDATE and DOFINAL are methods mentioned in the context of passing an offset and length, suggesting they are related in functionality."", ""DOFINAL"")"
You can encrypt or decrypt data into an existing byte array by passing the destination byte array as parameter to the update() and / or doFinal() method.,NULL
If you want to set a different offset for the dest byte array there is a version of update() and doFinal() which takes an offset parameter extra.,"(""update"", ""Both methods have a version that takes an offset parameter for the destination byte array."", ""doFinal"")"
Here is an example of calling the doFinal() method with an offset into the dest array:,"(""dofinal"", ""The doFinal method is called with an offset into the dest array, indicating a direct interaction between the method and the array."", ""dest array"")"
"When you call the doFinal() method on a Cipher instance, the Cipher instance is returned to the state it had just after initialization.","(""DoFinal"", ""The DoFinal method is a function that is called on an instance of the Cipher class."", ""Cipher"")"
Notice the call to update() and then doFinal() for these two blocks of data.,"(""UPDATE"", ""The methods UPDATE and DOFINAL are called sequentially to process blocks of data."", ""DOFINAL"")"
This is done with the doFinal() call with the third data block.,"(""doFinal"", ""The method doFinal is called with the data block as an argument."", ""data block"")"
After this doFinal() call you can encrypt yet another block of data with the same Java Cipher instance.,"(""doFinal"", ""The method doFinal is a function that is called on the Cipher class to perform encryption."", ""Cipher""); (""Cipher"", ""The class Cipher is part of the Java package, indicating it is a component of the Java programming environment."", ""Java"")"
JCA is structured around some central general purpose classes and interfaces.,"(""JCA"", ""JCA is structured around classes, indicating a relationship where JCA contains or utilizes these classes."", ""classes""); (""JCA"", ""JCA is structured around interfaces, indicating a relationship where JCA contains or utilizes these interfaces."", ""interfaces"")"
"Thus, you may use a Cipher class to encrypt and decrypt some data, but the concrete cipher implementation (encryption algorithm) depends on the concrete provider used.","(""Cipher"", ""The Cipher class is used to encrypt data."", ""encrypt""); (""Cipher"", ""The Cipher class is used to decrypt data."", ""decrypt"")"
The most commonly used of these classes are covered throughout the rest of this Java Cryptography tutorial.,"(""Java Cryptography"", ""The classes are part of the Java Cryptography package, as mentioned in the tutorial context."", ""classes"")"
The Provider (java.security.Provider) class is a central class in the Java cryptography API.,"(""Provider"", ""The Provider class is a specific implementation of the java.security.Provider class."", ""java.security.Provider""); (""Provider"", ""The Provider class is a central class in the Java cryptography API."", ""Java cryptography API"")"
"The Cipher class is explained in more detail in the text on the Java Cipher class, but I will give a brief introduction to the Cipher class in the following sections.","(""Cipher"", ""The Cipher class is part of the Java package as it is mentioned in the context of Java."", ""Java"")"
"The Cipher.getInstance(...) method take a String identifying which encryption algorithm to use, as well as a few other configurations of the algorithm.","(""Cipher"", ""The getInstance method is a part of the Cipher class, as it is used to obtain an instance of a Cipher object."", ""getInstance"")"
"To initialize a Cipher instance to decrypt data you have to use the Cipher.DECRYPT_MODE, like this:","(""Cipher"", ""DECRYPT_MODE is a method used to initialize a Cipher instance for decryption"", ""DECRYPT_MODE"")"
You do so by calling the Cipher update() or doFinal() methods.,"(""Cipher"", ""The update method is a function that belongs to the Cipher class."", ""update""); (""Cipher"", ""The doFinal method is a function that belongs to the Cipher class."", ""doFinal"")"
The update() method is used if you are encrypting or decrypting part of a bigger chunk of data.,"(""Update"", ""The term 'update()' is explicitly referred to as a method in the text."", ""Method"")"
"The doFinal() method is called when you are encrypting the last part of the big chunk of data, or if the block you pass to doFinal() represents the complete data block to encrypt.","(""doFinal"", ""The method doFinal is mentioned twice in the context of encrypting data, indicating its role in the encryption process."", ""doFinal"")"
Here is an example of encrypting some data with the doFinal() method,"(""DOFINAL"", ""The doFinal() method is used to encrypt some data."", ""ENCRYPTING SOME DATA"")"
To decrypt data you would have passed cipher text (encrypted data) into the doFinal() or doUpdate() method instead.,"(""DOFINAL"", ""Both are methods used for processing data in the decryption process."", ""DOUPDATE"")"
"The example in the previous section about the Cipher class used a very simple, hardcoded key.","(""Cipher"", ""The text refers to the Cipher class, indicating its use in the example."", ""Cipher"")"
You can use the Java KeyGenerator class to generate more random encryption keys.,"(""KeyGenerator"", ""The KeyGenerator class is part of the Java programming language."", ""Java"")"
"The resulting SecretKey instance can be passed to the Cipher.init() method, like this:","(""SecretKey"", ""The SecretKey instance is used with the Cipher class."", ""Cipher""); (""Cipher"", ""The init method is a part of the Cipher class."", ""init"")"
To generate an asymmetric key pair you can use the KeyPairGenerator (java.security.KeyPairGenerator).,"(""KeyPairGenerator"", ""KeyPairGenerator is part of the java.security.KeyPairGenerator package"", ""java.security.KeyPairGenerator"")"
The KeyStore class is quite advanced so it is described in more detail in its own Java KeyStore Tutorial.,"(""KeyStore"", ""The KeyStore class is described in more detail in the Java KeyStore Tutorial."", ""Java KeyStore Tutorial"")"
You can use the Java MessageDigest (java.security.MessageDigest) to calculate message digests.,"(""Java MessageDigest"", ""Java MessageDigest is a class that is part of the java.security.MessageDigest package"", ""java.security.MessageDigest"")"
In order to calculate a message digest of some data you call the update() or digest() method.,"(""Update"", ""Both are methods used to calculate a message digest of some data."", ""Digest"")"
"The update() method can be called multiple times, and the message digest is updated internally.","(""Update"", ""The update() method is related to the message digest as it updates the digest internally when called."", ""Message Digest"")"
"When you have passed all the data you want to include in the message digest, you call digest() and get the resulting message digest data out.","(""digest"", ""The method 'digest' is used to obtain the resulting message digest data."", ""message digest"")"
Here is an example of calling update() several times followed by a digest() call:,"(""Update"", ""The methods Update and Digest are related as they are both mentioned in the context of being called in sequence."", ""Digest"")"
You can also call digest() a single time passing all the data to calculate the message digest from.,"(""digest"", ""The method 'digest()' is related to 'digest' as it is a specific invocation or usage of the method."", ""digest()"")"
The Java Mac class is used to create a MAC from a message.,"(""Java Mac"", ""The Java Mac class is used to create a MAC from a message, indicating a functional relationship between the two classes."", ""MAC"")"
"The Mac class is described in more detail in the Java Mac tutorial, but below is a short introduction.","(""Mac"", ""The Mac class is part of the Java package as indicated by the context of the tutorial."", ""Java"")"
"You create a Java Mac instance by calling the Mac.getInstance() method, passing as parameter the name of the algorithm to use.","(""Java Mac"", ""The Mac.getInstance() method is used to create an instance of the Java Mac class."", ""Mac.getInstance()"")"
Once the Mac instance is initialized you can calculate a MAC from data by calling the update() and doFinal() method.,"(""Mac"", ""The update method is called on the Mac class to calculate a MAC from data."", ""update""); (""Mac"", ""The doFinal method is called on the Mac class to complete the MAC calculation."", ""doFinal"")"
"If you have all the data to calculate the MAC for, you can call the doFinal() method immediately.","(""DOFINAL"", ""The text mentions calling the doFinal() method, indicating that doFinal is a method."", ""METHOD"")"
"If you only have the access to the data in separate blocks, call update() multiple times with the data, and finish off with a call to doFinal().","(""UPDATE"", ""The methods UPDATE and DOFINAL are related because they are both part of a process for handling data in separate blocks, where UPDATE is called multiple times followed by a call to DOFINAL to complete the process."", ""DOFINAL"")"
You do so by calling the initSign(...) method passing the private key to use to sign the data.,"(""initSign"", ""The initSign method requires the private key as a parameter to sign the data."", ""private key"")"
You do so by calling update() passing the data to sign as parameter.,"(""update"", ""The method 'update' is called with 'data' as a parameter, indicating a relationship where 'data' is an input to the 'update' method."", ""data"")"
You can call the update() method several times with more data to include when creating the signature.,"(""Update"", ""The term 'update()' is explicitly referred to as a method in the text."", ""method"")"
When all the data has been passed to the update() method you call the sign() method to obtain the digital signature.,"(""UPDATE"", ""The SIGN method is called after the UPDATE method to obtain the digital signature, indicating a sequential relationship in the process."", ""SIGN"")"
This is done by calling the initVerify(...) method passing as parameter the public key to use to verify the signature.,"(""INITVERIFY"", ""The INITVERIFY method requires the PUBLIC KEY as a parameter to verify the signature."", ""PUBLIC KEY"")"
"Once initialized into verification mode, you call the update() method with the data the signature is signing, and finish with a call to verify() which returns true or false depending on whether the signature could be verified or not.","(""UPDATE"", ""The UPDATE method is followed by the VERIFY method to complete the verification process."", ""VERIFY"")"
Here is a full example of both creating and verifying a digital signature with the Signature class:,"(""Signature"", ""The text describes creating and verifying a digital signature using the Signature class."", ""Signature"")"
The Java KeyGenerator class (javax.crypto.KeyGenerator) is used to generate symmetric encryption keys.,"(""KeyGenerator"", ""The KeyGenerator class is part of the javax.crypto.KeyGenerator package, indicating a hierarchical relationship where the class is contained within the package."", ""javax.crypto.KeyGenerator"")"
Before you can use the Java KeyGenerator class you must create a KeyGenerator instance.,"(""KeyGenerator"", ""The KeyGenerator class is instantiated using the create method."", ""create"")"
You create a KeyGenerator instance by calling the static method getInstance() passing as parameter the name of the encryption algorithm to create a key for.,"(""KeyGenerator"", ""The method getInstance() is used to create an instance of the KeyGenerator class."", ""getInstance"")"
Initializing a KeyGenerator instance is done by calling its init() method.,"(""KeyGenerator"", ""The init() method is used to initialize an instance of the KeyGenerator class."", ""init"")"
"The KeyGenerator init() method takes two parameters: The bit size of the keys to generate, and a SecureRandom that is used during key generation.","(""KeyGenerator"", ""The init() method is a method of the KeyGenerator class."", ""init""); (""init"", ""The init() method uses SecureRandom as a parameter during key generation."", ""SecureRandom"")"
Generating a key is done by calling the KeyGenerator generateKey() method.,"(""KeyGenerator"", ""The generateKey method is a function of the KeyGenerator class."", ""generateKey"")"
You can access the PublicKey of a KeyPair by calling its getPublic() method.,"(""KeyPair"", ""The getPublic method is called on a KeyPair to access its PublicKey."", ""getPublic""); (""getPublic"", ""The getPublic method returns a PublicKey."", ""PublicKey"")"
You can access the PrivateKey of a KeyPair by calling the getPrivate() method.,"(""KeyPair"", ""The PrivateKey is a component of the KeyPair."", ""PrivateKey""); (""getPrivate"", ""The getPrivate() method is used to access the PrivateKey."", ""PrivateKey""); (""getPrivate"", ""The getPrivate() method is called on a KeyPair to retrieve its PrivateKey."", ""KeyPair"")"
The Java KeyPairGenerator class (java.security.KeyPairGenerator) is used to generate asymmetric encryption / decryption key pairs.,"(""KeyPairGenerator"", ""The KeyPairGenerator class is part of the java.security.KeyPairGenerator package."", ""java.security.KeyPairGenerator"")"
Creating a KeyPairGenerator instance is done by calling the method getInstance() method.,"(""KeyPairGenerator"", ""The method getInstance() is used to create an instance of the KeyPairGenerator class."", ""getInstance"")"
The getInstance() method takes the name of the encryption algorithm to generate the key pair for.,"(""getInstance"", ""The getInstance method takes the name of the encryption algorithm as a parameter."", ""encryption algorithm"")"
To generate a KeyPair with a KeyPairGenerator you call the generateKeyPair() method.,"(""KeyPairGenerator"", ""The generateKeyPair method is called on the KeyPairGenerator class to generate a KeyPair."", ""generateKeyPair""); (""generateKeyPair"", ""The generateKeyPair method is used to generate a KeyPair."", ""KeyPair"")"
This makes the KeyStore class a useful mechanism to handle encryption keys securely.,"(""KeyStore"", ""The KeyStore class is used to handle encryption keys securely."", ""encryption keys"")"
You can create a Java KeyStore instance by calling its getInstance() method.,"(""Java KeyStore"", ""The getInstance method is called on the Java KeyStore class to create an instance."", ""getInstance"")"
It is also possible to create other types of KeyStore instance by passing a different parameter to the getInstance() method.,"(""KeyStore"", ""The getInstance method is used to create instances of the KeyStore class by passing different parameters."", ""getInstance"")"
That is why the KeyStore class assumes that you must read its data in before you can use it.,"(""KeyStore"", ""The KeyStore class requires that its data be read before it can be used."", ""read"")"
Loading the KeyStore data from a file or other storage is done by calling the KeyStore load() method.,"(""KeyStore"", ""The load method is called on the KeyStore class to load data from a file or other storage."", ""load"")"
This example loads the KeyStore file located in the keystore.ks file.,"(""KeyStore"", ""The KeyStore class is used to load the keystore.ks file."", ""file"")"
You can get the keys of a Java KeyStore instance via its getEntry() method.,"(""Java KeyStore"", ""The getEntry method is used to access entries within a Java KeyStore instance."", ""getEntry"")"
"Thus, to access a key you must pass the key alias and password to the getEntry() method.","(""getEntry"", ""The getEntry method requires the key alias as a parameter to access a key."", ""key alias""); (""getEntry"", ""The getEntry method requires the password as a parameter to access a key."", ""password"")"
"If you know that the key entry you want to access is a private key, you can cast the KeyStore.Entry instance to a KeyStore.PrivateKeyEntry.","(""KeyStore.Entry"", ""KeyStore.Entry can be cast to KeyStore.PrivateKeyEntry when accessing a private key"", ""KeyStore.PrivateKeyEntry"")"
"After casting to a KeyStore.PrivateKeyEntry you can access the private key, certificate and certificate chain via these methods:","(""KeyStore.PrivateKeyEntry"", ""The private key can be accessed through the KeyStore.PrivateKeyEntry class."", ""private key""); (""KeyStore.PrivateKeyEntry"", ""The certificate can be accessed through the KeyStore.PrivateKeyEntry class."", ""certificate""); (""KeyStore.PrivateKeyEntry"", ""The certificate chain can be accessed through the KeyStore.PrivateKeyEntry class."", ""certificate chain"")"
"Sometimes you may want to store a KeyStore to some storage (disk, database etc.)","(""KeyStore"", ""KeyStore is stored in some form of storage such as disk or database."", ""storage"")"
"To execute it, open a command line (cmd, console, shell etc.).",NULL
This Keytool -delete command will remove the KeyStore entry with the alias testkey from the KeyStore stored in the file keystore.jks .,"(""Keytool"", ""The delete method is a command used by the Keytool class."", ""delete""); (""KeyStore"", ""The KeyStore class is stored in the keystore.jks package."", ""keystore.jks"")"
"Once generated, the certificate request should be sent to the CA you want to create a certificate for you (e.g.","(""Certificate Request"", ""The Certificate Request is sent to the CA to create a certificate."", ""CA"")"
"This command will generate a certificate request for the key stored with alias testkey in the keystore file keystore.jks, and write the certificate request into the file named certreq.certreq .","(""Testkey"", ""Testkey is an alias for a key stored in the keystore file."", ""Keystore""); (""Certreq"", ""Certreq is the file where the certificate request is written, related to the keystore."", ""Keystore"")"
The Java Mac (javax.crypto.Mac class can create a Message Authentication Code (MAC) from binary data.,"(""Java Mac"", ""The Java Mac is referred to as the javax.crypto.Mac class, indicating they are the same entity."", ""javax.crypto.Mac""); (""javax.crypto.Mac"", ""The javax.crypto.Mac class is used to create a Message Authentication Code (MAC), showing a functional relationship."", ""Message Authentication Code"")"
Before you can use the Java Mac class you must create a Mac instance.,"(""Java"", ""The Mac class is part of the Java package."", ""Mac""); (""Mac"", ""A Mac instance is an instance of the Mac class."", ""Mac instance"")"
The String parameter passed to the Mac getInstance() method contains the name of the MAC algorithm to use.,"(""Mac"", ""The getInstance method is associated with the Mac class as it is a method that belongs to or is used by this class."", ""getInstance""); (""String"", ""The getInstance method takes a String parameter, indicating a relationship where the method uses the String class."", ""getInstance"")"
You initialize the Mac instance by calling its init() method passing as parameter the secret key to be used by the Mac instance.,"(""Mac"", ""The init method is called to initialize the Mac class instance."", ""init"")"
To calculate a MAC value you call the Mac update() or doFinal() method.,"(""Mac"", ""The update method is called on the Mac class to calculate a MAC value."", ""update""); (""Mac"", ""The doFinal method is called on the Mac class to calculate a MAC value."", ""doFinal"")"
"If you only have a single block of data to calculate the MAC for, you can call doFinal() directly, like this:","(""doFinal"", ""The method doFinal is used to calculate the MAC for a block of data."", ""MAC"")"
"If you have multiple blocks of data to calculate the MAC for, e.g.",NULL
"if you are reading a file block by block, then you must call the update() method with each block, and finish with a call to doFinal().","(""UPDATE"", ""The UPDATE method is called with each block when reading a file, and the process is finished with a call to the DOFINAL method."", ""DOFINAL"")"
The Java MessageDigest class represents a cryptographic hash function which can calculate a message digest from binary data.,"(""Java MessageDigest"", ""The Java MessageDigest class represents a cryptographic hash function."", ""cryptographic hash function"")"
This tutorial only explains how to use the Java Cryptography API representation of a message digest in the MessageDigest class.,"(""Java Cryptography API"", ""The MessageDigest class is part of the Java Cryptography API, which provides cryptographic operations."", ""MessageDigest"")"
To create a Java MessageDigest instance you call the static getInstance() method of the MessageDigest class.,"(""getInstance"", ""The getInstance method is a static method of the MessageDigest class used to create an instance of it."", ""MessageDigest"")"
The text parameter passed to the getInstance() method is the name of the concrete message digest algorithm to use.,"(""GetInstance"", ""The 'text' parameter is passed to the 'getInstance' method."", ""Text"")"
"If you have a single block of data to calculate a message digest from, use the digest() method.","(""Digest"", ""The text refers to the digest() method as a way to calculate a message digest from a single block of data."", ""Digest"")"
"If you have multiple blocks of data to include in the same message digest, call the update() method and finish off with a call to digest().","(""UPDATE"", ""The update method is used to include multiple blocks of data in the message digest, and the digest method is called to complete the process."", ""DIGEST"")"
The Java Signature class (java.security.Signature) can create a digital signature for binary data.,"(""Signature"", ""The Signature class is part of the java.security.Signature package, indicating a containment or organizational relationship."", ""java.security.Signature"")"
Before you can use the Java Signature class you must create a Signature instance.,"(""Signature"", ""The method 'create' is used to instantiate an object of the 'Signature' class."", ""create"")"
You create a Signature instance by calling the static getInstance() method.,"(""Signature"", ""The getInstance method is used to create an instance of the Signature class."", ""getInstance"")"
The String passed as parameter to the getInstance() method is the name of the digital signature algorithm to use.,"(""getInstance"", ""The getInstance method takes a String as a parameter, which specifies the name of the digital signature algorithm to use."", ""String"")"
"You create a digital signature by calling the update() method one or more times, finishing with a call to sign().","(""UPDATE"", ""The UPDATE method is used in conjunction with the SIGN method to create a digital signature."", ""SIGN"")"
Therefore I have put together this little trail on Java's date and time classes.,"(""Java"", ""The date and time classes are part of the Java package."", ""date and time"")"
Hopefully that will help you get an overview of Java's date and time classes.,"(""Java"", ""Date is a class that is part of the Java package."", ""Date""); (""Java"", ""Time is a class that is part of the Java package."", ""Time"")"
I also hope it may clear up some of the confusion Sun has created with Java's many date and time classes.,"(""Sun"", ""Sun is associated with Java as it is the company that created Java."", ""Java""); (""Java"", ""Date is a class within the Java package."", ""Date""); (""Java"", ""Time is a class within the Java package."", ""Time""); (""Date"", ""Date and Time are both classes related to handling date and time functionalities in Java."", ""Time"")"
"Actually, the Java date time API has been changed (cleaned up) in Java 8 with the introduction of a whole new set of classes.","(""Java Date Time API"", ""The Java Date Time API was updated in Java 8."", ""Java 8""); (""Java 8"", ""Java 8 introduced a new set of classes."", ""Classes"")"
The new Java date time API is located in the Java package java.time which is part of the standard Java 8 class library.,"(""java.time"", ""The java.time package is part of the Java package."", ""Java""); (""java.time"", ""The java.time package is part of the standard Java 8 class library."", ""Java 8"")"
You will see this new date and time representation in many of the classes in the new Java date time API.,"(""Java"", ""The date and time representation is part of the Java package, as mentioned in the context of the new Java date time API."", ""date and time representation"")"
The java.time package also contains a set of subpackages which contain more utilities etc.,"(""Java.Time"", ""The Java.Time package contains a set of subpackages."", ""Subpackages"")"
"For instance the java.time.chrono contains classes to work with Japanese, Thai, Taiwanese and Islamic calendars.","(""Java.Time.Chrono"", ""The package Java.Time.Chrono contains the class Japanese for working with Japanese calendars."", ""Japanese""); (""Java.Time.Chrono"", ""The package Java.Time.Chrono contains the class Thai for working with Thai calendars."", ""Thai""); (""Java.Time.Chrono"", ""The package Java.Time.Chrono contains the class Taiwanese for working with Taiwanese calendars."", ""Taiwanese""); (""Java.Time.Chrono"", ""The package Java.Time.Chrono contains the class Islamic for working with Islamic calendars."", ""Islamic"")"
The java.time.format package contains classes used to parse and format dates from and to strings.,"(""Java.Time.Format"", ""The Parse method is part of the Java.Time.Format package."", ""Parse""); (""Java.Time.Format"", ""The Format method is part of the Java.Time.Format package."", ""Format""); (""Java.Time.Format"", ""The Dates class is part of the Java.Time.Format package."", ""Dates"")"
The core of the Java 8 date time API consists of the following classes:,"(""Java 8 date time API"", ""The Java 8 date time API consists of various classes, indicating a relationship where the API is composed of these classes."", ""classes"")"
Java 7 has the following date and time classes and methods.,"(""Java 7"", ""The class 'date' is part of the Java 7 package."", ""date""); (""Java 7"", ""The class 'time' is part of the Java 7 package."", ""time""); (""Java 7"", ""The methods are part of the Java 7 package."", ""methods""); (""date"", ""The methods are associated with the 'date' class."", ""methods""); (""time"", ""The methods are associated with the 'time' class."", ""methods"")"
"Each of these classes are also explained in their own pages, later.","(""Classes"", ""class"")"
If you need to do simple timing the System.currentTimeMillis() method will do just fine.,"(""System"", ""The currentTimeMillis method is a static method of the System class."", ""currentTimeMillis"")"
"If you just need an object to hold a date, for instance as a property in a simple domain model object, you can use the java.util.Date class.","(""Java.util.Date"", ""The Java.util.Date class is part of the Java.util package."", ""Java.util"")"
"If you need to read and write the date and time to a database, use the java.sql.Date and java.sql.Timestamp classes.","(""Java.Sql.Date"", ""Both classes are used for handling date and time in database operations."", ""Java.Sql.Timestamp"")"
"If you need to do date calculations like adding days or months to another date, or check what weekday (monday, tuesday etc.)",NULL
"a given date is, or convert dates and times between time zones, use the java.util.Calendar and java.util.GregorianCalendar classes.","(""Java.util.Calendar"", ""Both are classes used for handling dates and times in Java."", ""Java.util.GregorianCalendar"")"
The Java DateTimeFormatter class is used to parse and format dates represented with the classes in the Java 8 date time API.,"(""DateTimeFormatter"", ""The DateTimeFormatter class is part of the Java package, as it is used within the Java 8 date time API."", ""Java""); (""DateTimeFormatter"", ""The DateTimeFormatter class is used to parse and format dates, which is a functionality provided by the Java 8 date time API."", ""Java"")"
The DateTimeFormatter is located in the java.time.format package so the fully qualified class name is java.time.format.DateTimeFormatter.,"(""DateTimeFormatter"", ""The DateTimeFormatter class is located in the java.time.format package."", ""java.time.format"")"
The DateTimeFormatter class contains a set of predefined (constant) instances which can parse and format dates from standard date formats.,"(""DateTimeFormatter"", ""The DateTimeFormatter class is related to the parse method as it can parse dates."", ""parse""); (""DateTimeFormatter"", ""The DateTimeFormatter class is related to the format method as it can format dates."", ""format"")"
You can read about them in the JavaDoc for the DateTimeFormatter class.,"(""DateTimeFormatter"", ""The DateTimeFormatter class is documented in the JavaDoc."", ""JavaDoc"")"
Once you have an instance of a DateTimeFormatter you can format a date using its format() method.,"(""DateTimeFormatter"", ""The format method is used to format a date and is a method of the DateTimeFormatter class."", ""format"")"
A Duration object (java.time.Duration) represents a period of time between two Instant objects.,"(""Duration"", ""A Duration object represents a period of time between two Instant objects, indicating a relationship between these two classes."", ""Instant""); (""Duration"", ""The Duration class is part of the java.time package, indicating a package-class relationship."", ""java.time"")"
The Duration class was added to the Java date time API from Java 8.,"(""Duration"", ""The Duration class is part of the Java package."", ""Java""); (""Duration"", ""The Duration class is a component of the date time API."", ""date time API""); (""date time API"", ""The date time API was introduced in Java 8."", ""Java 8"")"
Creating a Duration object is done using one of the Duration class factory methods.,"(""Duration"", ""The factory methods are used to create instances of the Duration class."", ""factory methods""); (""Duration object"", ""A Duration object is an instance of the Duration class."", ""Duration"")"
Here is an example of how to create a Duration object using the between() method:,"(""Duration"", ""The between() method is used to create a Duration object."", ""between"")"
This is somewhat different from what we are used to with System.getCurrentTimeMillis() where a moment in time (or a period between two moments) is represented as a number of milliseconds.,"(""System"", ""The method getCurrentTimeMillis is a member of the class System."", ""getCurrentTimeMillis"")"
The toNanos() is different from the getNano() in that the getNano() only returns the part of the Duration which is less than one second.,"(""toNanos"", ""Both are methods that deal with nanoseconds in the context of a Duration."", ""getNano""); (""getNano"", ""getNano is a method that returns part of the Duration."", ""Duration""); (""toNanos"", ""toNanos is a method related to the Duration class."", ""Duration"")"
The toNanos() method returns the full time interval converted to nanoseconds.,"(""toNanos"", ""The toNanos method converts the time interval to nanoseconds, indicating a functional relationship."", ""nanoseconds"")"
You might be asking yourself if there is not a toSeconds() method.,"(""toSeconds"", ""method"")"
You can obtain the seconds part of the Duration using the getSeconds() method as explained earlier.,"(""Duration"", ""The getSeconds method is used to obtain the seconds part of the Duration class."", ""getSeconds"")"
The Duration class contains a set of methods you can use to perform calculations based on a Duration object.,"(""Duration"", ""The Duration class contains a set of methods for performing calculations."", ""methods"")"
The Instant class in the Java date time API (java.time.Instant) represents a specific moment on the time line.,"(""Instant"", ""The Instant class is part of the java.time.Instant package, which is a part of the Java date time API."", ""java.time.Instant""); (""Instant"", ""The Instant class is a component of the date time API."", ""date time API""); (""java.time.Instant"", ""The java.time.Instant package is part of the Java package."", ""Java"")"
"Time is measured using 86.400 seconds per day, moving forward from the origin.","(""Time"", ""The method 'seconds' is used to measure time in the class 'Time'."", ""seconds"")"
You create an Instant instance using one of the Instant class factory methods.,"(""Instant"", ""The Instant instance is created using the Instant class."", ""Instant instance""); (""Instant"", ""The factory methods are used to create an instance of the Instant class."", ""factory methods"")"
"For instance, to create an Instant which represents this exact moment of now, call Instant.now(), like this:","(""Instant"", ""The method 'now' is called on the class 'Instant' to create an instance representing the current moment."", ""now"")"
The Instant class also has several methods which can be used to make calculations relative to an Instant.,"(""Instant"", ""The methods are used to perform calculations relative to an Instant class."", ""methods"")"
The LocalDate class in the Java 8 date time API represents a local date which is a date without time zone information.,"(""LocalDate"", ""The LocalDate class is part of the Java 8 date time API."", ""Java 8 date time API"")"
"The LocalDate Java class is located in the java.time package, so its fully qualified class name is java.time.LocalDate.","(""LocalDate"", ""LocalDate is a class located in the java.time package."", ""java.time"")"
Here is an example of creating a LocalDate using the now() method:,"(""LocalDate"", ""The now() method is used to create an instance of the LocalDate class."", ""now"")"
"The LocalDate's of() method creates a LocalDate instance representing a specific day of a specific month of a specific year, but without time zone information.","(""LocalDate"", ""The 'of' method is a part of the LocalDate class, used to create an instance of LocalDate."", ""of"")"
Notice how the getMonth() and getDayOfWeek() methods return an enum instead of an int.,"(""GETMONTH"", ""Both are methods mentioned in the text that return an enum instead of an int."", ""GETDAYOFWEEK"")"
From these enums you can obtain their information as int values by calling their getValue() methods.,"(""getValue"", ""The getValue method is used to obtain information as int values."", ""int values"")"
You can perform a set of simple date calculations with the LocalDate class using one or more of the following methods:,"(""LocalDate"", ""The LocalDate class can use one or more methods to perform date calculations."", ""method"")"
The LocalDateTime class in the Java 8 date time API (java.time.LocalDateTime) represents a local date and time without any time zone information.,"(""LocalDateTime"", ""The LocalDateTime class is part of the java.time package, which is a part of the Java 8 date time API."", ""java.time"")"
You could view the LocalDateTime as a combination of the LocalDate and LocalTime classes of the Java 8 date time API.,"(""LocalDateTime"", ""LocalDateTime is a combination of the LocalDate class."", ""LocalDate""); (""LocalDateTime"", ""LocalDateTime is a combination of the LocalTime class."", ""LocalTime""); (""LocalDateTime"", ""LocalDateTime is part of the Java 8 date time API."", ""Java 8 date time API""); (""LocalDate"", ""LocalDate is part of the Java 8 date time API."", ""Java 8 date time API""); (""LocalTime"", ""LocalTime is part of the Java 8 date time API."", ""Java 8 date time API"")"
Here is an example that shows how to create a LocalDateTime object via the now() method:,"(""now"", ""The now() method is used to create a LocalDateTime object."", ""LocalDateTime"")"
"The parameters to the of() method are year, month, day (of month), hours, minutes, seconds and nanoseconds.","(""OF"", ""The 'of' method takes 'year' as one of its parameters."", ""YEAR""); (""OF"", ""The 'of' method takes 'month' as one of its parameters."", ""MONTH""); (""OF"", ""The 'of' method takes 'day' as one of its parameters."", ""DAY""); (""OF"", ""The 'of' method takes 'hours' as one of its parameters."", ""HOURS""); (""OF"", ""The 'of' method takes 'minutes' as one of its parameters."", ""MINUTES""); (""OF"", ""The 'of' method takes 'seconds' as one of its parameters."", ""SECONDS""); (""OF"", ""The 'of' method takes 'nanoseconds' as one of its parameters."", ""NANOSECONDS"")"
Via the methods that return an enum you can get an int representation of the enum by calling the getValue() of the enum .,"(""METHODS"", ""Methods return an enum, indicating a relationship where methods are used to obtain an enum."", ""ENUM""); (""GETVALUE"", ""The getValue() method is called on the enum, showing a direct interaction between the method and the class."", ""ENUM"")"
The LocalTime class in the Java 8 date time API represents a specific time of day without any time zone information.,"(""LocalTime"", ""The LocalTime class is part of the Java 8 date time API package."", ""Java 8 date time API"")"
"The LocalTime class is immutable, so all calculations on LocalTime objects return a new LocalTime instance.","(""LocalTime"", ""The LocalTime class is mentioned as being immutable and involved in calculations that return a new instance of itself."", ""LocalTime"")"
"There are also other versions of the of() method that only takes hours and minutes, or hours, minutes and seconds as parameters.","(""OF"", ""The text describes different versions of the of() method, indicating variations in its parameters."", ""OF"")"
The LocalTime class contains a set of methods that enable you to perform local time calculations.,"(""LocalTime"", ""The LocalTime class contains a set of methods for performing local time calculations."", ""methods"")"
The static method System.currentTimeMillis() returns the time since January 1st 1970 in milliseconds.,"(""System"", ""The method currentTimeMillis is a static method of the class System."", ""currentTimeMillis"")"
"The returned long value can be used to initialize java.util.Date, java.sql.Date, java.sql.Timestamp and java.util.GregorianCalendar objects.","(""Java.Util.Date"", ""Both are classes that can be initialized using the returned long value."", ""Java.Sql.Date""); (""Java.Util.Date"", ""Both are classes that can be initialized using the returned long value."", ""Java.Sql.Timestamp""); (""Java.Util.Date"", ""Both are classes that can be initialized using the returned long value."", ""Java.Util.GregorianCalendar""); (""Java.Sql.Date"", ""Both are classes that can be initialized using the returned long value."", ""Java.Sql.Timestamp""); (""Java.Sql.Date"", ""Both are classes that can be initialized using the returned long value."", ""Java.Util.GregorianCalendar""); (""Java.Sql.Timestamp"", ""Both are classes that can be initialized using the returned long value."", ""Java.Util.GregorianCalendar"")"
The granularity of the System.currentTimeMillis() method is larger than 1 millisecond.,"(""System"", ""The currentTimeMillis method is part of the System package."", ""currentTimeMillis"")"
Measuring time in Java is easiest to do with the System.currentTimeMillis() method.,"(""System.currentTimeMillis"", ""The System.currentTimeMillis method is used within the Java package to measure time."", ""Java"")"
The variable totalTime will now contain the total time it took to execute the callOperationToTime() method.,"(""callOperationToTime"", ""The method callOperationToTime is executed, and its execution time is stored in the variable totalTime."", ""totalTime"")"
"Because System.currentTimeMillis() does not return the time that accurately, it is a good idea to execute the operation to measure more than once.","(""System"", ""The method currentTimeMillis is a static method of the class System."", ""currentTimeMillis"")"
"Another good reason to repeat the operation to measure a lot of times is to allow the Java virtual machine to load the classes containing the code, JIT-compile it, and perhaps even optimize it.","(""Java Virtual Machine"", ""The Java Virtual Machine is responsible for executing methods like JIT-compile to optimize code execution."", ""JIT-compile"")"
"The calculations listed earlier in this text are rather trivial yet tedious to do, and could be encapsulated in a Timer class.","(""Timer"", ""class"")"
The ZonedDateTime class in the Java 8 date time API represents a date and time with time zone information.,"(""ZonedDateTime"", ""The ZonedDateTime class is part of the Java 8 date time API."", ""Java 8 date time API"")"
The first way is to call the now() method of the ZonedDateTime class.,"(""Now"", ""The Now method is a function that belongs to the ZonedDateTime class."", ""ZonedDateTime"")"
Here is an example of creating a ZonedDateTime object using the now() method:,"(""ZonedDateTime"", ""The now() method is used to create a ZonedDateTime object."", ""now"")"
Another way to create a ZonedDateTime object is to use the of() method which can create a ZonedDateTime object from a concrete date and time.,"(""of"", ""The of() method is used to create a ZonedDateTime object."", ""ZonedDateTime"")"
Here is an example of creating a ZonedDateTime object using the of() method:,"(""ZonedDateTime"", ""The of() method is used to create a ZonedDateTime object."", ""of()"")"
From the enums you can return an int representation of their value using their getValue() methods.,"(""ENUMS"", ""The method getValue() is used to return an int representation of the value of the enums."", ""GETVALUE"")"
The ZonedDateTime class contains a set of methods used for date time calculations.,"(""ZonedDateTime"", ""The ZonedDateTime class contains a set of methods used for date time calculations."", ""methods"")"
The time zones are represented by the ZoneId class as shown in the earlier example.,"(""ZoneId"", ""The ZoneId is a class that represents time zones."", ""class"")"
The parameter passed to the of() method is the ID of the time zone to create a ZoneId for.,"(""OF"", ""The of() method is used to create a ZoneId."", ""ZONEID"")"
"You can find the UTC offset for the desired time zone and create an ID matching it by combining ""UTC"" with the offset (e.g.","(""UTC"", ""The UTC class is used to create an ID by combining it with the offset."", ""ID"")"
"If you need to set a date on a java.sql.PreparedStatement or get a date from a java.sql.ResultSet, you will interact with java.sql.Date.","(""PreparedStatement"", ""PreparedStatement is part of the java.sql package"", ""java.sql""); (""ResultSet"", ""ResultSet is part of the java.sql package"", ""java.sql""); (""Date"", ""Date is part of the java.sql package"", ""java.sql""); (""PreparedStatement"", ""PreparedStatement can be used to set a Date"", ""Date""); (""ResultSet"", ""ResultSet can be used to get a Date"", ""Date"")"
"Actually, java.sql.Date extends java.util.Date, so anything you can do with a java.util.Date you can also do with a java.sql.Date.","(""Java.Sql.Date"", ""Java.Sql.Date extends Java.Util.Date, indicating an inheritance relationship where Java.Sql.Date is a subclass of Java.Util.Date."", ""Java.Util.Date"")"
"The biggest difference between java.sql.Date and java.util.Date is that the java.sql.Date only keeps the date, not the time, of the date it represents.","(""Java.Sql.Date"", ""The text compares the two classes, highlighting the difference in how they handle date and time."", ""Java.Util.Date"")"
"So, for instance, if you create a java.sql.Date using the date and time 2009-12-24 23:20, then the time (23:20) would be cut off.","(""Java.Sql.Date"", ""Java.Sql.Date is a class within the Java.Sql package"", ""Java.Sql"")"
"If you need to keep the time, use a java.sql.Timestamp instead.","(""Timestamp"", ""The class Timestamp is part of the package java.sql, indicating a containment or organizational relationship."", ""java.sql"")"
"If you need to set a date + time on a java.sql.PreparedStatement or get a date + time from a java.sql.ResultSet, you will interact with java.sql.Timestamp.","(""PreparedStatement"", ""PreparedStatement is a class within the java.sql package"", ""java.sql""); (""ResultSet"", ""ResultSet is a class within the java.sql package"", ""java.sql""); (""Timestamp"", ""Timestamp is a class within the java.sql package"", ""java.sql""); (""PreparedStatement"", ""PreparedStatement interacts with Timestamp to set a date + time"", ""Timestamp""); (""ResultSet"", ""ResultSet interacts with Timestamp to get a date + time"", ""Timestamp"")"
"Actually, java.sql.Timestamp extends java.util.Date, so anything you can do with a java.util.Date you can also do with a java.sql.Timestamp.","(""Java.Sql.Timestamp"", ""Java.Sql.Timestamp extends Java.Util.Date, indicating an inheritance relationship between the two classes."", ""Java.Util.Date"")"
"The biggest difference between java.sql.Date and java.sql.Timestamp is that the java.sql.Date only keeps the date, not the time, of the date it represents.","(""Java.Sql.Date"", ""Java.Sql.Date is a class within the Java.Sql package."", ""Java.Sql""); (""Java.Sql.Timestamp"", ""Java.Sql.Timestamp is a class within the Java.Sql package."", ""Java.Sql""); (""Java.Sql.Date"", ""Both Java.Sql.Date and Java.Sql.Timestamp are classes within the same package and are compared in terms of their functionality."", ""Java.Sql.Timestamp"")"
One difference in the java.sql.Timestamp from its superclass java.util.Date is its ability to hold the nanoseconds of a date too.,"(""Java.sql.Timestamp"", ""Java.sql.Timestamp is a subclass of Java.util.Date, indicating an inheritance relationship."", ""Java.util.Date"")"
You can get and set the nanoseconds using the getNanos() and setNanos().,"(""GETNANOS"", ""Both methods are used to manipulate the nanoseconds value."", ""SETNANOS"")"
Java's java.util.Calendar class is used to do date and time arithmetic.,"(""Java.util.Calendar"", ""The Java.util.Calendar class is used to perform date and time arithmetic."", ""Date and Time Arithmetic"")"
"Whenever you have something slightly more advanced than just representing a date and time, this is the class to use.","(""Class"", ""class"")"
"Java only comes with a Gregorian calendar implementation, the java.util.GregorianCalendar class.","(""java.util.GregorianCalendar"", ""The java.util.GregorianCalendar is a specific implementation of the GregorianCalendar class."", ""GregorianCalendar""); (""Java"", ""The java.util.GregorianCalendar class is part of the Java package."", ""java.util.GregorianCalendar"")"
"The Calendar class has a couple of methods you can use to access the year, month, day, hour, minutes, seconds, milliseconds and time zone of a given date.","(""Calendar"", ""The 'year' method is a part of the Calendar class, used to access the year of a given date."", ""year""); (""Calendar"", ""The 'month' method is a part of the Calendar class, used to access the month of a given date."", ""month""); (""Calendar"", ""The 'day' method is a part of the Calendar class, used to access the day of a given date."", ""day""); (""Calendar"", ""The 'hour' method is a part of the Calendar class, used to access the hour of a given date."", ""hour""); (""Calendar"", ""The 'minutes' method is a part of the Calendar class, used to access the minutes of a given date."", ""minutes""); (""Calendar"", ""The 'seconds' method is a part of the Calendar class, used to access the seconds of a given date."", ""seconds""); (""Calendar"", ""The 'milliseconds' method is a part of the Calendar class, used to access the milliseconds of a given date."", ""milliseconds""); (""Calendar"", ""The 'time zone' method is a part of the Calendar class, used to access the time zone of a given date."", ""time zone"")"
The Calendar class has a corresponding set() method so you can set these fields too.,"(""Calendar"", ""The set method is associated with the Calendar class as it allows setting fields within the class."", ""set"")"
"The add() method is really handy when doing date arithmetics like adding or subtracting years, months, days, hours etc.","(""Add"", ""The term 'add()' is explicitly referred to as a method in the text."", ""Method"")"
"To subtract from the fields call the add() method with negative values, like this:","(""Add"", ""The add() method is used to subtract from the fields by calling it with negative values."", ""Fields"")"
There are a few minor traps in the Calendar class that you should be aware of to avoid unnecessary headaches.,"(""Calendar"", ""The text mentions the Calendar class, indicating its relevance."", ""Calendar"")"
The MONTH field of the Calendar class does not go from 1 to 12 like they do when we write dates otherwise.,"(""MONTH"", ""The MONTH field is a part of the Calendar class."", ""Calendar"")"
"That means that 1 = sunday, 2 = monday, ..., 7 = saturday.",NULL
If you need to do heavy or complex date and time calculations it is a good idea to read the class documentation for java.util.Calendar in the official JavaDoc's.,"(""Java.util.Calendar"", ""Java.util.Calendar is a class whose documentation can be found in the JavaDoc package"", ""JavaDoc"")"
The class documentation contains more detail about the specific behaviour of the class.,"(""Class"", ""The text refers to the documentation of the class, indicating a relationship between the class and its documentation."", ""Class"")"
Today most of the methods in the class are deprecated in favor of the java.util.Calendar class.,"(""Methods"", ""Methods are part of the Class"", ""Class""); (""Class"", ""The Class is deprecated in favor of the Java.util.Calendar class"", ""Java.util.Calendar"")"
You can still use the java.util.Date class to represent a date though.,"(""Java.Util.Date"", ""Java.Util.Date is identified as a class in the text."", ""Class"")"
"You can access the date and time contained in a java.util.Date instance using the getTime() method, like this:","(""Java.Util.Date"", ""The GetTime method is used to access the date and time contained in a Java.Util.Date instance."", ""GetTime"")"
"You can also create a java.util.Date from a time in milliseconds, like this:","(""Java.Util.Date"", ""Java.Util.Date can be created from a time in milliseconds, indicating a relationship between the class and the method."", ""Milliseconds"")"
You can compare java.util.Date instance because the class implements the java.lang.Comparable interface.,"(""Java.Util.Date"", ""Java.Util.Date implements the Java.Lang.Comparable interface"", ""Java.Lang.Comparable"")"
"The comparison follows the rules for the Comparable interface, meaning the compareTo() method returns:","(""Comparable"", ""The compareTo() method is part of the Comparable interface, which defines the rules for comparison."", ""compareTo"")"
"The Java TimeZone class is a class that represents time zones, and is helpful when doing calendar arithmetics across time zones.","(""TimeZone"", ""TimeZone is explicitly mentioned as a class in the text."", ""class"")"
The java.util.TimeZone class is used in conjunction with the java.util.Calendar class.,"(""TimeZone"", ""The TimeZone class is part of the java.util package."", ""java.util""); (""Calendar"", ""The Calendar class is part of the java.util package."", ""java.util""); (""TimeZone"", ""The TimeZone class is used in conjunction with the Calendar class."", ""Calendar"")"
Note: In the Java 8 date time API the time zones are represented by the java.time.ZoneId class.,"(""Java 8 Date Time API"", ""The Java.time.ZoneId class is part of the Java 8 Date Time API, representing time zones."", ""Java.time.ZoneId"")"
But you only need to use the ZoneId class if you are using the Java 8 date time classes (like the ZonedDateTime class).,"(""ZoneId"", ""The ZoneId class is part of the Java 8 date time package."", ""Java 8 date time""); (""ZonedDateTime"", ""The ZonedDateTime class is part of the Java 8 date time package."", ""Java 8 date time""); (""ZoneId"", ""Both ZoneId and ZonedDateTime are classes used in the Java 8 date time package."", ""ZonedDateTime"")"
If you use a Calendar (from the Java 7 and earlier date time API) you can still use the java.util.TimeZone class.,"(""Calendar"", ""The Calendar class can use the java.util.TimeZone class for time zone management."", ""java.util.TimeZone""); (""Calendar"", ""The Calendar class is part of the Java 7 and earlier date time API."", ""Java 7"")"
The first method (TimeZone.getDefault()) returns the default time zone for the system (computer) this program is running on.,"(""TimeZone"", ""The method getDefault is a member of the class TimeZone"", ""getDefault"")"
"The second method (TimeZone.getTimeZone(""Europe/Copenhagen"")) returns the TimeZone corresponding to the given time zone ID (in this example ""Europe/Copenhagen"").","(""getTimeZone"", ""The method getTimeZone is a part of the TimeZone class, as it is used to return a TimeZone object."", ""TimeZone"")"
"The getOffset() method returns the offset in milliseconds for the given time zone to UTC, at the given time.","(""GETOFFSET"", ""The text explicitly mentions 'getOffset()' as a method."", ""METHOD"")"
The Calendar class is capable of converting the date and time between time zones.,"(""Calendar"", ""The Calendar class is related to date and time as it is capable of converting them between time zones."", ""date and time"")"
"Here is a list of the available time zone ids in the TimeZone class, printed as returned by TimeZone.getAvailableIDs().","(""TimeZone"", ""The method getAvailableIDs is a function of the TimeZone class, as it is used to retrieve available time zone IDs."", ""getAvailableIDs"")"
"It is possible to both parse dates from strings, and format dates to strings, using Java's java.text.SimpleDateFormat class.","(""SimpleDateFormat"", ""The SimpleDateFormat class is part of the java.text package."", ""java.text"")"
It is also possible to parse and format dates using the newer Java DateTimeFormatter which is able to parse and format dates from and to the newer date time classes added in Java 8.,"(""Java DateTimeFormatter"", ""Java DateTimeFormatter is a class introduced in Java 8 for parsing and formatting dates."", ""Java 8"")"
"Even though both classes for parsing and formatting dates are covered in more detail in their own texts, I will show you a few examples of how to use them below.","(""Parsing"", ""Both are classes related to handling dates, specifically for parsing and formatting."", ""Formatting"")"
Here is an example of how to format and parse a date using the SimpleDateFormat class.,"(""SimpleDateFormat"", ""The method 'format' is used in conjunction with the 'SimpleDateFormat' class to format dates."", ""format""); (""SimpleDateFormat"", ""The method 'parse' is used in conjunction with the 'SimpleDateFormat' class to parse dates."", ""parse"")"
The string passed as parameter to the SimpleDateFormat class is a pattern that tells how the instance is to parse and format dates.,"(""SimpleDateFormat"", ""The string is passed as a parameter to the SimpleDateFormat class, indicating a relationship where the string is used by the class."", ""string""); (""SimpleDateFormat"", ""The pattern is used by the SimpleDateFormat class to parse and format dates, showing a functional relationship."", ""pattern"")"
"For a full list, see the official JavaDoc for the SimpleDateFormat class.","(""SimpleDateFormat"", ""The SimpleDateFormat class is documented in the official JavaDoc."", ""JavaDoc"")"
Another way to format dates is to use the DateTimeFormatter which works with the newer date time classes added in Java 8.,"(""DateTimeFormatter"", ""DateTimeFormatter is a class used in the Java package for formatting dates."", ""Java""); (""DateTimeFormatter"", ""DateTimeFormatter works with the newer date time classes added in Java 8."", ""date time classes"")"
In the example above we use the DateTimeFormatter.BASIC_ISO_DATE instance which is configured to parse and format dates using the ISO date time format.,"(""DateTimeFormatter"", ""BASIC_ISO_DATE is a method or constant of the DateTimeFormatter class"", ""BASIC_ISO_DATE"")"
"Exceptions are regular Java classes that extends java.lang.Exception, or any of the other built-in exception classes.","(""Exceptions"", ""Exceptions are Java classes that extend java.lang.Exception, indicating a subclass relationship."", ""java.lang.Exception""); (""Exceptions"", ""Exceptions are described as regular Java classes, indicating they belong to the Java package."", ""Java"")"
"If a method declares that it throws an exception A, then it is also legal to throw subclasses of A.","(""Method"", ""The method declares that it throws Exception A."", ""Exception A""); (""Method"", ""The method can also legally throw subclasses of Exception A."", ""Subclasses of A""); (""Exception A"", ""Subclasses of A are derived from Exception A."", ""Subclasses of A"")"
"In the example above the ""System.out.println(result);"" statement will not get executed if an exception is thrown fromt the divide method.","(""System"", ""The 'out' method is a member of the 'System' class."", ""out""); (""out"", ""The 'println' method is called on the 'out' method."", ""println""); (""divide"", ""The 'println' method is used to output the result of the 'divide' method."", ""println"")"
"In the example above the ""System.out.println(""Division attempt done"");"" statement will always get executed.","(""System"", ""The 'out' method is a member of the 'System' class, used for output operations."", ""out""); (""out"", ""The 'println' method is called on the 'out' method to print messages to the console."", ""println"")"
Here is how the callDivide() method would look in that case.,"(""CALLDIVIDE"", ""The text explicitly mentions 'callDivide()' as a method."", ""METHOD"")"
"Thus the ""System.out.println(result);"" method will not get executed if an exception is thrown from the divide method.","(""System.out.println"", ""The System.out.println method will not execute if an exception is thrown from the divide method."", ""divide"")"
"If the reader.read() method call throws an IOException, the following System.out.println((char) i ); is not executed.","(""Read"", ""The Read method can throw an IOException, indicating a relationship where the method may result in an exception."", ""IOException""); (""System"", ""System is a package that contains the Out class, indicating a hierarchical relationship."", ""Out""); (""Out"", ""The Println method is part of the Out class, indicating a method-class relationship."", ""Println"")"
"Neither is the last reader.close() or the System.out.println(""--- File End ---""); statements.","(""reader.close()"", ""Both are method calls that are likely used in sequence to close a reader and then print a message indicating the end of a file."", ""System.out.println()"")"
Instead the program skips directly to the catch(IOException e){ ... } catch clause.,"(""catch"", ""The catch method is used to handle exceptions of the IOException class."", ""IOException"")"
"If an exception is thrown from the reader.read() method then program execution is halted, and the exception is passed up the call stack to the method that called openFile().","(""Read"", ""The Read method is called by the OpenFile method."", ""OpenFile""); (""Reader"", ""The Read method is part of the Reader class."", ""Read""); (""Program"", ""The Read method affects the execution of the Program class."", ""Read"")"
"If the calling method also just throws the method on, the calling method is also interrupted at the openFile() method call, and the exception passed on up the call stack.","(""calling method"", ""The calling method is interrupted at the openFile() method call, indicating a direct interaction between the two."", ""openFile"")"
That is why the previous example had the reader.close() method call in the finally block wrapped in a try-catch block:,"(""READER.CLOSE"", ""The method READER.CLOSE is called within a TRY-CATCH BLOCK to handle potential exceptions."", ""TRY-CATCH BLOCK""); (""READER.CLOSE"", ""The method READER.CLOSE is placed in the FINALLY BLOCK to ensure it is executed regardless of whether an exception occurs."", ""FINALLY BLOCK"")"
"That way the System.out.println(""--- File End ---""); method call will always be executed.","(""System.out.println"", ""The method System.out.println is used to print the string '--- File End ---'."", ""File End"")"
Notice how the two exception class names in the first catch block are separated by the pipe character |.,"(""Exception"", ""The Exception class is used within the Catch block to handle exceptions."", ""Catch"")"
The pipe character between exception class names is how you declare multiple exceptions to be caught by the same catch clause.,"(""Exception"", ""The exception class is caught by the catch clause method."", ""Catch Clause"")"
If storeDataFromUrl() wants to call readDataFromUrl() it has only two choices.,"(""StoreDataFromUrl"", ""StoreDataFromUrl calls ReadDataFromUrl as part of its operation"", ""ReadDataFromUrl"")"
Notice how the readDataFromUrl() method no longer declares that it throws BadUrlException.,"(""ReadDataFromUrl"", ""The method ReadDataFromUrl is related to the class BadUrlException because it previously declared that it throws this exception."", ""BadUrlException"")"
"The storeDataFromUrl() method can still choose to catch the exception but it no longer has to, and it no longer has to declare that it propagates the exception.","(""storeDataFromUrl"", ""The method storeDataFromUrl can choose to catch the exception, indicating a relationship between the method and the exception."", ""exception"")"
As you can see the readNumberFromUrl() needs to declare throwing both the BadUrlException and the BadNumberException that are thrown from the readDataFromUrl() and converData() methods.,"(""readNumberFromUrl"", ""The method readNumberFromUrl() declares throwing the BadUrlException."", ""BadUrlException""); (""readNumberFromUrl"", ""The method readNumberFromUrl() declares throwing the BadNumberException."", ""BadNumberException""); (""readDataFromUrl"", ""The method readDataFromUrl() throws the BadUrlException."", ""BadUrlException""); (""readDataFromUrl"", ""The method readDataFromUrl() throws the BadNumberException."", ""BadNumberException""); (""converData"", ""The method converData() throws the BadNumberException."", ""BadNumberException"")"
Imagine how many exceptions would need to be declared at the top level methods of an application with thousands of classes.,"(""methods"", ""Methods are typically part of a class in an application."", ""application""); (""application"", ""An application is composed of multiple classes."", ""classes""); (""methods"", ""Methods are functions that belong to classes."", ""classes"")"
As you can see the readNumberFromUrl() method now only declares throwing ApplicationException.,"(""ReadNumberFromUrl"", ""The method ReadNumberFromUrl declares throwing the class ApplicationException."", ""ApplicationException"")"
Notice how the readNumberFromUrl() method does not declare throwing the ApplicationException even if it throws it.,"(""ReadNumberFromUrl"", ""The method ReadNumberFromUrl throws the ApplicationException."", ""ApplicationException"")"
All exceptions thrown in the application must be a subclass of the base exception.,"(""Exception"", ""Exception is a subclass of Base Exception"", ""Base Exception"")"
As you know a method throwing Exception may also throw any subclass of Exception.,"(""method"", ""A method can throw an Exception, indicating a relationship where the method uses or interacts with the Exception class."", ""Exception""); (""subclass"", ""A subclass is a type of Exception, indicating an inheritance relationship where the subclass extends the Exception class."", ""Exception"")"
They are subclasses of the ApplicationException so they will get propagated up the call stack.,"(""ApplicationException"", ""The subclasses are related to ApplicationException because they inherit from it, indicating a class hierarchy."", ""subclasses"")"
Argument 5 (Pro Unchecked Exceptions) Checked exceptions declared on methods become part of a the class or interface contract.,"(""methods"", ""Methods are part of the class contract."", ""class""); (""methods"", ""Methods are part of the interface contract."", ""interface""); (""Pro Unchecked Exceptions"", ""Pro Unchecked Exceptions is a class."", ""class"")"
The only requirement is that the new exceptions thrown are subclasses of the base exception.,"(""subclasses"", ""Subclasses are derived from the base exception, indicating an inheritance relationship."", ""base exception"")"
Anders Hejlsberg on checked vs. unchecked exceptions http://www.artima.com/intv/handcuffs.html James Gosling on checked exceptions http://www.artima.com/intv/solid.html Bill Venners on Exceptions http://www.artima.com/interfacedesign/exceptions.html Bruce Eckel on checked exceptions http://www.artima.com/intv/typingP.html Designing with Exceptions (Bill Venners - www.artima.com) http://www.artima.com/designtechniques/desexcept.html Effective Java (Joshua Bloch - Addison Wesley 2001) Daniel Pietraru - in favor of checked exceptions Exceptional Java - Checked exceptions are priceless茂驴�?For everything else there is the RuntimeException,"(""Checked Exceptions"", ""Both are types of exceptions discussed in the context of Java programming."", ""Unchecked Exceptions""); (""Checked Exceptions"", ""Checked exceptions and RuntimeException are both types of exceptions in Java."", ""RuntimeException""); (""Checked Exceptions"", ""Checked exceptions are a subset of exceptions."", ""Exceptions""); (""Unchecked Exceptions"", ""Unchecked exceptions are a subset of exceptions."", ""Exceptions""); (""Effective Java"", ""Effective Java discusses the use of checked exceptions."", ""Checked Exceptions""); (""Exceptional Java"", ""Exceptional Java discusses the value of checked exceptions."", ""Checked Exceptions"")"
Checked exceptions declared on methods become part of a the class or interface contract.,"(""Methods"", ""Methods declare checked exceptions as part of their contract."", ""Checked Exceptions""); (""Checked Exceptions"", ""Checked exceptions are part of the class contract."", ""Class""); (""Checked Exceptions"", ""Checked exceptions are part of the interface contract."", ""Interface"")"
As you can see the method1() throws an EnrichableException which is a superclass for enrichable exceptions.,"(""Method1"", ""Method1 throws an EnrichableException"", ""EnrichableException""); (""EnrichableException"", ""EnrichableException is a superclass for enrichable exceptions"", ""EnrichableException"")"
"Notice how method2() calls the addInfo() method on the caught EnrichableException, and rethrow it afterwards.","(""method2"", ""The method2 method calls the addInfo method."", ""addInfo""); (""method2"", ""The method2 method interacts with the EnrichableException class by calling a method on it."", ""EnrichableException""); (""addInfo"", ""The addInfo method is called on the EnrichableException class."", ""EnrichableException"")"
"Notice how method1() adds the code ""ERROR1"" to the thrown EnrichableException to uniquely identify that error cause.","(""METHOD1"", ""METHOD1 adds the code to the thrown EnrichableException to identify the error cause"", ""ENRICHABLEEXCEPTION"")"
But notice too that method1() is called from both method2() and method3().,"(""METHOD1"", ""METHOD1 is called from METHOD2"", ""METHOD2""); (""METHOD1"", ""METHOD1 is called from METHOD3"", ""METHOD3"")"
"Though the error may seem the same to method1() no matter which of method2() and method3() that called it, this may important to know for the developer investigating the error.","(""Method1"", ""Method1 is called by Method2, indicating a direct relationship between the two methods."", ""Method2""); (""Method1"", ""Method1 is called by Method3, indicating a direct relationship between the two methods."", ""Method3"")"
Here is an example where the addInfo() method has been changed to accommodate this:,"(""ADDINFO"", ""The text explicitly mentions 'addInfo()' as a method."", ""METHOD"")"
Two new parameters have been added to the addInfo() method and the constructor of the EnrichableException.,"(""addInfo"", ""The addInfo method is likely a part of the EnrichableException class, as methods are typically associated with classes."", ""EnrichableException""); (""constructor"", ""The constructor is a special method used to initialize objects of the EnrichableException class."", ""EnrichableException"")"
An error identification for an exception thrown by method1() when called from method2() will now look like this:,"(""Method1"", ""Method1 is called from Method2, indicating a direct relationship between the two methods."", ""Method2"")"
When method1() is called from method3() the error identification will look like this:,"(""Method1"", ""Method1 is called from Method3, indicating a direct invocation relationship between the two methods"", ""Method3"")"
As you can see it is now possible to distinguish an exception thrown from method1() via method2() from the same exception thrown from method1() via method3().,"(""METHOD1"", ""Method1 is related to Method2 as exceptions can be thrown from Method1 via Method2."", ""METHOD2""); (""METHOD1"", ""Method1 is related to Method3 as exceptions can be thrown from Method1 via Method3."", ""METHOD3"")"
"Here is an example where method1() catches a non-enrichable exception and wraps it in an enrichable exception, and throws the enrichable exception:","(""METHOD1"", ""METHOD1 catches a non-enrichable exception and wraps it in an enrichable exception, then throws it."", ""METHOD1"")"
Exceptions caught in the program will be passed to the handleException() which will decide what concrete exception to throw instead.,"(""HANDLEEXCEPTION"", ""HANDLEEXCEPTION is responsible for processing EXCEPTIONS caught in the program."", ""EXCEPTIONS""); (""HANDLEEXCEPTION"", ""HANDLEEXCEPTION decides which CONCRETE EXCEPTION to throw."", ""CONCRETE EXCEPTION"")"
If the EnrichableException is unchecked it is not necessary to declare it in the handleException() method.,"(""EnrichableException"", ""The handleException method may handle or process the EnrichableException class."", ""handleException"")"
You may need to change the class definition to suit your own needs.,"(""Class"", ""class"")"
"If an exception is thrown from within the try block, and another exception is thrown from the input.close() call in the finally block, both exceptions are preserved in the MyException instance, and propagated up the call stack.","(""close"", ""The close method is involved in the process where exceptions are preserved in the MyException instance."", ""MyException""); (""MyException"", ""MyException is the class that handles exceptions thrown by the close method."", ""close"")"
"RuntimeExceptions thrown from the try-block are not preserved, if the input.close() call also throws an exception.","(""RuntimeExceptions"", ""RuntimeExceptions are thrown from the try-block."", ""try-block""); (""input.close()"", ""The input.close() method is called within the try-block."", ""try-block""); (""RuntimeExceptions"", ""RuntimeExceptions are not preserved if input.close() also throws an exception."", ""input.close()"")"
Notice how the process() method calls the doProcess() method inside the try-catch block.,"(""PROCESS"", ""The PROCESS method calls the DOPROCESS method inside the try-catch block."", ""DOPROCESS"")"
"You will use the template by subclassing it, and overriding the doProcess() method.","(""Template"", ""The doProcess method is overridden in the Template class."", ""DoProcess"")"
"This example creates an anonymous subclass of the InputStreamProcessingTemplate class, instantiates an instance of the subclass, and calls its process() method.","(""InputStreamProcessingTemplate"", ""The process method is called on an instance of the InputStreamProcessingTemplate class."", ""process"")"
"You will typically also get more help from your IDE's code completion when writing it, because the IDE will recognize both the doProcess() and process() methods.","(""doProcess"", ""Both are methods mentioned in the text that the IDE will recognize for code completion."", ""process"")"
Instead of subclassing the InputStreamProcessingTempate you could rewrite it to take an instance of an InputStreamProcessor interface.,"(""InputStreamProcessingTempate"", ""The InputStreamProcessingTempate class can be rewritten to use an instance of the InputStreamProcessor interface."", ""InputStreamProcessor"")"
"This is the InputStreamProcessor, which is called from inside the try block (processor.process(input)).","(""InputStreamProcessor"", ""The method 'process' is called on the 'InputStreamProcessor' class."", ""process"")"
"It doesn't look much different from the previous usage, except the call to the InputStreamProcessingTemplate.process() method is now closer to the top of the code.","(""InputStreamProcessingTemplate"", ""The method 'process' is called on the class 'InputStreamProcessingTemplate'."", ""process"")"
Notice how the call to the template's process() method is now a static method call.,"(""Process"", ""The process method is called on the template, indicating a relationship between the two."", ""Template"")"
"The advantage of exception hierarchies is that if you decide to catch (using try-catch) a certain exception in the hierarchy, then you will automatically also catch all subclasses of that exception too.","(""exception hierarchies"", ""Exception hierarchies are composed of multiple exceptions."", ""exception""); (""exception"", ""Subclasses are specific types of exceptions within the hierarchy."", ""subclasses"")"
"In the example with FileNotFoundException, if you catch IOException which is the superclass of FileNotFoundException, you will also catch FileNotFoundException.","(""IOException"", ""IOException is the superclass of FileNotFoundException, indicating an inheritance relationship."", ""FileNotFoundException"")"
"But, multiple catch blocks can also be used in the case where all the exceptions thrown inside the try-block are the same type or subclasses of that type.","(""catch blocks"", ""Catch blocks are used to handle exceptions."", ""exceptions""); (""try-block"", ""Exceptions are thrown inside the try-block."", ""exceptions"")"
"The fact that FileNotFoundException is a subclass of IOException gives us the choice of either treating all IOExceptions the same, or catch some of IOExceptions subclasses individually, as is done in the code example above.","(""FileNotFoundException"", ""FileNotFoundException is a subclass of IOException"", ""IOException"")"
"If the catch(FileNotFoundException e) block is removed any FileNotFoundException will be caught by the catch(IOException e) block, since FileNotFoundException is a subclass of IOException.","(""FileNotFoundException"", ""FileNotFoundException is a subclass of IOException, indicating an inheritance relationship between the two classes."", ""IOException"")"
"If a method can throw either a certain exception A, or any subclasses of A (Asub), then it is enough to declare in the method declaration that the method throws A.","(""Method"", ""The method can throw Exception A, so it is related to Exception A."", ""Exception A""); (""Method"", ""The method can throw subclasses of Exception A, such as Asub, so it is related to Asub."", ""Asub"")"
It is then allowed to throw subclasses of A from the method too.,"(""A"", ""The class A is mentioned as being thrown from the method, indicating a relationship between the class and the method."", ""method"")"
"You are allowed to declare the subclasses in the throws clause of the method, even if you don't really need to.","(""THROWS CLAUSE"", ""The throws clause is part of the method declaration, indicating which exceptions the method might throw."", ""METHOD"")"
"As long as the superclass of any declared exception is also declared thrown, it doesn't have any effect on the code to include the throwing of the subclass.","(""SUPERCLASS"", ""The SUPERCLASS is related to the SUBCLASS because the text discusses the throwing of exceptions where the superclass of any declared exception must also be declared thrown if the subclass is thrown."", ""SUBCLASS"")"
"It is still possible to handle the two exceptions with each their own catch-block as shown earlier, even if only the superclass is declared thrown.",NULL
"If you need more granularity on the exceptions thrown, for instance because you think the exceptions may be handled differently, then add new exceptions as subclasses of your API or application base exception.","(""subclasses"", ""Subclasses are a more specific type of exceptions, indicating a hierarchical relationship where subclasses extend the base class of exceptions."", ""exceptions"")"
"In Mr. Persister we could add a ConnectionOpenException, QueryException, UpdateException, CommitException, and ConnectionCloseException as subclasses of PersistenceException.","(""ConnectionOpenException"", ""ConnectionOpenException is a subclass of PersistenceException"", ""PersistenceException""); (""QueryException"", ""QueryException is a subclass of PersistenceException"", ""PersistenceException""); (""UpdateException"", ""UpdateException is a subclass of PersistenceException"", ""PersistenceException""); (""CommitException"", ""CommitException is a subclass of PersistenceException"", ""PersistenceException""); (""ConnectionCloseException"", ""ConnectionCloseException is a subclass of PersistenceException"", ""PersistenceException"")"
Summary In this text we have seen that exception hierarchies can be created by subclassing exception classes.,"(""Subclassing"", ""Subclassing is a method used to create exception hierarchies."", ""Exception Hierarchies""); (""Subclassing"", ""Subclassing is a method that involves using exception classes."", ""Exception Classes"")"
"It is a good idea to create a base exception for your API or application, and have all other exceptions subclass this base exception.","(""Exception"", ""Exception is a subclass of Base Exception"", ""Base Exception"")"
Individual subclasses makes it possible (but not obligatory) to catch and handle these individual exceptions differently.,"(""Individual subclasses"", ""Individual subclasses are designed to catch and handle exceptions differently."", ""exceptions"")"
In this text we have seen that exception hierarchies can be created by subclassing exception classes.,"(""Subclassing"", ""Subclassing is a method used to create exception hierarchies by extending exception classes."", ""Exception"")"
Exception wrapping is a standard feature in Java since JDK 1.4.,"(""Exception"", ""Exception is a feature in the Java programming language."", ""Java""); (""Exception"", ""Exception is a feature available since JDK 1.4."", ""JDK"")"
They also have a getCause() method that will return the wrapped exception.,"(""getCause"", ""The getCause method is related to the exception as it returns the wrapped exception."", ""exception"")"
"When a request is successfully processed, you can write the whole execution context object to a log file, as a single, coherent structure (e.g.",NULL
"It's implemented as a single class called ExecutionContext, which keeps all calls to it internally in a list.","(""ExecutionContext"", ""ExecutionContext keeps all calls to it internally in a list."", ""list"")"
Notice how each method ( level1() to level3() ) calls the ExecutionContext.,"(""Level1"", ""Level1 method calls the ExecutionContext class"", ""ExecutionContext""); (""Level2"", ""Level2 method calls the ExecutionContext class"", ""ExecutionContext""); (""Level3"", ""Level3 method calls the ExecutionContext class"", ""ExecutionContext"")"
"Therefore, I have developed an ExecutionContextTree class, which can contain this information.","(""ExecutionContextTree"", ""The ExecutionContextTree is mentioned as a class in the text."", ""ExecutionContextTree"")"
"The pre() call creates a new node, and attaches it to the parent node (if any).","(""pre"", ""The method 'pre' creates a new instance of the class 'node'."", ""node""); (""node"", ""The 'node' is attached to the 'parent node', indicating a hierarchical relationship."", ""parent node"")"
"Any calls to pre() after this one, will result in new nodes being attached to the newly created node.","(""PRE"", ""The method 'pre' is called to create or attach new nodes."", ""NODE""); (""NODE"", ""Nodes are the result of calling the 'pre' method."", ""PRE"")"
The post() call removes the node as the current parent in the execution tree.,"(""POST"", ""The POST method interacts with the NODE class by removing it as the current parent in the execution tree."", ""NODE"")"
The next call to pre() will now attach a node to the parent of the node just removed as parent node.,"(""pre"", ""The method 'pre' is responsible for attaching a 'node'."", ""node""); (""node"", ""A 'node' is attached to a 'parent', indicating a hierarchical relationship."", ""parent"")"
"As you can see, the pre() and post() calls are very often insert at the start and end of a method call.","(""PRE"", ""Both PRE and POST are methods that are often inserted at the start and end of a method call, indicating a sequence or complementary relationship."", ""POST"")"
"If the input.close() call fails, and an IOException is thrown, then it is caught, wrapped and rethrown.","(""input.close()"", ""The method input.close() can throw an IOException if it fails."", ""IOException"")"
All classes implementing this interface can be used inside the try-with-resources construct.,"(""Interface"", ""The interface is used within the try-with-resources construct, indicating a relationship between the two."", ""Try-with-resources construct"")"
The Java try-with-resources construct does not just work with Java's built-in classes.,"(""Java"", ""The try-with-resources construct is a feature of the Java programming language."", ""try-with-resources""); (""try-with-resources"", ""The try-with-resources construct is designed to work with Java's built-in classes."", ""Java's built-in classes"")"
"You can also implement the java.lang.AutoCloseable interface in your own classes, and use them with the try-with-resources construct.","(""java.lang.AutoCloseable"", ""The java.lang.AutoCloseable package is used with the try-with-resources class construct."", ""try-with-resources"")"
Any class that implements this interface can be used with the Java try-with-resources construct.,"(""class"", ""The class is used with the Java package in the context of the try-with-resources construct."", ""Java"")"
Here is the output printed to System.out when the method myAutoClosable() is called:,"(""myAutoClosable"", ""The method myAutoClosable() is called and its output is printed to System.out"", ""System.out"")"
"If an exception is thrown both from inside the try-with-resources block, and when a resource is closed (when close() is called), the exception thrown inside the try block will be propagated up the call stack.","(""Close"", ""The method Close is called when a resource is closed within the Try-with-resources block."", ""Try-with-resources block"")"
"In that case, the exception thrown when attempted closed will be propagated up the call stack to the main() method where the try-catch block will catch it.","(""MAIN"", ""The try-catch block is used within the main method to catch exceptions."", ""TRY-CATCH BLOCK"")"
"In that case, the Throwable array returned from e.getSuppessed() will be an empty array (size of 0).","(""e"", ""The method getSuppressed is called on the variable e to retrieve the Throwable array."", ""getSuppressed""); (""Throwable"", ""The method getSuppressed returns an array of Throwable objects."", ""getSuppressed"")"
"In case the parameter to resourceOne.doOp() was changed to true also, the doOp() method would throw an exception.","(""resourceOne"", ""The doOp method is a function that belongs to the resourceOne class, as indicated by the notation resourceOne.doOp()."", ""doOp"")"
"In that case, it is this exception that is propagated up the call stack to the main() method.","(""MAIN"", ""METHOD"")"
The exception thrown when attempting to close the resource would be available inside the Throwable array returned by e.getSuppressed().,"(""e.getSuppressed"", ""The method e.getSuppressed() returns an array of Throwable objects, indicating a direct relationship between the method and the class."", ""Throwable"")"
"However, in the example above I have forced both resources to throw an exception when attempted closed, and the first resource to throw an exception when used (when doOp() is called).","(""DOOP"", ""DOOP is related to EXCEPTION because the method is mentioned to throw an exception when called."", ""EXCEPTION"")"
The two exceptions thrown when attempting to close the resources are available in the Throwable array returned by e.getSuppressed().,"(""e.getSuppressed"", ""The method e.getSuppressed() returns a Throwable array, indicating a relationship between the method and the class."", ""Throwable"")"
"In case an exception is thrown when attempting to close one of the resources, these exceptions will be available from the exception's getSuppressed() method inside the catch block.","(""GETSUPPRESSED"", ""The getSuppressed() method is used inside the catch block to handle exceptions."", ""CATCH BLOCK"")"
"In the example above, the AutoClosableResource is configured to throw an exception both when doOp() is called, and when it is attempted closed (via close()).","(""AutoClosableResource"", ""The method doOp is called on the class AutoClosableResource."", ""doOp""); (""AutoClosableResource"", ""The method close is used to close the class AutoClosableResource."", ""close"")"
"The exception thrown from doOp() is caught in the catch block, its getSuppressed() method returns an array with the exception thrown when the resource was attempted closed.","(""doOp"", ""The getSuppressed method is related to doOp as it returns information about exceptions that were suppressed during the operation performed by doOp."", ""getSuppressed"")"
"The getSuppressed() method of that exception will return an empty array, since no exceptions where suppressed.","(""getSuppressed"", ""The getSuppressed method is related to the exception as it is a method that operates on exceptions to return suppressed exceptions."", ""exception"")"
The Throwable class has a method named addSuppressed() which takes a Throwable object as parameter.,"(""Throwable"", ""The addSuppressed method is a member of the Throwable class."", ""addSuppressed"")"
"Using the addSuppressed() method it is possible to add suppressed exceptions to another exception, in case you need that.","(""addSuppressed"", ""The addSuppressed method is used to add suppressed exceptions to another exception."", ""exception"")"
"To understand why, look at the following method which reads a file and prints it to the System.out:","(""method"", ""The method reads a file and prints it to the System.out, indicating a functional relationship where the method uses System.out for output."", ""System.out"")"
"The InputStream's close() method may throw an exception too, if closing it fails.","(""InputStream"", ""The close method is a function that operates on the InputStream class, likely to close the stream."", ""close"")"
You will have to code your own exception class in order to make exception enrichment possible.,"(""Exception Class"", ""The Exception Class is needed to enable Exception Enrichment."", ""Exception Enrichment"")"
"However, the ExceptionHandler can throw all the unchecked exceptions it wants (RuntimeException and subclasses of it).","(""ExceptionHandler"", ""ExceptionHandler can throw RuntimeException and its subclasses."", ""RuntimeException"")"
"In contrast, inside a DAO class you will most likely not be able to interact with the user to correct the error.","(""DAO"", ""DAO is identified as a type of class in the context of the text."", ""class"")"
In this example the validate() method throws an exception as soon as an validation error is found.,"(""Validate"", ""The Validate method throws an Exception when a validation error is found."", ""Exception"")"
"Notice how it is not necessary to cast the object obtained from the List.get() method call, as is normally necessary.","(""List"", ""The get method is a function that is called on the List class to retrieve an object."", ""get"")"
Notice how it is not necessary to cast the object returned from the iterator.next() next call.,"(""iterator.next()"", ""The 'next' method is called on the 'iterator.next()' method to retrieve the next element."", ""next"")"
"Adding and getting elements to a generic Map is done using the put() and get() methods, just like you have always done:","(""Map"", ""The put method is used to add elements to the Map class."", ""put""); (""Map"", ""The get method is used to retrieve elements from the Map class."", ""get"")"
Also notice how it is not necessary to cast the String instance returned by the get() method.,"(""get"", ""The get method returns an instance of the String class."", ""String"")"
Most often you iterate the key Set and access the values for each key via the Map.get() method.,"(""Map"", ""The get method is used to access values in the Map class."", ""get""); (""Set"", ""The Set is iterated to access keys in the Map."", ""Map"")"
"Adding elements to a generic Set is done using the add() method, just like you have always done:","(""Set"", ""The add method is used to add elements to the Set class."", ""add"")"
Generics is not restricted to the predefined classes in the Java API's.,"(""Generics"", ""Generics is a class that is part of the Java API package."", ""Java API"")"
The <T> is a type token that signals that this class can have a type set when instantiated.,"(""T"", ""T is a type token that signals the class can have a type set when instantiated."", ""class"")"
Notice how it is not necessary to cast the object returned from the factory.createInstance() method.,"(""factory.createInstance"", ""The method factory.createInstance returns an object, indicating a relationship between the method and the object."", ""object"")"
Notice how we can call the addAndReturn() method using both String's and Integer's and their corresponding collections.,"(""addAndReturn"", ""The addAndReturn method can be called using String, indicating a functional relationship."", ""String""); (""addAndReturn"", ""The addAndReturn method can be called using Integer, indicating a functional relationship."", ""Integer"")"
"Java Generic's wildcards is a mechanism in Java Generics aimed at making it possible to cast a collection of a certain class, e.g A, to a collection of a subclass or superclass of A.","(""Java Generics"", ""Wildcards is a mechanism within the Java Generics package."", ""Wildcards""); (""Collection"", ""A collection can be cast to a subclass or superclass of A."", ""A"")"
"In listA you can insert objects that are either instances of A, or subclasses of A (B and C).","(""LISTA"", ""LISTA can contain objects that are instances of A."", ""A""); (""LISTA"", ""LISTA can contain objects that are instances of B, which is a subclass of A."", ""B""); (""LISTA"", ""LISTA can contain objects that are instances of C, which is a subclass of A."", ""C""); (""B"", ""B is a subclass of A."", ""A""); (""C"", ""C is a subclass of A."", ""A"")"
When you then try to take objects out of listB you could risk to get non-B objects out (e.g.,"(""listB"", ""listB contains objects"", ""objects"")"
Thus you could insert non-B objects into a list declared to hold B (or B subclass) instances.,NULL
"Imagine you have a method that processes the elements of a List, e.g.","(""Method"", ""The method processes the elements of the List, indicating a functional relationship where the method operates on the List class."", ""List"")"
The processElements() method can now be called with any generic List as parameter.,"(""processElements"", ""The processElements method can be called with a List as a parameter, indicating a functional relationship between the method and the class."", ""List"")"
"When you know that the instances in the collection are of instances of A or subclasses of A, it is safe to read the instances of the collection and cast them to A instances.","(""A"", ""The text discusses instances of A and subclasses of A, indicating a relationship between the class A and its instances."", ""A"")"
"You can now call the processElements() method with either a List<A>, List<B> or List<C>.","(""ProcessElements"", ""The method ProcessElements can be called with a List."", ""List""); (""List"", ""List is a collection that can contain elements of class A."", ""A""); (""List"", ""List is a collection that can contain elements of class B."", ""B""); (""List"", ""List is a collection that can contain elements of class C."", ""C"")"
"super A> means that the list is typed to either the A class, or a superclass of A.","(""A"", ""The text indicates that the list is typed to either the A class or a superclass of A, suggesting a relationship between A and its superclass."", ""superclass"")"
"When you know that the list is typed to either A, or a superclass of A, it is safe to insert instances of A or subclasses of A (e.g.","(""A"", ""A is a class that can have a superclass"", ""superclass""); (""A"", ""A can have subclasses"", ""subclasses"")"
"All of the elements inserted here are either A instances, or instances of A's superclass.","(""A"", ""A is related to its superclass as it is mentioned that elements can be instances of A or its superclass."", ""superclass"")"
"Since both B and C extend A, if A had a superclass, B and C would also be instances of that superclass.","(""B"", ""B extends A, indicating an inheritance relationship."", ""A""); (""C"", ""C extends A, indicating an inheritance relationship."", ""A"")"
"You can now call insertElements() with either a List<A>, or a List typed to a superclass of A.","(""insertElements"", ""The method insertElements can be called with a List, indicating a functional relationship where the method operates on the List class."", ""List""); (""List"", ""The List is typed to class A, indicating that it holds elements of type A."", ""A""); (""List"", ""The List can also be typed to a superclass of A, indicating a hierarchical relationship where the List can hold elements of a type that is a superclass of A."", ""superclass"")"
"The insertElements() method cannot read from the list though, except if it casts the read objects to Object.","(""insertElements"", ""The insertElements method interacts with the list class by attempting to read from it."", ""list""); (""insertElements"", ""The insertElements method can cast read objects to the Object class."", ""Object"")"
"The elements already present in the list when insertElements() is called could be of any type that is either an A or superclass of A, but it is not possible to know exactly which class it is.","(""insertElements"", ""The method insertElements is related to the class A because it operates on elements that are of type A or its superclass."", ""A"")"
"However, since any class eventually subclass Object you can read objects from the list if you cast them to Object.","(""class"", ""The text mentions that any class eventually subclasses Object, indicating a relationship between a generic class and the Object class."", ""Object"")"
Here are a few examples of calls to the getInstance() method:,"(""getInstance"", ""method"")"
As you can see the return type changes depending on what class object you pass in as parameter to the method.,"(""Class"", ""The method takes a class object as a parameter, indicating a relationship between the class and the method."", ""Method"")"
It is possible to use your own collection type classes with the new for-loop.,"(""collection type"", ""The collection type class can be used with the for-loop method."", ""for-loop"")"
And here is the corresponding implementation skeleton of the MyIterator class:,"(""MyIterator"", ""class"")"
Generics add a way to specify concrete types to general purpose classes and methods that operated on Object before.,"(""Generics"", ""Generics specify concrete types to general purpose classes."", ""classes""); (""Generics"", ""Generics specify concrete types to general purpose methods."", ""methods""); (""classes"", ""Classes operated on Object before."", ""Object""); (""methods"", ""Methods operated on Object before."", ""Object"")"
"Note: Java generics can be used with other classes than the collection classes, but it is easiest to show the basics of Java generics using collections.","(""Java"", ""Java is a programming language that supports generics, which is a feature of the language."", ""generics""); (""generics"", ""Generics can be used with collection classes to define the type of objects they can contain."", ""collection""); (""Java"", ""Java provides collection classes that can utilize generics for type safety."", ""collection"")"
"When you just write a diamond operator as generic type, the Java compiler will assume that the class instantiated is to have the same type as the variable it is assigned to.","(""Diamond Operator"", ""The Java Compiler uses the Diamond Operator to infer the type of the class being instantiated."", ""Java Compiler"")"
This for-loop is shorter than original while-loop where you would iterate the collections Iterator and call Iterator.next() to obtain the next instance.,"(""Iterator"", ""The method 'next' is called on the 'Iterator' class to obtain the next instance."", ""next"")"
It is of course possible to use Generics for other classes than the Java collections.,"(""Generics"", ""Generics can be used for Java collections, indicating a relationship between these two classes."", ""Java collections"")"
"Using Java generics in your own classes is described in more detail in the tutorials about generic classes, generic methods and using class objects as type literals.","(""Generics"", ""Generics are used in the context of creating generic classes."", ""Classes""); (""Generics"", ""Generics are used in the context of creating generic methods."", ""Methods""); (""Java"", ""Java is the programming language in which generics are used."", ""Generics""); (""Java"", ""Java is the programming language in which classes are defined."", ""Classes""); (""Java"", ""Java is the programming language in which methods are defined."", ""Methods"")"
The java.text.DateFormat class is used to format dates as strings according to a specific Locale.,"(""DateFormat"", ""The DateFormat class uses the format method to format dates as strings."", ""format""); (""DateFormat"", ""The DateFormat class is part of the java.text package."", ""java.text""); (""DateFormat"", ""The DateFormat class formats dates according to a specific Locale."", ""Locale"")"
You create a DateFormat using the getDateInstance() and getTimeInstance() method of the DateFormat class.,"(""getDateInstance"", ""The getDateInstance method is used to create a DateFormat."", ""DateFormat""); (""getTimeInstance"", ""The getTimeInstance method is used to create a DateFormat."", ""DateFormat"")"
The date format parameter can be chosen among the following constants in the DateFormat class:,"(""DateFormat"", ""The date format parameter is a part of the DateFormat class, as it is mentioned that the parameter can be chosen among constants in this class."", ""date format parameter"")"
"In order to format only time and not the date itself, you need a time instance of the DateFormat class.","(""DateFormat"", ""A time instance is used with the DateFormat class to format only time and not the date."", ""time instance"")"
The java.text.DecimalFormat class is used to format numbers using a formatting pattern you specify yourself.,"(""DecimalFormat"", ""The DecimalFormat class is used to format numbers, indicating a method relationship."", ""format""); (""DecimalFormat"", ""The DecimalFormat class belongs to the java.text package."", ""java.text"")"
This text explains how to use the DecimalFormat class to format different types of numbers.,"(""DecimalFormat"", ""The DecimalFormat class is used to format different types of numbers."", ""format"")"
You can change this pattern later using the applyPattern() or applyLocalizedPattern() method.,"(""applyPattern"", ""Both are methods mentioned in the text that can be used to change the pattern."", ""applyLocalizedPattern"")"
The applyPattern() method simply applies a new pattern to the DecimalFormat instance as if it were created with that pattern.,"(""ApplyPattern"", ""The ApplyPattern method is used to apply a new pattern to an instance of the DecimalFormat class."", ""DecimalFormat"")"
The applyLocalizedPattern() does the same as applyPattern() except it interpretes the characters in the pattern according to the Locale the DecimalFormat was created with.,"(""applyLocalizedPattern"", ""applyLocalizedPattern is related to applyPattern as it performs a similar function with a difference in character interpretation."", ""applyPattern""); (""applyLocalizedPattern"", ""applyLocalizedPattern uses Locale to interpret characters in the pattern."", ""Locale""); (""DecimalFormat"", ""DecimalFormat is created with a specific Locale, which affects how patterns are interpreted."", ""Locale"")"
You format a number using the format() method of the DecimalFormat instance.,"(""DecimalFormat"", ""The format() method is used to format a number and is a method of the DecimalFormat class."", ""format()"")"
"For a full explanation of what these methods do, see the JavaDoc for the DecimalFormatSymbols class.","(""methods"", ""The methods are part of the DecimalFormatSymbols class."", ""DecimalFormatSymbols""); (""JavaDoc"", ""The JavaDoc provides documentation for the DecimalFormatSymbols class."", ""DecimalFormatSymbols"")"
The DecimalFormat class has a method called setGroupingSize() which sets how many digits of the integer part to group.,"(""DecimalFormat"", ""The method setGroupingSize is a function of the DecimalFormat class."", ""setGroupingSize"")"
"The java.text.BreakIterator class is used to find character, word and sentence boundaries across different languages.","(""BreakIterator"", ""The BreakIterator class is part of the java.text package, as indicated by the naming convention."", ""java.text"")"
You create an instance that can recognize one of the above boundaries using the corresponding factory method in the BreakIterator class.,"(""factory method"", ""The factory method is used to create an instance related to the BreakIterator class."", ""BreakIterator"")"
"A character instance of the BreakIterator class finds character boundaries for user characters, not unicode characters.","(""BreakIterator"", ""The character instance is an instance of the BreakIterator class, indicating a relationship between the two."", ""character instance"")"
"This example creates a BreakIterator targeted at the British language, and sets the text to find character breaks in using the setText() method.","(""BreakIterator"", ""The setText method is used to set the text for the BreakIterator class to find character breaks."", ""setText"")"
"Again, here the first() and next() methods return the unicode index of the found word boundary.","(""FIRST"", ""Both FIRST and NEXT are methods that return the unicode index of the found word boundary."", ""NEXT"")"
"Notice how the isWord() method uses the Character.isLetterOrDigit() method to determine if a character is a letter or digit, or something else (like semicolon, quote etc.).","(""isWord"", ""The isWord method uses the isLetterOrDigit method to determine if a character is a letter or digit."", ""isLetterOrDigit""); (""isLetterOrDigit"", ""The isLetterOrDigit method is part of the Character class."", ""Character"")"
"The Character.isLetterOrDigit() checks according to the unicode characters if a character is a letter or digit - and thus not just in the english language, but also in other languages.","(""Character"", ""The method isLetterOrDigit belongs to the class Character as it is a function that checks properties of characters."", ""isLetterOrDigit"")"
Java has some methods in the java.lang.Character class that are useful in internationalization of Java applications.,"(""java.lang.Character"", ""The methods are part of the java.lang.Character class."", ""methods""); (""Java"", ""The java.lang.Character class is part of the Java package."", ""java.lang.Character"")"
"To safely check if a character is a letter, number or space character you need to use the methods in java.lang.Character to do so.","(""Character"", ""The class Character is part of the package java.lang, as indicated by the text."", ""java.lang"")"
The Character class also has a getType() method which returns the type of a certain character.,"(""Character"", ""The getType method is a function that belongs to the Character class."", ""getType"")"
The returned type is an int which matches a set of predefined constants in the Character class.,"(""int"", ""The returned type 'int' is associated with predefined constants in the 'Character' class."", ""Character"")"
Look in the JavaDoc for the Character class for more constants.,"(""Character"", ""The Character class is documented in the JavaDoc."", ""JavaDoc"")"
The Character class also has a method that enables you to determine if the value of a given int defines a character in unicode.,"(""Character"", ""The method is a function that belongs to the Character class."", ""method"")"
"Thus, simply using the String.compareTo() method may not work for all languages.","(""String"", ""The compareTo method is a method of the String class."", ""compareTo"")"
"To sort a collection of strings according to the rules of a certain Locale, you use a java.text.Collator instance created for that specific Locale.","(""Collator"", ""A Collator instance is created for a specific Locale to sort strings according to its rules."", ""Locale""); (""Collator"", ""Collator is part of the java.text package."", ""java.text"")"
To compare two strings using the Collator instance you call the compare() method.,"(""Collator"", ""The compare method is used with the Collator class to compare two strings."", ""compare"")"
The compare() method returns an int with the same meaning as the String.compareTo() method:,"(""COMPARE"", ""The COMPARE method is related to the STRING.COMPARETO method because it returns an int with the same meaning as the STRING.COMPARETO method."", ""STRING.COMPARETO"")"
A 0 means that the two strings have the same order - e.g.,NULL
There are more rules you can use with the RuleBasedCollator class.,"(""RuleBasedCollator"", ""class"")"
You normalize a string using the static normalize() method of the java.text.Normalizer class.,"(""Normalize"", ""The Normalize method is a static method of the Java.text.Normalizer class."", ""Java.text.Normalizer"")"
The first parameter to the normalize() method is the text to normalize.,"(""NORMALIZE"", ""The normalize() method is related to the text as it is the first parameter to be normalized."", ""TEXT"")"
You can use the String class to convert a byte array to a String instance.,"(""String"", ""The String class is used to convert a byte array to a String instance."", ""byte array"")"
You can convert the text of a String to another format using the getBytes() method.,"(""String"", ""The getBytes() method is used to convert the text of a String to another format."", ""getBytes"")"
The Reader and Writer classes are stream oriented classes that enable a Java application to read and write streams of characters.,"(""Reader"", ""Both are stream oriented classes used in Java applications to handle streams of characters."", ""Writer""); (""Reader"", ""Reader is a class used within Java applications."", ""Java""); (""Writer"", ""Writer is a class used within Java applications."", ""Java"")"
This is done using the second constructor paramter in the InputStreamReader class.,"(""InputStreamReader"", ""The constructor is a method or function used to initialize objects of the InputStreamReader class."", ""constructor"")"
"Input is everything that your application receives from its users, either directly through the user interface, sent to it via service calls (e.g.","(""Input"", ""Input is something that the application receives."", ""Application""); (""User Interface"", ""Input is received directly through the user interface."", ""Input""); (""Service Calls"", ""Input is sent via service calls."", ""Input"")"
"The internationalization layer should convert from whatever character encoding the input comes in (ascii, UTF-8 etc.)",NULL
Java has a set of built-in classes that can help you handle internationalization of your application.,"(""Java"", ""Java is a programming language that provides built-in classes for various functionalities."", ""built-in classes""); (""built-in classes"", ""Built-in classes in Java can be used to handle internationalization."", ""internationalization"")"
Each of these classes are covered in more detail in later texts in this trail.,"(""classes"", ""class"")"
In Java you can convert between time zones using the java.util.Calendar class.,"(""Java"", ""The java.util.Calendar class is part of the Java package, which provides utilities for date and time operations."", ""java.util.Calendar"")"
"Please not, that the Calendar.getTimeInMillis() always returns the time in UTC, regardless of the time zone set on the Calendar instance.","(""Calendar"", ""The method getTimeInMillis is a function of the Calendar class."", ""getTimeInMillis"")"
"As you saw in the example, you get the time zone from the java.util.TimeZone class.","(""TimeZone"", ""The TimeZone class is part of the java.util package."", ""java.util"")"
You can obtain a list of the available time zone ID's using the TimeZone.getAvailableIDs() .,"(""TimeZone"", ""The method getAvailableIDs is a member of the class TimeZone."", ""getAvailableIDs"")"
"This examples obtains all the available time zone ID's, and then prints them to System.out.","(""System.out"", ""System.out is used to print the available time zone ID's"", ""time zone ID's"")"
"I have described the java.util.TimeZone class in more detail in my Java Date Time tutorial, in the TimeZone class.","(""TimeZone"", ""The TimeZone class is part of the java.util package."", ""java.util""); (""TimeZone"", ""The TimeZone class is discussed in the Java Date Time tutorial."", ""Java Date Time"")"
"This Java internationalization tutorial is ""work in progress"", so if you spot a a missing description of a feature etc., please be patient.",NULL
"The Java Locale class, java.util.Locale, is used to represent a ""geographical, political or cultural"" region to localize a given text, number, date or operation to.","(""Locale"", ""The Locale class is part of the java.util.Locale package, indicating that it is defined within this package."", ""java.util.Locale"")"
The Locale class cannot do any internationalization or localization by itself.,"(""Locale"", ""class"")"
"The Locale class complies with the BCP 47 (IETF BCP 47, ""Tags for Identifying Languages"") standard.","(""Locale"", ""The Locale class complies with the BCP 47 standard, indicating a relationship of compliance or adherence."", ""BCP 47"")"
"The Locale class also has support for the LDML (UTS#35 ""Unicode Locale Data Markup Language"") standard, which is a BCP 47-compatible extension for locale data exchange.","(""Locale"", ""The Locale class supports the LDML standard, indicating a relationship where Locale utilizes LDML for locale data exchange."", ""LDML"")"
"Language codes are case insensitive, but the Locale class always use lowercase versions of the language codes.","(""Locale"", ""The Locale class uses lowercase versions of the language codes, indicating a functional relationship."", ""language codes"")"
"Script codes are case insensitive, but the Locale class always uses a version with the first letter in uppercase, and the rest in lowercase.","(""Locale"", ""The Locale class uses a version of script codes with specific capitalization rules."", ""Script codes"")"
"The country code is a 2 character code following the ISO 3166 standard, or a UN M.49 numeric area code.","(""ISO 3166"", ""Both ISO 3166 and UN M.49 are standards for country codes."", ""UN M.49"")"
"The country code is case insensitive, but the Locale class uses an uppercase version of the country code.","(""Locale"", ""The Locale class uses an uppercase version of the country code, indicating a relationship between them."", ""country code"")"
See the JavaDoc for the Locale class for more detail about variant.,"(""Locale"", ""The JavaDoc provides detailed documentation about the Locale class."", ""JavaDoc"")"
"For instance, what calendar to use when displaying dates (Gregorian, Arab, Japanese etc.).","(""Calendar"", ""The Gregorian class is a type of calendar that can be used for displaying dates."", ""Gregorian""); (""Calendar"", ""The Arab class is a type of calendar that can be used for displaying dates."", ""Arab""); (""Calendar"", ""The Japanese class is a type of calendar that can be used for displaying dates."", ""Japanese"")"
See the JavaDoc for the Locale class for more detail about extensions.,"(""Locale"", ""The JavaDoc provides detailed documentation about the Locale class."", ""JavaDoc"")"
Creating a java.util.Locale instance can be done in four different ways:,"(""Java.Util.Locale"", ""Class"")"
The java.util.Locale class contains a set of constants that represent the most commonly used languages in the world.,"(""Locale"", ""The Locale class is part of the java.util package, indicating a containment or organizational relationship."", ""java.util"")"
You can also create a java.util.Locale instance by using one of its constructors.,"(""Java.Util.Locale"", ""Java.Util.Locale is instantiated using its constructors."", ""Constructors"")"
From Java 7 you can use the Locale.Builder class to build a Locale instance.,"(""Locale.Builder"", ""Locale.Builder is used to build a Locale instance, indicating a relationship where Locale.Builder constructs or configures Locale."", ""Locale"")"
The factory method Locale.forLanguageTag() can also be used to create a Locale instance.,"(""forLanguageTag"", ""The method forLanguageTag is used to create an instance of the class Locale."", ""Locale"")"
The ResourceBundle class is covered in more detail in the text about the ResourceBundle class.,"(""ResourceBundle"", ""The text mentions the ResourceBundle class in detail, indicating a focus on this class."", ""ResourceBundle"")"
"Finally, I may want to show how a given application works to a person who doesn't speak the language that my application is localized to (e.g.",NULL
"English or Danish), so I may want to temporarily change language to e.g.",NULL
The java.text.NumberFormat class is used to format numbers according to a specific Locale.,"(""NumberFormat"", ""The NumberFormat class is part of the java.text package."", ""java.text""); (""NumberFormat"", ""The NumberFormat class uses Locale to format numbers according to specific regional settings."", ""Locale"")"
Formatting a number using a NumberFormatter is done using the format() method.,"(""NumberFormatter"", ""The format() method is used to format a number using a NumberFormatter class."", ""format"")"
"Notice that numbers like 100.00 might be formatted without the decimals, as 100.",NULL
Formatting a number as a currency is still done using the format() method.,"(""Format"", ""The format() method is used to format a number as a currency."", ""Currency"")"
"You can also set the Currency object to use for formatting a number as a currency, using the setCurrency() method on the NumberFormat class.","(""setCurrency"", ""The setCurrency method is used on the NumberFormat class to format a number as a currency."", ""NumberFormat""); (""Currency"", ""The setCurrency method is used to set the Currency object for formatting purposes."", ""setCurrency"")"
Formatting a number as a percentage is also done using the format() method.,"(""Format"", ""The format method is used to format a number as a percentage."", ""Percentage"")"
You can set the rounding mode using the setRoundingMode() method of the NumberFormat class.,"(""setRoundingMode"", ""The setRoundingMode method is a function of the NumberFormat class, indicating that it is used to set the rounding mode for instances of this class."", ""NumberFormat"")"
"Had the NumberFormat instance been created using a UK Locale instance, the number had been parsed to 10000, because the comma would have been interpreted as a integer separator (e.g.","(""NumberFormat"", ""NumberFormat uses Locale to format numbers according to regional settings"", ""Locale"")"
"The Java ResourceBundle class, java.util.ResourceBundle, is used to store texts and components that are locale sensitive.","(""Java ResourceBundle"", ""The Java ResourceBundle class is part of the java.util.ResourceBundle package."", ""java.util.ResourceBundle"")"
"A user's locale is represented by the Java Locale class, by the way.","(""Java Locale"", ""The Java Locale class represents a user's locale."", ""Locale"")"
This text takes a closer look at the ResourceBundle class and its subclasses.,"(""ResourceBundle"", ""ResourceBundle is related to its subclasses as it is the parent class."", ""subclasses"")"
The PropertyResourceBundle class stores localized texts in standard Java property files.,"(""PropertyResourceBundle"", ""The PropertyResourceBundle class is used in the context of Java for storing localized texts in property files."", ""Java"")"
Then you pass that Locale instance to the ResourceBundle.getBundle() method along with the name of the resource bundle to load.,"(""ResourceBundle"", ""The getBundle method is a method of the ResourceBundle class."", ""getBundle""); (""Locale"", ""The Locale instance is passed as an argument to the getBundle method."", ""getBundle""); (""ResourceBundle"", ""The ResourceBundle class uses the Locale instance to load the appropriate resource bundle."", ""Locale"")"
Finally you can access the localized values in the ResourceBundle via its different getString() and getObject() etc.,"(""ResourceBundle"", ""The getString method is used to access localized values in the ResourceBundle class."", ""getString""); (""ResourceBundle"", ""The getObject method is used to access localized values in the ResourceBundle class."", ""getObject"")"
"You are never actually creating a ResourceBundle instance, but an instance of one of its two subclasses.","(""ResourceBundle"", ""ResourceBundle is related to its subclasses because it is mentioned that instances of its subclasses are created instead of ResourceBundle itself."", ""subclasses"")"
"First the ResourceBundle class will look for a ListResourceBundle, and then for a PropertyResourceBundle.","(""ResourceBundle"", ""The ResourceBundle class looks for a ListResourceBundle, indicating a dependency or usage relationship."", ""ListResourceBundle""); (""ResourceBundle"", ""The ResourceBundle class looks for a PropertyResourceBundle, indicating a dependency or usage relationship."", ""PropertyResourceBundle"")"
"It does so by matching the name of the requested resource bundle (first parameter in the getBundle() method) against the class names of a ListResourceBundle first, and if none found, against a property file resource bundle.","(""GETBUNDLE"", ""The getBundle() method uses the class names of ListResourceBundle to match the requested resource bundle."", ""LISTRESOURCEBUNDLE""); (""GETBUNDLE"", ""The getBundle() method matches the requested resource bundle against a property file resource bundle if no ListResourceBundle is found."", ""PROPERTY FILE RESOURCE BUNDLE"")"
For this example to work you should put a standard Java property file named MyBundle.properties in a Java package named i18n.,"(""MyBundle.properties"", ""The class MyBundle.properties is located within the package i18n."", ""i18n"")"
"Make sure this property file is available on your class path when you run the above code, meaning the property file should be located among the classes of your application, and in the i18n package.","(""Class"", ""The class is expected to be located within the i18n package as part of the application's structure."", ""I18n"")"
The name of a resource bundle is like a class name.,"(""Resource Bundle"", ""The name of a resource bundle is compared to a class name, indicating a conceptual relationship between the two."", ""Class Name"")"
"Thus, i18n.MyBundle means a property file named MyBundle.properties in the package (directory) i18n.","(""MyBundle"", ""MyBundle is a property file located in the package i18n."", ""i18n"")"
"In case no property file is available for the language (Locale) passed to the ResourceBundle.getBundle() method, and the system has no default Locale set (e.g.","(""ResourceBundle"", ""The getBundle method is a part of the ResourceBundle class, used to retrieve resource bundles."", ""getBundle""); (""getBundle"", ""The getBundle method uses Locale as a parameter to determine the language-specific resource bundle."", ""Locale""); (""ResourceBundle"", ""The ResourceBundle class interacts with Locale to manage language-specific resources."", ""Locale"")"
You can also use a set of classes to contain your resources.,"(""Classes"", ""Classes are used to contain resources."", ""Resources"")"
"Like with the property files, you create a set of classes with a bundle base name and language suffixes.","(""classes"", ""The classes are created with a bundle base name, indicating a relationship between them."", ""bundle base name""); (""classes"", ""The classes are created with language suffixes, indicating a relationship between them."", ""language suffixes"")"
Here is an example implementation of the default bundle class file:,"(""Default Bundle"", ""class"")"
"You can also obtain a set of all keys contained in the ResourceBundle using the keySet() method, like this:","(""ResourceBundle"", ""The keySet method is used to obtain a set of all keys contained in the ResourceBundle class."", ""keySet"")"
The java.text.SimpleDateFormat class is used to both parse and format dates according to a formatting pattern you specify yourself.,"(""SimpleDateFormat"", ""The SimpleDateFormat class is part of the java.text package, indicating a package-class relationship."", ""java.text"")"
This text explains how to use the SimpleDateFormat class to format dates.,"(""SimpleDateFormat"", ""The SimpleDateFormat class is used to format dates."", ""format dates"")"
Once you have created a SimpleDateFormat instance you can format dates using its format() method.,"(""SimpleDateFormat"", ""The format method is used by the SimpleDateFormat class to format dates."", ""format"")"
The Date instance passed to the format() method is a java.util.Date instance.,"(""format"", ""The format method takes a Date instance as an argument."", ""Date""); (""Date"", ""Date is an instance of the java.util.Date class."", ""java.util.Date"")"
"The Java SimpleDateFormat class is also capable of formatting a Date object into a StringBuffer, instead of returning an individual String with the date formatted.","(""SimpleDateFormat"", ""The SimpleDateFormat class is used to format Date objects."", ""Date""); (""SimpleDateFormat"", ""The SimpleDateFormat class can format a Date object into a StringBuffer."", ""StringBuffer""); (""SimpleDateFormat"", ""The SimpleDateFormat class can return a formatted date as a String."", ""String"")"
"The SimpleDateFormat class does this via a version of the format() method that takes the Date, StringBuffer and a FieldPosition instance as parameters.","(""SimpleDateFormat"", ""The format method is a member of the SimpleDateFormat class."", ""format""); (""format"", ""The format method takes a Date instance as a parameter."", ""Date""); (""format"", ""The format method takes a StringBuffer instance as a parameter."", ""StringBuffer""); (""format"", ""The format method takes a FieldPosition instance as a parameter."", ""FieldPosition"")"
It seems the format() method appends the formatted String to the end of the StringBuffer no matter what the int value passed to the FieldPosition constructor is.,"(""FORMAT"", ""The format() method appends the formatted String to the end of the StringBuffer."", ""STRINGBUFFER""); (""FIELDPOSITION"", ""The int value passed to the FieldPosition constructor is used in the format() method."", ""FORMAT"")"
You can parse a String into a java.util.Date instance using the parse() method of the SimpleDateFormat instance.,"(""parse()"", ""The parse() method is used by the SimpleDateFormat class to parse a String into a java.util.Date instance."", ""SimpleDateFormat""); (""String"", ""A String is parsed into a java.util.Date instance using the parse() method."", ""java.util.Date""); (""SimpleDateFormat"", ""The SimpleDateFormat class is used to create a java.util.Date instance from a String."", ""java.util.Date"")"
"For instance, you can write either yy for a 2-character version of the year (e.g.",NULL
"12), or you can write yyyy for a 4-character version of the year (e.g.",NULL
"For more information about the patterns accepted, see the JavaDoc for the SimpleDateFormat class.","(""SimpleDateFormat"", ""The JavaDoc provides documentation for the SimpleDateFormat class."", ""JavaDoc"")"
"The indices in this array must start from one, to be indexable by the Calendar.SUNDAY, Calendar.MONDAY etc.","(""Calendar"", ""SUNDAY is a method or constant that belongs to the Calendar class, as indicated by the dot notation."", ""SUNDAY""); (""Calendar"", ""MONDAY is a method or constant that belongs to the Calendar class, as indicated by the dot notation."", ""MONDAY"")"
See the JavaDoc for the java.text.DateFormatSymbols class for more details about these methods and symbols.,"(""DateFormatSymbols"", ""The DateFormatSymbols class contains or utilizes these methods."", ""methods""); (""DateFormatSymbols"", ""The DateFormatSymbols class is part of the java.text package."", ""java.text"")"
You can set the time zone of a SimpleDateFormat using its setTimeZone() method.,"(""SimpleDateFormat"", ""The setTimeZone method is used to set the time zone of a SimpleDateFormat class."", ""setTimeZone"")"
The setTimeZone() method takes an Java TimeZone instance (java.util.TimeZone) as parameter.,"(""SETTIMEZONE"", ""The setTimeZone() method takes a TimeZone instance as a parameter, indicating a direct usage relationship."", ""TIMEZONE""); (""TIMEZONE"", ""The TimeZone class is part of the java.util package, indicating a containment relationship."", ""JAVA.UTIL"")"
"Of these ISO time zone formats, the Java SimpleDateFormat class only supports the second format (+hhmm), or the format ending with the Z character.","(""SimpleDateFormat"", ""The SimpleDateFormat class is part of the Java package."", ""Java"")"
"This is to make the SimpleDateFormat class treat them as literal characters to be inserted, instead of trying to interpret them as representing some part of the date.","(""SimpleDateFormat"", ""class"")"
"The Java BufferedInputStream class, java.io.BufferedInputStream, provides transparent reading of chunks of bytes and buffering for a Java InputStream, including any subclasses of InputStream.","(""BufferedInputStream"", ""BufferedInputStream is a class that is part of the java.io package, as indicated by its fully qualified name."", ""java.io.BufferedInputStream""); (""BufferedInputStream"", ""BufferedInputStream provides buffering for a Java InputStream, indicating a relationship where BufferedInputStream is used to enhance InputStream functionality."", ""InputStream""); (""java.io.BufferedInputStream"", ""java.io.BufferedInputStream is a class within the java.io package, as indicated by its fully qualified name."", ""java.io""); (""java.io.BufferedInputStream"", ""java.io.BufferedInputStream provides buffering for a Java InputStream, indicating a relationship where it enhances InputStream functionality."", ""InputStream"")"
"The BufferedInputStream creates a byte array internally, and attempts to fill the array by calling the InputStream.read(byte[]) methods on the underlying InputStream.","(""BufferedInputStream"", ""BufferedInputStream uses InputStream to read data."", ""InputStream""); (""read"", ""The read method is called on the InputStream."", ""InputStream"")"
An interesting aspect to note about the BufferedInputStream is that is supports the mark() and reset() methods inherited from the InputStream.,"(""BufferedInputStream"", ""The method 'mark' is supported by the class 'BufferedInputStream'."", ""mark""); (""BufferedInputStream"", ""The method 'reset' is supported by the class 'BufferedInputStream'."", ""reset""); (""mark"", ""The method 'mark' is inherited from the class 'InputStream'."", ""InputStream""); (""reset"", ""The method 'reset' is inherited from the class 'InputStream'."", ""InputStream"")"
"In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not, but the BufferedInputStream supports them.","(""MarkSupported"", ""The MarkSupported method is used to check if the Mark method is supported."", ""Mark""); (""MarkSupported"", ""The MarkSupported method is used to check if the Reset method is supported."", ""Reset""); (""BufferedInputStream"", ""The BufferedInputStream class supports the Mark method."", ""Mark""); (""BufferedInputStream"", ""The BufferedInputStream class supports the Reset method."", ""Reset""); (""MarkSupported"", ""The MarkSupported method is used to check support on a given InputStream."", ""InputStream""); (""Mark"", ""The Mark method is used on an InputStream."", ""InputStream""); (""Reset"", ""The Reset method is used on an InputStream."", ""InputStream"")"
You close a BufferedInputStream by calling the close() method inherited from InputStream.,"(""BufferedInputStream"", ""The close() method is used to close a BufferedInputStream."", ""close()""); (""close()"", ""The close() method is inherited from the InputStream class."", ""InputStream""); (""BufferedInputStream"", ""BufferedInputStream inherits from the InputStream class."", ""InputStream"")"
Notice how the while loop continues until a -1 value is read from the BufferedInputStream read() method.,"(""BufferedInputStream"", ""The read method is a function that is called on the BufferedInputStream class to read data."", ""read"")"
"After that, the while loop exits, and the BufferedInputStream close() method is called.","(""BufferedInputStream"", ""The close method is called on the BufferedInputStream class."", ""close"")"
"If an exception is thrown while reading data from the BufferedInputStream, the close() method is never called.","(""BufferedInputStream"", ""The close() method is related to the BufferedInputStream class as it is a method that can be called on an instance of this class."", ""close"")"
Proper exception handling for use of Java IO classes is also explained in my tutorial on Java IO Exception Handling.,"(""Java IO"", ""Java IO is a part of the Java IO Exception Handling class, which deals with exceptions related to Java IO."", ""Java IO Exception Handling""); (""Exception Handling"", ""Exception Handling is a component of Java IO Exception Handling, focusing on managing exceptions."", ""Java IO Exception Handling"")"
"The setSource() method actually returns a reference to the ReusableBufferedInputStream, so you can actually create a ReusableBufferedInputStream and set the source in a single instruction:","(""setSource"", ""The setSource() method returns a reference to the ReusableBufferedInputStream class."", ""ReusableBufferedInputStream"")"
"Note, that this implementation only overrides the read() method of the InputStream class that it extends.","(""READ"", ""The READ method is overridden in the INPUTSTREAM class."", ""INPUTSTREAM"")"
"The Java BufferedOutputStream class, java.io.BufferedOutputStream, is used to capture bytes written to the BufferedOutputStream in a buffer, and write the whole buffer in one batch to an underlying Java OutputStream for increased performance.","(""BufferedOutputStream"", ""BufferedOutputStream is a class within the java.io.BufferedOutputStream package."", ""java.io.BufferedOutputStream""); (""BufferedOutputStream"", ""BufferedOutputStream writes data to an underlying OutputStream for increased performance."", ""OutputStream"")"
The only difference is that you may need to call flush() if you need to be absolutely sure that the data written until now is flushed out of the buffer and onto the network or disk.,"(""FLUSH"", ""FLUSH is related to BUFFER because the method is used to ensure that data is flushed out of the buffer."", ""BUFFER""); (""FLUSH"", ""FLUSH is related to NETWORK because the method ensures data is sent over the network."", ""NETWORK""); (""FLUSH"", ""FLUSH is related to DISK because the method ensures data is written to the disk."", ""DISK"")"
To write data to a Java BufferedOutputStream you can use its write() method.,"(""BufferedOutputStream"", ""The write method is used to write data to a BufferedOutputStream."", ""write"")"
The write() method takes an int which contains the byte value of the byte to write.,"(""Write"", ""The Write method takes an Int as a parameter, indicating a relationship where the method uses the class."", ""Int"")"
Here is an example of writing data to a Java BufferedOutputStream using its write() method:,"(""BufferedOutputStream"", ""The write() method is used to write data to the BufferedOutputStream class."", ""write()"")"
"Since the Java BufferedOutputStream is a subclass of OutputStream, you can write arrays of bytes to the BufferedOutputStream too, instead of just a single byte at a time.","(""BufferedOutputStream"", ""BufferedOutputStream is a subclass of OutputStream, indicating an inheritance relationship."", ""OutputStream"")"
If you want to make sure that all written data is written to disk without having to close the BufferedOutputStream you can call its flush() method.,"(""BufferedOutputStream"", ""The flush method is a function that can be called on the BufferedOutputStream class to ensure all written data is flushed to disk."", ""flush"")"
"Calling flush() will make sure that all data which has been written to the BufferedOutputStream so far, is fully written to the underlying OutputStream too, plus flush() will also have been called on the underlying OutputStream.","(""Flush"", ""The method flush() is called on the BufferedOutputStream to ensure all data is written."", ""BufferedOutputStream""); (""Flush"", ""The method flush() is also called on the underlying OutputStream to ensure all data is written."", ""OutputStream"")"
Here is an example of calling the Java BufferedOutputStream flush() method:,"(""BufferedOutputStream"", ""The flush() method is a function that can be called on an instance of the BufferedOutputStream class."", ""flush"")"
"The concrete implementations of hasMoreData() and getMoreData() are left out, but they are not really super important to understand the principle of this example.","(""hasMoreData"", ""Both are methods mentioned in the context of the example, suggesting they are related in functionality or purpose."", ""getMoreData"")"
"What matters is, that once the while loop ends, and you are done writing data to the BufferedOutputStream, its close() method is called, which closes the BufferedOutputStream .","(""BufferedOutputStream"", ""The close method is called on the BufferedOutputStream to close it after writing data."", ""close"")"
"In case the write() method throws an exception, the close() method will never get called.","(""WRITE"", ""The CLOSE method is mentioned as not being called if the WRITE method throws an exception."", ""CLOSE"")"
"Once the try block is exited, the close() method of the BufferedOutputStream is called automatically, because the BufferedOutputStream was declared inside the parentheses of the try block.","(""BufferedOutputStream"", ""The close method is called on the BufferedOutputStream class."", ""close"")"
"Even if an exception is thrown from inside the try block, the close() method is still called before the exception is propagated up the call stack.","(""close"", ""The close() method is called within the try block, indicating a relationship where the method is executed as part of the block's operations."", ""try block""); (""close"", ""The close() method is called even if an exception is thrown, showing a relationship where the method is executed in response to an exception event."", ""exception"")"
"The Java BufferedReader class, java.io.BufferedReader, provides buffering for your Java Reader instances.","(""BufferedReader"", ""BufferedReader is a class that is part of the java.io package, as indicated by its full name java.io.BufferedReader."", ""java.io.BufferedReader""); (""BufferedReader"", ""BufferedReader provides buffering for Reader instances, indicating a functional relationship between the two classes."", ""Reader""); (""java.io.BufferedReader"", ""java.io.BufferedReader is a class within the java.io package."", ""java.io"")"
"The Java BufferedReader class is a subclass of the Java Reader class, so you can use a BufferedReader anywhere a Reader is required.","(""BufferedReader"", ""BufferedReader is a subclass of Reader, indicating an inheritance relationship."", ""Reader"")"
Each character returned from read() is thus returned from this internal array.,"(""read"", ""The method 'read' returns characters from the 'internal array'."", ""internal array"")"
The readLine() method will return a textual line (all text until at line break is found) read from the BufferedReader.,"(""ReadLine"", ""The ReadLine method is used to read a line of text from the BufferedReader class."", ""BufferedReader"")"
"If there is no more data to read from the underlying Reader, then the BufferedReader's readLine() method will return null .","(""BufferedReader"", ""The readLine method is a function of the BufferedReader class."", ""readLine"")"
The read() method of a Java BufferedReader returns an int which contains the char value of the next character read.,"(""Read"", ""The Read method is a function that belongs to the BufferedReader class, used to read characters."", ""BufferedReader"")"
"If the read() method returns -1, there is no more data to read in the BufferedReader, and it can be closed.","(""Read"", ""The read method is used to read data from the BufferedReader class."", ""BufferedReader"")"
"If not, it processes that char and continues reading until -1 is returned from the BufferedReader read() method.","(""BufferedReader"", ""The read method is a function of the BufferedReader class."", ""read"")"
"As mentioned earlier, the BufferedReader will actually read an array of characters from the underlying Reader and return these characters one by one, rather than forwarding every read() call to the underlying Reader.","(""BufferedReader"", ""BufferedReader uses Reader to read an array of characters."", ""Reader""); (""BufferedReader"", ""BufferedReader implements the read method to return characters one by one."", ""read"")"
"The Java BufferedReader class also has a read() method that takes a char array as parameter, as well as a start offset and length.","(""BufferedReader"", ""The read method is a function of the BufferedReader class."", ""read"")"
The char array is where the read() method will read the characters into.,"(""Read"", ""The read() method reads characters into the char array."", ""Char Array"")"
The offset parameter is where in the char array the read() method should start reading into.,"(""READ"", ""The read method uses the offset parameter to determine where to start reading into the char array."", ""OFFSET""); (""READ"", ""The read method reads data into the char array."", ""CHAR ARRAY"")"
The length parameter is how many characters the read() method should read into the char array from the offset and forward.,"(""READ"", ""The read() method reads characters into the char array."", ""CHAR ARRAY"")"
The Java BufferedReader has a special read method named readLine() which reads a full line of text from the BufferedReader's internal buffer.,"(""BufferedReader"", ""The readLine method is a function of the BufferedReader class, used to read a full line of text from its internal buffer."", ""readLine"")"
"If there are no more lines to read from the BufferedReader, the readLine() method returns null.","(""BufferedReader"", ""The readLine method is a function that operates on the BufferedReader class."", ""readLine"")"
The Java BufferedReader class has a method named skip() which can be used to skip over a number of characters in the input that you do not want to read.,"(""BufferedReader"", ""The method skip() is a function of the BufferedReader class."", ""skip"")"
You pass the number of characters to skip as parameter to the skip() method.,"(""SKIP"", ""The text indicates that the skip() method is used to skip a number of characters, suggesting a functional relationship between the method and the action of skipping."", ""METHOD"")"
Notice how there is no longer any explicit close() method call.,"(""CLOSE"", ""METHOD"")"
"The setSource() method actually returns a reference to the ReusableBufferedReader, so you can actually create a ReusableBufferedReader and set the source in a single instruction:","(""setSource"", ""The setSource() method returns a reference to the ReusableBufferedReader class."", ""ReusableBufferedReader"")"
"Note, that this implementation only overrides the read() and read(char[] dest, int offset, int length) methods of the Reader class that it extends.","(""READ"", ""The READ method is part of the READER class as it is overridden in this class."", ""READER""); (""READ(CHAR[] DEST, INT OFFSET, INT LENGTH)"", ""The READ(CHAR[] DEST, INT OFFSET, INT LENGTH) method is part of the READER class as it is overridden in this class."", ""READER""); (""READ"", ""Both are methods that are overridden in the READER class."", ""READ(CHAR[] DEST, INT OFFSET, INT LENGTH)"")"
"The Java BufferedWriter is a Java Writer subclass, so it can be used anywhere a Writer is required.","(""Java BufferedWriter"", ""Java BufferedWriter is a subclass of Java Writer"", ""Java Writer""); (""Java BufferedWriter"", ""Java BufferedWriter can be used anywhere a Writer is required"", ""Writer"")"
The BufferedWriter adds one extra method though: The newLine() method which can write a new-line character to the underlying Writer.,"(""BufferedWriter"", ""The newLine method is a method of the BufferedWriter class."", ""newLine""); (""newLine"", ""The newLine method writes a new-line character to the underlying Writer class."", ""Writer"")"
"In addition, you may need to call flush() if you need to be absolutely sure that the characters written until now is flushed out of the buffer and onto the network or disk.","(""FLUSH"", ""The method FLUSH is used to ensure that characters are flushed out of the BUFFER."", ""BUFFER""); (""FLUSH"", ""The method FLUSH ensures that characters are flushed onto the NETWORK."", ""NETWORK""); (""FLUSH"", ""The method FLUSH ensures that characters are flushed onto the DISK."", ""DISK"")"
"Since the BufferedWriter collects the characters written internally in a buffer before writing them to the underlying Writer, the speedup is not as noticeable as with other Writer classes (that do not use buffering).","(""BufferedWriter"", ""BufferedWriter uses a buffer to collect characters before writing them to the underlying Writer."", ""Writer""); (""BufferedWriter"", ""BufferedWriter is a type of Writer class that uses buffering."", ""Writer"")"
The Java BufferedWriter's flush() method flushes all data written to the BufferedWriter to the underlying data destination.,"(""BufferedWriter"", ""The flush() method is a function that operates on the BufferedWriter class."", ""flush()""); (""flush()"", ""The flush() method is specifically designed to work with the BufferedWriter class to flush data."", ""BufferedWriter"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your BufferedWriter has).","(""flush"", ""The method flush is used to ensure that any buffered data in the BufferedWriter class is written to its destination."", ""BufferedWriter"")"
Here is an example of flushing data written to a Java BufferedWriter by calling its flush() method:,"(""BufferedWriter"", ""The flush method is called on the BufferedWriter class to flush data written to it."", ""flush"")"
"The Java ByteArrayInputStream class, java.io.ByteArrayInputStream, of the Java IO API enables you to read data from byte arrays as streams of bytes.","(""ByteArrayInputStream"", ""The class ByteArrayInputStream is also referred to by its fully qualified name java.io.ByteArrayInputStream."", ""java.io.ByteArrayInputStream""); (""java.io.ByteArrayInputStream"", ""The class java.io.ByteArrayInputStream is part of the Java IO package."", ""Java IO"")"
"In other words, the ByteArrayInputStream class can turn a byte array into an InputStream.","(""ByteArrayInputStream"", ""ByteArrayInputStream is a class that can turn a byte array into an InputStream."", ""InputStream"")"
"The ByteArrayInputStream class is a subclass of the InputStream class, so you can use a ByteArrayInputStream as an InputStream.","(""ByteArrayInputStream"", ""The ByteArrayInputStream class is a subclass of the InputStream class, indicating an inheritance relationship."", ""InputStream"")"
The ByteArrayInputStream also has a set of additional methods that are specific to the ByteArrayInputStream class.,"(""ByteArrayInputStream"", ""The method 'set' is specific to the ByteArrayInputStream class."", ""set"")"
To use a Java ByteArrayInputStream you must first create an instance of the ByteArrayInputStream class.,"(""ByteArrayInputStream"", ""The text mentions creating an instance of the ByteArrayInputStream class, indicating a relationship between the class and its instance."", ""ByteArrayInputStream"")"
"You read bytes from a Java ByteArrayInputStream just like you would from a regular InputStream, via its read() method.","(""ByteArrayInputStream"", ""The read method is used to read bytes from a ByteArrayInputStream."", ""read""); (""InputStream"", ""The read method is used to read bytes from an InputStream."", ""read"")"
"The read() will return the next byte from the byte array, or -1 if the end of the byte array (or byte array section) has been reached.","(""Read"", ""The Read method returns the next byte from the Byte Array."", ""Byte Array""); (""Read"", ""The Read method returns -1 if the end of the Byte Array Section has been reached."", ""Byte Array Section"")"
The Java ByteArrayInputStream available() method tells you how many bytes are still available in the ByteArrayInputStream.,"(""available"", ""The available() method is a function that operates on the ByteArrayInputStream class to determine how many bytes are still available."", ""ByteArrayInputStream""); (""ByteArrayInputStream"", ""The ByteArrayInputStream class is part of the Java package."", ""Java"")"
The mark() method of the ByteArrayInputStream class sets an internal mark at the current byte position - meaning right after the previous byte read.,"(""Mark"", ""The mark() method is a function of the ByteArrayInputStream class."", ""ByteArrayInputStream"")"
"The mark() method takes a parameter telling how many bytes can be read past this mark, before this mark becomes invalid.","(""Mark"", ""The term 'mark' is used in the context of the 'mark()' method, indicating that 'mark' is a method."", ""Method""); (""Bytes"", ""The 'mark()' method takes a parameter related to 'bytes', suggesting a relationship between the method and the class."", ""Mark""); (""Parameter"", ""The 'mark()' method takes a 'parameter', indicating a relationship between the method and the class."", ""Mark""); (""Bytes"", ""The 'parameter' is related to 'bytes', as it specifies how many bytes can be read, indicating a relationship between the two classes."", ""Parameter"")"
Here is an example of setting a mark in a ByteArrayInputStream via its mark() method:,"(""ByteArrayInputStream"", ""The mark method is used in the ByteArrayInputStream class to set a mark position in the input stream."", ""mark"")"
The reset() method of the ByteArrayInputStream resets how far it has read into the byte array.,"(""Reset"", ""The reset() method is a function of the ByteArrayInputStream class, indicating that it operates on instances of this class."", ""ByteArrayInputStream"")"
The Java ByteArrayInputStream skip() method enables you to skip over a number of bytes from the underlying byte array.,"(""ByteArrayInputStream"", ""The skip() method is a function of the ByteArrayInputStream class, allowing it to skip over bytes in the byte array."", ""skip"")"
Here is an example of skipping over a number of bytes using the ByteArrayInputStream skip() method:,"(""ByteArrayInputStream"", ""The skip() method is a function of the ByteArrayInputStream class, used to skip over a number of bytes in the input stream."", ""skip"")"
Notice how the while loop continues until a -1 value is read from the ByteArrayInputStream read() method.,"(""ByteArrayInputStream"", ""The read method is a function of the ByteArrayInputStream class."", ""read"")"
"After that, the while loop exits, and the ByteArrayInputStream close() method is called.","(""ByteArrayInputStream"", ""The close method is called on the ByteArrayInputStream class."", ""close"")"
"If an exception is thrown while reading data from the ByteArrayInputStream, the close() method is never called.","(""ByteArrayInputStream"", ""The close() method is related to the ByteArrayInputStream class as it is a method that would typically be called on an instance of this class."", ""close()"")"
"The Java ByteArrayOutputStream class, java.io.ByteArrayOutputStream of the Java IO API enables you to capture data written to a stream in a byte array.","(""ByteArrayOutputStream"", ""The class ByteArrayOutputStream is part of the java.io.ByteArrayOutputStream package."", ""java.io.ByteArrayOutputStream""); (""ByteArrayOutputStream"", ""The class ByteArrayOutputStream is a component of the Java IO API."", ""Java IO API"")"
You write your data to the ByteArrayOutputStream and when you are done you call the its toByteArray() method to obtain all the written data in a byte array.,"(""ByteArrayOutputStream"", ""The toByteArray method is called on the ByteArrayOutputStream class to obtain all the written data in a byte array."", ""toByteArray"")"
"Since the Java ByteArrayOutputStream class is a subclass of the Java OutputStream class, you write bytes to it using the same write methods that OutputStream has:","(""ByteArrayOutputStream"", ""ByteArrayOutputStream is a subclass of OutputStream"", ""OutputStream""); (""write"", ""The write method is used to write bytes to OutputStream"", ""OutputStream"")"
"Once you have finished writing to the ByteArrayOutputStream you can obtain all the bytes written as a Java byte array, using the ByteArrayOutputStream toByteArray() method.","(""ByteArrayOutputStream"", ""The toByteArray method is a function of the ByteArrayOutputStream class, used to obtain all the bytes written to the stream."", ""toByteArray"")"
Being a subclass of OutputStream the ByteArrayOutputStream also has a close() method.,"(""ByteArrayOutputStream"", ""ByteArrayOutputStream is a subclass of OutputStream"", ""OutputStream""); (""ByteArrayOutputStream"", ""ByteArrayOutputStream has a close() method"", ""close()"")"
But calling the close() method has no effect on the ByteArrayOutputStream.,"(""Close"", ""The Close method is mentioned in the context of the ByteArrayOutputStream class, indicating that it is a method that can be called on instances of this class."", ""ByteArrayOutputStream"")"
"The Java DataInputStream class, java.io.DataInputStream, enables you to read Java primitives (int, float, long etc.)","(""DataInputStream"", ""The DataInputStream class is part of the java.io.DataInputStream package, indicating a package-class relationship."", ""java.io.DataInputStream"")"
"The Java DataInputStream class is a subclass of InputStream, so DataInputStream also has the basic read methods that enable you to read a single byte or an array of bytes from the underlying InputStream, in case you need that.","(""Java DataInputStream"", ""Java DataInputStream is a subclass of InputStream."", ""InputStream""); (""Java DataInputStream"", ""Java DataInputStream has the basic read methods."", ""read"")"
"As mentioned earlier, the DataInputStream class is often used together with a DataOutputStream.","(""DataInputStream"", ""DataInputStream and DataOutputStream are related because they are often used together in programming to handle input and output streams."", ""DataOutputStream"")"
You can read a Java boolean from the DataInputStream using its readBoolean() method.,"(""DataInputStream"", ""The readBoolean method is a function of the DataInputStream class, allowing it to read a Java boolean."", ""readBoolean"")"
Here is an example of reading a boolean from a Java DataInputStream using readBoolean():,"(""DataInputStream"", ""The method readBoolean() is used to read a boolean value from the DataInputStream class."", ""readBoolean"")"
You can read a Java byte from the DataInputStream using its readByte() method.,"(""DataInputStream"", ""The readByte method is a function of the DataInputStream class, used to read a Java byte."", ""readByte"")"
Here is an example of reading a byte from a Java DataInputStream using readByte():,"(""DataInputStream"", ""The method readByte is used to read a byte from the DataInputStream class."", ""readByte"")"
You can read a Java unsigned byte (only positive values) from the DataInputStream using its readUnsignedByte() method.,"(""DataInputStream"", ""The readUnsignedByte method is a function provided by the DataInputStream class to read an unsigned byte."", ""readUnsignedByte"")"
Here is an example of reading an unsigned byte from a Java DataInputStream using readUnsignedByte():,"(""DataInputStream"", ""The method readUnsignedByte is used to read an unsigned byte from the DataInputStream class."", ""readUnsignedByte"")"
You can read a Java char from the DataInputStream using its readChar() method.,"(""DataInputStream"", ""The readChar method is a function of the DataInputStream class, allowing it to read a Java char."", ""readChar"")"
Here is an example of reading a char from a Java DataInputStream using readChar():,"(""DataInputStream"", ""The method readChar is used to read a character from the DataInputStream class."", ""readChar"")"
You can read a Java double from the DataInputStream using its readDouble() method.,"(""DataInputStream"", ""The readDouble method is a function of the DataInputStream class, allowing it to read a Java double."", ""readDouble"")"
Here is an example of reading a double from a Java DataInputStream using readDouble():,"(""DataInputStream"", ""The method readDouble is used to read a double value from the DataInputStream class."", ""readDouble"")"
You can read a Java float from the DataInputStream using its readFloat() method.,"(""DataInputStream"", ""The readFloat method is a function of the DataInputStream class, allowing it to read a Java float."", ""readFloat"")"
Here is an example of reading a float from a Java DataInputStream using readFloat():,"(""DataInputStream"", ""The method readFloat is used to read a float from the DataInputStream class."", ""readFloat"")"
You can read a Java short from the DataInputStream using its readShort() method.,"(""DataInputStream"", ""The readShort method is a function provided by the DataInputStream class to read a Java short."", ""readShort"")"
Here is an example of reading a short from a Java DataInputStream using readShort():,"(""DataInputStream"", ""The method readShort is used to read data from the DataInputStream class."", ""readShort"")"
You can read a Java unsigned short (only positive values) from the DataInputStream using its readUnsignedShort() method.,"(""DataInputStream"", ""The readUnsignedShort method is a function provided by the DataInputStream class to read an unsigned short value."", ""readUnsignedShort"")"
Here is an example of reading an unsigned short from a Java DataInputStream using readUnsignedShort():,"(""DataInputStream"", ""The method readUnsignedShort is used to read an unsigned short from the DataInputStream class."", ""readUnsignedShort"")"
You can read a Java int from the DataInputStream using its readInt() method.,"(""DataInputStream"", ""The readInt method is a function of the DataInputStream class, used to read a Java int."", ""readInt"")"
Here is an example of reading an int from a Java DataInputStream using readInt():,"(""DataInputStream"", ""The method readInt is used to read an int from the DataInputStream class."", ""readInt"")"
You can read a Java long from the DataInputStream using its readLong() method.,"(""DataInputStream"", ""The readLong method is a function of the DataInputStream class, allowing it to read a Java long."", ""readLong"")"
Here is an example of reading an int from a Java DataInputStream using readLong():,"(""DataInputStream"", ""The method readLong() is used to read data from the DataInputStream class."", ""readLong"")"
You can read a Java String from the DataInputStream using its readUTF() method.,"(""DataInputStream"", ""The readUTF method is a function provided by the DataInputStream class to read a Java String."", ""readUTF""); (""readUTF"", ""The readUTF method is used to read a Java String."", ""String"")"
Here is an example of reading a String from a Java DataInputStream using readUTF():,"(""DataInputStream"", ""The method readUTF() is used to read a String from a DataInputStream."", ""readUTF""); (""Java"", ""DataInputStream is a class within the Java package."", ""DataInputStream""); (""String"", ""The method readUTF() is used to read a String."", ""readUTF"")"
"The Java File class, java.io.File in the Java IO API gives you access to the underlying file system.","(""File"", ""The File class is represented by java.io.File in the Java IO API."", ""java.io.File""); (""java.io.File"", ""The java.io.File class is part of the Java IO API package."", ""Java IO API"")"
Note: The Java File class only gives you access to the file and directory meta data.,"(""File"", ""The File class is part of the Java programming language."", ""Java"")"
Note: If you are want to Java NIO (Java's non-blocking IO API) you will have to use the java.nio.FileChannel class instead.,"(""Java NIO"", ""The java.nio.FileChannel class is part of the Java NIO package, which is Java's non-blocking IO API."", ""java.nio.FileChannel"")"
"Both Java File and FileChannel works, but in case you want a pure Java NIO solution use the Java NIO FileChannel class.","(""Java File"", ""Both are mentioned as working solutions for file handling."", ""FileChannel""); (""FileChannel"", ""FileChannel is part of the Java NIO package."", ""Java NIO"")"
"Before you can do anything with the file system or File class, you must create a Java File instance.","(""File"", ""The File class is part of the Java package, as it is a class used within the Java programming environment."", ""Java"")"
The Java File class also has a few other constructors you can use to instantiate File instances in different ways.,"(""File"", ""The File class is used to instantiate File instances."", ""File"")"
You can check if a file referenced by a Java File object exists using the File exists() method.,"(""File"", ""The exists() method is used to check if a file referenced by a File object exists."", ""exists"")"
You can use the Java File class to create directories if they don't already exists.,"(""File"", ""The File class is used to create directories in Java."", ""create directories"")"
The File class contains the method mkdir() and mkdirs() for that purpose.,"(""File"", ""The mkdir method is contained within the File class."", ""mkdir""); (""File"", ""The mkdirs method is contained within the File class."", ""mkdirs"")"
The mkdir() method creates a single directory if it does not already exist.,"(""Mkdir"", ""The Mkdir method is used to create a directory."", ""Directory"")"
Here is an example of creating a single directory via the Java File class:,"(""File"", ""The File class is part of the Java programming language."", ""Java"")"
"The mkdir() returns true if the directory was created, and false if not.","(""mkdir()"", ""The mkdir() method is related to the directory as it is responsible for creating it."", ""directory"")"
The mkdirs() will create all directories that are missing in the path the File object represents.,"(""Mkdirs"", ""The Mkdirs method is used to create directories in the path represented by the File class."", ""File"")"
Here is an example of creating multiple directories via the Java File class:,"(""File"", ""The File class is part of the Java programming language."", ""Java"")"
"The mkdirs() method will return true if all the directories were created, and false if not.","(""Mkdirs"", ""The text explicitly mentions 'mkdirs()' as a method."", ""Method"")"
The Java File class enables you to read the length in bytes of a file.,"(""File"", ""The File class is related to the length because it enables reading the length in bytes of a file."", ""length"")"
"To read the length of a file, call the File length() method.","(""File"", ""The length method is called on the File class to read the length of a file."", ""length"")"
Here is an example of reading the length of a file via the Java File length() method:,"(""File"", ""The length() method is used to read the length of a file, indicating that it is a method belonging to the File class."", ""length()""); (""length()"", ""The length() method is part of the Java package, as it is a method used in Java programming."", ""Java"")"
"To rename (or move) a file, call the method renameTo() on the File class.","(""RenameTo"", ""The method RenameTo is called on the File class to rename or move a file."", ""File"")"
"As briefly mentioned earlier, the renameTo() method can also be used to move a file to a different directory.","(""renameTo"", ""The text explicitly mentions renameTo as a method."", ""method"")"
The new file name passed to the renameTo() method does not have to be in the same directory as the file was already residing in.,"(""RenameTo"", ""The RenameTo method is used to change the name of a file, indicating a direct interaction between the method and the file."", ""File"")"
"The renameTo() method returns boolean (true or false), indicating whether the renaming was successful.","(""RenameTo"", ""The RenameTo method returns a boolean value indicating the success of the renaming operation."", ""Boolean"")"
"The Java File renameTo() method also works for directories, by the way.","(""File"", ""The renameTo method is a function of the File class."", ""renameTo""); (""Java"", ""The File class is part of the Java package."", ""File"")"
"The delete() method returns boolean (true or false), indicating whether the deletion was successful.","(""Delete"", ""The Delete method returns a Boolean value indicating the success of the deletion."", ""Boolean"")"
"The Java File delete() method also works for directories, meaning you can also delete directories with it.","(""File"", ""The delete method is a function that belongs to the File class, allowing operations such as deleting files or directories."", ""delete"")"
The Java File delete() method can only delete a directory if the directory is empty.,"(""File"", ""The delete method is a function of the File class, used to delete files or directories."", ""delete""); (""Java"", ""The File class is part of the Java package, which provides the necessary classes for file manipulation."", ""File"")"
"You can check if a File object points to a file or directory, by calling its isDirectory() method.","(""File"", ""The isDirectory method is called on a File object to check if it points to a directory."", ""isDirectory"")"
You can obtain a list of all the files in a directory by calling either the Java File list() method or the listFiles() method.,"(""File"", ""The list method is a method of the File class."", ""list""); (""File"", ""The listFiles method is a method of the File class."", ""listFiles""); (""Java"", ""The File class is part of the Java package."", ""File"")"
The list() method returns an array of String's with the file and / or directory names of directory the File object points to.,"(""List"", ""The List method returns an array of Strings."", ""String""); (""List"", ""The List method operates on the File object to retrieve directory names."", ""File"")"
The listFiles() returns an array of File objects representing the files and / or directories in the directory the File points to.,"(""listFiles"", ""The method listFiles returns an array of File objects."", ""File"")"
Here is an example of listing all files in a directory via the Java File list() and listFiles() methods:,"(""File"", ""The list method is associated with the File class as it is used to list files in a directory."", ""list""); (""File"", ""The listFiles method is associated with the File class as it is used to list files in a directory."", ""listFiles"")"
"The Java FileInputStream class, java.io.FileInputStream, makes it possible to read the contents of a file as a stream of bytes.","(""FileInputStream"", ""The class FileInputStream is specifically referred to as java.io.FileInputStream, indicating they are the same class with the latter being the fully qualified name."", ""java.io.FileInputStream""); (""java.io.FileInputStream"", ""The class java.io.FileInputStream is part of the java.io package."", ""java.io"")"
"Note also, that since FileInputStream is a subclass of InputStream, we can cast the created FileInputStream to an InputStream everywhere we want to, as we do in the example above.","(""FileInputStream"", ""FileInputStream is a subclass of InputStream, indicating an inheritance relationship."", ""InputStream"")"
The FileInputStream class has a three different constructors you can use to create a FileInputStream instance.,"(""FileInputStream"", ""The FileInputStream class has constructors to create its instances."", ""constructors"")"
"Actually, in my experience Java will also understand if you use a / as directory separator on Windows (e.g.","(""Java"", ""Java is a programming language that can be used on the Windows operating system."", ""Windows"")"
The read() method of a FileInputStream returns an int which contains the byte value of the byte read.,"(""Read"", ""The Read method is a function that belongs to the FileInputStream class, indicating it operates on or is associated with instances of this class."", ""FileInputStream"")"
"If the read() method returns -1, there is no more data to read in the FileInputStream, and it can be closed.","(""Read"", ""The read method is used to read data from the FileInputStream class."", ""FileInputStream"")"
You use the read() method just like the read() method of an InputStream.,"(""Read"", ""The read() method is used in the context of an InputStream, indicating that it is a method belonging to or used with the InputStream class."", ""InputStream"")"
Being an InputStream the FileInputStream also has two read() methods which can read data into a byte array.,"(""FileInputStream"", ""FileInputStream is a type of InputStream."", ""InputStream""); (""read"", ""The read method is associated with the FileInputStream class."", ""FileInputStream""); (""read"", ""The read method can read data into a byte array."", ""byte array"")"
"These methods are inherited from the Java InputStream class, by the way.","(""InputStream"", ""The InputStream class is part of the Java package."", ""Java""); (""methods"", ""The methods are inherited from the InputStream class."", ""InputStream"")"
"If all bytes have been read from the FileInputStream, these read() methods will return -1.","(""FileInputStream"", ""The read method is used to read bytes from the FileInputStream class."", ""read"")"
Therefore it is necessary to inspect the value returned from these read() method calls.,"(""READ"", ""The term 'read()' is identified as a method due to the context of 'method calls' in the text."", ""METHOD"")"
The doSomethingWithData() method implementation has been left out of this example to keep it short.,"(""DoSomethingWithData"", ""The text explicitly mentions 'doSomethingWithData()' as a method."", ""method"")"
"Notice, that a BufferedInputStream is an InputStream subclass and can be used in any place where an InputStream can be used.","(""BufferedInputStream"", ""BufferedInputStream is a subclass of InputStream, indicating an inheritance relationship."", ""InputStream"")"
You close a FileInputStream by calling the close() method inherited from InputStream.,"(""FileInputStream"", ""The close() method is used to close a FileInputStream."", ""close()""); (""close()"", ""The close() method is inherited from the InputStream class."", ""InputStream"")"
Notice how the while loop continues until a -1 value is read from the FileInputStream read() method.,"(""FileInputStream"", ""The read method is a function of the FileInputStream class, used to read data from a file."", ""read"")"
"After that, the while loop exits, and the FileInputStream close() method is called.","(""FileInputStream"", ""The close method is called on the FileInputStream class to close the input stream."", ""close"")"
"If an exception is thrown while reading data from the FileInputStream, the close() method is never called.","(""FileInputStream"", ""The close() method is related to the FileInputStream class as it is typically used to close the stream after operations like reading data."", ""close()"")"
"The Java FileOutputStream class, java.io.FileOutputStream, makes it possible to write a file as a stream of bytes.","(""FileOutputStream"", ""The class FileOutputStream is specifically referred to as java.io.FileOutputStream, indicating a more specific or fully qualified name."", ""java.io.FileOutputStream""); (""java.io.FileOutputStream"", ""The class java.io.FileOutputStream is part of the java.io package."", ""java.io"")"
The Java FileOutputStream class is a subclass of Java OutputStream meaning you can use a FileOutputStream as an OutputStream.,"(""FileOutputStream"", ""FileOutputStream is a subclass of OutputStream, indicating an inheritance relationship."", ""OutputStream"")"
The Java FileOutputStream class contains a set of different useful constructors.,"(""FileOutputStream"", ""FileOutputStream is a class that is part of the Java programming language."", ""Java"")"
To write data to a Java FileOutputStream you can use its write() method.,"(""FileOutputStream"", ""The write method is used to write data to a FileOutputStream."", ""write"")"
Here is an example of writing data to a Java FileOutputStream using its write() method:,"(""FileOutputStream"", ""The write method is used to write data to the FileOutputStream class."", ""write"")"
"Since the Java FileOutputStream is a subclass of OutputStream, you can write arrays of bytes to the FileOutputStream too, instead of just a single byte at a time.","(""FileOutputStream"", ""FileOutputStream is a subclass of OutputStream, indicating an inheritance relationship."", ""OutputStream"")"
If you want to make sure that all written data is written to disk without having to close the FileOutputStream you can call its flush() method.,"(""FileOutputStream"", ""The flush method is called on the FileOutputStream class to ensure all written data is flushed to disk."", ""flush"")"
"Calling flush() will make sure that all data which has been written to the FileOutputStream so far, is fully written to disk too.","(""FLUSH"", ""The method FLUSH is called on the class FILEOUTPUTSTREAM to ensure data is fully written to disk."", ""FILEOUTPUTSTREAM"")"
Here is an example of calling the Java FileOutputStream flush() method:,"(""FileOutputStream"", ""The flush method is a function that can be called on the FileOutputStream class."", ""flush"")"
Here is an example of closing a Java FileOutputStream by calling its close() method:,"(""FileOutputStream"", ""The close method is used to close the FileOutputStream class."", ""close"")"
"Unfortunately, if an exception is thrown during the write() call in the example above, that exception will cause the program flow to break before the close() method is called.","(""WRITE"", ""The WRITE method is called before the CLOSE method, and an exception during WRITE can prevent CLOSE from being executed."", ""CLOSE"")"
"In other words, the FileOutputStream close() will be called automatically for you.","(""FileOutputStream"", ""The method close() is associated with the class FileOutputStream as it is a method that can be called on instances of this class."", ""close()"")"
You can convert a FileOutputStream to a character based Writer using the Java OutputStreamWriter class.,"(""FileOutputStream"", ""OutputStreamWriter is used to convert a FileOutputStream to a character-based Writer."", ""OutputStreamWriter""); (""OutputStreamWriter"", ""OutputStreamWriter is a class that acts as a bridge to convert byte streams to character streams, thus related to Writer."", ""Writer""); (""OutputStreamWriter"", ""OutputStreamWriter is a class within the Java package."", ""Java"")"
"The Java FileReader class, java.io.FileReader makes it possible to read the contents of a file as a stream of characters.","(""FileReader"", ""The FileReader class is part of the java.io.FileReader package, indicating a hierarchical relationship where the class is contained within the package."", ""java.io.FileReader"")"
"The Java FileReader is a subclass of the Java Reader class, so it has many of the same methods.","(""Java FileReader"", ""Java FileReader is a subclass of the Java Reader class, indicating an inheritance relationship."", ""Java Reader""); (""Java FileReader"", ""Java FileReader has many of the same methods as Java Reader, indicating it inherits or uses these methods."", ""methods"")"
The read() method of the Java FileReader returns an int which contains the char value of the character read.,"(""Read"", ""The Read method is a function that belongs to the FileReader class."", ""FileReader""); (""Read"", ""The Read method is part of the Java package."", ""Java"")"
"If the read() method returns -1, there is no more data to read in the FileReader, and it can be closed.","(""Read"", ""The Read method is used to read data from the FileReader class."", ""FileReader"")"
"Notice, that a BufferedReader is a Reader subclass and can be used in any place where an Reader can be used.","(""BufferedReader"", ""BufferedReader is a subclass of Reader, indicating an inheritance relationship."", ""Reader"")"
Notice how there is no longer any explicit close() method call to the FileReader instance.,"(""CLOSE"", ""The CLOSE method is typically used to close resources like a FILEREADER instance."", ""FILEREADER"")"
"The Java FileWriter class, java.io.FileWriter, makes it possible to write characters to a file.","(""FileWriter"", ""The FileWriter class is part of the java.io.FileWriter package, indicating a containment or organizational relationship."", ""java.io.FileWriter"")"
"The Java FileWriter class is a subclass of the Java Writer class, by the way.","(""FileWriter"", ""FileWriter is a subclass of the Writer class"", ""Writer"")"
The Java FileWriter's flush() method flushes all data written to the FileWriter to the underlying file.,"(""flush()"", ""The flush() method is a function of the FileWriter class, used to flush data to the underlying file."", ""FileWriter"")"
By calling flush() you can assure that any buffered data will be flushed (written) to disk.,"(""FLUSH"", ""The method FLUSH is used to ensure that buffered data is written to DISK."", ""DISK"")"
Here is an example of flushing data written to a Java FileWriter by calling its flush() method:,"(""FileWriter"", ""The flush method is called on the FileWriter class to flush data written to it."", ""flush""); (""flush"", ""The flush method is part of the Java package, as it is used in the context of Java programming."", ""Java"")"
Notice how there is no longer any explicit close() method call to the FileWriter instance.,"(""CLOSE"", ""The CLOSE method is related to the FILEWRITER class as it is typically used to close instances of FILEWRITER."", ""FILEWRITER"")"
"The Java InputStream class, java.io.InputStream, represents an ordered stream of bytes.","(""InputStream"", ""The InputStream class is part of the java.io.InputStream package, indicating a hierarchical relationship where the class is contained within the package."", ""java.io.InputStream"")"
The Java InputStream class is the base class (superclass) of all input streams in the Java IO API.,"(""InputStream"", ""InputStream is part of the Java IO API as it is a base class for input streams within this package."", ""Java IO API"")"
"Each subclass of InputStream typically has a very specific use, but can be used as an InputStream.","(""subclass"", ""A subclass is a type of class that extends or inherits from another class, in this case, InputStream."", ""InputStream"")"
FileInputStream is a subclass of InputStream so it is safe to assign an instance of FileInputStream to an InputStream variable (the inputstream variable).,"(""FileInputStream"", ""FileInputStream is a subclass of InputStream, indicating an inheritance relationship."", ""InputStream"")"
The read() method of an InputStream returns an int which contains the byte value of the byte read.,"(""Read"", ""The Read method is a function that belongs to the InputStream class, as it operates on an InputStream object to return a byte value."", ""InputStream"")"
"If the read() method returns -1, the end of stream has been reached, meaning there is no more data to read in the InputStream.","(""Read"", ""The read method is used to read data from the InputStream class."", ""InputStream"")"
The InputStream class also contains two read() methods which can read data from the InputStream's source into a byte array.,"(""InputStream"", ""The read method is part of the InputStream class, as it is used to read data from the InputStream's source."", ""read"")"
"Inside the while loop the doSomethingWithData() method is called, passing along the data byte array as well as how many bytes were read into the array as parameters.","(""DOSOMETHINGWITHDATA"", ""The method doSomethingWithData is called with the data byte array as a parameter, indicating a relationship where the method operates on the data."", ""DATA"")"
The Java InputStream class contains a method called readAllBytes() (since Java 9).,"(""InputStream"", ""The readAllBytes method is a part of the InputStream class."", ""readAllBytes""); (""readAllBytes"", ""The readAllBytes method was introduced in Java 9."", ""Java""); (""InputStream"", ""The InputStream class is part of the Java package."", ""Java"")"
Here is an example of reading all bytes from a Java InputStream via readAllBytes():,"(""InputStream"", ""The method readAllBytes() is used to read all bytes from the InputStream class."", ""readAllBytes"")"
The InputStream class has two methods called mark() and reset() which subclasses of InputStream may or may not support.,"(""InputStream"", ""The method mark() is associated with the InputStream class as it is mentioned as a method of this class."", ""mark""); (""InputStream"", ""The method reset() is associated with the InputStream class as it is mentioned as a method of this class."", ""reset""); (""InputStream"", ""The text mentions subclasses of InputStream, indicating a relationship between the class InputStream and its subclasses."", ""InputStream"")"
"If an InputStream subclass supports the mark() and reset() methods, then that subclass should override the markSupported() to return true.","(""InputStream"", ""The method 'mark' is supported by the InputStream class."", ""mark""); (""InputStream"", ""The method 'reset' is supported by the InputStream class."", ""reset""); (""InputStream"", ""The method 'markSupported' is related to the InputStream class as it should be overridden by subclasses."", ""markSupported""); (""mark"", ""The 'markSupported' method is related to 'mark' as it indicates whether the 'mark' method is supported."", ""markSupported""); (""reset"", ""The 'markSupported' method is related to 'reset' as it indicates whether the 'reset' method is supported."", ""markSupported"")"
If the markSupported() method returns false then mark() and reset() are not supported.,"(""markSupported"", ""The markSupported method determines if the mark method is supported."", ""mark""); (""markSupported"", ""The markSupported method determines if the reset method is supported."", ""reset"")"
The mark() sets a mark internally in the InputStream which marks the point in the stream to which data has been read so far.,"(""Mark"", ""The method 'mark()' is used within the 'InputStream' class to set a mark internally."", ""InputStream"")"
"If the code using the InputStream wants to go back to the point in the stream where the mark was set, the code calls reset() on the InputStream.","(""InputStream"", ""The method reset() is called on the InputStream class to return to the marked position in the stream."", ""reset"")"
The methods mark() and reset() methods are typically used when implementing parsers.,"(""MARK"", ""Both methods are typically used together when implementing parsers."", ""RESET"")"
Notice how the while loop continues until a -1 value is read from the InputStream read() method.,"(""InputStream"", ""The read method is a function of the InputStream class, indicating that it operates on or is part of this class."", ""read"")"
"After that, the while loop exits, and the InputStream close() method is called.","(""InputStream"", ""The close method is called on the InputStream class."", ""close"")"
"If an exception is thrown while reading data from the InputStream, the close() method is never called.","(""InputStream"", ""The close() method is related to the InputStream class as it is typically used to close the stream after operations like reading data."", ""close"")"
"The Java InputStreamReader class, java.io.InputStreamReader, wraps a Java InputStream, thereby turning the byte based InputStream into a character based Reader.","(""InputStreamReader"", ""The InputStreamReader class is represented by the fully qualified name java.io.InputStreamReader."", ""java.io.InputStreamReader""); (""InputStreamReader"", ""The InputStreamReader class wraps the InputStream class."", ""InputStream""); (""InputStreamReader"", ""The InputStreamReader class turns an InputStream into a Reader."", ""Reader"")"
The Java InputStreamReader class is thus a subclass of the Java Reader class.,"(""InputStreamReader"", ""InputStreamReader is a subclass of Reader"", ""Reader"")"
You can get the character encoding used by a Java InputStreamReader instance via its getEncoding() method.,"(""InputStreamReader"", ""The getEncoding method is used by the InputStreamReader class to retrieve the character encoding."", ""getEncoding"")"
The read() method of an InputStreamReader returns an int which contains the char value of the char read.,"(""Read"", ""The read method is a function of the InputStreamReader class"", ""InputStreamReader"")"
"If the read() method returns -1, the end of stream has been reached, meaning there is no more data to read in the InputStreamReader.","(""Read"", ""The Read method is used to read data from the InputStreamReader class."", ""InputStreamReader"")"
"As you can see, the while loop keeps running until a -1 is read from the InputStreamReader read() method.","(""InputStreamReader"", ""The read method is a function of the InputStreamReader class, indicating a class-method relationship."", ""read"")"
"Once all the data is written to it, simply call the method toByteArray() or toCharArray, and all the data written is returned in array form.","(""toByteArray"", ""Both methods are used to return data in array form."", ""toCharArray"")"
The Java CharArrayReader class (java.io.CharArrayReader) enables you to read the contents of a char array as a character stream.,"(""CharArrayReader"", ""The CharArrayReader class is part of the java.io.CharArrayReader package."", ""java.io.CharArrayReader"")"
"The Java CharArrayReader is handy when you have data in a char array, but need to pass that data to some component which can only read from a Reader (or a Reader subclass).","(""CharArrayReader"", ""CharArrayReader is used to pass data to components that can read from a Reader."", ""Reader""); (""CharArrayReader"", ""CharArrayReader can be used with components that require a Reader subclass."", ""Reader subclass"")"
Closing a CharArrayReader can be done using the close() method like this:,"(""CharArrayReader"", ""The close() method is used to close the CharArrayReader class."", ""close()"")"
Notice that there is no explicit close() call on the CharArrayReader.,"(""CharArrayReader"", ""The method close() is typically associated with classes that handle resources, suggesting a relationship with the CharArrayReader class."", ""close()"")"
The Java CharArrayWriter class (java.io.CharArrayWriter) makes it possible to write characters via the Writer methods (CharArrayWriter is a subclass of Writer) and convert the written characters into a char array.,"(""CharArrayWriter"", ""CharArrayWriter is a subclass of Writer, indicating an inheritance relationship."", ""Writer""); (""CharArrayWriter"", ""CharArrayWriter uses Writer methods to write characters, indicating a usage relationship."", ""Writer methods""); (""CharArrayWriter"", ""CharArrayWriter is part of the java.io.CharArrayWriter package, indicating a containment relationship."", ""java.io.CharArrayWriter"")"
"The Java CharArrayWriter class is handy when you have a component that can only write characters to a Writer, but you need the characters as a char array.","(""CharArrayWriter"", ""CharArrayWriter is a class that is used when you need to write characters to a Writer."", ""Writer"")"
"Simply pass that component a CharArrayWriter and when all characters are written to it, call toCharArray() on the CharArrayWriter.","(""CharArrayWriter"", ""The method toCharArray() is called on the CharArrayWriter class to retrieve the written characters."", ""toCharArray"")"
"Third, the written characters are obtained as a char array by calling the toCharArray() method on the CharArrayWriter.","(""TOCHARARRAY"", ""The toCharArray() method is called on the CharArrayWriter class to obtain a char array."", ""CHARARRAYWRITER"")"
Notice how there is no longer any explicit close() method call to the CharArrayWriter instance.,"(""CLOSE"", ""The CLOSE method is related to the CHARARRAYWRITER class as it is a method that can be called on an instance of this class."", ""CHARARRAYWRITER"")"
The Java DataOutputStream class enables you to write Java primitives to OutputStream's instead of only bytes.,"(""DataOutputStream"", ""DataOutputStream is a class that enables writing Java primitives to OutputStream, indicating a functional relationship between the two classes."", ""OutputStream"")"
"As mentioned earlier, the DataOutputStream class is often used together with a DataInputStream.","(""DataOutputStream"", ""DataOutputStream and DataInputStream are related because they are often used together for input and output operations."", ""DataInputStream"")"
But what happens if an exception is thrown from inside the doSomethingWithData() method?,"(""doSomethingWithData"", ""The doSomethingWithData method is mentioned in the context of handling exceptions, indicating a relationship where the method might throw or handle exceptions."", ""exception"")"
"Well, to catch that situation you will have to wrap the call to close() in a try-catch block too, like this:","(""CLOSE"", ""The method CLOSE is typically used within a TRY-CATCH BLOCK to handle exceptions that may occur during its execution."", ""TRY-CATCH BLOCK"")"
"But, what happens if an exception is also thrown from the input.close() method?","(""INPUT.CLOSE"", ""The method input.close() is mentioned in the context of an exception being thrown, indicating a relationship between the method and the exception."", ""EXCEPTION"")"
"Separate pages will describe each of these methods or classes in more detail, including examples of their usage etc.","(""METHOD"", ""The text suggests that methods and classes are related as they are both described in detail and examples of their usage are provided."", ""CLASS"")"
The Java IO API contains the following classes which are relevant to working with files in Java:,"(""Java IO API"", ""The Java IO API is a package that includes classes for working with files, such as Java."", ""Java"")"
"These classes are explained in more detail in their own texts, but the sections below will give a brief introduction to these classes.","(""Classes"", ""The text mentions classes and provides a brief introduction to them, indicating a relationship between the term 'classes' and the concept of classes."", ""Classes"")"
"These two classes lets you read a file one byte or character at a time from the start to the end of the file, or read the bytes into an array of byte or char, again from start towards the end of the file.","(""Classes"", ""The classes are used to read a file one byte or character at a time."", ""File"")"
"As I have already mentioned, you can get random access to files with Java IO via the RandomAccessFile class.","(""RandomAccessFile"", ""The RandomAccessFile class is part of the Java IO package, which provides random access to files."", ""Java IO"")"
Both file and directory information is available via the File class.,"(""File"", ""The text states that file and directory information is available via the File class, indicating a relationship between the concept of file and the File class."", ""class"")"
The FilterInputStream is a base class for implementing your own filtering input streams.,"(""FilterInputStream"", ""FilterInputStream is described as a base class, indicating it is a class entity."", ""class"")"
"It is intended to be a base class for your own subclasses, but in my opinion you might as well just subclass InputStream directly.","(""InputStream"", ""InputStream is mentioned as a class that can be subclassed directly."", ""subclass"")"
I cannot see that this class actually adds or changes any behaviour in InputStream except that it takes an InputStream in its constructor.,"(""InputStream"", ""The class InputStream is mentioned as being taken in its constructor, indicating a relationship between the class and its constructor."", ""InputStream"")"
The FilterOutputStream is a base class for implementing your own filtering output streams.,"(""FilterOutputStream"", ""FilterOutputStream is identified as a base class for implementing filtering output streams."", ""class"")"
I cannot see that this class actually adds or changes any behaviour in OutputStream except that it takes an OutputStream in its constructor.,"(""OutputStream"", ""The constructor method takes an OutputStream as a parameter, indicating a relationship between the class and the method."", ""constructor"")"
"If you choose to extend this class you might as well extend the OutputStream class directly, and avoid the extra class in the hierarchy.","(""OutputStream"", ""OutputStream is mentioned as a class that can be extended, indicating its role as a class entity."", ""class"")"
The FilterReader is a base class for implementing your own filtering readers.,"(""FilterReader"", ""FilterReader is described as a base class for implementing filtering readers."", ""class"")"
"Like with FilterInputStream, I see no sensible purpose for this class.","(""FilterInputStream"", ""FilterInputStream is mentioned as a class in the text."", ""class"")"
I cannot see that this class actually adds or changes any behaviour in Reader except that it takes a Reader in its constructor.,"(""Reader"", ""The constructor method takes a Reader class as a parameter, indicating a relationship between them."", ""constructor"")"
"If you choose to extend this class you might as well extend the Reader class directly, and avoid the extra class in the hierarchy.","(""Reader"", ""The Reader is mentioned as a class that can be extended directly, indicating a relationship between the Reader and the concept of a class."", ""class"")"
The FilterWriter is a base class for implementing your own filtering Writer's.,"(""FilterWriter"", ""FilterWriter is a base class for implementing filtering Writers."", ""Writer"")"
"Like with FilterOutputStream, I see no sensible purpose for this class.","(""FilterOutputStream"", ""FilterOutputStream is identified as a class in the text."", ""class"")"
I cannot see that this class actually adds or changes any behaviour in Writer except that it takes a Writer in its constructor.,"(""Writer"", ""The constructor takes a Writer as a parameter, indicating a relationship between the Writer class and the constructor method."", ""constructor"")"
"If you choose to extend this class you might as well extend the Writer class directly, and avoid the extra class in the hierarchy.","(""Writer"", ""The Writer is mentioned as a class that can be extended directly, indicating a relationship with the concept of a class."", ""class"")"
Some of the classes in the Java IO API are designed to help you parse input.,"(""Java IO API"", ""The classes are part of the Java IO API package."", ""classes"")"
The purpose was rather to give you above quick list of classes related to parsing of input data.,"(""Classes"", ""The classes are related to the parsing of input data as mentioned in the text."", ""Parsing"")"
If you have to parse data you will often end up writing your own classes that use some of the classes in this list.,"(""classes"", ""The classes are used in conjunction with the list."", ""list"")"
The Java LineNumberReader class (java.io.LineNumberReader is a BufferedReader that keeps track of line numbers of the read characters.,"(""LineNumberReader"", ""LineNumberReader is part of the java.io.LineNumberReader package."", ""java.io.LineNumberReader""); (""LineNumberReader"", ""LineNumberReader is a BufferedReader, indicating an inheritance or usage relationship."", ""BufferedReader"")"
You can get the current line number from the LineNumberReader by calling the getLineNumber() method.,"(""LineNumberReader"", ""The getLineNumber method is called on the LineNumberReader class to retrieve the current line number."", ""getLineNumber"")"
"You can also set the current line number, should you need to, by calling the setLineNumber() method.","(""setLineNumber"", ""The text explicitly mentions calling the setLineNumber() method, indicating that setLineNumber is a method."", ""method"")"
Since FileOutputStream is a subclass of OutputStream this should be no problem.,"(""FileOutputStream"", ""FileOutputStream is a subclass of OutputStream, indicating an inheritance relationship."", ""OutputStream"")"
In this example the process() method cannot see if the InputStream it gets as parameter comes from the file system or the network (the example only shows the file system version).,"(""PROCESS"", ""The PROCESS method takes INPUTSTREAM as a parameter, indicating a functional relationship where INPUTSTREAM is used by PROCESS."", ""INPUTSTREAM"")"
The Java ObjectInputStream class (java.io.ObjectInputStream) enables you to read Java objects from an InputStream instead of just raw bytes.,"(""ObjectInputStream"", ""The ObjectInputStream class is part of the java.io.ObjectInputStream package."", ""java.io.ObjectInputStream""); (""ObjectInputStream"", ""The ObjectInputStream class enables reading Java objects from an InputStream."", ""InputStream"")"
"For this ObjectInputStream example to work the object you read must be an instance of MyClass, and must have been serialized into the file ""object.data"" via an ObjectOutputStream.","(""ObjectInputStream"", ""ObjectInputStream reads objects that must be instances of MyClass."", ""MyClass""); (""ObjectOutputStream"", ""ObjectOutputStream serializes instances of MyClass into a file."", ""MyClass"")"
Before you can serialize and de-serialize objects the class of the object must implement java.io.Serializable.,"(""Java.io.Serializable"", ""The class Java.io.Serializable is implemented by the object to enable serialization and de-serialization."", ""object"")"
"After that the ObjectInputStream is also closed, and the values read into the Person object are printed to System.out.","(""ObjectInputStream"", ""The ObjectInputStream class is used to read values into the Person object."", ""Person""); (""Person"", ""The values read into the Person object are printed to the System.out package."", ""System.out"")"
The Java ObjectOutputStream class (java.io.ObjectOutputStream) enables you to write Java objects to an OutputStream instead of just raw bytes.,"(""ObjectOutputStream"", ""The ObjectOutputStream class is part of the java.io.ObjectOutputStream package."", ""java.io.ObjectOutputStream""); (""ObjectOutputStream"", ""The ObjectOutputStream class enables writing Java objects to an OutputStream."", ""OutputStream"")"
In this text I will try to give you an overview of the classes in the Java IO (java.io) package.,"(""Java IO"", ""Java IO is a common name for the Java.io package, indicating they are the same or closely related."", ""Java.io"")"
"More specifically, I will try to group the classes after their purpose.","(""Classes"", ""class"")"
"This grouping should make it easier for you in the future, to determine the purpose of a class, or find the class you need for a specific purpose.","(""Class"", ""class"")"
"Java IO contains many subclasses of the InputStream, OutputStream, Reader and Writer classes.","(""Java IO"", ""InputStream is a class within the Java IO package."", ""InputStream""); (""Java IO"", ""OutputStream is a class within the Java IO package."", ""OutputStream""); (""Java IO"", ""Reader is a class within the Java IO package."", ""Reader""); (""Java IO"", ""Writer is a class within the Java IO package."", ""Writer"")"
"The reason is, that all of these subclasses are addressing various different purposes.",NULL
These purposes are nice to know about when reading through the Java IO classes.,"(""Java IO"", ""The classes are part of the Java IO package."", ""classes"")"
They make it somewhat easier to understand what the classes are targeting.,"(""Classes"", ""class"")"
"Having discussed sources, destinations, input, output and the various IO purposes targeted by the Java IO classes, here is a table listing most (if not all) Java IO classes divided by input, output, being byte based or character based, and any more specific purpose they may be addressing, like buffering, parsing etc.","(""Java IO"", ""The text discusses Java IO classes, indicating that Java IO is a class related to input, output, and various IO purposes."", ""class"")"
The PipedInputStream class makes it possible to read the contents of a pipe as a stream of bytes.,"(""PipedInputStream"", ""The PipedInputStream class is used to read the contents of a pipe as a stream of bytes."", ""read"")"
The read() method of a PipedInputStream returns an int which contains the byte value of the byte read.,"(""READ"", ""The READ method is a function that belongs to the PIPEDINPUTSTREAM class."", ""PIPEDINPUTSTREAM"")"
"If the read() method returns -1, there is no more data to read in the stream, and it can be closed.","(""Read"", ""The read method is used to read data from the stream."", ""Stream""); (""Read"", ""The read method returns data from the stream."", ""Data""); (""Read"", ""The read method indicates when the stream can be closed by returning -1."", ""Closed"")"
"Since PipedInputStream is a subclass of InputStream, PipedInputStream has the same basic methods and use patterns as an InputStream.","(""PipedInputStream"", ""PipedInputStream is a subclass of InputStream, indicating an inheritance relationship."", ""InputStream""); (""PipedInputStream"", ""PipedInputStream has the same basic methods as InputStream, indicating it inherits or overrides these methods."", ""methods"")"
The PipedOutputStream class makes it possible to write to a Java pipe as a stream of bytes.,"(""PipedOutputStream"", ""The PipedOutputStream class is part of the Java package, as it is used to write to a Java pipe."", ""Java"")"
The write() method of a PipedOutputStream takes an int which contains the byte value of the byte to write.,"(""Write"", ""The write() method is a function of the PipedOutputStream class."", ""PipedOutputStream"")"
"Since PipedOutputStream is a subclass of OutputStream, PipedOutputStream has the same basic methods and use patterns as an OutputStream.","(""PipedOutputStream"", ""PipedOutputStream is a subclass of OutputStream, indicating an inheritance relationship."", ""OutputStream""); (""PipedOutputStream"", ""PipedOutputStream shares the same basic methods and use patterns as OutputStream, suggesting a functional relationship."", ""OutputStream"")"
The Java PipedReader class (java.io.PipedReader) makes it possible to read the contents of a pipe as a stream of characters.,"(""PipedReader"", ""PipedReader is a class within the java.io package"", ""java.io"")"
The read() method of a Java PipedReader returns an int which contains the char value of the character read.,"(""Read"", ""The Read method is a function that belongs to the PipedReader class."", ""PipedReader"")"
"If the read() method returns -1, there is no more data to read in the PipedReader, and it can be closed.","(""Read"", ""The Read method is used to read data from the PipedReader class."", ""PipedReader"")"
Notice how there is no longer any explicit close() method call to the PipedReader instance.,"(""CLOSE"", ""The CLOSE method is related to the PIPEDREADER class as it is a method that would typically be called on an instance of this class."", ""PIPEDREADER"")"
The Java PipedWriter class (java.io.PipedWriter) makes it possible to write to a Java pipe as a stream of characters.,"(""PipedWriter"", ""PipedWriter is a class within the java.io package"", ""java.io"")"
The write() method of a PipedWriter takes an int which contains the byte value of the byte to write.,"(""Write"", ""The write() method is a function that belongs to the PipedWriter class, indicating that it is used to perform operations related to writing in this class."", ""PipedWriter"")"
"There are also versions of the write() method that take a String, char array etc.","(""write"", ""The write method can take a String as an argument, indicating a functional relationship."", ""String""); (""write"", ""The write method can take a char array as an argument, indicating a functional relationship."", ""char array"")"
Notice how there is no longer any explicit close() method call to the PipedWriter instance.,"(""CLOSE"", ""The CLOSE method is related to the PIPEDWRITER class as it is a method that would typically be called on an instance of this class."", ""PIPEDWRITER"")"
Creating a pipe using Java IO is done via the PipedOutputStream and PipedInputStream classes.,"(""PipedOutputStream"", ""PipedOutputStream and PipedInputStream are related as they are both used to create a pipe in Java IO."", ""PipedInputStream""); (""PipedOutputStream"", ""PipedOutputStream is a class within the Java IO package."", ""Java IO""); (""PipedInputStream"", ""PipedInputStream is a class within the Java IO package."", ""Java IO"")"
You can also connect the two pipe streams using their connect() methods.,"(""Connect"", ""The connect() method is used to connect two Pipe instances."", ""Pipe""); (""Connect"", ""The connect() method is used to connect two Stream instances."", ""Stream"")"
Both PipedInputStream and PipedOutputStream has a connect() method that can connect one to the other.,"(""PipedInputStream"", ""The connect() method is associated with the PipedInputStream class as it can be used to connect it to a PipedOutputStream."", ""connect""); (""PipedOutputStream"", ""The connect() method is associated with the PipedOutputStream class as it can be used to connect it to a PipedInputStream."", ""connect"")"
"The read() and write() calls on the streams are blocking, meaning if you try to use the same thread to both read and write, this may result in the thread deadlocking itself.","(""READ"", ""Both are methods that operate on streams and can cause blocking if used on the same thread."", ""WRITE""); (""READ"", ""The read method can block a thread if used improperly."", ""THREAD""); (""WRITE"", ""The write method can block a thread if used improperly."", ""THREAD"")"
The Java PrintStream class (java.io.PrintStream) enables you to write formatted data to an underlying OutputStream.,"(""PrintStream"", ""The PrintStream class is part of the java.io.PrintStream package."", ""java.io.PrintStream""); (""PrintStream"", ""The PrintStream class writes formatted data to an underlying OutputStream."", ""OutputStream"")"
"The PrintStream class can format primitive types like int, long etc.","(""PrintStream"", ""The PrintStream class can format primitive types like int."", ""int""); (""PrintStream"", ""The PrintStream class can format primitive types like long."", ""long"")"
You may be familiar with these two well-known PrintStream instances in Java: System.out and System.err .,"(""System"", ""The 'out' method is a member of the 'System' class, commonly used for standard output."", ""out""); (""System"", ""The 'err' method is a member of the 'System' class, commonly used for error output."", ""err"")"
"The Java PrintStream class contains the powerful format() and printf() methods (they do exactly the same, but the name ""printf"" is more familiar to C-programmers).","(""PrintStream"", ""The method 'format' is part of the 'PrintStream' class."", ""format""); (""PrintStream"", ""The method 'printf' is part of the 'PrintStream' class."", ""printf"")"
The Java PrintWriter class (java.io.PrintWriter) enables you to write formatted data to an underlying Writer.,"(""PrintWriter"", ""PrintWriter is a class within the java.io.PrintWriter package"", ""java.io.PrintWriter""); (""PrintWriter"", ""PrintWriter writes formatted data to an underlying Writer"", ""Writer"")"
The PrintWriter class has all the same methods as the PrintStream except for the methods to write raw bytes.,"(""PrintWriter"", ""The PrintWriter class contains methods."", ""methods""); (""PrintStream"", ""The PrintStream class contains methods."", ""methods""); (""PrintWriter"", ""The PrintWriter class has all the same methods as the PrintStream class except for the methods to write raw bytes."", ""PrintStream"")"
Being a Writer subclass the PrintWriter is intended to write text.,"(""Writer"", ""PrintWriter is a subclass of Writer"", ""PrintWriter"")"
"Third, the example calls the advanced printf() method of the PrintWriter which can insert formatted numbers into a text string.","(""Printf"", ""The Printf method is a method of the PrintWriter class, indicating that Printf is used within or by PrintWriter."", ""PrintWriter"")"
"In that way the PrintWriter is a bit different from other Writer subclasses which tend to have mostly constructors that can take other Writer instances as parameters (except for a few, like OutputStreamWriter).","(""PrintWriter"", ""PrintWriter is a subclass of Writer."", ""Writer""); (""OutputStreamWriter"", ""OutputStreamWriter is a subclass of Writer."", ""Writer"")"
The Java PrintWriter class contains the powerful format() and printf() methods.,"(""PrintWriter"", ""The method 'format' is part of the 'PrintWriter' class."", ""format""); (""PrintWriter"", ""The method 'printf' is part of the 'PrintWriter' class."", ""printf"")"
"The format() and printf() methods allow you to mix text and data in very advanced ways, using a formatting string.","(""FORMAT"", ""Both FORMAT and PRINTF are methods that allow mixing text and data using a formatting string."", ""PRINTF"")"
The Java Reader (java.io.Reader) and Java Writer class (java.io.Writer) in Java IO work much like the InputStream and OutputStream with the exception that Reader and Writer are character based.,"(""Java Reader"", ""Java Reader is a class within the Java IO package."", ""Java IO""); (""Java Writer"", ""Java Writer is a class within the Java IO package."", ""Java IO""); (""Java Reader"", ""Java Reader works similarly to InputStream, indicating a functional relationship."", ""InputStream""); (""Java Writer"", ""Java Writer works similarly to OutputStream, indicating a functional relationship."", ""OutputStream"")"
The Java Reader is the base class of all Reader's in the Java IO API.,"(""Java Reader"", ""Java Reader is described as the base class of all Reader's."", ""Reader""); (""Java Reader"", ""Java Reader is part of the Java IO API."", ""Java IO"")"
The Java Writer class is the base class of all Writers in the Java IO API.,"(""Writer"", ""The Writer class is part of the Java IO package as it is mentioned as being in the Java IO API."", ""Java IO"")"
Before you can use the SequenceInputStream you must import it in your Java class.,"(""SequenceInputStream"", ""SequenceInputStream is a class that needs to be imported from the Java package to be used in a Java class."", ""Java"")"
"This import statement should be at the top of your Java class, right under the package declaration.","(""import statement"", ""The import statement is used within the Java class to include external classes or packages."", ""Java""); (""package declaration"", ""The package declaration is part of the Java class structure, indicating the package to which the class belongs."", ""Java"")"
"The FileInputStream extends the InputStream class, so they can be used with the SequenceInputStream.","(""FileInputStream"", ""FileInputStream extends the InputStream class, indicating an inheritance relationship."", ""InputStream""); (""FileInputStream"", ""FileInputStream can be used with SequenceInputStream, suggesting a usage relationship."", ""SequenceInputStream""); (""InputStream"", ""InputStream can be used with SequenceInputStream, suggesting a usage relationship."", ""SequenceInputStream"")"
"When there is no more data to read from the second InputStream, the SequenceInputStream read() method will return -1, just like any other InputStream does.","(""SequenceInputStream"", ""The read method is a function of the SequenceInputStream class, used to read data from the stream."", ""read""); (""InputStream"", ""The read method is a common method used in InputStream classes to read data."", ""read"")"
The Java Serializable interface (java.io.Serializable is a marker interface your classes must implement if they are to be serialized and deserialized.,"(""Java Serializable"", ""Java Serializable is the name of the interface, and java.io.Serializable is its fully qualified name."", ""java.io.Serializable""); (""classes"", ""Classes must implement the Java Serializable interface to be serialized and deserialized."", ""Java Serializable"")"
"Therefore, a class implementing Serializable does not have to implement any specific methods.","(""Serializable"", ""Serializable is a class that can implement methods, indicating a relationship between the class and the methods it can implement."", ""implement"")"
Implementing Serializable thus just tells the Java serialization classes that this class is intended for object serialization.,"(""Serializable"", ""Serializable is a class that is intended for object serialization, indicating a method relationship."", ""serialization""); (""Java"", ""Serializable is a class used within the Java package for serialization purposes."", ""Serializable"")"
Here is an example of a class that implements the Java Serializable interface:,"(""Class"", ""The Class implements the Serializable interface, indicating a relationship between them."", ""Serializable"")"
"As you can see, the Person class implements the Serializable interface, but does not actually implement any methods.","(""Person"", ""The Person class implements the Serializable interface, indicating a relationship where Person is a subclass or implementation of Serializable."", ""Serializable"")"
"In addition to implementing the Serializable interface, a class intended for serialization should also contain a private static final long variable named serialVersionUID.","(""Serializable"", ""The class Serializable is related to the variable serialVersionUID as it is a common practice to define this variable in classes that implement Serializable for version control during serialization."", ""serialVersionUID"")"
"Here is the Person class from before, with a serialVersionUID variable added:","(""Person"", ""The serialVersionUID is a variable added to the Person class."", ""serialVersionUID"")"
"The serialVersionUID variable is used by Java's object serialization API to determine if a deserialized object was serialized (written) with the same version of the class, as it is now attempting to deserialize it into.","(""Serialversionuid"", ""The serialVersionUID is used to check the version of the class during the deserialization process."", ""Class""); (""Object Serialization"", ""Object Serialization is a part of Java's API."", ""Java"")"
Now the serialized Person object may not correspond to the new version of the Person class.,"(""Person"", ""The text refers to a serialized object and a class, indicating that the serialized Person object is related to the Person class."", ""Person"")"
To detect such problems a class implementing Serializable should contain a serialVersionUID field.,"(""Serializable"", ""The class Serializable should contain a serialVersionUID field to detect serialization problems."", ""serialVersionUID"")"
"If you make big changes to the class, you should also change its serialVersionUID value.","(""Class"", ""The serialVersionUID is a field within the class that should be updated when significant changes are made to the class."", ""Serialversionuid"")"
"These other object serialization mechanisms typically do not require your Java classes to implement Serializable, by the way.","(""Java"", ""Serializable is a class that Java classes can implement for object serialization."", ""Serializable"")"
"They are typically using Java Reflection to inspect your class, so implementing the Serializable interface would be superflous - it would not add any useful information.","(""Java Reflection"", ""Java Reflection is used to inspect the class."", ""class""); (""Serializable"", ""The Serializable interface is related to the class as it is mentioned in the context of implementing it."", ""class"")"
The class java.io.InputStream is the base class for all Java IO input streams.,"(""Java.io.InputStream"", ""Java.io.InputStream is part of the Java IO package"", ""Java IO"")"
"If you are writing a component that needs to read input from a stream, try to make our component depend on an InputStream, rather than any of it's subclasses (e.g.","(""InputStream"", ""InputStream is mentioned as a class that components should depend on for reading input from a stream."", ""class"")"
"Doing so makes your code able to work with all types of input streams, instead of only the concrete subclass.","(""Input Streams"", ""The text suggests that the code can work with all types of input streams, not just a specific subclass, indicating a relationship between the general class and its subclass."", ""Subclass"")"
Otherwise your code will not be able to call the unread() method on the PushbackInputStream.,"(""Unread"", ""The Unread method is a function that can be called on the PushbackInputStream class."", ""PushbackInputStream"")"
You typically read data from an InputStream by calling the read() method.,"(""InputStream"", ""The read method is called on an InputStream to read data from it."", ""read"")"
The read() method returns a int containing the byte value of the byte read.,"(""Read"", ""The Read method returns an Int, indicating a relationship where the method's output is of type Int."", ""Int"")"
"If there is no more data to be read, the read() method typically returns -1;","(""READ"", ""The text explicitly mentions the read() method, indicating that READ is a METHOD."", ""METHOD"")"
The class java.io.OutputStream is the base class of all Java IO output streams.,"(""Java.io.OutputStream"", ""Java.io.OutputStream is part of the Java IO package as it is a base class for output streams in Java."", ""Java IO"")"
"If you are writing a component that needs to write output to a stream, try to make sure that component depends on an OutputStream and not one of its subclasses.","(""OutputStream"", ""OutputStream is a class that can have subclasses, which are related to it as derived or extended classes."", ""subclasses"")"
You can even write your own stream classes to wrap the standard stream classes that comes with Java.,"(""Stream Classes"", ""Stream Classes are designed to wrap the Standard Stream Classes."", ""Standard Stream Classes""); (""Standard Stream Classes"", ""Standard Stream Classes are part of the Java package."", ""Java"")"
The Java StringReader class enables you to turn an ordinary String into a Reader.,"(""StringReader"", ""StringReader is a class that extends or implements the Reader class, enabling it to function as a Reader."", ""Reader""); (""StringReader"", ""StringReader is used to convert a String into a Reader, indicating a functional relationship between the two classes."", ""String"")"
Closing a Java StringReader can be done using the close() method like this:,"(""StringReader"", ""The close method is used to close a StringReader instance."", ""close"")"
Notice that there is no explicit close() call on the StringReader.,"(""StringReader"", ""class"")"
The Java StringWriter class (java.io.StringWriter) enables you to obtain the characters written to a Writer as a String.,"(""StringWriter"", ""StringWriter is part of the java.io.StringWriter package."", ""java.io.StringWriter""); (""StringWriter"", ""StringWriter is a type of Writer."", ""Writer""); (""StringWriter"", ""StringWriter enables obtaining characters as a String."", ""String"")"
Third the characters written to the StringWriter are obtained via the two methods toString() and getBuffer().,"(""StringWriter"", ""The method toString() is used to obtain characters written to the StringWriter."", ""toString""); (""StringWriter"", ""The method getBuffer() is used to obtain characters written to the StringWriter."", ""getBuffer"")"
The method toString() returns the characters written to the StringWriter as a String.,"(""toString"", ""The method toString() is used to return the characters written to the StringWriter."", ""StringWriter""); (""toString"", ""The method toString() returns the characters as a String."", ""String"")"
The method getBuffer() returns the StringBuffer used by the StringWriter to build the string from the written characters.,"(""getBuffer"", ""The method getBuffer() returns the StringBuffer used by the StringWriter."", ""StringBuffer""); (""getBuffer"", ""The method getBuffer() is used by the StringWriter to build the string."", ""StringWriter"")"
Notice how there is no longer any explicit close() method call to the StringWriter instance.,"(""CLOSE"", ""The CLOSE method is related to the STRINGWRITER class as it is typically used to close or finalize operations on instances of this class."", ""STRINGWRITER"")"
The Java IO API is located in the Java IO package (java.io).,"(""Java IO API"", ""The Java IO API is located in the Java IO package."", ""Java IO"")"
If you look at the Java IO classes in the java.io package the vast amount of choices can be rather confusing.,"(""Java IO"", ""The Java IO class is part of the java.io package."", ""java.io"")"
"The purpose of this tutorial is to try to give you an overview of how all these classes are grouped, and the purpose behind them, so you don't have to wonder whether you chose the right class, or whether a class already exists for your purpose.","(""Class"", ""class"")"
"That tutorial gives you a quick overview of the central concepts in the Java IO API, and an overview of all the central classes in the Java IO API.","(""Java IO API"", ""The central concepts are part of the Java IO API."", ""central concepts""); (""Java IO API"", ""The central classes are part of the Java IO API."", ""central classes"")"
The java.io package doesn't actually address all types of input and output.,"(""Java.io"", ""package"")"
"Those types of input are covered elsewhere, for instance by the JFC classes in the Swing project, or the Servlet and HTTP packages in the Java Enterprise Edition.","(""JFC"", ""JFC is a class within the Swing project."", ""Swing""); (""Servlet"", ""Servlet is a package within the Java Enterprise Edition."", ""Java Enterprise Edition""); (""HTTP"", ""HTTP is a package within the Java Enterprise Edition."", ""Java Enterprise Edition"")"
"However, the Java IO package does not contain classes to open network sockets which are necessary for network communication.","(""Java IO"", ""The Java IO package does not contain classes to open network sockets, indicating a relationship where the package lacks these classes."", ""network sockets"")"
"Once you have opened a socket (network connection) though, you read and write data to and from it via Java IO's InputStream and OutputStream classes.","(""Java IO"", ""InputStream is a class within the Java IO package."", ""InputStream""); (""Java IO"", ""OutputStream is a class within the Java IO package."", ""OutputStream"")"
"It contains classes that does much of the same as the Java IO and Java Networking APIs, but Java NIO can work in non-blocking mode.","(""Java IO"", ""Java NIO provides similar functionality to Java IO but with additional non-blocking capabilities."", ""Java NIO""); (""Java Networking"", ""Java NIO offers similar functionalities to Java Networking, with the added feature of non-blocking mode."", ""Java NIO"")"
The tutorial trail called Java How To's and Utilities also contain a few Java IO utilities - e.g.,"(""Java How To's and Utilities"", ""Java IO utilities are part of the Java How To's and Utilities package"", ""Java IO utilities"")"
"Here is a table listing most (if not all) Java IO classes divided by input, output, being byte based or character based, and any more specific purpose they may be addressing, like buffering, parsing etc.","(""Java IO"", ""Java IO is a package that includes the Input class."", ""Input""); (""Java IO"", ""Java IO is a package that includes the Output class."", ""Output""); (""Java IO"", ""Java IO is a package that includes the Byte Based class."", ""Byte Based""); (""Java IO"", ""Java IO is a package that includes the Character Based class."", ""Character Based"")"
"The Java OutputStream class, java.io.OutputStream, is the base class of all output streams in the Java IO API.","(""OutputStream"", ""java.io.OutputStream is a specific implementation of the OutputStream class"", ""java.io.OutputStream""); (""java.io.OutputStream"", ""java.io.OutputStream is part of the Java IO API package"", ""Java IO API"")"
Subclasses of OutputStream include the Java BufferedOutputStream and the Java FileOutputStream among others.,"(""BufferedOutputStream"", ""BufferedOutputStream is a subclass of OutputStream"", ""OutputStream""); (""FileOutputStream"", ""FileOutputStream is a subclass of OutputStream"", ""OutputStream""); (""BufferedOutputStream"", ""BufferedOutputStream is part of the Java package"", ""Java""); (""FileOutputStream"", ""FileOutputStream is part of the Java package"", ""Java"")"
Here are some of the well-known subclasses of the Java OutputStream class:,"(""OutputStream"", ""OutputStream is a class in the Java programming language"", ""Java"")"
The write() method of an OutputStream takes an int which contains the byte value of the byte to write.,"(""Write"", ""The write method is a function that belongs to the OutputStream class, as it operates on an instance of OutputStream to perform its task."", ""OutputStream"")"
This OutputStream write() example first creates a FileOutputStream to which the data will be written.,"(""OutputStream"", ""The write method is associated with the OutputStream class as it is a common method used to write data to an output stream."", ""write""); (""FileOutputStream"", ""FileOutputStream is a subclass of OutputStream, used specifically for writing data to a file."", ""OutputStream"")"
The condition to exit the while loop is the return value of the method hasMoreData().,"(""HasMoreData"", ""The method HasMoreData is used as the condition to exit the while loop."", ""while loop"")"
"The implementation of hasMoreData() is not shown, but imagine that it returns true if there is more data to write, and false if not.","(""hasMoreData"", ""The method hasMoreData is related to its implementation, which is mentioned in the text."", ""implementation"")"
"Inside the while loop the example calls the method getMoreData() to get the next data to write to the OutputStream, and then writes that data to the OutputStream.","(""GetMoreData"", ""The method GetMoreData is called to retrieve data that is then written to the OutputStream."", ""OutputStream"")"
The Java OutputStream's flush() method flushes all data written to the OutputStream to the underlying data destination.,"(""OutputStream"", ""The flush() method is a function that operates on the OutputStream class to flush all data written to it to the underlying data destination."", ""flush()"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your OutputStream has).","(""FLUSH"", ""The method FLUSH is used to ensure that any buffered data in the OUTPUTSTREAM is written to its destination."", ""OUTPUTSTREAM"")"
Here is an example of flushing data written to a Java OutputStream by calling its flush() method:,"(""OutputStream"", ""The flush method is called on the OutputStream class to flush data written to it."", ""flush"")"
"What matters is, that once the while loop ends, and you are done writing data to the OutputStream, its close() method is called, which closes the OutputStream .","(""close"", ""The close method is called to close the OutputStream after writing data."", ""OutputStream"")"
"Once the try block is exited, the close() method of the OutputStream is called automatically, because the OutputStream was declared inside the parentheses of the try block.","(""Close"", ""The Close method is called on the OutputStream class to close the stream automatically when the try block is exited."", ""OutputStream"")"
You can convert a OutputStream to a character based Writer using the Java OutputStreamWriter class.,"(""OutputStream"", ""OutputStreamWriter is used to convert an OutputStream to a character-based Writer."", ""OutputStreamWriter""); (""OutputStreamWriter"", ""OutputStreamWriter converts an OutputStream to a Writer."", ""Writer""); (""OutputStreamWriter"", ""OutputStreamWriter is a class within the Java package."", ""Java"")"
"The Java OutputStreamWriter class, java.io.OutputStreamWriter, is intended to wrap an Java OutputStream and thereby turning the byte based output stream into a character based Writer.","(""Java OutputStreamWriter"", ""Java OutputStreamWriter is the class name and java.io.OutputStreamWriter is its fully qualified name in the java.io package."", ""java.io.OutputStreamWriter""); (""Java OutputStreamWriter"", ""Java OutputStreamWriter wraps a Java OutputStream to convert it into a character-based Writer."", ""Java OutputStream""); (""Java OutputStreamWriter"", ""Java OutputStreamWriter converts a byte-based output stream into a character-based Writer."", ""Writer""); (""java.io.OutputStreamWriter"", ""java.io.OutputStreamWriter is part of the java.io package."", ""java.io"")"
"The Java OutputStreamWriter is useful if you need to write characters to a file, encoded as e.g.","(""OutputStreamWriter"", ""OutputStreamWriter is a class in the Java programming language."", ""Java"")"
The Java OutputStreamWriter is a subclass of the Java Writer class.,"(""Java OutputStreamWriter"", ""Java OutputStreamWriter is a subclass of the Java Writer class."", ""Java Writer"")"
"The Java OutputStreamWriter also has alternative constructors that allow you to specify the character set (ISO-Latin1, UTF-8, UTF-16 etc.)","(""OutputStreamWriter"", ""OutputStreamWriter can specify the character set using ISO-Latin1."", ""ISO-Latin1""); (""OutputStreamWriter"", ""OutputStreamWriter can specify the character set using UTF-8."", ""UTF-8""); (""OutputStreamWriter"", ""OutputStreamWriter can specify the character set using UTF-16."", ""UTF-16"")"
The Java OutputStreamWriter's flush() method flushes all data written to the OutputStreamWriter to the underlying data destination.,"(""flush()"", ""The flush() method is a function of the Java OutputStreamWriter class."", ""Java OutputStreamWriter""); (""flush()"", ""The flush() method is a function of the OutputStreamWriter class."", ""OutputStreamWriter"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your OutputStreamWriter has).","(""FLUSH"", ""The method FLUSH is used to ensure that any buffered data in the OUTPUTSTREAMWRITER is written to its destination."", ""OUTPUTSTREAMWRITER"")"
Here is an example of flushing data written to a Java OutputStreamWriter by calling its flush() method:,"(""OutputStreamWriter"", ""The flush method is called on the OutputStreamWriter class to flush data written to it."", ""flush"")"
These bytes will then be read again the next time you call read().,"(""read"", ""The method 'read' is used to read bytes."", ""bytes"")"
"The Java PushbackInputStream is a subclass of the Java InputStream so it inherits its public methods - read(), close() etc.","(""Java PushbackInputStream"", ""Java PushbackInputStream is a subclass of Java InputStream, indicating an inheritance relationship."", ""Java InputStream""); (""Java PushbackInputStream"", ""Java PushbackInputStream inherits the read() method from Java InputStream."", ""read()""); (""Java PushbackInputStream"", ""Java PushbackInputStream inherits the close() method from Java InputStream."", ""close()"")"
The call to read() reads a byte just like from an InputStream.,"(""Read"", ""The method Read is used to read a byte from the class InputStream."", ""InputStream"")"
The call to unread() pushes a byte back into the PushbackInputStream.,"(""Unread"", ""The method Unread is used to push a byte back into the class PushbackInputStream."", ""Pushbackinputstream"")"
The next time read() is called the pushed back bytes will be read first.,"(""READ"", ""The method 'read()' is related to 'pushed back bytes' because it specifies that these bytes will be read first when the method is called."", ""PUSHED BACK BYTES"")"
"If you push back multiple bytes into the PushbackInputStream, the latest byte pushed back will be returned first from read(), just like on a stack.","(""PushbackInputStream"", ""The read method is used to retrieve bytes from the PushbackInputStream class."", ""read"")"
"You read bytes from the Java PushbackInputStream via its read() method, just like you do from a regular InputStream .","(""Java PushbackInputStream"", ""The read() method is used to read bytes from the Java PushbackInputStream class."", ""read()""); (""InputStream"", ""The read() method is also used to read bytes from a regular InputStream class."", ""read()"")"
"Notice, that once the PushbackInputStream has no more bytes to read, from its underlying PushbackInputStream, the read() method will return -1.","(""PushbackInputStream"", ""The read method is used to read bytes from the PushbackInputStream class."", ""read"")"
To push a byte back into the Java PushbackInputStream you use the unread() method.,"(""unread"", ""The unread method is used to push a byte back into the PushbackInputStream class."", ""PushbackInputStream""); (""PushbackInputStream"", ""The PushbackInputStream class is part of the Java package."", ""Java"")"
"This example first reads a byte from the PushbackInputStream, then pushes it back into the PushbackInputStream, and then reads that byte back again with the final read() call.","(""PushbackInputStream"", ""The read method is used to read a byte from the PushbackInputStream."", ""read""); (""PushbackInputStream"", ""The push method is used to push a byte back into the PushbackInputStream."", ""push""); (""read"", ""The read method is followed by the push method to demonstrate reading and then pushing back a byte."", ""push"")"
"The Java PushbackReader class, java.io.PushbackReader, is intended to be used when you parse data from a Reader.","(""PushbackReader"", ""The class PushbackReader is specifically referred to as java.io.PushbackReader, indicating a direct relationship."", ""java.io.PushbackReader""); (""java.io.PushbackReader"", ""The class java.io.PushbackReader is part of the java.io package."", ""java.io""); (""PushbackReader"", ""The PushbackReader class is used to parse data from a Reader, indicating a functional relationship."", ""Reader"")"
These characters will then be read again the next time you call read().,"(""call"", ""The method 'read' is invoked when you call it."", ""read"")"
The call to read() reads a character from the PushbackReader just like from any other Reader.,"(""Read"", ""The method 'read' is used to read a character from the 'PushbackReader' class."", ""PushbackReader""); (""Read"", ""The method 'read' is used to read a character from the 'Reader' class, similar to its use with 'PushbackReader'."", ""Reader"")"
The call to unread() pushes a character back into the PushbackReader.,"(""Unread"", ""The method Unread is used to push a character back into the Pushbackreader class."", ""Pushbackreader"")"
The next time read() is called the pushed back characters will be read first.,"(""READ"", ""The method 'read()' is related to 'pushed back characters' because it specifies that these characters will be read first when the method is called."", ""PUSHED BACK CHARACTERS"")"
"If you push back multiple characters into the PushbackReader, the latest pushed back character will be returned first from the read() method, just like with a stack.","(""PushbackReader"", ""The read method is used to retrieve characters from the PushbackReader class."", ""read"")"
You read characters from a Java PushbackReader just like you do from a Java Reader - because PushbackReader is a Java Reader subclass.,"(""PushbackReader"", ""PushbackReader is a subclass of Reader, indicating an inheritance relationship."", ""Reader"")"
"In other words, you use its read() method which is inherited from the Reader class.","(""READ"", ""The read method is inherited from the Reader class, indicating a relationship between the method and the class."", ""READER""); (""READER"", ""The Reader class provides the read method, establishing a connection between the class and the method."", ""READ"")"
Here is an example of reading characters from a Java PushbackReader via its read() method:,"(""PushbackReader"", ""The read method is a function that belongs to the PushbackReader class, indicating that it is used to perform operations on instances of this class."", ""read"")"
"The read() returns an int which you will have to cast to a char yourself, as shown in the example above.","(""READ"", ""The method READ returns an INT."", ""INT"")"
When there are no characters available in the PushbackReader the read() method will return the int value -1.,"(""PushbackReader"", ""The read() method is a function that operates on the PushbackReader class."", ""read"")"
To push a character back into a Java PushbackReader you must call its unread() method.,"(""PushbackReader"", ""The unread() method is a function that belongs to the PushbackReader class, allowing characters to be pushed back into the stream."", ""unread"")"
"This way the nextToken() method can ""sample"" the first character of the next token, and based on that decide what kind of token it is, and what read method to call for that kind of token.","(""nextToken"", ""The nextToken method decides which read method to call based on the type of token."", ""read"")"
"For the readSingleTokenWord() however, it is necessary, as the character read is the first character of the token's value.","(""readSingleTokenWord"", ""The method readSingleTokenWord is related to character as it reads the first character of the token's value."", ""character"")"
"The implementations of the readDoubleQuotedToken(), readSingleQuotedToken() and readSingleWordToken() have been left out to keep the example short.","(""readDoubleQuotedToken"", ""Both are methods mentioned in the text and likely part of the same implementation context."", ""readSingleQuotedToken""); (""readDoubleQuotedToken"", ""Both are methods mentioned in the text and likely part of the same implementation context."", ""readSingleWordToken""); (""readSingleQuotedToken"", ""Both are methods mentioned in the text and likely part of the same implementation context."", ""readSingleWordToken"")"
"Just imagine they read a token enclosed by double quotes (""), single quotes (') or a token which ends with a non-word character (e.g.",NULL
The Java RandomAccessFile class in the Java IO API allows you to move navigate a file and read from it or write to it as you please.,"(""Java RandomAccessFile"", ""The Java RandomAccessFile class is part of the Java IO package, as it is mentioned in the context of the Java IO API."", ""Java IO"")"
Before you can work with the RandomAccessFile class you must instantiate it.,"(""RandomAccessFile"", ""The RandomAccessFile class must be instantiated before it can be used."", ""instantiate"")"
You can obtain the current position of a Java RandomAccessFile using its getFilePointer() method.,"(""RandomAccessFile"", ""The getFilePointer method is used to obtain the current position of a RandomAccessFile."", ""getFilePointer"")"
Here is an example of obtaining the current position of a RandomAccessFile using its getFilePointer() method:,"(""RandomAccessFile"", ""The getFilePointer method is used to obtain the current position of a RandomAccessFile."", ""getFilePointer"")"
Reading a byte from a Java RandomAccessFile is done using its read() method.,"(""RandomAccessFile"", ""The read() method is used to read a byte from a RandomAccessFile, indicating that the method is part of the class."", ""read"")"
The read() method reads the byte located a the position in the file currently pointed to by the file pointer in the RandomAccessFile instance.,"(""Read"", ""The Read method is used to read bytes from a file, which is managed by the RandomAccessFile class."", ""RandomAccessFile"")"
Here is a thing the JavaDoc forgets to mention: The read() method increments the file pointer to point to the next byte in the file after the byte just read!,"(""Read"", ""The read() method increments the file pointer to point to the next byte in the file after the byte just read."", ""File Pointer"")"
This means that you can continue to call read() without having to manually move the file pointer.,"(""read"", ""The method read() is related to the file pointer because it involves reading data from a file, which typically requires managing the file pointer position."", ""file pointer"")"
This example reads a sequence of bytes into the dest byte array passed as parameter to the read() method.,"(""Read"", ""The read() method takes the dest byte array as a parameter, indicating a relationship where the method operates on the byte array."", ""Dest Byte Array"")"
The read() method will start reading in the file from the current file position of the RandomAccessFile.,"(""Read"", ""The read() method is a function that operates on the RandomAccessFile class to read data from a file."", ""RandomAccessFile"")"
"The read() method will start writing data into the byte array starting from the array position provided by the offset parameter, and at most the number of bytes provided by the length parameter.","(""Read"", ""The Read method writes data into the Byte Array."", ""Byte Array""); (""Read"", ""The Offset parameter specifies the starting position in the Byte Array for the Read method."", ""Offset""); (""Read"", ""The Length parameter specifies the maximum number of bytes to be read by the Read method."", ""Length"")"
You can write a single byte to a RandomAccessFile using its write() method which takes an int as parameter.,"(""RandomAccessFile"", ""The write method is a function that belongs to the RandomAccessFile class, allowing it to perform operations such as writing a single byte."", ""write"")"
"Remember, calling this write() method will advance the file position of the RandomAccessFile by 1.","(""WRITE"", ""The write() method is called on the RandomAccessFile class, indicating a functional relationship where the method operates on instances of the class."", ""RANDOMACCESSFILE"")"
Writing to a RandomAccessFile can be done using one it its many write() methods.,"(""RandomAccessFile"", ""The write method is used to perform writing operations on a RandomAccessFile."", ""write"")"
Just like with the read() method the write() method advances the file pointer after being called.,"(""READ"", ""Both are methods that manipulate the file pointer."", ""WRITE"")"
The RandomAccessFile has a close() method which must be called when you are done using the RandomAccessFile instance.,"(""RandomAccessFile"", ""The close() method is associated with the RandomAccessFile class as it must be called when done using an instance of RandomAccessFile."", ""close()"")"
You can see example of calls to close() in the examples above.,"(""close"", ""The method 'close' is mentioned in the context of examples, indicating it is used or demonstrated in them."", ""examples"")"
"The Java Reader class, java.io.Reader, is the base class for all Reader subclasses in the Java IO API.","(""Reader"", ""java.io.Reader is a specific implementation of the Reader class"", ""java.io.Reader""); (""Reader"", ""Reader is part of the Java IO package"", ""Java IO"")"
"This is done when you instantiate the Reader (actually, when you instantiate one of its subclasses).","(""Reader"", ""The Reader class is related to its subclasses because instantiation of Reader involves instantiation of one of its subclasses."", ""subclasses"")"
You will normally use a Reader subclass rather than a Reader directly.,"(""Reader"", ""A Reader subclass is a specific type of Reader class."", ""Reader subclass"")"
Here is an example of creating a Java FileReader which is a subclass of Java Reader:,"(""Java FileReader"", ""Java FileReader is a subclass of Java Reader"", ""Java Reader"")"
The read() method of a Java Reader returns an int which contains the char value of the next character read.,"(""Read"", ""The Read method is a function that belongs to the Java Reader class, as it operates on instances of this class."", ""Java Reader"")"
"If the read() method returns -1, there is no more data to read in the Reader, and it can be closed.","(""Read"", ""The Read method is used to read data from the Reader class."", ""Reader"")"
"If not, it processes that char and continues reading until -1 is returned from the Reader read() method.","(""Reader"", ""The read method is associated with the Reader class as it is a method that operates on or is defined within the Reader class."", ""read"")"
"The Java Reader class also has a read() method that takes a char array as parameter, as well as a start offset and length.","(""Reader"", ""The read method is a function of the Reader class."", ""read"")"
The Java Reader class has a method named skip() which can be used to skip over a number of characters in the input that you do not want to read.,"(""Reader"", ""The skip method is a function of the Reader class, used to skip over characters in the input."", ""skip"")"
The Java StreamTokenizer class (java.io.StreamTokenizer) can tokenize the characters read from a Reader into tokens.,"(""Java StreamTokenizer"", ""Java StreamTokenizer is a class represented by java.io.StreamTokenizer"", ""java.io.StreamTokenizer""); (""Java StreamTokenizer"", ""Java StreamTokenizer can tokenize characters read from a Reader"", ""Reader""); (""Java StreamTokenizer"", ""Java StreamTokenizer has a method to tokenize characters"", ""tokenize""); (""java.io.StreamTokenizer"", ""java.io.StreamTokenizer is part of the java.io package"", ""java.io"")"
You do so by calling the nextToken() method of the StreamTokenizer inside a loop.,"(""NextToken"", ""The NextToken method is a function that belongs to the StreamTokenizer class, as it is called on an instance of StreamTokenizer."", ""StreamTokenizer"")"
"After each call to nextToken() the StreamTokenizer has several fields you can read to see what kind of token was read, it's value etc.","(""nextToken"", ""The method nextToken is a part of the StreamTokenizer class, as it is called on it."", ""StreamTokenizer"")"
"Java has 3 streams called System.in, System.out, and System.err which are commonly used to provide input to, and output from Java applications.","(""Java"", ""System.in is a stream class used in Java applications for input."", ""System.in""); (""Java"", ""System.out is a stream class used in Java applications for output."", ""System.out""); (""Java"", ""System.err is a stream class used in Java applications for error output."", ""System.err""); (""System.in"", ""System.in and System.out are both stream classes used in Java applications for input and output respectively."", ""System.out""); (""System.in"", ""System.in and System.err are both stream classes used in Java applications for input and error output respectively."", ""System.err""); (""System.out"", ""System.out and System.err are both stream classes used in Java applications for output and error output respectively."", ""System.err"")"
Most commonly used is probably System.out for writing output to the console from console programs (command line applications).,"(""System"", ""The 'out' method is a member of the 'System' class, used for output operations."", ""out"")"
"System.in, System.out and System.err are initialized by the Java runtime when a Java VM starts up, so you don't have to instantiate any streams yourself (although you can exchange them at runtime).","(""System.in"", ""System.in is initialized by the Java runtime."", ""Java runtime""); (""System.out"", ""System.out is initialized by the Java runtime."", ""Java runtime""); (""System.err"", ""System.err is initialized by the Java runtime."", ""Java runtime""); (""Java runtime"", ""Java runtime initializes when a Java VM starts up."", ""Java VM"")"
System.in is an InputStream which is typically connected to keyboard input of console programs.,"(""System.in"", ""System.in is an instance of the InputStream class, indicating it inherits or implements its functionality."", ""InputStream"")"
"In other words, if you start a Java application from the command line, and you type something on the keyboard while the CLI console (or terminal) has focus, the keyboard input can typically be read via System.in from inside that Java application.","(""Java"", ""System.in is used within a Java application to read keyboard input."", ""System.in"")"
"However, it is only keyboard input directed to that Java application (the console / terminnal that started the application) which can be read via System.in.","(""System.in"", ""System.in is used to read keyboard input directed to the Java application."", ""Java application"")"
Keyboard input for other applications cannot be read via System.in .,"(""System.in"", ""class"")"
"System.in is not used as often since data is commonly passed to a command line Java application via command line arguments, files, or possibly via network connections if the application is designed for that.","(""System.in"", ""System.in is a class that is part of the Java package, commonly used for input operations in Java applications."", ""Java"")"
System.out normally outputs the data you write to it to the CLI console / terminal.,"(""System"", ""The 'out' method is a member of the 'System' class, used for outputting data."", ""out"")"
System.out is often used from console-only programs like command line tools as a way to display the result of their execution to the user.,"(""System"", ""The 'out' method is a member of the 'System' class, used for output operations."", ""out"")"
System.err works like System.out except it is normally only used to output error texts.,"(""System.err"", ""System.err and System.out are related because they are both classes used for output, with System.err specifically for error texts."", ""System.out"")"
"Some programs (like Eclipse) will show the output to System.err in red text, to make it more obvious that it is error text.","(""System.err"", ""System.err is used in programs like Eclipse to display error text."", ""Eclipse"")"
"Even if the 3 System streams are static members of the java.lang.System class, and are pre-instantiated at JVM startup, you can change what streams to use for each of them.","(""System"", ""The System class is part of the java.lang.System package."", ""java.lang.System""); (""System"", ""The System class streams are pre-instantiated at JVM startup, indicating a relationship with the JVM class."", ""JVM"")"
"Just set a new InputStream for System.in or a new OutputStream for System.out or System.err, and all further data will be read / written to the new stream.","(""InputStream"", ""InputStream is set for System.in to read data from the new stream."", ""System.in""); (""OutputStream"", ""OutputStream is set for System.out to write data to the new stream."", ""System.out""); (""OutputStream"", ""OutputStream is set for System.err to write data to the new stream."", ""System.err"")"
"To set a new System stream, use one of th emethods System.setIn(), System.setOut() or System.setErr().","(""System"", ""The method setIn is a part of the System class, used to set a new input stream."", ""setIn""); (""System"", ""The method setOut is a part of the System class, used to set a new output stream."", ""setOut""); (""System"", ""The method setErr is a part of the System class, used to set a new error stream."", ""setErr"")"
"Now all data written to System.out should be redirected into the file ""c:\\data\\system.out.txt"".","(""System.out"", ""System.out is a class that outputs data, which is being redirected to a file in the data package."", ""data"")"
"Keep in mind though, that you should make sure to flush System.out and close the file before the JVM shuts down, to be sure that all data written to System.out is actually flushed to the file.","(""System.out"", ""System.out needs to be flushed and closed before the JVM shuts down to ensure data integrity."", ""JVM"")"
The Java Writer class (java.io.Writer) is the base class for all Writer subclasses in the Java IO API.,"(""Writer"", ""The Writer class is the base class for java.io.Writer, indicating an inheritance relationship."", ""java.io.Writer""); (""java.io.Writer"", ""The java.io.Writer class is part of the Java IO package."", ""Java IO"")"
"The Java Writer subclasses can normally handle UTF-8 and UTF-16 encoding for you, so you don't have to worry about that.","(""Writer"", ""The Writer class can handle UTF-8 encoding."", ""UTF-8""); (""Writer"", ""The Writer class can handle UTF-16 encoding."", ""UTF-16"")"
You will normally use a Writer subclass rather than a Writer directly.,"(""Writer"", ""The text suggests using a subclass of Writer, indicating a relationship between the Writer class and its subclasses."", ""Writer"")"
The Java Writer's flush() method flushes all data written to the Writer to the underlying data destination.,"(""Writer"", ""The flush() method is a function that operates on the Writer class to flush data to the underlying destination."", ""flush()"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your Writer has).","(""FLUSH"", ""The method FLUSH is used to ensure that any buffered data in the WRITER class is written to its destination."", ""WRITER"")"
Here is an example of flushing data written to a Java Writer by calling its flush() method:,"(""Writer"", ""The flush method is called on the Writer class to flush data."", ""flush""); (""flush"", ""The flush method is part of the Java package."", ""Java"")"
"The concrete implementations of hasMoreCharacters() and getNextCharacter() are left out, but they are not really super important to understand the principle of this example.","(""hasMoreCharacters"", ""Both are methods mentioned in the context of the example, suggesting they are related in functionality or purpose."", ""getNextCharacter"")"
"What matters is, that once the while loop ends, and you are done writing data to the Writer, its close() method is called, which closes the Writer .","(""Writer"", ""The close() method is called on the Writer class to close it after writing data."", ""close()"")"
"Once the try block is exited, the close() method of the Writer is called automatically, because the Writer was declared inside the parentheses of the try block.","(""Writer"", ""The close() method is associated with the Writer class as it is called on an instance of Writer."", ""close"")"
"The SQL dialect used by the various different databases will vary slightly, so to be 100% database independent, you SQL must also be 100% database independent (i.e.","(""SQL"", ""SQL is related to Dialect as it specifies the type of SQL being used."", ""Dialect"")"
The Java String parameter passed to the Class forName() method is the name of the JDBC driver class for the given JDBC driver.,"(""Class"", ""The forName method belongs to the Class class."", ""forName""); (""JDBC"", ""The driver class is part of the JDBC package."", ""driver""); (""Java"", ""The String class is part of the Java package."", ""String"")"
You will have to find the right class name for the JDBC driver you are using.,"(""JDBC Driver"", ""The JDBC Driver is a class used in the context of JDBC, which is a Java Database Connectivity API."", ""JDBC"")"
"Typically, each database has its own JDBC driver, so you will have to look up what the JDBC driver class name is (if you are using pre Java 6).","(""JDBC Driver"", ""The JDBC Driver is a class used in Java for database connectivity."", ""Java"")"
"First you add the SQL statements to be executed in the batch, using the addBatch() method.","(""SQL statements"", ""The addBatch() method is used to add SQL statements to be executed in a batch."", ""addBatch"")"
The int[] array returned by the executeBatch() method is an array of int telling how many records were affected by each executed SQL statement in the batch.,"(""EXECUTEBATCH()"", ""The EXECUTEBATCH() method returns an INT[] array, indicating a direct relationship between the method and the class."", ""INT[]"")"
"Second, each set of parameter values are inserted into the preparedStatement, and the addBatch() method is called.","(""PreparedStatement"", ""The addBatch() method is called on the PreparedStatement class to insert parameter values."", ""AddBatch"")"
"Third, the executeBatch() method is called, which executes all the batch updates.","(""ExecuteBatch"", ""The executeBatch method is called to execute all the batch updates."", ""Batch Updates"")"
"By the way, imagine that the used Person class looks like this:","(""Person"", ""class"")"
A java.sql.CallableStatement is used to call stored procedures in a database.,"(""CallableStatement"", ""CallableStatement is a class within the java.sql package"", ""java.sql"")"
"A stored procedure is like a function or method in a class, except it lives inside the database.","(""Stored Procedure"", ""A stored procedure is compared to a function as they both perform similar roles."", ""Function""); (""Stored Procedure"", ""A stored procedure is likened to a method in terms of functionality."", ""Method""); (""Method"", ""A method is typically a function within a class."", ""Class""); (""Stored Procedure"", ""A stored procedure resides inside the database."", ""Database"")"
You create an instance of a CallableStatement by calling the prepareCall() method on a connection object.,"(""prepareCall"", ""The prepareCall method is used to create an instance of the CallableStatement class."", ""CallableStatement"")"
"If the stored procedure returns a ResultSet, and you need a non-default ResultSet (e.g.",NULL
The executeQuery() method is used if the stored procedure returns a ResultSet.,"(""EXECUTEQUERY"", ""The executeQuery method is related to ResultSet because it is used when the stored procedure returns a ResultSet."", ""RESULTSET"")"
"If the stored procedure just updates the database, you can call the executeUpdate() method instead, like this:","(""executeUpdate"", ""The executeUpdate method is used to update the database."", ""database"")"
"The JDBC Connection class, java.sql.Connection, represents a database connection to a relational database.","(""JDBC Connection"", ""The JDBC Connection class is represented by the java.sql.Connection class."", ""java.sql.Connection""); (""java.sql.Connection"", ""The java.sql.Connection class is part of the java.sql package."", ""java.sql"")"
Each JDBC driver has a primary driver class that initializes the driver when it is loaded.,"(""JDBC Driver"", ""The JDBC Driver has a primary driver class that initializes it."", ""Primary Driver Class""); (""Primary Driver Class"", ""The primary driver class initializes the driver when it is loaded."", ""Driver"")"
You open a JDBC Connection by call the java.sql.DriverManager class method getConnection().,"(""java.sql.DriverManager"", ""The getConnection method is a method of the java.sql.DriverManager class."", ""getConnection""); (""JDBC Connection"", ""The getConnection method is used to open a JDBC Connection."", ""getConnection"")"
This is how calling getConnection() only with the URL as parameter looks:,"(""getConnection"", ""The method getConnection is called with the URL as a parameter."", ""URL"")"
"The second variant of getConnection() takes both a database URL, a user name and a password as parameters.","(""getConnection"", ""The method getConnection takes a database URL as a parameter."", ""database URL""); (""getConnection"", ""The method getConnection takes a user name as a parameter."", ""user name""); (""getConnection"", ""The method getConnection takes a password as a parameter."", ""password"")"
Here is an example of calling that variant of getConnection() :,"(""getConnection"", ""method"")"
The third variant of getConnection() takes a database URL and a Properties object as parameter.,"(""getConnection"", ""The method getConnection() takes a Properties object as a parameter, indicating a relationship where Properties is used by getConnection."", ""Properties"")"
"The JDBC Connection setAutoCommit() method is used to switch the connection into, or out of, auto commit mode.","(""JDBC Connection"", ""The setAutoCommit method is used by the JDBC Connection class to manage the auto commit mode of the connection."", ""setAutoCommit"")"
"When not in auto commit mode, each database transaction must be explicitly committed by calling the Connection commit() method.","(""Connection"", ""The commit method is called on the Connection class to explicitly commit a database transaction."", ""commit"")"
"Keep in mind, that if some of the operations in the transaction fail, you would most likely want to call the rollback() method instead of commit().","(""ROLLBACK"", ""Both are methods used in transaction management, where ROLLBACK is used to undo operations and COMMIT is used to finalize them."", ""COMMIT"")"
The Java JDBC Connection rollback() method rolls back the operations executed within the currently ongoing transaction.,"(""Java JDBC Connection"", ""The rollback() method is a function of the Java JDBC Connection class, used to roll back operations within a transaction."", ""rollback()"")"
Exactly how to handle the calls to commit() and / or rollback() is covered in the JDBC Transactions Tutorial.,"(""COMMIT"", ""The method COMMIT is discussed in the JDBC Transactions Tutorial."", ""JDBC TRANSACTIONS TUTORIAL""); (""ROLLBACK"", ""The method ROLLBACK is discussed in the JDBC Transactions Tutorial."", ""JDBC TRANSACTIONS TUTORIAL"")"
Here is a simple example of calling the JDBC Connection rollback() method:,"(""JDBC Connection"", ""The rollback() method is a function that belongs to the JDBC Connection class, indicating that it is a method that can be called on instances of this class."", ""rollback()"")"
Notice how rollback() is called within the catch-block of a try-catch block.,"(""ROLLBACK"", ""ROLLBACK is called within the catch-block of a TRY-CATCH BLOCK"", ""TRY-CATCH BLOCK"")"
Here is an example of creating a JDBC Statement instance via the JDBC Connection createStatement() method:,"(""JDBC Connection"", ""The createStatement method is a function of the JDBC Connection class."", ""createStatement""); (""JDBC Connection"", ""The JDBC Connection class is used to create an instance of the JDBC Statement class via the createStatement method."", ""JDBC Statement"")"
Here is an example of creating a JDBC PreparedStatement instance via the JDBC Connection prepareStatement() method:,"(""Connection"", ""The prepareStatement() method is a method of the Connection class."", ""prepareStatement""); (""JDBC"", ""PreparedStatement is a class used within the JDBC package."", ""PreparedStatement""); (""JDBC"", ""Connection is a class used within the JDBC package."", ""Connection"")"
The JDBC Connection getMetaData() method returns a JDBC DatabaseMetaData object which can be used to introspect the database the JDBC Connection is connected to.,"(""JDBC Connection"", ""The getMetaData method is a method of the JDBC Connection class."", ""getMetaData""); (""getMetaData"", ""The getMetaData method returns a JDBC DatabaseMetaData object."", ""JDBC DatabaseMetaData"")"
Here is an example of creating a JDBC DatabaseMetaData object via the JDBC Connection getMetaData() method:,"(""JDBC"", ""DatabaseMetaData is a class that is part of the JDBC package"", ""DatabaseMetaData""); (""Connection"", ""getMetaData is a method of the Connection class"", ""getMetaData""); (""JDBC"", ""Connection is a class that is part of the JDBC package"", ""Connection"")"
Through the java.sql.DatabaseMetaData interface you can obtain meta data about the database you have connected to.,"(""DatabaseMetaData"", ""The DatabaseMetaData class is part of the java.sql package, as indicated by the naming convention and context."", ""java.sql"")"
"First you call the getTables() method, passing it 4 parameters which are all null.","(""getTables"", ""The getTables method requires parameters to be passed to it."", ""parameters"")"
The ResultSet returned from the getTables() method contains a list of table names matching the 4 given parameters (which were all null).,"(""getTables"", ""The getTables method returns a ResultSet, indicating a relationship where the method produces an instance of the class."", ""ResultSet"")"
The ResultSet returned by the getColumns() method contains a list of columns for the given table.,"(""getColumns"", ""The getColumns method returns a ResultSet, indicating a relationship where the method produces an instance of the class."", ""ResultSet"")"
The column type is an integer matching one of the type constants found in java.sql.Types,"(""Java.sql.Types"", ""The column type is an integer matching one of the type constants found in the java.sql.Types package"", ""Column Type"")"
"First you call the getPrimaryKeys() method, passing 3 parameters to it.","(""getPrimaryKeys"", ""The text explicitly mentions calling the getPrimaryKeys() method, indicating a relationship between the method name and its type."", ""method"")"
The ResultSet returned by the getPrimaryKeys() method contains a list of columns which make up the primary key of the given table.,"(""getPrimaryKeys"", ""The getPrimaryKeys method returns a ResultSet, indicating a direct relationship between the method and the class."", ""ResultSet"")"
"A JDBC driver is a set of Java classes that implement the JDBC interfaces, targeting a specific database.","(""JDBC Driver"", ""The JDBC Driver is implemented as a set of Java Classes."", ""Java Classes""); (""Java Classes"", ""Java Classes implement the JDBC Interfaces."", ""JDBC Interfaces"")"
A JDBC driver is a collection of Java classes that enables you to connect to a certain database.,"(""JDBC Driver"", ""JDBC Driver is a collection of Java classes, indicating it is implemented using Java."", ""Java"")"
"This works for executing queries too, using the executeQuery() method, which returns a ResultSet.","(""ExecuteQuery"", ""The ExecuteQuery method returns a ResultSet, indicating a functional relationship where the method's execution results in an instance of the class."", ""ResultSet"")"
"The ResultSet.next() method moves to the next row in the ResultSet, if there are anymore rows.","(""ResultSet"", ""The next method is a function that operates on the ResultSet class to move to the next row."", ""next"")"
You need to call next() at least one time before you can read any data.,"(""next()"", ""The method next() needs to be called before any data can be read, indicating a dependency or prerequisite relationship."", ""data"")"
Before the first next() call the ResultSet is positioned before the first row.,"(""ResultSet"", ""The method 'next' is likely a method that operates on the 'ResultSet' class, as it is mentioned in the context of calling it on a ResultSet."", ""next"")"
"You can get column data for the current row by calling some of the getXXX() methods, where XXX is a primitive data type.","(""getXXX()"", ""The getXXX() method is used to retrieve column data for the current row."", ""column data"")"
The column name to get the value of is passed as parameter to any of these getXXX() method calls.,"(""getXXX()"", ""The method getXXX() is used to retrieve the value of a column name passed as a parameter."", ""column name"")"
"You can get the index of a given column by calling the ResultSet.findColumn() method, like this:","(""ResultSet"", ""The findColumn method is a member of the ResultSet class, indicating that it is a function that can be called on an instance of ResultSet."", ""findColumn"")"
The text about queries shows how the result of a query is returned as a java.sql.ResultSet.,"(""ResultSet"", ""ResultSet is a class that is part of the java.sql package"", ""java.sql"")"
"The next() method returns true if the ResultSet has a next record, and moves the ResultSet to point to the next record.","(""Next"", ""The Next method is used to check and move the ResultSet to the next record."", ""ResultSet"")"
"If there were no more records, next() returns false, and you can no longer.","(""next"", ""The method 'next' returns the value 'false' when there are no more records."", ""false"")"
"Once the next() method has returned false, you should not call it anymore.","(""next()"", ""The next() method returns a boolean value, which can be true or false."", ""false"")"
Here is an example of iterating a ResultSet using the next() method:,"(""ResultSet"", ""The next() method is used to iterate over a ResultSet, indicating a functional relationship between the class and the method."", ""next()"")"
"As you can see, the next() method is actually called before the first record is accessed.","(""Next"", ""The term 'next()' is identified as a method in the text."", ""Method"")"
"Once next() has been called once, it points at the first record.","(""next()"", ""The method next() points at the first record after being called."", ""record"")"
"Similarly, when next() is called and returns false, the ResultSet is actually pointing after the last record.","(""next()"", ""The method next() is used to iterate over the records in the ResultSet class."", ""ResultSet"")"
You do so by calling one or more of the many getXXX() methods.,"(""getXXX()"", ""The text refers to 'getXXX()' as a method by mentioning it in the context of calling methods."", ""method"")"
"You pass the name of the column to get the value of, to the many getXXX() methods.","(""GETXXX"", ""The getXXX() methods are used to retrieve the value of a column."", ""COLUMN"")"
"There are a lot of getXXX() methods you can call, which return the value of the column as a certain data type, e.g.","(""getXXX()"", ""The method getXXX() is related to column as it returns the value of the column as a certain data type."", ""column"")"
Here is a list of quick examples of these getXXX() methods:,"(""getXXX()"", ""method"")"
The getXXX() methods also come in versions that take a column index instead of a column name.,"(""GETXXX"", ""The text refers to 'getXXX() methods', indicating that 'getXXX' is a method."", ""METHOD"")"
"If you do not know the index of a certain column you can find the index of that column using the ResultSet.findColumn(String columnName) method, like this:","(""ResultSet"", ""The findColumn method is a member of the ResultSet class, used to find the index of a column by its name."", ""findColumn"")"
The DatabaseMetaData.supportsResultSetType(int type) method returns true or false depending on whether the given type is supported or not.,"(""DatabaseMetaData"", ""The method supportsResultSetType is a member of the class DatabaseMetaData."", ""supportsResultSetType"")"
The DatabaseMetaData.supportsResultSetConcurrency(int concurrency) method returns true or false depending on whether the given concurrency mode is supported or not.,"(""DatabaseMetaData"", ""The method supportsResultSetConcurrency belongs to the class DatabaseMetaData."", ""supportsResultSetConcurrency"")"
It is when updateRow() is called that the database is updated with the values of the row.,"(""updateRow"", ""The method updateRow is responsible for updating the database with the values of the row."", ""database"")"
"If you call updateRow() inside a transaction, the data is not actually committed to the database until the transaction is committed.","(""updateRow"", ""The method updateRow is called within the context of a transaction, indicating a relationship where updateRow is an operation performed during a transaction."", ""transaction"")"
"The row pointed to after calling moveToInsertRow() is a special row, a buffer, which you can use to build up the row until all column values has been set on the row.","(""moveToInsertRow"", ""The method moveToInsertRow is related to the row as it points to a special row used as a buffer."", ""row"")"
"Once the row is ready to be inserted into the ResultSet, call the insertRow() method.","(""ResultSet"", ""The insertRow method is called on the ResultSet class to insert a row."", ""insertRow"")"
"If you need to insert another row, explicitly call moveToInsertRow() to signal this to the ResultSet.","(""MoveToInsertRow"", ""The method MoveToInsertRow is called on the ResultSet class to insert another row."", ""ResultSet"")"
The ResultSet holdability determines if a ResultSet is closed when the commit() method of the underlying connection is called.,"(""ResultSet"", ""The ResultSet class is affected by the commit method as it determines if a ResultSet is closed when the commit method of the underlying connection is called."", ""commit"")"
The DatabaseMetaData.supportsResultSetHoldability(int holdability) returns true or false depending on whether the given holdability mode is supported or not.,"(""DatabaseMetaData"", ""The method supportsResultSetHoldability is a member of the class DatabaseMetaData."", ""supportsResultSetHoldability"")"
The CLOSE_CURSORS_OVER_COMMIT holdability means that all ResultSet instances are closed when connection.commit() method is called on the connection that created the ResultSet.,"(""CLOSE_CURSORS_OVER_COMMIT"", ""CLOSE_CURSORS_OVER_COMMIT is a holdability setting that affects ResultSet instances."", ""ResultSet""); (""connection.commit()"", ""The connection.commit() method causes all ResultSet instances to be closed."", ""ResultSet""); (""connection.commit()"", ""The connection.commit() method is called on the connection."", ""connection"")"
The HOLD_CURSORS_OVER_COMMIT holdability means that the ResultSet is kept open when the connection.commit() method is called on the connection that created the ResultSet.,"(""HOLD_CURSORS_OVER_COMMIT"", ""HOLD_CURSORS_OVER_COMMIT is a holdability setting that affects the ResultSet."", ""ResultSet""); (""connection.commit()"", ""The connection.commit() method affects the state of the ResultSet by keeping it open."", ""ResultSet""); (""connection.commit()"", ""The connection.commit() method is called on the connection."", ""connection""); (""connection"", ""The connection is responsible for creating the ResultSet."", ""ResultSet"")"
"Thus, you can open a ResultSet, update rows in it, call connection.commit() and still keep the same ResultSet open for future transactions on the same rows.","(""ResultSet"", ""The method 'commit' is called to commit transactions that involve updates to the 'ResultSet'."", ""commit""); (""connection"", ""The 'commit' method is invoked on the 'connection' class to finalize transactions."", ""commit""); (""ResultSet"", ""The 'ResultSet' is associated with the 'connection' class for managing database transactions."", ""connection"")"
"The Java JDBC Statement, java.sql.Statement, interface is used to execute SQL statements against a relational database.","(""Java JDBC Statement"", ""The Java JDBC Statement is an interface represented by java.sql.Statement."", ""java.sql.Statement""); (""java.sql.Statement"", ""The java.sql.Statement interface is used to execute SQL statements."", ""execute""); (""execute"", ""The execute method is used to execute SQL statements."", ""SQL statements""); (""SQL statements"", ""SQL statements are executed against a relational database."", ""relational database"")"
"You do so by calling its executeQuery() method, passing an SQL statement as parameter.","(""executeQuery"", ""The executeQuery method is called with an SQL statement as a parameter, indicating a functional relationship between the method and the SQL statement."", ""SQL statement"")"
The Statement executeQuery() method returns a Java JDBC ResultSet which can be used to navigate the response of the query.,"(""Statement"", ""The executeQuery method is a function of the Statement class."", ""executeQuery""); (""executeQuery"", ""The executeQuery method returns a ResultSet."", ""ResultSet""); (""ResultSet"", ""ResultSet is a part of the Java JDBC package."", ""Java JDBC"")"
Here is an example of calling the Java JDBC Statement executeQuery() and navigating the returned ResultSet:,"(""Statement"", ""The method executeQuery is called on the Statement class."", ""executeQuery""); (""executeQuery"", ""The executeQuery method returns a ResultSet object."", ""ResultSet"")"
"The rowsAffected returned by the statement.executeUpdate(sql) call, tells how many records in the database were affected by the SQL statement.","(""STATEMENT"", ""The EXECUTEUPDATE method is called on the STATEMENT class."", ""EXECUTEUPDATE""); (""EXECUTEUPDATE"", ""The EXECUTEUPDATE method returns the ROWSAFFECTED class."", ""ROWSAFFECTED""); (""EXECUTEUPDATE"", ""The EXECUTEUPDATE method takes an SQL class as a parameter."", ""SQL"")"
The classic example of when transactions are necessary is the example of bank accounts.,"(""Transactions"", ""Transactions are often used to manage operations involving bank accounts, ensuring data integrity and consistency."", ""Bank Accounts"")"
"But, instead of calling the executeQuery() method, you call the executeUpdate() method.","(""ExecuteQuery"", ""Both are methods that can be called, likely within the same context or class."", ""ExecuteUpdate"")"
The executeUpdate() method is used for both of these types of updates.,"(""ExecuteUpdate"", ""The term 'executeUpdate()' is explicitly referred to as a method in the text."", ""Method"")"
"Again, the rowsAffected returned by the statement.executeUpdate(sql) call, tells how many records in the database were affected by the SQL statement.","(""statement"", ""The executeUpdate method is called on the statement class."", ""executeUpdate""); (""executeUpdate"", ""The executeUpdate method takes an SQL statement as an argument."", ""sql"")"
"Once you have installed the Java SDK, test that you have it working by opening a command prompt (textual interface to your computer, ala Unix Shell, Windows CMD etc.)","(""Java SDK"", ""The command prompt is used to test if the Java SDK is installed and working correctly."", ""command prompt"")"
"A Java abstract class is a class which cannot be instantiated, meaning you cannot create new instances of an abstract class.","(""abstract class"", ""An abstract class is a type of class in Java."", ""Java"")"
The purpose of an abstract class is to function as a base for subclasses.,"(""Abstract Class"", ""An abstract class serves as a base for subclasses, indicating a hierarchical relationship."", ""Subclass"")"
"This Java abstract class tutorial explains how abstract classes are created in Java, what rules apply to them.","(""Abstract Class"", ""The Abstract Class is a type of class in the Java programming language."", ""Java"")"
This tutorial gets into the purpose of abstract classes in Java in more detail towards the end of this text.,"(""Abstract Classes"", ""Abstract Classes are a type of class used within the Java package."", ""Java"")"
In Java you declare that a class is abstract by adding the abstract keyword to the class declaration.,"(""Class"", ""The term 'abstract' is used to describe a type of class in Java."", ""Abstract"")"
That is all there is to declaring an abstract class in Java.,"(""Abstract Class"", ""An abstract class is a type of class that can be declared in the Java programming language."", ""Java"")"
"If you try to compile the code above the Java compiler will generate an error, saying that you cannot instantiate MyAbstractClass because it is an abstract class.","(""Java compiler"", ""The Java compiler generates an error related to MyAbstractClass because it is an abstract class and cannot be instantiated."", ""MyAbstractClass"")"
"If a class has an abstract method, the whole class must be declared abstract.","(""Class"", ""An abstract method is a component of a class, and if a class contains an abstract method, the class itself must be declared abstract."", ""Abstract Method""); (""Class"", ""The statement refers to the requirement that if a class has an abstract method, the class must be declared abstract."", ""Class"")"
Not all methods in an abstract class have to be abstract methods.,"(""Abstract Class"", ""Methods can be part of an abstract class, as they define the behavior of the class."", ""Method""); (""Abstract Class"", ""Abstract methods are a specific type of method that can be defined within an abstract class."", ""Abstract Method"")"
An abstract class can have a mixture of abstract and non-abstract methods.,"(""Abstract Class"", ""An abstract class can contain abstract methods."", ""Abstract Methods""); (""Abstract Class"", ""An abstract class can also contain non-abstract methods."", ""Non-Abstract Methods"")"
Subclasses of an abstract class must implement (override) all abstract methods of its abstract superclass.,"(""Subclasses"", ""Subclasses are specific implementations of an abstract class."", ""Abstract Class""); (""Abstract Class"", ""An abstract class contains abstract methods that need to be implemented."", ""Abstract Methods""); (""Subclasses"", ""Subclasses must implement the abstract methods of their abstract superclass."", ""Abstract Methods""); (""Abstract Superclass"", ""The abstract superclass defines abstract methods that need to be overridden."", ""Abstract Methods"")"
The non-abstract methods of the superclass are just inherited as they are.,"(""METHOD"", ""The method is inherited from the superclass, indicating a relationship between them."", ""SUPERCLASS"")"
Notice how MySubClass has to implement the abstract method abstractMethod() from its abstract superclass MyAbstractClass.,"(""MySubClass"", ""MySubClass implements the abstract method abstractMethod()."", ""abstractMethod()""); (""MySubClass"", ""MySubClass is a subclass of the abstract superclass MyAbstractClass."", ""MyAbstractClass""); (""abstractMethod()"", ""abstractMethod() is a method from the abstract superclass MyAbstractClass."", ""MyAbstractClass"")"
"The only time a subclass of an abstract class is not forced to implement all abstract methods of its superclass, is if the subclass is also an abstract class.","(""SUBCLASS"", ""A subclass can be an abstract class itself."", ""ABSTRACT CLASS""); (""SUBCLASS"", ""A subclass inherits from a superclass."", ""SUPERCLASS""); (""ABSTRACT CLASS"", ""An abstract class can have abstract methods."", ""METHOD""); (""SUPERCLASS"", ""A superclass can define abstract methods that subclasses must implement."", ""METHOD"")"
The purpose of abstract classes is to function as base classes which can be extended by subclasses to create a full implementation.,"(""Abstract Classes"", ""Abstract classes serve as base classes that can be extended by subclasses to create a full implementation."", ""Subclasses"")"
"If the steps before and after the action are always the same, the 3-step process could be implemented in an abstract superclass with this Java code:",NULL
Subclasses of MyAbstractProcess can now extend MyAbstractProcess and just override the action() method.,"(""MyAbstractProcess"", ""The action method is intended to be overridden by subclasses of the MyAbstractProcess class."", ""action"")"
"When the process() method of the subclass is called, the full process is executed, including the stepBefore() and stepAfter() of the abstract superclass, and the action() method of the subclass.","(""PROCESS"", ""The process() method is a method of the subclass."", ""SUBCLASS""); (""STEPBEFORE"", ""The stepBefore() method is part of the abstract superclass."", ""SUPERCLASS""); (""STEPAFTER"", ""The stepAfter() method is part of the abstract superclass."", ""SUPERCLASS""); (""ACTION"", ""The action() method is a method of the subclass."", ""SUBCLASS""); (""PROCESS"", ""The process() method includes the execution of stepBefore()."", ""STEPBEFORE""); (""PROCESS"", ""The process() method includes the execution of stepAfter()."", ""STEPAFTER""); (""PROCESS"", ""The process() method includes the execution of action()."", ""ACTION"")"
"Of course, the MyAbstractProcess did not have to be an abstract class to function as a base class.","(""MyAbstractProcess"", ""MyAbstractProcess functions as a base class."", ""base class"")"
"However, by making the method to implement abstract, and thus the class too, you signal clearly to users of this class that this class should not be used as it is.","(""METHOD"", ""The method is part of the class, indicating that the class contains or uses the method."", ""CLASS"")"
"Instead it should be used as a base class for a subclass, and that the abstract method should be implemented in the subclass.","(""Base Class"", ""The base class is intended to be used as a foundation for creating a subclass."", ""Subclass""); (""Abstract Method"", ""The abstract method should be implemented in the subclass."", ""Subclass"")"
The above example did not have a default implementation for the action() method.,"(""ACTION"", ""The term 'action()' is identified as a method in the text."", ""METHOD"")"
In some cases your superclass might actually have a default implementation for the method that subclasses are supposed to override.,"(""superclass"", ""Subclasses are supposed to override methods from the superclass."", ""subclasses""); (""superclass"", ""The superclass might have a default implementation for the method."", ""method"")"
"You can still make the superclass abstract though, even if it contains no abstract methods.","(""SUPERCLASS"", ""The superclass can contain methods, which are part of its structure."", ""METHODS"")"
"Notice how the processURLData() is an abstract method, and that URLProcessorBase is an abstract class.","(""ProcessURLData"", ""ProcessURLData is a method that is likely part of the URLProcessorBase class, as it is mentioned in the context of the class."", ""URLProcessorBase"")"
Subclasses of URLProcessorBase have to implement the processURLData() method because it is an abstract method.,"(""URLProcessorBase"", ""The processURLData method must be implemented by subclasses of the URLProcessorBase class because it is an abstract method."", ""processURLData"")"
Subclasses of URLProcessorBase abstract class can process data downloaded from URLs without worrying about opening and closing the network connection to the URL.,"(""URLProcessorBase"", ""URLProcessorBase is designed to process data from URLs, indicating a functional relationship between the class and the URL."", ""URL"")"
Subclasses only need to worry about processing the data from the InputStream passed to the processURLData() method.,"(""processURLData"", ""The processURLData method processes data from the InputStream."", ""InputStream""); (""Subclasses"", ""Subclasses need to implement or use the processURLData method."", ""processURLData"")"
This makes it easier to implement classes that processes data from URLs.,"(""Classes"", ""Classes process data from URLs"", ""URLs"")"
"Notice how the subclass only implements the processURLData() method, and nothing more.","(""subclass"", ""The subclass implements the ProcessURLData method"", ""ProcessURLData"")"
The rest of the code is inherited from the URLProcessorBase superclass.,"(""URLProcessorBase"", ""The URLProcessorBase is mentioned as a superclass, indicating it is a class entity."", ""URLProcessorBase"")"
Here is an example of how to use the URLProcessorImpl class:,"(""URLProcessorImpl"", ""The text provides an example of how to use the URLProcessorImpl class, indicating its role as a class."", ""URLProcessorImpl"")"
"The process() method is called, which is implemented in the URLProcessorBase superclass.","(""Process"", ""The Process method is implemented in the URLProcessorBase class"", ""URLProcessorBase"")"
This method in turn calls the processURLData() in the URLProcessorImpl class.,"(""processURLData"", ""The method processURLData is called within the URLProcessorImpl class, indicating a functional relationship where the class likely contains or utilizes the method."", ""URLProcessorImpl"")"
The example I showed you above with the URLProcessorBase class is actually an example of the Template Method design pattern.,"(""URLProcessorBase"", ""The URLProcessorBase class is an example of the Template Method design pattern, indicating that it likely implements or uses this method."", ""Template Method"")"
"The Template Method design pattern provides a partial implementation of some process, which subclasses can complete when extending the Template Method base class.","(""Template Method"", ""Subclasses extend the Template Method base class to complete the partial implementation of a process."", ""subclasses"")"
"A Java access modifier specifies which classes can access a given class and its fields, constructors and methods.","(""Java"", ""Java is a programming language that uses access modifiers to control access to classes."", ""access modifier""); (""access modifier"", ""Access modifiers specify which classes can access fields."", ""fields""); (""access modifier"", ""Access modifiers specify which classes can access constructors."", ""constructors""); (""access modifier"", ""Access modifiers specify which classes can access methods."", ""methods"")"
"Access modifiers can be specified separately for a class, its constructors, fields and methods.","(""Class"", ""Constructors are components of a class that are used to initialize objects."", ""Constructors""); (""Class"", ""Fields are variables that belong to a class."", ""Fields""); (""Class"", ""Methods are functions that define the behavior of a class."", ""Methods"")"
"Assigning an access modifier to a class, constructor, field or method is also sometimes referred to as ""marking"" that class, constructor, field or method as that which the access modifier specifies.","(""CLASS"", ""The CLASS and METHOD are related because both can have an access modifier assigned to them."", ""METHOD""); (""CONSTRUCTOR"", ""The CONSTRUCTOR and FIELD are related because both can have an access modifier assigned to them."", ""FIELD""); (""CLASS"", ""The CLASS and CONSTRUCTOR are related because both can have an access modifier assigned to them."", ""CONSTRUCTOR""); (""CLASS"", ""The CLASS and FIELD are related because both can have an access modifier assigned to them."", ""FIELD""); (""METHOD"", ""The METHOD and CONSTRUCTOR are related because both can have an access modifier assigned to them."", ""CONSTRUCTOR""); (""METHOD"", ""The METHOD and FIELD are related because both can have an access modifier assigned to them."", ""FIELD""); (""CONSTRUCTOR"", ""The CONSTRUCTOR and CLASS are related because both can have an access modifier assigned to them."", ""CLASS""); (""FIELD"", ""The FIELD and CLASS are related because both can have an access modifier assigned to them."", ""CLASS""); (""FIELD"", ""The FIELD and METHOD are related because both can have an access modifier assigned to them."", ""METHOD""); (""FIELD"", ""The FIELD and CONSTRUCTOR are related because both can have an access modifier assigned to them."", ""CONSTRUCTOR"")"
"If a method or variable is marked as private (has the private access modifier assigned to it), then only code inside the same class can access the variable, or call the method.","(""METHOD"", ""A method can be called by code inside the same class."", ""CLASS""); (""VARIABLE"", ""A variable can be accessed by code inside the same class."", ""CLASS"")"
"Code inside subclasses cannot access the variable or method, nor can code from any external class.","(""subclasses"", ""Subclasses cannot access the method, indicating a relationship of access restriction."", ""method""); (""subclasses"", ""Subclasses are a type of class, indicating a hierarchical relationship."", ""class""); (""class"", ""Classes contain methods, indicating a composition relationship."", ""method"")"
"Marking a class with the private access modifier would mean that no other class could access it, which means that you could not really use the class at all.","(""Class"", ""The private access modifier is used to restrict access to the class."", ""Private Access Modifier"")"
"That means, that the member variable time inside the Clock class cannot be accessed from code outside the Clock class.","(""Clock"", ""The member variable 'time' is part of the 'Clock' class."", ""time"")"
"In some cases the fields are truly private, meaning they are only used internally in the class.","(""Class"", ""Fields are used internally within the class"", ""Fields"")"
In other cases the fields can be accessed via accessor methods (e.g.,"(""fields"", ""Fields can be accessed via accessor methods, indicating a relationship between them."", ""accessor methods"")"
In the above example the two methods getTime() and setTime() can access the time member variable.,"(""GETTIME"", ""Both methods are related as they can access the time member variable."", ""SETTIME""); (""SETTIME"", ""Both methods are related as they can access the time member variable."", ""GETTIME"")"
"If a constructor in a class is assigned the private Java access modifier, that means that the constructor cannot be called from anywhere outside the class.","(""Constructor"", ""A constructor is a method that is defined within a class."", ""Class"")"
"A private constructor can still get called from other constructors, or from static methods in the same class.","(""CONSTRUCTOR"", ""A constructor is a special method used to initialize objects of a class."", ""CLASS""); (""STATIC METHOD"", ""A static method belongs to the class and can be called on the class itself."", ""CLASS""); (""CONSTRUCTOR"", ""A constructor can be called from static methods within the same class."", ""STATIC METHOD"")"
This version of the Clock class contains a private constructor and a public constructor.,"(""Clock"", ""The Clock class contains a constructor, indicating a relationship between the class and its method."", ""constructor"")"
The private constructor is called from the public constructor (the statement this();).,"(""Public Constructor"", ""The public constructor calls the private constructor using the statement this();"", ""Private Constructor"")"
The private constructor is also called from the static method newClock().,"(""NewClock"", ""The method NewClock calls the Constructor."", ""Constructor"")"
The above example only serves to show you that a private constructor can be called from public constructors and from static methods inside the same class.,"(""constructor"", ""The constructor is a method that belongs to the class."", ""class""); (""methods"", ""The methods are part of the class."", ""class""); (""constructor"", ""The constructor can be called from methods."", ""methods"")"
"The default access modifier means that code inside the class itself as well as code inside classes in the same package as this class, can access the class, field, constructor or method which the default access modifier is assigned to.","(""CLASS"", ""A class can be accessed by other classes within the same package."", ""PACKAGE""); (""CLASS"", ""A method can be part of a class and is accessible based on the class's access modifier."", ""METHOD"")"
"Subclasses cannot access methods and member variables (fields) in the superclass, if they these methods and fields are marked with the default access modifier, unless the subclass is located in the same package as the superclass.","(""Subclasses"", ""Subclasses are related to the superclass as they inherit from it."", ""Superclass""); (""Methods"", ""Methods are part of the superclass as they define its behavior."", ""Superclass""); (""Member Variables"", ""Member variables are part of the superclass as they define its state."", ""Superclass""); (""Subclasses"", ""Subclasses can access superclass methods and fields if they are in the same package."", ""Package""); (""Superclass"", ""Superclass methods and fields with default access are accessible within the same package."", ""Package"")"
"The time field in the Clock class has no access modifier, which means that it is implicitly assigned the default / package access modifier.","(""Clock"", ""The time field is a component of the Clock class."", ""time""); (""time"", ""The time field is implicitly assigned the default / package access modifier."", ""package"")"
"Therefore, the ClockReader class can read the time member variable of the Clock object, provided that ClockReader and Clock are located in the same Java package.","(""ClockReader"", ""ClockReader can read the time member variable of the Clock object, indicating a relationship between these two classes."", ""Clock""); (""ClockReader"", ""ClockReader and Clock are located in the same Java package, indicating a relationship with the Java package."", ""Java""); (""Clock"", ""Clock and ClockReader are located in the same Java package, indicating a relationship with the Java package."", ""Java"")"
"The protected access modifier provides the same access as the default access modifier, with the addition that subclasses can access protected methods and member variables (fields) of the superclass.","(""Protected Access Modifier"", ""Subclasses can access protected methods and member variables of the superclass."", ""Subclass""); (""Protected Access Modifier"", ""Protected access allows access to methods and member variables of the superclass."", ""Superclass""); (""Subclass"", ""Subclasses can access protected methods and member variables of the superclass."", ""Superclass"")"
This is true even if the subclass is not located in the same package as the superclass.,"(""SUBCLASS"", ""A subclass is a type of class that inherits from a superclass."", ""SUPERCLASS""); (""SUBCLASS"", ""The subclass may be located in a different package than the superclass."", ""PACKAGE""); (""SUPERCLASS"", ""The superclass may be located in a different package than the subclass."", ""PACKAGE"")"
In the above example the subclass SmartClock has a method called getTimeInSeconds() which accesses the time variable of the superclass Clock.,"(""SmartClock"", ""The method getTimeInSeconds is a part of the SmartClock class."", ""getTimeInSeconds""); (""SmartClock"", ""SmartClock is a subclass of the Clock class."", ""Clock""); (""getTimeInSeconds"", ""The method getTimeInSeconds accesses the time variable of the Clock class."", ""Clock"")"
"The Java access modifier public means that all code can access the class, field, constructor or method, regardless of where the accessing code is located.","(""Public"", ""The public access modifier allows the field to be accessed by any code."", ""Field""); (""Public"", ""The public access modifier allows the constructor to be accessed by any code."", ""Constructor""); (""Public"", ""The public access modifier allows the method to be accessed by any code."", ""Method""); (""Java"", ""The public access modifier is a feature of the Java package."", ""Public"")"
The accessing code can be in a different class and different package.,"(""Class"", ""The text mentions that the accessing code can be in a different class and different package, indicating a relationship between classes and packages."", ""Package"")"
The time field in the Clock class is marked with the public Java access modifier.,"(""Clock"", ""The time field is a component or attribute within the Clock class."", ""time"")"
"Therefore, the ClockReader class can access the time field in the Clock no matter what package the ClockReader is located in.","(""ClockReader"", ""The ClockReader class can access the time field in the Clock class."", ""Clock""); (""ClockReader"", ""The ClockReader class can access the time field."", ""time""); (""Clock"", ""The time field is part of the Clock class."", ""time"")"
"It is important to keep in mind that the Java access modifier assigned to a Java class takes precedence over any access modifiers assigned to fields, constructors and methods of that class.","(""Java"", ""The fields are components or members of the Java class."", ""fields""); (""Java"", ""The constructors are components or members of the Java class."", ""constructors""); (""Java"", ""The methods are components or members of the Java class."", ""methods"")"
"If the class is marked with the default access modifier, then no other class outside the same Java package can access that class, including its constructors, fields and methods.","(""Class"", ""A class with default access modifier cannot be accessed by any class outside the same Java package."", ""Java Package""); (""Class"", ""Constructors are part of the class and are affected by the class's access level."", ""Constructors""); (""Class"", ""Fields are part of the class and are affected by the class's access level."", ""Fields""); (""Class"", ""Methods are part of the class and are affected by the class's access level."", ""Methods"")"
The Java access modifiers private and protected cannot be assigned to a class.,"(""Java"", ""The Java package is related to the class as it defines access modifiers for it."", ""class""); (""private"", ""The private access modifier is related to the class as it restricts access to it."", ""class""); (""protected"", ""The protected access modifier is related to the class as it restricts access to it."", ""class"")"
Java interfaces are meant to specify fields and methods that are publicly available in classes that implement the interfaces.,"(""interfaces"", ""Interfaces are implemented by classes."", ""classes""); (""interfaces"", ""Interfaces specify fields."", ""fields""); (""interfaces"", ""Interfaces specify methods."", ""methods""); (""classes"", ""Classes implement the fields specified by interfaces."", ""fields""); (""classes"", ""Classes implement the methods specified by interfaces."", ""methods"")"
"When you create a subclass of some class, the methods in the subclass cannot have less accessible access modifiers assigned to them than they had in the superclass.","(""Subclass"", ""A subclass is derived from a superclass, indicating an inheritance relationship."", ""Superclass""); (""Methods"", ""Methods are part of a subclass, indicating they belong to or are defined within the subclass."", ""Subclass""); (""Methods"", ""Methods are part of a superclass, indicating they belong to or are defined within the superclass."", ""Superclass"")"
"For instance, if a method in the superclass is public then it must be public in the subclass too, in case the subclass overrides the method.","(""Superclass"", ""The Subclass can override methods from the Superclass, indicating a hierarchical relationship."", ""Subclass""); (""Method"", ""The Method is part of the Superclass, as it can be overridden by the Subclass."", ""Superclass""); (""Method"", ""The Method can be overridden in the Subclass, indicating it is related to the Subclass."", ""Subclass"")"
If a method in the superclass is protected then it must be either protected or public in the subclass.,"(""Superclass"", ""A subclass is a derived class from a superclass."", ""Subclass""); (""Method"", ""A method can belong to a superclass."", ""Superclass""); (""Method"", ""A method can belong to a subclass."", ""Subclass"")"
"For instance, if a method is assigned the default access modifier in the superclass, then it is allowed to assign the overridden method in the subclass the public access modifier.","(""METHOD"", ""The METHOD is assigned a default access modifier in the SUPERCLASS."", ""SUPERCLASS""); (""METHOD"", ""The overridden METHOD in the SUBCLASS can be assigned a public access modifier."", ""SUBCLASS"")"
"The build process includes generating source code, compiling the source, generating XML files (e.g.",NULL
"You can place Java annotations above classes, interfaces, methods, method parameters, fields and local variables.","(""annotations"", ""Annotations can be placed above classes."", ""classes""); (""annotations"", ""Annotations can be placed above interfaces."", ""interfaces""); (""annotations"", ""Annotations can be placed above methods."", ""methods""); (""annotations"", ""Annotations can be placed above method parameters."", ""method parameters""); (""annotations"", ""Annotations can be placed above fields."", ""fields""); (""annotations"", ""Annotations can be placed above local variables."", ""local variables"")"
"Here is a bigger example with annotations above both the class, fields, methods, parameters and local variables:","(""CLASS"", ""FIELDS are components or attributes of a CLASS"", ""FIELDS""); (""CLASS"", ""METHODS are functions or procedures that belong to a CLASS"", ""METHODS""); (""CLASS"", ""PARAMETERS are inputs to METHODS within a CLASS"", ""PARAMETERS""); (""CLASS"", ""LOCAL VARIABLES are variables defined within METHODS of a CLASS"", ""LOCAL VARIABLES"")"
"If your code uses deprecated classes, methods or fields, the compiler will give you a warning.","(""CLASS"", ""The CLASS and METHOD are related as they are both elements that can be deprecated in code."", ""METHOD"")"
"If the method does not match a method in the superclass, the compiler will give you an error.","(""Method"", ""The method is being compared to methods in the superclass to check for a match."", ""Superclass"")"
"In case someone changed the name of the overridden method in the superclass, your subclass method would no longer override it.","(""OVERRIDDEN METHOD"", ""The overridden method is part of the superclass."", ""SUPERCLASS""); (""OVERRIDDEN METHOD"", ""The overridden method is intended to be overridden by the subclass."", ""SUBCLASS""); (""SUPERCLASS"", ""The subclass inherits from the superclass."", ""SUBCLASS"")"
"In case the method doTheThing() in MySuperClass changes signature so that the same method in the subclass no longer overrides it, the compiler will generate an error.","(""DOTHETHING"", ""The method DOTHETHING is part of the class MYSUPERCLASS."", ""MYSUPERCLASS"")"
"Annotations are defined in their own file, just like a Java class or interface.","(""Annotations"", ""Annotations are compared to a Java class or interface, indicating a conceptual similarity."", ""Java"")"
"RetentionPolicy.CLASS means that the annotation is stored in the .class file, but not available at runtime.","(""RetentionPolicy"", ""CLASS is a specific type of RetentionPolicy."", ""CLASS""); (""CLASS"", ""CLASS is stored in the .class file."", "".class file"")"
"RetentionPolicy.SOURCE means that the annotation is only available in the source code, and not in the .class files and not a runtime.","(""RetentionPolicy"", ""SOURCE is a specific type of RetentionPolicy"", ""SOURCE""); (""annotation"", ""The annotation is not available in the .class files"", "".class files"")"
"The second line declares an array of references to objects of the class MyClass, which symbolizes a class you have created yourself.","(""MyClass"", ""The text mentions that MyClass is a class created by the user, indicating a self-referential relationship."", ""MyClass"")"
Personally I prefer to locate the square brackets [] after the data type (e.g.,NULL
Java allows you to create an array of references to any type of object (to instances of any class).,"(""Array"", ""An array can hold references to instances of any class, including Object."", ""Object"")"
Notice how the values to be inserted into the array are listed inside the { ... } block.,NULL
"Of course, if the insertIntoArray() method is located in a different class than the above code, you would need an object of that class in order to be able to call the method.","(""InsertIntoArray"", ""The method InsertIntoArray is located in a class, indicating a relationship between the method and the class."", ""Class"")"
"Or, if the insertIntoArray() method was static, you would need to put the class name and a dot in front of the method name.","(""insertIntoArray"", ""The insertIntoArray method is associated with the class, as it is mentioned that the class name should precede the method name if it is static."", ""class"")"
"This removeFromArray() method takes two parameters: The array to remove the element from, and the index of the element to remove.","(""removeFromArray"", ""The method removeFromArray takes an array as a parameter to remove an element from it."", ""array""); (""removeFromArray"", ""The method removeFromArray uses the index parameter to identify which element to remove from the array."", ""index"")"
"Of course, if the removeFromArray() method is located in a different class than the above code, you would need an object of that class in order to be able to call the method.","(""removeFromArray"", ""The method removeFromArray is associated with a class, as it is mentioned that it could be located in a different class."", ""class"")"
"Or, if the removeFromArray() method was static, you would need to put the class name and a dot in front of the method name.","(""removeFromArray"", ""The removeFromArray method is associated with the class, as it is mentioned that the method would require the class name if it were static."", ""class"")"
The example first sets the minVal to Integer.MAX_VALUE which is the highest possible value an int can take.,"(""Integer"", ""MAX_VALUE is a field of the Integer class"", ""MAX_VALUE"")"
"Java contains a special utility class that makes it easier for you to perform many often used array operations like copying and sorting arrays, filling in data, searching in arrays etc.","(""Java"", ""The Utility class is part of the Java package, which provides various functionalities for array operations."", ""Utility"")"
The utility class is called Arrays and is located in the standard Java package java.util.,"(""Arrays"", ""The class Arrays is located in the package java.util."", ""java.util"")"
I will cover a few of the methods found in this class in the following sections.,"(""METHODS"", ""METHODS are typically functions or procedures that belong to a CLASS."", ""CLASS"")"
"Remember, in order to use java.util.Arrays in your Java classes you must import it.","(""Java"", ""Java class needs to import the java.util.Arrays package to use its functionalities."", ""java.util.Arrays"")"
Here is how importing java.util.Arrays could look in a Java class of your own:,"(""Java"", ""The Java class is importing the java.util.Arrays package."", ""java.util.Arrays"")"
It is this statement that imports the class java.util.Arrays into your Java class.,"(""Java.Util.Arrays"", ""Java.Util.Arrays is a class that is being imported into the Java class."", ""Java"")"
The second method to copy a Java array is to use the Arrays.copyOf() method.,"(""Arrays.copyOf()"", ""The text explicitly mentions that Arrays.copyOf() is a method used to copy a Java array."", ""method"")"
The third method to copy a Java array is to use the Arrays.copyOfRange() method.,"(""Arrays.copyOfRange()"", ""The Arrays.copyOfRange() method is used to copy a Java array."", ""Java array"")"
"The Arrays.copyOfRange() method copies a range of an array, not necessarily the full array.","(""Arrays"", ""The method copyOfRange is a function of the Arrays class."", ""copyOfRange"")"
Here is how copying a full array using Arrays.copyOfRange() in Java looks:,"(""Arrays.copyOfRange()"", ""The method Arrays.copyOfRange() is used within the Java package."", ""Java"")"
You can convert an Java array of primitive types to a String using the Arrays.toString() method.,"(""Arrays"", ""The toString method is a member of the Arrays class."", ""toString"")"
Here is an example of how to convert an array of int to a String using Arrays.toString():,"(""Arrays"", ""The method toString is a member of the class Arrays, used to convert an array of int to a String."", ""toString"")"
You can sort the elements of an array using the Arrays.sort() method.,"(""Arrays"", ""The sort method is a function provided by the Arrays class to sort elements."", ""sort"")"
After the for loop the array is converted to a String using Arrays.toString() and printed out to the console (command line).,NULL
The Arrays.sort() example shown earlier only works for Java arrays of primitive data types.,"(""Arrays"", ""The method 'sort' is a function of the class 'Arrays'."", ""sort""); (""sort"", ""The method 'sort' is used in the context of Java programming."", ""Java"")"
Here is first the class for the objects we want to sort:,"(""Class"", ""class"")"
The class Employee is a simple model of an employee (I have created the Employee class).,"(""Employee"", ""The text mentions the creation of the Employee class, indicating a relationship between the concept of an employee and the Employee class."", ""Employee"")"
Here is first an example of sorting an array of Employee objects by their name using the Arrays.sort() method:,"(""Arrays.sort()"", ""The Arrays.sort() method is used to sort an array of Employee objects."", ""Employee"")"
The array is of type Employee - the class I showed you earlier.,"(""Employee"", ""Employee is described as a class in the text."", ""class"")"
"As parameter to the Arrays.sort() method we pass the employee array, and a Comparator implementation which can determine the order of Employee objects.","(""Arrays.sort()"", ""The Comparator class is used as a parameter in the Arrays.sort() method to determine the order of sorting."", ""Comparator""); (""Arrays.sort()"", ""The Employee class is the type of objects being sorted by the Arrays.sort() method."", ""Employee"")"
Anonymous implementations of interfaces are covered in my text about nested classes in Java.,"(""Anonymous Implementations"", ""Anonymous implementations are a type of class that implements interfaces."", ""Interfaces""); (""Nested Classes"", ""Nested classes are a feature in the Java programming language."", ""Java"")"
What is important to catch in this example is the implementation of the compare() method of the anonymous inner implementation of the Comparator interface.,"(""COMPARE"", ""The COMPARE method is an implementation detail of the COMPARATOR class."", ""COMPARATOR"")"
In the example above we simply call the String.compare() method which does the comparison for us (compares the employee names).,"(""String"", ""The compare method is a function of the String class."", ""compare"")"
"Here is the example from before, with a modified implementation of the compare() method of the anonymous implementation of the Comparator interface:","(""COMPARE"", ""The COMPARE method is part of the COMPARATOR class as it is an implementation of the interface."", ""COMPARATOR"")"
Notice how the compare() method returns the difference between the employee ids by subtracting one from the other.,"(""COMPARE"", ""The compare() method operates on employee ids by calculating the difference between them."", ""EMPLOYEE IDS"")"
"To compare the Employee objects in the array first by their name, and if that is the same, then by their employee id, the compare() implementation would look like this:","(""Employee"", ""The compare method is used to compare Employee objects."", ""compare"")"
These Arrays.fill() methods can fill an array with a given value.,"(""Arrays"", ""The method 'fill' is a part of the 'Arrays' class, as indicated by the notation 'Arrays.fill()'."", ""fill"")"
Here is an example of using Arrays.fill() to fill an int array:,"(""Arrays"", ""The method 'fill' is used in conjunction with the class 'Arrays' to perform an operation on an array."", ""fill"")"
"There is a version of the Arrays.fill() method which takes a from and to index, so only elements with indexes in this interval are filled with the given value.","(""Arrays"", ""The fill method is a member of the Arrays class."", ""fill"")"
"You can do so yourself, or via the Arrays.sort() method covered earlier in this text.","(""Arrays"", ""The sort method is a method of the Arrays class."", ""sort"")"
The binarySearch() method will return the index in the array in which the element was found.,"(""BinarySearch"", ""The BinarySearch method operates on an array to find the index of an element."", ""Array"")"
"If all elements in the array are smaller than the sought value, then binarySearch() will return - length of the array - 1.","(""BINARYSEARCH"", ""The method binarySearch() operates on the array to perform a search operation."", ""ARRAY""); (""BINARYSEARCH"", ""The method binarySearch() returns a value related to the length of the array when the sought value is not found."", ""LENGTH"")"
Therefore binarySearch() will return -length (-6) - 1 = -6 -1 = -7.,"(""binarySearch"", ""The term 'binarySearch()' refers to a method in the context of the text."", ""method"")"
The Arrays.binarySearch() method also exists in a version where you just search part of the array.,"(""Arrays"", ""The method binarySearch is a part of the Arrays class."", ""binarySearch"")"
"This version of binarySearch() works just like the other version, except in the cases where no matching element is found.","(""binarySearch"", ""The text refers to binarySearch() as a method, indicating its functionality and behavior."", ""method"")"
"If no element is found matching within the index interval, then binarySearch() will still return the index of where the value should have been inserted.","(""binarySearch()"", ""The method binarySearch() is related to the index as it returns the index of where the value should have been inserted."", ""index"")"
"But, if all values in the interval are smaller than the sought value, binarySearch() will return -toIndex -1 , and not -array length - 1.","(""binarySearch"", ""The method binarySearch() returns -toIndex -1 if all values in the interval are smaller than the sought value."", ""toIndex""); (""binarySearch"", ""The method binarySearch() returns -array length - 1 if all values in the interval are smaller than the sought value."", ""array length"")"
The java.util.Arrays class contains a set of methods called equals() which can be used to check if two Java arrays are equal.,"(""Java.util.Arrays"", ""The Equals() method is part of the Java.util.Arrays class, used to check if two Java arrays are equal."", ""Equals()"")"
"Java classes are some of the core building blocks of Java applications, toolkits, frameworks, APIs etc.","(""Java"", ""Java is described as a class, which is a core building block of Java applications."", ""class"")"
"A small Java application may consist of a single Java class with a main() method in, as covered in the Java main method tutorial.","(""Java"", ""The main() method is typically part of a Java class."", ""main()""); (""main()"", ""The Java main method tutorial covers the main() method."", ""Java main method tutorial"")"
"As your Java application grows, keeping all the code in the same class makes it harder and harder to keep an overview of the code.","(""Java"", ""class"")"
Therefore it might be beneficial to start splitting the Java code up into multiple classes.,"(""Java"", ""The Java package is being split into multiple classes, indicating a structural relationship between the package and the classes."", ""classes"")"
"A Java class is a single, coherent unit of Java code which belongs together.","(""Java Class"", ""A Java class is a unit of Java code, indicating that the class is part of the code package."", ""Java Code"")"
A Java class may contain a mix of data (variables) and actions (methods).,"(""Java"", ""Java class contains data in the form of variables."", ""variables""); (""Java"", ""Java class contains actions in the form of methods."", ""methods"")"
Grouping variables and operations on these variables into Java classes makes it easier to structure your Java program when it gets too big to fit comfortably inside a single Java class.,"(""Java Class"", ""Java classes are used to structure a Java program by grouping variables and operations."", ""Java Program"")"
"Therefore, as the class grows, the file you are editing grows too, and becomes harder to keep an overview of in your head.","(""Class"", ""The class is related to the file as the file grows when the class grows."", ""File"")"
"Your Java application will typically have to contain at least a single Java class, but it may contain as many classes as you see fit to divide your application into.","(""Java"", ""The text refers to a Java application containing at least one Java class, indicating a relationship between the Java language and the Java class."", ""Java"")"
"Java also comes with a lot of predefined classes for you, so you don't have to code every little function you might desire yourself.","(""Java"", ""Java provides predefined classes for developers to use."", ""Class"")"
"Fields are variables (data) that are local to the class, or instances (objects) of that class.","(""Fields"", ""Fields are variables that are local to the class."", ""Class"")"
Methods are operations that the class or instances of that class can perform.,"(""METHODS"", ""Methods are operations that the class or instances of that class can perform."", ""CLASS"")"
Nested classes are Java classes that are defined inside another class.,"(""Nested Classes"", ""Nested classes are a type of Java classes that are defined inside another class."", ""Java Classes"")"
"Nested classes are typically intended to either be used only internally be the Java class that contains them, or to be used in connection with the class that contains them.","(""Nested Classes"", ""Nested classes are intended to be used internally by the Java class that contains them."", ""Java Class""); (""Nested Classes"", ""Nested classes are intended to be used in connection with the Java class that contains them."", ""Java Class"")"
Nested classes are covered in more detail in my Java nested class tutorial.,"(""Nested Classes"", ""Nested Classes are a feature within the Java programming language."", ""Java"")"
"Sometimes you have classes that only contain fields (data), and sometimes you have classes that only contain methods (operations).","(""Classes"", ""Classes can contain fields, which are data elements."", ""Fields""); (""Classes"", ""Classes can contain methods, which are operations."", ""Methods"")"
It depends on what the Java class is supposed to do.,"(""Java"", ""class"")"
All it takes to define a class in Java is this:,"(""Class"", ""class"")"
The above class definition should be put in its own file named MyClass.java.,"(""MyClass"", ""class"")"
"Java files should be named the same as the name of the class they contain, with the .java as file name extension.","(""Java"", ""Java files are named after the class they contain, indicating a relationship between the Java package and the class."", ""class"")"
Make sure you keep the same uppercase and lowercase characters from the class name in the file name too.,"(""Class"", ""class"")"
"Only put a single class definition in each Java file, unless your class contains inner classes of some kind.","(""Class"", ""Inner Classes are contained within a Class"", ""Inner Classes"")"
"As mentioned earlier, a Java class can contain data in the shape of variables.","(""Java"", ""A Java class can contain data in the shape of variables."", ""variables"")"
The next example shows a Java class which is to model a car.,"(""Java"", ""The Java class is used to model a car."", ""Car"")"
A constructor is a special method that is called when an object of the given class is created (explained later).,"(""Constructor"", ""A constructor is a special method that is called when an object of the given class is created."", ""Object"")"
The purpose of a constructor is to initialize the fields in the class.,"(""Constructor"", ""A constructor is used to initialize the fields in a class."", ""Fields"")"
Here is an example of a Java class with two constructors:,"(""Java"", ""class"")"
"The constructors are the two methods that have the same name as the class, and which have no return type specified.","(""CONSTRUCTORS"", ""CONSTRUCTORS are methods that have the same name as the CLASS."", ""CLASS"")"
"A Java method contains Java instructions that typically perform some operations on a field in the class, or on one of the parameters (also variables) values passed to the method when the method was called.","(""Java Method"", ""A Java method performs operations on a field in the class."", ""Field""); (""Java Method"", ""A Java method is called and receives parameters."", ""Java Method"")"
"Here is the Java class, Car example from the previous section with a method added:","(""Car"", ""The method is part of the Car class, indicating a relationship where the method is a function or operation within the Car class."", ""method"")"
In the class definition above I have added a setColor() method.,"(""Class"", ""The method setColor() is defined within the class."", ""SetColor"")"
"As mentioned earlier, you can define a nested class inside another Java class.","(""Nested Class"", ""A nested class is defined inside another Java class, indicating a hierarchical relationship."", ""Java Class"")"
Here is an example of defining a nested class inside a Java class:,"(""Java"", ""Java is a programming language that supports the concept of classes."", ""class"")"
"In the example above, the outer class is called MyClass and the nested class is called MyNestedClass .","(""MyClass"", ""MyNestedClass is a nested class within MyClass"", ""MyNestedClass"")"
"Neither of the classes in this example has any fields or methods, but both the outer and nested class could have as many fields and methods as you see fit.","(""Classes"", ""Classes can contain methods as part of their structure."", ""Methods"")"
You can read more about nested classes in my tutorial about nested classes in Java,"(""Nested Classes"", ""Nested Classes are a feature in the Java programming language."", ""Java"")"
A Java class is a template for how objects of that class looks.,"(""Java"", ""Java is a template for how objects of that class look."", ""objects"")"
"In other words, the Car class in the previous section is a template for how Car objects look.","(""Car"", ""The Car class is a template for Car objects, indicating a relationship between the class and the objects it defines."", ""Car"")"
"To create objects of a certain class, you use the new keyword.","(""Class"", ""The 'new keyword' is used to create objects of the 'Class'."", ""new keyword"")"
"This example creates 3 Car variables, and assign a new instance of the Car class to each variable.","(""Car"", ""The text mentions creating variables of the Car class, indicating a relationship between the class and its instances."", ""Car"")"
"Thus, the fields of different objects (even of the same class) can vary independently of each other.","(""Class"", ""The fields are attributes or properties that belong to a class, and they can vary independently in different objects of the same class."", ""Fields"")"
"After creating the 3 Car objects, the setColor() method is called on each object.","(""Car"", ""The setColor() method is called on each Car object, indicating that it is a method belonging to or acting upon the Car class."", ""setColor"")"
"Creating an object of a certain class is also called ""instantiating"" an object.","(""Object"", ""An object is an instance of a class, which is why creating an object is referred to as instantiating a class."", ""Class"")"
"The object is thus also called an ""instance"" of the given class.","(""Object"", ""The object is referred to as an instance of the given class, indicating a relationship between the object and the class."", ""Class"")"
"For instance, each of the Car objects above are also called an instance of the Car class, or simply ""Car instances"".","(""Car"", ""Car objects are instances of the Car class"", ""Car objects""); (""Car"", ""Car instances are another term for instances of the Car class"", ""Car instances"")"
What you have seen in this text only covers the very basics of Java classes.,"(""Java"", ""Java is a programming language that uses classes as a fundamental component."", ""classes"")"
"You need to learn about fields, constructors, methods nested classes, abstract classes, inheritance, access modifiers and interfaces too.","(""CONSTRUCTORS"", ""Constructors are a type of method used to initialize objects."", ""METHODS""); (""NESTED CLASSES"", ""Nested classes can be abstract, meaning they cannot be instantiated directly."", ""ABSTRACT CLASSES""); (""INHERITANCE"", ""Inheritance is a key concept in using abstract classes, allowing subclasses to implement abstract methods."", ""ABSTRACT CLASSES""); (""ACCESS MODIFIERS"", ""Access modifiers control the visibility of methods."", ""METHODS""); (""INTERFACES"", ""Interfaces define methods that must be implemented by a class."", ""METHODS"")"
"Here is a simple example that creates an object, which results in the class constructor being called:","(""CLASS"", ""The constructor is a method that is called when an object of the class is created."", ""CONSTRUCTOR"")"
The example shows a very simple Java class with a single constructor.,"(""Java"", ""The constructor is a method within the Java class."", ""constructor"")"
The second part of a Java constructor declaration is the name of the class the constructor belongs to.,"(""constructor"", ""A constructor is a special method that is used to initialize objects of a class."", ""class"")"
Using the class name for the constructor signals to the Java compiler that this is a constructor.,"(""Class Name"", ""The class name is used to signal the constructor in Java."", ""Constructor""); (""Constructor"", ""The constructor is recognized by the Java compiler."", ""Java Compiler"")"
The constructor parameters are declared inside the parentheses () after the class name part of the constructor .,"(""Constructor"", ""The constructor is associated with the class as it is defined after the class name."", ""Class"")"
"A class can have multiple constructors, as long as their signature (the parameters they take) are not the same.","(""Class"", ""A class can have multiple constructors, indicating a relationship where constructors are methods within a class."", ""Constructor"")"
"When a Java class contains multiple constructors, we say that the constructor is overloaded (comes in multiple versions).","(""Java"", ""A Java class can contain multiple constructors, indicating a relationship between the class and its constructors."", ""constructor"")"
"This is what constructor overloading means, that a Java class contains multiple constructors.","(""Java Class"", ""A Java class can contain multiple constructors, indicating a relationship between the class and its constructors."", ""Constructor"")"
The keyword this in front of the field name (this.number) is not necessary.,"(""this"", ""The keyword 'this' is used in front of the field name 'number'."", ""number"")"
"You don't have to define a constructor for a class, but if you don't define any constructor, the Java compiler will insert a default, no-argument constructor for you.","(""Constructor"", ""A constructor is a method that is used to initialize an object of a class."", ""Class""); (""Java Compiler"", ""The Java compiler inserts a default constructor if none is defined."", ""Constructor"")"
"Thus, once the class is compiled it will always at least have a no-argument constructor.","(""CLASS"", ""A class typically includes a constructor, which is a method used to initialize objects of the class."", ""CONSTRUCTOR"")"
"If you do define a constructor for your class, then the Java compiler will not insert the default no-argument constructor into your class.","(""Constructor"", ""A constructor is defined within a class."", ""Class""); (""Java Compiler"", ""The Java compiler interacts with the class to insert the default no-argument constructor."", ""Class"")"
The parameters are passed to the constructor inside the parentheses after the class name on the right side of the equal sign.,"(""Constructor"", ""The constructor is a method that is associated with the class, as it is used to initialize objects of the class."", ""Class"")"
"By default, if a parameter (or local variable) has the same name as a field in the same class, the parameter (or local variable) ""shadows"" for the field.","(""Parameter"", ""A parameter can have the same name as a field, causing it to shadow the field."", ""Field""); (""Local Variable"", ""A local variable can have the same name as a field, causing it to shadow the field."", ""Field""); (""Parameter"", ""A parameter is associated with a class when it has the same name as a field in that class."", ""Class""); (""Local Variable"", ""A local variable is associated with a class when it has the same name as a field in that class."", ""Class"")"
"Inside the constructor of the Employee class the firstName, lastName and birthYear identifiers now refer to the constructor parameters, not to the Employee fields with the same names.","(""Employee"", ""The constructor is a method within the Employee class."", ""constructor"")"
"To signal to the Java compiler that you mean the fields of the Employee class and not the parameters, put the this keyword and a dot in front of the field name.","(""Employee"", ""The Employee class is being referenced in the context of the Java compiler, indicating a relationship where the Java compiler processes or interacts with the Employee class."", ""Java compiler"")"
You call a constructor when you create a new instance of the class containing the constructor.,"(""Constructor"", ""A constructor is a method that is called to create a new instance of the class containing it."", ""Class"")"
"In case you want to pass parameters to the constructor, you include the parameters between the parentheses after the class name, like this:","(""class"", ""The constructor is a method that is associated with a class and is used to initialize objects of that class."", ""constructor"")"
The this keyword followed by parentheses and parameters means that another constructor in the same Java class is being called.,"(""this"", ""The 'this' keyword is used to call another constructor within the same Java class."", ""Java"")"
In this example it is the first constructor in the class that is being called.,"(""Class"", ""The constructor is a part of the class and is being called within it."", ""Constructor"")"
"When a class extends another class it is also said to ""inherit"" from the class it extends.","(""Class"", ""A class can extend another class, indicating an inheritance relationship."", ""Class"")"
"The class that extends is called the subclass, and the class being extended is called the superclass.","(""Subclass"", ""A subclass is related to a superclass because it extends the superclass."", ""Superclass"")"
A class that extends another class does not inherit its constructors.,"(""Class"", ""A class can extend another class, indicating a relationship between the two."", ""Class"")"
"However, the subclass must call a constructor in the superclass inside of its the subclass constructors!","(""Subclass"", ""The subclass is related to the superclass because it must call a constructor in the superclass."", ""Superclass""); (""Subclass"", ""The subclass must call a constructor, indicating a relationship between the subclass and the constructor."", ""Constructor"")"
"If a subclass calls another constructor within itself, then the called constructor must call the superclass constructor.","(""Subclass"", ""A subclass can call a constructor within itself."", ""Constructor""); (""Constructor"", ""A constructor must call the superclass constructor."", ""Superclass"")"
It calls the constructor in the superclass using this Java statement:,"(""Constructor"", ""The constructor is called in the superclass, indicating a relationship between the method and the class."", ""Superclass""); (""Java"", ""The constructor is invoked using a Java statement, showing a relationship between the package and the method."", ""Constructor"")"
Using the keyword super refers to the superclass of the class using the super keyword.,"(""Super"", ""The keyword 'super' is used to refer to the superclass of a class."", ""Superclass"")"
"When super keyword is followed by parentheses like it is here, it refers to a constructor in the superclass.","(""super"", ""The 'super' keyword is used to refer to a constructor."", ""constructor""); (""constructor"", ""The constructor is part of the superclass."", ""superclass"")"
In this case it refers to the constructor in the Vehicle class.,"(""constructor"", ""The constructor is a method that is part of the Vehicle class."", ""Vehicle"")"
The access modifier of a constructor determines what classes in your application that are allowed to call that constructor.,"(""constructor"", ""The constructor's access modifier determines which classes can call it, indicating a relationship between the constructor and the classes."", ""classes"")"
"For instance, if a constructor is declared protected then only classes in the same package, or subclasses of that class can call that constructor.","(""CONSTRUCTOR"", ""A constructor is a method that is associated with a class."", ""CLASS""); (""CLASS"", ""Classes can belong to a package."", ""PACKAGE""); (""CONSTRUCTOR"", ""A constructor can be called by classes within the same package."", ""PACKAGE"")"
"A class can have multiple constructors, and each constructor can have its own access modifier.","(""Class"", ""A class can have multiple constructors, indicating a relationship where constructors are part of a class."", ""Constructor""); (""Constructor"", ""Each constructor can have its own access modifier, showing a relationship where access modifiers are attributes of constructors."", ""Access Modifier"")"
"Thus, some constructors may be available to all classes in your application, while other constructors are only available to classes in the same package, subclasses, or even only to the class itself (private constructors).","(""CONSTRUCTORS"", ""Constructors are methods that can be available to classes in an application."", ""CLASSES""); (""CONSTRUCTORS"", ""Constructors can be available to classes within the same package."", ""PACKAGE""); (""CONSTRUCTORS"", ""Some constructors may be private, meaning they are only available to the constructor itself."", ""CONSTRUCTORS"")"
Here is an example of a Java class with a constructor that can throw an exception:,"(""constructor"", ""The constructor can throw an exception, indicating a direct relationship between the two."", ""exception"")"
Making a constructor throw an exception can be a good idea if you want to prevent an object of the given class to be created in an invalid state.,"(""Constructor"", ""A constructor can throw an exception to handle errors during object creation."", ""Exception""); (""Constructor"", ""A constructor is used to create an object."", ""Object""); (""Object"", ""An object is an instance of a class."", ""Class"")"
"A class can have fields, constructors and methods (plus more, but that is not important now).","(""Class"", ""A class can contain methods as part of its structure."", ""Method"")"
"When you create an object, that object is of a certain class.","(""Create"", ""The method 'Create' is used to instantiate or create an 'Object'."", ""Object"")"
The class is like a template (or blueprint) telling how objects of that class should look.,"(""Class"", ""The text describes how a class serves as a template for objects, indicating a self-referential relationship."", ""Class"")"
"When you create an object, you say ""give me an object of this class"".","(""Object"", ""An object is an instance of a class, indicating that objects are created based on the blueprint provided by the class."", ""Class"")"
"If you think of a factory producing lots and lots of the same items, then the class would be the blueprint / manual of how the finished product should look, and the objects would be each of the finished products.","(""Class"", ""class"")"
"If the factory produced cars, then the blueprint / design manual of the cars to produce corresponds to a Java class, and the physical cars produced corresponds to Java objects.","(""Class"", ""The Java class serves as a blueprint for creating Java objects, similar to how a design manual is used to produce physical cars."", ""Java objects"")"
Here is a simple diagram illustrating the principle of objects being of a certain class.,"(""Class"", ""class"")"
The class determines what fields and methods the objects of that class have.,"(""Class"", ""Fields are attributes or properties defined within a class."", ""Fields""); (""Class"", ""Methods are functions or procedures defined within a class."", ""Methods"")"
"The Car class does not contain any fields, constructors or methods.","(""Car"", ""The Car class is mentioned in relation to methods, indicating that methods are typically associated with classes."", ""methods""); (""Car"", ""The Car class is mentioned in relation to constructors, indicating that constructors are typically associated with classes."", ""constructors""); (""Car"", ""The Car class is mentioned in relation to fields, indicating that fields are typically associated with classes."", ""fields"")"
The example primarily serves to show you an example of how a class declaration looks in Java code.,"(""Class"", ""class"")"
A field is a variable that belongs to a class or an object.,"(""Class"", ""class"")"
"For instance, a Car class could define the field brand which all Car objects would have.","(""Car"", ""The Car class defines the field brand, indicating a relationship where brand is a property or attribute of Car."", ""brand"")"
Here is the Car class declaration from above with a field name brand added:,"(""Car"", ""The 'brand' is a field added to the 'Car' class."", ""brand"")"
Constructors are a special kind of method that is executed when an object of that class is created.,"(""Constructors"", ""Constructors are methods that are executed when an object of a class is created."", ""object"")"
Here is the Car class from before with a constructor that initializes the brand field:,"(""Car"", ""The constructor is a method within the Car class that initializes its fields."", ""constructor"")"
"Here is the Car class from before with a single, simple method named getBrand added:","(""Car"", ""The method getBrand is a part of the Car class"", ""getBrand"")"
"When a class implements an interface, the class has to implement all the methods described in the interface.","(""Class"", ""A class must implement all the methods described in an interface it implements."", ""Method"")"
"Packages provides a handy way of grouping related classes and interfaces, thus making modularization of your Java code easier.","(""Packages"", ""Packages group related classes together."", ""Classes""); (""Packages"", ""Packages group related interfaces together."", ""Interfaces"")"
"That these are primitive data types means that they are not objects, nor references to objects (classes and objects are explained in later texts in this Java tutorial).","(""Java"", ""Java is a programming language that includes classes as a fundamental concept."", ""classes""); (""Java"", ""Java is a programming language that includes objects as a fundamental concept."", ""objects"")"
You can also create your own more complex data types by creating custom classes.,"(""Classes"", ""Classes are used to create custom data types."", ""Data Types"")"
"More precisely, a Java enum type is a special kind of Java class.","(""Java"", ""A Java enum type is described as a special kind of Java class, indicating a relationship between the two."", ""enum"")"
Notice the enum keyword which is used in place of class or interface.,"(""ENUM"", ""The ENUM is used in place of a CLASS, indicating a relationship where ENUM can substitute CLASS."", ""CLASS""); (""ENUM"", ""The ENUM is used in place of an INTERFACE, indicating a relationship where ENUM can substitute INTERFACE."", ""INTERFACE"")"
Replace the ... with the code to execute if the level variable matches the given Level constant value.,"(""level"", ""The 'level' variable is being compared to the 'Level' constant, indicating a relationship between them."", ""Level"")"
You can obtain an array of all the possible values of a Java enum type by calling its static values() method.,"(""Java"", ""The values() method is a static method that can be called on a Java enum type to obtain an array of all possible values."", ""values()"")"
All enum types get a static values() method automatically by the Java compiler.,"(""Enum Types"", ""The values() method is automatically provided to all enum types by the Java compiler."", ""Values()""); (""Values()"", ""The Java compiler automatically generates the values() method for enum types."", ""Java Compiler"")"
An enum class automatically gets a toString() method in the class when compiled.,"(""Enum Class"", ""The toString() method is automatically included in the enum class when it is compiled."", ""ToString"")"
The toString() method returns a string value of the name of the given enum instance.,"(""toString"", ""The toString method is used to return a string value of the name of the given enum instance."", ""enum"")"
"Then the toString() method will get called behind the scenes, so the value that will be printed out is the textual name of the enum instance.","(""toString"", ""The toString method is called to get the textual name of the enum instance."", ""enum instance"")"
An enum class automatically gets a static valueOf() method in the class when compiled.,"(""Enum Class"", ""The ValueOf method is automatically included in the Enum Class when it is compiled."", ""ValueOf"")"
The valueOf() method can be used to obtain an instance of the enum class for a given String value.,"(""valueOf"", ""The valueOf method is used to obtain an instance of the enum class."", ""enum"")"
The level variable will point to the Level.HIGH after executing this line.,"(""Level"", ""HIGH is a method or constant within the Level class, as indicated by the dot notation Level.HIGH."", ""HIGH"")"
It is possible for a Java enum class to have abstract methods too.,"(""Java Enum Class"", ""A Java enum class can contain abstract methods, indicating a relationship where the class can define or implement these methods."", ""Abstract Methods"")"
"If an enum class has an abstract method, then each instance of the enum class must implement it.","(""Enum Class"", ""An enum class must implement an abstract method if it has one."", ""Abstract Method"")"
Notice the abstract method declaration at the bottom of the enum class.,"(""ENUM"", ""The method is declared within the enum class, indicating a relationship between the class and the method."", ""METHOD"")"
It is the method getDescription() that comes from the interface MyInterface.,"(""Getdescription"", ""The method Getdescription is part of the interface Myinterface."", ""Myinterface"")"
"Java enums extend the java.lang.Enum class implicitly, so your enum types cannot extend another class.","(""Java Enums"", ""Java Enums implicitly extend the java.lang.Enum class."", ""java.lang.Enum"")"
"The purpose of this exercise is to verify that you know how to create classes, how to create instance variables inside the classes, how to create an array of objects and how to iterate that array while referencing the objects in it.","(""Classes"", ""Instance Variables are created inside Classes."", ""Instance Variables""); (""Array"", ""The Array contains Objects, and iteration involves referencing these Objects."", ""Objects"")"
"For instance, in a class representing an employee, the Employee class might contain the following fields:","(""Employee"", ""The Employee is a specific example of a class representing an employee."", ""class"")"
The access modifier determines which object classes that can access the field.,"(""access modifier"", ""The access modifier determines which object classes can access the field."", ""object""); (""object"", ""Object classes can access the field."", ""field"")"
"In Java, static fields belongs to the class, not instances of the class.","(""Class"", ""The text mentions that static fields belong to the class, indicating a relationship between the concept of static fields and the class itself."", ""Class"")"
"Thus, all instances of any class will access the same static field variable.","(""Class"", ""All instances of any class will access the same static field variable, indicating a relationship between the class and the static field variable."", ""Static Field Variable"")"
A non-static field value can be different for every object (instance) of a class.,"(""Field"", ""A non-static field value can be different for every object, indicating a relationship between fields and objects."", ""Object""); (""Object"", ""An object is an instance of a class, showing a direct relationship between these two entities."", ""Instance""); (""Field"", ""A non-static field value can vary for each instance, linking fields to instances."", ""Instance"")"
The Java field access modifier determines whether the field can be accessed by classes other than the the class owning the field.,"(""field"", ""The access modifier determines the accessibility of the field."", ""access modifier""); (""field"", ""The field is a member of the class."", ""class""); (""access modifier"", ""The access modifier controls access to the class members."", ""class"")"
The private access modifier means that only code inside the class itself can access this Java field.,"(""Class"", ""The Java field is accessible only within the class due to the private access modifier."", ""Java"")"
"The package access modifier means that only code inside the class itself, or other classes in the same package, can access the field.","(""Access Modifier"", ""The access modifier is a feature of the class that controls access to its fields."", ""Class""); (""Access Modifier"", ""The access modifier determines access to fields for classes within the same package."", ""Package""); (""Class"", ""Classes within the same package can access each other's fields due to the package access modifier."", ""Package"")"
"The protected access modifier is like the package modifier, except subclasses of the class can also access the field, even if the subclass is not located in the same package.","(""Protected Access Modifier"", ""Both are access modifiers that control visibility."", ""Package Modifier""); (""Subclass"", ""A subclass is a type of class that inherits from another class."", ""Class""); (""Subclass"", ""A subclass can access fields in a package if it is protected."", ""Package""); (""Class"", ""A class can contain fields."", ""Field""); (""Subclass"", ""A subclass can access fields of its superclass."", ""Field"")"
The public access modifier means that the field can be accessed by all classes in your application.,"(""Public Access Modifier"", ""The public access modifier allows the field to be accessed by all classes."", ""Field""); (""Field"", ""The field can be accessed by all classes in the application."", ""Application"")"
You would probably not use all access modifiers in the same class.,"(""Class"", ""Access modifiers are typically used within a class to control the visibility of its members."", ""Access Modifiers"")"
"For simple, data carrying classes you may declare all fields public.","(""class"", ""class"")"
"Thus, no matter how many objects you create of that class, there will only exist one field located in the class, and the value of that field is the same, no matter from which object it is accessed.","(""Class"", ""The field is located in the class and its value is consistent across all objects of the class."", ""Field"")"
"Static fields are located in the class, so you don't need an instance of the class to access static fields.","(""Class"", ""Static fields are located in the class, indicating a relationship between the class and the static fields."", ""Class"")"
"Non-static Java fields, on the other hand, are located in the instances of the class.","(""Java"", ""Fields are located in instances of the Java class"", ""fields"")"
Each instance of the class can have its own values for these fields.,"(""Class"", ""class"")"
To access a non-static field you need an instance of the class (an object) on which you can access it.,"(""Class"", ""A non-static field is accessed through an instance of the class."", ""Field"")"
"That means, that even if the field belongs to objects (class instances), you cannot vary the value of the field from object to object.","(""Field"", ""The field belongs to objects, indicating a relationship between the field and the object."", ""Object"")"
"That way it only exists in the class, not in every object too.","(""Class"", ""The text implies that the class contains something that does not exist in every object, suggesting a relationship between the class and object."", ""Object"")"
"The first line creates a new Customer object (an instance of the Customer class), and stores it in a variable called customer.","(""Customer"", ""The term 'Customer' is used to describe both the object and the class, indicating that the object is an instance of the Customer class."", ""Customer"")"
A class is loaded the first time it is referenced in your program.,"(""Class"", ""A class is loaded the first time it is referenced, which implies a method call or reference in the program."", ""Method"")"
"Inside the parentheses () after the for keyword, are three statements separated by semicolon (;).",NULL
"In this example, only the first System.out.println() statement is executed inside the for loop.","(""System"", ""The 'out' method is a member of the 'System' class, used for output operations."", ""out""); (""out"", ""The 'println' method is called on the 'out' method to print text to the console."", ""println"")"
The second System.out.println() statement is not executed until after the for loop is finished.,"(""System.out.println()"", ""The System.out.println() method is executed after the for loop is finished."", ""for loop"")"
"Second, inside the isValid() method the String.equals() method is used to test for equality to a certain string value.","(""isValid"", ""The isValid method uses the equals method to test for equality."", ""equals""); (""equals"", ""The equals method is a method of the String class."", ""String"")"
The isValid() method could actually have been written in a shorter way.,"(""isValid"", ""method"")"
Now the isValid() method returns the value returned by the value.equals() method call.,"(""isValid"", ""The isValid method returns the value from the value.equals method call, indicating a direct functional relationship between the two methods."", ""value.equals"")"
Java inheritance refers to the ability in Java for one class to inherit from another class.,"(""Java"", ""Java is a package that provides the ability for one class to inherit from another class."", ""Class""); (""Class"", ""The concept of inheritance involves one class inheriting from another class."", ""Class"")"
One class can extend another class and thereby inherit from that class.,"(""Class"", ""One class can extend another class, indicating a relationship of inheritance between them."", ""Class"")"
"When one class inherits from another class in Java, the two classes take on certain roles.","(""Class"", ""The text describes a relationship where one class inherits from another class, indicating a hierarchical or parent-child relationship between the two classes."", ""Class""); (""Class"", ""The text mentions classes in the context of Java, indicating that the classes are part of the Java programming language."", ""Java"")"
The class that extends (inherits from another class) is the subclass and the class that is being extended (the class being inherited from) is the superclass .,"(""Subclass"", ""The Subclass extends or inherits from the Superclass, indicating a hierarchical relationship between them."", ""Superclass"")"
"A subclass is a specialization of a superclass, and a superclass is a generalization of one or more subclasses.","(""Subclass"", ""A subclass is a specialization of a superclass."", ""Superclass""); (""Superclass"", ""A superclass is a generalization of one or more subclasses."", ""Subclass"")"
"Inheritance can be an effective method to share code between classes that have some traits in common, yet allowing the classes to have some parts that are different.","(""Inheritance"", ""Inheritance is a method used to share code between classes."", ""Classes"")"
"Here is diagram illustrating a class called Vehicle, which has two subclasses called Car and Truck.","(""Vehicle"", ""Car is a subclass of Vehicle"", ""Car""); (""Vehicle"", ""Truck is a subclass of Vehicle"", ""Truck"")"
The Vehicle class can contain those fields and methods that all Vehicles need (e.g.,"(""Vehicle"", ""The Vehicle class is related to Vehicles as it defines fields and methods that all Vehicles need."", ""Vehicles"")"
Note: Some people will claim that inheritance is a way to categorize your classes based on what they are.,"(""Inheritance"", ""Inheritance is a way to categorize classes based on their characteristics."", ""Classes"")"
"In practice, however, that is not how you determine which superclasses and subclasses your application needs to have.",NULL
Then it makes sense to have a common Vehicle superclass for the two classes.,"(""Vehicle"", ""Vehicle is described as a superclass for the two classes."", ""superclass"")"
"If you never process Car and Truck objects in the same way, there is no point in having a common superclass for them, except perhaps to share code between them (to avoid writing duplicate code).",NULL
Superclasses and subclasses form an inheritance structure which is also called a class hierarchy.,"(""Superclasses"", ""Superclasses and subclasses are related as they form an inheritance structure, indicating a hierarchical relationship."", ""Subclasses""); (""Superclasses"", ""Superclasses are part of the class hierarchy as they form the top level of the inheritance structure."", ""Class Hierarchy""); (""Subclasses"", ""Subclasses are part of the class hierarchy as they form the lower levels of the inheritance structure."", ""Class Hierarchy"")"
At the top of the class hierarchy you have the superclasses.,"(""Class"", ""class"")"
At the bottom of the class hierarchy you have the subclasses.,"(""Class Hierarchy"", ""Subclasses are part of the class hierarchy"", ""Subclasses"")"
"A class hierarchy may have multiple levels, meaning multiple levels of superclasses and subclasses.","(""Class Hierarchy"", ""A class hierarchy includes multiple levels of superclasses."", ""Superclasses""); (""Class Hierarchy"", ""A class hierarchy includes multiple levels of subclasses."", ""Subclasses"")"
A subclass may itself be a superclass of other subclasses etc.,"(""Subclass"", ""A subclass is a type of class that can inherit from a superclass."", ""Superclass""); (""Superclass"", ""A superclass can have subclasses that inherit from it."", ""Subclass"")"
"When a class inherits from a superclass, it inherits parts of the superclass methods and fields.","(""Class"", ""A class inherits from a superclass, indicating a relationship of inheritance."", ""Superclass""); (""Class"", ""A class inherits methods from a superclass, indicating a relationship of method inheritance."", ""Methods"")"
"When a subclass extends a superclass in Java, all protected and public fields and methods of the superclass are inherited by the subclass.","(""Subclass"", ""A subclass extends a superclass, indicating an inheritance relationship."", ""Superclass""); (""Superclass"", ""Methods of the superclass are inherited by the subclass, showing a relationship between the superclass and its methods."", ""Method"")"
"By inherited is meant that these fields and methods are part of of the subclass, as if the subclass had declared them itself.","(""SUBCLASS"", ""FIELDS are part of the SUBCLASS as if declared by it."", ""FIELDS""); (""SUBCLASS"", ""METHODS are part of the SUBCLASS as if declared by it."", ""METHODS"")"
protected and public fields can be called and referenced just like the methods declared directly in the subclass.,"(""fields"", ""Fields can be called and referenced in the subclass."", ""subclass""); (""methods"", ""Methods can be declared directly in the subclass."", ""subclass"")"
Fields and methods with default (package) access modifiers can be accessed by subclasses only if the subclass is located in the same package as the superclass.,"(""Fields"", ""Fields have default access modifiers that are related to the package."", ""Package""); (""Methods"", ""Methods have default access modifiers that are related to the package."", ""Package""); (""Subclasses"", ""Subclasses can access fields and methods of the superclass if they are in the same package."", ""Superclass""); (""Subclasses"", ""Subclasses can access fields and methods if they are in the same package."", ""Package""); (""Superclass"", ""Superclass fields and methods can be accessed by subclasses if they are in the same package."", ""Package"")"
Private fields and methods of the superclass can never be referenced directly by subclasses.,"(""SUPERCLASS"", ""Subclasses inherit from superclasses, indicating a hierarchical relationship."", ""SUBCLASS""); (""METHOD"", ""Methods are typically associated with classes, and in this context, they belong to the superclass."", ""SUPERCLASS"")"
"They can, however, be referenced indirectly via methods reachable from the subclass (e.g default (package), protected and public methods).","(""METHODS"", ""Methods are reachable from the subclass, indicating a relationship between them."", ""SUBCLASS""); (""METHODS"", ""Methods can be referenced indirectly via the package, showing a connection."", ""PACKAGE"")"
"Constructors are not inherited by subclasses, but a subclass constructor must call a constructor in the superclass.","(""SUBCLASS CONSTRUCTOR"", ""A subclass constructor must call a constructor in the superclass, indicating a relationship between the subclass constructor and the superclass."", ""SUPERCLASS""); (""CONSTRUCTORS"", ""Constructors are mentioned in the context of subclasses, indicating a relationship between constructors and subclasses."", ""SUBCLASSES"")"
The Java inheritance mechanism only allows a Java class to inherit from a single superclass (singular inheritance).,"(""Java"", ""Java is a class that inherits from a superclass according to the inheritance mechanism described."", ""superclass"")"
"In some programming languages, like C++, it is possible for a subclass to inherit from multiple superclasses (multiple inheritance).","(""subclass"", ""A subclass inherits from multiple superclasses in the context of multiple inheritance."", ""superclass"")"
"the superclasses contain methods with the same names and parameters, multiple inheritance was left out in Java.","(""Superclasses"", ""Superclasses contain methods, indicating a relationship where methods are part of or defined within superclasses."", ""Methods""); (""Superclasses"", ""The text discusses features of Java, including superclasses, indicating that superclasses are a concept within the Java package."", ""Java"")"
You declare that one class extends another class by using the extends keyword in the class definition.,"(""Class"", ""The 'extends' keyword is used to declare that one class extends another class."", ""Extends"")"
"The Car class in this example extends the Vehicle class, meaning the Car class inherits from the Vehicle class.","(""Car"", ""The Car class inherits from the Vehicle class, indicating a parent-child relationship between them."", ""Vehicle"")"
"Because the Car class extends the Vehicle class, the protected field licensePlate from the Vehicle class is inherited by the Car class.","(""Car"", ""The Car class extends the Vehicle class, indicating an inheritance relationship."", ""Vehicle""); (""Car"", ""The Car class inherits the protected field licensePlate from the Vehicle class."", ""Vehicle"")"
"The licensePlate field is not actually being referenced from the Car class in the code above, but it could if we wanted to.","(""Car"", ""The licensePlate field could be referenced from the Car class."", ""licensePlate"")"
In many cases it would have made sense to place the getLicensePlate() method in the Vehicle class where the licensePlate field is located.,"(""GetLicensePlate"", ""The GetLicensePlate method is related to the Vehicle class because it is suggested to be placed within this class, where the licensePlate field is located."", ""Vehicle"")"
I just placed the getLicensePlate() method in the Car class to show that it is possible.,"(""GetLicensePlate"", ""The method GetLicensePlate is part of the Car class."", ""Car"")"
It is possible to reference a subclass as an instance of one of its superclasses.,"(""Subclass"", ""A subclass is a type of class that inherits from a superclass, indicating a hierarchical relationship."", ""Superclass"")"
"For instance, using the class definitions from the example in the previous section it is possible to reference an instance of the Car class as an instance of the Vehicle class.","(""Car"", ""The Car class is referenced as an instance of the Vehicle class, indicating a relationship between the two classes."", ""Vehicle"")"
"Because the Car class extends (inherits from) the Vehicle class, it is also said to be a Vehicle.","(""Car"", ""The Car class extends (inherits from) the Vehicle class, indicating an inheritance relationship."", ""Vehicle"")"
Here is a Java code example: Car car = new Car(); Vehicle vehicle = car; First a Car instance is created.,"(""Car"", ""Car is assigned to Vehicle, indicating a relationship between the two classes"", ""Vehicle"")"
This is possible because the Car class inherits from the Vehicle class.,"(""Car"", ""The Car class inherits from the Vehicle class, indicating a parent-child relationship."", ""Vehicle"")"
"As you can see, it is possible to use an instance of some subclass as if it were an instance of its superclass.","(""Subclass"", ""A subclass is a type of class that inherits from a superclass, indicating a hierarchical relationship."", ""Superclass"")"
"That way, you don't need to know exactly what subclass the object is an instance of.","(""Subclass"", ""The text refers to an object being an instance of a subclass, indicating a relationship between the two."", ""Object"")"
The process of referencing an object of class as a different type than the class itself is called type casting.,"(""Class"", ""class"")"
Upcasting and Downcasting You can always cast an object of a subclass to one of its superclasses.,"(""Subclass"", ""A subclass can be cast to one of its superclasses, indicating a hierarchical relationship."", ""Superclass""); (""Upcasting"", ""Upcasting involves casting an object to a superclass, which is related to the subclass."", ""Subclass""); (""Downcasting"", ""Downcasting involves casting an object to a subclass, which is related to the subclass."", ""Subclass"")"
This is referred to as upcasting (from a subclass type to a superclass type).,"(""SUBCLASS"", ""Upcasting involves converting a subclass type to a superclass type."", ""SUPERCLASS"")"
"It may also be possible to cast an object from a superclass type to a subclass type, but only if the object really is an instance of that subclass (or an instance of a subclass of that subclass).",NULL
This is referred to as downcasting (from a superclass type to a subclass type).,"(""superclass"", ""Downcasting involves converting from a superclass type to a subclass type."", ""subclass"")"
"Thus, this example of downcasting is valid: Car car = new Car(); // upcast to Vehicle Vehicle vehicle = car; // downcast to car again Car car2 = (Car) vehicle; However, the following downcast example is not valid.","(""Car"", ""Car is being upcast to Vehicle, indicating a relationship between the two classes"", ""Vehicle""); (""Vehicle"", ""Vehicle is being downcast back to Car, showing a reverse relationship between the two classes"", ""Car"")"
"Truck truck = new Truck(); // upcast to Vehicle Vehicle vehicle = truck; // downcast to car again Car car = (Car) vehicle; The Truck object can be upcast to a Vehicle object, but it cannot be downcast to a Car object later.","(""Truck"", ""The Truck object can be upcast to a Vehicle object, indicating a relationship between the Truck class and the Vehicle class."", ""Vehicle""); (""Vehicle"", ""The Vehicle object is downcast to a Car object, indicating a relationship between the Vehicle class and the Car class."", ""Car"")"
Overriding Methods In a subclass you can override (redefine) methods defined in the superclass.,"(""Subclass"", ""A subclass can override methods, indicating a relationship where the subclass modifies or extends the behavior of the methods."", ""Methods""); (""Superclass"", ""Methods are defined in the superclass, showing a relationship where the superclass provides the initial implementation of the methods."", ""Methods""); (""Subclass"", ""A subclass is derived from a superclass, indicating an inheritance relationship between the two classes."", ""Superclass"")"
Here is a Java method override example: public class Vehicle { String licensePlate = null; public void setLicensePlate(String licensePlate) { this.licensePlate = licensePlate; } } public class Car extends Vehicle { public void setLicensePlate(String license) { this.licensePlate = license.toLowerCase(); } } Notice how both the Vehicle class and the Car class defines a method called setLicensePlate().,"(""Vehicle"", ""The Vehicle class defines a method called setLicensePlate."", ""setLicensePlate""); (""Car"", ""The Car class defines a method called setLicensePlate, which overrides the method in the Vehicle class."", ""setLicensePlate""); (""Car"", ""The Car class extends the Vehicle class, indicating an inheritance relationship."", ""Vehicle"")"
"Now, whenever the setLicensePlate() method is called on a Car object, it is the method defined in the Car class that is called.","(""SetLicensePlate"", ""The SetLicensePlate method is called on a Car object, indicating it is a method within the Car class."", ""Car""); (""SetLicensePlate"", ""The SetLicensePlate method is defined in the Car class, establishing a direct relationship between the method and the class."", ""Car"")"
To override a method the method signature in the subclass must be the same as in the superclass.,"(""Subclass"", ""A subclass is a type of class that inherits from a superclass."", ""Superclass""); (""Method"", ""A method can be overridden in a subclass."", ""Subclass""); (""Method"", ""A method is originally defined in a superclass."", ""Superclass"")"
"That means that the method definition in the subclass must have exactly the same name and the same number and type of parameters, and the parameters must be listed in the exact same sequence as in the superclass.","(""Subclass"", ""The Subclass is related to the Superclass because it inherits or extends the Superclass, as indicated by the need for method definitions to match."", ""Superclass""); (""Method"", ""The Method is related to the Subclass because it is defined within the Subclass and must match the Superclass's method signature."", ""Subclass""); (""Method"", ""The Method is related to the Superclass because the Subclass's method must match the Superclass's method signature."", ""Superclass"")"
Otherwise the method in the subclass will be considered a separate method.,"(""method"", ""The method is part of the subclass, indicating a relationship between the method and the class."", ""subclass"")"
"If the superclass calls a private method internally from some other method, it will continue to call that method from the superclass, even if you create a private method in the subclass with the same signature.","(""Superclass"", ""The Superclass calls the Method internally from some other method."", ""Method""); (""Subclass"", ""The Subclass can have a private method with the same signature as a method in the Superclass."", ""Superclass"")"
"It would be nice if the compiler could tell you that the method being overridden no longer overrides a method in the superclass, right?","(""METHOD"", ""The method is being overridden in the superclass."", ""SUPERCLASS""); (""COMPILER"", ""The compiler checks if the method being overridden is valid."", ""METHOD"")"
"You can call superclass implementations from any method in a subclass, like above.","(""superclass"", ""A superclass is a class from which a subclass inherits methods and properties."", ""subclass""); (""method"", ""Methods can be implemented in a subclass, and they can call implementations from a superclass."", ""subclass"")"
"For instance, you could also have called super.setLicensePlate() from a method in the Car class called updateLicensePlate() which does not override the setLicensePlate() method.","(""Car"", ""The updateLicensePlate method is a method within the Car class."", ""updateLicensePlate""); (""updateLicensePlate"", ""The updateLicensePlate method calls the setLicensePlate method."", ""setLicensePlate""); (""Car"", ""The setLicensePlate method is associated with the Car class, as it is mentioned in the context of being overridden or called from within the class."", ""setLicensePlate"")"
The instanceof instruction can determine whether a given object is an instance of some class.,"(""Instanceof"", ""The instanceof method is used to check if an object is an instance of a class."", ""Object""); (""Instanceof"", ""The instanceof method checks if an object is an instance of a specific class."", ""Class"")"
Here is a Java instanceof example: Car car = new Car(); boolean isCar = car instanceof Car; After this code has been executed the isCar variable will contain the value true.,"(""Car"", ""The 'instanceof' method is used to check if 'car' is an instance of the 'Car' class."", ""instanceof""); (""Car"", ""The 'car' variable is an instance of the 'Car' class."", ""Car"")"
The instanceof instruction can also be used determine if an object is a instance of a superclass of its class.,"(""Instanceof"", ""The instanceof method is used to determine if an object is an instance of a class."", ""Object""); (""Instanceof"", ""The instanceof method can determine if an object is an instance of a superclass of its class."", ""Superclass"")"
"Here is an instanceof example that checks if a Car object is an instance of Vehicle: Car car = new Car(); boolean isVehicle = car instanceof Vehicle; Assuming that the Car class extends (inherits from) the Vehicle class, the isVehicle variable will contain the value true after this code is executed.","(""Car"", ""The Car class is an instance of the Vehicle class, indicating an inheritance relationship."", ""Vehicle""); (""Car"", ""The Car class extends (inherits from) the Vehicle class, showing a clear parent-child relationship."", ""Vehicle"")"
A Car object is also a Vehicle object because Car is a subclass of Vehicle.,"(""Car"", ""Car is a subclass of Vehicle, indicating an inheritance relationship between the two classes."", ""Vehicle"")"
"Look at this instanceof example: Car car = new Car(); Vehicle vehicle = car; boolean isCar = vehicle instanceof Car; Even though the vehicle variable is of type Vehicle, the object it ends up pointing to in this example is a Car object.","(""Car"", ""Car is an instance of Vehicle, as shown by the instanceof example where a Car object is assigned to a Vehicle variable."", ""Vehicle""); (""Vehicle"", ""The instanceof operator checks if the Vehicle object is actually an instance of the Car class."", ""Car"")"
"Here is the same instanceof example, but using a Truck object instead of a Car object: Truck truck = new Truck(); Vehicle vehicle = truck; boolean isCar = vehicle instanceof Car; After executing this code the isCar will contain the value false.","(""Truck"", ""A Truck object is assigned to a Vehicle reference, indicating that Truck is a subclass or implementation of Vehicle."", ""Vehicle""); (""Vehicle"", ""The instanceof operator is used to check if a Vehicle object is an instance of the Car class, indicating a potential relationship between Vehicle and Car."", ""Car"")"
"Fields and Inheritance As mentioned earlier, in Java fields cannot be overridden in a subclass.","(""Fields"", ""Fields and Inheritance are both classes mentioned in the context of Java."", ""Inheritance""); (""Inheritance"", ""Inheritance is related to subclass as it is mentioned that fields cannot be overridden in a subclass."", ""subclass""); (""Java"", ""Fields are mentioned in the context of Java, indicating a relationship between the package and the class."", ""Fields""); (""Java"", ""Inheritance is discussed in the context of Java, indicating a relationship between the package and the class."", ""Inheritance""); (""Java"", ""Subclass is mentioned in the context of Java, indicating a relationship between the package and the class."", ""subclass"")"
"If you define a field in a subclass with the same name as a field in the superclass, the field in the subclass will hide (shadow) the field in the superclass.","(""Subclass"", ""The Subclass hides (or shadows) the field in the Superclass when a field with the same name is defined in both."", ""Superclass"")"
"If the subclass tries to access the field, it will access the field in the subclass.","(""Subclass"", ""The Subclass accesses the Field, indicating a relationship where the Subclass interacts with or utilizes the Field."", ""Field"")"
"If, however, the subclass calls up into a method in the superclass, and that method accesses the field with the same name as in the subclass, it is the field in the superclass that is accessed.","(""SUBCLASS"", ""The subclass calls a method in the superclass, indicating a relationship between the two classes."", ""SUPERCLASS""); (""METHOD"", ""The method accesses the field, indicating a relationship between the method and the field."", ""FIELD"")"
Both the Vehicle class and Car class has the methods setLicensePlate() and getLicensePlate().,"(""Vehicle"", ""The Vehicle class has the method setLicensePlate()."", ""setLicensePlate""); (""Vehicle"", ""The Vehicle class has the method getLicensePlate()."", ""getLicensePlate""); (""Car"", ""The Car class has the method setLicensePlate()."", ""setLicensePlate""); (""Car"", ""The Car class has the method getLicensePlate()."", ""getLicensePlate"")"
The methods in the Car class calls the corresponding methods in the Vehicle class.,"(""Car"", ""The Car class contains or uses the methods."", ""methods""); (""Vehicle"", ""The Vehicle class contains or uses the methods."", ""methods""); (""Car"", ""The methods in the Car class call the corresponding methods in the Vehicle class, indicating a relationship between the two classes."", ""Vehicle"")"
"The result is, that eventually both set of methods access the licensePlate field in the Vehicle class.","(""methods"", ""The methods access the licensePlate field."", ""licensePlate""); (""licensePlate"", ""The licensePlate field is part of the Vehicle class."", ""Vehicle"")"
"The updateLicensePlate() method in the Car class however, accesses the licensePlate field directly.","(""UpdateLicensePlate"", ""The method updateLicensePlate() is part of the Car class."", ""Car"")"
"Therefore, you will not get the same result if you call setLicensePlate() as when you call the updateLicense() method.","(""setLicensePlate"", ""Both are methods that seem to be related to handling license information."", ""updateLicense"")"
"Look at the following lines of Java code: Car car = new Car(); car.setLicensePlate(""123""); car.updateLicensePlate(""abc""); System.out.println(""license plate: "" + car.getLicensePlate()); This Java code will print out the text 123.","(""Car"", ""The method setLicensePlate is called on an instance of the Car class."", ""setLicensePlate""); (""Car"", ""The method updateLicensePlate is called on an instance of the Car class."", ""updateLicensePlate""); (""Car"", ""The method getLicensePlate is called on an instance of the Car class."", ""getLicensePlate""); (""System"", ""The method out is a member of the System class."", ""out""); (""out"", ""The method println is called on the out method."", ""println"")"
The updateLicensePlate() method sets the license plate value on the licensePlate field in the Car class.,"(""UpdateLicensePlate"", ""The UpdateLicensePlate method sets the value on the LicensePlate field."", ""LicensePlate""); (""UpdateLicensePlate"", ""The UpdateLicensePlate method is associated with the Car class."", ""Car"")"
"The getLicensePlate() method, however, returns the value of the licensePlate field in the Vehicle class.","(""GetLicensePlate"", ""The GetLicensePlate method is related to the Vehicle class because it returns the value of the licensePlate field within this class."", ""Vehicle"")"
"Therefore, the value 123 which is set as value for the licensePlate field in the Vehicle class via the setLicensePlate() method, is what is printed out.","(""Vehicle"", ""The setLicensePlate method is used to set the value for the licensePlate field in the Vehicle class."", ""setLicensePlate"")"
"In other words, constructors of a superclass are not inherited by subclasses.","(""CONSTRUCTORS"", ""Constructors are methods that belong to the superclass."", ""SUPERCLASS""); (""SUPERCLASS"", ""Subclasses inherit from the superclass."", ""SUBCLASSES"")"
Subclasses can still call the constructors in the superclass using the super() contruct.,"(""Subclasses"", ""Subclasses can call constructors in the superclass using the super() method."", ""superclass""); (""super()"", ""The super() method is used to call constructors in the superclass."", ""superclass"")"
"In fact, a subclass constructor is required to call one of the constructors in the superclass as the very first action inside the constructor body.","(""Subclass Constructor"", ""A subclass constructor must call a constructor in the superclass as its first action, indicating a relationship between the two classes."", ""Superclass"")"
Here is how that looks: public class Vehicle { public Vehicle() { } } public class Car extends Vehicle{ public Car() { super(); //perform other initialization here } } Notice the call to super() inside the Car constructor.,"(""Car"", ""Car is a subclass of Vehicle, as indicated by the 'extends' keyword."", ""Vehicle""); (""super"", ""The method super() is called within the Car constructor to initialize the superclass Vehicle."", ""Car"")"
You may have seen Java classes where the subclass constructors did not seem to call the constructors in the superclass.,"(""Subclass"", ""The Subclass is related to the Superclass because it is implied that the Subclass constructors are expected to call the constructors in the Superclass."", ""Superclass""); (""Java"", ""The Java class is related to the Subclass as it is a type of class being discussed."", ""Subclass""); (""Java"", ""The Java class is related to the Superclass as it is a type of class being discussed."", ""Superclass"")"
"However, the subclass constructors have still called superclass constructors in those case.","(""Subclass Constructors"", ""Subclass constructors call superclass constructors."", ""Superclass Constructors"")"
"Let me explain why: If a class does not have any explicit constructor defined, the Java compiler inserts an implicit no-arg constructor.","(""Class"", ""A class can have a constructor, which is a method used to initialize objects of the class."", ""Constructor""); (""Java Compiler"", ""The Java compiler inserts an implicit no-arg constructor if none is explicitly defined in a class."", ""Constructor"")"
"Therefore the following version of Vehicle is equivalent to the version shown just above: public class Vehicle { } Second, if a constructor does not explicitly call a constructor in the superclass, the Java compiler inserts an implicit call to the no-arg constructor in the superclass.","(""Vehicle"", ""The Vehicle class can have a constructor, which is a method used to initialize objects of the class."", ""constructor""); (""constructor"", ""The constructor is a method in Java, which is a programming language and environment."", ""Java"")"
"That means that the following version of the Car class is actually equivalent to the version shown earlier: public class Car extends Vehicle{ public Car() { } } In fact, since the constructor is now empty, we could leave it out and the Java compiler would insert it, and insert an implicit call to the no-arg constructor in the superclass.","(""Car"", ""Car is a subclass of Vehicle, as indicated by 'extends Vehicle' in the class definition."", ""Vehicle"")"
"This is how the two classes would look then: public class Vehicle { } public class Car extends Vehicle{ } Even though no constructors are declared in these two classes, they both get a no-arg constructor, and the no-arg constructor in the Car class will call the no-arg constructor in the Vehicle class.","(""Car"", ""The Car class extends the Vehicle class, indicating an inheritance relationship where Car is a subclass of Vehicle."", ""Vehicle""); (""Car"", ""The no-arg constructor in the Car class calls the no-arg constructor in the Vehicle class, showing a relationship where Car depends on Vehicle for its constructor logic."", ""Vehicle"")"
"If the Vehicle class did not have a no-arg constructor, but had another constructor which takes parameters, the Java compiler would complain.","(""Vehicle"", ""The Vehicle class is related to the constructor because it is mentioned that the class has a constructor."", ""constructor""); (""Java"", ""The Java package is related to the compiler as it is mentioned in the context of Java compilation."", ""compiler"")"
"The Car class would then be required to declare a constructor, and inside that constructor call the constructor in the Vehicle class.","(""Car"", ""The Car class is required to declare a constructor."", ""constructor""); (""Car"", ""The constructor in the Car class calls the constructor in the Vehicle class, indicating a relationship between the two classes."", ""Vehicle""); (""constructor"", ""The constructor in the Car class calls the constructor in the Vehicle class."", ""Vehicle"")"
Nested Classes and Inheritance The same Java inheritance rules apply to nested classes.,"(""Nested Classes"", ""Nested Classes are a type of class that can be involved in inheritance relationships."", ""Inheritance""); (""Java"", ""Nested Classes are a feature within the Java programming language."", ""Nested Classes""); (""Java"", ""Inheritance is a fundamental concept in the Java programming language."", ""Inheritance"")"
Nested classes with the default (package) access modifier are only accessible to subclasses if the subclass is located in the same package as the superclass.,"(""Nested Classes"", ""Nested classes have a default access modifier that is package-level."", ""Package""); (""Subclasses"", ""Subclasses are accessible if they are in the same package."", ""Package""); (""Subclasses"", ""Subclasses are related to the superclass in terms of access."", ""Superclass""); (""Superclass"", ""Superclass must be in the same package for subclasses to access nested classes."", ""Package"")"
Nested classes with the protected or public access modifier are always inherited by subclasses.,"(""Nested Classes"", ""Nested classes are inherited by subclasses when they have protected or public access modifiers."", ""Subclasses"")"
Here is a nested class inheritance example: class MyClass { class MyNestedClass { } } public class MySubclass extends MyClass { public static void main(String[] args) { MySubclass subclass = new MySubclass(); MyNestedClass nested = subclass.new MyNestedClass(); } } Notice how it is possible to create an instance of the nested class MyNestedClass which is defined in the superclass (MyClass) via a reference to the subclass (MySubclass).,"(""MyNestedClass"", ""MyNestedClass is a nested class within MyClass."", ""MyClass""); (""MySubclass"", ""MySubclass extends MyClass, indicating an inheritance relationship."", ""MyClass""); (""MyNestedClass"", ""An instance of MyNestedClass is created via a reference to MySubclass, showing a relationship between the nested class and the subclass."", ""MySubclass"")"
Here is now that looks: public final class MyClass { } A final class cannot be extended.,"(""MyClass"", ""MyClass is described as a final class, indicating it cannot be extended."", ""final"")"
"In other words, you cannot inherit from a final class in Java.","(""Final Class"", ""A final class is a type of class in the Java programming language."", ""Java"")"
Abstract Classes and Inheritance In Java a class can be declared abstract.,"(""Abstract Classes"", ""Abstract Classes and Inheritance are related as they both pertain to class structures in Java."", ""Inheritance""); (""Abstract Classes"", ""Abstract Classes are a feature within the Java package."", ""Java""); (""Inheritance"", ""Inheritance is a concept used within the Java package."", ""Java"")"
I have explained abstract classes in more detail in my Java abstract classes tutorial.,"(""Abstract Classes"", ""Abstract Classes are a feature within the Java programming language."", ""Java"")"
An abstract class is a class that does not contain the full implementation of whatever the abstract class should do.,"(""Abstract Class"", ""An abstract class is a type of class that does not contain the full implementation of its intended functionality."", ""Class"")"
"In other words, you cannot create objects of an abstract class.","(""Abstract Class"", ""class"")"
In Java abstract classes are intended to be extended to create a full implementation.,"(""Java"", ""Abstract classes are a feature of the Java programming language."", ""abstract classes"")"
The Java inheritance rules are the same for abstract classes as for non-abstract classes.,"(""inheritance"", ""The inheritance rules apply to abstract classes."", ""abstract classes""); (""inheritance"", ""The inheritance rules apply to non-abstract classes."", ""non-abstract classes""); (""abstract classes"", ""The inheritance rules are the same for both abstract and non-abstract classes."", ""non-abstract classes"")"
You can always cast an object of a subclass to one of its superclasses.,"(""Subclass"", ""A subclass can be cast to one of its superclasses because it inherits properties and methods from the superclass."", ""Superclass"")"
In a subclass you can override (redefine) methods defined in the superclass.,"(""Subclass"", ""A subclass is a type of class that inherits from a superclass."", ""Superclass""); (""Subclass"", ""In a subclass, you can override methods that are defined in the superclass."", ""Methods""); (""Superclass"", ""Methods are defined in the superclass and can be overridden in a subclass."", ""Methods"")"
Notice how both the Vehicle class and the Car class defines a method called setLicensePlate().,"(""Vehicle"", ""The Vehicle class defines the setLicensePlate method."", ""setLicensePlate""); (""Car"", ""The Car class defines the setLicensePlate method."", ""setLicensePlate""); (""Vehicle"", ""Both are classes mentioned in the context of defining the same method, setLicensePlate."", ""Car"")"
"If you override a method in a subclass, and the method is all of a sudden removed or renamed or have its signature changed in the superclass, the method in the subclass no longer overrides the method in the superclass.","(""Subclass"", ""A subclass is a type of class that inherits from a superclass."", ""Superclass""); (""Method"", ""A method can be overridden in a subclass."", ""Subclass""); (""Method"", ""A method can be defined in a superclass and overridden in a subclass."", ""Superclass"")"
"If you override a method in a subclass, but still need to call the method defined in the superclass, you can do so using the super reference, like this:","(""Subclass"", ""A subclass is a type of class that inherits from a superclass."", ""Superclass""); (""Method"", ""The method is defined in the superclass."", ""Superclass""); (""Method"", ""The method is overridden in the subclass."", ""Subclass"")"
"In the above code example the method setLicensePlate() in the Car class, calls the setLicensePlate() method in the Vehicle class.","(""SetLicensePlate"", ""The method SetLicensePlate is part of the Car class."", ""Car""); (""SetLicensePlate"", ""The method SetLicensePlate is also part of the Vehicle class."", ""Vehicle"")"
"Assuming that the Car class extends (inherits from) the Vehicle class, the isVehicle variable will contain the value true after this code is executed.","(""Car"", ""The Car class extends (inherits from) the Vehicle class, indicating an inheritance relationship."", ""Vehicle"")"
"As mentioned earlier, in Java fields cannot be overridden in a subclass.","(""fields"", ""Fields cannot be overridden in a subclass, indicating a relationship between the two."", ""subclass"")"
Here is Java inheritance example that illustrates how fields in subclasses shadow (hides) fields in superclasses:,"(""Subclasses"", ""Subclasses inherit from superclasses, which is a fundamental concept in Java inheritance."", ""Superclasses""); (""Fields"", ""Fields in subclasses can shadow fields in superclasses, as mentioned in the text."", ""Subclasses""); (""Fields"", ""Fields in superclasses can be shadowed by fields in subclasses, as mentioned in the text."", ""Superclasses"")"
"If a class does not have any explicit constructor defined, the Java compiler inserts an implicit no-arg constructor.","(""Class"", ""A class can have a constructor, which is a method used to initialize objects of the class."", ""Constructor""); (""Java Compiler"", ""The Java compiler inserts an implicit no-arg constructor if a class does not have any explicit constructor defined."", ""Constructor"")"
"Second, if a constructor does not explicitly call a constructor in the superclass, the Java compiler inserts an implicit call to the no-arg constructor in the superclass.","(""Constructor"", ""A constructor can call a constructor in the superclass."", ""Superclass""); (""Java Compiler"", ""The Java compiler inserts an implicit call to the no-arg constructor."", ""Constructor"")"
That means that the following version of the Car class is actually equivalent to the version shown earlier:,"(""Car"", ""The text indicates that the current version of the Car class is equivalent to an earlier version, suggesting a relationship between the two versions."", ""Car"")"
"In fact, since the constructor is now empty, we could leave it out and the Java compiler would insert it, and insert an implicit call to the no-arg constructor in the superclass.","(""constructor"", ""The Java compiler can insert the constructor if it is left out."", ""Java compiler""); (""constructor"", ""The constructor can include an implicit call to the no-arg constructor in the superclass."", ""superclass"")"
"Even though no constructors are declared in these two classes, they both get a no-arg constructor, and the no-arg constructor in the Car class will call the no-arg constructor in the Vehicle class.","(""CAR"", ""The Car class calls the no-arg constructor in the Vehicle class, indicating a relationship between the two classes."", ""VEHICLE""); (""CAR"", ""The Car class has a no-arg constructor, which is a method within the class."", ""NO-ARG CONSTRUCTOR""); (""VEHICLE"", ""The Vehicle class has a no-arg constructor, which is a method within the class."", ""NO-ARG CONSTRUCTOR"")"
Notice how it is possible to create an instance of the nested class MyNestedClass which is defined in the superclass (MyClass) via a reference to the subclass (MySubclass).,"(""MyNestedClass"", ""MyNestedClass is a nested class defined in the superclass MyClass."", ""MyClass""); (""MyNestedClass"", ""MyNestedClass can be instantiated via a reference to the subclass MySubclass."", ""MySubclass""); (""MySubclass"", ""MySubclass is a subclass of MyClass."", ""MyClass"")"
"The Java instanceof operator can determine if a given Java object is an instance of a given class, superclass or interface.","(""Java"", ""The instanceof operator is used in Java to determine if an object is an instance of a class, superclass, or interface."", ""instanceof"")"
The Java instanceof operator is also referred to as a type comparison operator because it compares the type of a given instance (object) with a specific type (class or interface).,"(""Java"", ""The instanceof operator is a feature of the Java programming language."", ""Instanceof""); (""Instanceof"", ""The instanceof operator is also known as a type comparison operator."", ""Type Comparison Operator""); (""Instance"", ""The instanceof operator compares the type of a given instance with a specific class."", ""Class""); (""Instance"", ""The instanceof operator compares the type of a given instance with a specific interface."", ""Interface"")"
"The expression map instanceof Object will evaluate to true if the map variable references an object that is an instance of class Object, or any subclass of class Object.","(""map"", ""The map variable is being checked to see if it is an instance of the class Object or any subclass of it."", ""Object"")"
"Since all classes in Java inherit from Object, this expression will evaluate to true.","(""Object"", ""All classes in Java inherit from the Object class, indicating a hierarchical relationship."", ""Object"")"
"As mentioned earlier, the Java instanceof operator will evaluate to true if you compare an object to the exact class of that object.","(""Java"", ""The Java package contains the Instanceof class, which is used for type comparison."", ""Instanceof"")"
Here is a Java instanceof example showing a comparison of an object to its exact class:,"(""instanceof"", ""The 'instanceof' method is used to compare an object to a class."", ""object""); (""object"", ""An object is compared to its exact class in the example."", ""class"")"
"As also mentioned earlier, the Java instanceof operator also evaluates to true when comparing an object against a superclass of the type of that object.","(""Instanceof"", ""The Instanceof class is part of the Java package, as it is a feature of the Java programming language."", ""Java"")"
"Since HashMap is a subclass of Object - even if not a direct subclass, the expression map instanceof Object evaluates to true.","(""HashMap"", ""HashMap is a subclass of Object"", ""Object""); (""map"", ""The expression 'map instanceof Object' evaluates to true, indicating a relationship between 'map' and 'Object'"", ""Object"")"
"Note, that it does not matter how high up in the inheritance hierarchy the compared type is superclass of the type of the object.",NULL
"As long as the type compared to is a superclass somewhere up the inheritance hierarchy, instanceof will evaluate to true.","(""INSTANCEOF"", ""INSTANCEOF is related to SUPERCLASS because INSTANCEOF checks if an object is an instance of a SUPERCLASS in the inheritance hierarchy."", ""SUPERCLASS"")"
The Java instanceof operator also works when comparing an object against an interface instead of a class.,"(""Instanceof"", ""The instanceof operator is used to compare an object."", ""Object""); (""Instanceof"", ""The instanceof operator can also compare an object against an interface."", ""Interface"")"
"Notice, that even if the map variable is of type HashMap, the instanceof operator returns true for the expression map instanceof Map because the HashMap class implements the Map interface.","(""HashMap"", ""The HashMap class implements the Map interface, indicating a relationship where HashMap is a specific implementation of the Map interface."", ""Map""); (""instanceof"", ""The instanceof method is used to check if the map variable, which is of type HashMap, is an instance of the Map interface."", ""HashMap""); (""instanceof"", ""The instanceof method is used to verify if the map variable is an instance of the Map interface."", ""Map"")"
"The Java instanceof operator also evaluates to true when comparing an object against a superinterface which the class of the object, or a superclass of the object implements.","(""Object"", ""The object is compared against a superinterface to evaluate the instanceof operator."", ""Superinterface""); (""Object"", ""The object is compared against a superclass to evaluate the instanceof operator."", ""Superclass"")"
"The TreeMap class implements SortedMap, and thus also indirectly the Map interface.","(""TreeMap"", ""TreeMap class implements SortedMap class"", ""SortedMap""); (""TreeMap"", ""TreeMap class indirectly implements Map interface through SortedMap"", ""Map"")"
The Java instanceof operator always evaluates to false when a null variable is compared against any class or interface.,"(""Instanceof"", ""The instanceof is referred to as an operator in the text."", ""Operator""); (""Variable"", ""A variable is compared against a class in the text."", ""Class""); (""Variable"", ""A variable is compared against an interface in the text."", ""Interface"")"
Here is a Java instanceof example illustrating the comparison of null against a class:,"(""Java"", ""The Java package is used to demonstrate the instanceof class example."", ""Instanceof"")"
"That is because it is not the reference type that is compared against the target class or interface, but the actual type of the referenced object.","(""REFERENCED OBJECT"", ""The referenced object is compared against the target class."", ""CLASS""); (""REFERENCED OBJECT"", ""The referenced object is compared against the target interface."", ""INTERFACE"")"
"Since a Java String object can never be an instance of the Java Integer class, the Java compiler will catch this an give you an error.","(""Java String"", ""The Java String class and Java Integer class are mentioned together to illustrate a type mismatch error."", ""Java Integer""); (""Java compiler"", ""The Java compiler checks the Java String class for type compatibility."", ""Java String""); (""Java compiler"", ""The Java compiler checks the Java Integer class for type compatibility."", ""Java Integer"")"
That means that the actual class of the referenced object could be pretty much any class (since all classes are subclasses of Object).,"(""Object"", ""Object is mentioned as a superclass of all classes, indicating a relationship between Object and any class."", ""class"")"
"In short, we can avoid the explicit downcast of an object when comparing it against a subclass.","(""object"", ""The term 'subclass' implies a hierarchical relationship where 'object' is being compared against 'subclass'."", ""subclass"")"
Notice the str variable after the String class name in the instanceof expression inside the if-statement.,"(""String"", ""The str variable is being checked against the String class using the instanceof expression."", ""str"")"
"Since the right hand side of the expression is only evaluated if the left hand side evaluates to true, this cannot result in startsWith() being called on a non-String object.","(""STARTSWITH"", ""The method startsWith() is being called on a String object."", ""STRING"")"
"A question I get a lot is what the difference is between Java interfaces and abstract classes, and when to use each.","(""Java"", ""Interfaces are a type of class in the Java package."", ""interfaces""); (""Java"", ""Abstract classes are a type of class in the Java package."", ""abstract classes"")"
"Having answered this question by email multiple times, I decided to write this tutorial about Java interfaces vs abstract classes.","(""Java"", ""Interfaces are a type of class in the Java package."", ""interfaces""); (""Java"", ""Abstract classes are a type of class in the Java package."", ""abstract classes"")"
"In other words, to make the classes using the interface independent of the classes implementing the interface.","(""Classes"", ""The classes are using the interface, indicating a dependency or interaction between them."", ""Interface""); (""Interface"", ""The interface is implemented by the classes, showing a relationship where the interface defines a contract that the classes fulfill."", ""Classes"")"
"Thus, you can exchange the implementation of the interface, without having to change the class using the interface.","(""CLASS"", ""The class is using the interface, indicating a dependency or interaction between them."", ""INTERFACE"")"
Abstract classes are typically used as base classes for extension by subclasses.,"(""Abstract Classes"", ""Abstract classes are used as base classes for extension by subclasses."", ""Subclasses"")"
"Some programming languages use abstract classes to achieve polymorphism, and to separate interface from implementation, but in Java you use interfaces for that.","(""Abstract Classes"", ""Abstract classes are used to achieve polymorphism."", ""Polymorphism""); (""Abstract Classes"", ""Abstract classes help separate interface from implementation."", ""Interface""); (""Java"", ""In Java, interfaces are used to separate interface from implementation."", ""Interface"")"
"Remember, a Java class can only have 1 superclass, but it can implement multiple interfaces.","(""Java"", ""A Java class can have one superclass, indicating a hierarchical relationship."", ""superclass""); (""Java"", ""A Java class can implement multiple interfaces, indicating a relationship where the class adopts behaviors defined by the interfaces."", ""interfaces"")"
"Thus, if a class already has a different superclass, it can implement an interface, but it cannot extend another abstract class.","(""Class"", ""A class can have a superclass, indicating a relationship of inheritance."", ""Superclass""); (""Class"", ""A class can implement an interface, indicating a relationship of implementation."", ""Interface""); (""Class"", ""A class cannot extend another abstract class, indicating a restriction in inheritance."", ""Abstract Class"")"
"If you also need to provide a base class or default implementation of the interface, add an abstract class (or normal class) that implements the interface.","(""Abstract Class"", ""An abstract class is mentioned as a way to implement the interface."", ""Interface""); (""Normal Class"", ""A normal class is mentioned as a way to implement the interface."", ""Interface"")"
"Here is an example showing a class referencing an interface, an abstract class implementing that interface, and a subclass extending the abstract class.","(""Class"", ""The class is referencing the interface."", ""Interface""); (""Abstract Class"", ""The abstract class is implementing the interface."", ""Interface""); (""Subclass"", ""The subclass is extending the abstract class."", ""Abstract Class"")"
"Below are the code examples from the text on Java Abstract Classes, but with an interface added which is implemented by the abstract base class.","(""interface"", ""The interface is implemented by the abstract base class."", ""abstract base class"")"
"Fourth, how to use the interface URLProcessor as variable type, even though it is the subclass UrlProcessorImpl that is instantiated.","(""UrlProcessorImpl"", ""UrlProcessorImpl is a subclass of URLProcessor"", ""URLProcessor"")"
Using both an interface and an abstract base class makes your code more flexible.,"(""Interface"", ""Both are types of classes that can be used to make code more flexible."", ""Abstract Base Class"")"
It possible to implement simple URL processors simply by subclassing the abstract base class.,"(""URL Processors"", ""URL Processors is a subclass of the Abstract Base Class"", ""Abstract Base Class"")"
"A Java interface is a bit like a Java class, except a Java interface can only contain method signatures and fields.","(""Java Interface"", ""A Java interface is similar to a Java class in structure."", ""Java Class""); (""Java Interface"", ""A Java interface can contain method signatures."", ""Method Signatures""); (""Java Interface"", ""A Java interface can contain fields."", ""Fields"")"
"However, it is possible to provide default implememntations of a method in a Java interface, to make the implementation of the interface easier for classes implementing the interface.","(""interface"", ""An interface can provide default implementations of a method."", ""method""); (""classes"", ""Classes implement the interface."", ""interface""); (""Java"", ""The interface is a feature of the Java package."", ""interface"")"
"Just like with classes, a Java interface can be declared public or package scope (no access modifier).","(""Java"", ""Java is a type of class, and interface is a type of class in Java."", ""interface""); (""interface"", ""An interface can have a package scope in Java."", ""package"")"
"As you can see, accessing a variable from an interface is very similar to accessing a static variable in a class.","(""INTERFACE"", ""The INTERFACE is related to the VARIABLE because accessing a variable from an interface is mentioned."", ""VARIABLE"")"
"The method, however, needs to be implemented by some class before you can access it.","(""METHOD"", ""The method needs to be implemented by the class, indicating a dependency or implementation relationship."", ""CLASS"")"
"Before you can really use an interface, you must implement that interface in some Java class.","(""Interface"", ""A Java class implements an interface to use its defined methods and properties."", ""Java Class"")"
Here is a class that implements the MyInterface interface shown above:,"(""MyInterface"", ""class"")"
This signals to the Java compiler that the MyInterfaceImpl class implements the MyInterface interface.,"(""MyInterfaceImpl"", ""The MyInterfaceImpl class implements the MyInterface interface."", ""MyInterface"")"
A class that implements an interface must implement all the methods declared in the interface.,"(""Class"", ""A class must implement all the methods declared in the interface, indicating a dependency relationship."", ""Method"")"
The class does not need to implement (declare) the variables of an interface.,"(""Class"", ""The class is related to the interface as it does not need to implement the variables declared by the interface."", ""Interface"")"
Once a Java class implements an Java interface you can use an instance of that class as an instance of that interface.,"(""Java Class"", ""A Java class can implement a Java interface, allowing an instance of the class to be used as an instance of the interface."", ""Java Interface"")"
Java allows this because the class MyInterfaceImpl implements the MyInterface interface.,"(""MyInterfaceImpl"", ""MyInterfaceImpl implements the MyInterface interface"", ""MyInterface"")"
You can then reference instances of the MyInterfaceImpl class as instances of the MyInterface interface.,"(""MyInterfaceImpl"", ""MyInterfaceImpl is an implementation of the MyInterface interface, indicating a class-to-class relationship."", ""MyInterface"")"
"You must always create an instance of some class that implements the interface, and reference that instance as an instance of the interface.","(""Class"", ""A class implements the interface, indicating a relationship between the two."", ""Interface"")"
In that case the class must implement all the methods declared in all the interfaces implemented.,"(""Class"", ""A class must implement all the methods declared in the interfaces it implements."", ""Method"")"
"If the interfaces are not located in the same packages as the implementing class, you will also need to import the interfaces.","(""interfaces"", ""Interfaces are typically organized within packages."", ""packages""); (""class"", ""A class can implement interfaces."", ""interfaces""); (""class"", ""A class can be part of a package."", ""packages"")"
Java interfaces are imported using the import instruction just like Java classes.,"(""Java"", ""Java is a package that contains Java classes."", ""Java classes""); (""import"", ""The import method is used to import Java classes."", ""Java classes"")"
Here are the two Java interfaces implemented by the class above:,"(""Java"", ""The Java package contains the interfaces."", ""interfaces""); (""class"", ""The class implements the interfaces."", ""interfaces"")"
"If a Java class implements multiple Java interfaces, there is a risk that some of these interfaces may contain methods with the same signature (name + parameters).","(""Java Class"", ""A Java class can implement multiple Java interfaces."", ""Java Interfaces""); (""Java Interfaces"", ""Java interfaces may contain methods."", ""Methods""); (""Methods"", ""Methods can be part of Java interfaces."", ""Java Interfaces"")"
"Since a Java class can only implement at method with a given signature once, this could potentially lead to some problems.","(""Java"", ""A Java class can implement a method, indicating a relationship between the class and the method."", ""method"")"
"Especially if those constants are to be used by the classes implementing the interface, e.g.","(""Classes"", ""Classes implement the interface, indicating a relationship between them."", ""Interface"")"
It is up to the classes implementing the interface to specify an implementation.,"(""CLASSES"", ""The classes are responsible for implementing the interface."", ""INTERFACE"")"
"If the API just adds the method to the desired interface, all classes that implements the interface must implement that new method.","(""method"", ""The method is added to the interface, indicating a direct relationship."", ""interface""); (""classes"", ""Classes implement the interface, showing a dependency relationship."", ""interface""); (""classes"", ""Classes must implement the new method, indicating a requirement relationship."", ""method"")"
That is fine if all implementing classes are located within the API.,"(""CLASS"", ""The CLASS is an implementing class located within the API."", ""API"")"
"But if some implementing classes are located in client code of the API (the code that uses the API), then that code breaks.","(""class"", ""The class is implemented in the client code, which uses the API."", ""client code"")"
Look at this interface and imagine that it is part of e.g.,NULL
"If the developer of the API wants to add one more method to the ResourceLoader interface, then the FileLoader class will be broken when that project upgrades to the new version of the API.","(""ResourceLoader"", ""FileLoader class will be affected by changes in the ResourceLoader interface"", ""FileLoader"")"
"A class can override the implementation of a default method simply by implementing that method explicitly, as is done normally when implementing a Java interface.","(""Class"", ""A class can override the implementation of a default method by implementing it explicitly."", ""Method""); (""Class"", ""A class implements a Java interface, which may contain default methods."", ""Java Interface"")"
Any implementation in a class takes precedence over interface default method implementations.,"(""Class"", ""A class implementation takes precedence over interface default method implementations, indicating a hierarchical relationship where the class can override the default methods."", ""Interface Default Method Implementations"")"
Calling a static method in an interface looks and works just like calling a static method in a class.,"(""STATIC METHOD"", ""A static method can be called within an interface, indicating a relationship between the method and the interface."", ""INTERFACE""); (""STATIC METHOD"", ""A static method can also be called within a class, indicating a relationship between the method and the class."", ""CLASS"")"
Here is an example of calling the static print() method from the above MyInterface interface:,"(""PRINT"", ""The PRINT method is called from the MYINTERFACE class."", ""MYINTERFACE"")"
"It is possible for a Java interface to inherit from another Java interface, just like classes can inherit from other classes.","(""Java Interface"", ""Java Interface can inherit from another Java Interface, similar to how Classes can inherit from other Classes."", ""Classes"")"
"That then means, that if a class implements MySubInterface, that class has to implement all methods defined in both MySubInterface and MySuperInterface.","(""MySubInterface"", ""MySubInterface requires the implementation of certain methods."", ""methods""); (""MySuperInterface"", ""MySuperInterface requires the implementation of certain methods."", ""methods""); (""MySubInterface"", ""A class implementing MySubInterface must also implement methods from MySuperInterface."", ""MySuperInterface"")"
A class implementing an interface which inherits from multiple interfaces must implement all methods from the interface and its superinterfaces.,"(""Class"", ""A class implements an interface."", ""Interface""); (""Class"", ""A class must implement all methods from the interface."", ""Method""); (""Interface"", ""An interface inherits from multiple superinterfaces."", ""Superinterfaces"")"
"While it is normally possible for a class to implement multiple interfaces even if the interfaces contain methods with the same signature, this is not possible if one or more of these methods are default methods.","(""Class"", ""A class can implement multiple interfaces, which may contain methods with the same signature."", ""Method""); (""Method"", ""Methods can be part of a package, and default methods are mentioned in the context of interfaces."", ""Package"")"
"In other words, if two interfaces contain the same method signature (name + parameters) and one of the interfaces declare this method as a default method, a class cannot automatically implement both interfaces.","(""METHOD"", ""A class implements methods, which are defined by interfaces."", ""CLASS"")"
In both of the above situations the Java compiler requires that the class implementing the interface(s) explicitly implements the method which causes the problem.,"(""Java Compiler"", ""The Java Compiler requires that the class implementing the interface explicitly implements the method."", ""Interface""); (""Interface"", ""The interface requires the implementation of the method."", ""Method"")"
That way there is no doubt about which implementation the class will have.,"(""Class"", ""The class is related to the implementation as it specifies which implementation it will have."", ""Implementation"")"
The implementation in the class takes precedence over any default implementations.,"(""Class"", ""The class may contain methods that have implementations."", ""Method""); (""Class"", ""The class is typically part of a package."", ""Package"")"
"Basically, polymorphism means that an instance of an class (an object) can be used as if it were of different types.","(""Instance"", ""An instance is an example of a class, and polymorphism allows it to be used as if it were of different types."", ""Polymorphism"")"
"The classes above are all parts of a model representing different types of vehicles and drivers, with fields and methods.","(""Model"", ""The Model class represents different types of vehicles."", ""Vehicle""); (""Model"", ""The Model class represents different types of drivers."", ""Driver""); (""Vehicle"", ""The Vehicle class contains fields."", ""Field""); (""Vehicle"", ""The Vehicle class contains methods."", ""Method""); (""Driver"", ""The Driver class contains fields."", ""Field""); (""Driver"", ""The Driver class contains methods."", ""Method"")"
That is the responsibility of these classes - to model these entities from real life.,"(""Classes"", ""The text suggests that classes are responsible for modeling entities from real life."", ""Entities"")"
"Please forget for a while, that implementing this functionality as methods directly on the objects may lead to a messy class hierarchy.","(""METHODS"", ""Methods are typically implemented within a class, indicating a direct relationship between the two."", ""CLASS"")"
"Where in the above diagram would you put these three methods, so they are accessible on all classes?","(""method"", ""Methods are typically part of a class, and the text suggests placing methods so they are accessible on all classes."", ""class"")"
"One way to solve this problem would be to create a common superclass for the Vehicle and Driver class, which has the storage and serialization methods.","(""Vehicle"", ""Both Vehicle and Driver are classes that could share a common superclass."", ""Driver""); (""storage"", ""Both storage and serialization are methods that could be part of the common superclass."", ""serialization"")"
"The class hierarchy would no longer model vehicles and drivers, but also be tied to the storage and serialization mechanisms used in your application.","(""Class"", ""The class hierarchy is tied to the storage mechanisms used in the application."", ""Storage""); (""Class"", ""The class hierarchy is tied to the serialization mechanisms used in the application."", ""Serialization"")"
"A better solution would be to create some interfaces with the storage and serialization methods on, and let the classes implement these interfaces.","(""storage"", ""The storage method is likely implemented by the classes."", ""classes""); (""serialization"", ""The serialization method is likely implemented by the classes."", ""classes"")"
"When each class implements these two interfaces and their methods, you can access the methods of these interfaces by casting the objects to instances of the interface types.","(""Class"", ""A class implements methods, indicating a relationship where methods are part of the class's functionality."", ""Method"")"
"You don't need to know exactly what class a given object is of, as long as you know what interface it implements.","(""Class"", ""A class implements an interface, indicating a relationship between the two."", ""Interface"")"
"As you can probably imagine by now, interfaces provide a cleaner way of implementing cross cutting functionality in classes than inheritance.","(""INTERFACES"", ""INTERFACES provide a cleaner way of implementing cross cutting FUNCTIONALITY in classes."", ""FUNCTIONALITY"")"
A generic Java interface is an interface which can be typed - meaning it can be specialized to work with a specific type (e.g.,NULL
This interface represents an interface which contains a single method called produce() which can produce a single object.,"(""Produce"", ""The text explicitly mentions that 'produce()' is a method."", ""Method"")"
"Since the return value of produce() is Object, it can return any Java object.","(""Produce"", ""The method Produce returns an Object, indicating a relationship where Produce is a method that outputs an Object."", ""Object""); (""Object"", ""Object is a class that is part of the Java package, indicating a relationship where Object belongs to Java."", ""Java"")"
The implementation of the produce() method returns a new Car object every time it is called.,"(""Produce"", ""The produce() method returns a new Car object, indicating that the method is responsible for creating instances of the Car class."", ""Car"")"
"Notice how the object returned from the carProducer.produce() method call has to be cast to a Car instance, because the produce() method return type is Object.","(""CarProducer"", ""The Produce method is called on the CarProducer class."", ""Produce""); (""Produce"", ""The Produce method returns an object that needs to be cast to a Car instance."", ""Car"")"
"Now when I implement the MyProducer interface in the CarProducer class, I have to include the generic type declaration too, like this:","(""CarProducer"", ""CarProducer implements the MyProducer interface, indicating a relationship where CarProducer is a subclass or implementation of MyProducer."", ""MyProducer"")"
"As you can see, since the generic type for the CarProducer instance is set to Car, it is no longer necessary to cast the object returned from the produce() method, since the original method declaration in the MyProducer interface states, that this method returns the same type as is specified in the generic type when used.","(""CarProducer"", ""CarProducer is a class that produces instances of the Car class."", ""Car""); (""produce"", ""The produce method is declared in the MyProducer interface."", ""MyProducer""); (""produce"", ""The produce method returns an instance of the Car class."", ""Car"")"
But - now it is actually possible to specify another generic type for a CarProducer instance than the type it actually returns from it's produce() method implementation.,"(""CarProducer"", ""The produce method is implemented by the CarProducer class."", ""produce"")"
"If you scroll up, you can see that the CarProducer.produce() implementation returns a Car object no matter what generic type you specify for it when you create it.","(""CarProducer"", ""The method 'produce' is implemented in the 'CarProducer' class."", ""produce""); (""produce"", ""The 'produce' method returns a 'Car' object."", ""Car"")"
"Instead, you can lock down the generic type of the MyProducer interface already when you implement it, in the CarProducer class.","(""CarProducer"", ""CarProducer class implements the MyProducer interface"", ""MyProducer"")"
"As you can see, it is still not necessary to cast the object returned by produce(), as the CarProducer implementation declares that to be a Car instance.","(""produce"", ""The method 'produce' returns an object that is a Car instance."", ""Car""); (""CarProducer"", ""The CarProducer class is responsible for producing instances of the Car class."", ""Car"")"
A Java lambda expression is thus a function which can be created without belonging to any class.,"(""Java"", ""A lambda expression is a feature of the Java programming language."", ""Lambda Expression"")"
Imagine you have a class called StateOwner which can register state event listeners.,"(""StateOwner"", ""StateOwner can register state event listeners, indicating a relationship where StateOwner is likely responsible for managing or interacting with these listeners."", ""state event listeners"")"
The lambda expression is matched against the parameter type of the addStateListener() method's parameter.,"(""AddStateListener"", ""The lambda expression is matched against the parameter type of the addStateListener() method's parameter."", ""lambda expression"")"
"For instance, the interface type of the parameter can be inferred from the method declaration of the addStateListener() method (the single method on the StateChangeListener interface).","(""AddStateListener"", ""The AddStateListener method is related to the StateChangeListener class because it is a method that operates on the StateChangeListener interface."", ""StateChangeListener"")"
"In the example above, the compiler can infer their type from the onStateChange() method declaration.","(""compiler"", ""The compiler can infer the type from the onStateChange() method declaration, indicating a relationship between the compiler and the method."", ""onStateChange"")"
"Thus, the type of the parameters oldState and newState are inferred from the method declaration of the onStateChange() method.","(""oldState"", ""The parameter oldState is part of the method declaration of the onStateChange method."", ""onStateChange""); (""newState"", ""The parameter newState is part of the method declaration of the onStateChange method."", ""onStateChange"")"
"In this case, these parameters have to match the parameters of the onStateChange() method of the StateChangeListener interface:","(""onStateChange"", ""The onStateChange method is part of the StateChangeListener interface, indicating a relationship where the method is implemented or used within the class."", ""StateChangeListener"")"
Here is an example class that creates a lambda which references a static variable from inside the lambda body:,"(""Class"", ""The class creates a lambda, indicating a relationship where the class is responsible for the lambda's creation."", ""Lambda"")"
The class primarily serves to show you that a lambda can access static variables.,"(""Class"", ""The class is used to demonstrate that a lambda can access static variables."", ""Lambda"")"
"Since all the lambda body does is forward the string parameter to the System.out.println() method, we can replace the above lambda declaration with a method reference.","(""System.out.println"", ""The text suggests replacing a lambda declaration with a method reference, specifically referring to the System.out.println method."", ""method reference"")"
Whatever class or object that owns the referenced method comes before the double colons.,"(""Whatever"", ""The class 'Whatever' is described as owning the 'method'."", ""method"")"
"Since the parameters of the Finder.find() and MyClass.doFind() methods match, it is possible to create a lambda expression that implements Finder.find() and references the MyClass.doFind() method.","(""Finder.find()"", ""The method Finder.find() is a method of the class Finder."", ""Finder""); (""MyClass.doFind()"", ""The method MyClass.doFind() is a method of the class MyClass."", ""MyClass""); (""Finder.find()"", ""The methods Finder.find() and MyClass.doFind() are related because their parameters match, allowing for a lambda expression to implement Finder.find() and reference MyClass.doFind()."", ""MyClass.doFind()"")"
Here is an example of a Java lambda expression that calls String.indexOf() to search:,"(""String"", ""The method indexOf is a member of the class String, as it is called using String.indexOf()."", ""indexOf"")"
The convertToInt() method has the same signature as the deserialize() method of the Deserializer deserialize() method.,"(""ConvertToInt"", ""Both are methods mentioned in the text."", ""Deserialize""); (""Deserialize"", ""The Deserialize method is part of the Deserializer class."", ""Deserializer"")"
"Because of that, we can create an instance of StringConverter and reference its convertToInt() method from a Java lambda expression, like this:","(""StringConverter"", ""The convertToInt method is a member of the StringConverter class."", ""convertToInt""); (""convertToInt"", ""The convertToInt method can be referenced from a Java lambda expression."", ""Java"")"
Finally it is possible to reference a constructor of a class.,"(""CONSTRUCTOR"", ""A constructor is a special method used to initialize objects of a class."", ""CLASS"")"
"You do that by writing the class name followed by ::new, like this:","(""Class"", ""The class is related to the method as it is used to instantiate a new object using the ::new syntax."", ""Method"")"
The create() method of this interface matches the signature of one of the constructors in the String class.,"(""CREATE"", ""The CREATE method is related to the STRING class because it matches the signature of one of the constructors in the STRING class."", ""STRING"")"
"In Java, all instructions (code) have to be located inside a Java class.","(""Java"", ""The term 'Java' is used to refer to both a class and a package in the context of the programming language."", ""Java"")"
A class is a way of grouping data and instructions that belong together.,"(""Class"", ""class"")"
"Declaring a simple class without any variables, methods or any other instructions, looks like this in Java code:","(""Class"", ""A class can contain methods as part of its structure."", ""Method""); (""Class"", ""A class can be part of a package in Java."", ""Package"")"
This Java code needs to be located in a file with the same file name as the class and ending with the file suffix .java.,"(""Java"", ""The Java class needs to be located in a file with the same name as the class."", ""file"")"
"Once the file is located in a file matching its class name and ending with .java, you can compile it with the Java compiler from the Java SDK, or from inside your Java IDE (which is much easier).","(""Java SDK"", ""Both Java SDK and Java IDE are tools used for Java development, with the SDK providing the necessary libraries and the IDE offering a user-friendly interface for coding."", ""Java IDE"")"
It is recommended that you locate your class in a Java package.,"(""Class"", ""A class is typically located within a Java package to organize code and manage namespaces."", ""Java Package"")"
"If you locate a Java class inside a Java package, you have to specify the package name at the top of the Java file.","(""Java Class"", ""A Java class is located inside a Java package, indicating a containment relationship."", ""Java Package"")"
Here is how the class from earlier looks with a package declaration added:,"(""Class"", ""The class is part of the package, as indicated by the package declaration."", ""Package"")"
Note: The file MyClass.java must now be located in the directory myjavacode and contain the package declaration package myjavacode; .,"(""MyClass"", ""MyClass is part of the myjavacode package as indicated by the package declaration."", ""myjavacode"")"
A Java program starts by executing the main method of some class.,"(""Main"", ""The main method is executed within a class in a Java program."", ""Class"")"
"You can choose the name of the class to execute, but not the name of the method.","(""Class"", ""A class contains methods, and the text refers to executing a class and a method, indicating a relationship between them."", ""Method"")"
Here is how the main method declaration looks when located inside the Java class declaration from earlier:,"(""Main Method"", ""The Main Method is declared inside the Java Class."", ""Java Class"")"
Just remember that a main() method declaration needs these three keywords.,"(""MAIN"", ""The text specifies that 'main' is a type of method, as indicated by the phrase 'main() method declaration'."", ""METHOD"")"
"In the main() method example earlier I called the String array parameter args, and in the second example I called it stringArray.","(""MAIN"", ""The MAIN method uses STRING as a parameter type."", ""STRING""); (""MAIN"", ""The MAIN method uses ARGS as a parameter name."", ""ARGS""); (""MAIN"", ""The MAIN method uses STRINGARRAY as a parameter name in the second example."", ""STRINGARRAY"")"
"You call the java command that comes with the JRE, and tells it what Java class to execute, and what arguments to pass to the main() method.","(""Java"", ""The Java class is executed by calling the main() method."", ""Main""); (""JRE"", ""The java command comes with the JRE package, which is used to execute the Java class."", ""Java"")"
The second and third arguments (-cp classes) tells the JVM in what directory the compiled Java classes are located (cp means class path).,"(""JVM"", ""The JVM uses the class path to locate compiled Java classes."", ""Class"")"
In this case the compiled Java classes are located in a directory named classes.,"(""Java"", ""The Java class files are located in the directory named classes."", ""classes"")"
The fourth argument is the name of the Java class the JVM is to execute.,"(""Java"", ""The Java class is executed by the JVM."", ""JVM"")"
"Notice how the class name also contains the name of the package the class is located in (the ""fully qualified class name"").","(""Class"", ""The class is located within the package, indicating a containment or organizational relationship."", ""Package"")"
You can pass arguments from the command line to the main() method.,"(""MAIN"", ""The text specifies that 'main()' is a method."", ""METHOD"")"
"When the JVM executes the main() method of the myjavacode.MyClass, the String array passed as parameter to the main() method will contain two Strings: ""Hello"" and ""World"".","(""Main"", ""The main() method is executed within the context of the Myjavacode.Myclass class."", ""Myjavacode.Myclass""); (""Main"", ""The main() method takes a String array as a parameter."", ""String"")"
The main() method can access the arguments from the command line like this:,"(""Main"", ""The main() method can access the arguments from the command line."", ""Arguments"")"
"If only a single Java class in your Java program contains a main() method, then the class containing the main() method is often referred to as the main class.","(""Java"", ""The main() method is typically found within a Java class."", ""main()""); (""main()"", ""The main class is defined by the presence of the main() method."", ""main"")"
You can have as many classes as you want in your project with a main() method in.,"(""Classes"", ""The main() method is typically a part of a class, as it serves as the entry point for the program execution within a class."", ""Main()"")"
You can still call the other main() methods from inside the main() method the Java Virtual Machine executes (you haven't seen how yet) and you can also start up multiple virtual machines which each execute a single main() method.,"(""MAIN"", ""The Java Virtual Machine executes the main() method."", ""JAVA VIRTUAL MACHINE"")"
Therefore Java also contains the Java Math class which contains methods for performing more advanced math calculations in Java.,"(""Java Math"", ""The Java Math class contains methods for performing advanced math calculations."", ""methods""); (""Java Math"", ""The Java Math class is part of the Java package."", ""Java"")"
This Java math tutorial will take a closer look at both Java's math operators as well as the Java Math class.,"(""Java Math"", ""The Java Math class is part of the Java programming language."", ""Java"")"
"The result of this division would be 12.5 , but since the two numbers are integers, the .5 fraction is cut off.",NULL
"Even though the result variable is now a floating point type (double), the final result is still just 12 instead of 12.5 .",NULL
Now the result variable would end up with the value 12.5.,"(""Result"", ""The result variable is assigned the value 12.5."", ""Value"")"
"The first System.out.println() statement correctly prints the value 0.0 , which is the start value of the the resultDbl3 variable.","(""System"", ""The println method is a part of the System class, used for outputting text to the console."", ""println"")"
"Adding the value 0.01 to 0 a total of 100 times should result in the value 1.0, right?","(""Value"", ""The 'Value' is being added a total of 100 times, indicating a relationship between the two entities."", ""Total"")"
The Java Math class provides more advanced mathematical calculations than what the basic Java math operators provide.,"(""Java Math"", ""The Java Math class is part of the Java package, as it provides advanced mathematical calculations within the Java programming environment."", ""Java"")"
"The Math class contains methods for finding the maximum or minimum of two values, rounding values, logarithmic functions, square root, and trigonometric functions (sin, cos, tan etc.","(""Math"", ""The Math class contains the method for finding the maximum of two values."", ""maximum""); (""Math"", ""The Math class contains the method for finding the minimum of two values."", ""minimum""); (""Math"", ""The Math class contains the method for rounding values."", ""rounding""); (""Math"", ""The Math class contains methods for logarithmic functions."", ""logarithmic functions""); (""Math"", ""The Math class contains the method for finding the square root."", ""square root""); (""Math"", ""The Math class contains methods for trigonometric functions such as sin, cos, and tan."", ""trigonometric functions"")"
"The Math is located in the java.lang package, and not in the java.math package.","(""Math"", ""The Math class is located in the java.lang package."", ""java.lang""); (""Math"", ""The Math class is not located in the java.math package."", ""java.math"")"
"Thus, the fully qualified class name of the Math class is java.lang.Math .","(""Math"", ""The Math class is referred to by its fully qualified class name java.lang.Math."", ""java.lang.Math"")"
"Since many of the functions of the Math class are independent from each other, each method will be explained in its own section below.","(""Math"", ""The Math class contains various methods, each of which is explained in its own section."", ""method"")"
"The java.lang.Math contains a set of basic math functions for obtaining the absolute value, highest and lowest of two values, rounding of values, random values etc.","(""Java.Lang.Math"", ""The Absolute Value method is part of the Java.Lang.Math package."", ""Absolute Value""); (""Java.Lang.Math"", ""The Highest And Lowest Of Two Values method is part of the Java.Lang.Math package."", ""Highest And Lowest Of Two Values""); (""Java.Lang.Math"", ""The Rounding Of Values method is part of the Java.Lang.Math package."", ""Rounding Of Values""); (""Java.Lang.Math"", ""The Random Values method is part of the Java.Lang.Math package."", ""Random Values"")"
These basic math functions of the Java Math class will be covered in the following sections.,"(""Java Math"", ""The basic math functions are methods that belong to the Java Math class."", ""basic math functions"")"
The Math.abs() function returns the absolute value of the parameter passed to it.,"(""Math"", ""The abs method is a function that belongs to the Math class, as it is invoked using Math.abs()."", ""abs"")"
Which of these methods are called depends on the type of the parameter passed to the Math.abs() method.,"(""Math.abs"", ""The text refers to Math.abs as a method, indicating its role in the context."", ""method"")"
The Math.ceil() function rounds a floating point value up to the nearest integer value.,"(""Math"", ""The method 'ceil' is a function that belongs to the 'Math' class, as it is invoked using 'Math.ceil()'."", ""ceil"")"
After executing this Java code the ceil variable will contain the value 8.0 .,"(""Java"", ""package"")"
The Math.floor() function rounds a floating point value down to the nearest integer value.,"(""Math"", ""The method 'floor' is a function that belongs to the 'Math' class, as it is invoked using 'Math.floor()'."", ""floor"")"
After executing this Java code the floor variable will contain the value 7.0 .,NULL
"The Math.floorDiv() method divides one integer (int or long) by another, and rounds the result down to the nearest integer value.","(""Math"", ""The floorDiv method is a part of the Math class, as indicated by the notation Math.floorDiv()."", ""floorDiv"")"
"The floorDiv() method rounds down to the nearest negative integer, instead of the rounding up that would occur with fraction truncation.","(""floorDiv"", ""The floorDiv is a method because it is described as such in the text."", ""method"")"
This shows the difference between the / division operator and Math.floorDiv() .,"(""Math.floorDiv()"", ""Math.floorDiv() is related to the / division operator as they both perform division operations, but in different ways."", ""/"")"
The Math.min() method returns the smallest of two values passed to it as parameter.,"(""Math.min()"", ""The Math.min() method is a method that belongs to the Math class, as indicated by the naming convention."", ""Math"")"
The Math.max() method returns the largest of two values passed to it as parameter.,"(""Math.max()"", ""The Math.max() method is part of the Math class, which provides mathematical functions."", ""Math"")"
The Math.round() method rounds a float or double to the nearest integer using normal math round rules (either up or down).,"(""Math"", ""The round method is a function of the Math class."", ""round"")"
"After executing these two Java statements the roundedDown variable will contain the value 23.0 , and the roundedUp variable will contain the value 24.0.",NULL
The Math.random() method returns a random floating point number between 0 and 1.,"(""Math"", ""The random method is a part of the Math class, as it is invoked using Math.random()."", ""random"")"
"100, multiply the value returned by Math.random() with the maximum number (e.g.","(""Math"", ""The method 'random' is part of the 'Math' package, indicating a relationship where 'random' is a method provided by the 'Math' package."", ""random"")"
"If you need an integer value, use the round(), floor() or ceil() method.","(""ROUND"", ""Both are methods used to obtain integer values."", ""FLOOR""); (""ROUND"", ""Both are methods used to obtain integer values."", ""CEIL""); (""FLOOR"", ""Both are methods used to obtain integer values."", ""CEIL"")"
The Java Math class also contains a set of functions intended for exponential and logarithmic calculations.,"(""Math"", ""The Math class contains a set of functions for calculations."", ""functions"")"
The Math.exp() function returns e (Euler's number) raised to the power of the value provided as parameter.,"(""Math"", ""The exp method is a function that belongs to the Math class."", ""exp"")"
The Math.log10 method works like the Math.log() method except is uses 10 as is base for calculating the logarithm instead of e (Euler's Number).,"(""log10"", ""The log10 method is related to the log method as both are used for calculating logarithms, with log10 using base 10 and log using base e."", ""log"")"
"In other words, the Math.pow() example calculate the values of 22 and 28 which are 4 and 256.","(""Math"", ""The method 'pow' is part of the 'Math' package, as indicated by the notation 'Math.pow()'."", ""pow"")"
The Math.sqrt() method calculates the square root of the parameter given to it.,"(""Math"", ""The method 'sqrt' belongs to the class 'Math' as it is invoked using 'Math.sqrt()'."", ""sqrt"")"
"If you are looking for a trigonometric function and you cannot find it here, check the JavaDoc for the Java Math class.","(""Java Math"", ""The Java Math class is documented in the JavaDoc package."", ""JavaDoc"")"
"The Math class just might have the function you are looking for, even if I have not described it here.","(""Math"", ""The Math class is likely to contain functions, as suggested by the text."", ""function"")"
The Math.PI constant is a double with a value that is very close to the value of PI - the mathematical definition of PI.,"(""Math"", ""The PI constant is a member of the Math class, representing the mathematical constant PI."", ""PI"")"
You will often need the Math.PI field when making trigonometric calculations.,"(""Math"", ""PI is a field within the Math package, often used for trigonometric calculations."", ""PI"")"
The Math.sin() method calculates the sine value of some angle value in radians.,"(""Math"", ""The sin method is part of the Math package, which provides mathematical functions."", ""sin"")"
The Math.cos() method calculates the cosine value of some angle value in radians.,"(""Math"", ""The method 'cos' is a function of the class 'Math'."", ""cos"")"
The Math.tan() method calculates the tangens value of some angle value in radians.,"(""Math"", ""The tan method is a function of the Math class, indicating that it is a method belonging to this class."", ""tan"")"
The Math.asin() method calculates the arc sine value of a value between 1 and -1.,"(""Math"", ""The asin method is a part of the Math class, which provides mathematical functions."", ""asin"")"
The Math.acos() method calculates the arc cosine value of a value between 1 and -1.,"(""Math"", ""The acos method is a part of the Math class, as indicated by the notation Math.acos()."", ""acos"")"
The Math.atan() method calculates the arc tangens value of a value between 1 and -1.,"(""Math"", ""The atan method is a function of the Math class."", ""atan"")"
The Math.sinh() method calculates the hyperbolic sine value of a value between 1 and -1.,"(""Math"", ""The sinh method is a function of the Math class"", ""sinh"")"
The Math.cosh() method calculates the hyperbolic cosine value of a value between 1 and -1.,"(""Math"", ""The cosh method is a function of the Math class."", ""cosh"")"
The Math.tanh() method calculates the hyperbolic tangens value of a value between 1 and -1.,"(""Math"", ""The tanh method is a function of the Math class, indicating that it is a method belonging to this class."", ""tanh"")"
Java methods are similar to what is called functions or procedures in other programming languages (e.g.,"(""Java"", ""Methods are a part of the Java package, as they are used to define the behavior of classes within Java."", ""methods"")"
The example above defines a method called writeText inside a class named MyClass.,"(""WriteText"", ""The method WriteText is defined inside the class MyClass."", ""MyClass"")"
You can use any primitive data type or built-in Java class as data type for parameters.,"(""Java"", ""class"")"
"When the above Java code is executed, the writeText() method will get executed, and the parameters will contain the values ""Hello"" and ""World"".","(""writeText"", ""The text mentions the writeText() method, indicating it is a method entity."", ""method"")"
"But, instead of returning to where the method was called from, the execution is resumed inside the first catch() { } clause surrounding the method, targeted at that exception.","(""Method"", ""The execution is resumed inside the first catch() clause surrounding the method, indicating a relationship between the method and the catch clause."", ""Method"")"
"Notice how the method callSum() creates a variable called theSum, and assigns it the value returned by the add(1, 3) method call.","(""CallSum"", ""The CallSum method uses the Add method to perform an operation and assign its result to a variable."", ""Add"")"
Before Java 9 and the Java Platform Module System you would have had to package all of the Java Platform APIs with your Java application because there was no official way of reliably checking what classes your Java application used.,"(""Java Platform Module System"", ""The Java Platform Module System is related to the Java Platform APIs as it provides a way to manage and organize these APIs."", ""Java Platform APIs""); (""Java Platform APIs"", ""Java Platform APIs are used within a Java application, indicating a dependency or usage relationship."", ""Java application""); (""classes"", ""Classes are components that a Java application uses, indicating a usage relationship."", ""Java application"")"
"Since the Java Platform APIs have grown quite large over the years, your application would get a large amount of Java classes included in its distribution, many of which your application would probably not be using.","(""Java Platform APIs"", ""Java Platform APIs include a large number of Java classes as part of their distribution."", ""Java classes"")"
The unused classes makes your application distributable bigger than it needs to be.,NULL
from a missing JAR file) would not be detected until the application actually tried to use the missing class.,"(""JAR"", ""The JAR package contains the class, and if the JAR file is missing, the class cannot be used."", ""class"")"
This would happen sometime at runtime - depending on when the application tried to use the missing class.,"(""Application"", ""The application tries to use the class at runtime, indicating a dependency or usage relationship."", ""Class"")"
Having missing modules reported at application startup time is a big advantage compared to at runtime when trying to use the missing module / JAR / class.,"(""APPLICATION STARTUP TIME"", ""The application startup time is when missing modules are reported."", ""MISSING MODULE""); (""RUNTIME"", ""At runtime, the missing module is attempted to be used."", ""MISSING MODULE""); (""MISSING MODULE"", ""The missing module can be a JAR file."", ""JAR"")"
"However, you should not use underscores (_) in module names (or package names, class names, method names, variable names etc.)","(""MODULE"", ""The text mentions that underscores should not be used in both module names and package names, indicating a relationship between these two entities."", ""PACKAGE""); (""CLASS"", ""The text lists class names and method names together, suggesting a relationship between these two entities."", ""METHOD"")"
"Before Java 9 all Java classes for an application or API were nested directly inside a root class directory (which was added to the classpath), or directly inside a JAR file.","(""Java 9"", ""Java 9 is a version of the Java class."", ""Java""); (""Java"", ""Java classes are added to the classpath."", ""classpath""); (""Java"", ""Java classes can be contained within a JAR file."", ""JAR file"")"
The module root directory is used both for the source files and compiled classes of a Java module.,"(""MODULE ROOT DIRECTORY"", ""The module root directory is used for the source files of a Java module."", ""SOURCE FILES""); (""MODULE ROOT DIRECTORY"", ""The module root directory is used for the compiled classes of a Java module."", ""COMPILED CLASSES"")"
Each Java module needs a Java module descriptor named module-info.java which has to be located in the corresponding module root directory.,"(""Java module"", ""A Java module contains a Java module descriptor."", ""Java module descriptor""); (""Java module descriptor"", ""The module-info.java is the specific file name for a Java module descriptor."", ""module-info.java"")"
Notice also how the module descriptor is suffixed .java and yet it uses a hyphen in the file name (module-info.java).,"(""MODULE DESCRIPTOR"", ""The module descriptor is a part of the module-info.java file, as indicated by the text."", ""MODULE-INFO.JAVA"")"
"Hyphens are not normally allowed in Java class names, but in module descriptor file names they are required!","(""Java"", ""The module descriptor is a part of the Java package system, indicating a relationship between them."", ""module descriptor"")"
This example module descriptor declares that it requires the standard Java module named javafx.graphics.,"(""Javafx.graphics"", ""The text indicates that the module descriptor requires the Java package named javafx.graphics."", ""Javafx.graphics"")"
By split package is meant that the total content (classes) of the package is split between multiple modules.,"(""SPLIT PACKAGE"", ""The split package contains classes, indicating that classes are part of the package."", ""CLASSES""); (""SPLIT PACKAGE"", ""The split package is distributed across multiple modules, indicating a relationship between the package and the modules."", ""MODULES"")"
"Inside that directory you will find a directory with the name of the module, and inside that directory you will find the compiled classes plus a compiled version of the module-info.java module descriptor named module-info.class.","(""MODULE-INFO.JAVA"", ""MODULE-INFO.CLASS is the compiled version of the MODULE-INFO.JAVA module descriptor"", ""MODULE-INFO.CLASS"")"
"In order to run the main class of a Java module you use the java command, like this:","(""Main"", ""The Main class is part of the Java package, as it is a common structure in Java modules."", ""Java"")"
The --module argument tells what module + main class to run.,"(""MODULE"", ""The module is related to the main class as it specifies which main class to run."", ""MAIN CLASS"")"
Notice how the module name and main class name are separated by a slash (/) character.,"(""Module Name"", ""The module name and main class name are related as they are separated by a slash (/) character, indicating a hierarchical relationship."", ""Main Class Name"")"
You can still set the JAR main class when generating the module JAR file.,"(""JAR"", ""The JAR class is being set when generating the module package."", ""module"")"
Here is an example of setting the main class of a Java module JAR file:,"(""Main Class"", ""The main class is a component of the Java module."", ""Java Module""); (""Java Module"", ""The Java module is packaged into a JAR file."", ""JAR File"")"
You can now run the main class of this JAR file with a shortcut.,"(""Main"", ""The main class is typically the entry point of a JAR file, which is a package."", ""JAR"")"
Here is how you run the main class from a Java module JAR file:,"(""Main Class"", ""The Main Class is executed from the Java Module."", ""Java Module"")"
"If the Java module JAR file has a main class set (see a few sections earlier in this tutorial for how to do that), you can run the Java module main class with a little shorter command line.","(""Java Module"", ""The Java Module can have a Main Class set, indicating a relationship where the Main Class is part of or associated with the Java Module."", ""Main Class""); (""Main Class"", ""The Main Class can be run using a Command Line, indicating a method to execute the Main Class."", ""Command Line""); (""Java Module"", ""The Java Module is contained within or associated with the Java Module JAR File."", ""Java Module JAR File"")"
Here is an example of running a Java module from a JAR file with a main class set:,"(""Java"", ""Java is the programming language used to create the module."", ""module""); (""module"", ""The module is packaged into a JAR file."", ""JAR""); (""main"", ""The main method is set in the class to be executed."", ""class"")"
The --module argument specifies which module plus main class to run.,"(""MODULE"", ""The module is specified to run along with the main class."", ""MAIN CLASS"")"
"From Java 9 and forward, all Java classes must be located in a module for the Java VM to use them.","(""Java"", ""Java classes must be located in a module for the Java VM to use them"", ""Java VM"")"
"But what do you do with older Java libraries where you just have the compiled classes, or a JAR file?","(""Java"", ""Java is often packaged into JAR files for distribution."", ""JAR""); (""JAR"", ""JAR files contain compiled classes."", ""classes"")"
In Java 9 you can still use the -classpath argument to the Java VM when running an application.,"(""Java VM"", ""The Java VM is used to run an application."", ""application"")"
"On the classpath you can include all your older Java classes, just like you have done before Java 9.","(""Classpath"", ""Classpath is used to include Java classes."", ""Java"")"
All classes found on the classpath will be included in what Java calls the unnamed module.,"(""Java"", ""The unnamed module is a concept within the Java package."", ""Unnamed Module"")"
"However, the classes in the unnamed module are only readable by other classes in the unnamed module - or from automatic modules (see next section).","(""Unnamed Module"", ""The unnamed module classes are readable by classes from automatic modules."", ""Automatic Modules"")"
No named module can read the classes of the unnamed module.,"(""Named Module"", ""The named module cannot read the classes of the unnamed module, indicating a relationship between them."", ""Unnamed Module"")"
All classes in the unnamed module requires all modules found on the module path.,"(""Unnamed Module"", ""The unnamed module requires all modules found on the module path, indicating a dependency relationship."", ""Module Path"")"
"That way, all classes in the unnamed module can read all classes exported by all the Java modules found on the module path.","(""Unnamed Module"", ""The unnamed module can read all classes exported by the Java modules."", ""Java Modules""); (""Java Modules"", ""Java modules are found on the module path."", ""Module Path"")"
"While you can include the third party library on the classpath and thus include it in the unnamed module, your own named modules cannot use it, because named modules cannot read classes from the unnamed module.","(""UNNAMED MODULE"", ""Unnamed module contains classes that cannot be read by named modules."", ""CLASSES""); (""NAMED MODULES"", ""Named modules cannot read classes from the unnamed module."", ""UNNAMED MODULE"")"
"An automatic module is made from a JAR file with Java classes that are not modularized, meaning the JAR file has no module descriptor.","(""JAR file"", ""The JAR file contains Java classes, indicating a containment relationship."", ""Java classes"")"
When you place an ordinary JAR file on the module path (not the classpath) the Java VM will convert it to an automatic module at runtime.,"(""JAR File"", ""A JAR file can be placed on the module path."", ""Module Path""); (""JAR File"", ""A JAR file can be placed on the classpath."", ""Classpath""); (""JAR File"", ""A JAR file is converted to an automatic module at runtime."", ""Automatic Module""); (""Java VM"", ""The Java VM converts a JAR file to an automatic module at runtime."", ""Automatic Module"")"
"If your application contains multiple automatic modules, each automatic module can read the classes of all other automatic modules.","(""Application"", ""An application can contain multiple automatic modules."", ""Automatic Module""); (""Automatic Module"", ""Each automatic module can read the classes of other automatic modules."", ""Class"")"
This is different from explicitly named modules (real Java modules) which cannot read classes in the unnamed module.,"(""Modules"", ""Modules cannot read classes in the unnamed module"", ""Unnamed Module"")"
"An automatic module exports all its packages, so all named modules on the module path can use the classes of an automatic module.","(""Automatic Module"", ""An automatic module exports all its packages."", ""Packages""); (""Named Modules"", ""Named modules on the module path can use the classes of an automatic module."", ""Automatic Module""); (""Module Path"", ""Named modules are on the module path."", ""Named Modules"")"
"If a JAR file contains versioning in its file name, e.g.",NULL
"The service interface is typically located in a service interface Java module which only contains the service interface, plus any classes and interfaces related to the service interface.","(""Service Interface"", ""The service interface is located in a Java module."", ""Java Module""); (""Classes"", ""Classes are related to the service interface as they are contained within the same module."", ""Service Interface""); (""Interfaces"", ""Interfaces are related to the service interface as they are contained within the same module."", ""Service Interface"")"
The com folder at the root level of the JAR file contains the compiled Java classes for pre Java 9 versions.,"(""com"", ""The 'com' package contains the compiled Java classes."", ""Java"")"
Earlier versions of Java do not understand multi Java version JAR files so they use the classes found here.,"(""Java"", ""Java is related to JAR files as it is a programming language that can be used to create and manage JAR files."", ""JAR"")"
The META-INF directory contains the MANIFEST.MF file and a directory named versions.,"(""META-INF"", ""The MANIFEST.MF file is contained within the META-INF directory."", ""MANIFEST.MF""); (""META-INF"", ""The versions directory is contained within the META-INF directory."", ""versions"")"
The MANIFEST.MF file needs a special entry that marks the JAR file as a multi version JAR file.,"(""MANIFEST.MF"", ""The MANIFEST.MF file contains entries that define the properties of the JAR file."", ""JAR"")"
The versions directory which can contain the compiled classes for different versions of Java for your module.,"(""VERSIONS DIRECTORY"", ""The versions directory contains the compiled classes."", ""COMPILED CLASSES""); (""COMPILED CLASSES"", ""The compiled classes are for different versions of Java."", ""JAVA"")"
"Upgrading utility libraries first to automatic modules, and later to full modules, starting at the bottom of the dependency hierarchy should assure that your libraries can still read each other during upgrade, plus be readable by the main applications on the classpath in the unnamed module or as an automatic or named module.","(""Unnamed Module"", ""Both are types of modules that can be read by main applications on the classpath."", ""Automatic Module""); (""Unnamed Module"", ""Both are types of modules that can be read by main applications on the classpath."", ""Named Module""); (""Automatic Module"", ""Both are types of modules that can be read by main applications on the classpath."", ""Named Module"")"
In Java nested classes are classes that are defined inside another class.,"(""nested classes"", ""Nested classes are a type of classes defined within another class."", ""classes"")"
"The purpose of a nested class is to clearly group the nested class with its surrounding class, signaling that these two classes are to be used together.","(""Nested Class"", ""The nested class is grouped with its surrounding class, indicating they are intended to be used together."", ""Surrounding Class"")"
Or perhaps that the nested class is only to be used from inside its enclosing (owning) class.,"(""NESTED CLASS"", ""The nested class is intended to be used from inside its enclosing class, indicating a relationship of containment or usage."", ""ENCLOSING CLASS"")"
"Java developers often refer to nested classes as inner classes, but inner classes (non-static nested classes) are only one out of several different types of nested classes in Java.","(""Inner Classes"", ""Inner Classes are a type of Nested Classes in Java"", ""Nested Classes""); (""Java"", ""Nested Classes are a concept within the Java package"", ""Nested Classes"")"
In Java nested classes are considered members of their enclosing class.,"(""nested classes"", ""Nested classes are considered members of their enclosing class in Java."", ""enclosing class"")"
"Thus, a nested class can be declared public, package (no access modifier), protected and private (see access modifiers for more info).","(""Nested Class"", ""Nested Class can have different access levels, which are defined by Access Modifiers."", ""Access Modifiers"")"
Therefore nested classes in Java can also be inherited by subclasses as explained in my tutorial about Java inheritance.,"(""Nested Classes"", ""Nested classes can be inherited by subclasses."", ""Subclasses""); (""Java"", ""Java inheritance is a concept within the Java package."", ""Java Inheritance"")"
You can create several different types of nested classes in Java.,"(""Nested Classes"", ""Nested Classes are a feature available in the Java programming language."", ""Java"")"
All these types of nested classes will be covered in the following sections.,"(""Nested Classes"", ""The text indicates that nested classes will be covered in the following sections, suggesting a relationship between the two."", ""Sections"")"
"In order to create an instance of the Nested class you must reference it by prefixing it with the Outer class name, like this:","(""Nested"", ""The Nested class is related to the Outer class because it must be referenced by prefixing it with the Outer class name to create an instance."", ""Outer"")"
In Java a static nested class is essentially a normal class that has just been nested inside another class.,"(""Static Nested Class"", ""A static nested class is a type of class that is nested inside another class."", ""Class"")"
"Being static, a static nested class can only access instance variables of the enclosing class via a reference to an instance of the enclosing class.","(""Static Nested Class"", ""A static nested class can only access instance variables of the enclosing class via a reference to an instance of the enclosing class."", ""Enclosing Class"")"
Inner classes are associated with an instance of the enclosing class.,"(""Inner classes"", ""Inner classes are associated with an instance of the enclosing class."", ""enclosing class"")"
"Thus, you must first create an instance of the enclosing class to create an instance of an inner class.","(""Enclosing Class"", ""An instance of the enclosing class must be created first to create an instance of the inner class."", ""Inner Class"")"
Here is how you create an instance of the Inner class:,"(""Inner"", ""The text describes creating an instance of the Inner class, indicating a relationship between the action of creating and the Inner class."", ""create"")"
Notice how you put new after the reference to the outer class in order to create an instance of the inner class.,"(""Outer Class"", ""The inner class is created as an instance of the outer class, indicating a relationship where the inner class is contained within or associated with the outer class."", ""Inner Class"")"
"Non-static nested classes (inner classes) have access to the fields of the enclosing class, even if they are declared private.","(""Non-static Nested Classes"", ""Non-static nested classes are a type of inner class that have access to the fields of the enclosing class."", ""Enclosing Class""); (""Non-static Nested Classes"", ""Non-static nested classes have access to the fields of the enclosing class, even if they are private."", ""Fields"")"
Notice how the printText() method of the Inner class references the private text field of the Outer class.,"(""PRINTTEXT"", ""The printText method belongs to the Inner class."", ""INNER""); (""TEXT"", ""The text field is a private member of the Outer class."", ""OUTER"")"
"If a Java inner class declares fields or methods with the same names as field or methods in its enclosing class, the inner fields or methods are said to shadow over the outer fields or methods.","(""Inner Class"", ""An inner class is defined within an enclosing class."", ""Enclosing Class""); (""Fields"", ""Fields and methods are both members of a class."", ""Methods""); (""Inner Class"", ""An inner class can declare fields."", ""Fields""); (""Inner Class"", ""An inner class can declare methods."", ""Methods""); (""Enclosing Class"", ""An enclosing class can have fields."", ""Fields""); (""Enclosing Class"", ""An enclosing class can have methods."", ""Methods"")"
In the above example both the Outer and Inner class contains a field named text.,"(""Outer"", ""The Outer class contains the Inner class, indicating a nesting relationship."", ""Inner""); (""Outer"", ""The Outer class contains a field named text."", ""text""); (""Inner"", ""The Inner class contains a field named text."", ""text"")"
When the Inner class refers to text it refers to its own field.,"(""Inner"", ""The Inner class has a field named text, indicating a relationship where the class contains or refers to this field."", ""text"")"
"Java makes it possible though, for the Inner class to refer to the text field of the Outer class.","(""Inner"", ""The Inner class is related to the Outer class because it can refer to the text field of the Outer class."", ""Outer"")"
To do so it has to prefix the text field reference with Outer.this.,"(""Outer"", ""The method 'this' is being referenced with the class 'Outer' to access the text field."", ""this"")"
Now the Inner.printText() method will print both the Inner.text and Outer.text fields.,"(""Inner.printText()"", ""The method Inner.printText() accesses the Inner.text field."", ""Inner.text""); (""Inner.printText()"", ""The method Inner.printText() accesses the Outer.text field."", ""Outer.text"")"
Local classes in Java are like inner classes (non-static nested classes) that are defined inside a method or scope block ({ ... }) inside a method.,"(""Local Classes"", ""Local classes are defined inside a method or scope block."", ""Method""); (""Inner Classes"", ""Local classes are a type of inner classes."", ""Local Classes""); (""Java"", ""Local classes are a feature in the Java programming language."", ""Local Classes"")"
Local classes can only be accessed from inside the method or scope block in which they are defined.,"(""Local Classes"", ""Local classes can only be accessed from inside the method in which they are defined, indicating a relationship between the two."", ""Method"")"
Local classes can access members (fields and methods) of its enclosing class just like regular inner classes.,"(""Local Classes"", ""Local classes can access members of its enclosing class."", ""Members""); (""Local Classes"", ""Local classes can access fields of its enclosing class."", ""Fields""); (""Local Classes"", ""Local classes can access methods of its enclosing class."", ""Methods""); (""Local Classes"", ""Local classes are defined within an enclosing class."", ""Enclosing Class"")"
"Local classes can also access local variables inside the same method or scope block, provided these variables are declared final.","(""Local Classes"", ""Local classes can access local variables inside the same method or scope block."", ""Method"")"
From Java 8 local classes can also access local variables and parameters of the method the local class is declared in.,"(""local classes"", ""Local classes can access local variables and parameters of the method they are declared in."", ""method"")"
In that case the local class only has access to the static parts of the enclosing class.,"(""Local Class"", ""The local class has access to the static parts of the enclosing class."", ""Static Parts""); (""Local Class"", ""The local class is defined within the enclosing class."", ""Enclosing Class"")"
"Local classes cannot contain all kinds of static declarations (constants are allowed - variables declared static final), because local classes are non-static in nature - even if declared inside a static method.","(""Local Classes"", ""Local classes cannot contain static declarations because they are non-static in nature."", ""Static Declarations""); (""Constants"", ""Constants are a type of static declaration that is allowed in local classes."", ""Static Declarations""); (""Variables"", ""Variables can be declared as static final, which is allowed in local classes."", ""Static Final""); (""Local Classes"", ""Local classes can be declared inside a static method."", ""Static Method"")"
The same shadowing rules apply for local classes as for inner classes.,"(""Local Classes"", ""The text mentions that the same shadowing rules apply to both local classes and inner classes, indicating a relationship between the two."", ""Inner Classes"")"
Anonymous classes in Java are nested classes without a class name.,"(""Anonymous Classes"", ""Anonymous classes are a type of nested classes in Java."", ""Nested Classes"")"
"They are typically declared as either subclasses of an existing class, or as implementations of some interface.","(""Class"", ""The text suggests that a class can implement an interface, indicating a relationship between the two entities."", ""Interface"")"
Here is an example that declares an anonymous subclass of a superclass called SuperClass:,"(""SuperClass"", ""The anonymous subclass is a subclass of the SuperClass."", ""anonymous subclass"")"
Running this Java code would result in Anonymous class doIt() being printed to System.out.,"(""Anonymous class"", ""The method doIt() is part of the Anonymous class."", ""doIt""); (""doIt"", ""The method doIt() is being printed to the System.out package."", ""System.out"")"
The anonymous class subclasses (extends) SuperClass and overrides the doIt() method.,"(""SuperClass"", ""The doIt method is overridden in the subclass of SuperClass."", ""doIt"")"
A Java anonymous class can also implement an interface instead of extending a class.,"(""anonymous class"", ""An anonymous class can implement an interface."", ""interface""); (""anonymous class"", ""An anonymous class is a type of class in Java."", ""Java"")"
"As you can see, an anonymous class implementing an interface is pretty similar to an anonymous class extending another class.","(""Anonymous Class"", ""An anonymous class can implement an interface, indicating a relationship where the class provides specific implementations for the interface's methods."", ""Interface"")"
"You can declare fields and methods inside an anonymous class, but you cannot declare a constructor.","(""fields"", ""Fields can be declared inside an anonymous class."", ""anonymous class""); (""methods"", ""Methods can be declared inside an anonymous class."", ""anonymous class"")"
"You can declare a static initializer for the anonymous class instead, though.","(""Static Initializer"", ""A static initializer can be declared for an anonymous class."", ""Anonymous Class"")"
The same shadowing rules apply to anonymous classes as to inner classes.,"(""Anonymous Classes"", ""Anonymous classes follow the same shadowing rules as inner classes, indicating a relationship in terms of behavior or rules."", ""Inner Classes"")"
The benefits of Java nested classes are that you can group classes together that belong together.,"(""Java"", ""Java is the programming language that supports the concept of nested classes."", ""nested classes"")"
"You could do so already by putting them in the same package, but putting one class inside another makes an even stronger grouping.","(""PACKAGE"", ""The CLASS can be grouped within the PACKAGE to organize code."", ""CLASS""); (""CLASS"", ""One CLASS can be nested inside another CLASS to create a stronger grouping."", ""CLASS"")"
A nested class is typically only used by or with its enclosing class.,"(""Nested Class"", ""A nested class is typically used by or with its enclosing class, indicating a relationship of usage or association."", ""Enclosing Class"")"
"Sometimes a nested class is only visible to the enclosing class, is only used internally, and is thus never visible outside the enclosing class.","(""Nested Class"", ""A nested class is only visible to the enclosing class, indicating a relationship of containment or encapsulation."", ""Enclosing Class"")"
"Other times the nested class is visible outside its enclosing class, but can only be used in conjunction with the enclosing class.","(""NESTED CLASS"", ""The nested class is visible outside its enclosing class, indicating a relationship where the nested class is part of or associated with the enclosing class."", ""ENCLOSING CLASS""); (""NESTED CLASS"", ""The nested class can only be used in conjunction with the enclosing class, showing a dependency or usage relationship."", ""ENCLOSING CLASS"")"
"Inside the Cache class you might declare a CacheEntry class which can contain information about a specific cache entry (cached value, time inserted, number of times accessed etc.).","(""Cache"", ""The CacheEntry class is declared inside the Cache class, indicating a containment or composition relationship."", ""CacheEntry"")"
"Users of the Cache class may never see the CacheEntry class, if they have no need to obtain information about the CacheEntry itself, but only the cached value.","(""Cache"", ""The Cache class uses the CacheEntry class to store cached values, indicating a relationship where CacheEntry is a component or part of Cache."", ""CacheEntry"")"
"However, the Cache class may choose to make the CacheEntry class visible to the outside world, so they can access more than just the cached value (for instance information about when the value was last refreshed etc.","(""Cache"", ""The Cache class may choose to make the CacheEntry class visible to the outside world, indicating a relationship where Cache contains or manages CacheEntry."", ""CacheEntry"")"
The first Cache class hides its CacheEntry nested class while the second Cache class exposes it.,"(""Cache"", ""CacheEntry is a nested class within the Cache class"", ""CacheEntry""); (""Cache"", ""CacheEntry is a nested class within the Cache class"", ""CacheEntry"")"
You instantiate an object of a certain class using the new keyword.,"(""Class"", ""The 'new keyword' is used to instantiate an object of a certain class."", ""new keyword"")"
"This example declares a variable of the MyClass class (custom data type), and then creates a new MyClass instance and assigns a reference to this instance to myClassInstance variable.","(""MyClass"", ""The text describes creating a new instance of the MyClass class."", ""MyClass"")"
"Inside the parantheses () after the for keyword, are three statements separated by semicolon (;).",NULL
"Here is a simple example of a class that has two methods, where one method calls the other:","(""Method"", ""One method calls the other, indicating a relationship between the two methods."", ""Method"")"
"Notice how printBoth() calls the print() method two times, each time with a different of the parameters passed to the printBoth() method.","(""printBoth"", ""The printBoth method calls the print method."", ""print""); (""printBoth"", ""The printBoth method is referenced in the text as being called."", ""printBoth"")"
The print() method is thus a reusable block of code that can be called from anywhere.,"(""Print"", ""The text describes 'print()' as a method, indicating that it is a reusable block of code."", ""Method"")"
"When the print() method is finished executing, the program jumps back to after the line that called the print() method.","(""Print"", ""The text describes the execution of the print() method, indicating its role in the program flow."", ""Print"")"
"Java packages are a mechanism to group Java classes that are related to each other, into the same ""group"" (package).","(""Java Packages"", ""Java packages group Java classes that are related to each other."", ""Java Classes"")"
"When a Java project grows bigger, for instance an app or API, it is useful to split the code into multiple Java classes, and the classes into multiple Java packages.","(""Java"", ""Java""|""package""|""Java classes are organized into Java packages to manage and structure the code effectively."", ""class"")"
"When you divide classes into multiple Java packages, it becomes easier to figure out where a certain class you are looking for is.","(""Classes"", ""Classes are organized into Java packages to improve structure and accessibility."", ""Java Packages"")"
All Java source and class files of classes belonging to the same package are located in the same directory.,"(""Java"", ""Java is a programming language, and source files are typically written in Java."", ""source""); (""source"", ""Source files contain the code that defines classes."", ""class""); (""class"", ""Classes are organized into packages."", ""package""); (""package"", ""Packages are stored in directories."", ""directory"")"
"Its a tree of packages, subpackages and classes inside these classes.","(""PACKAGES"", ""SUBPACKAGES are a part of PACKAGES"", ""SUBPACKAGES""); (""SUBPACKAGES"", ""CLASSES are inside SUBPACKAGES"", ""CLASSES""); (""PACKAGES"", ""CLASSES are inside PACKAGES"", ""CLASSES"")"
"I have expanded two of the sublevel Java packages, so you can see the classes inside.","(""Java"", ""The classes are contained within the Java package."", ""classes"")"
"The classes are illustrated using a little blue circle with a C inside, in the screenshot above.","(""Class"", ""class"")"
"Similarly, the fully qualified name of a Java class includes its package name.","(""Java"", ""The Java class is associated with a package name as part of its fully qualified name."", ""package"")"
"For instance, the full qualified name of the ""Page"" class, is:","(""Page"", ""class"")"
"In order to put add Java classes to packages, you must do two things:","(""Java"", ""Java is a class that can be added to packages."", ""packages"")"
Put the class files into the directory matching the package you want to add it to.,"(""Class"", ""The class files are placed into a directory that matches the package, indicating a relationship where the class is part of or associated with the package."", ""Package"")"
"When you have put your Java source file into the correct directory (matching the package the class should belong to), you have to declare inside that class file, that it belongs to that Java package.","(""class"", ""The class is declared to belong to the Java package."", ""Java"")"
"Not like Java classes, where the first letter is usually a capital letter.","(""Java"", ""Java is mentioned as an example of a class."", ""class"")"
"If the classes A and B are located in the same Java package, there is no problem with the code above.","(""A"", ""Class A is located in the Java package."", ""Java""); (""B"", ""Class B is located in the Java package."", ""Java"")"
"If you need to use a lot of classes from a certain Java package, importing them one at a time results in a lot of import statements.","(""Java"", ""The import method is used to bring classes from the Java package into use."", ""import"")"
It is possible to import all classes of a package using the * character instead of a class name.,"(""Class"", ""Classes are components that can be imported from a package."", ""Package"")"
It is possible to use a class from another package without importing it with an import statement.,"(""Class"", ""A class can be used from another package, indicating a relationship between the class and the package."", ""Package""); (""Import Statement"", ""An import statement is used to import a package, showing a relationship between the import statement and the package."", ""Package""); (""Import Statement"", ""An import statement can be used to import a class, indicating a relationship between the import statement and the class."", ""Class"")"
You can write the fully qualified class name instead of just the name of the class itself.,"(""Class"", ""The text refers to the fully qualified class name and the name of the class itself, indicating a relationship between the two concepts."", ""Class"")"
"The fully qualified class name consists of the full package path down to the subclass containing the class, and also including the class name itself.","(""Class"", ""A class is contained within a package, as indicated by the fully qualified class name including the package path."", ""Package"")"
The fully qualified class name is also what you would write in an import statement.,"(""Class Name"", ""The class name is used in an import statement to include the class in a package."", ""Import Statement"")"
"You could use this fully qualified class name to reference the TimeUtil class inside another class, like this:","(""TimeUtil"", ""The TimeUtil class is mentioned as being used inside another class, indicating a relationship between the two classes."", ""class"")"
"You might be wondering how you decide on what Java packages to create, and how to divide your classes into these packages.","(""Java"", ""The text discusses dividing classes into Java packages, indicating a relationship between Java packages and classes."", ""classes""); (""Java"", ""The text refers to creating Java packages, indicating a relationship between Java and packages."", ""packages""); (""packages"", ""The text mentions dividing classes into packages, showing a relationship between packages and classes."", ""classes"")"
"The first method is to divide classes after what ""layer"" of the application they belong to.","(""Method"", ""The method is related to classes as it is a way to divide them based on their application layer."", ""Classes"")"
All classes involved in communication with the database would then be located in the database package.,"(""Database"", ""The text indicates that all classes involved in communication with the database are located in the database package, suggesting a relationship between the database and the package."", ""Package"")"
The second method is to divide your classes based on what part of the application functionality they belong to.,"(""Classes"", ""Classes are divided based on the part of the application functionality they belong to."", ""Application Functionality""); (""Method"", ""The method is used to divide the classes."", ""Classes"")"
"All classes involved in one way or another in the pension calculations would go into that package (or subpackages, if the number of classes in pension grow large).","(""Classes"", ""Classes are grouped into a package for pension calculations."", ""Package"")"
"The ""divide by application functionality"" method of dividing classes into Java packages tends to work better than ""divide by layer"", as your application grows in number of classes.","(""Divide By Application Functionality"", ""The method 'Divide By Application Functionality' involves dividing classes."", ""Classes""); (""Divide By Application Functionality"", ""The method 'Divide By Application Functionality' involves organizing classes into Java packages."", ""Java Packages""); (""Divide By Layer"", ""The method 'Divide By Layer' is another approach to organizing classes."", ""Classes""); (""Divide By Layer"", ""The method 'Divide By Layer' contrasts with organizing classes into Java packages."", ""Java Packages"")"
"Instead of having a fixed number of layer packages which keep growing in number of classes, you get a growing number of application functionality packages with a smaller number of classes inside.","(""Layer Packages"", ""Layer Packages contain a number of Classes."", ""Classes""); (""Application Functionality Packages"", ""Application Functionality Packages contain a smaller number of Classes."", ""Classes"")"
"These packages contain classes for all kinds of purposes that programmers often need, like reading and writing files from the local hard disk, sending and receiving data over networks and the internet, connecting to databases, and many, many other things.","(""Packages"", ""Packages contain classes for various purposes"", ""Classes"")"
"When you compile all the source code in the source, the compiler produces one .class file for each .java file.","(""CLASS"", ""The compiler produces a .class file for each .java file, indicating a relationship between the two."", ""JAVA"")"
It is the .class files that the Java Virtual Machine can execute.,"(""Java Virtual Machine"", ""The Java Virtual Machine executes .class files."", ""class files"")"
Therefore it is normal to separate the .java files from the .class files.,"(""Java Files"", ""Java Files are source code files that are compiled into Class Files."", ""Class Files"")"
This is normally done by instructing the compiler to write the .class files into a separate directory.,"(""compiler"", ""The compiler writes the .class files into a separate directory, indicating a relationship between the compiler and the directory."", ""directory"")"
"This directory is often called classes, but again, it is not a requirement, and it depends on what build tool or IDE etc.",NULL
The *.java means the compiler should compile all files in the given directory.,"(""Java"", ""The Java class is compiled by the compiler."", ""Compiler"")"
"Once the compiler has done its job, the classes directory will contain the compiled .class files.","(""COMPILER"", ""The compiler is responsible for creating the compiled .class files, which are stored in the classes directory."", ""CLASSES"")"
The package structure (directory structure) from the source directory will be preserved under the class directory.,"(""Package"", ""The package structure is preserved under the class directory, indicating a relationship between the package and class."", ""Class"")"
You can run any one of these .class files which have a main() method in it.,"(""class"", ""The main method is typically found within a class and is used to execute the class."", ""main"")"
"You can run the .class from inside your Java IDE, or from the command line.","(""Java IDE"", ""Both are environments where the .class can be executed"", ""command line"")"
The -cp classes flag tells the Java Virtual Machine that all your classes are located under the directory called classes.,"(""Java Virtual Machine"", ""The Java Virtual Machine uses the classes located in the directory called classes."", ""classes"")"
The name of the class to run is the last argument in the above command - the myfirstapp.MyJavaApp part.,"(""MyJavaApp"", ""MyJavaApp is a class within the myfirstapp package"", ""myfirstapp"")"
The JVM needs to know the fully qualified class name (all packages plus class name) to determine where the corresponding .class file is located.,"(""class"", ""The class is part of a package, as indicated by the need for a fully qualified class name, which includes both the package and class name."", ""package"")"
When you run the the class your command line will look similar to this (including the output from the Java app):,"(""Class"", ""class"")"
A Java Record is a special kind of Java class which has a concise syntax for defining immutable data-only classes.,"(""Java Record"", ""Java Record is a type of class within the Java package"", ""Java"")"
A Java Record consist of one or more data fields which corresponds to member variables in a regular Java class.,"(""Java Record"", ""A Java Record consists of data fields, which are similar to member variables in a class."", ""data fields""); (""Java Record"", ""Java Record is a type of class in the Java programming language."", ""Java"")"
"The Java compiler auto generates getter methods, toString(), hashcode() and equals() methods for these data fields, so you don't have to write that boilerplate code yourself.","(""Java"", ""The toString method is a part of the Java package."", ""toString""); (""Java"", ""The hashcode method is a part of the Java package."", ""hashcode""); (""Java"", ""The equals method is a part of the Java package."", ""equals"")"
"The Java compiler then generates the corresponding fields, getter methods and a hashCode() and equals() method.","(""hashCode"", ""Both are methods typically overridden together to ensure consistent behavior in Java objects."", ""equals""); (""Java"", ""hashCode is a method commonly used in Java programming."", ""hashCode""); (""Java"", ""equals is a method commonly used in Java programming."", ""equals"")"
You use a Java Record just like you use other Java classes - by creating instances of the record type using the Java new keyword.,"(""Java Record"", ""Java Record is a class that is part of the Java package."", ""Java""); (""Java Record"", ""The 'new' method is used to create instances of the Java Record class."", ""new"")"
"Notice how the Java compiler has generated a brand() method, a licensePlate() method and a toString() method for us.","(""Brand"", ""Both are methods generated by the Java compiler."", ""LicensePlate""); (""Brand"", ""Both are methods generated by the Java compiler."", ""ToString""); (""LicensePlate"", ""Both are methods generated by the Java compiler."", ""ToString"")"
"A Record type definition is final, meaning you cannot create subclasses (subrecords) of a Java Record type.","(""Record"", ""The Record class is a type definition in the Java package."", ""Java"")"
You can add instance methods to a Java Record definition - just like you can with a regular Java class.,"(""Java Record"", ""Instance methods can be added to a Java Record, indicating a relationship between the class and the methods."", ""instance methods""); (""Java class"", ""Instance methods can be added to a Java class, indicating a relationship between the class and the methods."", ""instance methods""); (""Java Record"", ""Java Record is compared to a regular Java class, indicating a relationship between the two classes."", ""Java class"")"
Here is an example of the Vehicle Java Record definition from earlier sections with an instance method named brandAsLowerCase() added:,"(""Vehicle"", ""The method brandAsLowerCase is an instance method of the class Vehicle"", ""brandAsLowerCase"")"
Notice how the brandAsLowerCase() method calls the auto-generated brand() method internally.,"(""brandAsLowerCase"", ""The brandAsLowerCase method calls the brand method internally, indicating a direct functional relationship."", ""brand"")"
"That means, that even classes from different projects compiled separately, but which are used in the same application may share constant String objects.","(""String"", ""String objects are used in the same application"", ""application"")"
"As you can see, a new StringBuilder is created, passing along the first String to its constructor, and the second String to its append() method, before finally calling the toString() method.","(""StringBuilder"", ""The append method is called on the StringBuilder class."", ""append""); (""StringBuilder"", ""The toString method is called on the StringBuilder class."", ""toString""); (""StringBuilder"", ""The StringBuilder class is initialized with a String."", ""String"")"
This code actually creates two objects: A StringBuilder instance and a new String instance returned from the toString() method.,"(""toString"", ""The toString method returns a new instance of the String class."", ""String""); (""StringBuilder"", ""The toString method is called on the StringBuilder instance."", ""toString"")"
"The bigger the result String grows, the longer it takes to copy the characters from it into a new StringBuilder, and again copy the characters from the StringBuilder into the temporary String created by the toString() method.","(""String"", ""StringBuilder is used to build or modify a String object."", ""StringBuilder""); (""StringBuilder"", ""The toString method is used to convert the contents of a StringBuilder into a String."", ""toString"")"
You can obtain the length of a String using the length() method.,"(""String"", ""The length method is used to obtain the length of a String."", ""length"")"
You do so using the substring() method of the String class.,"(""Substring"", ""The Substring method is a function that belongs to the String class."", ""String"")"
The last character in the string has has the index String.length() - 1.,"(""String"", ""The method 'length' is associated with the class 'String' as it is used to determine the length of a string instance."", ""length"")"
You can search for substrings in Strings using the indexOf() method.,"(""indexOf"", ""The indexOf method is used to search for substrings within the Strings class."", ""Strings"")"
The indexOf() method returns the index of where the first character in the first matching substring is found.,"(""IndexOf"", ""The term 'indexOf()' is identified as a method in the text."", ""Method"")"
"If the substring is not found within the string, the indexOf() method returns -1;","(""indexOf"", ""The indexOf is a method that is used to find the position of a substring within a string."", ""method"")"
There is a version of the indexOf() method that takes an index from which the search is to start.,"(""INDEXOF"", ""The text describes 'indexOf()' as a method."", ""METHOD"")"
The Java String class also has a lastIndexOf() method which finds the last occurrence of a substring.,"(""String"", ""The lastIndexOf method is a function of the String class, used to find the last occurrence of a substring."", ""lastIndexOf"")"
"The Java String matches() method takes a regular expression as parameter, and returns true if the regular expression matches the string, and false if not.","(""String"", ""The matches method is a function of the String class."", ""matches""); (""Java"", ""The String class is part of the Java package."", ""String"")"
The equals() method tests if two Strings are exactly equal to each other.,"(""EQUALS"", ""The equals() method is used to test if two String objects are exactly equal to each other."", ""STRING"")"
The String class also has a method called equalsIgnoreCase() which compares two strings but ignores the case of the characters.,"(""String"", ""The equalsIgnoreCase method is a function of the String class."", ""equalsIgnoreCase"")"
The startsWith() and endsWith() methods check if the String starts with a certain substring.,"(""STARTSWITH"", ""The STARTSWITH method is used to check if a STRING starts with a certain substring."", ""STRING""); (""ENDSWITH"", ""The ENDSWITH method is used to check if a STRING ends with a certain substring."", ""STRING"")"
"The compareTo() method compares the String to another String and returns an int telling whether this String is smaller, equal to or larger than the other String.","(""COMPARETO"", ""The compareTo() method is used to compare one String object to another."", ""STRING"")"
"If the String is earlier in sorting order than the other String, compareTo() returns a negative number.","(""compareTo"", ""The method compareTo is used to compare String objects."", ""String"")"
"If the String is equal in sorting order to the other String, compareTo() returns 0.","(""String"", ""The method compareTo is used to compare String objects."", ""compareTo"")"
"If the String is after the other String in sorting order, the compareTo() metod returns a positive number.","(""String"", ""The compareTo method is used to compare String objects."", ""compareTo"")"
You should be aware that the compareTo() method may not work correctly for Strings in different languages than English.,"(""compareTo"", ""The compareTo method is used to compare Strings."", ""Strings"")"
The Java String class contains a method called trim() which can trim a string object.,"(""String"", ""The trim method is a function within the String class."", ""trim"")"
The trim() method can be very useful to trim text typed into input fields by a user.,"(""Trim"", ""The term 'trim()' is identified as a method in the text."", ""Method"")"
The trim() method is an easy way to remove such extra white space characters.,"(""Trim"", ""The text describes 'trim()' as a method."", ""Method"")"
The Java String class contains a method named replace() which can replace characters in a String.,"(""String"", ""The replace method is a function within the String class that allows for replacing characters in a String."", ""replace"")"
The replace() method does not actually replace characters in the existing String.,"(""Replace"", ""The replace() method is used to perform operations on the String class."", ""String"")"
"The replace() method will replace all character matching the character passed as first parameter to the method, with the second character passed as parameter to the replace() method.","(""Replace"", ""The replace() method is mentioned multiple times in the text, indicating its function of replacing characters based on parameters."", ""Replace"")"
The Java String replaceFirst() method returns a new String with the first match of the regular expression passed as first parameter with the string value of the second parameter.,"(""String"", ""The replaceFirst method is a member of the String class."", ""replaceFirst""); (""Java"", ""The String class is part of the Java package."", ""String"")"
The Java String replaceAll() method returns a new String with all matches of the regular expression passed as first parameter with the string value of the second parameter.,"(""String"", ""The replaceAll method is a function that operates on the String class."", ""replaceAll""); (""Java"", ""The String class is part of the Java package."", ""String"")"
The Java String class contains a split() method which can be used to split a String into an array of String objects.,"(""Java String"", ""The split() method is a part of the Java String class."", ""split()""); (""split()"", ""The split() method is used to split a String into an array of String objects."", ""String"")"
The parameter passed to the split() method is actually a Java regular expression.,"(""split"", ""The split method uses a Java regular expression as its parameter."", ""Java"")"
The String split() method exists in a version that takes a limit as a second parameter.,"(""String"", ""The split method is a function that belongs to the String class."", ""split"")"
Here is a Java String split() example using the limit parameter:,"(""String"", ""The method 'split' is a function that operates on the 'String' class."", ""split"")"
The Java String class contains a set of overloaded static methods named valueOf() which can be used to convert a number to a String.,"(""Java String"", ""The method valueOf is part of the Java String class as it is mentioned to be contained within it."", ""valueOf"")"
"Since all Java classes extends (inherits from) the Object class, all objects have a toString() method.","(""Object"", ""The toString method is a method that belongs to the Object class, as all Java classes inherit from Object."", ""toString"")"
"Note: For the toString() method to return a sane String representation of the given object, the class of the object must have overridden the toString() method.","(""toString"", ""The toString method is used to return a String representation of an object."", ""String""); (""class"", ""The class must override the toString method to provide a custom String representation."", ""toString"")"
"If not, the default toString() method (inherited from the Object class) will get called.","(""TOSTRING"", ""The toString method is inherited from the Object class."", ""OBJECT""); (""TOSTRING"", ""The toString method is part of the Object class."", ""CLASS"")"
The default toString() method does not provide that much useful information.,"(""toString"", ""method"")"
It is possible to get a character at a certain index in a String using the charAt() method.,"(""String"", ""The charAt() method is used to get a character at a certain index in a String."", ""charAt"")"
You can also get the byte representation of the String method using the getBytes() method.,"(""getBytes"", ""The getBytes method is used to obtain the byte representation of the String method."", ""String"")"
The first getBytes() call return a byte representation of the String using the default character set encoding on the machine.,"(""getBytes"", ""The method getBytes() is used to obtain a byte representation of the String class."", ""String"")"
The second getBytes() call return a UTF-8 byte representation of the String.,"(""getBytes"", ""The method getBytes() returns a byte representation in the UTF-8 format."", ""UTF-8""); (""getBytes"", ""The method getBytes() operates on a String to return its byte representation."", ""String"")"
You can convert Strings to uppercase and lowercase using the methods toUpperCase() and toLowerCase().,"(""Strings"", ""The method toUpperCase() is used to convert Strings to uppercase."", ""toUpperCase""); (""Strings"", ""The method toLowerCase() is used to convert Strings to lowercase."", ""toLowerCase"")"
From Java 13 the Java String class got a new method named formatted() which can be used to return a formatted version of the String formatted() is called on.,"(""Java String"", ""The method 'formatted' is a new method of the 'Java String' class introduced in Java 13."", ""formatted"")"
"The formatted() method is only a preview feature that was added together with Java Text Blocks in Java 13, so we do not yet know if it will stay in.","(""Formatted"", ""The formatted() method is associated with Java Text Blocks as it was introduced together with this feature."", ""Java Text Blocks""); (""Java Text Blocks"", ""Java Text Blocks is a feature within the Java programming language."", ""Java"")"
Here is an example of using the Java String formatted() method:,"(""String"", ""The formatted() method is a member of the String class."", ""formatted()""); (""Java"", ""The String class is part of the Java package."", ""String"")"
The parameter values passed to formatted() will be inserted into the returned String at the %s location of the input String.,"(""formatted"", ""The method 'formatted' is used to insert parameter values into a 'String'."", ""String"")"
"From Java 13 the Java String class got a new method named stripIndent() which can be used to strip out indentation, similarly to how indentation is stripped out of Java Text Blocks.","(""Java String"", ""The stripIndent method is a new method of the Java String class introduced in Java 13."", ""stripIndent""); (""stripIndent"", ""The stripIndent method is used similarly to how indentation is stripped out of Java Text Blocks."", ""Java Text Blocks"")"
"The stripIndent() method is a preview feature, so we don't know if it will stay in Java yet.","(""StripIndent"", ""The StripIndent method is mentioned as a feature that may or may not remain in the Java package."", ""Java"")"
Here is an example of using the new Java String stripIndent() method:,"(""String"", ""The stripIndent method is a member of the String class."", ""stripIndent""); (""Java"", ""The String class is part of the Java package."", ""String"")"
From Java 13 the Java String class got a new method called translateEscapes() which can translate escape codes that exist inside a String in the same way the Java compiler translates them.,"(""Java String"", ""The method translateEscapes is a new method added to the Java String class."", ""translateEscapes""); (""Java"", ""The Java String class is part of the Java package."", ""Java String"")"
"For now, the translateEscapes() is a preview feature, so it is not yet sure that it will stay in Java.","(""TranslateEscapes"", ""The method TranslateEscapes is mentioned as a feature related to the Java package."", ""Java"")"
Here is an example of using the Java String translateEscapes() method:,"(""String"", ""The translateEscapes() method is a function that belongs to the String class in Java."", ""translateEscapes"")"
When calling the translateEscapes() method the \n part of the text will now be interpreted as a line break escape code.,"(""translateEscapes"", ""The translateEscapes method interprets the \n part of the text as a line break escape code."", ""line break escape code"")"
The String class has several other useful methods than the ones described in this tutorial.,"(""String"", ""The String class contains several useful methods."", ""methods"")"
"The result of this is, that execution just ""falls through"" to the operation of the next case statement ( and the next etc.)",NULL
All Java code must reside inside a file with the extension .java .,"(""Java"", ""Java code is typically organized within files, indicating a relationship between the Java class and the file class."", ""file"")"
"Below is an example .java file that contains all of the above elements, so you can see the basic syntax of a .java file:",NULL
The .java file should be located in a directory structure that matches the package name.,"(""Java File"", ""The Java file is located in a directory structure."", ""Directory Structure""); (""Directory Structure"", ""The directory structure matches the package name."", ""Package Name"")"
"Please note, that the code example does not actually use the Java HashMap class anywhere.","(""HashMap"", ""HashMap is a class that is part of the Java programming language."", ""Java"")"
Of course you should not import classes you do not use in a real project.,"(""import"", ""The method 'import' is used to include the 'class' in a project."", ""class"")"
"In Java a type is either a class, an abstract class an interface, an enum or an annotation.","(""Java"", ""Java is a programming language that defines the concept of a class."", ""Class""); (""Java"", ""Java supports the use of abstract classes."", ""Abstract Class""); (""Java"", ""Java allows the definition of interfaces."", ""Interface""); (""Java"", ""Java includes enums as a type."", ""Enum""); (""Java"", ""Java supports annotations as a type."", ""Annotation"")"
A type (class / interface / enum) can have more than one field.,"(""Class"", ""class"")"
The fifth line (or block of lines) is a class initializer block.,"(""Class Initializer Block"", ""The text explicitly mentions 'class initializer block' as a class."", ""Class Initializer Block"")"
Inside this block you can put initialization code that is to be executed a instance of the class is created.,"(""CLASS"", ""An instance is created from a class, indicating a direct relationship between the two."", ""INSTANCE"")"
"Then they are executed already when the class is loaded, and only once because the class is only loaded in the Java Virtual Machine once.","(""Class"", ""The class is loaded into the Java Virtual Machine."", ""Java Virtual Machine"")"
"Constructors are similar to class initializers, except they can take parameters.","(""Constructors"", ""Constructors are used to initialize instances of a class."", ""Class"")"
"A class can have more than one constructor, although this example just shows one.","(""Class"", ""A class can have more than one constructor, indicating a relationship where constructors are methods within a class."", ""Constructor"")"
When you create an instance of a class (an object) the object can have methods you can execute.,"(""Class"", ""An instance of a class is referred to as an object."", ""Object""); (""Object"", ""Objects can have methods that can be executed."", ""Methods"")"
"A static method belongs to the class, not objects of the class.","(""Static Method"", ""A static method is a function that belongs to the class rather than instances of the class."", ""Class""); (""Class"", ""The class is the owner of the static method, indicating a relationship where the method is part of the class."", ""Static Method"")"
That means that you can call a static method without having an object of the class the static method belongs to.,"(""Static Method"", ""A static method belongs to a class and can be called without an instance of the class."", ""Class"")"
"In the example above, if case.equals(""uppercase"") evaluates to true then the ternary operator expression as a whole returns the String value JOHN.","(""String"", ""JOHN is a value of type String"", ""JOHN"")"
"If case.equals(""uppercase"") evaluates to false then the ternary operator expression as a whole returns the String value john.","(""case"", ""The method 'equals' is used to compare the 'case' class."", ""equals""); (""equals"", ""The 'equals' method is used to compare a 'String' value."", ""String"")"
"That means, that the String variable name will end up having the value JOHN or john depending on whether the expression case.equals(""uppercase"") evaluates to true or false.","(""case.equals"", ""The method case.equals is used to determine the value assigned to the variable name based on the condition it evaluates."", ""name""); (""String"", ""The variable name is of the class type String."", ""name"")"
"As you can see, both of these code examples avoid calling object.getValue() if the object reference is null, but the first code example is a bit shorter and more elegant.","(""object"", ""The method getValue is called on the object."", ""getValue"")"
You can achieve the same functionality as the Java Math max() function using a Java ternary operator.,"(""Math"", ""The max() method is a function within the Math class."", ""max()""); (""Java"", ""The Math class is part of the Java package."", ""Math"")"
Here is an example of achieving the Math.max() functionality using a Java ternary operator:,"(""Math.max()"", ""Math.max() is a method that can be used within the Java package."", ""Java"")"
The Java ternary operator can also be used to achieve the same effect as the Java Math min() function.,"(""Math"", ""The Min method is part of the Math package."", ""Min""); (""Java"", ""The Ternary Operator is a feature used in the Java package."", ""Ternary Operator""); (""Java"", ""The Math package is part of the Java package."", ""Math"")"
Here is an example of achieving the Math.min() functionality using a Java ternary operator:,"(""Math.min()"", ""Math.min() is a method that can be used within the Java package."", ""Java"")"
The Java ternary operator can also be used to achieve the same effect as the Java Math abs() function.,"(""Math"", ""The abs method is a function within the Math class."", ""abs""); (""Java"", ""The Math class is part of the Java package."", ""Math""); (""Java"", ""The abs method is used in the context of Java."", ""abs"")"
Here is an example of achieving the Math.abs() functionality using a Java ternary operator:,"(""Math.abs()"", ""The Math.abs() method is a part of the Java package, which provides mathematical functions."", ""Java"")"
"If the input String is not equal to the empty String, the second ternary operator returns the value of Integer.parseInt(input) .","(""Integer"", ""The method parseInt is a method of the Integer class."", ""parseInt""); (""String"", ""The method parseInt is used to parse a String into an Integer."", ""parseInt"")"
"This can be any kind of information ranging from texts, codes (e.g.","(""This"", ""The class 'This' is related to the class 'information' as it is describing the type of information being referred to."", ""information"")"
"In the code example below, the main() method contains the declaration of a single integer variable named number.","(""MAIN"", ""The main() method contains the declaration of the integer variable named number."", ""NUMBER"")"
"Non-static fields are also called instance variables, because they belong to instances (objects) of a class.","(""INSTANCE VARIABLES"", ""Instance variables are related to a class because they belong to instances (objects) of a class."", ""CLASS"")"
A static field is a variable that belongs to a class.,"(""Class"", ""A static field is a variable that belongs to a class."", ""Static Field"")"
The second line assigns the floating point value 199.99 to the floating point variable named myFloat.,NULL
"In this example, only the first System.out.println() statement is executed inside the while loop.","(""System"", ""The 'out' method is a member of the 'System' class, used for output operations."", ""out""); (""out"", ""The 'println' method is called on the 'out' method to print text to the console."", ""println"")"
The second System.out.println() statement is not executed until after the while loop is finished.,"(""System.out.println()"", ""The System.out.println() method is executed after the while loop is finished, indicating a sequential relationship."", ""while loop"")"
"This is typically done via a command line interface (CLI), like e.g.",NULL
On the command line you tell the JVM what Java class (bytecode) to execute.,"(""JVM"", ""The JVM executes the Java class bytecode."", ""Java"")"
Only the full Java SDK contains the Java compiler which turns your .java source files into byte code .class files.,"(""Java SDK"", ""The Java SDK contains the Java compiler."", ""Java compiler""); (""Java compiler"", ""The Java compiler turns .java source files into byte code."", "".java source files""); (""Java compiler"", ""The Java compiler generates byte code .class files from .java source files."", ""byte code .class files"")"
"Additionally, some Java servers may need some of the tools in the JDK to e.g.",NULL
"The Java Code Conventions are a set of conventions for how to format your Java code, and how to name classes, variables, files etc.","(""Java Code Conventions"", ""The Java Code Conventions are related to the Java package as they provide guidelines on how to format Java code."", ""Java"")"
JavaFX was inspired by Flex (Flash) and Silverlight for .NET (Microsoft).,"(""JavaFX"", ""JavaFX was inspired by Flex."", ""Flex""); (""JavaFX"", ""JavaFX was inspired by Silverlight."", ""Silverlight""); (""Silverlight"", ""Silverlight is associated with .NET."", "".NET""); ("".NET"", "".NET is a Microsoft product."", ""Microsoft""); (""Silverlight"", ""Silverlight is a Microsoft product."", ""Microsoft"")"
In this tutorial I will show you how to make your first Java app with IntelliJ IDEA community edition (free) version 2019.3.3.,"(""Java"", ""Java is a programming language that can be used to develop applications in the IntelliJ IDEA package."", ""IntelliJ IDEA"")"
"How you do that depends on what operating system you are running (Windows, Mac, Linux etc.)",NULL
"A Java package is just a directory inside which you can put one or more Java files (class, interface, annotation, enum etc.","(""Java"", ""Java files are contained within a Java package."", ""Java files"")"
Now you must create a new class inside your newly created package.,"(""Class"", ""The class is created inside the package, indicating a containment or organizational relationship."", ""Package"")"
"In the dialog that opens, type in a name for your new Java class.","(""Java"", ""The text refers to creating a new Java class, indicating a relationship between Java and class."", ""class"")"
"It is custom to have class names start with an uppercase character followed by lowercase characters, and a new uppercase character for each new word in the class name.","(""Class"", ""class"")"
"When you have typed in a name for your new Java class, click the ""OK"" button.","(""Java"", ""The text refers to a Java class, indicating that Java is the programming language used for the class."", ""class"")"
"Once you have created the new class, it will be empty.","(""Class"", ""class"")"
The part inside the /* ... */ are comments and are not part of the executed Java code.,"(""Java"", ""Comments are a part of Java code, indicating a relationship between the two."", ""comments"")"
Before you can run your Java app you need to insert a main() method into the class.,"(""Main"", ""The main() method is typically inserted into a class to serve as the entry point for a Java application."", ""Class"")"
Now your are ready to run your newly created Java class.,"(""Java"", ""The text refers to a 'Java class', indicating that 'Java' is the programming language used to create the 'class'."", ""class"")"
"You do so by right clicking the class source code in the editor, and choose ""Run..."", like this:","(""Class"", ""class"")"
"When you click the ""Run..."" option, IntelliJ IDEA will first compile your Java class, and then run it.","(""IntelliJ IDEA"", ""IntelliJ IDEA is an IDE that supports running and compiling Java code."", ""Java""); (""IntelliJ IDEA"", ""IntelliJ IDEA compiles and runs the Java class."", ""class"")"
"After you have executed the Java class main method, you will see an output at the bottom of the IntelliJ IDEA window similar to this:","(""Java"", ""The main method is typically a part of a Java class, serving as the entry point for execution."", ""main""); (""IntelliJ IDEA"", ""IntelliJ IDEA is an integrated development environment (IDE) that can be used to execute and manage Java classes."", ""Java"")"
"Don't worry if you don't yet understand what a main() method is, or classes, or packages.","(""MAIN()"", ""The main() method is typically a part of a class in programming."", ""CLASSES""); (""CLASSES"", ""Classes are often organized within packages in programming."", ""PACKAGES"")"
The most common way of using the Java Logging API is to create a Logger in each class that needs to log.,"(""Java Logging API"", ""Logger is a component of the Java Logging API used for logging purposes."", ""Logger""); (""Logger"", ""Logger is created in each class that needs to log."", ""class""); (""Java Logging API"", ""Classes use the Java Logging API to perform logging operations."", ""class"")"
"This instance is typically made static and final, meaning all instances of that class use the same Logger instance.","(""Logger"", ""The text refers to a Logger instance being used by all instances of a class, indicating a relationship between the Logger class and its instances."", ""Logger"")"
"As you can see from this example, it is common practice to use the class name including package name as name for the Logger.","(""Logger"", ""The text suggests using the class name, including the package name, as the name for the Logger, indicating a relationship between the class and the Logger."", ""Logger"")"
The name of the Logger to create is passed as string parameter to the Logger.getLogger() method.,"(""Logger.getLogger"", ""The Logger.getLogger method is used to create or retrieve a Logger instance."", ""Logger"")"
"For instance, ordinary debug trace logging calls to entering() and exiting() would be called at the beginning and end of a method call.","(""ENTERING"", ""Both are methods used for debug trace logging at the beginning and end of a method call."", ""EXITING"")"
The initialization of the configuration is taken care of by the java.util.logging.LogManager class.,"(""LogManager"", ""The LogManager class is part of the java.util.logging package."", ""java.util.logging"")"
You can use a Java class to configure the Java Logging API.,"(""Java"", ""The Java class is used to configure the Java Logging API, indicating a relationship between the class and the package."", ""Logging"")"
You do so by specifying the name of the class in the JVM parameter java.util.logging.config.class.,"(""Java.Util.Logging.Config.Class"", ""The class Java.Util.Logging.Config.Class is specified as a parameter in the JVM package."", ""JVM"")"
It is the constructor of that class that should load the configuration and apply it to the Logger's in the hierarchy.,"(""Logger"", ""The constructor is responsible for loading the configuration and applying it to the Logger class."", ""constructor"")"
"If no configuration class is specified, you can instead specify a configuration file (but no configuration class can be specified then!","(""configuration class"", ""The text indicates that if no configuration class is specified, a configuration file can be used instead, suggesting a mutually exclusive relationship between the two."", ""configuration file"")"
"The Java Logging API has a default logging configuration file located at ""lib/logging.properties"", inside the JRE directory.","(""Java Logging API"", ""The Java Logging API's default logging configuration file is located inside the JRE directory."", ""JRE"")"
You do so by setting the JVM property java.util.logging.config.file to point to this file.,"(""JVM"", ""The JVM uses the java.util.logging.config.file property to configure logging settings."", ""java.util.logging.config.file"")"
You should double check the JavaDoc over time to see if any of this changes (e.g.,NULL
"If the isLoggable() method returns false, the LogRecord is not logged.","(""isLoggable"", ""The isLoggable method determines whether the LogRecord should be logged based on its return value."", ""LogRecord"")"
The Handler's in the Java Logging API use a java.util.logging.Formatter to format the LogRecord's before writing it to an external system.,"(""Handler"", ""Handler is a component within the Java Logging API."", ""Java Logging API""); (""Handler"", ""Handler uses java.util.logging.Formatter to format LogRecord."", ""java.util.logging.Formatter""); (""java.util.logging.Formatter"", ""java.util.logging.Formatter formats LogRecord."", ""LogRecord"")"
"The various Handler's in the Java Logging API use either of these two Formatter's by default, but you can also set your own custom Formatter subclass on a Handler.","(""Handler"", ""Handlers use Formatters by default in the Java Logging API."", ""Formatter""); (""Handler"", ""You can set a custom Formatter subclass on a Handler."", ""Formatter subclass""); (""Java Logging API"", ""Handlers are part of the Java Logging API."", ""Handler""); (""Java Logging API"", ""Formatters are used within the Java Logging API."", ""Formatter"")"
You can create your own Formatter by subclassing the java.util.logging.Formatter class.,"(""Formatter"", ""The Formatter class is part of the java.util.logging package."", ""java.util.logging"")"
The subclass must override the abstract format() method in the Formatter class.,"(""FORMAT"", ""The FORMAT method is part of the FORMATTER class, as it needs to be overridden in a subclass."", ""FORMATTER""); (""SUBCLASS"", ""The SUBCLASS must override the FORMAT method, indicating a relationship between them."", ""FORMAT""); (""SUBCLASS"", ""The SUBCLASS is related to the FORMATTER class as it must override a method from it."", ""FORMATTER"")"
The String returned by the format() is what is forwarded to the external system by the Handler.,"(""format"", ""The method format() returns a String."", ""String""); (""String"", ""The String returned by format() is forwarded to the external system by the Handler."", ""Handler"")"
The Formatter class also contains the convenience method formatMessage() which can be used to format the message using the ResourceBundle of the LogRecord.,"(""Formatter"", ""The formatMessage method is a convenience method contained within the Formatter class."", ""formatMessage""); (""formatMessage"", ""The formatMessage method uses the ResourceBundle to format the message."", ""ResourceBundle""); (""formatMessage"", ""The formatMessage method formats the message using the LogRecord."", ""LogRecord"")"
By default the ConsoleHandler uses a SimpleFormatter to format the messages before writing them to System.err.,"(""ConsoleHandler"", ""ConsoleHandler uses SimpleFormatter to format messages."", ""SimpleFormatter""); (""ConsoleHandler"", ""ConsoleHandler writes formatted messages to System.err."", ""System.err"")"
"If no %g code has been specified and the file count of the FileHandler is greater than 1, then the generation number (file sequence number) will be appended to the end of the file name, after a dot (.)","(""FileHandler"", ""The file count is a method related to the FileHandler class, likely used to determine the number of files handled by the FileHandler."", ""file count""); (""FileHandler"", ""The generation number is related to the FileHandler class as it is used to append a sequence number to the file name managed by FileHandler."", ""generation number"")"
You must set one using the method setOutputStream() before using the handler.,"(""setOutputStream"", ""The method setOutputStream is used in conjunction with the handler, indicating a relationship where the method is applied to the handler."", ""handler"")"
You can also call the push() method to force the LogRecord's in the buffer to be flushed to the target Handler.,"(""Push"", ""The Push method is used to force the LogRecord to be flushed."", ""LogRecord""); (""LogRecord"", ""The LogRecord is flushed to the target Handler."", ""Handler"")"
This class contains a constant for each of the above log levels.,"(""Class"", ""The class contains a constant for each of the log levels, indicating a relationship between the class and the log levels."", ""Log Levels"")"
When you create a Logger you pass a name to the Logger.getLogger() method.,"(""Logger"", ""The Logger.getLogger() method is used to create or retrieve a Logger instance."", ""Logger.getLogger()"")"
(Note: These levels are different from the log levels of the messages logged.).,NULL
If you call getParent() on that Logger you will get the Logger with the name com.,"(""getParent"", ""The method getParent is called on the Logger class."", ""Logger""); (""Logger"", ""The Logger class is associated with the package com."", ""com"")"
"... and call getParent() method, you will get the Logger with the name """".","(""getParent"", ""The getParent method is used to retrieve the Logger class instance."", ""Logger"")"
"The third message is being logged three times: Once by the 1.2 Logger, once by the 1 Logger, and once by the root Logger.","(""Logger"", ""The text mentions the Logger class being used multiple times, indicating its role in logging messages."", ""Logger"")"
"Notice though, that the message propagated up the hierarchy from the Logger named 1.2 is still logged by the middle Logger, and still forwarded up to the root Logger.","(""1.2"", ""The Logger named 1.2 propagates its message up to the middle Logger."", ""middle Logger""); (""middle Logger"", ""The middle Logger forwards the message up to the root Logger."", ""root Logger"")"
"Another peculiar result of the above code is, that the INFO message passed to the bottom Logger (named 1.2) is also ignored, and not propagated.","(""Logger"", ""The Logger class is responsible for handling and propagating log messages, including those of the INFO level."", ""INFO"")"
"In order to enable all INFO messages to be logged from the bottom Logger (named 1.2), even if the middle Logger has a log level of WARNING, we add the following to the code (in bold):",NULL
"The result of this code is that the INFO message logged on the bottom Logger (named 1.2) is now logged, but it is still not propagated up the hierarchy.","(""INFO"", ""The INFO message is logged by the Logger class."", ""Logger"")"
The java.util.Logger class is the main access point to the Java logging API.,"(""Logger"", ""The Logger class is part of the java.util package, which is a common package for utility classes in Java."", ""java.util"")"
The string passed as parameter to the getLogger() factory method is the name of the Logger to create.,"(""getLogger"", ""The getLogger method is used to create an instance of the Logger class."", ""Logger"")"
"The two names ""myApp.user"" and ""myApp.admin"" are children of the ""myApp"" name.","(""myApp.user"", ""myApp.user is a child of the myApp package"", ""myApp""); (""myApp.admin"", ""myApp.admin is a child of the myApp package"", ""myApp"")"
"The name ""myApp.admin.import.user"" is a branch of the name ""myApp.admin.import"", which is again a branch of the ""myApp.admin"" name.","(""myApp.admin.import.user"", ""myApp.admin.import.user is a branch of the myApp.admin.import package"", ""myApp.admin.import""); (""myApp.admin.import"", ""myApp.admin.import is a branch of the myApp.admin package"", ""myApp.admin"")"
"You can obtain the name of a Logger using the getName() method, in case you need it.","(""Logger"", ""The getName method is used to obtain the name of a Logger class."", ""getName"")"
"It is convention to use the class name of the class creating the Logger, including package name, as name for the Logger.","(""Class"", ""The class is responsible for creating the Logger."", ""Logger""); (""Package"", ""The package name is used as part of the name for the Logger."", ""Logger"")"
The log() group of methods will log a message at a certain log level.,"(""Log"", ""The log() group of methods is associated with logging messages at a certain log level."", ""Log Level"")"
"As mentioned earlier, the number inside the token refers to the index of the object parameter to insert, in the object parameter array passed to the log() message.","(""log"", ""The log method uses the object parameter to insert values into the message."", ""object parameter"")"
"The logp() methods work like the log() methods, except each method take an extra two parameters: The sourceClass and sourceMethod parameter.","(""logp"", ""The logp method is described as working like the log method, indicating a functional relationship."", ""log""); (""logp"", ""The logp method takes sourceClass as an extra parameter, indicating a dependency or usage relationship."", ""sourceClass""); (""logp"", ""The logp method takes sourceMethod as an extra parameter, indicating a dependency or usage relationship."", ""sourceMethod"")"
These two parameters are intended to tell from what class and method the log message originated.,"(""Class"", ""The log message is intended to indicate the origin, specifying both the class and method."", ""Method"")"
"In other words, which class and method was the ""source"" of the log message.","(""Class"", ""The class contains or is associated with the method, as classes typically define methods."", ""Method"")"
"The logrb() methods work like the log() methods too, except they can obtain the log messages from a resource bundle.","(""LOGRB"", ""Both methods are used for logging purposes, with LOGRB being a variant of LOG that can obtain log messages from a resource bundle."", ""LOG"")"
This example looks up a message in the resource bundle named resources.myresources by the key key1.,"(""Resources.Myresources"", ""The package Resources.Myresources contains the class Key1, as it is used to look up a message by this key."", ""Key1"")"
"For instance, finest(), finer(), fine(), info(), warning() and severe() each corresponds to one of the log levels.","(""FINEST"", ""The method FINEST corresponds to a log level."", ""LOG LEVEL""); (""FINER"", ""The method FINER corresponds to a log level."", ""LOG LEVEL""); (""FINE"", ""The method FINE corresponds to a log level."", ""LOG LEVEL""); (""INFO"", ""The method INFO corresponds to a log level."", ""LOG LEVEL""); (""WARNING"", ""The method WARNING corresponds to a log level."", ""LOG LEVEL""); (""SEVERE"", ""The method SEVERE corresponds to a log level."", ""LOG LEVEL"")"
Logging message using one of these methods corresponds to calling the log() method,"(""Log"", ""The text indicates that logging a message involves calling the log() method, suggesting a relationship between the action of logging and the log() method."", ""Log"")"
You can add Handler's to the Logger using the addHandler() method.,"(""addHandler"", ""The addHandler method is used to add Handlers to the Logger."", ""Logger""); (""Handler"", ""Handlers are added to the Logger to manage logging output."", ""Logger"")"
"You can obtain all Handler's of a Logger using the getHandlers() method, like this:","(""Logger"", ""The getHandlers method is used to obtain all Handlers of a Logger."", ""getHandlers""); (""getHandlers"", ""The getHandlers method is used to retrieve Handler instances."", ""Handler"")"
"You set the Filter on a Logger using the setFilter() method, like this:","(""setFilter"", ""The setFilter method is used to set a Filter on a Logger."", ""Filter""); (""setFilter"", ""The setFilter method is applied to a Logger to set a Filter."", ""Logger"")"
The class MyFilterImpl should be your own implementation of the Filter interface.,"(""MyFilterImpl"", ""MyFilterImpl is an implementation of the Filter interface"", ""Filter"")"
"You can obtain the Filter in use by calling the getFilter() method, like this:","(""getFilter"", ""The getFilter method is used to obtain the Filter class in use."", ""Filter"")"
"This example sets the minimum log level of messages to be forwarded, to Level.INFO.","(""Level.INFO"", ""class"")"
You can obtain the log level of a Logger using the getLevel() method:,"(""Logger"", ""The getLevel method is used to obtain the log level of a Logger class."", ""getLevel"")"
You can obtain the parent Logger of a given Logger using the getParent() method.,"(""Logger"", ""The getParent() method is used to obtain the parent Logger of a given Logger."", ""getParent"")"
You can check if a Logger forwards log messages to its parent Logger using the method getUseParentHandlers().,"(""Logger"", ""The method getUseParentHandlers() is used to check if a Logger forwards log messages to its parent Logger."", ""getUseParentHandlers"")"
The Logger class has a few more methods that I haven't covered here.,"(""Logger"", ""The Logger class contains several methods."", ""methods"")"
"The java.util.logging.LogManager manages the internal Logger hierarchy, and initiates the configuration of the Logger's, either through the configuration class or configuration file.","(""LogManager"", ""LogManager manages the internal Logger hierarchy"", ""Logger""); (""LogManager"", ""LogManager initiates the configuration of the Logger"", ""configuration""); (""java.util.logging"", ""LogManager is part of the java.util.logging package"", ""LogManager"")"
"The first method on the LogManager simply re-reads the configuration from file (or class), in case these has changed.","(""LogManager"", ""The method is a function or operation that belongs to the LogManager class."", ""method"")"
You can also get access to an MXBean (Java Management Extensions) from the LogManager using the method getLoggingMXBean().,"(""getLoggingMXBean"", ""The method getLoggingMXBean() provides access to an MXBean."", ""MXBean""); (""getLoggingMXBean"", ""The method getLoggingMXBean() is used in conjunction with the LogManager to access an MXBean."", ""LogManager"")"
"The LogRecord contains the following getter methods, which can be used in e.g.","(""LogRecord"", ""The LogRecord class contains the getter methods, indicating a relationship where the methods are part of the class."", ""getter methods"")"
The getLevel() method returns the log level the message represented by this LogRecord was logged with.,"(""getLevel"", ""The getLevel method is used to retrieve the log level of a message associated with a LogRecord."", ""LogRecord"")"
The getLoggerName() method returns the name of the Logger that logged this LogRecord.,"(""getLoggerName"", ""The getLoggerName method returns the name of the Logger."", ""Logger""); (""getLoggerName"", ""The getLoggerName method is associated with the LogRecord that was logged."", ""LogRecord"")"
The getMillis() method returns the time in milliseconds this LogRecord was recorded.,"(""getMillis"", ""The getMillis method is used to return the time in milliseconds for a LogRecord instance."", ""LogRecord"")"
The getParameters() method returns the parameters to be inserted into the message of this LogRecord.,"(""GetParameters"", ""The GetParameters method is used to return parameters that are inserted into the message of the LogRecord class."", ""LogRecord"")"
The getResourceBundle() method returns the ResourceBundle (if any) used to localize the message of this LogRecord.,"(""getResourceBundle"", ""The getResourceBundle method returns the ResourceBundle used for localization."", ""ResourceBundle""); (""getResourceBundle"", ""The getResourceBundle method is used to localize the message of this LogRecord."", ""LogRecord"")"
The getResourceBundleName() method returns the name of the ResourceBundle (if any) used to localize the message of this LogRecord.,"(""getResourceBundleName"", ""The method getResourceBundleName returns the name of the ResourceBundle used for localization."", ""ResourceBundle""); (""getResourceBundleName"", ""The method getResourceBundleName is used to localize the message of this LogRecord."", ""LogRecord"")"
The getSequenceNumber() method returns a sequence number generated internally in the LogRecord constructor when the LogRecord is created.,"(""GetSequenceNumber"", ""The GetSequenceNumber method is related to the LogRecord class as it returns a sequence number generated when a LogRecord is created."", ""LogRecord""); (""Constructor"", ""The Constructor method is related to the LogRecord class as it is used to create a LogRecord."", ""LogRecord"")"
The getSourceClassName() returns the class name of the class logging the message represented by this LogRecord.,"(""getSourceClassName"", ""The method getSourceClassName is related to the class LogRecord because it returns the class name of the class logging the message represented by this LogRecord."", ""LogRecord"")"
The getSourceMethodName() returns the method name of the method logging the message represented by this LogRecord.,"(""getSourceMethodName"", ""The method getSourceMethodName is related to the class LogRecord as it returns the method name of the method logging the message represented by this LogRecord."", ""LogRecord"")"
The getThreadID() method returns the ID of the thread logging the message represented by this LogRecord.,"(""GetThreadID"", ""The GetThreadID method is related to the LogRecord class because it returns the ID of the thread logging the message represented by this LogRecord."", ""LogRecord"")"
The getThrown() method returns the Throwable that was marked thrown when logging the message represented by this LogRecord.,"(""GETTHROWN"", ""The GETTHROWN method returns the THROWABLE that was marked thrown."", ""THROWABLE""); (""GETTHROWN"", ""The GETTHROWN method is related to the LOGRECORD as it logs the message represented by this LOGRECORD."", ""LOGRECORD"")"
In this text I will try to give you an overview of the java.util.logging API.,"(""Java.Util.Logging"", ""Java.Util.Logging is a package that is part of the API being discussed."", ""API"")"
This tutorial is about Javas built-in logging API in the java.util.logging package.,"(""Logging API"", ""The Logging API is part of the java.util.logging package."", ""Java.util.logging""); (""Java"", ""Java's built-in logging API refers to the Logging API."", ""Logging API"")"
"Note: This tutorial does not cover the other popular Java logging API's (Log4J, SLF4J, Apache Commons Logging, LogBack etc.).","(""Log4J"", ""Both are popular Java logging packages."", ""SLF4J""); (""Log4J"", ""Both are popular Java logging packages."", ""Apache Commons Logging""); (""Log4J"", ""Both are popular Java logging packages."", ""LogBack""); (""SLF4J"", ""Both are popular Java logging packages."", ""Apache Commons Logging""); (""SLF4J"", ""Both are popular Java logging packages."", ""LogBack""); (""Apache Commons Logging"", ""Both are popular Java logging packages."", ""LogBack"")"
"If you can choose your own logging API freely, you may choose one of these other, popular logging API's instead of java.util.logging.","(""Java.util.logging"", ""package"")"
"However, if you are running your web applications on Google App Engine, like I do, then you have to use the java.util.logging API.","(""Google App Engine"", ""Google App Engine uses the java.util.logging package for logging purposes in web applications."", ""java.util.logging"")"
Instances of this class are used together with UDP DatagramSockets and normal Socket's and ServerSocket's.,"(""UDP DatagramSockets"", ""UDP DatagramSockets are used together with Socket."", ""Socket""); (""UDP DatagramSockets"", ""UDP DatagramSockets are used together with ServerSocket."", ""ServerSocket""); (""Socket"", ""Socket and ServerSocket are mentioned together, indicating a relationship."", ""ServerSocket"")"
The InetAddress class has a lot of additional methods you can use.,"(""InetAddress"", ""The InetAddress class contains additional methods that can be used."", ""methods"")"
"For instance, you can obtain the IP address as a byte array by calling getAddress() etc.","(""getAddress"", ""The method getAddress is used to obtain the IP address as a byte array."", ""IP address"")"
"To learn more about these methods, it is easier to read the JavaDoc for the InetAddress class though.","(""InetAddress"", ""The JavaDoc package provides documentation for the InetAddress class."", ""JavaDoc"")"
Java's JarURLConnection class is used to connect to a Java Jar file.,"(""JarURLConnection"", ""The JarURLConnection class is used to connect to a Java Jar file, indicating a method relationship."", ""connect""); (""Java"", ""The JarURLConnection class is part of the Java package."", ""JarURLConnection""); (""Jar"", ""The JarURLConnection class is used to connect to a Jar file, indicating a package relationship."", ""JarURLConnection"")"
"Of course, sometimes this protocol is already have been decided for you, e.g.",NULL
Sending the header in a separate roundtrip (the first) can be smart if the server can do some initial pre-validation of e.g.,NULL
"In order to implement a Java server that listens for incoming connections from clients via TCP/IP, you need to use a java.net.ServerSocket .","(""Java Server"", ""The Java Server uses the java.net.ServerSocket class to listen for incoming connections."", ""java.net.ServerSocket""); (""Java Server"", ""The Java Server listens for incoming connections via the TCP/IP package."", ""TCP/IP"")"
"In case you prefer to use Java NIO instead of Java Networking (standard API), then you can also use a ServerSocketChannel instead of the java.net.ServerSocket.","(""Java NIO"", ""Java NIO provides the ServerSocketChannel class as part of its package."", ""ServerSocketChannel""); (""Java Networking"", ""Java Networking includes the java.net.ServerSocket class as part of its standard API."", ""java.net.ServerSocket""); (""ServerSocketChannel"", ""ServerSocketChannel can be used as an alternative to java.net.ServerSocket."", ""java.net.ServerSocket"")"
In order to accept incoming connections you must call the ServerSocket.accept() method.,"(""ServerSocket"", ""The accept method is called on the ServerSocket class to accept incoming connections."", ""accept"")"
The accept() method returns a Socket which behaves like an ordinary Java Socket.,"(""Accept"", ""The accept() method returns a Socket, indicating a functional relationship where the method produces an instance of the class."", ""Socket"")"
Only one incoming connection is opened for each call to the accept() method.,"(""ACCEPT"", ""The accept method is responsible for opening an incoming connection."", ""CONNECTION"")"
"Additionally, incoming connections can only be accepted while the thread running the server has called accept().","(""Thread"", ""The method 'accept()' is called by the thread running the server, indicating a relationship between the thread and the method."", ""Accept"")"
"In order to connect to a server over the internet (via TCP/IP) in Java, you need to create a java.net.Socket and connect it to the server.","(""Java.net.Socket"", ""Java.net.Socket is used to connect to the server over the internet via TCP/IP."", ""server"")"
This code example connects to the server with IP address 78.46.84.171 on port 80.,NULL
"Don't forget to call flush() when you really, really want the data sent across the internet to the server.","(""flush()"", ""The method flush() is used to send data across the internet to the server."", ""server"")"
The getByName() method returns an InetAddress instance with the IP address matching the given host name.,"(""getByName"", ""The getByName method returns an instance of the InetAddress class."", ""InetAddress"")"
Receiving data via a DatagramSocket is done by first creating a DatagramPacket and then receiving data into it via the DatagramSocket's receive() method.,"(""DatagramSocket"", ""The receive() method is a function of the DatagramSocket class, used to receive data."", ""receive""); (""DatagramSocket"", ""Data is received into a DatagramPacket via the DatagramSocket."", ""DatagramPacket"")"
"A real server program would probably call the receive() method in a loop, and pass all received DatagramPacket's to a pool of worker threads, just like a TCP server does with incoming connections (see Java Multithreaded Servers for more details).","(""Receive"", ""The receive() method is used to handle DatagramPacket objects."", ""DatagramPacket""); (""Java Multithreaded Servers"", ""The Java Multithreaded Servers package likely contains information or examples on using the receive() method in a multithreaded context."", ""Receive"")"
The java.net package contains two interesting classes: The URL class and the URLConnection class.,"(""Java.net"", ""The URL class is part of the java.net package."", ""URL""); (""Java.net"", ""The URLConnection class is part of the java.net package."", ""URLConnection""); (""URL"", ""Both URL and URLConnection are classes within the java.net package, indicating a potential relationship in functionality or usage."", ""URLConnection"")"
These classes can be used to create client connections to web servers (HTTP servers).,"(""Classes"", ""Classes are used to create client connections to web servers."", ""Client Connections"")"
"If you want to send an HTTP POST request instead, call the URLConnection.setDoOutput(true) method, like this:","(""URLConnection"", ""The setDoOutput method is a member of the URLConnection class, as it is called on an instance of this class."", ""setDoOutput"")"
The URL class can also be used to access files in the local file system.,"(""URL"", ""The URL class can be used to access files in the local file system."", ""files"")"
"Thus the URL class can be a handy way to open a file, if you need your code to not know whether the file came from the network or local file system.","(""URL"", ""The URL class is used to open a file, indicating a functional relationship between the two."", ""file"")"
Here is an example of how to open a file in the local file system using the URL class:,"(""URL"", ""The URL class is used to open a file in the local file system."", ""file"")"
"Notice how the only difference from accessing a file on a web server via HTTP is the the URL: ""file:/c:/data/test.txt"".","(""HTTP"", ""HTTP is a protocol used to access resources identified by a URL"", ""URL"")"
"Even though the Java Networking APIs enable you to open and close network connections via sockets, all communication happens via the Java IO classes InputStream and OutputStream.","(""Java Networking APIs"", ""Java Networking APIs use InputStream for handling input operations in network communication."", ""InputStream""); (""Java Networking APIs"", ""Java Networking APIs use OutputStream for handling output operations in network communication."", ""OutputStream""); (""InputStream"", ""InputStream and OutputStream are both Java IO classes used for handling input and output operations, respectively."", ""OutputStream"")"
Alternatively you can use the networking classes in the Java NIO API.,"(""Networking Classes"", ""The networking classes are part of the Java NIO API package."", ""Java NIO API"")"
"These classes are similar to the classes found in the Java Networking API, except the Java NIO API can work in non-blocking mode.","(""Java Networking API"", ""Both are packages related to Java and deal with networking capabilities, with Java NIO API offering non-blocking mode features."", ""Java NIO API"")"
The first parameter to the open() method is a Path instance pointing to the file the AsynchronousFileChannel is to be associated with.,"(""Open"", ""The Open method takes a Path instance as its first parameter."", ""Path""); (""Open"", ""The Open method is used to associate with the AsynchronousFileChannel."", ""AsynchronousFileChannel"")"
In this example we used the StandardOpenOption.READ which means that the file will be opened for reading.,"(""StandardOpenOption"", ""READ is a method associated with the StandardOpenOption class, indicating a specific option for opening files."", ""READ"")"
Each way to read data call one of the read() methods of the AsynchronousFileChannel.,"(""Read"", ""The read method is a function of the AsynchronousFileChannel class, indicating that it is used to read data from this class."", ""AsynchronousFileChannel"")"
The first way to read data from an AsynchronousFileChannel is to call the read() method that returns a Future.,"(""AsynchronousFileChannel"", ""The read method is called on an AsynchronousFileChannel to read data."", ""read""); (""read"", ""The read method returns a Future, indicating the result of the asynchronous read operation."", ""Future"")"
This version of the read() method takes ByteBuffer as first parameter.,"(""Read"", ""The Read method takes ByteBuffer as its first parameter, indicating a direct interaction between the method and the class."", ""ByteBuffer"")"
"The read() method return immediately, even if the read operation has not finished.","(""Read"", ""The text describes the behavior of the Read method, indicating its immediate return characteristic."", ""Read"")"
You can check the when the read operation is finished by calling the isDone() method of the Future instance returned by the read() method.,"(""Read"", ""The isDone() method is used to check the completion status of the read operation."", ""IsDone""); (""Read"", ""The read() method returns an instance of the Future class."", ""Future""); (""IsDone"", ""The isDone() method is called on the Future instance."", ""Future"")"
Here is a longer example showing how to use this version of the read() method:,"(""Read"", ""The text describes the use of the read() method, indicating that 'Read' is a method."", ""Method"")"
"This example creates an AsynchronousFileChannel and then creates a ByteBuffer which is passed to the read() method as parameter, along with a position of 0.","(""ByteBuffer"", ""ByteBuffer is passed as a parameter to the read() method."", ""read""); (""AsynchronousFileChannel"", ""The read() method is likely associated with the AsynchronousFileChannel class."", ""read"")"
After calling read() the example loops until the isDone() method of the returned Future returns true.,"(""READ"", ""The ISDONE method is called after the READ method in the example."", ""ISDONE""); (""ISDONE"", ""The ISDONE method is a method of the returned FUTURE class."", ""FUTURE"")"
Once the read operation has completed the data read into the ByteBuffer and then into a String and printed to System.out .,"(""ByteBuffer"", ""Data is read from ByteBuffer into a String."", ""String""); (""String"", ""The String is printed to System.out."", ""System.out"")"
The second method of reading data from an AsynchronousFileChannel is to call the read() method version that takes a CompletionHandler as a parameter.,"(""read"", ""The read method takes a CompletionHandler as a parameter, indicating a relationship between the method and the class."", ""CompletionHandler""); (""read"", ""The read method is used to read data from an AsynchronousFileChannel, indicating a relationship between the method and the class."", ""AsynchronousFileChannel"")"
Once the read operation finishes the CompletionHandler's completed() method will be called.,"(""CompletionHandler"", ""The completed() method is part of the CompletionHandler class, as it is called when the read operation finishes."", ""completed"")"
"As parameters to the completed() method are passed an Integer telling how many bytes were read, and the ""attachment"" which was passed to the read() method.","(""COMPLETED"", ""The COMPLETED method takes an INTEGER as a parameter to indicate how many bytes were read."", ""INTEGER""); (""COMPLETED"", ""The COMPLETED method takes an ATTACHMENT as a parameter, which was passed to the READ method."", ""ATTACHMENT""); (""READ"", ""The ATTACHMENT is passed to the READ method."", ""ATTACHMENT"")"
"If the read operation fails, the failed() method of the CompletionHandler will get called instead.","(""FAILED"", ""The FAILED method is a part of the COMPLETIONHANDLER class, as it is called when the read operation fails."", ""COMPLETIONHANDLER"")"
Each way to write data call one of the write() methods of the AsynchronousFileChannel.,"(""WRITE"", ""The WRITE method is a function of the ASYNCHRONOUSFILECHANNEL class, as it is used to write data through this class."", ""ASYNCHRONOUSFILECHANNEL"")"
If the file does not exist the write() method will throw a java.nio.file.NoSuchFileException .,"(""write"", ""The write method will throw a java.nio.file.NoSuchFileException if the file does not exist."", ""java.nio.file.NoSuchFileException"")"
The CompletionHandler's completed() method will get called when the write operation completes.,"(""CompletionHandler"", ""The completed() method is a part of the CompletionHandler class, indicating that it is a method belonging to this class."", ""completed"")"
"If the write fails for some reason, the failed() method will get called instead.","(""write"", ""The 'failed' method is called if the 'write' method fails."", ""failed"")"
"Once you need to read the data, you need to switch the buffer from writing mode into reading mode using the flip() method call.","(""FLIP"", ""The flip() method is used to switch the buffer from writing mode into reading mode."", ""BUFFER"")"
You can do this in two ways: By calling clear() or by calling compact().,"(""clear"", ""Both are methods that can be called to perform an action."", ""compact"")"
The compact() method only clears the data which you have already read.,"(""COMPACT"", ""The term 'compact' is directly referred to as a method in the text."", ""METHOD"")"
Here is an example that writes data into a Buffer via the put() method:,"(""Buffer"", ""The put() method is used to write data into the Buffer class."", ""put"")"
"There are many other versions of the put() method, allowing you to write data into the Buffer in many different ways.","(""PUT"", ""The PUT method is used to write data into the BUFFER class."", ""BUFFER"")"
The flip() method switches a Buffer from writing mode to reading mode.,"(""Flip"", ""The Flip method is a function that operates on the Buffer class to switch its mode from writing to reading."", ""Buffer"")"
"Calling flip() sets the position back to 0, and sets the limit to where position just was.","(""FLIP"", ""The method FLIP is called to set the POSITION back to 0."", ""POSITION""); (""FLIP"", ""The method FLIP sets the LIMIT to where the POSITION just was."", ""LIMIT"")"
Here is an example that reads data from a Buffer using the get() method:,"(""Buffer"", ""The get() method is used to read data from the Buffer class."", ""get"")"
"There are many other versions of the get() method, allowing you to read data from the Buffer in many different ways.","(""GET"", ""The GET method is used to read data from the BUFFER class."", ""BUFFER"")"
"The Buffer.rewind() sets the position back to 0, so you can reread all the data in the buffer.","(""Buffer"", ""The method 'rewind' is associated with the class 'Buffer' as it operates on it."", ""rewind"")"
"The limit remains untouched, thus still marking how many elements (bytes, chars etc.)",NULL
You can do so either by calling clear() or by calling compact().,"(""CLEAR"", ""Both CLEAR and COMPACT are methods that can be called, indicating they are related as operations that can be performed."", ""COMPACT"")"
If you call clear() the position is set back to 0 and the limit to capacity.,"(""CLEAR"", ""The method CLEAR affects the POSITION by setting it back to 0."", ""POSITION""); (""CLEAR"", ""The method CLEAR affects the LIMIT by setting it to capacity."", ""LIMIT"")"
"If there is any unread data in the Buffer when you call clear() that data will be ""forgotten"", meaning you no longer have any markers telling what data has been read, and what has not been read.","(""Buffer"", ""The method clear() is called on the Buffer class to reset or clear its unread data."", ""clear"")"
"If there is still unread data in the Buffer, and you want to read it later, but you need to do some writing first, call compact() instead of clear().","(""Buffer"", ""The method compact() is called on the Buffer class to manage unread data."", ""compact()""); (""Buffer"", ""The method clear() is called on the Buffer class to manage data operations."", ""clear()"")"
compact() copies all unread data to the beginning of the Buffer.,"(""COMPACT"", ""The method 'compact' operates on the class 'Buffer' by copying all unread data to the beginning of it."", ""BUFFER"")"
"The limit property is still set to capacity, just like clear() does.","(""Limit"", ""The limit property is set to capacity, indicating a relationship between these two properties."", ""Capacity""); (""Clear"", ""The clear() method is mentioned in relation to setting the limit property, suggesting a functional relationship."", ""Limit"")"
You can mark a given position in a Buffer by calling the Buffer.mark() method.,"(""Buffer"", ""The method 'mark' is a function that can be called on the 'Buffer' class."", ""mark"")"
You can then later reset the position back to the marked position by calling the Buffer.reset() method.,"(""Buffer"", ""The reset method is a function that belongs to the Buffer class, allowing the position to be reset to a marked position."", ""reset"")"
It is possible to compare two buffers using equals() and compareTo().,"(""EQUALS"", ""Both EQUALS and COMPARETO are methods used to compare two buffers."", ""COMPARETO"")"
The FileChannel class has a transferTo() and a transferFrom() method which does this for you.,"(""FileChannel"", ""The transferTo method is a part of the FileChannel class."", ""transferTo""); (""FileChannel"", ""The transferFrom method is a part of the FileChannel class."", ""transferFrom"")"
The FileChannel.transferFrom() method transfers data from a source channel into the FileChannel.,"(""transferFrom"", ""The transferFrom method is a method of the FileChannel class, indicating that it operates on instances of FileChannel."", ""FileChannel""); (""FileChannel"", ""The FileChannel is mentioned twice, indicating it is the class involved in the data transfer operation."", ""FileChannel"")"
The transferTo() method transfer from a FileChannel into some other channel.,"(""TransferTo"", ""The TransferTo method is used to transfer data from a FileChannel."", ""FileChannel"")"
The issue with SocketChannel is also present with the transferTo() method.,"(""SocketChannel"", ""The transferTo method is associated with the SocketChannel class as it is mentioned in the context of an issue related to SocketChannel."", ""transferTo"")"
"You receive data from a DatagramChannel by calling its receive() method, like this:","(""DatagramChannel"", ""The receive method is called on the DatagramChannel class to receive data."", ""receive"")"
The receive() method will copy the content of a received packet of data into the given Buffer.,"(""Receive"", ""The receive() method interacts with the Buffer class by copying the content of a received packet of data into it."", ""Buffer"")"
"You can send data via a DatagramChannel by calling its send() method, like this:","(""DatagramChannel"", ""The send method is a function that belongs to the DatagramChannel class, allowing it to send data."", ""send"")"
"When connected you can also use the read() and write() method, as if you were using a traditional channel.","(""READ"", ""Both are methods that can be used when connected, similar to using a traditional channel."", ""WRITE"")"
The Java NIO FileChannel class is NIO's an alternative to reading files with the standard Java IO API.,"(""Java NIO"", ""FileChannel is a class within the Java NIO package."", ""FileChannel""); (""Java IO"", ""FileChannel is an alternative to reading files with the standard Java IO package."", ""FileChannel"")"
To read data from a FileChannel you call one of the read() methods.,"(""FileChannel"", ""The read() method is used to read data from a FileChannel class."", ""read"")"
The int returned by the read() method tells how many bytes were written into the Buffer.,"(""READ"", ""The read method interacts with the Buffer class by writing bytes into it."", ""BUFFER"")"
"Writing data to a FileChannel is done using the FileChannel.write() method, which takes a Buffer as parameter.","(""FileChannel"", ""The FileChannel.write() method is a function of the FileChannel class."", ""FileChannel.write()""); (""FileChannel.write()"", ""The FileChannel.write() method takes a Buffer as a parameter, indicating a relationship between the method and the class."", ""Buffer"")"
There is no guarantee of how many bytes the write() method writes to the FileChannel.,"(""WRITE"", ""The write() method is used in the context of the FileChannel class, indicating a functional relationship where the method operates on or with the class."", ""FILECHANNEL"")"
Therefore we repeat the write() call until the Buffer has no further bytes to write.,"(""Write"", ""The method Write is called to operate on the class Buffer, indicating a functional relationship where Write interacts with Buffer."", ""Buffer"")"
You can obtain the current position of the FileChannel object by calling the position() method.,"(""FileChannel"", ""The position method is called on the FileChannel class to obtain the current position."", ""position"")"
The size() method of the FileChannel object returns the file size of the file the channel is connected to.,"(""Size"", ""The size() method is a method of the FileChannel class, indicating that it operates on instances of this class."", ""FileChannel"")"
The FileChannel.force() method flushes all unwritten data from the channel to the disk.,"(""FileChannel"", ""The force method is a function of the FileChannel class."", ""force"")"
"An operating system may cache data in memory for performance reasons, so you are not guaranteed that data written to the channel is actually written to disk, until you call the force() method.","(""FORCE"", ""The force() method is called to ensure that data written to the channel is actually written to disk."", ""CHANNEL""); (""FORCE"", ""The force() method is used to guarantee that data is written to disk."", ""DISK"")"
"The force() method takes a boolean as parameter, telling whether the file meta data (permission etc.)","(""Force"", ""The force() method takes a boolean as a parameter, indicating a relationship between the method and the data type."", ""Boolean"")"
The Java NIO Files class (java.nio.file.Files) provides several methods for manipulating files in the file system.,"(""Files"", ""The Files class provides several methods for manipulating files."", ""methods""); (""Files"", ""The Files class is part of the java.nio.file package."", ""java.nio.file"")"
"The Files class contains many methods, so check the JavaDoc too, if you need a method that is not described here.","(""Files"", ""The Files class is documented in the JavaDoc package, which provides detailed information about its methods."", ""JavaDoc"")"
The Files class just might have a method for it still.,"(""Files"", ""The Files class likely contains a method, as suggested by the text."", ""method"")"
"The java.nio.file.Files class works with java.nio.file.Path instances, so you need to understand the Path class before you can work with the Files class.","(""Files"", ""The Files class works with Path instances, indicating a functional relationship between them."", ""Path""); (""Files"", ""The Files class is part of the java.nio.file package."", ""java.nio.file""); (""Path"", ""The Path class is part of the java.nio.file package."", ""java.nio.file"")"
The Files.exists() method checks if a given Path exists in the file system.,"(""Files"", ""The exists method is a function of the Files class."", ""exists""); (""exists"", ""The exists method checks if a given Path exists in the file system."", ""Path"")"
"Since Path instances may or may not point to paths that exist in the file system, you can use the Files.exists() method to determine if they do (in case you need to check that).","(""Files"", ""The 'exists' method is a function provided by the 'Files' class."", ""exists""); (""Path"", ""The 'Path' class instances can be checked for existence in the file system using the 'Files' class."", ""Files"")"
"Second, the example calls the Files.exists() method with the Path instance as the first parameter.","(""Files.exists()"", ""The Files.exists() method is called with a Path instance as a parameter, indicating a relationship where the method operates on or uses the Path class."", ""Path"")"
This parameter is an array of options that influence how the Files.exists() determines if the path exists or not.,"(""Files"", ""The method 'exists' is a member of the class 'Files', indicating that it is used to check if a path exists within the context of the Files class."", ""exists"")"
In this example above the array contains the LinkOption.NOFOLLOW_LINKS which means that the Files.exists() method should not follow symbolic links in the file system to determine if the path exists.,"(""LinkOption"", ""NOFOLLOW_LINKS is a member or constant of the LinkOption class"", ""NOFOLLOW_LINKS""); (""Files"", ""The exists method is a part of the Files class"", ""exists"")"
The Files.createDirectory() method creates a new directory from a Path instance.,"(""Files"", ""The createDirectory method is a member of the Files class."", ""createDirectory""); (""createDirectory"", ""The createDirectory method uses a Path instance to create a new directory."", ""Path"")"
Inside the try-catch block the Files.createDirectory() method is called with the path as parameter.,"(""Files.createDirectory()"", ""The Files.createDirectory() method is called with the path as a parameter, indicating a relationship where the method uses the path."", ""path"")"
The Files.copy() method copies a file from one path to another.,"(""Files.copy()"", ""The Files.copy() method is a part of the Files class, indicating that it is a method belonging to this class."", ""Files"")"
"Then the example calls Files.copy(), passing the two Path instances as parameters.","(""Files.copy()"", ""The method Files.copy() uses Path instances as parameters, indicating a relationship where Path is used by Files.copy()."", ""Path"")"
It is possible to force the Files.copy() to overwrite an existing file.,"(""Files"", ""The method 'copy' is a function of the 'Files' class."", ""copy"")"
Here an example showing how to overwrite an existing file using Files.copy():,"(""Files"", ""The method 'copy' is a function of the 'Files' class, indicating that 'copy' is used to perform operations related to file handling."", ""copy"")"
This parameter instructs the copy() method to overwrite an existing file if the destination file already exists.,"(""COPY"", ""The copy() method is instructed to overwrite an existing file if the destination file already exists."", ""OVERWRITE"")"
The Java NIO Files class also contains a function for moving files from one path to another.,"(""Files"", ""The Files class contains a function for moving files, indicating a relationship between the class and the action of moving files."", ""moving files"")"
"Yes, the java.io.File class could also do that with its renameTo() method, but now you have the file move functionality in the java.nio.file.Files class too.","(""Java.io.File"", ""The RenameTo method is a part of the Java.io.File class."", ""RenameTo""); (""Java.nio.file.Files"", ""The RenameTo method is related to the Java.nio.file.Files class as it provides similar file move functionality."", ""RenameTo"")"
This parameter tells the Files.move() method to overwrite any existing file at the destination path.,"(""Files.move()"", ""The Files.move() method is a part of the Files class, indicating a relationship where the method belongs to the class."", ""Files"")"
The Files.move() method may throw an IOException if moving the file fails.,"(""Files.move()"", ""The Files.move() method may throw an IOException if moving the file fails."", ""IOException"")"
"For instance, if a file already exists at the destination path, and you have left out the StandardCopyOption.REPLACE_EXISTING option, or if the file to move does not exist etc.","(""StandardCopyOption"", ""REPLACE_EXISTING is a method or constant within the StandardCopyOption class"", ""REPLACE_EXISTING"")"
If the Files.delete() fails to delete the file for some reason (e.g.,"(""Files"", ""The delete method is associated with the Files class, as it is invoked using Files.delete()."", ""delete"")"
The Files.walkFileTree() method contains functionality for traversing a directory tree recursively.,"(""Files"", ""The method walkFileTree is a functionality provided by the Files class for traversing a directory tree recursively."", ""walkFileTree"")"
The walkFileTree() method takes a Path instance and a FileVisitor as parameters.,"(""walkFileTree"", ""The walkFileTree method takes a Path instance as a parameter, indicating a relationship where Path is used by walkFileTree."", ""Path""); (""walkFileTree"", ""The walkFileTree method takes a FileVisitor as a parameter, indicating a relationship where FileVisitor is used by walkFileTree."", ""FileVisitor"")"
"You have to implement the FileVisitor interface yourself, and pass an instance of your implementation to the walkFileTree() method.","(""FileVisitor"", ""The walkFileTree method requires an instance of a class implementing the FileVisitor interface to function."", ""walkFileTree"")"
"If you do not need to hook into all of these methods, you can extend the SimpleFileVisitor class, which contains default implementations of all methods in the FileVisitor interface.","(""SimpleFileVisitor"", ""SimpleFileVisitor class provides default implementations for all methods in the FileVisitor interface"", ""FileVisitor"")"
The visitFile() mehtod is called for every file visited during the file walk.,"(""visitFile"", ""The visitFile method is called for every file visited during the file walk, indicating a direct interaction with files."", ""file"")"
The visitFileFailed() method is called in case visiting a file fails.,"(""visitFileFailed"", ""method"")"
Here is a walkFileTree() that extends SimpleFileVisitor to look for a file named README.txt :,"(""walkFileTree"", ""The method walkFileTree extends the class SimpleFileVisitor."", ""SimpleFileVisitor""); (""walkFileTree"", ""The method walkFileTree is used to look for a file named README.txt."", ""README.txt"")"
The Files.walkFileTree() can also be used to delete a directory with all files and subdirectories inside it.,"(""Files"", ""The method walkFileTree is a function of the class Files."", ""walkFileTree"")"
The Files.delete() method will only delete a directory if it is empty.,"(""Files"", ""The delete method is a function of the Files class."", ""delete"")"
"By walking through all directories and deleting all files (inside visitFile()) in each directory, and afterwards delete the directory itself (inside postVisitDirectory()) you can delete a directory with all subdirectories and files.","(""visitFile"", ""Both methods are used in the process of deleting directories and their contents."", ""postVisitDirectory"")"
"The java.nio.file.Files class contains many other useful functions, like functions for creating symbolic links, determining the file size, setting file permissions etc.","(""Files"", ""The Files class contains functions for creating symbolic links, determining the file size, and setting file permissions."", ""Files"")"
Check out the JavaDoc for the java.nio.file.Files class for more information about these methods.,"(""Files"", ""The Files class is part of the java.nio.file package, indicating a containment or organizational relationship."", ""java.nio.file""); (""Files"", ""The Files class contains or provides various methods, as indicated by the reference to 'these methods' in the text."", ""methods"")"
And that is before the server has used any memory for processing the incoming messages (e.g.,NULL
"To keep the number of threads down, many servers use a design where the server keeps a pool of threads (e.g.",NULL
When you call select() or selectNow() on the Selector it gives you only the SelectableChannel instances that actually has data to read.,"(""Selector"", ""The method 'select' is called on the 'Selector' class."", ""select""); (""Selector"", ""The method 'selectNow' is called on the 'Selector' class."", ""selectNow""); (""Selector"", ""The 'Selector' class provides instances of 'SelectableChannel' that have data to read."", ""SelectableChannel"")"
"A data block could potentially contain a partial message (less than a message), a full message, or more than a message, for instance 1.5 or 2.5 messsages.",NULL
The first way to implement a resizable buffer is to start with a small buffer of e.g.,NULL
"If a message cannot fit into the 4KB buffer, a larger buffer of e.g.",NULL
For 1.000.000 concurrent connections that results in 1.000.000 x 4KB = 4GB which is possible in most servers today (2015).,NULL
Another workaround is to time out messages which have not been received within e.g.,NULL
The fact that TLV encodings makes memory management easier is one of the reasons why HTTP 1.1 is such a terrible protocol.,"(""TLV"", ""TLV encodings are mentioned in the context of HTTP 1.1, suggesting a relationship in terms of protocol design and memory management."", ""HTTP 1.1"")"
That is one of the problems they are trying to fix in HTTP 2.0 where data is transported in LTV encoded frames.,"(""HTTP 2.0"", ""HTTP 2.0 uses LTV encoded frames to transport data"", ""LTV encoded frames"")"
This is also why we have designed our own network protocol for our VStack.co project that uses a TLV encoding.,"(""VStack.co"", ""The TLV encoding is used as part of the network protocol for the VStack.co project."", ""TLV encoding"")"
Imagine if you have 1.000.000 connections which are mostly idle and all 1.000.000 connections were registered with the Selector.,"(""connections"", ""Connections are registered with the Selector class, indicating a management or handling relationship."", ""Selector"")"
"Then, when you call select() most of these Channel instances would be write-ready (they are mostly idle, remember?).","(""SELECT"", ""The method SELECT is called on instances of the class CHANNEL."", ""CHANNEL"")"
"Java NIO has more classes and components than these, but the Channel, Buffer and Selector forms the core of the API, in my opinion.","(""Java NIO"", ""Channel is a core class within the Java NIO package."", ""Channel""); (""Java NIO"", ""Buffer is a core class within the Java NIO package."", ""Buffer""); (""Java NIO"", ""Selector is a core class within the Java NIO package."", ""Selector"")"
"The rest of the components, like Pipe and FileLock are merely utility classes to be used in conjunction with the three core components.","(""Pipe"", ""Both Pipe and FileLock are utility classes mentioned together as components."", ""FileLock"")"
"There are a few interesting interfaces accompanying these classes too, but I'll keep them out of this Java NIO overview for simplicity's sake.","(""Java NIO"", ""The text mentions classes in the context of Java NIO, indicating that these classes are part of the Java NIO package."", ""classes"")"
"The Path interface is located in the java.nio.file package, so the fully qualified name of the Java Path interface is java.nio.file.Path.","(""Path"", ""The Path class is located in the java.nio.file package."", ""java.nio.file"")"
The java.nio.file.Path interface has nothing to do with the path environment variable.,"(""Path"", ""The Path class is part of the java.nio.file package"", ""java.nio.file"")"
"In many ways the java.nio.file.Path interface is similar to the java.io.File class, but there are some minor differences.","(""Java.Nio.File.Path"", ""The Java.Nio.File.Path interface is compared to the Java.Io.File class, indicating a relationship between the two entities."", ""Java.Io.File"")"
"In many cases though, you can replace the use of the File class with use of the Path interface.","(""File"", ""The File class can be replaced by the Path interface, indicating a relationship where Path serves a similar purpose or function as File."", ""Path"")"
In order to use a java.nio.file.Path instance you must create a Path instance.,"(""Path"", ""The class Path is part of the package java.nio.file"", ""java.nio.file"")"
You create a Path instance using a static method in the Paths class (java.nio.file.Paths) named Paths.get().,"(""Paths"", ""The method Paths.get() is a static method in the Paths class."", ""Paths.get()""); (""Paths"", ""The Paths class is part of the java.nio.file.Paths package."", ""java.nio.file.Paths""); (""Path"", ""A Path instance is created using the Paths.get() method."", ""Paths.get()"")"
To use the Path interface and the Paths class we must first import them.,"(""Path"", ""Both are related as they are part of the same context of usage in the text."", ""Paths"")"
It is the call to the Paths.get() method that creates the Path instance.,"(""Paths.get()"", ""The Paths.get() method is responsible for creating an instance of the Path class."", ""Path"")"
"The Paths.get() method is a factory method for Path instances, in other words.","(""Paths.get()"", ""The Paths.get() method is used to create instances of the Path class."", ""Path"")"
Creating an absolute path is done by calling the Paths.get() factory method with the absolute file as parameter.,"(""Paths"", ""The get method is a factory method of the Paths class."", ""get"")"
The Java NIO Path class can also be used to work with relative paths.,"(""Path"", ""The Path class is part of the Java NIO package, which provides functionalities for working with paths."", ""Java NIO"")"
The second example creates a Path instance which points to the path (file) d:\data\projects\a-project\myfile.txt .,"(""Path"", ""The Path class instance points to the specified file path."", ""d:\\data\\projects\\a-project\\myfile.txt"")"
If you use the .. code in the middle of a path string it will correspond to changing one directory up at that point in the path string.,"(""Path"", ""The Path class and String class are related because a path is often represented as a string in programming."", ""String"")"
The .. code after the a-project directory changes directory up the the parent directory projects and then the path references down into the another-project directory from there.,NULL
and .. codes also work in combination with the two-string Paths.get() method.,"(""Paths.get"", ""The text mentions the Paths.get() method, indicating it is a method entity."", ""Paths.get"")"
Here are two Java Paths.get() examples showing simple examples of that:,"(""Paths"", ""The method 'get' is a member of the 'Paths' class, as indicated by the notation 'Paths.get()'."", ""get"")"
There are more ways that the Java NIO Path class can be used to work with relative paths.,"(""Path"", ""The Path class is part of the Java NIO package, which provides functionalities for working with file paths."", ""Java NIO"")"
The Java Path method relativize() can create a new Path which represents the second Path relative to the first Path.,"(""Java Path"", ""The method 'relativize()' is associated with the 'Java Path' class as it operates on Path objects."", ""relativize""); (""relativize"", ""The method 'relativize()' creates a new 'Path', indicating a functional relationship between the method and the class."", ""Path"")"
"For instance, with the path /data and /data/subdata/subsubdata/myfile.txt"", the second path can be expressed as /subdata/subsubdata/myfile.txt relative to the first path.","(""Path"", ""The second path is expressed relative to the first path, indicating a relationship between the two paths."", ""Path"")"
"If you add the relative path subdata/subsubdata/myfile.txt to the directory path /data, you get the full path /data/subdata/subsubdata/myfile.txt.",NULL
If you you add the relative path ../../.. to the full file path /data/subdata/subsubdata/myfile.txt then you get /data,NULL
The normalize() method of the Path interface can normalize a path.,"(""Normalize"", ""The normalize method is a function that belongs to the Path class."", ""Path"")"
"and .. codes in the middle of the path string, and resolves what path the path string refers to.",NULL
This Path example first creates a path string with a .. code in the middle.,"(""Path"", ""The 'code' method is mentioned in the context of creating a path string, suggesting it is used within the 'Path' class."", ""code"")"
"Then the example creates a Path instance from this path string, and prints that Path instance out (actually it prints Path.toString()).","(""Path"", ""The toString method is used to print the Path instance."", ""toString"")"
"The example then calls normalize() on the created Path instance, which returns a new Path instance.","(""Normalize"", ""The method Normalize is called on an instance of the class Path."", ""Path""); (""Path"", ""The method Normalize returns a new instance of the class Path."", ""Path"")"
"As you can see, the normalized path does not contain the a-project\.. part, as this is redundant.",NULL
"You write to a SinkChannel by calling it's write() method, like this:","(""SinkChannel"", ""The write method is called on the SinkChannel class to perform a write operation."", ""write"")"
To read from the source channel you call its read() method like this:,"(""Read"", ""The read method is used to read from the source channel"", ""Source Channel"")"
The int returned by the read() method tells how many bytes were read into the buffer.,"(""READ"", ""The read() method returns an int, indicating the number of bytes read into the buffer."", ""INT"")"
"Notice how the buffers are first inserted into an array, then the array passed as parameter to the channel.read() method.","(""CHANNEL"", ""The method 'read' is associated with the class 'Channel' as it is invoked on a channel object."", ""READ"")"
The read() method then writes data from the channel in the sequence the buffers occur in the array.,"(""Read"", ""The read method writes data from the channel."", ""Data""); (""Read"", ""The read method writes data from the channel."", ""Channel""); (""Read"", ""The read method writes data in the sequence the buffers occur in the array."", ""Buffers"")"
"In other words, if you have a header and a body, and the header is fixed size (e.g.",NULL
"The array of buffers are passed into the write() method, which writes the content of the buffers in the sequence they are encountered in the array.","(""Write"", ""The Write method writes the content of the Buffers."", ""Buffers""); (""Write"", ""The Write method processes the Buffers in the sequence they are encountered in the Array."", ""Array"")"
"The Java NIO Selector is a component which can examine one or more Java NIO Channel instances, and determine which channels are ready for e.g.","(""Java NIO Selector"", ""The Java NIO Selector is related to Java NIO Channel as it examines one or more instances of this class to determine their readiness."", ""Java NIO Channel"")"
"You create a Selector by calling the Selector.open() method, like this:","(""Selector"", ""The open method is used to create an instance of the Selector class."", ""open"")"
"As you saw in the previous section, when you register a Channel with a Selector the register() method returns a SelectionKey objects.","(""Channel"", ""A Channel can be registered with a Selector."", ""Selector""); (""register"", ""The register() method returns a SelectionKey object."", ""SelectionKey""); (""register"", ""The register() method is used to register a Channel."", ""Channel""); (""register"", ""The register() method is associated with a Selector."", ""Selector"")"
"You can also attach an object already while registering the Channel with the Selector, in the register() method.","(""register"", ""The register method is used to register the Channel with the Selector."", ""Channel""); (""register"", ""The register method is used to register the Channel with the Selector."", ""Selector"")"
Once you have register one or more channels with a Selector you can call one of the select() methods.,"(""Selector"", ""The select() method is called on the Selector class."", ""select"")"
"In other words, if you are interested in channels that are ready for reading, you will receive the channels that are ready for reading from the select() methods.","(""Select"", ""The text mentions the select() method, indicating that it is a method related to channels that are ready for reading."", ""Select"")"
select() blocks until at least one channel is ready for the events you registered for.,"(""SELECT"", ""The method 'select()' blocks until at least one channel is ready, indicating a relationship between the method and the channel."", ""CHANNEL"")"
select(long timeout) does the same as select() except it blocks for a maximum of timeout milliseconds (the parameter).,"(""select"", ""The method 'select' uses 'timeout' as a parameter to determine the maximum blocking time in milliseconds."", ""timeout"")"
The int returned by the select() methods tells how many channels are ready.,"(""Select"", ""The method 'Select' returns an integer value indicating the number of channels that are ready."", ""Int"")"
"That is, how many channels that became ready since last time you called select().","(""Select"", ""The method 'Select' is related to 'Channels' as it is used to determine how many channels became ready since the last call."", ""Channels"")"
"If you call select() and it returns 1 because one channel has become ready, and you call select() one more time, and one more channel has become ready, it will return 1 again.","(""SELECT"", ""The method SELECT is called multiple times in the text, indicating a repeated action or process."", ""SELECT"")"
"If you have done nothing with the first channel that was ready, you now have 2 ready channels, but only one channel had become ready between each select() call.","(""Select"", ""The method 'Select' is used to determine when a 'Channel' becomes ready."", ""Channel"")"
"Once you have called one of the select() methods and its return value has indicated that one or more channels are ready, you can access the ready channels via the ""selected key set"", by calling the selectors selectedKeys() method.","(""select()"", ""The select() method is used to determine which channels are ready, and the selectedKeys() method is used to access those ready channels."", ""selectedKeys()"")"
When you register a channel with a Selector the Channel.register() method returns a SelectionKey object.,"(""Channel"", ""The Channel.register() is a method of the Channel class."", ""Channel.register()""); (""Channel.register()"", ""The Channel.register() method returns a SelectionKey object."", ""SelectionKey""); (""Channel"", ""A channel is registered with a Selector."", ""Selector"")"
It is these keys you can access via the selectedKeySet() method.,"(""SELECTEDKEYSET"", ""METHOD"")"
"The channel returned by the SelectionKey.channel() method should be cast to the channel you need to work with, e.g a ServerSocketChannel or SocketChannel etc.","(""SelectionKey"", ""The channel method is part of the SelectionKey class, as indicated by the SelectionKey.channel() syntax."", ""channel""); (""channel"", ""The channel method can return a ServerSocketChannel, as suggested by the example usage."", ""ServerSocketChannel""); (""channel"", ""The channel method can return a SocketChannel, as suggested by the example usage."", ""SocketChannel"")"
"A thread that has called the select() method which is blocked, can be made to leave the select() method, even if no channels are yet ready.","(""Select"", ""The text mentions a thread calling the select() method, indicating a relationship between the method and its invocation context."", ""Select"")"
This is done by having a different thread call the Selector.wakeup() method on the Selector which the first thread has called select() on.,"(""Selector"", ""The wakeup method is called on the Selector class."", ""wakeup""); (""Selector"", ""The select method is called on the Selector class."", ""select"")"
"If a different thread calls wakeup() and no thread is currently blocked inside select(), the next thread that calls select() will ""wake up"" immediately.","(""wakeup"", ""The method wakeup() is related to the method select() because wakeup() affects the behavior of threads that are blocked inside select()."", ""select""); (""select"", ""The method select() is related to the method wakeup() because select() is influenced by the wakeup() method when a thread calls it."", ""wakeup"")"
When you are finished with the Selector you call its close() method.,"(""Selector"", ""The close() method is called on the Selector class, indicating a relationship where the method is used to perform an action on the class."", ""close()"")"
Listening for incoming connections is done by calling the ServerSocketChannel.accept() method.,"(""ServerSocketChannel"", ""The accept method is called on the ServerSocketChannel class to listen for incoming connections."", ""accept"")"
"When the accept() method returns, it returns a SocketChannel with an incoming connection.","(""ACCEPT"", ""The ACCEPT method returns a SOCKETCHANNEL, indicating a direct relationship where the method provides an instance of the class."", ""SOCKETCHANNEL"")"
"Since you are typically not interested in listening just for a single connection, you call the accept() inside a while-loop.","(""accept"", ""The method 'accept' is called inside a 'while-loop' to handle multiple connections."", ""while-loop"")"
"In non-blocking mode the accept() method returns immediately, and may thus return null, if no incoming connection had arrived.","(""Accept"", ""The text explicitly mentions the 'accept()' method, indicating that 'Accept' is a method."", ""Method"")"
You close a SocketChannel after use by calling the SocketChannel.close() method.,"(""SocketChannel"", ""The close method is used to close a SocketChannel after use."", ""close"")"
To read data from a SocketChannel you call one of the read() methods.,"(""SocketChannel"", ""The read() method is used to read data from a SocketChannel."", ""read"")"
The int returned by the read() method tells how many bytes were witten into the Buffer.,"(""READ"", ""The READ method interacts with the BUFFER class by writing bytes into it."", ""BUFFER"")"
"Writing data to a SocketChannel is done using the SocketChannel.write() method, which takes a Buffer as parameter.","(""SocketChannel"", ""The write method is used to perform operations on the SocketChannel class."", ""write""); (""write"", ""The write method takes a Buffer as a parameter."", ""Buffer"")"
There is no guarantee of how many bytes the write() method writes to the SocketChannel.,"(""Write"", ""The write method is used to write bytes to the SocketChannel class."", ""SocketChannel"")"
"When you do so, you can call connect(), read() and write() in asynchronous mode.","(""Connect"", ""Connect and Read are related as they are both methods that can be called in asynchronous mode."", ""Read""); (""Connect"", ""Connect and Write are related as they are both methods that can be called in asynchronous mode."", ""Write""); (""Read"", ""Read and Write are related as they are both methods that can be called in asynchronous mode."", ""Write"")"
"If the SocketChannel is in non-blocking mode, and you call connect(), the method may return before a connection is established.","(""SocketChannel"", ""The method 'connect' is called on the 'SocketChannel' class."", ""connect"")"
"To determine whether the connection is established, you can call the finishConnect() method, like this:","(""FINISHCONNECT"", ""The finishConnect() method is used to determine whether the connection is established."", ""CONNECTION"")"
In non-blocking mode the write() method may return without having written anything.,"(""WRITE"", ""The term 'write()' is identified as a method due to its context and syntax."", ""METHOD"")"
Therefore you need to call the write() method in a loop.,"(""WRITE"", ""The WRITE method is called within a LOOP, indicating a functional relationship where the method is executed repeatedly."", ""LOOP"")"
In non-blocking mode the read() method may return without having read any data at all.,"(""READ"", ""The text specifies that 'read' is a method, indicating a relationship between the entity 'read' and the entity type 'method'."", ""METHOD"")"
"Also, parts of the NIO APIs are actually blocking - e.g.","(""NIO"", ""package"")"
"A selector is an object that can monitor multiple channels for events (like: connection opened, data arrived etc.).","(""Selector"", ""A selector monitors multiple channels for events."", ""Channel"")"
"That means, that when a thread invokes a read() or write(), that thread is blocked until there is some data to read, or the data is fully written.","(""Read"", ""Both Read and Write are methods that involve thread operations related to data handling."", ""Write"")"
Rather than just read the data byte for byte from e.g.,NULL
"In other words, once the first reader.readLine() method returns, you know for sure that a full line of text has been read.","(""Reader"", ""The ReadLine method is a function that is called on the Reader class to read a line of text."", ""ReadLine"")"
"The readLine() blocks until a full line is read, that's why.","(""readLine"", ""The readLine is a method because it is described as performing an action, specifically blocking until a full line is read."", ""method"")"
"Similarly, when the second readLine() call returns, you know that this line contains the age etc.","(""readLine"", ""The text refers to the second call of the readLine method, indicating a sequence or repeated use of the same method."", ""readLine"")"
"The bufferFull() method has to keep track of how much data is read into the buffer, and return either true or false, depending on whether the buffer is full.","(""BufferFull"", ""The BufferFull method is related to the buffer as it keeps track of how much data is read into the buffer."", ""Buffer"")"
"The bufferFull() method scans through the buffer, but must leave the buffer in the same state as before the bufferFull() method was called.","(""BUFFERFULL"", ""The BUFFERFULL method operates on the BUFFER class by scanning through it."", ""BUFFER"")"
"Similarly, if you need to keep a lot of open connections to other computers, e.g.",NULL
"If you have fewer connections with very high bandwidth, sending a lot of data at a time, perhaps a classic IO server implementation might be the best fit.",NULL
Using Java Reflection you can access the annotations attached to Java classes at runtime.,"(""Java Reflection"", ""Java Reflection can be used to access annotations at runtime."", ""annotations""); (""Java Reflection"", ""Java Reflection can access Java classes at runtime."", ""Java classes"")"
"You can also specify METHOD or FIELD, or you can leave the target out alltogether so the annotation can be used for both classes, methods and fields.","(""METHOD"", ""The METHOD is a target that can be specified for the annotation."", ""annotation""); (""FIELD"", ""The FIELD is a target that can be specified for the annotation."", ""annotation""); (""annotation"", ""The annotation can be used for methods."", ""METHOD""); (""annotation"", ""The annotation can be used for fields."", ""FIELD""); (""annotation"", ""The annotation can be used for classes."", ""classes"")"
"You can access the annotations of a class, method or field at runtime.","(""Class"", ""Both Class and Method can have annotations that can be accessed at runtime."", ""Method"")"
"Notice how the Method.getParameterAnnotations() method returns a two-dimensional Annotation array, containing an array of annotations for each method parameter.","(""Method.getParameterAnnotations()"", ""The Method.getParameterAnnotations() method returns an array of Annotation objects, indicating a relationship where the method provides instances of the class."", ""Annotation"")"
This text will discuss how to both create arrays and get their class objects via Java Reflection.,"(""Arrays"", ""Java Reflection is used to get class objects of arrays."", ""Java Reflection"")"
Working with arrays via Java Reflection is done using the java.lang.reflect.Array class.,"(""Array"", ""The Array class is part of the java.lang.reflect package, which provides classes for working with Java Reflection."", ""java.lang.reflect"")"
"Do not confuse this class with the java.util.Arrays class in the Java Collections suite, which contains utility methods for sorting arrays, converting them to collections etc.","(""Java.util.Arrays"", ""The Java.util.Arrays class is part of the Java Collections package."", ""Java Collections""); (""Sorting"", ""The Sorting method is a utility method contained within the Java.util.Arrays class."", ""Java.util.Arrays""); (""Converting"", ""The Converting method is a utility method contained within the Java.util.Arrays class."", ""Java.util.Arrays"")"
Creating arrays via Java Reflection is done using the java.lang.reflect.Array class.,"(""Java Reflection"", ""The Java.lang.reflect.Array class is used within the Java Reflection package to create arrays."", ""Java.lang.reflect.Array"")"
The first parameter int.class given to the Array.newInstance() method tells what type each element in the array should be of.,"(""NEWINSTANCE"", ""The method NEWINSTANCE uses INT.CLASS as a parameter to specify the type of elements in the array."", ""INT.CLASS""); (""NEWINSTANCE"", ""The method NEWINSTANCE is used to create an instance of the ARRAY class."", ""ARRAY"")"
"For instance, you can access the primitive int array class object like this:","(""INT ARRAY"", ""CLASS"")"
The [ on the left means it is the class of an int array I am interested in.,"(""int array"", ""The text indicates that 'int array' is a class."", ""class"")"
"Notice the [L to the left of the class name, and the ; to the right.","(""L"", ""The 'L' is mentioned as being to the left of the class name, indicating a positional relationship."", ""class name""); (""class name"", ""The ';' is mentioned as being to the right of the class name, indicating a positional relationship."", "";"")"
"As a side note, you cannot obtain the class object of primitives using Class.forName().","(""Class"", ""The method forName is associated with the class Class as it is used to obtain class objects."", ""forName"")"
I usually do something like this to obtain the class name for primitives as well as objects:,"(""Class"", ""class"")"
"The solution, or workaround as you might call it, is to create an empty array of the desired type and obtain the class object from that empty array.","(""Create"", ""The method 'Create' is used to obtain the class object from an empty array."", ""Class"")"
"This presents a single, uniform method to access the array class of arrays of any type.","(""Method"", ""The method is used to access the array class."", ""Array"")"
"To make sure that the Class object really is an array, you can call the Class.isArray() method to check:","(""Class"", ""The isArray method is called on the Class object to check if it is an array."", ""isArray"")"
Once you have obtained the Class object for an array you can access its component type via the Class.getComponentType() method.,"(""Class"", ""The Class.getComponentType() method is used to access the component type of a Class object."", ""Class.getComponentType()"")"
"For instance, the component type of an int[] array is the int.class Class object.","(""int[]"", ""The int[] array has a component type which is represented by the int.class Class object."", ""int.class"")"
The component type of a String[] array is the java.lang.String Class object.,"(""String[]"", ""The component type of the String[] array is the java.lang.String class object."", ""java.lang.String"")"
"This example will print out the text ""java.lang.String"" which is the component type of the String array.","(""Java.Lang.String"", ""Java.Lang.String is the component type of the String array."", ""String"")"
Inspecting classes is often the first thing you do when using Reflection.,"(""Classes"", ""Classes are often inspected using the Reflection package."", ""Reflection"")"
For a full list you should consult the JavaDoc for java.lang.Class.,"(""JavaDoc"", ""JavaDoc provides documentation for the java.lang.Class."", ""java.lang.Class"")"
Before you can do any inspection on a class you need to obtain its java.lang.Class object.,"(""Class"", ""The Class is related to java.lang.Class because it refers to obtaining the java.lang.Class object for inspection."", ""java.lang.Class"")"
"All types in Java including the primitive types (int, long, float etc.)","(""Java"", ""int is a primitive type in the Java programming language."", ""int""); (""Java"", ""long is a primitive type in the Java programming language."", ""long""); (""Java"", ""float is a primitive type in the Java programming language."", ""float"")"
If you know the name of the class at compile time you can obtain a Class object like this:,"(""Class"", ""The text describes obtaining a Class object, indicating a relationship between the concept of a class and the Class object itself."", ""Class"")"
"If you don't know the name at compile time, but have the class name as a string at runtime, you can do like this:","(""Class"", ""The class name is used at runtime to dynamically access methods."", ""Method"")"
String className = ... //obtain class name as string at runtime Class class = Class.forName(className);,"(""Class"", ""The method 'forName' is used to obtain a 'Class' object based on the class name provided as a string."", ""forName"")"
When using the Class.forName() method you must supply the fully qualified class name.,"(""Class"", ""The forName method is a method of the Class class."", ""forName"")"
The Class.forName() method may throw a ClassNotFoundException if the class cannot be found on the classpath at runtime.,"(""Class"", ""The forName method is a static method of the Class class."", ""forName""); (""forName"", ""The forName method may throw a ClassNotFoundException if the class cannot be found."", ""ClassNotFoundException"")"
The fully qualified class name (including package name) is obtained using the getName() method like this:,"(""Class"", ""The class is associated with the package as it is part of the fully qualified class name."", ""Package""); (""Class"", ""The getName() method is used to obtain the fully qualified class name."", ""GetName"")"
"If you want the class name without the pacakge name you can obtain it using the getSimpleName() method, like this:","(""Class"", ""The GetSimpleName method is used to obtain the class name without the package name."", ""GetSimpleName"")"
You can access the modifiers of a class via the Class object.,"(""Class"", ""The Class object is used to access the modifiers of a class."", ""Class"")"
You can check the modifiers using these methods in the class java.lang.reflect.Modifier:,"(""MODIFIERS"", ""The method 'MODIFIERS' is used within the class 'JAVA.LANG.REFLECT.MODIFIER' to check the modifiers."", ""JAVA.LANG.REFLECT.MODIFIER"")"
You can also access information specified for this package in the Manifest file of the JAR file this package is located in on the classpath.,"(""Manifest"", ""The Manifest file is located within the JAR package."", ""JAR""); (""JAR"", ""The JAR package is located on the classpath."", ""classpath"")"
From the Class object you can access the superclass of the class.,"(""Class"", ""The Class object can access the Superclass, indicating a relationship between them."", ""Superclass"")"
"The superclass class object is a Class object like any other, so you can continue doing class reflection on that too.","(""Class"", ""The text refers to the superclass as a Class object, indicating a relationship between the concept of a superclass and the Class entity."", ""Class"")"
It is possible to get a list of the interfaces implemented by a given class.,"(""Class"", ""A class can implement multiple interfaces, which is why the text mentions getting a list of interfaces implemented by a class."", ""Interfaces"")"
NOTE: Only the interfaces specifically declared implemented by a given class is returned.,"(""CLASS"", ""The CLASS entity is related to the INTERFACES entity because the text mentions that interfaces are implemented by a class."", ""INTERFACES"")"
"If a superclass of the class implements an interface, but the class doesn't specifically state that it also implements that interface, that interface will not be returned in the array.","(""CLASS"", ""The CLASS may implement the INTERFACE if its superclass does, but it is not explicitly stated in the CLASS."", ""INTERFACE"")"
"Even if the class in practice implements that interface, because the superclass does.","(""CLASS"", ""The CLASS implements the INTERFACE."", ""INTERFACE""); (""CLASS"", ""The CLASS is related to the SUPERCLASS as it is mentioned in the context of implementation."", ""SUPERCLASS"")"
To get a complete list of the interfaces implemented by a given class you will have to consult both the class and its superclasses recursively.,"(""Class"", ""A class is related to its superclasses because it can inherit properties and methods from them."", ""Superclasses""); (""Class"", ""A class can implement interfaces, which define methods that the class must provide."", ""Interfaces"")"
You can access the fields (member variables) of a class like this:,"(""Class"", ""class"")"
You can access the class annotations of a class like this:,"(""Class Annotations"", ""The class annotations are a feature or attribute of the class."", ""Class"")"
Using Java Reflection you can inspect the constructors of classes and instantiate objects at runtime.,"(""Java Reflection"", ""Java Reflection allows you to inspect the constructors of classes."", ""constructors""); (""Java Reflection"", ""Java Reflection is used to inspect and instantiate objects of classes at runtime."", ""classes"")"
The Constructor[] array will have one Constructor instance for each public constructor declared in the class.,"(""Constructor[]"", ""Constructor[] is an array that contains instances of the Constructor class."", ""Constructor""); (""Constructor"", ""Constructor is a type of class."", ""class"")"
This example returns the public constructor of the given class which takes a String as parameter:,"(""Constructor"", ""The constructor is a method that belongs to the class and is used to create instances of the class."", ""Class""); (""Constructor"", ""The constructor takes a String as a parameter, indicating a relationship where the String is used as an input to the constructor."", ""String"")"
"If no constructor matches the given constructor arguments, in this case String.class, a NoSuchMethodException is thrown.","(""String"", ""A NoSuchMethodException is thrown when no constructor matches the given constructor arguments, which includes String.class."", ""NoSuchMethodException"")"
"The Constructor.newInstance() method takes an optional amount of parameters, but you must supply exactly one parameter per argument in the constructor you are invoking.","(""Constructor"", ""The newInstance method is a part of the Constructor class, as it is invoked on a Constructor object."", ""newInstance"")"
"It is possible to load and reload classes at runtime in Java, though it is not as straightforward as one might have hoped.","(""Java"", ""Java is the programming language in which classes are loaded and reloaded at runtime."", ""classes"")"
This text will explain when and how you can load and reload classes in Java.,"(""Java"", ""Classes are a fundamental part of the Java package, as they define the structure and behavior of objects in Java."", ""classes"")"
"You can argue whether Java's dynamic class loading features are really part of Java Reflection, or a part of the core Java platform.","(""Java"", ""Java is a class that is part of the Java Reflection package, which provides dynamic class loading features."", ""Java Reflection""); (""Java Reflection"", ""Java Reflection includes features that involve dynamic class loading, which is related to the Java class."", ""Java"")"
All classes in a Java application are loaded using some subclass of java.lang.ClassLoader.,"(""Java Application"", ""Classes are components within a Java application."", ""Class""); (""Java.lang.ClassLoader"", ""Java.lang.ClassLoader is used to load classes."", ""Class"")"
Loading classes dynamically must therefore also be done using a java.lang.ClassLoader subclass.,"(""ClassLoader"", ""ClassLoader is a subclass that is part of the java.lang package, which is used for loading classes dynamically."", ""java.lang"")"
"When a class is loaded, all classes it references are loaded too.","(""Class"", ""A class references other classes, which are also loaded when the class is loaded."", ""Class"")"
"This class loading pattern happens recursively, until all classes needed are loaded.","(""Class"", ""class"")"
Unreferenced classes are not loaded until the time they are referenced.,"(""Unreferenced classes"", ""Unreferenced classes are related to time because they are not loaded until they are referenced at a specific time."", ""time"")"
"If a ClassLoader is asked to load a class, it will ask its parent class loader to load it.","(""ClassLoader"", ""A ClassLoader is responsible for loading a class."", ""class"")"
"If the parent class loader can't find the class, the child class loader then tries to load it itself.","(""Parent Class Loader"", ""The Parent Class Loader is responsible for attempting to find the Class first."", ""Class""); (""Child Class Loader"", ""If the Parent Class Loader cannot find the Class, the Child Class Loader attempts to load it."", ""Class"")"
The steps a given class loader uses when loading classes are:,"(""Class Loader"", ""A class loader is responsible for loading classes."", ""Classes"")"
When you implement a class loader that is capable of reloading classes you will need to deviate a bit from this sequence.,"(""Class Loader"", ""A class loader is responsible for loading classes, indicating a direct relationship between the two."", ""Classes"")"
The classes to reload should not be requested loaded by the parent class loader.,"(""Class"", ""class"")"
All you need to do is to obtain a ClassLoader and call its loadClass() method.,"(""ClassLoader"", ""The loadClass method is a function that is called on the ClassLoader class."", ""loadClass"")"
Java's builtin Class loaders always checks if a class is already loaded before loading it.,"(""Class Loaders"", ""Class Loaders are responsible for loading Class objects in Java."", ""Class"")"
Reloading the class is therefore not possible using Java's builtin class loaders.,"(""Class"", ""The class is mentioned in the context of Java's class loaders, indicating a relationship between the class and the Java package."", ""Java"")"
To reload a class you will have to implement your own ClassLoader subclass.,"(""ClassLoader"", ""Subclass is a type of ClassLoader, indicating an inheritance relationship."", ""Subclass""); (""Class"", ""ClassLoader is used to load or reload a Class, indicating a functional relationship."", ""ClassLoader"")"
Even with a custom subclass of ClassLoader you have a challenge.,"(""subclass"", ""A subclass is a type of class that extends or inherits from another class, in this case, ClassLoader."", ""ClassLoader"")"
"This method is final, and thus cannot be overridden in your ClassLoader subclass.","(""Method"", ""The method is mentioned in the context of being overridden in a ClassLoader subclass."", ""ClassLoader""); (""ClassLoader"", ""Subclass is a type of ClassLoader, as it is mentioned in the context of being a subclass of ClassLoader."", ""Subclass"")"
The resolve() method will not allow any given ClassLoader instance to link the same class twice.,"(""resolve"", ""The resolve method is related to the ClassLoader class as it operates on instances of ClassLoader to manage class linking."", ""ClassLoader"")"
"Therefore, everytime you want to reload a class you must use a new instance of your ClassLoader subclass.","(""ClassLoader"", ""ClassLoader is used to load and reload instances of Class"", ""Class"")"
"This is not impossible, but necessary to know when designing for class reloading.","(""Class"", ""class"")"
As stated earlier you cannot reload a class using a ClassLoader that has already loaded that class once.,"(""ClassLoader"", ""ClassLoader is used to load classes, indicating a relationship between the ClassLoader and the class it loads."", ""class"")"
Therefore you will have to reload the class using a different ClassLoader instance.,"(""ClassLoader"", ""ClassLoader is a type of class used to load other classes."", ""class"")"
"Every class loaded in a Java application is identified by its fully qualified name (package name + class name), and the ClassLoader instance that loaded it.","(""Package"", ""A class is identified by its fully qualified name, which includes the package name."", ""Class""); (""ClassLoader"", ""A ClassLoader instance is responsible for loading a class."", ""Class"")"
"That means, that a class MyObject loaded by class loader A, is not the same class as the MyObject class loaded with class loader B.","(""MyObject"", ""The class MyObject is loaded by class loader A."", ""A""); (""MyObject"", ""The class MyObject is loaded by class loader B."", ""B"")"
"Notice how the MyObject class is referenced in the code, as the type of the object variable.","(""MyObject"", ""The MyObject class is referenced as the type of the object variable in the code."", ""object variable"")"
This causes the MyObject class to be loaded by the same class loader that loaded the class this code is residing in.,"(""MyObject"", ""The MyObject class is loaded by the class loader."", ""class loader"")"
"If the myClassReloadingFactory object factory reloads the MyObject class using a different class loader than the class the above code resides in, you cannot cast the instance of the reloaded MyObject class to the MyObject type of the object variable.","(""MyClassReloadingFactory"", ""The MyClassReloadingFactory is responsible for reloading the MyObject class using a different class loader."", ""MyObject"")"
"Since the two MyObject classes were loaded with different class loaders, the are regarded as different classes, even if they have the same fully qualified class name.","(""MyObject"", ""MyObject classes are loaded with different class loaders, which affects their identity."", ""class loaders"")"
Trying to cast an object of the one class to a reference of the other will result in a ClassCastException.,"(""ClassCastException"", ""ClassCastException is a type of exception class that occurs when an object is improperly cast to a class."", ""class"")"
"Either of these two methods will work if the type of the variable, the interface or superclass, is not reloaded when the implementing class or subclass is reloaded.","(""METHOD"", ""The method is related to the variable as it is one of the two methods mentioned."", ""VARIABLE""); (""INTERFACE"", ""The interface or superclass is related as they are both types of the variable."", ""SUPERCLASS""); (""IMPLEMENTING CLASS"", ""The implementing class or subclass is related as they are both mentioned in the context of being reloaded."", ""SUBCLASS"")"
To make this work you will of course need to implement your class loader to let the interface or superclass be loaded by its parent.,"(""Class Loader"", ""The class loader is responsible for loading the interface."", ""Interface""); (""Class Loader"", ""The class loader is responsible for loading the superclass."", ""Superclass"")"
"When your class loader is asked to load the MyObject class, it will also be asked to load the MyObjectInterface class, or the MyObjectSuperclass class, since these are referenced from within the MyObject class.","(""MyObject"", ""The MyObject class references the MyObjectInterface class, indicating a relationship between them."", ""MyObjectInterface""); (""MyObject"", ""The MyObject class references the MyObjectSuperclass class, indicating a relationship between them."", ""MyObjectSuperclass"")"
Your class loader must delegate the loading of those classes to the same class loader that loaded the class containing the interface or superclass typed variables.,"(""Class Loader"", ""The class loader is responsible for loading the class."", ""Class""); (""Class"", ""The class may contain interface typed variables."", ""Interface""); (""Class"", ""The class may contain superclass typed variables."", ""Superclass"")"
Notice how it delegates class loading to its parent except for the one class it is intended to be able to reload.,"(""Class"", ""The class delegates loading to its parent, indicating a hierarchical relationship."", ""Parent"")"
"If the loading of this class is delegated to the parent class loader, it cannot be reloaded later.","(""Class"", ""The class loading is delegated to the parent class loader, indicating a relationship between the class and the parent class loader."", ""Parent Class Loader"")"
"Remember, a class can only be loaded once by the same ClassLoader instance.","(""ClassLoader"", ""ClassLoader is an instance that loads a class"", ""class"")"
It is not a production ready template for your own class loaders.,"(""Class Loaders"", ""class"")"
"Your own class loaders should probably not be limited to a single class, but a collection of classes that you know you will need to reload.","(""Class Loaders"", ""Class Loaders are responsible for loading classes."", ""Class"")"
"In addition, you should probably not hardcode the class paths either.","(""Class"", ""class"")"
Here is the reflection.MyObject class that is loaded using the class loader.,"(""Reflection.MyObject"", ""The Reflection.MyObject class is loaded using the class loader."", ""Class Loader"")"
Notice how it both extends a superclass and implements an interface.,"(""Superclass"", ""The text indicates that a class extends a superclass and implements an interface, suggesting a relationship between the two."", ""Interface"")"
The name of this class is why I refer to these dynamic interface implementations as dynamic proxies.,"(""Class"", ""The text refers to the class as being related to dynamic proxies through dynamic interface implementations."", ""dynamic proxies"")"
As mentioned earlier you must pass an InvocationHandler implementation to the Proxy.newProxyInstance() method.,"(""Proxy"", ""The newProxyInstance is a method of the Proxy class."", ""newProxyInstance""); (""InvocationHandler"", ""The newProxyInstance method requires an InvocationHandler implementation to be passed to it."", ""newProxyInstance"")"
The proxy parameter passed to the invoke() method is the dynamic proxy object implementing the interface.,"(""invoke"", ""The proxy parameter is passed to the invoke() method, indicating a relationship where the method uses the proxy."", ""proxy"")"
The Method object passed into the invoke() method represents the method called on the interface the dynamic proxy implements.,"(""Method"", ""The Method object is passed into the invoke() method, indicating a relationship where the Method is used by the invoke method."", ""invoke""); (""dynamic proxy"", ""The dynamic proxy implements the interface, indicating a relationship where the dynamic proxy is a specific implementation of the interface."", ""interface"")"
"But now you can check via the mock if the DAO uses the connection properly, for instance if the connection.close() is called (or NOT called), if you expected that.","(""connection"", ""The method 'close' is called on the 'connection' class, indicating a relationship where 'close' is a method of 'connection'."", ""close""); (""DAO"", ""The 'DAO' class uses the 'connection' class, indicating a relationship where 'DAO' interacts with 'connection'."", ""connection"")"
Thus the factory interface and your class could look something like this:,"(""Factory Interface"", ""The Factory Interface is related to the Class as it defines the structure or blueprint that the Class implements."", ""Class"")"
"When the MyAction class calls methods on the IMyFactory instance injected into its constructor by the container, the method calls are translated into calls to the IContainer.instance() method, which is the method you use to obtain instances from the container.","(""MyAction"", ""The MyAction class calls methods on the IMyFactory instance."", ""IMyFactory""); (""IMyFactory"", ""Methods on the IMyFactory instance are translated into calls to the IContainer.instance() method."", ""IContainer""); (""IContainer"", ""The instance method is used to obtain instances from the IContainer class."", ""instance"")"
Using Java Reflection you can inspect the fields (member variables) of classes and get / set them at runtime.,"(""Java Reflection"", ""Java Reflection allows inspection of fields at runtime."", ""fields""); (""Java Reflection"", ""Java Reflection can inspect classes and their fields."", ""classes"")"
The Field[] array will have one Field instance for each public field declared in the class.,"(""Field"", ""The Field[] array contains Field instances, indicating a relationship between the class and method entities."", ""Field"")"
"If no field exists with the name given as parameter to the getField() method, a NoSuchFieldException is thrown.","(""GETFIELD"", ""The GETFIELD method throws a NOSUCHFIELDEXCEPTION if no field exists with the given name."", ""NOSUCHFIELDEXCEPTION"")"
"Once you have obtained a Field instance, you can get its field name using the Field.getName() method, like this:","(""Field"", ""The getName method is used to retrieve the field name from a Field instance."", ""getName"")"
"Once you have obtained a Field reference you can get and set its values using the Field.get() and Field.set()methods, like this:","(""Field"", ""The 'get' method is used to retrieve values from a Field object."", ""get""); (""Field"", ""The 'set' method is used to assign values to a Field object."", ""set"")"
The objectInstance parameter passed to the get and set method should be an instance of the class that owns the field.,"(""OBJECTINSTANCE"", ""The OBJECTINSTANCE parameter is passed to the GET method."", ""GET""); (""OBJECTINSTANCE"", ""The OBJECTINSTANCE parameter is passed to the SET method."", ""SET""); (""CLASS"", ""The OBJECTINSTANCE should be an instance of the CLASS that owns the field."", ""OBJECTINSTANCE""); (""GET"", ""The GET method is related to the CLASS as it operates on its instance."", ""CLASS""); (""SET"", ""The SET method is related to the CLASS as it operates on its instance."", ""CLASS"")"
"In the above example an instance of MyObject is used, because the someField is an instance member of the MyObject class.","(""MyObject"", ""someField is an instance member of the MyObject class"", ""someField"")"
"It the field is a static field (public static ...) pass null as parameter to the get and set methods, instead of the objectInstance parameter passed above.","(""GET"", ""Both GET and SET are methods mentioned in the context of handling static fields."", ""SET"")"
When you write a class or interface you can specify that it should be paramerizable.,"(""Class"", ""A class or interface can be parameterizable, indicating a relationship between the two."", ""Interface"")"
"Rather than create a list of Object you can parameterize java.util.List to create a list of say String, like this:","(""java.util.List"", ""java.util.List is parameterized to create a list of Object."", ""Object""); (""java.util.List"", ""java.util.List is parameterized to create a list of String."", ""String"")"
"When inspecting a parameterizable type itself at runtime via reflection, like java.util.List, there is no way of knowing what type is has been parameterized to.","(""Java.Util.List"", ""Java.Util.List is a class within the Java.Util package"", ""Java.Util"")"
If you have obtained a java.lang.reflect.Method object it is possible to obtain information about its generic return type.,"(""Method"", ""The Method class is part of the java.lang.reflect package, which provides classes for obtaining reflective information about classes and objects."", ""java.lang.reflect""); (""Method"", ""The Method class can provide information about its generic return type, which is a feature of the method."", ""generic return type"")"
Here is an example class with a method having a parameterized return type:,"(""Example Class"", ""The method is part of the example class."", ""Method"")"
In this class it is possible to obtain the generic return type of the getStringList() method.,"(""Class"", ""The method getStringList() is mentioned as part of the class, indicating a relationship where the method belongs to or is defined within the class."", ""GetStringList"")"
"In other words, it is possible to detect that getStringList() returns a List<String> and not just a List.","(""getStringList"", ""The method getStringList() returns a List<String>, indicating a relationship where the method provides an instance of this class."", ""List<String>""); (""getStringList"", ""The method getStringList() returns a List, indicating a relationship where the method provides an instance of this class."", ""List"")"
"This piece of code will print out the text ""typeArgClass = java.lang.String"".","(""TypeArgClass"", ""The text indicates that TypeArgClass is associated with the Java.Lang.String class."", ""Java.Lang.String"")"
The Type[] array typeArguments array will contain one item - a Class instance representing the class java.lang.String.,"(""Type[]"", ""The Type[] array is related to typeArguments as it contains the typeArguments array."", ""typeArguments""); (""Class"", ""The Class instance represents the class java.lang.String."", ""java.lang.String"")"
Here is an example class with a method taking a parameterized List as parameter:,"(""Class"", ""The Method is a part of the Class, as it is described as a method within the class."", ""Method"")"
The Type[] array parameterArgTypes array will contain one item - a Class instance representing the class java.lang.String.,"(""Type[]"", ""The Type[] array is related to parameterArgTypes as it is described as an array parameter."", ""parameterArgTypes""); (""Class"", ""The Class instance represents the class java.lang.String."", ""java.lang.String"")"
Fields are class member variables - either static or instance variables.,"(""Fields"", ""Fields are described as class member variables, indicating a relationship between the two."", ""class"")"
The Type[] array fieldArgTypes array will contain one item - a Class instance representing the class java.lang.String.,"(""Type[]"", ""The Type[] array is related to fieldArgTypes as it is described as containing items."", ""fieldArgTypes""); (""Class"", ""The Class instance represents the class java.lang.String."", ""java.lang.String"")"
Using Java Reflection you can inspect the methods of classes and invoke them at runtime.,"(""Java Reflection"", ""Java Reflection allows you to inspect methods."", ""methods""); (""Java Reflection"", ""Java Reflection allows you to inspect classes."", ""classes""); (""methods"", ""Methods are part of classes."", ""classes"")"
This can be used to detect what getters and setters a given class has.,"(""Class"", ""Getters are methods that retrieve the value of a class's attribute."", ""getters""); (""Class"", ""Setters are methods that set or update the value of a class's attribute."", ""setters"")"
"You cannot ask for getters and setters explicitly, so you will have to scan through all the methods of a class and check if each method is a getter or setter.","(""METHODS"", ""Methods are part of a class and need to be scanned to identify getters and setters."", ""CLASS""); (""GETTERS AND SETTERS"", ""Getters and setters are specific types of methods."", ""METHODS"")"
Here is a code example that finds getter and setters of a class:,"(""getter"", ""Getter is a method that retrieves the value of a field in a class."", ""class""); (""setter"", ""Setter is a method that sets the value of a field in a class."", ""class"")"
The Method[] array will have one Method instance for each public method declared in the class.,"(""Method[]"", ""Method[] is an array that contains instances of the Method class."", ""Method""); (""Method"", ""Method is a public method declared in the class."", ""class"")"
"This example returns the public method named ""doSomething"", in the given class which takes a String as parameter:","(""doSomething"", ""The method 'doSomething' takes a 'String' as a parameter, indicating a relationship between the method and the class."", ""String"")"
"If no method matches the given method name and arguments, in this case String.class, a NoSuchMethodException is thrown.","(""String"", ""The NoSuchMethodException is thrown when no method matches the given method name and arguments, which includes the String class."", ""NoSuchMethodException"")"
"In this example, if doSomething(String.class) is not static, you need to supply a valid MyObject instance instead of null;","(""doSomething"", ""The method doSomething takes String as a parameter."", ""String""); (""doSomething"", ""The method doSomething requires an instance of MyObject if it is not static."", ""MyObject"")"
"The Method.invoke(Object target, Object ... parameters) method takes an optional amount of parameters, but you must supply exactly one parameter per argument in the method you are invoking.","(""Method.invoke"", ""The Method.invoke is a specific method that is being described in the text."", ""Method"")"
This Java module reflection tutorial will explain how to access the Java Module a Java class belongs to via Java reflection.,"(""Java class"", ""A Java class belongs to a Java Module, indicating a relationship of containment or membership."", ""Java Module""); (""Java Module"", ""Java reflection is used to access the Java Module, indicating a relationship of interaction or usage."", ""Java reflection""); (""Java class"", ""Java reflection is used to access the Java Module a Java class belongs to, indicating a relationship of interaction or usage."", ""Java reflection"")"
"Thus, each Java class belongs to a package, and the package belongs to a module.","(""Java"", ""Each Java class belongs to a package."", ""package""); (""package"", ""The package belongs to a module."", ""module"")"
A Java module is represented by the Java reflection class java.lang.Module in the Java module java.base.,"(""Java Reflection Class"", ""The Java reflection class is represented by the Java.lang.Module class."", ""Java.lang.Module""); (""Java.lang.Module"", ""The Java.lang.Module class is part of the Java.base package."", ""Java.base"")"
"Via this class you can interact with the Java Platform Module System to obtain information about a given module, or modify a module.","(""Java Platform Module System"", ""The Java Platform Module System class is used to interact with and obtain or modify information about a module."", ""module"")"
"You can obtain an instance of the Module class via a Class instance, like this:","(""Module"", ""The Module class can be obtained via a Class instance, indicating a relationship between the two classes."", ""Class"")"
You can check if a Module instance a represents a named module by calling the Module isNamed() method.,"(""Module"", ""The isNamed method is called on a Module instance to check if it represents a named module."", ""isNamed"")"
You can check if a Module is a named module via the Module isOpen() method.,"(""Module"", ""The isOpen method is used to check if a Module is a named module."", ""isOpen"")"
Once you have access to a Module instance you can access its ModuleDescriptor via the getDescriptor() method.,"(""Module"", ""The getDescriptor method is used to access the ModuleDescriptor from a Module instance."", ""getDescriptor""); (""getDescriptor"", ""The getDescriptor method returns the ModuleDescriptor."", ""ModuleDescriptor"")"
Here is an example of accessing a Java Module's ModuleDescriptor via getDescriptor() :,"(""getDescriptor"", ""The method getDescriptor is used to access the ModuleDescriptor class."", ""ModuleDescriptor"")"
You can get the name of a named module from its module descriptor via the ModuleDescriptor name() method.,"(""ModuleDescriptor"", ""The name method is a part of the ModuleDescriptor class, used to get the name of a named module."", ""name"")"
"You can read the list of packages exported by a Java module via Java reflection, via the ModuleDescriptor exports() method.","(""ModuleDescriptor"", ""The exports() method is a part of the ModuleDescriptor class, used to read the list of packages exported by a Java module."", ""exports""); (""Java"", ""The ModuleDescriptor class is used in the context of Java reflection to access module information."", ""ModuleDescriptor"")"
You can check if a Java module is an automatic module or not via the ModuleDescriptor isAutomatic() method.,"(""ModuleDescriptor"", ""The isAutomatic() method is a part of the ModuleDescriptor class, used to check if a module is automatic."", ""isAutomatic"")"
You can check if a Java module is an open module or not via the ModuleDescriptor isOpen() method.,"(""ModuleDescriptor"", ""The isOpen method is a part of the ModuleDescriptor class, used to check if a module is open."", ""isOpen"")"
You can read the module service dependencies via the ModuleDescriptor uses() method.,"(""ModuleDescriptor"", ""The uses() method is a part of the ModuleDescriptor class, indicating a relationship where the method is used to read service dependencies."", ""uses"")"
Despite the common belief it is actually possible to access private fields and methods of other classes via Java Reflection.,"(""Java Reflection"", ""Java Reflection allows access to private fields."", ""fields""); (""Java Reflection"", ""Java Reflection allows access to private methods."", ""methods""); (""Java Reflection"", ""Java Reflection can access private fields and methods of other classes."", ""classes"")"
To access a private field you will need to call the Class.getDeclaredField(String name) or Class.getDeclaredFields() method.,"(""Class"", ""The getDeclaredField method is a method of the Class entity, used to access a private field by name."", ""getDeclaredField""); (""Class"", ""The getDeclaredFields method is a method of the Class entity, used to access all private fields."", ""getDeclaredFields"")"
"The methods Class.getField(String name) and Class.getFields() methods only return public fields, so they won't work.","(""Class"", ""The method getField is associated with the class Class as it is a method of this class."", ""getField""); (""Class"", ""The method getFields is associated with the class Class as it is a method of this class."", ""getFields"")"
"Here is a simple example of a class with a private field, and below that the code to access that field via Java Reflection:","(""Class"", ""Java Reflection is used to access the private field of the Class."", ""Java Reflection"")"
"This method only returns fields declared in that particular class, not fields declared in any superclasses.","(""METHOD"", ""The method is associated with the class as it returns fields declared in that particular class."", ""CLASS"")"
"By calling Field.setAcessible(true) you turn off the access checks for this particular Field instance, for reflection only.","(""Field"", ""The method setAcessible is used to modify the access level of the Field class instance."", ""setAcessible"")"
"To access a private method you will need to call the Class.getDeclaredMethod(String name, Class[] parameterTypes) or Class.getDeclaredMethods() method.","(""Class"", ""The getDeclaredMethod method is a method that belongs to the Class class, as it is used to access private methods of a class."", ""getDeclaredMethod""); (""Class"", ""The getDeclaredMethods method is a method that belongs to the Class class, as it is used to access all declared methods of a class."", ""getDeclaredMethods"")"
"The methods Class.getMethod(String name, Class[] parameterTypes) and Class.getMethods() methods only return public methods, so they won't work.","(""Class"", ""The method getMethod is associated with the class Class as it is a method of this class."", ""getMethod""); (""Class"", ""The method getMethods is associated with the class Class as it is a method of this class."", ""getMethods"")"
"Here is a simple example of a class with a private method, and below that the code to access that method via Java Reflection:","(""Class"", ""The method is a part of the class, as it is described as a private method within the class."", ""Method""); (""Method"", ""Java Reflection is used to access the private method, indicating a relationship between the method and the package."", ""Java Reflection"")"
"This code example will print out the text ""returnValue = The Private Value"", which is the value returned by the method getPrivateString() when invoked on the PrivateObject instance created at the beginning of the code sample.","(""GETPRIVATESTRING"", ""The method getPrivateString() is invoked on the PrivateObject instance."", ""PRIVATEOBJECT"")"
"This method only returns methods declared in that particular class, not methods declared in any superclasses.","(""Method"", ""The method is declared within the class."", ""Class""); (""Method"", ""The method is not declared in any superclasses, indicating a relationship of exclusion."", ""Superclasses"")"
"By calling Method.setAcessible(true) you turn off the access checks for this particular Method instance, for reflection only.","(""Method"", ""The method 'setAcessible' is called on the 'Method' class to modify its access checks."", ""setAcessible"")"
"Java Reflection makes it possible to inspect classes, interfaces, fields and methods at runtime, without knowing the names of the classes, methods etc.","(""Java Reflection"", ""Java Reflection allows inspection of classes at runtime."", ""Classes""); (""Java Reflection"", ""Java Reflection allows inspection of methods at runtime."", ""Methods"")"
"It will explain the basics of Java Reflection including how to work with arrays, annotations, generics and dynamic proxies, and do dynamic class loading and reloading.","(""Java Reflection"", ""Java Reflection includes working with arrays."", ""Arrays""); (""Java Reflection"", ""Java Reflection includes working with annotations."", ""Annotations""); (""Java Reflection"", ""Java Reflection includes working with generics."", ""Generics""); (""Java Reflection"", ""Java Reflection includes working with dynamic proxies."", ""Dynamic Proxies""); (""Java Reflection"", ""Java Reflection includes dynamic class loading."", ""Dynamic Class Loading""); (""Java Reflection"", ""Java Reflection includes reloading."", ""Reloading"")"
"It will also show you how to do more specific Java Reflection tasks, like reading all getter methods of a class, or accessing private fields and methods of a class.","(""getter methods"", ""Getter methods are specific methods within a class."", ""class""); (""private fields"", ""Private fields are elements that can be accessed within a class."", ""class"")"
This example obtains the Class object from the class called MyObject.,"(""Class"", ""The Class object is obtained from the class called MyObject."", ""MyObject"")"
"Using the class object the example gets a list of the methods in that class, iterates the methods and print out their names.","(""Class"", ""The class contains methods, and the example involves iterating over these methods to print their names."", ""Method"")"
When using Java reflection the starting point is often a Class object representing some Java class you want to inspect via reflection.,"(""Class"", ""The Class object represents a Java class that you want to inspect via reflection."", ""Java class"")"
"For instance, to obtain the Class object for a class named MyObject you could write:","(""Class"", ""MyObject is an instance of the Class object."", ""MyObject"")"
Now you have a reference to the Class object for the MyObject class.,"(""Class"", ""The Class object is a reference to the MyObject class."", ""MyObject"")"
"Once you have a reference to the Class object representing some class, you can see what fields that class contains.","(""Class"", ""The Class object represents the class, indicating a direct relationship between the two."", ""Class object"")"
Here is an example of accessing fields of a Java class:,"(""Java"", ""The text refers to accessing fields of a Java class, indicating a relationship between Java and class."", ""class"")"
Using Java Reflection it is possible find out what constructors a given Java class contains and what parameters they take etc.,"(""Java Reflection"", ""Java Reflection is used to find out details about a Java class, such as its constructors and parameters."", ""class""); (""Java"", ""Java is the programming language in which the class is defined."", ""class"")"
You can also see what methods a given class has from its Class object.,"(""Class"", ""The Class entity contains or defines the methods."", ""methods""); (""Class object"", ""The Class object is an instance or representation of the Class."", ""Class"")"
Here is an example of accessing the methods a given class via Java reflection:,"(""Java"", ""Java reflection is a technique used to access methods of a class."", ""reflection""); (""reflection"", ""Reflection is used to access methods of a given class."", ""class"")"
You can also use Java reflection to find out what getter and setter methods a class has.,"(""reflection"", ""Reflection can be used to discover getter methods."", ""getter""); (""reflection"", ""Reflection can be used to discover setter methods."", ""setter""); (""class"", ""A class can have getter methods."", ""getter""); (""class"", ""A class can have setter methods."", ""setter"")"
You can even access private fields and methods via Java reflection - even from outside the class that owns the private field or method.,"(""reflection"", ""Reflection allows access to private fields."", ""field""); (""reflection"", ""Reflection allows access to private methods."", ""method""); (""class"", ""Fields are part of a class."", ""field""); (""class"", ""Methods are part of a class."", ""method"")"
"In case a Java class has annotations which are available at runtime, you can access them via Java reflection too.","(""Java"", ""Java class can have annotations."", ""annotations""); (""Java"", ""Java reflection is used to access annotations at runtime."", ""reflection"")"
"For instance, you can determine what type of class the array is an array of.","(""Class"", ""The text discusses determining the type of class that the array is an array of, indicating a relationship between the class and the array."", ""Array"")"
"For instance, if you are introspecting a String array, you can detect that the element type is String by inspecting the array class.","(""array"", ""The array class contains elements of type String, indicating a relationship between the array and the String class."", ""String"")"
"Java reflection has a special Proxy class that can implement a Java Interface dynamically at runtime, rather than at compile time.","(""Proxy"", ""The Proxy class can implement a Java Interface dynamically at runtime."", ""Java Interface"")"
In Java it is possible to dynamically load and also reload classes using a Java ClassLoader.,"(""Java"", ""ClassLoader is a class used within the Java package to load classes dynamically."", ""ClassLoader"")"
"The ClassLoader class is actually not part of the Java Reflection API, but since Java Reflection is often used to achieve ""dynamic"" behaviour (behavioral changes at runtime), and dynamic class loading and reloading kind of fits into this theme, I have decided to include that tutorial in my Java Reflection tutorial.","(""ClassLoader"", ""ClassLoader is mentioned in the context of Java Reflection as it relates to dynamic behavior and class loading, which is a theme in Java Reflection."", ""Java Reflection""); (""Java Reflection"", ""Java Reflection often involves dynamic behavior, and ClassLoader is relevant to this as it deals with dynamic class loading."", ""ClassLoader"")"
Dynamic class loading and reloading is explained in my Java Reflection - Dynamic Class Loading and Reloading tutorial.,"(""Dynamic Class Loading and Reloading"", ""The class 'Dynamic Class Loading and Reloading' is explained in the context of the 'Java Reflection' package."", ""Java Reflection"")"
The Java regex API is located in the java.util.regex package which has been part of standard Java (JSE) since Java 1.4.,"(""Java Regex API"", ""The Java Regex API is located in the java.util.regex package."", ""Java.util.regex"")"
"Although Java regex has been part of standard Java since Java 1.4, this Java regex tutorial covers the Java regex API released with Java 8.","(""Java Regex"", ""Java Regex is a part of the standard Java package."", ""Java""); (""Java Regex"", ""Java Regex has been part of Java since version 1.4."", ""Java 1.4""); (""Java Regex"", ""The tutorial covers the Java Regex API released with Java 8."", ""Java 8"")"
But first I will introduce the core classes of the Java regex API in the following section.,"(""Java"", ""The regex class is part of the Java package, as indicated by the context of the API."", ""regex"")"
The Matcher class is used to match a given regular expression (Pattern instance) against a text multiple times.,"(""Matcher"", ""The Matcher class is used to match a given regular expression, which is an instance of the Pattern class."", ""Pattern"")"
Both the Pattern and Matcher classes are covered in detail in their own texts.,"(""Pattern"", ""Both are classes that are covered in detail in their own texts."", ""Matcher"")"
The third line uses the Pattern.matches() static method to check if the regular expression (pattern) matches the text.,"(""Pattern"", ""The matches method is a static method of the Pattern class."", ""matches"")"
"If the regular expression matches the text, then Pattern.matches() returns true.","(""Pattern"", ""The method 'matches' is associated with the 'Pattern' class, as indicated by the syntax 'Pattern.matches()'."", ""matches"")"
If the regular expression does not match the text Pattern.matches() returns false.,"(""Pattern"", ""The method matches is a member of the class Pattern."", ""matches"")"
"The example does not actually check if the found http:// string is part of a valid URL, with domain name and suffix (.com, .net etc.).",NULL
"Here is another Java regex example which uses the Matcher class to locate multiple occurrences of the substring ""is"" inside a text:","(""Matcher"", ""The Matcher class is part of the Java programming language, which is used for regex operations."", ""Java"")"
The special metacharacter meaning of an escaped metacharacter is ignored - only its actual literal value (e.g.,NULL
Java regular expressions support matching any of a specified set of characters using what is referred to as character classes.,"(""Java"", ""Java supports matching using character classes, indicating a relationship between the package and the class."", ""character classes"")"
"The character class (set of characters to match) is enclosed in the square brackets - the [ae] part of the regular expression, in other words.","(""Character Class"", ""The character class is enclosed in the square brackets as part of the regular expression."", ""Square Brackets"")"
"The character class will match one of the enclosed characters regardless of which, but no mor than one.","(""Character Class"", ""The Character Class is related to Character as it matches one of the enclosed characters."", ""Character"")"
"For instance, the character class [a-z] will match all characters between a lowercase a and a lowercase z, both a and z included.","(""Character"", ""The character class [a-z] defines a range of characters from a to z."", ""a-z"")"
You can have more than one character range within a character class.,"(""Character Class"", ""A character class can contain multiple character ranges within it."", ""Character Range"")"
"For instance, the character class [a-zA-Z] will match all letters between a and z or between A and Z .","(""Character"", ""The character class [a-zA-Z] is used to match all letters between a and z or between A and Z."", ""a-zA-Z"")"
"For instance, the character class [0-9] will match the characters between 0 and 9, both included.","(""Character"", ""The character class [0-9] specifies a range of characters that the class will match."", ""0-9"")"
"If you want to match the square brackets inside a character class, here is how that looks:","(""character class"", ""class"")"
The character class contains the two square brackets escaped (\\[ and \\]).,"(""Character"", ""The Character class contains the Square Brackets class, indicating a containment relationship."", ""Square Brackets"")"
You can match digits of a number with the predefined character class with the code \d.,"(""Digits"", ""Digits are matched using the predefined character class."", ""Class"")"
Matching non-digits can be done with the predefined character class [\D] (uppercase D).,"(""[\D]"", ""The class [\D] is used for matching non-digit characters, as described in the text."", ""Matching non-digits"")"
You can match word characters with the predefined character class with the code \w .,"(""Word Characters"", ""Word Characters are matched using the Predefined Character Class"", ""Predefined Character Class""); (""Predefined Character Class"", ""The Predefined Character Class is represented by the Code \w"", ""Code \w"")"
You can match non-word characters with the predefined character class [\W] (uppercase W).,"(""[\W]"", ""The class [\W] is used to match non-word characters."", ""non-word characters"")"
Here is a regular expression example using the non-word character class:,"(""Non-word Character"", ""The non-word character is a type of character class used in regular expressions."", ""Regular Expression"")"
The Java String class has a few regular expression methods too.,"(""String"", ""The String class contains regular expression methods."", ""regular expression"")"
The Java String split() method splits the string into N substrings and returns a String array with these substrings.,"(""String"", ""The split method is a function that operates on the String class."", ""split""); (""Java"", ""The String class is part of the Java package."", ""String"")"
The split() method takes a regular expression as parameter and splits the string at all positions in the string where the regular expression matches a part of the string.,"(""Split"", ""The Split method operates on a string by dividing it based on a regular expression."", ""String"")"
The Java Matcher class (java.util.regex.Matcher) is used to search through a text for multiple occurrences of a regular expression.,"(""Matcher"", ""The Matcher class is part of the java.util.regex package, which provides classes for matching character sequences against patterns specified by regular expressions."", ""java.util.regex"")"
I will cover the core methods of the Java Matcher class in this tutorial.,"(""Matcher"", ""The methods are part of the Matcher class."", ""methods""); (""Matcher"", ""The Matcher class is part of the Java package."", ""Java"")"
"For a full list, see the official JavaDoc for the Matcher class.","(""Matcher"", ""The JavaDoc provides documentation for the Matcher class."", ""JavaDoc"")"
Here is a quick Java Matcher example so you can get an idea of how the Matcher class works:,"(""Matcher"", ""The text provides an example of how the Matcher class works, indicating a focus on this class."", ""Matcher"")"
"The matches() returns true if the regular expression matches the text, and false if not.","(""matches"", ""The method 'matches' is related to 'text' because it checks if the regular expression matches the text."", ""text"")"
You can do a whole lot more with the Matcher class.,"(""Matcher"", ""The text indicates that Matcher is a class."", ""class"")"
The Pattern class is covered separately in my Java Regex Pattern tutorial.,"(""Pattern"", ""The Pattern class is discussed in the Java Regex Pattern tutorial."", ""Java Regex Pattern tutorial"")"
Creating a Matcher is done via the matcher() method in the Pattern class.,"(""matcher()"", ""The matcher() method is a method within the Pattern class."", ""Pattern""); (""Matcher"", ""The Matcher class is created using the matcher() method."", ""matcher()"")"
"The matches() method in the Matcher class matches the regular expression against the whole text passed to the Pattern.matcher() method, when the Matcher was created.","(""Matches"", ""The matches() method is a method within the Matcher class."", ""Matcher""); (""Matcher"", ""The Matcher class is associated with the Pattern class through the matcher() method."", ""Pattern"")"
"If the regular expression matches the whole text, then the matches() method returns true.","(""MATCHES"", ""The text mentions the matches() method, indicating it is a method."", ""METHOD"")"
You cannot use the matches() method to search for multiple occurrences of a regular expression in a text.,"(""matches"", ""The term 'matches()' is identified as a method in the text."", ""method"")"
"For that, you need to use the find(), start() and end() methods.","(""FIND"", ""Both are methods mentioned in the text."", ""START""); (""FIND"", ""Both are methods mentioned in the text."", ""END""); (""START"", ""Both are methods mentioned in the text."", ""END"")"
The Matcher lookingAt() method works like the matches() method with one major difference.,"(""Matcher"", ""The lookingAt() method is a method of the Matcher class."", ""lookingAt""); (""Matcher"", ""The matches() method is a method of the Matcher class."", ""matches""); (""lookingAt"", ""The lookingAt() method and the matches() method are compared in terms of their functionality."", ""matches"")"
"The lookingAt() method only matches the regular expression against the beginning of the text, whereas matches() matches the regular expression against the whole text.","(""LookingAt"", ""Both are methods that match regular expressions against text, but they differ in scope: LookingAt matches at the beginning, while Matches checks the whole text."", ""Matches"")"
"In other words, if the regular expression matches the beginning of a text but not the whole text, lookingAt() will return true, whereas matches() will return false.","(""LookingAt"", ""Both are methods used to evaluate regular expressions against text."", ""Matches"")"
Matching the regular expression against the beginning of the text (lookingAt()) will return true.,"(""LOOKINGAT"", ""LOOKINGAT is a method mentioned in the text that is used to match the regular expression against the beginning of the text."", ""METHOD"")"
"Matching the regular expression against the whole text (matches()) will return false, because the text has more characters than the regular expression.","(""MATCHES"", ""The method 'matches()' is used to match the regular expression against the whole text."", ""TEXT""); (""MATCHES"", ""The method 'matches()' is used to match the regular expression."", ""REGULAR EXPRESSION""); (""MATCHES"", ""The method 'matches()' will return false if the text has more characters than the regular expression."", ""FALSE"")"
"The Matcher find() method searches for occurrences of the regular expressions in the text passed to the Pattern.matcher(text) method, when the Matcher was created.","(""Matcher"", ""The find() method is a function of the Matcher class."", ""find""); (""Pattern"", ""The matcher() method is a function of the Pattern class."", ""matcher"")"
"If multiple matches can be found in the text, the find() method will find the first, and then for each subsequent call to find() it will move to the next match.","(""FIND"", ""The find() method is mentioned multiple times, indicating its repeated use in finding matches in the text."", ""FIND"")"
The methods start() and end() will give the indexes into the text where the found match starts and ends.,"(""START"", ""Both methods are used to determine the indexes of where a match starts and ends in the text."", ""END"")"
Actually end() returns the index of the character just after the end of the matching section.,"(""end"", ""The method 'end' returns the 'index' of the character just after the end of the matching section."", ""index"")"
"Thus, you can use the return values of start() and end() inside a String.substring() call.","(""start"", ""The method 'start' is used to provide a return value that can be used as an argument in the 'substring' method."", ""substring""); (""end"", ""The method 'end' is used to provide a return value that can be used as an argument in the 'substring' method."", ""substring""); (""String"", ""The 'substring' method is a method of the 'String' class."", ""substring"")"
The Matcher reset() method resets the matching state internally in the Matcher.,"(""Matcher"", ""The reset method is a function that belongs to the Matcher class, indicating a relationship where the method operates on or is part of the class."", ""reset"")"
"In case you have started matching occurrences in a string via the find() method, the Matcher will internally keep a state about how far it has searched through the input text.","(""Find"", ""The find() method is used by the Matcher class to search through the input text."", ""Matcher"")"
By calling reset() the matching will start from the beginning of the text again.,"(""RESET"", ""The method RESET is used to start the MATCHING process from the beginning of the text again."", ""MATCHING"")"
"Of course you could do this with the start() and end() methods, but it is easier to do so with the group functions.","(""START"", ""Both are methods mentioned together as alternatives for achieving a task."", ""END""); (""START"", ""Both are methods mentioned in the context of performing a similar task."", ""GROUP""); (""END"", ""Both are methods mentioned in the context of performing a similar task."", ""GROUP"")"
The Matcher replaceAll() and replaceFirst() methods can be used to replace parts of the string the Matcher is searching through.,"(""Matcher"", ""The replaceAll method is a function of the Matcher class."", ""replaceAll""); (""Matcher"", ""The replaceFirst method is a function of the Matcher class."", ""replaceFirst"")"
"The Matcher appendReplacement() and appendTail() methods are used to replace string tokens in an input text, and append the resulting string to a StringBuffer.","(""Matcher"", ""The appendReplacement method is a part of the Matcher class."", ""appendReplacement""); (""Matcher"", ""The appendTail method is a part of the Matcher class."", ""appendTail""); (""appendReplacement"", ""The appendReplacement method appends the resulting string to a StringBuffer."", ""StringBuffer""); (""appendTail"", ""The appendTail method appends the resulting string to a StringBuffer."", ""StringBuffer"")"
"When you have found a match using the find() method, you can call the appendReplacement().","(""Find"", ""The Find method is used to locate a match, and the AppendReplacement method is called subsequently to perform an operation based on that match."", ""AppendReplacement"")"
"The appendReplacement() method keeps track of what has been copied into the StringBuffer, so you can continue searching for matches using find() until no more matches are found in the input text.","(""AppendReplacement"", ""The AppendReplacement method interacts with the StringBuffer class to keep track of what has been copied."", ""StringBuffer""); (""AppendReplacement"", ""The AppendReplacement method allows continued searching for matches using the Find method."", ""Find"")"
By calling appendTail() you can append these last characters to the StringBuffer too.,"(""appendTail"", ""The method appendTail is used to append characters to the StringBuffer class."", ""StringBuffer"")"
"Notice how appendReplacement() is called inside the while(matcher.find()) loop, and appendTail() is called just after the loop.","(""AppendReplacement"", ""AppendReplacement is called inside the loop controlled by the Find method."", ""Find""); (""AppendTail"", ""AppendTail is called after the loop controlled by the Find method."", ""Find""); (""Find"", ""Find is a method that is likely part of the Matcher class."", ""Matcher"")"
"The Java Pattern class (java.util.regex.Pattern), is the main access point of the Java regular expression API.","(""Pattern"", ""The Pattern class is part of the java.util.regex package, which is related to regular expressions in Java."", ""java.util.regex"")"
"Whenever you need to work with regular expressions in Java, you start with Java's Pattern class.","(""Pattern"", ""The Pattern class is part of Java's regular expression handling."", ""Java"")"
A regular expression is also sometimes referred to as a pattern (hence the name of the Java Pattern class).,"(""Pattern"", ""The Pattern class is part of the Java package, as indicated by the text."", ""Java"")"
You can use the Pattern.matches() method to quickly check if a text (String) matches a given regular expression.,"(""Pattern"", ""The matches method is a part of the Pattern class."", ""matches""); (""matches"", ""The matches method is used to check if a String matches a given regular expression."", ""String"")"
Or you can compile a Pattern instance using Pattern.compile() which can be used multiple times to match the regular expression against multiple texts.,"(""Pattern"", ""Pattern.compile() is a method used to compile a Pattern instance."", ""Pattern.compile()"")"
The easiest way to check if a regular expression pattern matches a text is to use the static Pattern.matches() method.,"(""Pattern"", ""The matches method is a static method of the Pattern class."", ""matches"")"
"This Pattern.matches() example searches the string referenced by the text variable for an occurrence of the word ""is"", allowing zero or more characters to be present before and after the word (the two .","(""Pattern"", ""The method 'matches' is a member of the 'Pattern' class, indicating a class-method relationship."", ""matches"")"
"The Pattern.matches() method is fine if you just need to check a pattern against a text a single time, and the default settings of the Pattern class are appropriate.","(""Pattern.matches()"", ""The Pattern.matches() method is a method of the Pattern class."", ""Pattern"")"
"If you need to match for multiple occurrences, and even access the various matches, or just need non-default settings, you need to compile a Pattern instance using the Pattern.compile() method.","(""Pattern"", ""The Pattern.compile() method is used to compile a Pattern instance, indicating a direct relationship between the class and the method."", ""Pattern.compile()"")"
"If you need to match a text against a regular expression pattern more than one time, you need to create a Pattern instance using the Pattern.compile() method.","(""Pattern"", ""The Pattern.compile() method is used to create an instance of the Pattern class."", ""Pattern.compile()"")"
You can also use the Pattern.compile() method to compile a Pattern using special flags.,"(""Pattern"", ""The compile method is used to compile a Pattern, indicating a direct relationship between the class and the method."", ""compile"")"
The Java Pattern class contains a list of flags (int constants) that you can use to make the Pattern matching behave in certain ways.,"(""Pattern"", ""The Pattern class is mentioned as containing a list of flags for matching behavior."", ""Pattern"")"
"For more information of the flags you can use with the Java Pattern class, see the JavaDoc for Pattern .","(""Pattern"", ""The JavaDoc provides documentation for the Pattern class, indicating a relationship where JavaDoc contains information about Pattern."", ""JavaDoc"")"
The Matcher class has a matches() method that tests whether the pattern matches the text.,"(""Matcher"", ""The matches() method is a function of the Matcher class."", ""matches()"")"
"Too keep this text short, the Matcher covered in more detail in the text about the Java Matcher class.","(""Matcher"", ""The Matcher is discussed in the context of the Java Matcher class, indicating a relationship between the two."", ""Java Matcher"")"
"The split() method in the Pattern class can split a text into an array of String's, using the regular expression (the pattern) as delimiter.","(""SPLIT"", ""The SPLIT method is part of the PATTERN class."", ""PATTERN""); (""SPLIT"", ""The SPLIT method returns an array of STRINGs."", ""STRING"")"
This Pattern.split() example splits the text in the text variable into 5 separate strings.,"(""Pattern"", ""The method 'split' is a function of the class 'Pattern'."", ""split"")"
Each of these strings are included in the String array returned by the split() method.,"(""split"", ""The split method returns an array of String objects."", ""String"")"
The pattern() method of the Pattern class simply returns the pattern string (regular expression) that the Pattern instance was compiled from.,"(""Pattern"", ""The pattern() method belongs to the Pattern class."", ""pattern"")"
Character classes are constructst that enable you to specify a match against multiple characters instead of just one.,"(""Character Classes"", ""Character Classes are constructs that enable you to specify a match against multiple characters."", ""Character"")"
"In other words, a character class matches a single character in the input text against multiple allowed characters in the character class.","(""Character Class"", ""A character class is used to match a single character in the input text."", ""Character"")"
Character classes are nested inside a pair of square brackets [].,"(""Character classes"", ""Character classes are nested inside square brackets, indicating a structural relationship."", ""square brackets"")"
"The character class [Jj] will match either a J or a j, and the rest of the expression will match the characters ohn in that exact sequence.","(""Character Class"", ""The character class [Jj] is used to match either a J or a j."", ""J""); (""Character Class"", ""The character class [Jj] is used to match either a J or a j."", ""j"")"
The Java regular expression syntax has a few predefined character classes you can use.,"(""Java"", ""Java is a programming language that supports regular expressions, which are used for pattern matching."", ""regular expression"")"
"For instance, the \d character class matches any digit, the \s character class matches any white space character, and the \w character matches any word character.","(""D"", ""Both are character classes used in regular expressions to match specific types of characters."", ""S""); (""D"", ""Both are character classes used in regular expressions to match specific types of characters."", ""W""); (""S"", ""Both are character classes used in regular expressions to match specific types of characters."", ""W"")"
"The predefined character classes do not have to be enclosed in square brackets, but you can if you want to combine them.","(""Character Classes"", ""Character classes can be enclosed in square brackets to combine them."", ""Square Brackets"")"
The predefined character classes are listed in a table later in this text.,"(""Character Classes"", ""class"")"
"The Java GZIPInputStream class (java.util.zip.GZIPInputStream) can be used to decompress files that are compressed with the GZIP compression algorithm, for instance via the GZIPOutputStream class.","(""GZIPInputStream"", ""GZIPInputStream is a class within the java.util.zip package"", ""java.util.zip.GZIPInputStream""); (""GZIPInputStream"", ""GZIPInputStream is used to decompress files that are compressed by GZIPOutputStream"", ""GZIPOutputStream""); (""java.util.zip.GZIPInputStream"", ""java.util.zip.GZIPInputStream is a class within the java.util.zip package"", ""java.util.zip""); (""GZIPOutputStream"", ""GZIPOutputStream is likely a class within the java.util.zip package, similar to GZIPInputStream"", ""java.util.zip"")"
In the example above I passed it a FileInputStream connected to a file named myfile.zip.,"(""FileInputStream"", ""FileInputStream is connected to the file named myfile.zip"", ""myfile.zip"")"
When you are finished reading data from the GZIPInputStream you should close it using its close() method.,"(""GZIPInputStream"", ""The close method is used to close the GZIPInputStream after reading data from it."", ""close"")"
The Java GZIPOutputStream class (java.util.zip.GZIPOutStream) can be used to GZIP compress data and write it to an OutputStream.,"(""GZIPOutputStream"", ""GZIPOutputStream is part of the java.util.zip package"", ""java.util.zip""); (""GZIPOutputStream"", ""GZIPOutputStream writes compressed data to an OutputStream"", ""OutputStream"")"
This Java ZIP tutorial explains how the core classes of the Java ZIP API works.,"(""Java ZIP"", ""Java ZIP is part of the Java ZIP API, indicating a package relationship."", ""Java ZIP API""); (""core classes"", ""The core classes are part of the Java ZIP API, indicating a class-package relationship."", ""Java ZIP API"")"
The Java ZipFile class is used to work with ZIP files containing multiple files.,"(""ZipFile"", ""The ZipFile class is part of the Java programming language."", ""Java"")"
The Java GZIPInputStream and GZIPOutputStream classes are used to ZIP compress a single file.,"(""GZIPInputStream"", ""Both classes are used for ZIP compression of files in Java."", ""GZIPOutputStream"")"
The above classes will be covered in detail their own tutorials (see the side menu for links).,NULL
The Java ZipFile class (java.util.zip.ZipFile) can be used to read files from a ZIP file.,"(""ZipFile"", ""The ZipFile class is part of the java.util.zip package."", ""java.util.zip"")"
This tutorial will show you how to use the ZipFile class.,"(""ZipFile"", ""class"")"
In order to use the Java ZipFile class you must first create a ZipFile instance.,"(""ZipFile"", ""The text indicates that a ZipFile instance must be created, suggesting a relationship between the class and its instance."", ""ZipFile"")"
"As you can see, the ZipFile class takes a single parameter in its constructor.","(""ZipFile"", ""The ZipFile class is related to its constructor because it takes a parameter in it."", ""constructor"")"
Each file in the ZIP file is represented by a ZipEntry (java.util.zip.ZipEntry).,"(""ZipEntry"", ""ZipEntry is a class within the java.util.zip package"", ""java.util.zip"")"
To extract a file from the ZIP file you can call the method getEntry() method on the ZipFile class.,"(""GETENTRY"", ""The method getEntry() is called on the ZipFile class to extract a file from the ZIP file."", ""ZIPFILE"")"
This example gets a ZipEntry representing the file file1.txt which is contained in the ZIP file.,"(""ZipEntry"", ""ZipEntry represents the file file1.txt"", ""file1.txt""); (""file1.txt"", ""file1.txt is contained in the ZIP file"", ""ZIP file"")"
The InputStream obtained from the getInputStream() of the ZipFile class can be read like any other Java InputStream.,"(""getInputStream"", ""The method getInputStream is associated with the ZipFile class as it is a method that can be called on a ZipFile object."", ""ZipFile""); (""InputStream"", ""The InputStream class is related to the getInputStream method because the method returns an InputStream object."", ""getInputStream""); (""InputStream"", ""The InputStream class is related to the ZipFile class because the getInputStream method of the ZipFile class returns an InputStream."", ""ZipFile"")"
You can list all entries contained in a ZipFile using the entries() method.,"(""ZipFile"", ""The entries() method is used to list all entries contained in a ZipFile class."", ""entries"")"
You can iterate the Enumeration returned by the entries() method like this:,"(""entries"", ""The entries() method returns an Enumeration, indicating a relationship where the method provides an instance of the class."", ""Enumeration"")"
The Zip Slip attack consists of adding entries to a ZipFile that contains relative file paths with one or more /.. sections in the path.,"(""ZipFile"", ""The Zip Slip attack involves manipulating entries within a ZipFile class."", ""Zip Slip"")"
An entry in the ZipFile has the relative path ../../../../etc/hosts .,"(""ZipFile"", ""The entry is a path within the ZipFile class."", ""../../../../etc/hosts"")"
The final path of that entry becomes: /apps/myapp/data/unzipped-file/../../../../etc/hosts which is equivalent of /etc/hosts .,NULL
"Unzipping this file could potentially overwrite hour hosts file (on a Linux OS), enabling the attacker to point e.g.",NULL
"The Java examples in this tutorial were created with Java 8, and Acme4J Client v. 2.1 and Acme4J Utils v. 0.3.","(""Acme4J Client"", ""Both are packages mentioned in the context of the tutorial and likely part of the same library or framework."", ""Acme4J Utils"")"
Here is a Java class capable of creating a private key for use with Acme4J:,"(""Java"", ""The Java class is used in conjunction with the Acme4J package to create a private key."", ""Acme4J"")"
Here is a class that can create a Let's Encrypt account:,"(""Let's Encrypt"", ""class"")"
It is the execute() method that starts the account creation process.,"(""Execute"", ""The execute() method initiates the account creation process."", ""Account Creation Process"")"
The fully qualified name for the Order class is org.shredzone.acme4j.Order .,"(""Order"", ""The Order class is part of the org.shredzone.acme4j package"", ""org.shredzone.acme4j"")"
Calling create() results in a request being sent to Let's Encrypt.,"(""create"", ""The method create() sends a request to the Let's Encrypt class."", ""Let's Encrypt"")"
Once you have called the order.create() method a request is sent to Let's Encrypt.,"(""Order"", ""The 'create' method is a function that belongs to the 'Order' class."", ""Create""); (""Create"", ""The 'create' method sends a request to the 'Let's Encrypt' package."", ""Let's Encrypt"")"
"The above example specifically looks for an HTTP authorization object, which is then triggered by calling challenge.trigger().","(""challenge"", ""The method 'trigger' is called on the 'challenge' class."", ""trigger"")"
"Before the challenge is triggered, you must read the value from challenge.getAuthorization() and upload it in a file to your web server.","(""Challenge"", ""GetAuthorization is a method that belongs to the Challenge class"", ""GetAuthorization"")"
"... where ${domain} is the domain for which you are requesting the domain for (returned by challenge.getDomain() ), and ${token} is the value returned by challenge.getToken().","(""challenge"", ""The method getDomain is associated with the class challenge as it is called on it."", ""getDomain""); (""challenge"", ""The method getToken is associated with the class challenge as it is called on it."", ""getToken"")"
"If your code cannot access your web server to upload the challenge file before calling challenge.trigger(), you can run the code in your debugger, set a breakpoint before calling challenge.trigger(), pause the code at that breakpoint, read the token (file name) and authorization (file content) out of the challenge object, upload that to your web server, and then continue the code in the debugger.","(""CHALLENGE"", ""The method TRIGGER is called on the CHALLENGE class, indicating a relationship where TRIGGER is a method belonging to or associated with the CHALLENGE class."", ""TRIGGER"")"
That is what happens in the last part of the processAuth() method.,"(""processAuth"", ""method"")"
"First, the code above waits until the Order object has status Status.VALID.","(""Order"", ""The Order class has a status attribute that is an instance of the Status class."", ""Status""); (""Status"", ""VALID is a method or constant within the Status class."", ""VALID"")"
The value of that Ant property will be inserted at the place of the ${...} code.,"(""Ant"", ""class"")"
This example first defines a property named dir.build which has its value set to build.,"(""DIR.BUILD"", ""The property DIR.BUILD has its value set to BUILD."", ""BUILD"")"
"Second, this example defines a property named dir.build.classes which has its value set to ${dir.build}/classes .","(""dir.build.classes"", ""The property 'dir.build.classes' has its value set to '${dir.build}/classes'."", ""${dir.build}/classes"")"
"When Ant defines this property it will resolve the value of the referenced property dir.build, and insert its value where the property is reference.","(""Ant"", ""Ant is responsible for resolving the value of the referenced property dir.build."", ""dir.build"")"
"Thus, the second Ant property defined will have its final value set to build/classes because build is the value of the dir.build property referenced.","(""Ant"", ""Ant is a package that contains the class build."", ""build""); (""build"", ""The class build is related to the property dir.build as it sets its final value."", ""dir.build"")"
"The echo task as defined here will print out the message ""This is version 1.2.3"" to the console.",NULL
"Just to recap, a ""Java build tool"" is a tool which can compile Java code, run the unit tests for it, package the compiled classes into a JAR file and many, many other things.","(""Java"", ""Java code is compiled into classes which are then packaged into a JAR file"", ""JAR"")"
This Ant tutorial is based on Ant version 1.9.6 which is the newest version of Ant at the time of writing (august 2015).,"(""Ant"", ""The text refers to a specific version of the Ant package, indicating a relationship between the package and its version."", ""version"")"
"Inside the project directory you have just created, create an empty file named build.xml.","(""BUILD.XML"", ""FILE"")"
"By default Ant looks for a build script named build.xml in your project root directory, so you might as well call your Ant build script build.xml.","(""Ant"", ""Ant is a package that uses a build script to automate tasks."", ""build script""); (""build script"", ""The build script is named build.xml by default in Ant."", ""build.xml"")"
"You could use another name, but using build.xml makes your Ant commands shorter, and it makes it easier for other developers to find the Ant build script.","(""Ant"", ""Ant is a package that uses the build.xml file as its build script."", ""build.xml"")"
Open the build.xml file and insert the following text (XML) into it:,"(""build.xml"", ""The build.xml file is being modified to include XML content."", ""XML"")"
You can test this build file by opening a command prompt and change directory into the directory that contains the build.xml file and execute this command:,"(""Build File"", ""The build file is associated with the build.xml file as it contains the build instructions."", ""Build.xml""); (""Command Prompt"", ""The command prompt is used to execute commands related to the build file."", ""Build File"")"
"This test was performed using Java 5, Butterfly Container 1.9.11-beta, and Guice 1.0.","(""Butterfly Container 1.9.11-beta"", ""Butterfly Container 1.9.11-beta is a package that can be used within the Java 5 environment."", ""Java 5""); (""Guice 1.0"", ""Guice 1.0 is a package that can be used within the Java 5 environment."", ""Java 5"")"
"The test performs 10.000.000 instantiations of a TestProduct class using a no-arg constructor, for each DI mechanism.","(""TestProduct"", ""The TestProduct class is instantiated using a no-arg constructor."", ""no-arg constructor"")"
Java is a statically typed language meaning that types (primtives and classes) cannot change at runtime.,"(""Java"", ""class"")"
"It is not like you can all of a sudden let your Java class members, method parameters and variables be untyped.","(""Java"", ""The term 'Java' is related to 'members' as it refers to the members of a Java class."", ""members""); (""Java"", ""The term 'Java' is related to 'method' as it refers to method parameters in a Java context."", ""method"")"
"This is done at the beginning, by the method call BO.setDao(dao).","(""BO"", ""The method setDao is called on the class BO."", ""setDao""); (""setDao"", ""The method setDao takes an instance of the class dao as a parameter."", ""dao"")"
"But, notice how no DI is used inside the BO.checkPersonIsValid() or the DAO.readPerson() methods.","(""BO"", ""The method checkPersonIsValid is a method of the class BO."", ""checkPersonIsValid""); (""DAO"", ""The method readPerson is a method of the class DAO."", ""readPerson"")"
I most likely never have to change implementation of the Person class.,"(""Person"", ""class"")"
In Java this will result in a class cast exception at runtime (or some similar type error exception).,"(""Class Cast Exception"", ""A class cast exception occurs at runtime, indicating a relationship between the exception and the runtime environment."", ""Runtime"")"
"Each factory definition states how a given instance is to be created and configured, when calling the container.instance() method.","(""CONTAINER.INSTANCE()"", ""The method 'CONTAINER.INSTANCE()' is used in the context of creating and configuring instances as defined by a factory definition."", ""FACTORY DEFINITION"")"
"The input parameters .hashcode() and .equals() methods determine if an input parameter has an instance associated with it already, or a new one needs to be created and associated with the input parameter for succeeding calls.","(""HASHCODE"", ""Both are methods used to determine if an input parameter has an instance associated with it or if a new one needs to be created."", ""EQUALS"")"
As you can see the constructor call was chained with a call to the setValue() method.,"(""CONSTRUCTOR"", ""The constructor call is chained with a call to the setValue() method, indicating a relationship between them."", ""SETVALUE"")"
"Notice how the length() method is called on the ""value"" parameter.","(""LENGTH"", ""The LENGTH method is called on the VALUE parameter, indicating a direct interaction between the method and the parameter."", ""VALUE"")"
"If the setValue() method in the example above returns void, the factory will return the SomeObject instance the method was called on.","(""setValue"", ""The setValue method is called on an instance of the SomeObject class."", ""SomeObject"")"
The factory defined by this script will return a SomeObject instance that has had the two methods setValue() and setValue2() invoked on it.,"(""SomeObject"", ""The method setValue() is invoked on an instance of the class SomeObject."", ""setValue""); (""SomeObject"", ""The method setValue2() is invoked on an instance of the class SomeObject."", ""setValue2"")"
"Here is a list of classes and primitives that parameters can be converted to, automatically:",NULL
Sometimes a constructor or method call in a factory definition matches more than one constructor or method in the owning class.,"(""CONSTRUCTOR"", ""A constructor is a type of method."", ""METHOD""); (""FACTORY DEFINITION"", ""A factory definition can contain methods or constructors that belong to the owning class."", ""OWNING CLASS"")"
You can cast to any type or class available on the classpath.,"(""Class"", ""The class is available on the classpath, indicating a relationship between the two."", ""Classpath"")"
"To call a static method instead of a constructor when creating an instance of some class, simply write as you would in Java:","(""static method"", ""Both are methods used in the context of creating instances."", ""constructor""); (""instance"", ""An instance is created from a class."", ""class""); (""Java"", ""Static methods are a feature of the Java programming language."", ""static method"")"
Note: The container uses java.util.ArrayList and java.util.HashSet as the List and Set implementations.,"(""Java.util.ArrayList"", ""Java.util.ArrayList is used as the implementation of the List interface."", ""List""); (""Java.util.HashSet"", ""Java.util.HashSet is used as the implementation of the Set interface."", ""Set""); (""Java.util.ArrayList"", ""Java.util.ArrayList is part of the Java.util package."", ""Java.util""); (""Java.util.HashSet"", ""Java.util.HashSet is part of the Java.util package."", ""Java.util"")"
From version 2.5.9 Butterfly Container Script provides a shortcut to configuring Map instances.,"(""Butterfly Container Script"", ""Butterfly Container Script provides a shortcut to configuring Map instances, indicating a functional relationship between the package and the class."", ""Map"")"
First an instance of SomeObject is created and then the setValue() method is called on it.,"(""SomeObject"", ""The setValue() method is called on an instance of the SomeObject class, indicating a relationship where the method operates on the class."", ""setValue"")"
Below is an example that register the newly created instance with a static method in the MyClass class.,"(""register"", ""The method 'register' is used within the 'MyClass' class to register the newly created instance."", ""MyClass"")"
You can inject instances of classes created locally in a factory definition.,"(""Factory Definition"", ""Factory Definition is related to Classes because it is responsible for creating instances of these classes."", ""Classes"")"
"Notice how the setNewValue() method is called on the instance obtained from the bean1 factory, before it is injected into OtherObject's constructor.","(""setNewValue"", ""The setNewValue method is called before being injected into OtherObject's constructor, indicating a relationship where the method is used within the class."", ""OtherObject"")"
"Thus, the setFurtherValue() method of the someObject singleton is called for each instance of bean2 created, even if the method call is redundant.","(""SETFURTHERVALUE"", ""The method SETFURTHERVALUE is called on the SOMEOBJECT singleton."", ""SOMEOBJECT""); (""SETFURTHERVALUE"", ""The method SETFURTHERVALUE is called for each instance of BEAN2 created."", ""BEAN2"")"
"Notice how the bean2 definition obtains an instance from the bean1 factory, and calls the setValue() method on it before returning it.","(""Bean2"", ""Bean2 obtains an instance from the Bean1 factory."", ""Bean1""); (""Bean2"", ""Bean2 calls the setValue() method."", ""SetValue"")"
"Input parameters can be given to the container.instance() method, like this:","(""CONTAINER"", ""The INSTANCE method is a function that belongs to the CONTAINER class."", ""INSTANCE"")"
"The container cannot determine the type of input parameters until runtime, when the container.instance() method is called.","(""CONTAINER"", ""The INSTANCE method is called on the CONTAINER class to determine the type of input parameters at runtime."", ""INSTANCE"")"
Therefore it is only possible to call methods that exists in java.lang.Object on input parameters.,"(""java.lang.Object"", ""Methods from the java.lang.Object class can be called on input parameters."", ""input parameters"")"
"Your application will ask the container for an object, and the container will make sure that all dependencies (config parameters, collaborating objects, texts etc.)",NULL
"Rather than having to design integration mechanisms yourself, and decide on configuration formats etc., you can have the dependency injection container do all that for you.",NULL
"The ""connectionTimeout"" factory is defined as a singleton returning whatever value the CONNECTION_TIMEOUT constant is set to in the Constants class.","(""CONNECTION_TIMEOUT"", ""The CONNECTION_TIMEOUT constant is set in the Constants class, indicating a relationship between the two."", ""Constants"")"
The simplest way to add a function is to create a static method in a Java class that performs the logic for the function.,"(""STATIC METHOD"", ""A static method is a function that is defined within a Java class."", ""JAVA CLASS"")"
Sometimes you may need to create an instance of some class and call a method on that instance.,"(""Class"", ""A method is typically called on an instance of a class."", ""Method"")"
The beanB factory will call the beanA factory with the parameter returned from the static default() method.,"(""BeanB"", ""BeanB factory calls the BeanA factory."", ""BeanA""); (""BeanB"", ""BeanB factory uses the parameter returned from the Default method."", ""Default"")"
"If input parameter 0 passed to the beanB factory is null, then the default() method will return the default value ""default value"".","(""beanB"", ""The method 'default' is associated with the 'beanB' class as it is mentioned in the context of the beanB factory."", ""default"")"
"If you need to call the default() method more than once you can simplify the script a bit by mapping the default method to a factory, and then call this factory whenever the function is needed.","(""DEFAULT"", ""The default method is mapped to a factory to simplify the script."", ""FACTORY""); (""FACTORY"", ""The factory is called whenever the function is needed."", ""FUNCTION"")"
"The default() method has been mapped to a factory called ""default"".","(""DEFAULT"", ""The method DEFAULT is mapped to a factory also called DEFAULT."", ""DEFAULT"")"
This default factory is then called from the beanB factory instead of calling the static default() method directly.,"(""default factory"", ""The default factory is called from the beanB factory."", ""beanB factory""); (""default()"", ""The default() method is associated with the default factory as it is mentioned in the context of being called."", ""default factory"")"
"There is no package and class name to disturb you when reading the script, and whenever you need the default function all you need to write is ""default(a, b)"", instead of ""com.myapp.util.Util.default(a, b)"".","(""default"", ""The method 'default' is part of the class 'com.myapp.util.Util', as indicated by the usage 'com.myapp.util.Util.default(a, b)'."", ""com.myapp.util.Util"")"
Defining the static max() method as a factory (and thereby a function) is done like this:,"(""Max"", ""The Max method is described as being static, indicating its nature as a class-level method."", ""Static""); (""Max"", ""The Max method is described as a factory, indicating its role in creating instances."", ""Factory""); (""Max"", ""The Max method is also described as a function, highlighting its functional behavior."", ""Function"")"
"This little script defines the ""max"" factory as a call to the static max() method with input parameter 0 and 1 passed to the max() method.","(""Max"", ""The 'max' factory is defined as a call to the static 'max()' method."", ""Max"")"
"The max factory will call the max() method and return the value that is largest of either the input parameter 0 passed to the beanA factory, or the hard coded value 1.","(""Max"", ""The Max method is called to determine the largest value between the input parameter passed to the BeanA factory and a hardcoded value."", ""BeanA"")"
"This example uses the java.text.SimpleDateFormat class and defines its instance method parse() as a function called ""toDate"".","(""SimpleDateFormat"", ""The method 'parse' is an instance method of the 'SimpleDateFormat' class."", ""parse""); (""parse"", ""The method 'parse' is defined as a function called 'toDate'."", ""toDate"")"
Second the toDate factory is defined as a call to the toDateFactory and then a call to the parse() method on the instance returned from the toDateFactory.,"(""toDate"", ""The toDate method is defined as a call to the toDateFactory method."", ""toDateFactory""); (""parse"", ""The parse method is called on the instance returned from the toDateFactory method."", ""toDateFactory"")"
The toDate factory takes a single parameter which is the string to parse into a java.util.Date instance.,"(""toDate"", ""The toDate method is used to parse a string into a java.util.Date instance."", ""java.util.Date"")"
"It is possible to extend Butterfly Container Script (BCS) with custom instantiation modes, if the standard modes (new instance, singleton etc.)","(""Butterfly Container Script"", ""BCS is an abbreviation for Butterfly Container Script"", ""BCS""); (""Instantiation Modes"", ""Standard Modes are a type of Instantiation Modes"", ""Standard Modes"")"
"By calling the set() method with the current request as parameter, the request is associated with the thread calling the set() method.","(""SET"", ""The set() method is called with the current request as a parameter, associating the request with the thread."", ""REQUEST"")"
By calling the get() method the request object associated with the calling thread can be obtained.,"(""GET"", ""The GET method is used to obtain the REQUEST OBJECT associated with the calling thread."", ""REQUEST OBJECT"")"
"The ""request"" factory is defined as a call to the get() method on the product returned from the ""requestCache"" factory.","(""Request"", ""The 'request' factory is defined as a call to the get() method."", ""Get""); (""RequestCache"", ""The 'request' factory is a product returned from the 'requestCache' factory."", ""Request"")"
"In other words, as a call to the get() method on the HttpRequestCache singleton.","(""Get"", ""The Get method is called on the HttpRequestCache class, indicating a relationship where the method is part of or used by the class."", ""HttpRequestCache"")"
"The ""session"" factory is defined as a call to the getSession() method of the product returned by the ""request"" factory.","(""SESSION"", ""The session is created by calling the getSession() method."", ""GETSESSION""); (""REQUEST"", ""The session is a product returned by the request factory."", ""SESSION"")"
"In other words, as a call to the getSession() method on the request object obtained from the HttpRequestCache singleton, which is the request object associated with the calling thread.","(""GetSession"", ""The GetSession method is called on the request object obtained from the HttpRequestCache singleton."", ""HttpRequestCache"")"
In order to make the the request and session factories return the correct objects you must first call the HttpRequestCache's set() method.,"(""HttpRequestCache"", ""The set method is a function of the HttpRequestCache class."", ""set"")"
"Another disadvantage is that all instantiation modes (singleton, thread singleton, flyweight etc.)","(""Singleton"", ""Both are instantiation modes that manage object creation and lifecycle."", ""Thread Singleton""); (""Singleton"", ""Both are instantiation modes that manage object creation and lifecycle."", ""Flyweight""); (""Thread Singleton"", ""Both are instantiation modes that manage object creation and lifecycle."", ""Flyweight"")"
"If you use an anonymous subclass of JavaFactory, inserted instead of ""new MyFactory()"", the JavaFactoryBuilder cannot access the ""otherFactory"" field, even if it is public.","(""JavaFactory"", ""JavaFactory is used in conjunction with JavaFactoryBuilder, indicating a relationship between the two classes."", ""JavaFactoryBuilder""); (""JavaFactory"", ""The otherFactory field is mentioned in the context of JavaFactory, suggesting a relationship."", ""otherFactory""); (""MyFactory"", ""MyFactory is used as an instance in place of JavaFactory, indicating a relationship between the two classes."", ""JavaFactory"")"
"Inner classes will do just fine too, as long as they are declared ""public static"".","(""Inner classes"", ""Inner classes need to be declared as public static to function properly."", ""public static"")"
"This method takes 3 parameters: The name of the factory, the return type of the factory, and a subclass of JavaFactory which implements the factory.","(""This Method"", ""The method takes a subclass of JavaFactory as one of its parameters, indicating a relationship between the method and the class."", ""JavaFactory"")"
"The name is used when calling the container.instance(""name"") method to obtain an instance from the factory.","(""CONTAINER"", ""The INSTANCE method is called on the CONTAINER class to obtain an instance."", ""INSTANCE""); (""INSTANCE"", ""The INSTANCE method is used to obtain an instance from the FACTORY class."", ""FACTORY"")"
JavaFactoryBuilder has a method that omits the return type and instead extracts that information from the return type of the JavaFactory subclass's instance method.,"(""JavaFactoryBuilder"", ""JavaFactoryBuilder contains a method."", ""method""); (""JavaFactory"", ""The instance method belongs to the JavaFactory subclass."", ""instance method"")"
Notice how no return type is passed in the addFactory() call.,"(""addFactory"", ""The text refers to the 'addFactory()' call, indicating it is a method."", ""method"")"
Also notice how the return type of the instance() method is now MyObject.,"(""INSTANCE"", ""The INSTANCE method returns an object of type MYOBJECT, indicating a relationship between the method and the class."", ""MYOBJECT"")"
By declaring a field of type IGlobalFactory in the JavaFactory subclass the JavaFactoryBuilder knows that the factory depends on another factory.,"(""JavaFactory"", ""JavaFactory declares a field of type IGlobalFactory, indicating a dependency."", ""IGlobalFactory""); (""JavaFactoryBuilder"", ""JavaFactoryBuilder knows about the dependency of JavaFactory on another factory."", ""JavaFactory"")"
"You can add as many factories as you want, using the addFactory() method.","(""Addfactory"", ""The text describes using the addFactory() method, indicating that Addfactory is a method."", ""Method"")"
The ScriptFactoryBuilder has a addFactories() method that takes an InputStream as parameter instead of a String.,"(""ScriptFactoryBuilder"", ""The addFactories method is a part of the ScriptFactoryBuilder class."", ""addFactories"")"
"Using this method you can load a container script from disk, over a network, from the classpath and also from inside a Jar file.","(""Method"", ""The method is used to load a container script."", ""container script""); (""container script"", ""The container script can be loaded from disk."", ""disk""); (""container script"", ""The container script can be loaded over a network."", ""network""); (""container script"", ""The container script can be loaded from the classpath."", ""classpath""); (""container script"", ""The container script can be loaded from inside a Jar file."", ""Jar file"")"
"To configure the container using a script contained in a file located on the classpath (including inside a Jar file), you can do like this:","(""Classpath"", ""Jar files can be located on the classpath, indicating a relationship between the two."", ""Jar"")"
"The init() method creates all singletons, starts services and other stuff that need to be done before the instances in the container can be used.","(""Init"", ""The init() method is responsible for creating all singletons."", ""Singletons""); (""Init"", ""The init() method starts services."", ""Services""); (""Init"", ""The init() method performs tasks needed before the instances in the container can be used."", ""Instances"")"
The instance() method needs the name of the object factory to get an instance from.,"(""INSTANCE"", ""The INSTANCE method requires the name of the OBJECT FACTORY to obtain an instance."", ""OBJECT FACTORY"")"
You can put as many input parameters into the instance() call as you like.,"(""instance"", ""The method 'instance' can accept multiple input parameters."", ""input parameters"")"
The input parameters are defined as an optional parameter (Object ... parameters).,"(""Object"", ""The Object class is used as a type for the parameters method, indicating that the method can accept objects of this class."", ""parameters"")"
"When the dispose() method is called, the dispose life cycle phase is executed for all factories in the container, before the method call returns.","(""Dispose"", ""The dispose() method is related to the dispose life cycle phase as it triggers the execution of this phase."", ""Dispose""); (""Dispose"", ""The dispose() method initiates the dispose life cycle phase."", ""Dispose Life Cycle Phase""); (""Dispose Life Cycle Phase"", ""The dispose life cycle phase is executed for all factories in the container."", ""Container"")"
A thread calling get() will only get the object it had set itself by calling set().,"(""Get"", ""The method 'get()' retrieves the object that was set by the method 'set()'."", ""Set"")"
"Then the value obtained from the container.instance(""myThreadLocal"") call will be the value the calling thread associated with itself, by calling MyClass.threadLocal.set().","(""MyClass"", ""The method 'threadLocal' is associated with the class 'MyClass' as it is called using 'MyClass.threadLocal.set()'."", ""threadLocal"")"
ThreadLocal's can be used to associate a java.util.Locale with the calling thread.,"(""ThreadLocal"", ""ThreadLocal can be used to associate a java.util.Locale with the calling thread, indicating a relationship between the two classes."", ""java.util.Locale"")"
"Basically what you will do is call a ThreadLocal.set() method with the Locale to associate with the calling thread, before calling container.instance().","(""ThreadLocal"", ""The set method is a method of the ThreadLocal class."", ""set""); (""container"", ""The instance method is called on the container class."", ""instance""); (""set"", ""The set method is used to associate a Locale with the calling thread."", ""Locale"")"
"Notice how the Locale is not obtained by the ThreadLocal.get() method, but via the static method getLocale().","(""ThreadLocal"", ""The get method is associated with the ThreadLocal class as it is a method that can be called on a ThreadLocal object."", ""get""); (""Locale"", ""The getLocale method is associated with the Locale class as it is a static method used to obtain a Locale instance."", ""getLocale"")"
"The getLocale() method functions as a cast from Object to its return value Locale, enabling the container to determine the type of the returned object (Locale).","(""GetLocale"", ""The GetLocale method returns an object of type Locale."", ""Locale"")"
"Notice how the HttpServletRequest and HttpServletResponse are not obtained by the ThreadLocal.get() method, but via the static methods getRequest() and getResponse().","(""ThreadLocal.get()"", ""The HttpServletRequest is mentioned in the context of not being obtained by the ThreadLocal.get() method."", ""HttpServletRequest""); (""ThreadLocal.get()"", ""The HttpServletResponse is mentioned in the context of not being obtained by the ThreadLocal.get() method."", ""HttpServletResponse""); (""getRequest()"", ""The getRequest() method is used to obtain the HttpServletRequest."", ""HttpServletRequest""); (""getResponse()"", ""The getResponse() method is used to obtain the HttpServletResponse."", ""HttpServletResponse"")"
"The getRequest() method functions as a cast from Object to its return value HttpServletRequest, enabling the container to determine the type of the returned object (HttpServletRequest).","(""getRequest"", ""The getRequest() method returns an object of type HttpServletRequest."", ""HttpServletRequest"")"
"Instantiation time localization means that you inject localized dependencies (texts, paths, number and date formatters etc.)","(""Instantiation Time Localization"", ""Instantiation Time Localization involves injecting Localized Dependencies such as texts, paths, number and date formatters."", ""Localized Dependencies"")"
"As you can imagine, the more resources the MyComponent needs, the larger both the class and the configuration grows.","(""MyComponent"", ""MyComponent is described as needing resources, which implies it is a class."", ""class"")"
"As you can imagine, only the execute() method will grow as the number of localized dependencies grow.","(""Execute"", ""The execute method will grow as the number of localized dependencies grow, indicating a relationship between the method and the dependencies."", ""Localized Dependencies"")"
"Assuming that the MyService class implements an interface called IService, you can create a mock implementation of the IService interface using this code:","(""MyService"", ""MyService class implements the IService interface"", ""IService""); (""IService"", ""IService is the interface implemented by the MyService class"", ""MyService"")"
This mockService factory returns a dynamic implementation of the IService interface based on Java's java.lang.reflect.Proxy class.,"(""MOCKSERVICE"", ""MOCKSERVICE is a factory that returns an implementation of the ISERVICE interface."", ""ISERVICE""); (""MOCKSERVICE"", ""MOCKSERVICE uses JAVA.LANG.REFLECT.PROXY to create dynamic implementations."", ""JAVA.LANG.REFLECT.PROXY"")"
"The serviceMock instance passed to the getMock() method should be the mock object obtained from the mockService factory, using the container.instance(""mockService"") method call.","(""SERVICEMOCK"", ""The SERVICEMOCK instance is passed to the GETMOCK method."", ""GETMOCK""); (""MOCKSERVICE"", ""The MOCKSERVICE is obtained using the CONTAINER instance method call."", ""CONTAINER"")"
"In other words, the instance returned from the MockFactory.createProxy() method call.","(""MockFactory"", ""The createProxy method is a part of the MockFactory class, as it is invoked using the MockFactory.createProxy() syntax."", ""createProxy"")"
This way it is possible to detect if close() is called on the database connection after some method call that uses the connection has completed.,"(""CLOSE"", ""The method CLOSE is called on the DATABASE CONNECTION to terminate or close the connection."", ""DATABASE CONNECTION""); (""METHOD CALL"", ""The METHOD CALL uses the DATABASE CONNECTION, indicating a dependency or interaction between them."", ""DATABASE CONNECTION"")"
"A suggestion would be to have a PersonDao.getConnection() method, even though you'd probably mostly use it during testing.","(""PersonDao"", ""The getConnection method is likely a part of the PersonDao class, as suggested by the naming convention and context."", ""getConnection"")"
From version 2.1.9 it is possible to replace factories at runtime.,"(""Version"", ""The text suggests that the version update allows for the replacement of factories, indicating a relationship between the version and the factory."", ""Factory"")"
"It is also possible to replace several script factories at a time, by using the ScriptFactoryBuilder.replaceFactories(InputStream) method.","(""ScriptFactoryBuilder"", ""The replaceFactories method is a part of the ScriptFactoryBuilder class."", ""replaceFactories""); (""replaceFactories"", ""The replaceFactories method takes an InputStream as a parameter."", ""InputStream"")"
Rather than configuring the PersonDao by hand with dependencies (and their dependencies recursively) you just reuse the configuration of the PersonDao from the application container configuration (the file containerConfig.bcs).,"(""PersonDao"", ""PersonDao is configured using the application container configuration file containerConfig.bcs."", ""containerConfig.bcs"")"
"When designing Butterfly we considered using an XML format for configuration like several alternative DI containers do (Spring, Nano etc.).","(""Butterfly"", ""Butterfly considered using an XML format for configuration."", ""XML""); (""Butterfly"", ""Butterfly is compared to alternative DI containers."", ""DI containers""); (""DI containers"", ""Spring is an example of a DI container."", ""Spring""); (""DI containers"", ""Nano is an example of a DI container."", ""Nano"")"
In this example a java.util.ArrayList() instance is created inside the call to setSomeList().,"(""ArrayList"", ""ArrayList is a class within the java.util package."", ""java.util""); (""ArrayList"", ""ArrayList is used as an instance within the setSomeList method."", ""setSomeList"")"
As you can see the List.add() method is called twice to add the string and myDataSource factory product to the list.,"(""List"", ""The add method is a function of the List class, used to add elements to the list."", ""add""); (""add"", ""The add method is used to add the myDataSource factory product to the list."", ""myDataSource"")"
The fact One of the advantages you get when designing your own language is the freedom to e.g make methods that return void chainable.,"(""Method"", ""The method is described as returning void, indicating a relationship between the method and the return type void."", ""Void"")"
"The [] around the values in the setSomeList() call signals that the values are to be put inside a List or array, depending on the setSomeList() parameter type.","(""setSomeList"", ""The method setSomeList is related to the class List because it can accept a List as a parameter."", ""List"")"
It is possible to map classes to tables and columns using annotations.,"(""Classes"", ""Classes can be mapped to tables using annotations"", ""Tables""); (""Classes"", ""Classes can be mapped to columns using annotations"", ""Columns"")"
You cannot have more than one mapping for the same class using annotation based mapping alone.,"(""Class"", ""The text refers to a class having a mapping, indicating a relationship between the two."", ""Mapping"")"
Each annotation is only allowed once in the code for a given class by the Java compiler.,"(""Class"", ""The Java compiler enforces rules on how annotations are applied to a class."", ""Java Compiler"")"
There are two types of annotations available: A class annotation Annotations for getters and setters.,"(""A"", ""A is a class annotation, which is a type of Annotations"", ""Annotations"")"
AClassMapping The class annotation (AClassMapping) is used ontop of your class name for your POJO classes.,"(""AClassMapping"", ""AClassMapping is used as an annotation on top of POJO classes."", ""POJO classes"")"
"If you set the mappingMode to ""modify"" then Butterfly Persistence will first use automatic mapping to guess as much as it can, and then look at the annotations and modify the class mapping accordingly.","(""MappingMode"", ""MappingMode is set to 'modify' which affects how Automatic Mapping is used."", ""Automatic Mapping""); (""Butterfly Persistence"", ""Butterfly Persistence uses MappingMode for class mapping."", ""MappingMode""); (""Automatic Mapping"", ""Automatic Mapping is adjusted based on Annotations."", ""Annotations""); (""MappingMode"", ""MappingMode modifies class mapping based on Annotations."", ""Annotations"")"
"The tableName element can be set to the name of the table the class is to be mapped to, if it cannot be guessed by the automatic mapping mechanism.","(""tableName"", ""The tableName element is used to specify the name of the table to which the class is mapped."", ""class"")"
"If you have a database generated (e.g auto-incremented) primary key that is mapped to a getter method, you will have to mark the getter method as database generated, to avoid having Butterly Persistence try to set that value in the database.","(""Database"", ""The primary key is a key component of a database, often used to uniquely identify records."", ""Primary Key""); (""Primary Key"", ""The getter method is used to access the primary key value."", ""Getter Method""); (""Butterly Persistence"", ""Butterly Persistence interacts with the database to manage data persistence."", ""Database"")"
The class annotation (AClassMapping) is used ontop of your class name for your POJO classes.,"(""AClassMapping"", ""AClassMapping is used as an annotation on top of the class name for POJO classes."", ""class"")"
"Notice how the second class definition uses manual mapping, so the getter and setter must be fully mapped to columns in the database.","(""Class"", ""The getter method is part of the class definition and is used for accessing class properties."", ""Getter""); (""Class"", ""The setter method is part of the class definition and is used for modifying class properties."", ""Setter"")"
The ASetterMapping annotation is used to map setters of classes to columns in database tables or SQL queries.,"(""ASetterMapping"", ""ASetterMapping is used to map setters to columns in database tables or SQL queries."", ""setters""); (""ASetterMapping"", ""ASetterMapping is used to map setters of classes to columns in database tables or SQL queries."", ""classes"")"
In this example the Employee.class object is the object mapping key.,"(""Employee"", ""The Employee class is described as the object mapping key in the text."", ""object mapping key"")"
"However, if you want Butterfly Persistence to be able to auto-map the target class to the database, the object mapping key should be either a Class object, or an IObjectMappingKey instance.","(""Butterfly Persistence"", ""Butterfly Persistence can auto-map the target class to the database, indicating a relationship between the package and the class."", ""Class""); (""Butterfly Persistence"", ""Butterfly Persistence can use an IObjectMappingKey instance for object mapping, indicating a relationship between the package and the class."", ""IObjectMappingKey"")"
"The IObjectMappingKey instance can contain more information about the class to be mapped, than a Class object can.","(""IObjectMappingKey"", ""IObjectMappingKey is related to Class as it contains more information about the class to be mapped."", ""Class"")"
"An IObjectMappingKey instance has a getObjectClass() method that returns the Class object of the class to map, so automatic mapping is possible in either case.","(""IObjectMappingKey"", ""The getObjectClass method is a part of the IObjectMappingKey class."", ""getObjectClass""); (""getObjectClass"", ""The getObjectClass method returns a Class object."", ""Class""); (""IObjectMappingKey"", ""The IObjectMappingKey class is related to the Class object as it is used for mapping."", ""Class"")"
When checking for tables with similar names to the class to map only the class name itself is used.,"(""Class"", ""The text refers to mapping only the class name itself, indicating a relationship between the class and its name."", ""Class"")"
The ObjectMapper generates various textual combinations based on the class name and checks the database meta data to see if any of these match.,"(""ObjectMapper"", ""The ObjectMapper checks the database meta data to see if any generated textual combinations match."", ""database meta data"")"
"The ObjectMapper mapper breaks the class name into words, based on the uppercase letters and numbers in the class name.","(""ObjectMapper"", ""The ObjectMapper is referred to as a mapper, indicating a relationship between the two."", ""mapper""); (""ObjectMapper"", ""The ObjectMapper is involved in breaking the class name into words, showing a functional relationship."", ""class name""); (""mapper"", ""The mapper is responsible for breaking the class name into words, indicating a functional relationship."", ""class name"")"
Based on these combinations the PersistentObject class name would be similar to the table names PersistentObject persistentObject persistentobject PERSISTENTOBJECT Persistent_Object persistent_object PERSISTENT_OBJECT PersistentObjects persistentObjects persistentobjects PERSISTENTOBJECTS PERSISTENTOBJECTs Persistent_Objects persistent_objects PERSISTENT_OBJECTS PERSISTENT_OBJECTs As you can see there is a reasonable chance that the table name will be guessed if it is similar to the class name.,"(""PersistentObject"", ""The text suggests that the class name 'PersistentObject' is similar to various table name formats, indicating a relationship between the class and its potential table representations."", ""PersistentObject"")"
"The Object Mapper uses reflection to iterate the methods of the class to be mapped, and filters out all other methods than getters and setters.","(""Object Mapper"", ""The Object Mapper uses reflection to iterate over the methods."", ""methods""); (""methods"", ""The methods belong to the class to be mapped."", ""class""); (""getters"", ""Getters are a type of method."", ""methods""); (""setters"", ""Setters are a type of method."", ""methods"")"
If your custom mapper implementation returns an object mapping from the getObjectMapping() method then automatic and annotation based mapping are not applied.,"(""getObjectMapping"", ""The getObjectMapping method returns an object mapping, indicating a direct relationship between the method and the object mapping it returns."", ""object mapping"")"
"If a table name is returned from the getTableName() method, then Butterfly Persistence will not try to guess a table name, nor look at the class annotation for table name.","(""GETTABLENAME"", ""The getTableName() method is used by Butterfly Persistence to determine the table name."", ""BUTTERFLY PERSISTENCE""); (""GETTABLENAME"", ""The getTableName() method interacts with the class annotation to determine the table name."", ""CLASS""); (""BUTTERFLY PERSISTENCE"", ""Butterfly Persistence uses the class annotation to determine the table name if not provided by the getTableName() method."", ""CLASS"")"
If null is returned Butterfly Persistence will look at the class annotation to see if a table name is set there.,"(""Butterfly Persistence"", ""Butterfly Persistence is a package that interacts with the class to check for annotations."", ""class""); (""class"", ""The class contains an annotation that may have a table name set."", ""annotation"")"
If the getObjectMapping() method returned null Butterfly Persistence will call the modify() method to allow your custom object mapper to modify the automatically generated mapping.,"(""getObjectMapping"", ""The modify method is called if the getObjectMapping method returns null, indicating a sequence of operations."", ""modify""); (""Butterfly Persistence"", ""Butterfly Persistence calls the modify method to allow custom object mapping."", ""modify"")"
Before doing so Butterfly Persistence will have applied the annotations in the class to the mapping.,"(""Butterfly Persistence"", ""Butterfly Persistence applies annotations to the mapping."", ""annotations""); (""annotations"", ""Annotations are applied to the mapping."", ""mapping"")"
"If you want Butterfly Persistence to manage the opening of connections, pass a javax.sql.DataSource implementation into the constructor of the PersistenceManager.","(""javax.sql.DataSource"", ""The javax.sql.DataSource implementation is passed into the constructor of the PersistenceManager."", ""PersistenceManager""); (""Butterfly Persistence"", ""Butterfly Persistence manages the opening of connections through the PersistenceManager."", ""PersistenceManager"")"
The readLong() method comes in another version too which takes an optional list of parameters.,"(""ReadLong"", ""The ReadLong method takes an optional list of parameters."", ""Parameters"")"
They will be inserted in the sequence they are passed to the readLong() method.,"(""READLONG"", ""The method readLong() is related to the sequence as it specifies the order in which elements are inserted."", ""SEQUENCE"")"
"The string (4,5,6,7) is an id string which could be returned by the readIdString() method.","(""READIDSTRING"", ""The method readIdString() is related to the string (4,5,6,7) as it could return this string."", ""STRING"")"
The readIdString() method comes in a variant that takes an optional list of parameters.,"(""ReadIdString"", ""The ReadIdString method can take an optional list of parameters, indicating a relationship where parameters are used by the method."", ""Parameters"")"
The IJdbcDao has a few read() methods that allows you to decide what to do with each record in the ResultSet resulting from some SQL query.,"(""IJdbcDao"", ""The read method is part of the IJdbcDao class, indicating that it is a function or operation that the class can perform."", ""read""); (""read"", ""The read method interacts with the ResultSet class, as it processes records from the ResultSet resulting from an SQL query."", ""ResultSet"")"
To do so you must provide the read() method with an implementation of the IResultSetProcessor interface.,"(""READ"", ""The READ method requires an implementation of the IRESULTSETPROCESSOR interface, indicating a dependency or usage relationship."", ""IRESULTSETPROCESSOR"")"
The init() method is called before the iteration of the ResultSet begins.,"(""Init"", ""The Init method is called before the iteration of the ResultSet begins, indicating a procedural relationship where Init prepares or initializes the ResultSet."", ""ResultSet"")"
The process() method is called for each record in the ResultSet The read() method returns an object.,"(""Process"", ""The process() method is called for each record in the ResultSet, indicating a relationship where the method operates on the class."", ""ResultSet""); (""Read"", ""The read() method returns an object, indicating a relationship where the method produces or interacts with an object."", ""Object"")"
This is the object is obtained from the getResult() method of the IResultSetProcessor.,"(""GetResult"", ""The GetResult method is associated with the IResultSetProcessor class as it is a method that belongs to or is used by this class."", ""IResultSetProcessor"")"
Here is an example of how to use a IResultSetProcessor with the read() methods:,"(""IResultSetProcessor"", ""The class IResultSetProcessor is used with the read method, indicating a functional relationship where the class likely processes results obtained from the read method."", ""read"")"
It may be a good idea to create a base class for your IResultSetProcessor implementations with empty method implementations for init() and perhaps a default behaviour for getResult().,"(""IResultSetProcessor"", ""The method 'init' is mentioned as part of the IResultSetProcessor class, suggesting it is a method that can be implemented in this class."", ""init""); (""IResultSetProcessor"", ""The method 'getResult' is mentioned as part of the IResultSetProcessor class, suggesting it is a method that can be implemented in this class."", ""getResult"")"
The read() method comes in a version that takes an optional number of parameters.,"(""Read"", ""The text describes 'read()' as a method."", ""Method"")"
Notice how the number 1975 is passed into the read() method at the end.,"(""1975"", ""The number 1975 is passed as an argument to the READ method, indicating a direct interaction between the two."", ""READ"")"
The execute() method should execute the PreparedStatement and return the result of the execution.,"(""Execute"", ""The execute method is used to execute the PreparedStatement."", ""PreparedStatement"")"
The postProcess() method is normally used to call methods on the PreparedStatement after execution.,"(""PostProcess"", ""The PostProcess method is used to call methods on the PreparedStatement class after execution."", ""PreparedStatement"")"
"To read the ids of X records returned from a query into a string of the format (id1, id2, id3, ...) you will do like this:",NULL
"From version 5.3.9 you no longer need to cast the returned object, if you use a Class object as object mapping key.","(""Class"", ""The Class entity is used as an object mapping key, indicating a relationship between the Class and the object."", ""object"")"
You can also parameterize the SQL statement and pass the parameters to the readList() method.,"(""READLIST"", ""The READLIST method is used to execute or interact with the SQL STATEMENT."", ""SQL STATEMENT"")"
"This text contains a few examples of how to use the object DAO, IObjectDao, so you can get an idea about how to use the IObjectDao class:","(""IObjectDao"", ""The text mentions using the object DAO in relation to the IObjectDao class, suggesting a relationship between them."", ""DAO""); (""IObjectDao"", ""The text explicitly refers to the IObjectDao class, indicating a self-referential relationship."", ""IObjectDao"")"
In addition the Person class and persons table are defined like this:,"(""Person"", ""The Person class is related to the persons table as it likely represents the structure or schema of the data stored in the table."", ""persons"")"
"Thus, it doesn't matter how many fields in a class are mapped to columns in the ""items"" table.","(""Class"", ""The class is mapped to columns in the 'items' table, indicating a relationship between the class and the items."", ""Items"")"
"Therefore you need to create a special object mapping for the given class, that only maps the fields you want to write to columns in the database.","(""Class"", ""class"")"
"The object mapping key could be any object you choose, but if you want help from Butterfly Persistence to map a class to the database, the object mapping key should be either a java.lang.Class object, or an ObjectMappingKey instance.","(""Butterfly Persistence"", ""Butterfly Persistence helps map a class to the database."", ""Class""); (""Butterfly Persistence"", ""Butterfly Persistence can use an ObjectMappingKey instance for object mapping."", ""ObjectMappingKey"")"
"For instance, Employee.class is the object mapping key in the method call below:","(""Employee.class"", ""Employee.class is used as the object mapping key in the method call."", ""method"")"
"To enable easy, always-in-time custom object mapping Butterfly Persistence provides the ObjectMappingKey class for advanced object mapping keys.","(""Butterfly Persistence"", ""The ObjectMappingKey class is provided by Butterfly Persistence for advanced object mapping keys."", ""ObjectMappingKey"")"
Creating an ObjectMappingKey instance is done using the ObjectMappingKey class factory methods.,"(""ObjectMappingKey"", ""The ObjectMappingKey class is related to the ObjectMappingKey method as the method is used to create an instance of the class."", ""ObjectMappingKey"")"
"That is because the ObjectMappingKey's factory methods gives each ObjectMappingKey instance a unique id, an int, which is used by its equals() and hashCode() methods.","(""ObjectMappingKey"", ""The factory methods are used to create instances of the ObjectMappingKey class."", ""factory methods""); (""ObjectMappingKey"", ""The equals() method is used by instances of the ObjectMappingKey class."", ""equals()""); (""ObjectMappingKey"", ""The hashCode() method is used by instances of the ObjectMappingKey class."", ""hashCode()"")"
"This speeds up object mapping cache lookups because the hashCode() method returns this int id, and because equals() also only compares int id's, instead of Class objects, table names etc.","(""hashCode()"", ""Both methods are mentioned in the context of object mapping cache lookups and are related by their use of int id for comparison."", ""equals()""); (""hashCode()"", ""The hashCode() method is typically associated with Class objects for generating hash codes."", ""Class""); (""equals()"", ""The equals() method is typically used to compare Class objects for equality."", ""Class"")"
Instead of the class MyCustomObjectMapper you should use your own class.,"(""MyCustomObjectMapper"", ""The text suggests using a class, indicating that MyCustomObjectMapper is a class."", ""class"")"
The extended class CustomObjectMapperBase is an empty implementation of the ICustomObjectMapper interface.,"(""CustomObjectMapperBase"", ""CustomObjectMapperBase is an implementation of the ICustomObjectMapper interface"", ""ICustomObjectMapper"")"
Just call the IObjectMapping.removeGetterMapping(String name) or IObjectMapping.removeSetterMapping(String name) method to do so.,"(""IObjectMapping"", ""The method removeGetterMapping is a part of the IObjectMapping class."", ""removeGetterMapping""); (""IObjectMapping"", ""The method removeSetterMapping is a part of the IObjectMapping class."", ""removeSetterMapping"")"
The ObjectMappingKey class has some static shortcut factory methods to create object mapping keys that has custom object mappers for auto-generated columns.,"(""ObjectMappingKey"", ""The ObjectMappingKey class contains static shortcut factory methods to create object mapping keys."", ""factory methods"")"
The only thing required to use Butterfly Persistence is that you add the JAR file to the classpath of your application.,"(""Butterfly Persistence"", ""The JAR file is required to use the Butterfly Persistence package."", ""JAR file"")"
"A lot of things are cached internally in the PersistenceManager instance, like object mappings, sql etc., so you should not create a new instance everytime you need it.","(""PersistenceManager"", ""The PersistenceManager class is mentioned as an instance that caches things internally, indicating its role in managing persistence."", ""PersistenceManager"")"
Version control systems typically also makes it easier for multiple people to collaborate - e.g.,NULL
"The Docker base image you are using may itself consist of multiple layers, and can itself be based on another base image etc., until you get down to the most basic Docker image you can create - a raw Linux container image with no special settings applied.",NULL
This example copies a single file from the Docker host at /myapp/target/myapp.jar to the Docker image at /myapp/myapp.jar .,"(""Docker"", ""The Docker package is used to manage and manipulate the File class within the Docker environment."", ""File""); (""File"", ""The File class is being copied from the Docker host to the Docker image, indicating a direct interaction between the two."", ""Docker"")"
This example copies the two files /myapp/config/prod/conf1.cfg and /myapp/conig/prod/conf2.cfg into the Docker image directory /myapp/config/ .,NULL
"In other words, you can create a directory inside the docker image, e.g.",NULL
"called /data which can later be mounted to a directory, e.g.",NULL
In a Maven repository a JAR file is identified by its group name (e.g.,NULL
"the organization that made it), its artifact name (the name of the project / software / tool / API), and a version number (e.g.",NULL
"This example declares a dependency on Log4J using the group name log4j, the artifact name log4j and the version 1.2.17 .","(""Log4J"", ""Log4J is related to log4j as it is declared as a dependency with the group name log4j."", ""log4j""); (""Log4J"", ""Log4J is related to log4j as it is declared as a dependency with the artifact name log4j."", ""log4j"")"
By default the testCompile dependency configuration also includes the compiled classes and the dependencies from the compile dependency configuration.,"(""TESTCOMPILE"", ""The TESTCOMPILE class includes the compiled classes and dependencies from the COMPILE class."", ""COMPILE"")"
The build task will compile all your Java classes and create a JAR file with them in.,"(""build task"", ""The build task compiles Java classes."", ""Java"")"
Gradle outputs classes and JAR file to the directory named build inside your project root directory.,"(""Gradle"", ""Gradle outputs classes to a directory."", ""classes""); (""Gradle"", ""Gradle outputs a JAR file to a directory."", ""JAR file""); (""classes"", ""Classes are output to the build directory."", ""build""); (""JAR file"", ""JAR file is output to the build directory."", ""build"")"
The compiled classes are written to build/classes and the JAR file to build/libs .,"(""CLASSES"", ""Both are outputs of the build process, with classes being compiled and the JAR file being created."", ""JAR FILE"")"
"This is because the classes, jar and assemble tasks are now all UP-TO-DATE from the last run.","(""Classes"", ""Both are mentioned as being UP-TO-DATE from the last run, indicating they are related tasks or components."", ""Jar""); (""Classes"", ""Both are mentioned as being UP-TO-DATE from the last run, indicating they are related tasks or components."", ""Assemble Tasks""); (""Jar"", ""Both are mentioned as being UP-TO-DATE from the last run, indicating they are related tasks or components."", ""Assemble Tasks"")"
"Running the clean task removes the build directory, and thus all compiled classes and created JAR files.","(""clean"", ""The clean method removes the build directory."", ""build directory""); (""clean"", ""The clean method removes all compiled classes and created JAR files."", ""JAR files"")"
"Second, this example calls the myTask doFirst() method, passing along a closure as parameter.","(""myTask"", ""The doFirst method is called on the myTask class."", ""doFirst"")"
"Third, this example calls the myTask doLast() method, passing along another closure as parameter.","(""myTask"", ""The doLast method is called on the myTask class."", ""doLast"")"
"When the task myTask is executed Gradle will first execute all closures passed as parameters the doFirst() method, and then all closures passed as parameters the doLast() method.","(""DOFIRST"", ""Both DOFIRST and DOLAST are methods that execute closures in a specific order when a task is executed in Gradle."", ""DOLAST"")"
"First of all you do not need the semicolon ; after the doFirst() and doLast() method calls, if the code line with the method calls ends with a new line.","(""doFirst"", ""Both are method calls mentioned in the text that do not require a semicolon at the end if the line ends with a new line."", ""doLast"")"
"Second, you do not need the parentheses around the closure when calling doFirst() or doLast().","(""DOFIRST"", ""Both DOFIRST and DOLAST are methods mentioned in the context of calling closures."", ""DOLAST"")"
With these two syntax optimizations you can write the doFirst() and doLast() method calls like this:,"(""doFirst"", ""Both are method calls that can be optimized using syntax optimizations."", ""doLast"")"
Often you will not need to pass closures to both doFirst() and doLast() .,"(""doFirst"", ""Both are methods that can be used to pass closures in a sequence."", ""doLast"")"
It is quite common to pass just a single closure to the doLast() method.,"(""doLast"", ""The text explicitly mentions the doLast() method, indicating it is a method entity."", ""method"")"
"Because this is such a common use case, Gradle has a shortcut for passing a closure to the doLast() method.","(""Gradle"", ""The doLast method is a part of the Gradle package, which provides a shortcut for passing a closure."", ""doLast"")"
The two characters << corresponds to calling the doLast() method like this:,"(""<<"", ""The '<<' characters are used to call the 'doLast' method"", ""doLast"")"
You can even define the task on the same line as you pass the closure to the doLast() method.,"(""doLast"", ""The task is defined using the doLast method, indicating a relationship where the method is used to specify the task's behavior."", ""task"")"
You can also add multiple closures using the doLast() shortcut notation.,"(""doLast"", ""method"")"
"A task could be compiling the source code, generating JavaDoc, zipping the compiled classes into a JAR file etc.","(""source code"", ""Compiling the source code results in compiled classes."", ""compiled classes""); (""compiled classes"", ""The compiled classes are zipped into a JAR file."", ""JAR file"")"
The build script is typically called build.gradle and is normally located in the root directory of the project you are building.,NULL
When you specify another build script Gradle does not use its settings.gradle file.,"(""Gradle"", ""Gradle uses the settings.gradle file as part of its build configuration process."", ""settings.gradle"")"
Gradle will use the build.gradle file found in the project directory (subproject-dir) and will execute the build task in that build script.,"(""Gradle"", ""Gradle uses the build.gradle file to configure the build process."", ""build.gradle""); (""build.gradle"", ""The build task is executed as part of the build.gradle script."", ""build"")"
"Note, that the Predicate interface contains a single unimplemented method named test() which returns a boolean.","(""Predicate"", ""The method 'test' is part of the 'Predicate' class as it is mentioned that the Predicate interface contains this method."", ""test"")"
"After creating the two basic functions, a third Predicate is composed, which calls the test() methods of the two first functions.","(""Predicate"", ""The Predicate class is related to the test method because it calls the test() methods of the two first functions."", ""test"")"
The Predicate interface (java.util.function.Predicate) contains a few methods that help you compose new Predicate instances from other Predicate instances.,"(""Predicate"", ""The Predicate class is part of the java.util.function package."", ""java.util.function""); (""Predicate"", ""The Predicate class can be composed with other Predicate instances."", ""Predicate"")"
The and() method is used to combine two other Predicate functions in the same way I showed in the beginning of this Java functional composition tutorial.,"(""And"", ""The and() method is used to combine two Predicate functions."", ""Predicate""); (""And"", ""The and() method is part of Java functional composition."", ""Java"")"
Here is an example of functional composition with the Predicate and() method:,"(""Predicate"", ""The and() method is a function of the Predicate class, indicating a relationship where the method is part of the class."", ""and()"")"
This Predicate composition example composes a new Predicate from two other Predicate instances using the and() method of one of the basic Predicate instances.,"(""Predicate"", ""The and() method is used to compose a new Predicate from two other Predicate instances."", ""and()"")"
The composed Predicate will return true from it's test() method if both of the Predicate instances it was composed from also return true.,"(""Predicate"", ""The test method is a function of the Predicate class"", ""test"")"
"The Predicate or() method is used to combine a Predicate instance with another, to compose a third Predicate instance.","(""or()"", ""The or() method is used to combine Predicate instances."", ""Predicate"")"
"The composed Predicate will return true if either of the Predicate instances it is composed from return true, when their test() methods are called with same input parameter as the composed Predicate.","(""Predicate"", ""The Predicate class uses the test method to evaluate conditions."", ""test""); (""Predicate"", ""The composed Predicate is related to the Predicate instances it is composed from."", ""Predicate"")"
This Predicate or() functional composition example first creates two basic Predicate instances.,"(""Predicate"", ""The method 'or' is used in conjunction with the class 'Predicate' for functional composition."", ""or"")"
"Second, the example creates a third Predicate composed from the first two, by calling the or() method on the first Predicate and passing the second Predicate as parameter to the or() method.","(""Predicate"", ""The or() method is called on the Predicate class."", ""or""); (""or"", ""The or() method takes a Predicate as a parameter."", ""Predicate"")"
The Java Function interface (java.util.function.Function) also contains a few methods that can be used to compose new Function instances from existing ones.,"(""Function"", ""The Function class is part of the java.util.function package."", ""java.util.function""); (""compose"", ""The compose method is used to create new Function instances from existing ones."", ""Function"")"
"The Java Function compose() method composes a new Function instance from the Function instance it is called on, and the Function instance passed as parameter to the compose() method.","(""compose()"", ""The compose() method is a method that operates on instances of the Function class."", ""Function"")"
"The Function returned by compose() will first call the Function passed as parameter to compose(), and then it will call the Function which compose() was called on.","(""Compose"", ""Compose is a method that returns a Function and calls the Function passed as a parameter."", ""Function""); (""Compose"", ""Compose calls the Function it was called on."", ""Function"")"
"This is easier to understand with an example, so here is a Java Function compose() example:","(""Function"", ""The method 'compose' is an example of the 'Function' class."", ""compose"")"
The Java Function andThen() method works opposite of the compose() method.,"(""AndThen"", ""The AndThen method works opposite of the Compose method."", ""Compose"")"
"A Function composed with andThen() will first call the Function that andThen() was called on, and then it will call the Function passed as parameter to the andThen() method.","(""Function"", ""The andThen method is used to compose two Function instances, where the first Function is called initially, followed by the Function passed to andThen."", ""andThen"")"
"Then the andThen() method is called on the multiply Function to compose a new Function, passing the add Function as parameter to andThen().","(""andThen"", ""The andThen method is called on the multiply class to compose a new Function."", ""multiply""); (""andThen"", ""The andThen method uses the add class as a parameter."", ""add""); (""andThen"", ""The andThen method is used to compose a new Function."", ""Function"")"
Calling the Function composed by andThen() with the value 3 will result in the following calculation 3 * 2 + 3 and the result will be 9.,"(""Function"", ""The Function is composed by using the andThen() method."", ""andThen()"")"
"Note: As mentioned in the beginning, andThen() works opposite of compose().","(""AndThen"", ""AndThen and Compose are related because they are both methods mentioned in the context of their opposite functionality."", ""Compose"")"
"Therefore, calling a.andThen(b) is actually the same as calling b.compose(a) .","(""A"", ""The method A is related to method B because calling A.andThen(B) is equivalent to calling B.compose(A)."", ""B"")"
The Java Function interface (java.util.function.Function) interface is one of the most central functional interfaces in Java.,"(""Function"", ""The Function class is part of the java.util.function package"", ""java.util.function"")"
The only method you have to implement to implement the Function interface is the apply() method.,"(""Function"", ""The apply method is the only method that needs to be implemented for the Function interface."", ""apply"")"
"This Function implementation implements the apply() method so it takes a Long as parameter, and returns a Long.","(""Function"", ""The apply method is implemented by the Function class."", ""apply""); (""apply"", ""The apply method takes a Long as a parameter and returns a Long."", ""Long"")"
"Second, the example calls the apply() method on the AddThree instance.","(""Apply"", ""The Apply method is called on the AddThree instance, indicating a relationship where the method is used by the class."", ""AddThree"")"
"As you can see, the Function interface implementation is now inlined in the declaration of the adderLambda variable, rather than in a separate class.","(""Function"", ""The Function interface is implemented in the declaration of the adderLambda variable."", ""adderLambda"")"
"The Java Predicate interface, java.util.function.Predicate, represents a simple function that takes a single value as parameter, and returns true or false.","(""Predicate"", ""The Predicate class is part of the java.util.function package, indicating it is defined within this package."", ""java.util.function"")"
"The Predicate interface contains more methods than the test() method, but the rest of the methods are default or static methods which you don't have to implement.","(""Predicate"", ""The test method is part of the Predicate interface."", ""test"")"
"You can implement the Predicate interface using a class, like this:","(""Predicate"", ""The Predicate interface can be implemented using a class, indicating a relationship between the Predicate interface and a class."", ""class"")"
This lambda implementation of the Predicate interface effectively does the same as the implementation above that uses a class.,"(""Predicate"", ""The Predicate interface is implemented using a lambda, which is an alternative to using a class implementation."", ""Predicate"")"
This Java Consumer implementation prints the value passed as parameter to it out to System.out.,"(""Consumer"", ""The Consumer class uses the System class to output values."", ""System""); (""System"", ""The out method is part of the System class, used for output operations."", ""out"")"
"Especially the idea of ""no side effects"" makes it hard to e.g.",NULL
"In the functional programming paradigm, functions are first class objects in the language.","(""FUNCTION"", ""Functions are considered first class objects in the language, indicating a relationship between the two."", ""OBJECT"")"
Notice how the return value of the sum() function only depends on the input parameters.,"(""SUM"", ""The return value is a result of the execution of the sum() method."", ""RETURN VALUE""); (""SUM"", ""The sum() method relies on input parameters to produce its return value."", ""INPUT PARAMETERS"")"
"Notice also that the sum() has no side effects, meaning it does not modify any state (variables) outside the function anywhere.","(""SUM"", ""The text refers to 'sum()' as a function, which is synonymous with a method in programming contexts."", ""METHOD"")"
"Notice how the method add() uses a member variable to calculate its return value, and it also modifies the state of the value member variable, so it has a side effect.","(""Add"", ""The method 'Add' uses a member variable to calculate its return value and modifies the state of the member variable, indicating a relationship between them."", ""Member Variable"")"
Notice how the createFactory() method returns a lambda expression as result.,"(""CreateFactory"", ""The CreateFactory method returns a lambda expression as a result."", ""Lambda Expression"")"
Notice also that the createFactory() method takes two instances as parameters which are both implementations of interfaces (IProducer and IConfigurator).,"(""CreateFactory"", ""The CreateFactory method takes an instance of IProducer as a parameter."", ""IProducer""); (""CreateFactory"", ""The CreateFactory method takes an instance of IConfigurator as a parameter."", ""IConfigurator"")"
Therefore they can be implemented by Java lambda expressions - and therefore the createFactory() method is a higher order function.,"(""CreateFactory"", ""The createFactory() method can be implemented by Java lambda expressions, indicating a functional relationship."", ""Java Lambda Expressions""); (""CreateFactory"", ""The createFactory() method is described as a higher order function, indicating its ability to take functions as parameters or return them."", ""Higher Order Function"")"
"A function may have local variables containing temporary state internally, but the function cannot reference any member variables of the class or object the function belongs to.","(""Function"", ""The function is described as belonging to a class, indicating a relationship between the two."", ""Class"")"
"State outside of a function refers both to member variables in the class or object the function, and member variables inside parameters to the functions, or state in external systems like file systems or databases.","(""Class"", ""The function refers to member variables in the class, indicating a relationship between the class and the function."", ""Function"")"
"This is still a functional interface, because only run() is not implemented (abstract).","(""RUN"", ""RUN is identified as a method because it is mentioned as not being implemented, which is a characteristic of methods in interfaces."", ""METHOD"")"
The first example of a higher order function is the Collections.sort() method which takes a Comparator as parameter.,"(""Collections.sort()"", ""The Collections.sort() method takes a Comparator as a parameter, indicating a relationship where the method uses the class."", ""Comparator"")"
The lambda parameter is what makes Collections.sort() a higher order function.,"(""Collections"", ""The method 'sort' is a part of the 'Collections' class."", ""sort"")"
"Second, the example calls the reversed() method on the Comparator lambda.","(""REVERSED"", ""The reversed() method is called on the Comparator class, indicating a functional relationship where the method operates on or utilizes the class."", ""COMPARATOR"")"
"The reversed() method returns a new Comparator lambda, which reverse the result returned by the first Comparator implementation.","(""REVERSED"", ""The reversed() method returns a new Comparator lambda, indicating that the method is related to the Comparator class."", ""COMPARATOR"")"
"By ""reversing"" I mean that it simply returns -1 * comparator.compare(a,b)","(""comparator"", ""The method 'compare' is likely a member of the class 'comparator' as it is being used with it."", ""compare"")"
"Because the reversed() method returns a lambda (function), the reversed() method is considered a higher order function.","(""Reversed"", ""The reversed() method returns a lambda, indicating a relationship where the method produces or utilizes the class."", ""Lambda"")"
"Third, the example sorts the List of Strings using the Collections.sort() method.","(""Collections"", ""The sort method is part of the Collections package."", ""sort""); (""List"", ""List is a class that contains Strings."", ""Strings""); (""Collections"", ""The Collections package provides utilities for working with collections like List."", ""List""); (""sort"", ""The sort method is used to sort a List."", ""List"")"
"In contrast, when you are using the Java Collections iteration features (e.g a Java Iterator or the Java for-each loop used with a Java Iterable) you have to implement the iteration of the elements yourself.","(""Java Collections"", ""Java Iterator is a class used within the Java Collections package for iteration."", ""Java Iterator""); (""Java Collections"", ""Java for-each loop is a method used with Java Collections for iterating over elements."", ""Java for-each loop""); (""Java Collections"", ""Java Iterable is a class that is part of the Java Collections framework, allowing objects to be iterated."", ""Java Iterable""); (""Java Iterator"", ""Java Iterator is used to iterate over elements in a Java Iterable class."", ""Java Iterable""); (""Java for-each loop"", ""Java for-each loop is used with Java Iterable to iterate over its elements."", ""Java Iterable"")"
"Finally, the example calls the stream() method to obtain a Stream instance.","(""stream"", ""The stream() method is used to obtain a Stream instance, indicating a relationship where the method is part of the Stream class."", ""Stream"")"
The call to the map() method of the Stream interface is a non-terminal operation.,"(""Map"", ""The map() method is a method of the Stream interface, indicating a relationship where Map is a method belonging to the Stream class."", ""Stream"")"
The map() method will be covered in more detail later on.,"(""MAP"", ""The term 'map' is identified as a method in the text."", ""METHOD"")"
Notice how the second call to Stream map() is called on the Stream returned by the first map() call.,"(""Stream"", ""The method map() is called on the Stream class."", ""map"")"
The Java Stream filter() can be used to filter out elements from a Java Stream.,"(""Java Stream"", ""The method filter() is used to filter out elements from the Java Stream class."", ""filter()"")"
Here is an example of calling the Java Stream filter() method:,"(""Stream"", ""The filter method is a function that operates on the Stream class."", ""filter"")"
The Java Stream map() method converts (maps) an element to another object.,"(""Java Stream"", ""The map() method is a function of the Java Stream class, used to convert elements."", ""map()"")"
The Java Stream flatMap() methods maps a single element into multiple elements.,"(""Java Stream"", ""The flatMap method is a function of the Java Stream class."", ""flatMap"")"
This example should give you an idea about how flatMap() can be used to map a single element into multiple elements.,"(""flatMap"", ""The method flatMap is used to map a single element into multiple elements."", ""map"")"
This Java Stream flatMap() example first creates a List with 3 strings containing book titles.,"(""Java Stream"", ""The flatMap() method is a function that can be used with the Java Stream class."", ""flatMap()""); (""List"", ""The List is used to provide data that can be processed by the Java Stream class."", ""Java Stream"")"
"Then a Stream for the List is obtained, and flatMap() called.","(""Stream"", ""A Stream is obtained for the List, indicating a relationship where the Stream operates on or is derived from the List."", ""List""); (""Stream"", ""The method flatMap() is called on the Stream, indicating a relationship where flatMap is a method of the Stream class."", ""flatMap"")"
The flatMap() operation called on the Stream has to return another Stream representing the flat mapped elements.,"(""FlatMap"", ""The FlatMap method is called on the Stream class to perform an operation."", ""Stream"")"
Note that this example finishes with a call to forEach() which is a terminal operation.,"(""ForEach"", ""ForEach is described as a terminal operation in the text."", ""Terminal Operation"")"
The Java Stream distinct() method is a non-terminal operation that returns a new Stream which will only contain the distinct elements from the original stream.,"(""Java Stream"", ""The distinct() method is a part of the Java Stream class, used to filter distinct elements."", ""distinct()""); (""distinct()"", ""The distinct() method returns a new Stream containing only distinct elements."", ""Stream"")"
Only the first occurrence of this element will be included in the Stream returned by distinct().,"(""distinct"", ""The method 'distinct' is used to return a Stream with only the first occurrence of each element."", ""Stream"")"
"Thus, the resulting List (from calling collect()) will only contain one, two and three.","(""collect"", ""The method 'collect' is used to create or manipulate a 'List'."", ""List"")"
The Java Stream limit() method can limit the number of elements in a stream to a number given to the limit() method as parameter.,"(""Java Stream"", ""The limit() method is used within the Java Stream class to limit the number of elements in a stream."", ""limit()"")"
The limit() method returns a new Stream which will at most contain the given number of elements.,"(""Limit"", ""The Limit method returns a new Stream, indicating a functional relationship where Limit is used to create or modify a Stream."", ""Stream"")"
"This example first creates a Stream, then calls limit() on it, and then calls forEach() with a lambda that prints out the elements in the stream.","(""Stream"", ""The method limit() is called on the Stream class."", ""limit""); (""Stream"", ""The method forEach() is called on the Stream class."", ""forEach"")"
The Java Stream peek() method is a non-terminal operation that takes a Consumer (java.util.function.Consumer) as parameter.,"(""peek()"", ""The peek() method is a part of the Java Stream class."", ""Java Stream""); (""peek()"", ""The peek() method takes a Consumer from the java.util.function package as a parameter."", ""java.util.function.Consumer"")"
The peek() method returns a new Stream which contains all the elements in the original stream.,"(""Peek"", ""The peek() method is a function that operates on a Stream class, returning a new Stream with the same elements."", ""Stream"")"
"The purpose of the peek() method is, as the method says, to peek at the elements in the stream, not to transform them.","(""PEEK"", ""The text explicitly mentions 'peek()' as a method."", ""METHOD"")"
It is the call to count() at the end of the example that is the terminal operation.,"(""count"", ""The method 'count' is used in the context of the 'example' as a terminal operation."", ""example"")"
"Since count() returns a long, the Stream chain of non-terminal operations (the map() calls) is ended.","(""Count"", ""The method Count is used in the context of a Stream chain."", ""Stream""); (""Map"", ""The method Map is part of the Stream chain of operations."", ""Stream"")"
"The Java Stream anyMatch() method is a terminal operation that takes a single Predicate as parameter, starts the internal iteration of the Stream, and applies the Predicate parameter to each element.","(""anyMatch"", ""The anyMatch method is a terminal operation of the Java Stream class."", ""Java Stream""); (""anyMatch"", ""The anyMatch method takes a Predicate as a parameter."", ""Predicate"")"
"If the Predicate returns true for any of the elements, the anyMatch() method returns true.","(""Predicate"", ""The anyMatch() method uses the Predicate class to evaluate elements."", ""anyMatch"")"
"In the example above, the anyMatch() method call will return true, because the first string element in the stream starts with ""One"".","(""anyMatch"", ""The anyMatch method is called on the stream to evaluate its elements."", ""stream"")"
"The Java Stream allMatch() method is a terminal operation that takes a single Predicate as parameter, starts the internal iteration of elements in the Stream, and applies the Predicate parameter to each element.","(""allMatch"", ""The allMatch method takes a Predicate as a parameter."", ""Predicate""); (""Java Stream"", ""The allMatch method is a terminal operation of the Java Stream class."", ""allMatch"")"
"If the Predicate returns true for all elements in the Stream, the allMatch() will return true.","(""Predicate"", ""The Predicate class is used as a condition in the allMatch() method to evaluate elements."", ""allMatch""); (""Stream"", ""The allMatch() method is called on a Stream to check if all elements match a given Predicate."", ""allMatch"")"
"If not all elements match the Predicate, the allMatch() method returns false.","(""allMatch"", ""The allMatch method uses the Predicate class to determine if all elements match a condition."", ""Predicate"")"
"In the example above, the allMatch() method will return false, because only one of the strings in the Stream starts with ""One"".","(""allMatch"", ""The allMatch method is used on the Stream class to evaluate its elements."", ""Stream"")"
"The Java Stream noneMatch() method is a terminal operation that will iterate the elements in the stream and return true or false, depending on whether no elements in the stream matches the Predicate passed to noneMatch() as parameter.","(""noneMatch"", ""The noneMatch method is a terminal operation of the Java Stream class."", ""Java Stream""); (""noneMatch"", ""The noneMatch method uses a Predicate as a parameter to determine if no elements in the stream match the condition."", ""Predicate"")"
"The noneMatch() method will return true if no elements are matched by the Predicate, and false if one or more elements are matched.","(""noneMatch"", ""The noneMatch method uses the Predicate class to determine if elements match a condition."", ""Predicate"")"
"The Java Stream collect() method is a terminal operation that starts the internal iteration of elements, and collects the elements in the stream in a collection or object of some kind.","(""Java Stream"", ""The collect() method is a terminal operation associated with the Java Stream class."", ""collect()"")"
"Luckily, the Java class java.util.stream.Collectors contains a set of pre-implemented Collector implementations you can use, for the most common operations.","(""java.util.stream.Collectors"", ""The class java.util.stream.Collectors contains implementations of the Collector class."", ""Collector"")"
"In the example above, it was the Collector implementation returned by Collectors.toList() that was used.","(""Collectors"", ""The method 'toList' is a part of the 'Collectors' class, as it is invoked on 'Collectors'."", ""toList""); (""toList"", ""The 'toList' method returns an implementation of the 'Collector' class."", ""Collector"")"
"The Java Stream count() method is a terminal operation which starts the internal iteration of the elements in the Stream, and counts the elements.","(""Java Stream"", ""The count() method is a terminal operation of the Java Stream class."", ""count()"")"
"This example first creates a List of strings, then obtain the Stream for that List, adds a flatMap() operation for it, and then finishes with a call to count().","(""List"", ""The Stream is obtained from the List, indicating a relationship where the List is the source of the Stream."", ""Stream""); (""Stream"", ""The flatMap() method is applied to the Stream, showing a relationship where the Stream is the target of the flatMap() operation."", ""flatMap""); (""Stream"", ""The count() method is called on the Stream, indicating a relationship where the Stream is the target of the count() operation."", ""count"")"
"The count() method will start the iteration of the elements in the Stream which will result in the string elements being split up into words in the flatMap() operation, and then counted.","(""Count"", ""The count() method operates on elements within the Stream class."", ""Stream""); (""FlatMap"", ""The flatMap() method is used in conjunction with the Stream class to process elements."", ""Stream""); (""Count"", ""The count() method is used after the flatMap() operation to count the words."", ""FlatMap"")"
The Java Stream findAny() method can find a single element from the Stream.,"(""Java Stream"", ""The findAny method is a function that operates on the Java Stream class."", ""findAny""); (""findAny"", ""The findAny method is used to find an element from the Stream class."", ""Stream"")"
You can check if an element was found via the Optional isPresent() method.,"(""Optional"", ""The isPresent method is a member of the Optional class, used to check if an element is present."", ""isPresent"")"
"The Java Stream findFirst() method finds the first element in the Stream, if any elements are present in the Stream.","(""Java Stream"", ""The findFirst method is a function that operates on the Java Stream class to find the first element."", ""findFirst"")"
"The findFirst() method returns an Optional from which you can obtain the element, if present.","(""findFirst"", ""The findFirst method returns an Optional, indicating a relationship where the method's output is an Optional object."", ""Optional"")"
You can check if the Optional returned contains an element via its isPresent() method.,"(""Optional"", ""The isPresent method is used to check if the Optional class contains an element."", ""isPresent"")"
"The Java Stream forEach() method is a terminal operation which starts the internal iteration of the elements in the Stream, and applies a Consumer (java.util.function.Consumer) to each element in the Stream.","(""forEach()"", ""The forEach() method is a terminal operation of the Java Stream class."", ""Java Stream""); (""forEach()"", ""The forEach() method applies a Consumer to each element in the Stream, indicating a relationship with the java.util.function.Consumer class."", ""java.util.function.Consumer"")"
The Java Stream min() method is a terminal operation that returns the smallest element in the Stream.,"(""Java Stream"", ""The min() method is a terminal operation of the Java Stream class."", ""min()""); (""min()"", ""The min() method operates on the Stream class to return the smallest element."", ""Stream"")"
Which element is the smallest is determined by the Comparator implementation you pass to the min() method.,"(""Comparator"", ""The Comparator class is used to determine the smallest element when passed to the min() method."", ""min"")"
Notice how the min() method returns an Optional which may or may not contain a result.,"(""MIN"", ""The MIN method returns an OPTIONAL, indicating a relationship where the method's output is encapsulated in the class."", ""OPTIONAL"")"
"If the Stream is empty, the Optional get() method will throw a NoSuchElementException.","(""Optional"", ""The get method is a method of the Optional class."", ""get""); (""Stream"", ""The Optional class is used in the context of a Stream being empty."", ""Optional""); (""get"", ""The get method throws a NoSuchElementException if the Stream is empty."", ""NoSuchElementException"")"
The Java Stream max() method is a terminal operation that returns the largest element in the Stream.,"(""Java Stream"", ""The max() method is a terminal operation associated with the Java Stream class."", ""max()""); (""max()"", ""The max() method operates on the Stream class to return the largest element."", ""Stream"")"
Which element is the largest is determined by the Comparator implementation you pass to the max() method.,"(""Comparator"", ""The Comparator class is used to determine the largest element when passed to the max() method."", ""max"")"
Notice how the max() method returns an Optional which may or may not contain a result.,"(""Max"", ""The Max method returns an Optional, indicating a relationship where Max is the source and Optional is the result it returns."", ""Optional"")"
The Java Stream reduce() method is a terminal operation that can reduce all elements in the stream to a single element.,"(""Java Stream"", ""The reduce() method is a terminal operation of the Java Stream class."", ""reduce()"")"
This Optional contains the value (if any) returned by the lambda expression passed to the reduce() method.,"(""Optional"", ""The reduce() method is used to return a value that is contained within the Optional class."", ""reduce"")"
"The Java Stream toArray() method is a terminal operation that starts the internal iteration of the elements in the stream, and returns an array of Object containing all the elements.","(""Java Stream"", ""The toArray method is a terminal operation of the Java Stream class."", ""toArray"")"
The Java Stream interface contains a static method called concat() which can concatenate two streams into one.,"(""Java Stream"", ""The concat method is a static method within the Java Stream interface."", ""concat"")"
Here is an example of using the Java Stream concat() method:,"(""Stream"", ""The concat() method is a function that belongs to the Stream class."", ""concat()""); (""Java"", ""The Stream class is part of the Java package."", ""Stream"")"
The Java Stream interface contains a static method called of() which can be used to create a Stream from one or more objects.,"(""Java Stream"", ""The method of() is a static method contained within the Java Stream class."", ""of()""); (""of()"", ""The method of() is used to create a Stream from one or more objects."", ""Stream"")"
Here is an example of using the Java Stream of() metho:,"(""Stream"", ""The 'of' method is a method of the 'Stream' class."", ""of"")"
"A graph based stream processing API could instead support a ""sample"" operation where each node in the stream processing graph is asked for any value it may hold internally (e.g.","(""Graph Based Stream Processing API"", ""The 'sample' operation is a method that could be supported by the graph-based stream processing API."", ""Sample"")"
Some graph based stream processing APIs are also designed to kind of hide the iteration of the elements from the user of the API (e.g.,"(""API"", ""class"")"
The full code for the command line argument parsers is listed at the end of this tutorial (it's just one class).,"(""Command Line Argument Parsers"", ""The text indicates that the command line argument parsers are implemented as a single class."", ""Command Line Argument Parsers"")"
The interpretation of these command line arguments could be that the copy program should copy file.txt to a file named file2.txt and overwrite file2.txt if it already exists.,NULL
These command line arguments consists of one switch (-overwrite) and two targets (file.txt and file.2.txt).,NULL
"When the switch -overwrite is removed, the two arguments file.txt and file2.txt remain.","(""switch"", ""The switch is related to file.txt as it is likely used to modify or affect the file."", ""file.txt""); (""switch"", ""The switch is related to file2.txt as it is likely used to modify or affect the file."", ""file2.txt"")"
The command line argument parser consists of a single Java class named CliArgs.,"(""CliArgs"", ""CliArgs is a Java class, indicating it is implemented in the Java programming language."", ""Java"")"
The CliArgs class takes an array of String as argument to its constructor.,"(""CliArgs"", ""The CliArgs class takes an array of String as argument to its constructor."", ""String"")"
The CliArgs class contains the following methods you can use to obtain switch information and values:,"(""CliArgs"", ""The CliArgs class contains methods to obtain switch information and values."", ""methods"")"
The switchPresent() method can be used to ask if a given switch is present or not.,"(""SwitchPresent"", ""The text describes the switchPresent() as a method."", ""Method"")"
"If the command line arguments contains the -overwrite switch anywhere, the switchPresent() method will return true.","(""SWITCHPRESENT"", ""The switchPresent() method checks the command line arguments to determine if the -overwrite switch is present."", ""COMMAND LINE ARGUMENTS"")"
The switchValue() method can be use to obtain the value of a switch.,"(""SwitchValue"", ""The method SwitchValue is used to obtain the value of a switch."", ""Switch"")"
Here is a code example showing how to use switchValue() to read the value of the -port switch:,"(""switchValue"", ""The method switchValue() is used to read the value of the -port switch."", ""port"")"
If you want the value of a switch parsed into a long or double you can use the switchLongValue() and switchDoubleValue() methods.,"(""Switchlongvalue"", ""Both methods are used to parse the value of a switch into different numeric types."", ""Switchdoublevalue"")"
The switchValues() method is used to obtain multiple values for a switch.,"(""SwitchValues"", ""The method SwitchValues is used to obtain multiple values for a switch, indicating a functional relationship between the method and the switch."", ""Switch"")"
The switchValues() method will return all values after the switch and until the next switch is met (next argument starting with a - character).,"(""SwitchValues"", ""The text describes 'switchValues()' as a method."", ""Method"")"
The values of the -from switch will be file1.txt and file2.txt.,"(""from"", ""The method 'from' uses 'file1.txt' as a value."", ""file1.txt""); (""from"", ""The method 'from' uses 'file2.txt' as a value."", ""file2.txt"")"
The values of the -to switch will be copy1.txt and copy2.txt.,NULL
Instead you can create a swith POJO (Plain Old Java Object) class to hold all the switches.,"(""POJO"", ""The POJO class is used to hold all the switches."", ""switches"")"
"You can now read all the switches from the command line directly into an instance of the CliSwitches class, using the switchPojo() method.","(""CliSwitches"", ""The switchPojo method is used to read switches into an instance of the CliSwitches class."", ""switchPojo"")"
The CliArgs switchPojo() method will use the property names inside the class to match against switches in the command line.,"(""switchPojo"", ""The method switchPojo is associated with the class CliArgs as it is a method belonging to this class."", ""CliArgs"")"
The targets() method returns all the arguments which are not switches or switch values.,"(""Targets"", ""The Targets method returns all the arguments, indicating a functional relationship where the method processes or interacts with the arguments."", ""Arguments"")"
"The CliArgs class distinguishes between switch values and targets by assuming, that all arguments which have not been ""taken"" already as switch values must be targets.","(""CliArgs"", ""The CliArgs class distinguishes between switch values and targets."", ""switch values""); (""CliArgs"", ""The CliArgs class distinguishes between switch values and targets."", ""targets"")"
"will the method targets() as executed in the code above, return the String","(""Targets"", ""The method 'Targets' is expected to return a value of type 'String'."", ""String"")"
"Therefore the targets() method call will return the argument web-root , because web-root is the only argument that has not been ""taken"" yet, even if it is located in the middle of the argument list.","(""targets"", ""The targets method returns the argument web-root because it is the only argument not yet taken."", ""web-root"")"
You may need to have at least N next bytes (e.g.,NULL
"To be able to move forth and back in the stream data, you may need to keep the next e.g.",NULL
To solve this problem I will develop a RollingBufferInputStream class which keeps at least N bytes available in a buffer.,"(""RollingBufferInputStream"", ""The RollingBufferInputStream class is designed to keep at least N bytes available in a buffer."", ""buffer"")"
"The RollingBufferInputStream class which I have developed, can be used to iterate an InputStream while at the same time making sure there is always block size bytes available in the buffer.","(""RollingBufferInputStream"", ""The RollingBufferInputStream class is used to iterate over an InputStream."", ""InputStream"")"
"Note: Even if the class is called RollingBufferInputStream, it is not an InputStream subclass.","(""RollingBufferInputStream"", ""RollingBufferInputStream is mentioned in the context of being related to InputStream, suggesting a potential subclass relationship."", ""InputStream"")"
"First you ask if the buffer has N available bytes, by calling hasAvailableBytes().","(""HasAvailableBytes"", ""The method 'hasAvailableBytes()' is called on the buffer to check if it has N available bytes."", ""Buffer"")"
This outline mostly serves to show you the interface of the RollingBufferInputStream class.,"(""RollingBufferInputStream"", ""The text indicates that RollingBufferInputStream is associated with an interface, suggesting a relationship between the class and its interface."", ""interface"")"
"If the call to hasAvailableBytes() detects that there is not enough bytes available in the buffer, it will attempt to fill the buffer.","(""hasAvailableBytes"", ""The method hasAvailableBytes interacts with the buffer class to check the availability of bytes."", ""buffer"")"
"Here is the full hasAvailableBytes() method implementation, so you can see how it works:","(""hasAvailableBytes"", ""The text explicitly refers to hasAvailableBytes as a method."", ""method"")"
"Filling data into the buffer is done by the method fillDataFromStreamIntoBuffer(), which is shown here:","(""FillDataFromStreamIntoBuffer"", ""The method FillDataFromStreamIntoBuffer is responsible for filling data into the buffer."", ""Buffer"")"
"You could use the String.replace() method, but for large amounts of data, and high number of replacements, this performs badly.","(""String"", ""The replace method is a function that belongs to the String class."", ""replace"")"
The String.replace() method creates a new String instance - which is a copy of the original String with the replacements applied.,"(""String"", ""The replace method is a function that operates on the String class to create a new instance with replacements applied."", ""replace""); (""replace"", ""The replace method returns a new String instance after applying the replacements."", ""String"")"
"If you have to perform 5 replacements, you have to call replace() 5 times, each time on the string returned by the last replace() call, like this:","(""replace"", ""The method 'replace' is called multiple times in sequence to perform multiple replacements on a string."", ""replace"")"
"... where N = the size of the string, and M = the number of replacements to perform.",NULL
"Instead of using the String.replace() method I will here present a different, more scalable solution called a TokenReplacingReader.","(""String.replace()"", ""TokenReplacingReader is presented as an alternative solution to the String.replace() method"", ""TokenReplacingReader"")"
The token name (without the enclosing ${} ) is passed to the ITokenResolver.resolveToken(String tokenName) method.,"(""ITokenResolver"", ""The resolveToken method is a part of the ITokenResolver class."", ""resolveToken""); (""resolveToken"", ""The resolveToken method takes a String as a parameter."", ""String"")"
"The TokenReplacingReader is itself a subclass of java.io.Reader, so any class that can use a Reader, can use a TokenReplacingReader.","(""TokenReplacingReader"", ""TokenReplacingReader is a subclass of java.io.Reader, indicating an inheritance relationship."", ""java.io.Reader""); (""TokenReplacingReader"", ""TokenReplacingReader can be used wherever a Reader is used, indicating compatibility or substitution."", ""Reader"")"
The TokenReplacingReader does not use as much memory as the String.replace() method.,"(""TokenReplacingReader"", ""The TokenReplacingReader class is compared to the String.replace() method in terms of memory usage."", ""String.replace()"")"
"... where N is the size of the data to replace tokens in, and M is the number of replacements.",NULL
This is faster than the O(N * M) of the String.replace() method.,"(""String.replace()"", ""The String.replace() method has a time complexity of O(N * M)."", ""O(N * M)"")"
You could create a variant of the TokenReplacingReader which can replace XML entities (e.g.,"(""TokenReplacingReader"", ""The TokenReplacingReader class is designed to replace XML entities."", ""XML entities"")"
"Additionally, since TokenReplacingReader is a java.io.Reader, and it gets its characters from a Reader itself, you can chain it with other java.io.Reader's or InputStreams which does other things (like unzipping, decrypting, converting from UTF-8, UTF-16 etc.)","(""TokenReplacingReader"", ""TokenReplacingReader is a type of java.io.Reader."", ""java.io.Reader""); (""TokenReplacingReader"", ""TokenReplacingReader gets its characters from a Reader."", ""Reader""); (""TokenReplacingReader"", ""TokenReplacingReader can be chained with InputStreams for additional processing."", ""InputStreams"")"
Implementing a Java web crawler is a fun and challenging task often given in university programming classes.,"(""Java"", ""Java is the programming language used to implement the web crawler"", ""web crawler"")"
That way the thread listening for incoming requests spends as much time as possible in the serverSocket.accept() call.,"(""serverSocket"", ""The accept method is called on the serverSocket class to listen for incoming requests."", ""accept"")"
That way the risk is minimized for clients being denied access to the server because the listening thread is not inside the accept() call.,"(""listening thread"", ""The listening thread is related to the accept method because it is responsible for handling incoming connections, which involves calling the accept method."", ""accept"")"
"Here is the code for the WorkerRunnable class, which is passed to the worker thread constructor:","(""WorkerRunnable"", ""The WorkerRunnable class is passed to the worker thread constructor, indicating a relationship where the class is used by the constructor."", ""worker thread constructor"")"
"As mentioned earlier the more time the thread calling serverSocket.accept() spends inside this method call, the more responsive the server will be.","(""ServerSocket"", ""The Accept method is called on the ServerSocket class to handle incoming connections."", ""Accept"")"
Only when the listening thread is inside the accept() call can clients connect to the server.,"(""accept"", ""The listening thread uses the accept() method to allow clients to connect to the server."", ""listening thread"")"
Clients can only connect to the server while the server is inside the serverSocket.accept() method call.,"(""ServerSocket"", ""The Accept method is a function that belongs to the ServerSocket class."", ""Accept""); (""Clients"", ""Clients connect to the Server, indicating a relationship between these two classes."", ""Server""); (""Server"", ""The Server is likely using the ServerSocket class to manage connections."", ""ServerSocket"")"
"The longer time the listening thread spends outside the serverSocket.accept() call, the higher the probability that the client will be denied access to the server.","(""ServerSocket"", ""The Accept method is called on the ServerSocket class to listen for incoming connections."", ""Accept""); (""Client"", ""The Client interacts with the ServerSocket to establish a connection."", ""ServerSocket"")"
That way the listening thread spends as little time as possible outside the serverSocket.accept() call.,"(""serverSocket"", ""The accept method is called on the serverSocket class."", ""accept"")"
"For instance, if you process 1.000 requests concurrently and each request takes 1 second, then all requests will take 1.000 seconds to complete.",NULL
"To use IText PDF API for Java you must first download the IText JAR file from the IText website, and include it on your application class path.","(""IText"", ""IText is a package that provides the PDF API functionality."", ""PDF API""); (""IText"", ""The IText package is distributed as a JAR file."", ""JAR""); (""JAR"", ""The JAR file needs to be included in the application class path."", ""class path""); (""IText"", ""IText is used in Java applications."", ""Java"")"
"The com.itextpdf.text.Anchor class in IText represents an link, either to an external website, or internally in the document.","(""Anchor"", ""The Anchor class is part of the com.itextpdf.text package."", ""com.itextpdf.text""); (""Anchor"", ""The Anchor class is used within the IText package."", ""IText"")"
"The com.itextpdf.text.Chunk class in IText represents the smallest possible ""chunk"" of text.","(""Com.itextpdf.text.Chunk"", ""The Com.itextpdf.text.Chunk class is part of the IText package."", ""IText"")"
"If you need to generate a PDF document from scratch, you will use the Document class.","(""Document"", ""The Document class is used to generate a PDF document."", ""PDF document"")"
"You can specify fonts for most text objects (Chunk, Phrase, Paragraph etc.)","(""Chunk"", ""Both are text objects that can have fonts specified."", ""Phrase""); (""Chunk"", ""Both are text objects that can have fonts specified."", ""Paragraph""); (""Phrase"", ""Both are text objects that can have fonts specified."", ""Paragraph"")"
The com.itextpdf.text.Image is used to add images to IText PDF documents.,"(""Com.itextpdf.text.Image"", ""The class Com.itextpdf.text.Image is used within the IText package to add images to PDF documents."", ""IText"")"
You set the absolute position of an image using the setAbsolutePosition() method.,"(""setAbsolutePosition"", ""The setAbsolutePosition method is used to set the absolute position of an image."", ""image"")"
"If you already have a finished PDF, and just want to add a header, footer or watermark to it, IText provides the com.itextpdf.pdf.PdfStamper class.","(""IText"", ""The com.itextpdf.pdf.PdfStamper class is provided by the IText package."", ""com.itextpdf.pdf.PdfStamper"")"
You can set the alignment of the paragraph using the setAlignment() method.,"(""SETALIGNMENT"", ""The setAlignment method is used to set the alignment of the paragraph."", ""PARAGRAPH"")"
"You can write text as superscript or subscript using the Chunk class, and it's setTextRise() method.","(""Chunk"", ""The setTextRise method is a function of the Chunk class, allowing text to be written as superscript or subscript."", ""setTextRise"")"
You can add tables to a PDF document using the com.itextpdf.text.PdfPTable class in IText.,"(""PdfPTable"", ""PdfPTable is a class within the com.itextpdf.text package."", ""com.itextpdf.text""); (""PdfPTable"", ""PdfPTable is used in the context of the IText package."", ""IText"")"
"To add cells to the table you call the addCell() method, passing PdfPCell instances, or other IText objects like Paragraph etc.","(""Addcell"", ""The addCell() method is used to add PdfPCell instances to the table."", ""Pdfpcell""); (""Addcell"", ""The addCell() method can also accept other IText objects."", ""Itext""); (""Addcell"", ""The addCell() method can accept Paragraph objects, which are part of the IText package."", ""Paragraph"")"
"You can set the column widths using the setWidths() method, like this:","(""setWidths"", ""The setWidths method is used to set the column widths."", ""column widths"")"
"If you need a cell to span multiple columns you can do so using the setColspan() method, like this:","(""setColspan"", ""The setColspan method is used to make a cell span multiple columns."", ""cell"")"
"In text mode the settings of the added element (Phrase, Paragraph etc.)","(""Phrase"", ""Both Phrase and Paragraph are examples of elements that can be added in text mode."", ""Paragraph"")"
Content added via the PdfCell.addElement() method is considered composite mode content.,"(""PdfCell"", ""The addElement method is a function of the PdfCell class."", ""addElement"")"
"You can set the default cell settings of new cells added, using the table.addCell() methods, like this:","(""Table"", ""The AddCell method is used to set the default cell settings for new cells added to the Table class."", ""AddCell"")"
The method setIndent() sets the indentation of the first paragraph in the cell.,"(""SetIndent"", ""The method SetIndent is used to set the indentation of the first paragraph in the cell."", ""Indentation"")"
The method setFollowingIndent() sets the indentation of the following paragraphs in the cell.,"(""setFollowingIndent"", ""The method setFollowingIndent() is related to the following paragraphs as it sets their indentation."", ""following paragraphs"")"
The method setRightIndent() sets the right indentation of the cell content.,"(""setRightIndent"", ""The method setRightIndent() is used to set the right indentation of the cell content."", ""cell content"")"
"If the cell is in composite mode, just set the leading on the element added, e.g.","(""Cell"", ""The cell is described as being in composite mode, indicating a relationship between the two."", ""Composite Mode""); (""Element"", ""The element is added to the cell, suggesting a relationship between them."", ""Cell"")"
The second method call sets the leading to 0 points + 1.5 x font height.,"(""Method"", ""The method call involves a calculation using the font height."", ""Font Height"")"
"You can set the rotation of the cell content using the setRotation() method, like this:","(""setRotation"", ""The setRotation method is used to set the rotation of the cell content."", ""cell content"")"
"You can add underline and strikethrough text using the Chunk class, and its setUnderline() method.","(""Chunk"", ""The setUnderline method is a function of the Chunk class, indicating a direct relationship where the method is used to manipulate or interact with instances of the class."", ""setUnderline"")"
Quite often Java applications keep objects in data structures that contain java.util.ArrayList instances.,"(""ArrayList"", ""ArrayList is a class within the java.util package"", ""java.util""); (""Java"", ""Java applications often use ArrayList instances to keep objects in data structures"", ""ArrayList"")"
This tutorial will also look at the performance of the OpenArrayList class - a class that mimics the java.util.ArrayList but designed with performance in mind.,"(""OpenArrayList"", ""OpenArrayList is a class that mimics the java.util.ArrayList"", ""java.util.ArrayList"")"
Each element is obtained from the ArrayList instance using the get() method.,"(""ArrayList"", ""The get method is used to obtain elements from the ArrayList class instance."", ""get"")"
The third way to iterate an ArrayList is to use an java.util.Iterator obtained from the ArrayList.,"(""ArrayList"", ""The java.util.Iterator is obtained from the ArrayList to iterate over its elements."", ""java.util.Iterator""); (""java.util.Iterator"", ""The java.util.Iterator is part of the java.util package."", ""java.util"")"
The benchmarks were executed using JDK 1.8.0_u60 on a Intel Core i7-4770 Haswell server which was doing nothing but the benchmarks.,"(""JDK"", ""The JDK package was executed on the Intel Core i7-4770 Haswell server."", ""Intel Core i7-4770 Haswell"")"
"You can also see that iterating an ArrayList using a standard Java for loop with a counter, and obtaining each element by calling the ArrayList get() method is about 10% faster for an ArrayList with 10 elements, and around 12,5% faster when the ArrayList contains 100 elements.","(""ArrayList"", ""The get method is used to obtain each element from an ArrayList."", ""get""); (""Java"", ""ArrayList is a class in the Java package."", ""ArrayList"")"
The OpenArrayList class is a very simple imitation of the ArrayList which I have implemented to see if it could iterate a collection of elements faster than an ArrayList .,"(""OpenArrayList"", ""OpenArrayList is an imitation of the ArrayList class."", ""ArrayList"")"
"This should be a tiny bit faster than calling the ArrayList get() method, although the JVM could optimize the get() method call away.","(""ArrayList"", ""The get method is a method of the ArrayList class."", ""get"")"
Another advantage of making the elements array public is that you can write to it or copy from it using System.arraycopy() which is very fast.,"(""System"", ""The method arraycopy is part of the System package, which is why they are related."", ""arraycopy"")"
The fact that the performance is so close is probably a sign that the JVM has optimized the get() call away.,"(""JVM"", ""The JVM is responsible for optimizing the performance of the get() method call."", ""get()"")"
"As you can see, the readMyData() method returns a MyData object.","(""READMYDATA"", ""The READMYDATA method returns an object of the MYDATA class."", ""MYDATA"")"
What is worth noting about this read pattern is that every time you call the readMyData() method a new MyData object is returned.,"(""READMYDATA"", ""The READMYDATA method returns a new instance of the MYDATA class each time it is called."", ""MYDATA"")"
If the readMyData() method is called frequently that will lead to a lot of MyData objects being created.,"(""ReadMyData"", ""The ReadMyData method is responsible for creating instances of the MyData class."", ""MyData"")"
Here is how the earlier readMyData() method would look using the read-into-existing pattern:,"(""readMyData"", ""The readMyData method is being described in the context of using the read-into-existing pattern."", ""read-into-existing"")"
"It is now up to the caller of the readMyData() method to decide if an existing MyData instance should be reused, or if a new instance should be created.","(""ReadMyData"", ""The ReadMyData method is responsible for handling instances of the MyData class, either by reusing an existing instance or creating a new one."", ""MyData"")"
Reusing an object also means that the chance the object is located in the CPU cache is much higher than when you create a new object for each call to the readMyData() method.,"(""READMYDATA"", ""The method readMyData() is likely to be called on or interact with an object."", ""OBJECT"")"
To change the previous example code to read data directly from the underlying source we need to change the implementation of the MyData class:,"(""MyData"", ""The text mentions changing the implementation of the MyData class, indicating that MyData is a class entity."", ""class"")"
"To use the MyData class in its new variation, you will use code like this:","(""MyData"", ""class"")"
Just call setSource() when you need to read data out of a new byte array.,"(""setSource"", ""The method setSource is used to read data from a byte array."", ""byte array"")"
"Third, only if you actually call both getVal1() and getVal2() will the corresponding data be read out of the underlying byte array.","(""GETVAL1"", ""Both methods need to be called to read the corresponding data from the underlying byte array."", ""GETVAL2"")"
"Assuming that each MyData object consists of 2 bytes from the underlying source, here is how the MyData class would look with a navigation method added:","(""MyData"", ""The navigation method is added to the MyData class, indicating a functional relationship where the method is part of the class."", ""navigation"")"
The first change is the that the setSource() method now takes an extra parameter called offset.,"(""SETSOURCE"", ""The OFFSET parameter is an additional argument for the SETSOURCE method."", ""OFFSET"")"
The second change is that the getVal1() and getVal2() methods now use the value of the internal offset variable as index into the source array when reading values out.,"(""getVal1"", ""The method getVal1 uses the internal offset variable as an index."", ""internal offset""); (""getVal2"", ""The method getVal2 uses the internal offset variable as an index."", ""internal offset""); (""getVal1"", ""The method getVal1 reads values from the source array."", ""source array""); (""getVal2"", ""The method getVal2 reads values from the source array."", ""source array"")"
"The next() method increments the internal offset variable by 2, so that the offset variable points to the next record in the array.","(""Next"", ""The Next method increments the internal Offset variable by 2."", ""Offset""); (""Next"", ""The Next method points to the next Record in the array."", ""Record"")"
The fourth change is the addition of the hasNext() method which returns true if the source byte array has more records (bytes) in it.,"(""hasNext"", ""The hasNext method checks if the source byte array has more records (bytes) in it."", ""source byte array"")"
"As you can see, using the MyData class in the navigator pattern implementation is pretty straightforward.","(""MyData"", ""The MyData class is used in the implementation of the navigator pattern."", ""navigator pattern"")"
"Additionally, if your server works on many tasks at the same time (e.g incoming HTTP requests), the other CPUs in your server may already be busy working on their own tasks.","(""HTTP"", ""HTTP is a type of request that the server handles."", ""server"")"
"My own experiences come from from a mix of Java performance experiments, as well as the design and development of VStack.co - a fully hosted application backend which I have cofounded with WorpCloud Ltd.","(""VStack.co"", ""VStack.co is a fully hosted application backend cofounded with WorpCloud Ltd."", ""WorpCloud Ltd."")"
"The Java ArrayList class only works for objects - not for primitive types (byte, int, long etc).","(""ArrayList"", ""The ArrayList class is part of the Java package."", ""Java"")"
The code consist of 3 Java classes and 2 unit tests.,"(""Java"", ""The unit tests are related to the Java classes as they are used to test the functionality of these classes."", ""unit tests"")"
100.000 x 1MB = 100GB (approximately - not precisely - but you get the picture).,NULL
"Note, that in languages with built-in garbage collection (like Java, C# etc.)","(""Java"", ""Both Java and C# are programming languages with built-in garbage collection."", ""C#"")"
Even at 4GB (1.000.000 x 4KB) modern servers should be able to handle it.,"(""4GB"", ""4GB is a data size that modern servers should be able to handle"", ""modern servers"")"
"Additionally, if you use a small block size, you may have to expand blocks more often than if you use e.g.",NULL
"To obtain a ResizableArray instance, call the ResizableArrayBuffer's getArray() method, like this:","(""ResizableArrayBuffer"", ""The getArray method is a function of the ResizableArrayBuffer class."", ""getArray""); (""ResizableArray"", ""The ResizableArray instance is obtained through the ResizableArrayBuffer class."", ""ResizableArrayBuffer"")"
The ResizableArray class in the GitHub repository only contains a single write() method which takes a ByteBuffer as parameter.,"(""ResizableArray"", ""The write method is contained within the ResizableArray class."", ""write""); (""write"", ""The write method takes a ByteBuffer as a parameter."", ""ByteBuffer""); (""ResizableArray"", ""The ResizableArray class is part of the GitHub repository."", ""GitHub"")"
"It should be pretty easy to add more write() methods yourself, though.","(""WRITE"", ""METHOD"")"
The value returned by write() is the number of bytes copied from the ByteBuffer.,"(""WRITE"", ""The method WRITE operates on the CLASS BYTEBUFFER to copy bytes."", ""BYTEBUFFER"")"
"If the ResizableArray cannot contain all the data in the ByteBuffer after expanding itself to the max size, the write() method will return -1 and no data will have been copied at all!","(""ResizableArray"", ""The write method is associated with the ResizableArray class as it is mentioned in the context of its operation."", ""write""); (""ByteBuffer"", ""The ResizableArray class interacts with ByteBuffer as it attempts to contain data from ByteBuffer."", ""ResizableArray"")"
"You do so simply by calling the free() method on the ResizableArray, like this:","(""Free"", ""The Free method is called on the ResizableArray class to perform an action."", ""ResizableArray"")"
"Calling free() takes care of returning the used block to the correct block queue, regardless of the size of the block allocated to the ResizableArray.","(""FREE"", ""The method FREE is used to manage memory blocks allocated to the class RESIZABLEARRAY."", ""RESIZABLEARRAY"")"
I have implemented batch mode put() and take() operations for both ring buffer implementations.,"(""put"", ""The put method is implemented for the ring buffer class."", ""ring buffer""); (""take"", ""The take method is implemented for the ring buffer class."", ""ring buffer"")"
My benchmarks showed that batch put() and take() operations provides up to 4 times the throughput of putting and taking a single element at a time.,"(""Put"", ""Both Put and Take are methods mentioned in the context of batch operations for throughput improvement."", ""Take"")"
Here is an implementation of the ring buffer that uses a fill count including the batch put() and take() operations.,"(""Ring Buffer"", ""The Fill Count method is used within the Ring Buffer class to manage the number of elements."", ""Fill Count""); (""Ring Buffer"", ""The Batch Put method is an operation of the Ring Buffer class for adding multiple elements."", ""Batch Put""); (""Ring Buffer"", ""The Take method is an operation of the Ring Buffer class for removing elements."", ""Take"")"
"Here is an implementation of the ring buffer that uses a read position and flip marker, including the batch put() and take() operations.","(""Ring Buffer"", ""The Read Position is a method used in the Ring Buffer class."", ""Read Position""); (""Ring Buffer"", ""The Flip Marker is a method used in the Ring Buffer class."", ""Flip Marker""); (""Ring Buffer"", ""The Batch Put is a method used in the Ring Buffer class."", ""Batch Put""); (""Ring Buffer"", ""The Take is a method used in the Ring Buffer class."", ""Take"")"
"The JMH Maven archetype will generate a new Java project with a single, example benchmark Java class, and a Maven pom.xml file.","(""JMH Maven archetype"", ""The JMH Maven archetype generates a Java project, indicating a relationship between the archetype and the Java class."", ""Java""); (""JMH Maven archetype"", ""The JMH Maven archetype generates a Maven pom.xml file, indicating a relationship between the archetype and the pom.xml file."", ""pom.xml"")"
The Maven pom.xml file contains the correct dependencies to compile and build your JMH microbenchmark suite.,"(""Maven"", ""The pom.xml file is associated with Maven as it is used to manage dependencies in Maven projects."", ""pom.xml""); (""JMH"", ""The pom.xml file contains dependencies necessary for building the JMH microbenchmark suite."", ""pom.xml"")"
"It is time to write your first JMH benchmark class, or at least see how it is done.","(""JMH"", ""The benchmark class is part of the JMH package, which is used for writing benchmarks."", ""benchmark"")"
The generated MyBenchmark class is a JMH class template which you can use to implement your JMH benchmarks.,"(""MyBenchmark"", ""MyBenchmark is a class that serves as a template for implementing JMH benchmarks, indicating it is related to the JMH package."", ""JMH"")"
"You can either implement your benchmarks directly in the generated MyBenchmark class, or create a new class in the same Java package.","(""MyBenchmark"", ""The MyBenchmark class can be implemented in the Java package, indicating a relationship between the class and the package."", ""Java"")"
To make it easy for you to write your first JMH benchmark I will just use the generated class in this example.,"(""JMH"", ""The benchmark class is part of the JMH package, which is used for writing benchmarks."", ""benchmark"")"
You can put the code you want to measure inside the testMethod() method body.,"(""testMethod"", ""The text explicitly mentions testMethod as a method."", ""method"")"
"For now, just imagine that the testMethod() body actually contained a good benchmark implementation.","(""testMethod"", ""method"")"
"When you build your JMH benchmarks, Maven will always generate a JAR file named benchmarks.jar in the target directory (Maven's standard output directory).","(""Maven"", ""Maven generates the benchmarks.jar file as part of the build process."", ""benchmarks.jar""); (""JMH"", ""JMH benchmarks are compiled into the benchmarks.jar file."", ""benchmarks.jar"")"
It contains your compiled benchmark classes as well as all JMH classes needed to run the benchmark.,"(""Benchmark"", ""The Benchmark class is part of the JMH package, which is needed to run the benchmark."", ""JMH"")"
"If your benchmarks has any external dependencies (JAR files from other projects needed to run your benchmarks), declare these dependencies inside the Maven pom.xml, and they will be included in the benchmarks.jar too.","(""Maven"", ""The pom.xml file is a configuration file used by the Maven package to manage project dependencies."", ""pom.xml""); (""pom.xml"", ""The dependencies declared in the pom.xml file are included in the benchmarks.jar file."", ""benchmarks.jar"")"
"Since benchmarks.jar is fully self contained, you can copy that JAR file to another computer to run your JMH benchmarks on that computer.","(""benchmarks.jar"", ""benchmarks.jar is used to run JMH benchmarks, indicating a relationship between the package and the benchmarks it supports."", ""JMH"")"
This means that you want the output shown using the time unit minutes (e.g.,NULL
"State variables are declared in special state classes, and an instance of that state class can then be provided as parameter to the benchmark method.","(""State Variables"", ""State variables are declared in special state classes, indicating a relationship where state variables belong to or are part of state classes."", ""State Classes""); (""State Classes"", ""An instance of the state class can be provided as a parameter to the benchmark method, showing a relationship where state classes are used by benchmark methods."", ""Benchmark Method"")"
In this example I have added a nested static class named MyState.,"(""MyState"", ""class"")"
Notice that the testMethod() benchmark method now takes an instance of MyState as parameter.,"(""TESTMETHOD"", ""The method TESTMETHOD takes an instance of the class MYSTATE as a parameter."", ""MYSTATE"")"
Notice also that the testMethod() body has now been changed to use the MyState object when performing its sum calculation.,"(""testMethod"", ""The method testMethod uses the MyState class to perform its sum calculation."", ""MyState"")"
Notice the two new methods in the MyState class named doSetup() and doTearDown().,"(""MyState"", ""The method doSetup is part of the MyState class."", ""doSetup""); (""MyState"", ""The method doTearDown is part of the MyState class."", ""doTearDown"")"
"If you have any doubts about when a setup or tear down method is called, try inserting a System.out.println() statement in the method.","(""System.out.println()"", ""System.out.println() is a method that can be inserted into another method to print output for debugging purposes."", ""method"")"
"If your benchmark method is calculating multiple values that might end up being eliminated as dead code, you can either combine the two values into a single, and return that value (e.g.","(""benchmark method"", ""The benchmark method involves calculating multiple values."", ""calculate"")"
Notice how the testMethod() benchmark method now takes a Blackhole object as parameter.,"(""TESTMETHOD"", ""The TESTMETHOD method takes a BLACKHOLE object as a parameter, indicating a functional relationship between the method and the class."", ""BLACKHOLE"")"
Notice also how the calculated sum in the sum variable is now passed to the consume() method of the Blackhole instance.,"(""Consume"", ""The consume() method is a part of the Blackhole class, as indicated by the use of the method on an instance of Blackhole."", ""Blackhole"")"
"If your benchmark method produces multiple results you can pass each of these results to a black hole, meaning calling consume() on the Blackhole instance for each value.","(""Benchmark Method"", ""The benchmark method results are passed to the Blackhole instance."", ""Blackhole""); (""Consume"", ""The consume() method is called on the Blackhole instance."", ""Blackhole"")"
"The JVM could even continue and never call the testMethod() because it knows it always returns 3, and just inline the constant 3 wherever the testMethod() was to be called.","(""JVM"", ""The JVM may choose not to call the testMethod() because it can optimize by inlining the constant value returned by the method."", ""testMethod"")"
Sometimes a lot of time is even spent just allocating and freeing memory (e.g.,NULL
"When you control object allocation, deallocation and reallocation you can make limits like e.g.",NULL
having a maximum of 10.000 messages in memory at a time.,NULL
"The batch size can thus vary from 1 to a maximum upper limit set by the system, e.g.",NULL
"To achieve lower latency, yet allowing for micro batching to happen, you can loop over the input channels (inbound network connections, directories etc.)",NULL
Therefore it can be beneficial to batch up data sent outside a process to minimize the overhead per data block (e.g.,NULL
"Instead of traversing the whole data structure to serve just one ""request"" (task, message etc.)","(""Request"", ""The term 'request' is used to describe a task or message, indicating it is a class of operations or actions."", ""Request"")"
Notice how two different DAO's were called from inside the control's execute() method.,"(""control"", ""The execute method is part of the control class, as it is called from inside the control."", ""execute""); (""DAO"", ""The execute method calls the DAO class, indicating a relationship where the method utilizes the DAO."", ""execute"")"
"To make this happen you need to obtain a database connection (or equivalent object) inside the Control.execute() method, and pass this connection (or other object) to each DAO.","(""Control"", ""The execute method is a function that belongs to the Control class."", ""execute"")"
"Well, you could if you call a setConnection() method on them afterwards.","(""setConnection"", ""The method setConnection is called on the object referred to as 'them'."", ""them"")"
The DaoManager is a class that you put in between the Control and the DAO's.,"(""DaoManager"", ""DaoManager is positioned between Control and DAO's, indicating a relationship."", ""Control""); (""DaoManager"", ""DaoManager is positioned between Control and DAO's, indicating a relationship."", ""DAO's"")"
Once the DaoManager.executeAndClose() method finishes the database connection inside the DaoManager is closed.,"(""DaoManager"", ""The executeAndClose method is a function that belongs to the DaoManager class."", ""executeAndClose"")"
"As you can see from the code example in the previous section, the scope of the connection when managed by the DaoManager.executeAndClose() is the boundaries of the executeAndClose() method.","(""DaoManager"", ""The executeAndClose method is managed by the DaoManager class, indicating a relationship where the class likely contains or utilizes the method."", ""executeAndClose"")"
This could be the case in a desktop application if each control is registered independently as listeners on e.g.,NULL
It is the DaoManager's executeAndClose() method that demarcates the life span of the underlying connection.,"(""DaoManager"", ""The executeAndClose method is a function of the DaoManager class."", ""executeAndClose"")"
"If you call this method from each control's execute() method (or whatever the central execution method in your controls is called), each control will open and close a connection separately.","(""method"", ""The text refers to calling a method named 'execute' from each control's execution method."", ""execute"")"
The ScopingDataSource will be moved to Butterfly Persistence from around version 5.2.0 or 5.4.0 which will be released in 2009.,"(""ScopingDataSource"", ""The class ScopingDataSource will be moved to the package Butterfly Persistence."", ""Butterfly Persistence"")"
The ScopingDataSource is an implementation of the standard Java interface javax.sql.DataSource.,"(""ScopingDataSource"", ""ScopingDataSource is an implementation of the javax.sql.DataSource interface"", ""javax.sql.DataSource"")"
"Once this method is called, whenever the tread that called this method calls the ScopingDataSource.getConnection() method, the same connection instance is returned.","(""Method"", ""The Method is related to ScopingDataSource.getConnection because it specifies the behavior when the ScopingDataSource.getConnection method is called."", ""ScopingDataSource.getConnection"")"
"This ScopingConnection ignores all calls to the close() method, so the underlying connection can be reused.","(""ScopingConnection"", ""The ScopingConnection class ignores calls to the close method, indicating a direct interaction between the class and the method."", ""close"")"
"When you are ready to close the connection your control calls the ScopingDataSource.endConnectionScope(), and the currently open connection (if any) is closed.","(""ScopingDataSource"", ""The method endConnectionScope is a part of the ScopingDataSource class, as indicated by the syntax ScopingDataSource.endConnectionScope()."", ""endConnectionScope"")"
"From here on the ScopingDataSource behaves just like a regular DataSource, returning a new Connection for every call to getConnection().","(""ScopingDataSource"", ""ScopingDataSource behaves like a regular DataSource, indicating a relationship between the two classes."", ""DataSource""); (""ScopingDataSource"", ""ScopingDataSource returns a new Connection for every call, indicating a relationship between the class and the Connection class."", ""Connection""); (""getConnection"", ""The method getConnection() is used to obtain a new Connection, indicating a relationship between the method and the Connection class."", ""Connection"")"
"The calls to beginConnectionScope() and endConnectionScope() do not have to be located within the same method, nor within the same class.","(""beginConnectionScope"", ""beginConnectionScope is a method that can be called within a class."", ""method""); (""endConnectionScope"", ""endConnectionScope is a method that can be called within a class."", ""method""); (""method"", ""Methods are typically defined within a class."", ""class"")"
"You can just extend the DBControlBase and override the doExecute() method, then all connection scoping is done for you.","(""DBControlBase"", ""The doExecute method is overridden in the DBControlBase class."", ""doExecute"")"
"They can be called outside the Control.execute() method too, or inside a parent control.","(""Control"", ""The execute method is a part of the Control class, as indicated by the syntax Control.execute()."", ""execute"")"
"If your Control class implements an interface, you can implement a Dynamic Proxy which implements the same interface.","(""Control"", ""Both Control and Dynamic Proxy implement the same interface, indicating a relationship between them."", ""Dynamic Proxy"")"
"When the execute() method is called on the control interface, this dynamic proxy will call the beginConnectionScope(), then call your controls execute() method, and finally the endConnectionScope().","(""control"", ""The execute() method is called on the control class, indicating a direct relationship between the class and the method."", ""execute()""); (""execute()"", ""The execute() method calls the beginConnectionScope() method, showing a sequence of operations."", ""beginConnectionScope()""); (""execute()"", ""The execute() method calls the endConnectionScope() method, showing a sequence of operations."", ""endConnectionScope()"")"
The only difference is that you call beginTransactionScope() and endTransactionScope() instead.,"(""beginTransactionScope"", ""Both methods are likely related as they are used to start and end a transaction scope, respectively."", ""endTransactionScope"")"
"When a connection is obtained from the ScopingDataSource while inside a transaction scope, connection.setAutoCommit(false) is called.","(""ScopingDataSource"", ""The method setAutoCommit is called on a connection obtained from the ScopingDataSource class."", ""setAutoCommit"")"
"If an exception is thrown before the endTransactionScope() method is called, you should catch that exception and call abortTransactionScope(Exception) with that exception.","(""endTransactionScope"", ""Both methods are related to transaction management, where endTransactionScope is used to end a transaction and abortTransactionScope is used to handle exceptions by aborting the transaction."", ""abortTransactionScope"")"
The first problem you run into when designing DAO classes is connection scoping.,"(""DAO"", ""The text discusses the issue of connection scoping in the context of designing DAO classes, indicating a relationship between the two."", ""connection scoping"")"
A naive implementation of a DAO class using JDBC to target a relational database might look like below (at least I have designed DAO's like this in the past).,"(""DAO"", ""The DAO class uses JDBC to interact with a relational database."", ""JDBC"")"
Notice how the readPerson() method opens its own connection and closes it again once it is done.,"(""readPerson"", ""The readPerson method opens and closes its own connection, indicating a functional relationship."", ""connection"")"
You might also be able to hide connection closing from the domain logic by adding a close() method to the DAO.,"(""CLOSE"", ""The CLOSE method is suggested to be added to the DAO class to manage connection closing."", ""DAO"")"
But somewhere in the domain logic you would have to call that close() method.,"(""DOMAIN LOGIC"", ""The close() method is likely part of the domain logic, as it is mentioned that it needs to be called within it."", ""CLOSE"")"
The method call daoFactory.beginConnectionScope() marks the beginning of a connection scope.,"(""DaoFactory"", ""The method BeginConnectionScope is called on the class DaoFactory, indicating a relationship between the class and the method."", ""BeginConnectionScope"")"
The method call daoFactory.endConnectionScope() ends the current connection scope and closes the connection associated with the scope.,"(""DaoFactory"", ""The method EndConnectionScope is called on the class DaoFactory to end the current connection scope."", ""EndConnectionScope"")"
This way neither of the DAO's need to have close() methods.,"(""DAO"", ""The text implies that the DAO (Data Access Object) might typically have a close() method, suggesting a relationship between the DAO and the close method."", ""CLOSE"")"
The methods beginTransaction() and endTransaction() mark the beginning and end of the transaction.,"(""BeginTransaction"", ""BeginTransaction and EndTransaction are related as they mark the beginning and end of a transaction, respectively."", ""EndTransaction"")"
The beginTransaction() method will call connection.setAutoCommit(false) for the connection associated with the transaction scope.,"(""BeginTransaction"", ""The BeginTransaction method interacts with the Connection class by calling connection.setAutoCommit(false) to manage transaction scope."", ""Connection"")"
The endTransaction() method will attempt to commit the transaction and call setAutoCommit(false) again.,"(""endTransaction"", ""The endTransaction method calls the setAutoCommit method."", ""setAutoCommit"")"
Notice the new method call in the catch-block of the transaction scope: daoFactory.abortTransaction(e).,"(""DAOfactory"", ""The method 'abortTransaction' is called on the 'DAOfactory' class, indicating a relationship where the method is a part of or used by the class."", ""abortTransaction"")"
This method call rolls the transaction back if an exception is thrown from any of the dao methods or from endTransaction().,"(""METHOD"", ""The method is responsible for rolling the transaction back."", ""TRANSACTION""); (""METHOD"", ""The method rolls back the transaction if an exception is thrown."", ""EXCEPTION""); (""EXCEPTION"", ""An exception can be thrown from any of the DAO methods."", ""DAO METHODS""); (""EXCEPTION"", ""An exception can be thrown from endTransaction()."", ""ENDTRANSACTION"")"
"The DAO layer usually consists of a smaller set of classes, than the number of domain logic classes that uses it.","(""DAO layer"", ""The DAO layer is used by the domain logic classes."", ""domain logic classes"")"
"It is also a somewhat more controlled operation, since you can search for all DAO classes, and make sure they are changed to use the new persistence mechanism.","(""DAO"", ""DAO is related to persistence mechanism as it is mentioned that DAO classes need to be changed to use the new persistence mechanism."", ""persistence mechanism"")"
"To solve the problems mentioned earlier, you can move some of the code to a DaoManager class.","(""DaoManager"", ""DaoManager is identified as a class in the text."", ""class"")"
Notice that the getPersonDao() method isn't synchronized even though it returns a kind of singleton.,"(""getPersonDao"", ""The getPersonDao method is related to singleton because it returns a kind of singleton."", ""singleton"")"
"Rather than implementing a close() method in the DaoManager class, a template method will be added called executeAndClose().","(""DaoManager"", ""The close() method is mentioned in the context of the DaoManager class, suggesting it is or was intended to be a method of this class."", ""close()""); (""DaoManager"", ""The executeAndClose() method is described as a template method to be added, indicating it is related to the DaoManager class."", ""executeAndClose()"")"
This instance then has it's execute() method invoked with the DaoManager itself as parameter.,"(""Execute"", ""The Execute method is invoked with the DaoManager class as a parameter."", ""DaoManager"")"
Now the scope of the connection is marked by the scope of the method call executeAndClose().,"(""executeAndClose"", ""The text indicates that executeAndClose is a method call, suggesting a relationship between the method and its invocation."", ""method"")"
"Any exception handling related to the connection.close() call can be hidden away inside the executeAndClose() method, and reused throughout the application.","(""EXECUTEANDCLOSE()"", ""The EXECUTEANDCLOSE() method likely calls the CONNECTION.CLOSE() method to handle exceptions related to closing connections."", ""CONNECTION.CLOSE()"")"
You can add a transaction() method similar to the executeAndClose() method which takes care of transaction management.,"(""Transaction"", ""Both methods are related as they handle transaction management."", ""ExecuteAndClose"")"
"For instance, if both commit() and rollback() throws exceptions, both of these exception are not properly preserved or handled.","(""COMMIT"", ""Both methods are mentioned together in the context of handling exceptions, indicating they are related in functionality."", ""ROLLBACK"")"
Using the transaction() method is analogous to using the executeAndClose() method:,"(""TRANSACTION"", ""Both TRANSACTION and EXECUTEANDCLOSE are methods, and the text suggests they are analogous, indicating a functional similarity or relationship."", ""EXECUTEANDCLOSE"")"
This could be done by wrapping the call to transaction() inside the call to executeAndClose().,"(""Transaction"", ""The method 'Transaction' is called inside the method 'ExecuteAndClose', indicating a relationship where 'Transaction' is used within 'ExecuteAndClose'."", ""ExecuteAndClose"")"
"As you can see a DaoManager class can solve the problems of marking both connection life span and transaction boundaries, and automatically open and close connections and commit / rollback transactions.","(""DaoManager"", ""The DaoManager class is responsible for managing the connection life span."", ""connection""); (""DaoManager"", ""The DaoManager class handles transaction boundaries, including commit and rollback operations."", ""transaction""); (""DaoManager"", ""The DaoManager class automatically opens and closes connections."", ""connections""); (""DaoManager"", ""The DaoManager class automatically commits or rolls back transactions."", ""transactions"")"
"If you implement a base event listener class that all event listeners (or actions, or whatever your framework calls them) extend, you can put the DaoManager code in that class (or a subclass of the base class).","(""Base Event Listener"", ""Event Listeners extend the Base Event Listener class."", ""Event Listeners""); (""Base Event Listener"", ""Actions extend the Base Event Listener class."", ""Actions""); (""Base Event Listener"", ""DaoManager code can be put in the Base Event Listener class."", ""DaoManager""); (""Base Event Listener"", ""Subclass extends the Base Event Listener class."", ""Subclass""); (""Subclass"", ""DaoManager code can be put in a subclass of the Base Event Listener class."", ""DaoManager""); (""Framework"", ""Event Listeners are part of the framework."", ""Event Listeners""); (""Framework"", ""Actions are part of the framework."", ""Actions"")"
Here is an example of a subclass that executes the persistence code marked in bold in the first code box in this section:,"(""SUBCLASS"", ""CLASS"")"
Now your domain logic class only contains the persistence code that is actually interesting.,"(""Domain Logic"", ""The domain logic class contains the persistence code, indicating a relationship where the class is responsible for handling or managing the persistence code."", ""Persistence Code"")"
It may not always be possible or feasible to implement such a persistence action base class.,"(""Persistence Action Base"", ""The text refers to 'persistence action base' as a type of class, indicating a relationship between the entity and the entity type."", ""class"")"
It would be tempting to put that validation code inside the doPersistenceAction() method.,"(""doPersistenceAction"", ""The text explicitly mentions doPersistenceAction as a method."", ""method"")"
"But remember, a connection has been opened already when the DaoManager is instantiated, which happens before the doPersistenceAction() method is called.","(""DaoManager"", ""The doPersistenceAction method is called after the DaoManager class is instantiated, indicating a sequence of operations involving these entities."", ""doPersistenceAction"")"
"Furthermore, if the validation fails and aborts the doPersistenceAction() method call, you have opened a connection without ever using it.","(""doPersistenceAction"", ""The doPersistenceAction method call is related to the connection because it mentions the opening of a connection in the context of the method's execution."", ""connection"")"
"If you are using a persistence API you will inject whatever class you obtain connections or their equivalents from (sessions in Hibernate, IDaos in Butterfly Persistence).","(""Persistence API"", ""The Persistence API is used to inject the class that obtains connections or their equivalents."", ""Class""); (""Class"", ""The class is responsible for obtaining connections."", ""Connections""); (""Sessions"", ""Sessions are the equivalent of connections in Hibernate."", ""Hibernate""); (""IDaos"", ""IDaos are used in Butterfly Persistence as equivalents of connections."", ""Butterfly Persistence"")"
"This is done to avoid obtaining the connection before the DaoCommand.execute() method is called, to postpone obtaining the connection as much as possible.","(""DaoCommand"", ""The execute method is a part of the DaoCommand class, as indicated by the notation DaoCommand.execute()."", ""execute"")"
"Inside the DaoCommand.execute() method the getPersonDaoTx() will be called, and then getConnectionTx() will be called, and then connection.setAutoCommit(false) will be called at that time.","(""DaoCommand.execute()"", ""The getPersonDaoTx() method is called within the DaoCommand.execute() method."", ""getPersonDaoTx()""); (""DaoCommand.execute()"", ""The getConnectionTx() method is called within the DaoCommand.execute() method."", ""getConnectionTx()""); (""DaoCommand.execute()"", ""The connection.setAutoCommit() method is called within the DaoCommand.execute() method."", ""connection.setAutoCommit()"")"
"After this code is executed, you can now access the cookies in the cookieMap using the cookie names as keys (cookieMap.get(""cookieName"")).","(""cookieMap"", ""The method 'get' is used to access elements in the 'cookieMap' class using cookie names as keys."", ""get"")"
"Second, it sets the expiration to 24 hours using the setMaxAge() method.","(""setMaxAge"", ""The setMaxAge method is used to set the expiration to 24 hours."", ""expiration"")"
"Cookies are most often used to store user specific information, like e.g.",NULL
The browser includes the Accept-Encoding HTTP header in requests sent to an HTTP server (e.g.,"(""Accept-Encoding"", ""The Accept-Encoding class is part of the HTTP package as it is used in HTTP headers."", ""HTTP""); (""Accept-Encoding"", ""The Accept-Encoding class is used in requests sent to an HTTP server."", ""HTTP server""); (""HTTP"", ""The HTTP server is a component that interacts with the HTTP package."", ""HTTP server"")"
That class is mapped to a set of URL's in the web.xml file.,"(""CLASS"", ""The CLASS is mapped to a set of URL's in the web.xml file, indicating a configuration or association between them."", ""URL"")"
"It does so by using a GZIPOutputStream internally, which is a standard Java class.","(""GZIPOutputStream"", ""GZIPOutputStream is a class that is part of the Java package."", ""Java"")"
Remember to replace the class name with the fully qualified name of your own GZip Servlet filter class.,"(""GZip Servlet Filter"", ""The text refers to 'GZip Servlet filter' as a type of class, indicating that it is a specific implementation or example of a class."", ""class"")"
"In general, If no header exists with the name passed to getHeader(), null is returned.","(""getHeader"", ""The method getHeader() returns null if no header exists with the specified name."", ""null"")"
"NOTE: You will have to call this method before calling any getParameter() method, because calling the getParameter() method on an HTTP POST request will cause the servlet engine to parse the HTTP request body for parameters.","(""GETPARAMETER"", ""The GETPARAMETER method is called on an HTTP POST request."", ""HTTP POST""); (""GETPARAMETER"", ""The GETPARAMETER method causes the servlet engine to parse the HTTP request body for parameters."", ""SERVLET ENGINE"")"
"For instance, you can access context parameters set in the web.xml file, you can forward the request to other servlets, and you can store application wide parameters in the ServletContext too.","(""ServletContext"", ""ServletContext can access context parameters set in the web.xml file"", ""web.xml""); (""ServletContext"", ""ServletContext can forward the request to other servlets"", ""servlets""); (""ServletContext"", ""ServletContext can store application wide parameters"", ""application wide parameters"")"
In order to write binary data back to the browser you cannot use the Writer obtained from response.getWriter().,"(""response"", ""The method getWriter is called on the response object to obtain a Writer."", ""getWriter""); (""getWriter"", ""The getWriter method returns an instance of the Writer class."", ""Writer"")"
Instead you have to use the OutputStream obtained from the response.getOutputStream() method.,"(""response"", ""The getOutputStream method is called on the response object to obtain an OutputStream."", ""getOutputStream""); (""getOutputStream"", ""The getOutputStream method returns an OutputStream."", ""OutputStream"")"
The javax.servlet.http.HttpServlet class is a slightly more advanced base class than the GenericServlet shown in the Simple Servlet example.,"(""HttpServlet"", ""HttpServlet is a class within the javax.servlet.http package"", ""javax.servlet.http""); (""HttpServlet"", ""HttpServlet is a more advanced base class than GenericServlet"", ""GenericServlet"")"
"The HttpServlet class reads the HTTP request, and determines if the request is an HTTP GET, POST, PUT, DELETE, HEAD etc.","(""HttpServlet"", ""HttpServlet class determines if the request is an HTTP GET method"", ""HTTP GET""); (""HttpServlet"", ""HttpServlet class determines if the request is a POST method"", ""POST""); (""HttpServlet"", ""HttpServlet class determines if the request is a PUT method"", ""PUT""); (""HttpServlet"", ""HttpServlet class determines if the request is a DELETE method"", ""DELETE""); (""HttpServlet"", ""HttpServlet class determines if the request is a HEAD method"", ""HEAD"")"
"HTTP GET requests only, you will extend the HttpServlet class, and override the doGet() method only.","(""HttpServlet"", ""The doGet method is overridden in the HttpServlet class to handle HTTP GET requests."", ""doGet"")"
"The HttpServlet class has methods you can override for each HTTP method (GET, POST etc.).","(""HttpServlet"", ""The HttpServlet class has methods you can override for each HTTP method, including GET."", ""GET""); (""HttpServlet"", ""The HttpServlet class has methods you can override for each HTTP method, including POST."", ""POST"")"
A Java Servlet is just an ordinary Java class which implements the interface,"(""Java Servlet"", ""Java Servlet is a type of Servlet class."", ""Servlet""); (""Java Servlet"", ""Java Servlet implements the interface."", ""interface""); (""Java"", ""Java Servlet is part of the Java package."", ""Java Servlet"")"
The easiest way to implement this interface is to extend either the class GenericServlet or HttpServlet.,"(""GenericServlet"", ""Both are classes that can be extended to implement the interface."", ""HttpServlet""); (""HttpServlet"", ""Both are classes that can be extended to implement the interface."", ""GenericServlet"")"
"When an HTTP request arrives at the web server, targeted for your Servlet, the web server calls your Servlet's service() method.","(""HTTP Request"", ""The HTTP Request is processed by the Web Server."", ""Web Server""); (""Web Server"", ""The Web Server targets the Servlet to handle the request."", ""Servlet""); (""Servlet"", ""The Servlet's service() method is called to process the request."", ""Service"")"
"The service() method then reads the request, and generates a response which is sent back to the client (e.g.","(""SERVICE"", ""The SERVICE method reads the REQUEST."", ""REQUEST""); (""SERVICE"", ""The SERVICE method generates a RESPONSE."", ""RESPONSE"")"
"You will need to run your Java Servlets inside a Servlet compatible ""Servlet Container"" (e.g.","(""Java Servlets"", ""Java Servlets are a type of Servlet."", ""Servlet""); (""Java Servlets"", ""Java Servlets need to run inside a Servlet Container."", ""Servlet Container"")"
"The RequestDispatcher class enables your servlet to ""call"" another servlet from inside another servlet.","(""RequestDispatcher"", ""The RequestDispatcher class is used to call another servlet from inside a servlet."", ""servlet"")"
The above code obtains a RequestDispatcher targeted at whatever Servlet (or JSP) that is mapped to the URL /anotherUrl.simple.,"(""RequestDispatcher"", ""RequestDispatcher is used to forward requests to a Servlet."", ""Servlet""); (""RequestDispatcher"", ""RequestDispatcher is used to forward requests to a JSP."", ""JSP"")"
You can call the RequestDispatcher using either its include() or forward() method:,"(""RequestDispatcher"", ""The include method is a method of the RequestDispatcher class."", ""include""); (""RequestDispatcher"", ""The forward method is a method of the RequestDispatcher class."", ""forward"")"
By calling either the include() or forward() method the servlet container activates whatever Servlet is mapped to the URL the RequestDispatcher.,"(""Include"", ""The Include method is used to activate a Servlet mapped to a URL."", ""Servlet""); (""Forward"", ""The Forward method is used to activate a Servlet mapped to a URL."", ""Servlet""); (""Include"", ""The Include method is part of the RequestDispatcher functionality."", ""RequestDispatcher""); (""Forward"", ""The Forward method is part of the RequestDispatcher functionality."", ""RequestDispatcher"")"
There is a little difference between calling the forward() and include() method.,"(""FORWARD"", ""Both FORWARD and INCLUDE are methods mentioned in the text, indicating they are related as they are being compared."", ""INCLUDE"")"
"The forward() method intended for use in forwarding the request, meaning after the response of the calling servlet has been committed.","(""FORWARD"", ""The term 'forward()' is described as a method in the text."", ""METHOD"")"
"The include() method merges the response written by the calling servlet, and the activated servlet.","(""Include"", ""The include() method is used to merge the response written by the calling servlet, indicating a functional relationship between the method and the servlet class."", ""Servlet"")"
"This way you can achieve ""server side includes"" using the include().","(""include"", ""The method 'include' is used to achieve 'server side includes'."", ""server side includes"")"
The red boxes represent state (variables) that your servlet's service() method should be careful about accessing.,"(""SERVICE"", ""The SERVICE method is part of the SERVLET's functionality, as it is mentioned in the context of accessing state variables."", ""SERVLET"")"
"Of course it is not only the member variables and static variables inside the servlet class itself, that you need to be careful about accessing.","(""Servlet"", ""The text refers to the 'servlet class' indicating that 'Servlet' is a class entity."", ""Servlet"")"
"Static variables in any other class which are accessed by your servlet, must also be thread safe.","(""STATIC VARIABLES"", ""Static variables are accessed by the servlet, indicating a relationship between the two classes."", ""SERVLET"")"
In order to create a servlet filter you must implement the javax.servlet.Filter interface.,"(""javax.servlet.Filter"", ""The javax.servlet.Filter is an interface that needs to be implemented to create a servlet filter."", ""Filter"")"
"When the servlet filter is loaded the first time, its init() method is called, just like with servlets.","(""Servlet Filter"", ""The Init method is called when the Servlet Filter is loaded for the first time."", ""Init""); (""Servlet Filter"", ""The Servlet Filter is similar to Servlets in that both have an Init method that is called when they are loaded."", ""Servlets"")"
"Notice how the doFilter() method checks a request parameter, myParam, to see if it equals the string ""blockTheRequest"".","(""doFilter"", ""The doFilter method checks the request parameter myParam."", ""myParam"")"
"If not, the request is forwarded to the target of the request, by calling the filterChain.doFilter() method.","(""FILTERCHAIN"", ""The doFilter method is called on the FilterChain class to forward the request."", ""DOFILTER"")"
"You need to configure the servlet filter in the web.xml file of your web application, before it works.","(""Servlet Filter"", ""The Servlet Filter needs to be configured in the web.xml file."", ""Web.xml""); (""Servlet Filter"", ""The Servlet Filter is part of the configuration for the web application."", ""Web Application"")"
With this configuration all requests with URL's ending in .simple will be intercepted by the servlet filter.,NULL
Before a servlet can be invoked the servlet container must first load its class definition.,"(""Servlet"", ""The servlet is managed and executed by the servlet container, indicating a relationship where the container loads and runs the servlet."", ""Servlet Container"")"
"When the servlet class is loaded, the servlet container creates an instance of the servlet.","(""Servlet"", ""The servlet container creates an instance of the servlet when the servlet class is loaded."", ""Servlet Container"")"
"When a servlet instance is created, its init() method is invoked.","(""Servlet"", ""The init() method is invoked on a servlet instance, indicating that Init is a method of the Servlet class."", ""Init"")"
The init() method allows a servlet to initialize itself before the first request is processed.,"(""Init"", ""The init() method is used by a servlet to initialize itself."", ""Servlet"")"
You can specify init parameters to the servlet in the web.xml file.,"(""init parameters"", ""Init parameters are specified for the servlet."", ""servlet""); (""servlet"", ""The servlet is configured in the web.xml file."", ""web.xml"")"
"For every request received to the servlet, the servlets service() method is called.","(""Servlet"", ""The Service method is called on the Servlet class for every request received."", ""Service"")"
"As long as the servlet is active in the servlet container, the service() method can be called.","(""Servlet"", ""The Service method is a function that can be called on the Servlet class."", ""Service""); (""Servlet"", ""The Servlet class is active within the Servlet Container class."", ""Servlet Container"")"
"When a servlet is unloaded by the servlet container, its destroy() method is called.","(""Servlet"", ""The destroy() method is called on the Servlet class when it is unloaded."", ""Destroy""); (""Servlet Container"", ""The Servlet is managed by the Servlet Container, which unloads it."", ""Servlet"")"
"Once the servlet has been activated via the service() method, the servlet processes the request, and generates a response.","(""Servlet"", ""The Service method is a function that is activated by the Servlet class to process requests and generate responses."", ""Service"")"
This is done in the web.xml file of your Java web application.,"(""WEB.XML"", ""WEB.XML is a configuration file used in Java web applications."", ""JAVA"")"
"To configure a servlet in the web.xml file, you write this:",NULL
"Here you give the servlet a name, and writes the class name of the servlet.","(""Servlet"", ""The text refers to giving the servlet a name and writing the class name of the servlet, indicating a relationship between the servlet as a class and its naming."", ""Servlet"")"
"In the above example, all URL's ending in .html are sent to the servlet.","(""URL"", ""URLs ending in .html are directed to the servlet, indicating a relationship where the servlet processes these URLs."", ""SERVLET"")"
You can pass parameters to a servlet from the web.xml file.,"(""servlet"", ""Parameters can be passed to a servlet from the web.xml file, indicating a configuration relationship."", ""web.xml"")"
Here is how you read the init parameters from inside your servlet - in the servlets init() method:,"(""Init"", ""The init method is used within the Servlet class to read initialization parameters."", ""Servlet"")"
A servlets init() method is called when the servlet container loads the servlet for the first time.,"(""Servlets"", ""The init() method is a method of the Servlets class, called during the servlet's initialization."", ""Init""); (""Servlet Container"", ""The Servlet Container loads the Servlets class when it is first initialized."", ""Servlets"")"
"No one can access the servlet until the servlet has been loaded, and the init() method has been called successfully.","(""SERVLET"", ""The INIT method is called on the SERVLET class to initialize it."", ""INIT"")"
"Remember, the servlets init() method is called when the servlet is loaded.","(""Init"", ""The init() method is a part of the servlet lifecycle and is called when the servlet is loaded."", ""Servlet"")"
Here is how you access the parameter from inside an HttpServlet subclass:,"(""HttpServlet"", ""The text mentions accessing a parameter from inside an HttpServlet subclass, indicating a relationship where HttpServlet is the superclass."", ""subclass"")"
In this text I will show you a simple unit test implemented using JUnit 4.8.1.,"(""JUnit"", ""JUnit 4.8.1 is a specific version of the JUnit package"", ""JUnit 4.8.1"")"
First I will show you the class I want to test:,NULL
I have kept the class very simple to make it eaiser to understand what is going on.,NULL
To test this class I need a unit test that test each of its public methods.,"(""Class"", ""The class contains public methods that need to be tested."", ""Method"")"
"The class only has one public method, concatenate(), so all I need to test is this method.","(""Class"", ""The method 'concatenate()' is a public method of the class."", ""Concatenate"")"
Each test method usually tests a single method of the target class.,"(""TEST METHOD"", ""A test method is designed to test a single method of the target class."", ""TARGET CLASS"")"
"Sometimes, a test method can test more than one method in the target class, and sometimes, if the method to test is big, you split the test into multiple test methods.","(""test method"", ""A test method is used to test a method in the target class."", ""method""); (""test method"", ""A test method is associated with a target class as it tests methods within that class."", ""target class""); (""test methods"", ""Multiple test methods can be used to test a big method by splitting the test."", ""method"")"
Here is the JUnit unit test that test that the concatenate() method:,"(""JUnit"", ""The concatenate method is likely part of the JUnit package as it is being tested in a JUnit unit test."", ""concatenate"")"
"The unit test class is an ordinary class, with one method, testConcatenate().","(""Unit Test Class"", ""The method testConcatenate() is a part of the Unit Test Class."", ""Testconcatenate"")"
In this method we compare the output of the called method (concatenate()) with the expected output.,"(""Concatenate"", ""Concatenate is identified as a method because it is referred to as a called method in the text."", ""Method"")"
"In other words, we compare ""onetwo"" (expected output) with the value returned by the concatenate() method, which is kept in the variable result.","(""Concatenate"", ""The method Concatenate is used to produce a value that is stored in the variable Result."", ""Result"")"
"The assertEquals() method is a statically imported method, which normally resides in the org.junit.Assert class.","(""assertequals()"", ""The assertEquals() method is part of the org.junit.Assert class."", ""org.junit.assert"")"
Notice the static import of this class at the top of MyUnitTest.,"(""MyUnitTest"", ""MyUnitTest is a class that is being referenced in the context of a static import."", ""class"")"
Using the static import of the method is shorter than writing Assert.assertEquals().,"(""Assert"", ""The method assertEquals is a member of the class Assert."", ""assertEquals"")"
You can have as many test methods in a unit test class as you want.,"(""Test Methods"", ""Test Methods are contained within a Unit Test Class"", ""Unit Test Class"")"
This is how simple a unit test can be with JUnit 4.8.2 .,"(""JUnit"", ""JUnit is a package and 4.8.2 is a version number associated with it"", ""4.8.2"")"
"As you may have figured out from the simple test, most of the secret of implementing JUnit unit tests, is in the use of the assert methods in the class org.junit.Assert.","(""assert methods"", ""The assert methods are used within the Assert class."", ""Assert""); (""Assert"", ""The Assert class is part of the org.junit package."", ""org.junit"")"
In this text I will take a closer look at what assert methods are available in this class.,"(""ASSERT METHODS"", ""Assert methods are available within the class, indicating a relationship where the class contains or uses these methods."", ""CLASS"")"
"The code for this class is not shown, but you don't really need the code in order to understand how to test it.","(""Class"", ""class"")"
The assertArrayEquals() method will test whether two arrays are equal to each other.,"(""AssertArrayEquals"", ""AssertArrayEquals is a method that tests whether two arrays are equal."", ""Method"")"
"To check for element equality, the elements in the array are compared using their equals() method.","(""Equals"", ""The equals() method is used to compare elements in the array for equality."", ""Array"")"
"More specifically, the elements of each array are compared one by one using their equals() method.","(""Equals"", ""The equals() method is used to compare elements of each array."", ""Array"")"
"Second the myUnit.getTheStringArray() method is called, which is the method we want to test.","(""MYUNIT"", ""The method GETTHESTRINGARRAY is called on the class MYUNIT."", ""GETTHESTRINGARRAY"")"
"Third, the result of the myUnit.getTheStringArray() method call is compared to the expected array.","(""myUnit"", ""The method getTheStringArray is called on the class myUnit."", ""getTheStringArray"")"
"If the arrays are equal, the assertArrayEquals() will proceed without errors.","(""assertArrayEquals"", ""The method assertArrayEquals is used to compare arrays to check if they are equal."", ""arrays"")"
"The assertEquals() method compares two objects for equality, using their equals() method.","(""assertequals()"", ""The assertEquals() method uses the equals() method to compare two objects for equality."", ""equals()"")"
"First the myUnit.concatenate() method is called, and the result is stored in the variable result.","(""MyUnit"", ""The Concatenate method is a function that belongs to the MyUnit class."", ""Concatenate"")"
"Second, the result value is compared to the expected value ""onetwo"", using the assertEquals() method.","(""assertEquals"", ""The assertEquals method is used to compare the result value to the expected value 'onetwo'."", ""onetwo"")"
"If the two objects are equal according to their implementation of their equals() method, the assertEquals() method will return normally.","(""equals()"", ""The assertEquals() method uses the equals() method to determine if two objects are equal."", ""assertEquals()"")"
"Otherwise the assertEquals() method will throw an exception, and the test will stop there.","(""assertequals"", ""The assertEquals() method will throw an exception if the condition is not met."", ""exception"")"
"This example compared to String objects, but the assertEquals() method can compare any two objects to each other.","(""assertEquals"", ""The assertEquals method is used to compare String objects."", ""String"")"
The assertEquals() method also come in versions which compare primitive types like int and float to each other.,"(""assertequals"", ""The assertEquals() method is used to compare primitive types like int and float."", ""primitive types"")"
"The assertTrue() and assertFalse() methods tests a single variable to see if its value is either true, or false.","(""AssertTrue"", ""Both methods are used to test a single variable for boolean values."", ""AssertFalse"")"
"As you can see, the method call to myUnit.getTheBollean() is inlined inside the assertTrue() assertFalse() calls.","(""myUnit"", ""The method getTheBollean is called on the class myUnit."", ""getTheBollean""); (""getTheBollean"", ""The method getTheBollean is used as an argument in the assertTrue method."", ""assertTrue""); (""getTheBollean"", ""The method getTheBollean is used as an argument in the assertFalse method."", ""assertFalse"")"
"If the getTheBoolean() method returns true, the assertTrue() method will return normally.","(""getTheBoolean"", ""The assertTrue() method's behavior depends on the return value of the getTheBoolean() method."", ""assertTrue"")"
"If the getTheBoolean() method returns false, the assertFalse() method will return normally.","(""GetTheBoolean"", ""The AssertFalse method's behavior depends on the return value of the GetTheBoolean method."", ""AssertFalse"")"
"Of course the above test will fail in either the assertTrue() or assertFalse() call, if the getTheBoolean() method returns the same value in both calls.","(""assertTrue"", ""The assertTrue method is related to the getTheBoolean method because it uses the return value of getTheBoolean to perform its assertion."", ""getTheBoolean""); (""assertFalse"", ""The assertFalse method is related to the getTheBoolean method because it uses the return value of getTheBoolean to perform its assertion."", ""getTheBoolean"")"
The assertNull() and assertNotNull() methods test a single variable to see if it is null or not null.,"(""AssertNull"", ""Both methods are used to test a single variable for null or not null values."", ""AssertNotNull"")"
The call to myUnit.getTheObject() is inlined in the assertNull() and assertNotNull() calls.,"(""myUnit"", ""The method getTheObject is called on the class myUnit."", ""getTheObject""); (""getTheObject"", ""The method getTheObject is used within the assertNull method call."", ""assertNull""); (""getTheObject"", ""The method getTheObject is used within the assertNotNull method call."", ""assertNotNull"")"
"If the myUnit.getTheObject() returns null, the assertNull() method will return normally.","(""myUnit"", ""The method getTheObject is called on the class myUnit."", ""getTheObject""); (""assertNull"", ""The method assertNull is used to check the result of the getTheObject method."", ""getTheObject"")"
"If a non-null value is returned, the assertNull() method will throw an exception, and the test will be aborted here.","(""ASSERTNULL"", ""The assertNull() method will throw an exception if a non-null value is returned."", ""EXCEPTION""); (""ASSERTNULL"", ""The assertNull() method will cause the test to be aborted if a non-null value is returned."", ""TEST"")"
"The assertNotNull() method works oppositely of the assertNull() method, throwing an exception if a null value is passed to it, and returning normally if a non-null value is passed to it.","(""AssertNotNull"", ""Both methods are related as they perform opposite checks on null values."", ""AssertNull"")"
The assertSame() and assertNotSame() methods tests if two object references point to the same object or not.,"(""assertSame"", ""Both are methods used to test if two object references point to the same object or not."", ""assertNotSame"")"
It is not enough that the two objects pointed to are equals according to their equals() methods.,"(""equals"", ""The text refers to the equals() methods, indicating a relationship between the concept of equality and the method itself."", ""equals"")"
The calls to myUnit.getTheSameObject() are inlined into the assertSame() and assertNotSame() method calls.,"(""myUnit"", ""The method getTheSameObject is called on the class myUnit."", ""getTheSameObject""); (""getTheSameObject"", ""The method getTheSameObject is inlined into the method assertSame."", ""assertSame""); (""getTheSameObject"", ""The method getTheSameObject is inlined into the method assertNotSame."", ""assertNotSame"")"
"If the two references points to the same object, the assertSame() method will return normally.","(""assertSame"", ""The assertSame method checks if two references point to the same object."", ""object"")"
"If the two objects do not poin to the same object, the assertNotSame() method will return normally.","(""assertNotSame"", ""The assertNotSame is identified as a method because it is described as such in the text."", ""method"")"
The assertThat() method compares an object to an org.hamcrest.Matcher to see if the given object matches whatever the Matcher requires it to match.,"(""assertThat()"", ""The assertThat() method uses the org.hamcrest.Matcher class to compare an object and determine if it matches the required conditions."", ""org.hamcrest.Matcher"")"
"If you are testing a component that uses a database, e.g.","(""Component"", ""A component may interact with a database as part of its functionality."", ""Database"")"
"a DAO class, you may want to test that the component really inserts data into the database, updates it etc.","(""DAO"", ""The DAO class is likely a component that interacts with the database to perform operations like inserting and updating data."", ""component"")"
It is just a standard Java class - nothing secret about it.,"(""Java"", ""class"")"
"Exactly what methods you will put in your own TestData class, depends on the data used by your application.","(""TestData"", ""The methods are part of the TestData class, as they are implemented within it."", ""methods"")"
"Also, you may want some of the methods to take parameters, rather than e.g.","(""methods"", ""The methods may take parameters, indicating a relationship where methods use parameters as input."", ""parameters"")"
"Once you have such a TestData class, you can use and reuse it in your unit tests.","(""TestData"", ""The TestData class is used and reused in unit tests."", ""unit tests"")"
"The TestData class can contain all kinds of business wise complex test data setups, which are then easy to setup in the database, once they have been programmed once.","(""TestData"", ""The TestData class is used to set up complex test data in the database."", ""database"")"
"Below is a diagram illustrating a unit test, a unit (which is being tested), and a dependency which is some class used by the unit.","(""UNIT"", ""The unit is being tested and relies on the dependency, which is a class used by the unit."", ""DEPENDENCY"")"
"If a method or field is private, only instances of that class can access that method or field.","(""Method"", ""A method is associated with a class as it is defined within it."", ""Class""); (""Field"", ""A field is associated with a class as it is defined within it."", ""Class"")"
"A protected method or field, on the other hand, is also accessible to other classes in the same package, and for subclasses of the unit too.","(""Method"", ""A method is accessible to other classes."", ""Classes""); (""Field"", ""A field is accessible to other classes."", ""Classes""); (""Method"", ""A method is accessible to other classes in the same package."", ""Package""); (""Field"", ""A field is accessible to other classes in the same package."", ""Package""); (""Method"", ""A method is accessible to subclasses."", ""Subclasses""); (""Field"", ""A field is accessible to subclasses."", ""Subclasses"")"
"By encapsulating calls to external dependencies (components) in protected methods, you can create a subclass mock of the unit to test, and override these protected methods, to make them record information about whether they were called or not.","(""subclass"", ""The subclass can override the protected methods to record information about their calls."", ""protected methods"")"
"By ""boundary class"" I mean classes that plug into some framework.","(""Boundary Class"", ""Boundary Class is a type of class that integrates with a framework"", ""Framework"")"
You may need the whole framework running in order to test your boundary class.,"(""Framework"", ""The Boundary class may need the Framework class to be running for testing purposes."", ""Boundary"")"
"Examples of boundary classes are Servlets, Struts actions, custom Swing components, EJB's etc.","(""Servlets"", ""class""); (""Struts actions"", ""class""); (""Swing components"", ""class""); (""EJB's"", ""class"")"
Each of these boundary classes need a larger framework or server running in order to test them.,"(""Boundary Classes"", ""Boundary classes need a larger framework to function properly."", ""Framework""); (""Boundary Classes"", ""Boundary classes require a server running to be tested."", ""Server"")"
"A way to get around that is to move the business logic out of the boundary class, and into it's own component.","(""boundary"", ""The business logic is suggested to be moved out of the boundary class, indicating a relationship between them."", ""business logic"")"
Make sure that the business logic component does not know anything about the boundary classes.,"(""BUSINESS LOGIC COMPONENT"", ""The business logic component should not have any knowledge of the boundary classes, indicating a separation of concerns between these two classes."", ""BOUNDARY CLASSES"")"
"For instance, if your boundary class is a servlet, your business logic class should not know anything about the HttpRequest or HttpResponse interfaces.","(""Servlet"", ""The Servlet class interacts with the HttpRequest class as it typically processes incoming requests."", ""HttpRequest""); (""Servlet"", ""The Servlet class interacts with the HttpResponse class as it typically generates responses."", ""HttpResponse""); (""HttpRequest"", ""HttpRequest and HttpResponse are related as they are both part of the request-response cycle in web applications."", ""HttpResponse"")"
"Preferably, the business logic class only takes the parameters it needs, as the types it needs.","(""Business Logic"", ""The business logic class takes parameters as part of its operation."", ""Parameters"")"
"When your business logic class is separated from the boundary class, you can test the business logic class separately.","(""Business Logic Class"", ""The Business Logic Class is separated from the Boundary Class, indicating a relationship between the two classes."", ""Boundary Class"")"
"When the boundary classes are minimized to dispatch logic, the risk of errors in them are a lot smaller, in case you choose not to unit test them.","(""Boundary Classes"", ""Boundary Classes are minimized to Dispatch Logic, indicating a relationship where Boundary Classes are reduced to or transformed into Dispatch Logic."", ""Dispatch Logic"")"
"For an example of this, see the Servlet Unit Testing text, in which I show how to unit test the business logic of a servlet, by moving the business logic to a separate class.","(""Servlet"", ""The business logic is part of the servlet, as it is mentioned that the business logic of a servlet is being tested."", ""Business Logic""); (""Servlet Unit Testing"", ""Servlet Unit Testing involves testing the servlet, as indicated by the context of unit testing the business logic of a servlet."", ""Servlet"")"
In this text I will give a few suggestions to how you can test such classes.,"(""Classes"", ""class"")"
Let's look at how to write a unit test for this class.,"(""Unit Test"", ""A unit test is typically written to test the functionality of a class."", ""Class"")"
The ByteArrayInputStream is then used as input into the MyIOUnitTest.read() method.,"(""MyIOUnitTest"", ""The read method is a part of the MyIOUnitTest class."", ""read""); (""ByteArrayInputStream"", ""The ByteArrayInputStream is used as input into the read method."", ""read"")"
Here is the unit test which uses a ByteArrayOutputStream to collect the data written to the OutputStream passed to the MyIOUnit.write() method:,"(""MyIOUnit"", ""The write method is associated with the MyIOUnit class, indicating that it is a function or operation that can be performed by instances of MyIOUnit."", ""write""); (""ByteArrayOutputStream"", ""ByteArrayOutputStream is used to collect data written to an OutputStream, indicating a functional relationship where ByteArrayOutputStream acts as a buffer for OutputStream."", ""OutputStream"")"
"Notice how the output.toByteArray() method is called, and passed into a String.","(""Output"", ""The ToByteArray method is called on the Output class."", ""ToByteArray""); (""ToByteArray"", ""The result of the ToByteArray method is passed into a String."", ""String"")"
"If your input or output component uses a Reader or Writer instead of an InputStream or OutputStream, you can use the classes CharArrayReader and CharArrayWriter instead of ByteArrayInputStream and ByteArrayOutputStream.","(""CharArrayReader"", ""Both are classes used as alternatives to Reader and Writer components."", ""CharArrayWriter""); (""ByteArrayInputStream"", ""Both are classes used as alternatives to InputStream and OutputStream components."", ""ByteArrayOutputStream""); (""CharArrayReader"", ""Both are classes that serve as alternatives for different types of input components."", ""ByteArrayInputStream""); (""CharArrayWriter"", ""Both are classes that serve as alternatives for different types of output components."", ""ByteArrayOutputStream"")"
You may also be able to use the StringReader and StringWriter classes in your unit tests.,"(""StringReader"", ""Both are classes that can be used in unit tests for handling strings."", ""StringWriter"")"
"Unit testing means testing the smaller units of your application, like classes and methods.","(""Unit Testing"", ""Unit testing involves testing individual classes as part of the process."", ""Classes""); (""Unit Testing"", ""Unit testing involves testing individual methods as part of the process."", ""Methods"")"
"JUnit 4.8.2 ships with Hamcrest internally, so you don't have to download it, and add it yourself.","(""JUnit"", ""JUnit includes Hamcrest internally, indicating a dependency or inclusion relationship between the two packages."", ""Hamcrest"")"
"Matchers are used with the org.junit.Assert.assertThat() method, which looks like this:","(""Matchers"", ""Matchers are used with the assertThat method."", ""assertThat""); (""org.junit.Assert"", ""The assertThat method is part of the org.junit.Assert package."", ""assertThat"")"
"The assertThat() method just takes care of the ""plumming"" - meaning calling the Matcher with the given object.","(""assertThat"", ""The assertThat method calls the Matcher with the given object, indicating a functional relationship between them."", ""Matcher"")"
"In the example above, the org.hamcrest.CoreMatchers.is() method is used to create a Matcher.","(""is"", ""The method 'is' is a part of the 'CoreMatchers' class."", ""CoreMatchers""); (""CoreMatchers"", ""The 'CoreMatchers' class is contained within the 'org.hamcrest' package."", ""org.hamcrest"")"
"The Matcher returned by is() returns true, if the two values compared are equal, and false if not.","(""Matcher"", ""The method 'is' is likely a part of or used by the 'Matcher' class, as it returns a Matcher object."", ""is"")"
"The is() method returns one matcher, and the not() method returns another.","(""Is"", ""Both are methods that return matchers."", ""Not"")"
The matcher returned by not() negates the matcher output of the matcher given as input.,"(""Not"", ""The method 'not()' returns a matcher, indicating that it is related to the 'Matcher' class."", ""Matcher"")"
"In this case, it is the output of the matcher returned by the is() method, that is negated.","(""IS"", ""The IS method returns the output of the MATCHER."", ""MATCHER""); (""IS"", ""The IS method returns the OUTPUT."", ""OUTPUT"")"
You can write your own matchers and plug into the assertThat() method.,"(""matchers"", ""The matchers can be plugged into the assertThat method, indicating a functional relationship where matchers are used within the method."", ""assertThat"")"
The static method matches() creates a new matcher and returns it.,"(""matches"", ""The method 'matches' creates a new matcher."", ""matcher""); (""matches"", ""The method 'matches' returns a matcher."", ""returns"")"
You just embed the call to the static method matches() inside the assertThat() method.,"(""Matches"", ""The Matches method is used inside the AssertThat method, indicating a functional relationship where Matches is called by AssertThat."", ""AssertThat"")"
In several situations mock testing is easier than testing with the real collaborators of a class.,"(""Class"", ""class"")"
When testing a DAO you may use a mock java.sql.Connection and java.sql.ResultSet object with the DAO to check that the DAO makes the correct JDBC calls.,"(""DAO"", ""The DAO class uses the java.sql.Connection class to establish a connection to the database."", ""java.sql.Connection""); (""DAO"", ""The DAO class uses the java.sql.ResultSet class to handle the results of a database query."", ""java.sql.ResultSet""); (""DAO"", ""The DAO class makes JDBC calls to interact with the database."", ""JDBC"")"
It is not visible from the value returned by the DAO if it remembered to call ResultSet.close() and Connection.close() before returning.,"(""DAO"", ""The DAO class is responsible for calling the ResultSet.close() method to close the result set."", ""ResultSet.close()""); (""DAO"", ""The DAO class is responsible for calling the Connection.close() method to close the connection."", ""Connection.close()"")"
The above situation was exactly the case for the GenericDao class in Mr. Persister.,"(""GenericDao"", ""The GenericDao class is part of the Mr. Persister package."", ""Mr. Persister"")"
Ideally the JDBC driver would detect that when calling the PreparedStatement.executeUpdate() method.,"(""PreparedStatement"", ""The executeUpdate method is a function that belongs to the PreparedStatement class."", ""executeUpdate""); (""JDBC Driver"", ""The JDBC Driver interacts with the PreparedStatement class to execute SQL statements."", ""PreparedStatement"")"
Therefore we decided to compare the PreparedStatement.getParameterMetaData().getParameterCount() with parameters.length before calling PreparedStatement.executeUpdate().,"(""PreparedStatement"", ""The method getParameterMetaData is called on the class PreparedStatement."", ""getParameterMetaData""); (""getParameterMetaData"", ""The method getParameterCount is called on the result of getParameterMetaData."", ""getParameterCount""); (""PreparedStatement"", ""The method executeUpdate is called on the class PreparedStatement."", ""executeUpdate"")"
"This works with the HSQLDB driver, but the MySQL driver haven't implemented the PreparedStatement.getParameterMetaData() method.","(""HSQLDB"", ""The HSQLDB driver works with the getParameterMetaData method."", ""getParameterMetaData""); (""MySQL"", ""The MySQL driver has not implemented the getParameterMetaData method."", ""getParameterMetaData""); (""PreparedStatement"", ""The getParameterMetaData is a method of the PreparedStatement class."", ""getParameterMetaData"")"
Fortunately the MySQL driver does throw an exception if the ?-signs and the parameters set doesn't match when calling PreparedStatement.executeUpdate().,"(""PreparedStatement"", ""The method executeUpdate is called on the PreparedStatement class."", ""executeUpdate""); (""MySQL Driver"", ""The MySQL Driver is responsible for handling database operations, which includes using the PreparedStatement class."", ""PreparedStatement"")"
"In the classpath element I add the output locations of my project code, and test code.","(""Classpath Element"", ""The classpath element includes the output locations of the project and test code."", ""Output Locations"")"
In the test element I declare which unit test class to execute.,"(""Test Element"", ""The Test Element specifies which Unit Test Class to execute."", ""Unit Test Class"")"
The classpath stuff is the same as in the first example.,"(""Classpath"", ""class"")"
"In this example I execute all files that has the text ""Test"" and "".java"" in their file name, regardless of what directory they are located in, recursively.",NULL
"What I usually do instead, is to ""move the code out of the boundary class"", as I have described in the text Design for Testability.","(""Boundary Class"", ""The text 'Design for Testability' describes the concept of moving code out of the 'Boundary Class'."", ""Design for Testability"")"
"Basically, I would try to push the main business logic in the servlet into a separate class which has no dependencies on the Servlet API's, if possible.","(""Servlet"", ""The Servlet class is part of the Servlet API package, indicating a dependency or usage relationship."", ""Servlet API""); (""Business Logic"", ""The Business Logic class is suggested to be separated from the Servlet class to reduce dependencies."", ""Servlet"")"
"So, I will take the concatenation logic and move into a separate class, which can be tested independent from the MyServlet class.","(""Concatenation Logic"", ""The Concatenation Logic class is being moved to be independent from the MyServlet class, indicating a relationship where Concatenation Logic was previously part of or used by MyServlet."", ""MyServlet"")"
Notice how the concatenation logic has been moved to a class called MyConcatenator.,"(""MyConcatenator"", ""The concatenation logic is implemented within the MyConcatenator class."", ""concatenation logic"")"
Notice how the concatenate() method only refers to a string array.,"(""Concatenate"", ""The concatenate method is used to refer to a string array."", ""String Array"")"
Notice again how it was not necessary to reference any servlet classes or interfaces in this unit test.,"(""servlet"", ""The text mentions that it was not necessary to reference any servlet classes or interfaces in the unit test, indicating a relationship between servlet and unit test."", ""unit test"")"
By real objects I mean the objects the tested unit (class) will be using in the real application.,"(""Class"", ""The term 'class' is mentioned as the tested unit, indicating a relationship with the concept of real objects in the application."", ""Class"")"
"If you have a class Calculator, that needs a dao (Data Access Object) object to load the data it needs from a database, then the dao object is a ""real object"".","(""Calculator"", ""The class Calculator requires a dao object to load data from a database, indicating a dependency relationship."", ""dao"")"
In order to test the Calculator class you will have to provide it with a dao object that has a valid connection to the database.,"(""Calculator"", ""The Calculator class requires a dao object to function, indicating a dependency or interaction between them."", ""dao"")"
Instead you can provide the Calculator instance with a fake dao class which just returns the data you need for the test.,"(""Calculator"", ""The Calculator class is provided with a dao class to return the necessary data for testing."", ""dao"")"
The fake dao class will not actually read the data from the database.,"(""Fake Dao"", ""The Fake Dao class is mentioned in the context of reading data from the database, indicating a relationship between the class and the database."", ""Database"")"
A replacement for a real object which makes it easier to test the Calculator class.,"(""Calculator"", ""The replacement is used to facilitate testing of the Calculator class."", ""replacement"")"
Nor can you see if the connection.close() method was called before returning the value.,"(""CONNECTION.CLOSE()"", ""The method CONNECTION.CLOSE() is mentioned in the context of being called before returning the value, indicating a relationship between the method and the value."", ""VALUE"")"
"If you add a String ""myReturnValue"" as return value to the stub and then call connection.prepareStatement(""select * from houses"") which returns a PreparedStatement, you will get an exception.","(""prepareStatement"", ""The method prepareStatement is used to obtain an instance of the class PreparedStatement."", ""PreparedStatement""); (""String"", ""The class String is used as a return value in the context of calling the method prepareStatement."", ""prepareStatement"")"
"The String return value cannot be returned from the connection.prepareStatement(""...""); You will have to make sure yourself that the return values and called methods on the stub match.","(""prepareStatement"", ""The method prepareStatement is related to the class String as it is mentioned in the context of returning a String value."", ""String"")"
If the connection.close() method has not been called a java.lang.AssertionError is thrown.,"(""connection.close()"", ""The java.lang.AssertionError is thrown if the connection.close() method has not been called."", ""java.lang.AssertionError"")"
You just provide the real collaborator to the MockFactory instead of an interface (class object).,"(""MockFactory"", ""MockFactory is described as a class object in the text, indicating it is a class entity."", ""class"")"
You can even turn the proxyConnection into a stub temporarily by adding a return value to the proxy via the mock.addReturnValue(...).,"(""mock"", ""The method addReturnValue is used with the mock class to add a return value to the proxy."", ""addReturnValue""); (""proxyConnection"", ""The proxyConnection can be turned into a stub by using the mock class."", ""mock"")"
"Subclass mock objects is a mock object that is created by subclassing the class you want to test, and overriding some of its methods.","(""Subclass Mock Objects"", ""Subclass Mock Objects is a type of Mock Object created by subclassing."", ""Mock Object""); (""Subclass Mock Objects"", ""Subclass Mock Objects involves overriding some methods of the class being tested."", ""Method"")"
The class MyUnit is the class I am trying to unit test.,"(""MyUnit"", ""MyUnit is the class that is being unit tested."", ""unit test"")"
"In this unit test, I want to check if the MyUnit class calls the MyDependency class correctly.","(""MyUnit"", ""The MyUnit class is expected to call the MyDependency class, indicating a relationship where MyUnit depends on MyDependency."", ""MyDependency"")"
"The first thing to do is to refactory the MyUnit class, so that all calls to the MyDependency class are encapsulated in their own methods.","(""MyUnit"", ""The MyUnit class makes calls to the MyDependency class, indicating a dependency relationship."", ""MyDependency""); (""MyUnit"", ""The MyUnit class encapsulates calls to MyDependency in its own methods, indicating that methods are part of MyUnit."", ""methods"")"
"Notice how the two calls to MyDependency.callOne() and MyDependency.callTwo() are now encapsulated in two protected methods, callOne() and callTwo().","(""MyDependency"", ""The method callOne() is invoked on the class MyDependency."", ""callOne""); (""MyDependency"", ""The method callTwo() is invoked on the class MyDependency."", ""callTwo"")"
The second step is to create a subclass mock of the MyUnit class.,"(""mock"", ""The mock is a subclass of the MyUnit class."", ""MyUnit"")"
Here is a unit test method that uses the MyUnitMock class:,"(""unit test"", ""The unit test method uses the MyUnitMock class, indicating a dependency or interaction between the two."", ""MyUnitMock"")"
"Third, assertions are made about whether the callOne() and callTwo() method were invoked.","(""Callone"", ""Both are methods mentioned in the context of being invoked."", ""Calltwo"")"
"As you can see, it is possible to test almost all of a class by using subclass mocks, as described above.","(""Class"", ""Subclass Mocks are used to test the Class"", ""Subclass Mocks"")"
"There are, however, situations where it works better to use a completely separate mock dependency object with the original class instead.","(""Mock Dependency Object"", ""The Mock Dependency Object is used with the Original Class as a separate entity to improve functionality in certain situations."", ""Original Class"")"
"If the throwIllegalArgumentException() method returns normall, then this fail() call is executed, causing the test to fail.","(""throwIllegalArgumentException"", ""The fail() method is executed if the throwIllegalArgumentException() method returns normally, indicating a relationship where one method's behavior affects the execution of another."", ""fail"")"
"Correspondingly, if the throwIllegalArgumentException() method throws the expected IllegalArgumentException, it is caught in the catch-clause, and ignored.","(""throwIllegalArgumentException"", ""The method throwIllegalArgumentException is related to the class IllegalArgumentException because it throws an exception of this type."", ""IllegalArgumentException"")"
"Instead you want users trying to access your web app to see a nice ""This web app is down for maintenance..."" page.",NULL
"A ""This web app is down for maintenance..."" page lets them know that the down time is controlled and expected.",NULL
Here is how the web.xml configuration looks for such a setup:,"(""web.xml"", ""The web.xml file is used for configuration purposes in a web application setup."", ""configuration"")"
"For instance, imagine that a user sends a request that takes 1 minute to process (e.g.",NULL
"I've posted the full solution including the servlet filter Java code, the web.xml configuration, the maintenance message page and the maintenance GUI page, for your convenience below.","(""Servlet Filter"", ""The servlet filter is configured in the web.xml file."", ""Web.xml""); (""Servlet Filter"", ""The servlet filter likely serves the maintenance message page during maintenance."", ""Maintenance Message Page""); (""Servlet Filter"", ""The servlet filter likely interacts with the maintenance GUI page for maintenance operations."", ""Maintenance GUI Page"")"
"Apparently the field name ""comment"" caused the text (""Comment..."") in the textarea not to show up in Firefox... weird, right...?!","(""Comment"", ""The field 'Comment' is likely related to the 'Textarea' class as it is mentioned in the context of text not showing up in the textarea."", ""Textarea"")"
"In order to get a Java web server or servlet container to run your Java web application, you need to package the resources inside it (servlets, JSP's etc.)","(""Java"", ""Servlets are part of the resources that need to be packaged in a Java web application."", ""Servlet""); (""Java"", ""JSPs are part of the resources that need to be packaged in a Java web application."", ""JSP"")"
... then the index.jsp page will be accessible at the URL,NULL
"For instance, if you create a subdirectory called layout, and put a file inside it called theLayout.jsp, then you could access that file from the outside, via this URL:",NULL
"Inside the WEB-INF directory there are two important directories (classes and lib, and one important file (web.xml).","(""WEB-INF"", ""The 'classes' directory is located inside the 'WEB-INF' directory."", ""classes""); (""WEB-INF"", ""The 'lib' directory is located inside the 'WEB-INF' directory."", ""lib""); (""WEB-INF"", ""The 'web.xml' file is located inside the 'WEB-INF' directory."", ""web.xml"")"
"The web.xml file contains information about the web application, which is used by the Java web server / servlet container in order to properly deploy and execute the web application.","(""Web.xml"", ""The web.xml file contains information about the web application."", ""Web Application""); (""Web.xml"", ""The web.xml file is used by the Java web server to deploy and execute the web application."", ""Java Web Server""); (""Web.xml"", ""The web.xml file is used by the servlet container to deploy and execute the web application."", ""Servlet Container"")"
"For instance, the web.xml contains information about which servlets a web application should deploy, and what URL's they should be mapped to.","(""WEB.XML"", ""WEB.XML contains information about which SERVLETS a web application should deploy"", ""SERVLETS"")"
I will not get into more detail about the web.xml file here.,"(""WEB.XML"", ""FILE"")"
The classes directory contains all compiled Java classes that are part of your web application.,"(""Classes"", ""The classes are contained within the directory, indicating a containment relationship."", ""Directory"")"
"The classes should be located in a directory structure matching their package structure, just like if you were to run them directly from the commandline, or package them in a JAR file.","(""Classes"", ""Classes are organized within a package structure."", ""Package"")"
"You could, however, also put your own classes into a JAR file, and locate it here, rather than putting those classes in the classes directory.","(""JAR file"", ""JAR file can contain classes, which are typically stored in the classes directory."", ""classes"")"
Perl or C. A Servlet is an ordinary Java class that implements a special Servlet interface.,"(""Servlet"", ""Servlet is a class that is part of the Java package."", ""Java""); (""Servlet"", ""Servlet is a class that implements the Servlet interface."", ""Servlet"")"
"Here is a small servlet and JSP example to better illustrate the difference: public void service(ServletRequest request, ServletResponse response){ PrintWriter writer = ((HttpServletResponse) response)).getWriter(); writer.write(""<html>""); writer.write(""<body>""); writer.write(""<table>""); for(int i=0; i<10; i++){ writer.write(""<tr><td>""); writer.write("""" + i); writer.write(""</td></tr>""); } writer.write(""</table>""); writer.write(""</body>""); writer.write(""</html>""); } <html> <body> <table> <% for(int i=0; i<10; i++){ %><tr><td><%=i%></td></tr><% } %> </table> </body> </html> As you can see, the JSP example is much shorter than the Servlet example, and it is much easier to get an overview of the HTML.","(""service"", ""The method 'service' takes 'ServletRequest' as a parameter, indicating a relationship where 'ServletRequest' is used within the method."", ""ServletRequest""); (""service"", ""The method 'service' takes 'ServletResponse' as a parameter, indicating a relationship where 'ServletResponse' is used within the method."", ""ServletResponse""); (""service"", ""Within the 'service' method, 'PrintWriter' is used to write HTML content, showing a relationship where 'PrintWriter' is utilized in the method."", ""PrintWriter""); (""ServletResponse"", ""'HttpServletResponse' is a specific implementation or subclass of 'ServletResponse', indicating a class relationship."", ""HttpServletResponse"")"
This is illustrated below: component.control --> component.control --> component.control --> component.control --> component.control component.view --> component.view --> component.view --> component.view --> component.view First all components in the hierarchy executes their control logic (domain logic).,"(""Component.Control"", ""Component.Control and Component.View are both part of the component hierarchy and interact through the execution of control logic."", ""Component.View"")"
A Servlet is an ordinary Java class that implements a special Servlet interface.,"(""Servlet"", ""Servlet is a class that implements the Servlet interface"", ""Servlet interface""); (""Servlet"", ""Servlet is a Java class"", ""Java"")"
JCTools is an open source toolkit and is released under the Apache License 2.0.,"(""JCTools"", ""JCTools is released under the Apache License 2.0, indicating a licensing relationship."", ""Apache License 2.0"")"
"A Fat JAR is a single JAR file that contains all the compiled Java classes from your project, and all compiled Java classes from all JAR files your project depends on (see Maven Dependencies).","(""Fat JAR"", ""A Fat JAR includes all compiled Java classes from dependencies, which are managed by Maven Dependencies."", ""Maven Dependencies"")"
"Fat JARs are handy when you need to build an executable JAR file, e.g.",NULL
"This makes execution much easier, because you don't have to list all the JAR files your microservice depends on, on the classpath.","(""JAR"", ""JAR files are typically included in the classpath to be used by applications."", ""classpath""); (""microservice"", ""Microservices often depend on JAR files for their execution."", ""JAR"")"
"When you execute Maven package phase with the maven-assembly-plugin configuration shown earlier, Maven will output a Fat JAR in the target directory, into which Maven outputs all of its other build products (e.g.","(""Maven"", ""Maven uses the maven-assembly-plugin during the package phase."", ""Maven-assembly-plugin""); (""Maven-assembly-plugin"", ""The maven-assembly-plugin is configured to output a Fat JAR."", ""Fat JAR""); (""Fat JAR"", ""The Fat JAR is output into the target directory."", ""target directory"")"
"The list contains more than 1.300 Maven archetypes, so it is not really that easy to find the archetype you need.",NULL
"Too look at the list of available Maven archetypes, you can pipe the output into a file, and open that file in e.g.",NULL
"Keep in mind, that when you execute the clean goal of Maven, the target directory is removed, meaning you lose all compiled classes from previous builds.","(""clean"", ""The clean goal of Maven removes the target directory."", ""target""); (""target"", ""The target directory contains compiled classes from previous builds."", ""classes"")"
"That means, that Maven will have to build all of your project again from scratch, rather than being able to just compile the classes that were changed since last build.","(""Maven"", ""Maven is a build automation tool that compiles classes in a project."", ""classes"")"
"However, sometimes it can be nice to have a clean, fresh build, e.g.",NULL
The pom.xml file is the Maven POM file (Project Object Model).,"(""POM"", ""POM is part of the Maven package as it is a file used in Maven projects."", ""Maven"")"
The .mvn directory is a directory where you can put some Maven configuration files.,"(""Maven"", ""package"")"
One of these Maven configuration files is the jvm.config file which can be used to configure the Java VM that is used by Maven to build your project.,"(""JVM.CONFIG"", ""The JVM.CONFIG file is used to configure the Java VM."", ""JAVA VM""); (""JVM.CONFIG"", ""The JVM.CONFIG file is a configuration file used by Maven."", ""MAVEN""); (""JAVA VM"", ""The Java VM is used by Maven to build the project."", ""MAVEN"")"
The resource files will be available for loading via the classpath.,"(""CLASSPATH"", ""Classpath is used to load resource files."", ""RESOURCE FILES"")"
The default Java compiler version used by Maven is Java 1.5 .,"(""Maven"", ""Maven uses Java as its default compiler version"", ""Java"")"
"To make Maven compile your Java code with a newer version of the Java compiler, you need to specify the Java compiler explicitly in your project's POM file (pom.xml).","(""Maven"", ""Maven is used to manage Java projects and can specify the Java compiler version."", ""Java Compiler""); (""POM File"", ""The POM file is used to specify the Java compiler version in a Maven project."", ""Java Compiler"")"
Notice also that the version of the Maven Java compiler plugin has changed from 3.6.1 to 3.8.0 .,"(""Maven Java Compiler Plugin"", ""The version 3.6.1 is associated with the Maven Java Compiler Plugin."", ""3.6.1""); (""Maven Java Compiler Plugin"", ""The version 3.8.0 is associated with the Maven Java Compiler Plugin."", ""3.8.0"")"
The first version of this Maven tutorial is based on Maven 3.6.3.,"(""Maven"", ""Maven 3.6.3 is a specific version of the Maven package"", ""Maven 3.6.3"")"
The POM file is named pom.xml and should be located in the root directory of your project.,"(""POM"", ""The POM file is named pom.xml, indicating that pom.xml is an instance or representation of the POM class."", ""pom.xml"")"
"This command first executes the clean build life cycle, which removes compiled classes from the Maven output directory, and then it executes the install build phase.","(""Clean Build Life Cycle"", ""The Clean Build Life Cycle is a process within the Maven package."", ""Maven""); (""Install Build Phase"", ""The Install Build Phase is a method executed as part of the Maven package."", ""Maven"")"
These JAR files are needed on the classpath when you compile your project code.,"(""JAR Files"", ""JAR Files are needed on the classpath when compiling project code."", ""Classpath"")"
"The example above needs the org.jsoup group's jsoup artifact in version 1.7.1, and the junit group's junit artifact in version 4.8.1.","(""org.jsoup"", ""The jsoup artifact is part of the org.jsoup group, indicating a relationship between the package and the artifact."", ""jsoup""); (""junit"", ""The junit artifact is part of the junit group, indicating a relationship between the package and the artifact."", ""junit"")"
"Thus Maven only needs to download the dependencies once, even if multiple projects depends on them (e.g.","(""Maven"", ""Maven manages dependencies for projects, indicating a relationship between the package and the dependencies it handles."", ""dependencies"")"
Your Maven settings file is also located in your user-home/.m2 directory and is called settings.xml.,"(""Maven"", ""The settings.xml file is part of the Maven package, as it is located in the Maven settings directory."", ""settings.xml"")"
"The clean life cycle handles everything related to removing temporary files from the output directory, including generated source files, compiled classes, previous JAR files etc.","(""Clean Life Cycle"", ""The clean life cycle is responsible for handling the removal of temporary files."", ""Temporary Files""); (""Clean Life Cycle"", ""The clean life cycle manages the removal of files from the output directory."", ""Output Directory""); (""Clean Life Cycle"", ""The clean life cycle handles the removal of generated source files."", ""Generated Source Files""); (""Clean Life Cycle"", ""The clean life cycle is responsible for removing compiled classes."", ""Compiled Classes""); (""Clean Life Cycle"", ""The clean life cycle manages the removal of previous JAR files."", ""JAR Files"")"
One way to choose what profile is being executed is in the settings.xml file.,"(""settings.xml"", ""The settings.xml file is used to choose what profile is being executed."", ""profile"")"
"You do so by creating a simple Java class that extends a special Maven class, and then create a POM for the project.","(""Java"", ""The Java class extends the Maven class, indicating a relationship of inheritance or extension."", ""Maven""); (""Maven"", ""The POM is created for the project, which involves the Maven class, suggesting a relationship in the context of project management or build configuration."", ""POM"")"
It is the argument -Dmaven.test.skip=true that makes Maven skip the tests completely.,"(""Dmaven.test.skip"", ""The argument Dmaven.test.skip is used to configure the Maven package to skip tests."", ""Maven"")"
To configure the Maven Surefire plugin to enable Java preview features you need the following configuration in your Maven POM file - in the <build><plugins>...</plugins></build> section:,"(""Maven Surefire Plugin"", ""The Maven Surefire Plugin is configured within the Maven POM File."", ""Maven POM File""); (""Java"", ""The Maven Surefire Plugin is used to enable Java preview features."", ""Maven Surefire Plugin"")"
To publish a JAR file with compiled Java classes to the Maven central repository you need to go through set of steps.,"(""JAR File"", ""A JAR file contains compiled Java classes."", ""Java Classes""); (""JAR File"", ""The JAR file is published to the Maven central repository."", ""Maven Central Repository"")"
You can find more information about creating and publishing a public key / priate key pair from the Sonatype producers page: https://central.sonatype.org/pages/producers.html.,"(""Sonatype"", ""The Sonatype package is related to the producers page as it provides information about creating and publishing a public/private key pair."", ""producers"")"
"For a full POM file, check out the pom.xml in this github repository: RION Ops for Java GitHub Repository","(""POM File"", ""The POM File is represented by the pom.xml file."", ""pom.xml""); (""RION Ops"", ""RION Ops is a package available in the Java GitHub Repository."", ""Java GitHub Repository"")"
From Maven 3.3 and forward you can set the memory limits in a file called jvm.config located in the .mvn directory inside your project directory.,"(""jvm.config"", ""The jvm.config file is located inside the .mvn directory."", "".mvn""); ("".mvn"", ""The .mvn directory is part of the Maven project structure."", ""Maven"")"
Inside the jvm.config file you need the following settings to be able to control the memory limits of Maven during a Maven build:,"(""JVM.Config"", ""JVM.Config is used to configure settings for Maven."", ""Maven""); (""Maven"", ""Maven is the package that executes the Maven Build method."", ""Maven Build"")"
"Once you have created the project root directory, create a file called pom.xml inside the directory.","(""POM.XML"", ""FILE"")"
"When you have created the pom.xml file inside the project root directory it is a good idea to just test that Maven works, and that Maven understands the pom.xml file.","(""POM.XML"", ""The POM.XML file is used by Maven to understand the project's configuration."", ""MAVEN""); (""PROJECT ROOT DIRECTORY"", ""The POM.XML file is located inside the project root directory."", ""POM.XML"")"
"To test the pom.xml file, open a command prompt and change directory (cd) into the project root directory.",NULL
Inside the helloworld directory (java package) insert a file named HelloWorld.java.,"(""Helloworld"", ""The class Helloworld.java is located inside the Helloworld package."", ""Helloworld.java"")"
Maven will compile the Java source file and create a JAR file containing the compiled Java class.,"(""Maven"", ""Maven compiles the Java source file."", ""Java""); (""Maven"", ""Maven creates a JAR file containing the compiled Java class."", ""JAR"")"
"Inside the target directory you will find the finished JAR file, as well as lots of temporary files (e.g.",NULL
The Mem Ops Bytes class represents a sequence of bytes from a byte array.,"(""Mem Ops Bytes"", ""The Mem Ops Bytes class represents a sequence of bytes from a byte array."", ""byte array"")"
"To avoid fragmenting the Java heap with Bytes instances, the Bytes class is designed to be obtained from an ObjectPool .","(""Bytes"", ""The Bytes class is designed to be obtained from an ObjectPool, indicating a relationship where Bytes instances are managed or created by ObjectPool."", ""ObjectPool"")"
"To use the Bytes class effectively you should create a BytesAllocatorAutoDefrag, a BytesFactory and an ObjectPool .","(""Bytes"", ""BytesAllocatorAutoDefrag is used to allocate and manage Bytes objects."", ""BytesAllocatorAutoDefrag""); (""Bytes"", ""BytesFactory is used to create instances of Bytes."", ""BytesFactory""); (""Bytes"", ""ObjectPool is used to manage a pool of Bytes objects for efficient reuse."", ""ObjectPool"")"
To obtain a Bytes instance from the ObjectPool you simply call the ObjectPool instance() method.,"(""ObjectPool"", ""The 'instance' method is called on the 'ObjectPool' class to obtain an instance."", ""instance""); (""ObjectPool"", ""The 'Bytes' instance is obtained from the 'ObjectPool' class."", ""Bytes"")"
Calling free() will free the Bytes instance back to the ObjectPool and the allocated bytes back to the BytesAllocatorAutoDefrag.,"(""Free"", ""The method 'Free' is called on the 'Bytes' class to perform an action."", ""Bytes""); (""Free"", ""The method 'Free' returns the 'Bytes' instance back to the 'ObjectPool'."", ""ObjectPool""); (""Free"", ""The method 'Free' returns the allocated bytes back to the 'BytesAllocatorAutoDefrag'."", ""BytesAllocatorAutoDefrag"")"
"In this section I will try to give you a few visual use case examples that shows how to use the Bytes class, and its fields.","(""Bytes"", ""The text mentions fields in relation to the Bytes class, indicating that fields are attributes or components of the Bytes class."", ""fields"")"
"The use cases are actually quite similar in how they use the Bytes class, even if they are doing different things.","(""Bytes"", ""The text mentions how use cases utilize the Bytes class, indicating a relationship between the use cases and the Bytes class."", ""Bytes"")"
The Mem Ops BytesAllocatorAutoDefrag class is capable of allocating smaller sections (blocks) of a bigger byte array.,"(""Mem Ops BytesAllocatorAutoDefrag"", ""The class is responsible for allocating smaller sections of a byte array."", ""Mem Ops BytesAllocatorAutoDefrag"")"
"When you free a byte array section, the BytesAllocatorAutoDefrag class will automatically defragment its internal big byte array so the freed section is joined with adjacent free sections to form a larger free section from which future sections can be allocated.","(""BytesAllocatorAutoDefrag"", ""The BytesAllocatorAutoDefrag class is responsible for automatically defragmenting the byte array section when it is freed."", ""byte array section"")"
To use the BytesAllocatorAutoDefrag class you must first create an instance of it.,"(""BytesAllocatorAutoDefrag"", ""The text suggests creating an instance of the BytesAllocatorAutoDefrag class, indicating a relationship between the class and its instance."", ""instance"")"
"In order to allocate a block (section) of bytes from the underlying byte array, you call the allocate() method.","(""ALLOCATE"", ""The ALLOCATE method is used to allocate a block of bytes from the BYTE ARRAY."", ""BYTE ARRAY"")"
"Once allocated, no other allocate() call can allocate the same block until it has been freed.","(""ALLOCATE"", ""The method ALLOCATE() is related to the concept of ALLOCATE as it represents the action of allocating resources."", ""ALLOCATE()""); (""ALLOCATE()"", ""ALLOCATE() is a specific instance or call of the general ALLOCATE method."", ""ALLOCATE"")"
"The allocate() method returns the offset into the big, underlying byte array where the allocated block starts.","(""Allocate"", ""The Allocate method returns the offset into the big, underlying byte array where the allocated block starts."", ""Byte Array"")"
You can get a reference to the underlying byte array via the getData() method.,"(""getData"", ""The getData method provides access to the underlying byte array."", ""byte array"")"
"Once you have allocated a block of bytes from the BytesAllocatorAutoDefrag you can access it via the data array, from the offset returned by allocate() and until offset + length - 1.","(""BytesAllocatorAutoDefrag"", ""The method 'allocate' is likely a function of the class 'BytesAllocatorAutoDefrag', as it is mentioned in the context of allocating bytes from it."", ""allocate"")"
The free() method takes the start and end offset of the block to free.,"(""FREE"", ""The free() method is used to free a block, indicating a direct relationship between the method and the block."", ""BLOCK"")"
The Mem Ops BytesAllocatorManualDefrag class is capable of allocating smaller sections (blocks) of a bigger byte array.,"(""Mem Ops BytesAllocatorManualDefrag"", ""The class is capable of allocating smaller sections of a bigger byte array."", ""byte array"")"
"When you free a byte array section, the ByteArrayAllocatorAutoDefrag class will mark it as free, but will not defragment the underlying byte array until you explicitly to tell it to.","(""ByteArrayAllocatorAutoDefrag"", ""The ByteArrayAllocatorAutoDefrag class manages the allocation and deallocation of byte array sections."", ""byte array"")"
To use the BytesAllocatorManualDefrag class you must first create an instance of it.,"(""BytesAllocatorManualDefrag"", ""The text suggests creating an instance of the BytesAllocatorManualDefrag class, indicating a relationship between the class and its instance."", ""instance"")"
"Once you have allocated a block of bytes from the BytesAllocatorManualDefrag you can access it via the data array, from the offset returned by allocate() and until offset + length - 1.","(""BytesAllocatorManualDefrag"", ""The method 'allocate' is likely a function of the class 'BytesAllocatorManualDefrag', as it is mentioned in the context of allocating bytes from this class."", ""allocate"")"
To defragment the free blocks you call the defragment() method of the BytesAllocatorManualDefrag .,"(""Defragment"", ""The defragment() method is a function that belongs to the BytesAllocatorManualDefrag class, indicating a method-class relationship."", ""BytesAllocatorManualDefrag"")"
It is during such idle times you should call defragment() .,"(""Defragment"", ""The text suggests calling the method 'defragment()' during idle times, indicating its use as a method."", ""Defragment"")"
"If your system is constantly very busy, there may never be an idle period during which to call defragment().","(""system"", ""The method 'defragment' is called on the 'system' when it is not busy."", ""defragment"")"
Calling defragment() will most likely result in a longer pause than if you immediately defragment free blocks like the ByteArrayAllocatorAutoDefrag does.,"(""Defragment"", ""The method 'Defragment' is related to the class 'ByteArrayAllocatorAutoDefrag' because the class likely implements or uses this method to manage memory allocation."", ""ByteArrayAllocatorAutoDefrag"")"
"Systems that need to create high numbers of objects at a rapid pace, but do not need all of these objects at the same time, can benefit from using object pools rather than instantiating the objects using the Java new XYZObject() .","(""Java"", ""XYZObject is likely a class that can be instantiated using the Java package."", ""XYZObject"")"
The Bytes class represents a byte sequence allocated from a shared byte array.,"(""Bytes"", ""The Bytes class represents a byte sequence."", ""byte sequence""); (""Bytes"", ""The Bytes class is allocated from a shared byte array."", ""shared byte array"")"
The Mem Ops ObjectPool class is capable of pooling instances of objects which can be reused.,"(""ObjectPool"", ""The ObjectPool class is part of the Mem Ops package, as it is described as being capable of pooling instances of objects."", ""Mem Ops"")"
To use the Mem Ops ObjectPool you must first create an instance of the com.nanosai.memops.objects.ObjectPool class.,"(""ObjectPool"", ""The ObjectPool class is part of the com.nanosai.memops.objects package."", ""com.nanosai.memops.objects"")"
Notice that the ObjectPool class constructor takes two parameters: The capacity and an IObjectFactory implementation.,"(""ObjectPool"", ""The constructor is a method of the ObjectPool class."", ""constructor""); (""constructor"", ""The constructor takes an IObjectFactory implementation as a parameter."", ""IObjectFactory"")"
"As you can see, the IObjectFactory only contains a single method named instance().","(""IObjectFactory"", ""The IObjectFactory class contains the method instance."", ""instance"")"
The type returned from the instance() method is decided by you when you implement the IObjectFactory interface.,"(""INSTANCE"", ""The INSTANCE method is implemented as part of the IOBJECTFACTORY interface, indicating a relationship between the method and the class."", ""IOBJECTFACTORY"")"
You free an object instance for reuse by calling the ObjectPool free() method.,"(""ObjectPool"", ""The free method is called on the ObjectPool class to free an object instance for reuse."", ""free"")"
"You just tell what module that contains the main class to run, and ModRun resolves and loads all its dependencies too.","(""ModRun"", ""ModRun resolves and loads all dependencies for the main class to run"", ""main class"")"
"By loading the classes of a module with its own ClassLoader, ModRun can control what classes are visible to each module.","(""ModRun"", ""ModRun uses ClassLoader to manage class visibility for each module"", ""ClassLoader"")"
A module can only see the classes from itself or from its dependencies (modules) and transitive dependencies.,"(""MODULE"", ""A module can see the classes from itself or its dependencies."", ""CLASSES"")"
"A module cannot see classes from modules ""above"" itself in the dependency graph.","(""module"", ""A module is part of the dependency graph, which determines its visibility to other modules."", ""dependency graph"")"
The JVM will consider classes loaded from the two different versions of the API as different classes because they are loaded with different ClassLoader instances.,"(""JVM"", ""The JVM uses ClassLoader instances to load classes, which affects how classes are considered by the JVM."", ""ClassLoader"")"
Each instance of the module have the classes loaded from its dependency graph isolated from the other instances of the same module (at least it can - if you want to).,"(""MODULE"", ""Each instance of the module is isolated from other instances, indicating a relationship between the module and its instances."", ""INSTANCE"")"
Loading the classes from each module with its own ClassLoader makes application multi tenancy easier.,"(""ClassLoader"", ""ClassLoader is used to load classes from each module"", ""module"")"
"ModRun can load multiple applications into the same JVM at the same time, and have their classes be completely isolated from each other, so one application cannot access the classes of another application.","(""ModRun"", ""ModRun can load multiple applications into the same JVM."", ""JVM""); (""application"", ""Each application has its own isolated classes."", ""classes"")"
"Here is an example that creates a module from a Maven repository, loads a class from the module, creates an instance of the class and calls a method on the instance via reflection:","(""MODULE"", ""The module is created from the Maven repository."", ""MAVEN REPOSITORY""); (""CLASS"", ""The class is loaded from the module."", ""MODULE""); (""INSTANCE"", ""The instance is created from the class."", ""CLASS""); (""METHOD"", ""The method is called on the instance."", ""INSTANCE"")"
Installing Netty in your Java project only requires that you download the Netty JAR files and include them on the classpath.,"(""Netty"", ""Netty is a package that includes the Netty JAR files, which are necessary for installation."", ""Netty JAR files""); (""Netty JAR files"", ""Netty JAR files need to be included in the classpath of a Java project for installation."", ""Java"")"
"A Netty EventLoop is a loop that keeps looking for new events, e.g.","(""Netty"", ""EventLoop is a class within the Netty package"", ""EventLoop"")"
"Third, the NioServerSocketChannel class instance is set on the ServerBootstrap instance.","(""NioServerSocketChannel"", ""The NioServerSocketChannel class instance is set on the ServerBootstrap instance, indicating a relationship where the former is used or configured within the latter."", ""ServerBootstrap"")"
Its method initChannel() is called whenever a new incoming TCP connection is accepted by the TCP server.,"(""initChannel"", ""The method initChannel() is called by the TCP server when a new incoming TCP connection is accepted."", ""TCP server"")"
"As you can see, the ChannelInitializer is added to the ServerBootstrap using the childHandler() method.","(""ChannelInitializer"", ""ChannelInitializer is added to the ServerBootstrap, indicating a relationship where ChannelInitializer is used within ServerBootstrap."", ""ServerBootstrap""); (""childHandler"", ""The childHandler() method is used with ServerBootstrap, suggesting that it is a method belonging to or used by ServerBootstrap."", ""ServerBootstrap"")"
The serverBootstrap.bind() method returns a ChannelFuture which can be used to know when the binding of the server (binding to local address and TCP port) is done.,"(""ServerBootstrap"", ""The Bind method is a function of the ServerBootstrap class."", ""Bind""); (""Bind"", ""The Bind method returns a ChannelFuture object."", ""ChannelFuture"")"
"By calling sync() on the ChannelFuture the main thread that creates the server waits until the server has started, before continuing.","(""ChannelFuture"", ""The method sync() is called on the ChannelFuture class."", ""sync"")"
The channelRead() method is called whenever data is received from the SocketChannel the HelloServerHandler instance is attached to.,"(""ChannelRead"", ""The ChannelRead method is called when data is received from the SocketChannel."", ""SocketChannel""); (""ChannelRead"", ""The ChannelRead method is part of the HelloServerHandler instance."", ""HelloServerHandler""); (""SocketChannel"", ""The HelloServerHandler instance is attached to the SocketChannel."", ""HelloServerHandler"")"
"As you can see, the channelRead() responds with ""Hello "" + whatever the client sent to the server.","(""CHANNELREAD"", ""The method channelRead() responds with the string 'Hello'."", ""HELLO""); (""CHANNELREAD"", ""The method channelRead() processes data sent by the client."", ""CLIENT""); (""CHANNELREAD"", ""The method channelRead() is part of the server's response mechanism."", ""SERVER"")"
The channelReadComplete() method is called when there is no more data to read from the SocketChannel.,"(""channelReadComplete"", ""The channelReadComplete method is called when there is no more data to read from the SocketChannel, indicating a direct interaction between the method and the class."", ""SocketChannel"")"
The exceptionCaught() method is called if an exception is thrown while receiving or sending data from the SocketChannel.,"(""exceptionCaught"", ""The exceptionCaught method is related to the SocketChannel class because it is called when an exception occurs during data transmission involving a SocketChannel."", ""SocketChannel"")"
That means that you create a Java application with a class with a main() method and inside that application you create one of the Netty servers.,"(""Application"", ""The Main method is part of the Application class."", ""Main""); (""Java"", ""The Application class is part of a Java package."", ""Application""); (""Netty"", ""The Application creates a server using the Netty package."", ""Application"")"
The RION Ops RionObjectReader class can read a RION Object field into a Java object.,"(""RionObjectReader"", ""The RionObjectReader class is part of the RION package."", ""RION""); (""RionObjectReader"", ""The RionObjectReader class has a method to read a RION Object field."", ""RionObjectReader"")"
The easiest way to create an instance of the RionObjectReader is via the RionObjectReaderBuilder class.,"(""RionObjectReaderBuilder"", ""The RionObjectReaderBuilder class is used to create an instance of the RionObjectReader class."", ""RionObjectReader"")"
This class makes it easier to configure and create a RionObjectReader instance.,"(""RionObjectReader"", ""The text mentions configuring and creating an instance of the RionObjectReader class, indicating a relationship between the class and its instance creation."", ""RionObjectReader"")"
Here is an example of creating a RionObjectReader via the RionObjectReaderBuilder class:,"(""RionObjectReaderBuilder"", ""RionObjectReader is created using the RionObjectReaderBuilder class"", ""RionObjectReader"")"
The RionObjectReader readCyclic() method reads a cyclic object graph stored as RION in a byte array.,"(""RionObjectReader"", ""The readCyclic method is a function of the RionObjectReader class."", ""readCyclic""); (""readCyclic"", ""The readCyclic method reads a cyclic object graph stored as RION."", ""RION"")"
The RION Ops RionObjectWriter class makes it easy to write Java objects as a RION field to a byte array.,"(""RionObjectWriter"", ""The RionObjectWriter class is used to write Java objects as a RION field."", ""RION""); (""RionObjectWriter"", ""The RionObjectWriter class writes Java objects."", ""Java""); (""RionObjectWriter"", ""The RionObjectWriter class writes to a byte array."", ""byte array"")"
"To use the RionObjectWriter you must first create an instance of the RionObjectWriter class, com.nanosai.rionops.rion.object.RionObjectWriter.","(""RionObjectWriter"", ""The RionObjectWriter class is part of the com.nanosai.rionops.rion.object.RionObjectWriter package."", ""com.nanosai.rionops.rion.object.RionObjectWriter"")"
The easiest way to create a RionObjectWriter instance is via the RionObjectWriterBuilder class.,"(""RionObjectWriterBuilder"", ""The RionObjectWriterBuilder class is used to create an instance of the RionObjectWriter class."", ""RionObjectWriter"")"
"These examples build a RionObjectWriter which will serialize all fields (private, protected, default and public) found in the Pojo class to RION.","(""RionObjectWriter"", ""RionObjectWriter is used to serialize instances of the Pojo class."", ""Pojo""); (""serialize"", ""The method serialize is associated with the RionObjectWriter class to perform serialization."", ""RionObjectWriter"")"
"Once created, the RionObjectWriter instance then only serialize objects of the given class.","(""RionObjectWriter"", ""The RionObjectWriter class is responsible for serializing objects."", ""serialize"")"
To serialize objects of multiple classes you will have to create a RionObjectWriter for each class.,"(""RionObjectWriter"", ""RionObjectWriter is used to serialize objects."", ""objects""); (""serialize"", ""The method serialize is applied to objects."", ""objects"")"
Note: You only need one RionObjectWriter per root class you want to serialize.,"(""RionObjectWriter"", ""RionObjectWriter is used to serialize the root class."", ""root class"")"
"If a given class represents an object graph consisting of other classes referenced from within the root class (or any of its field's classes recursively), all of these classes will be serialized too.","(""Class"", ""The text describes a class that represents an object graph consisting of other classes, indicating a relationship between the root class and the referenced classes."", ""Class"")"
"To elaborate, in the example above, if the Pojo class contained fields of class Pojo2 and Pojo3 internally, these would be serialized too because they are part of an object graph rooted by a Pojo object.","(""Pojo"", ""Pojo2 is a field within the Pojo class, indicating a part of the object graph rooted by a Pojo object."", ""Pojo2""); (""Pojo"", ""Pojo3 is a field within the Pojo class, indicating a part of the object graph rooted by a Pojo object."", ""Pojo3"")"
The RionObjectWriter contains an writeAcyclic() and writeCyclic() method for these purposes.,"(""RionObjectWriter"", ""The method writeAcyclic is contained within the RionObjectWriter class."", ""writeAcyclic""); (""RionObjectWriter"", ""The method writeCyclic is contained within the RionObjectWriter class."", ""writeCyclic"")"
The RionObjectWriter writeAcyclic() can write an acyclic object graph as RION into a byte array.,"(""RionObjectWriter"", ""The method writeAcyclic is a function of the class RionObjectWriter."", ""writeAcyclic"")"
"If the object is part of a cyclic (not acyclic) object graph, the writeAcyclic() method will enter an infinite recursion and eventually crash.","(""writeAcyclic"", ""The writeAcyclic method is mentioned in the context of handling an object graph, indicating it operates on or is related to objects."", ""object"")"
Here is an example of writing an object using the RionObjectWriter writeAcyclic() method:,"(""RionObjectWriter"", ""The method writeAcyclic is a function of the RionObjectWriter class."", ""writeAcyclic"")"
The RionObjectWriter writeCyclic() method can write a cyclic object graph as RION to a byte array.,"(""RionObjectWriter"", ""The writeCyclic method is a part of the RionObjectWriter class."", ""writeCyclic""); (""writeCyclic"", ""The writeCyclic method writes a cyclic object graph as RION."", ""RION"")"
Here is an example of writing a cyclic object graph to RION using the RionObjectWriter writeCyclic() method.,"(""RionObjectWriter"", ""The writeCyclic method is a function of the RionObjectWriter class."", ""writeCyclic""); (""RION"", ""The RionObjectWriter class is used to write to the RION package."", ""RionObjectWriter"")"
"The RION Ops RionReader class, com.nanosai.rionops.rion.read.RionReader makes it easy to write RION fields from a Java byte array.","(""RionReader"", ""The RionReader class is part of the com.nanosai.rionops.rion.read.RionReader package"", ""com.nanosai.rionops.rion.read.RionReader"")"
Setting a source byte array is done via the method setSource().,"(""SetSource"", ""The method SetSource is used to set a source byte array."", ""Source Byte Array"")"
Here is an example of setting the source byte array on a RionReader via its setSource() method:,"(""RionReader"", ""The setSource method is used on the RionReader class to set the source byte array."", ""setSource"")"
"Third, the example loops as long as hasNext() returns true, and iterates through all the RION fields in the source byte array, one by one.","(""hasNext"", ""The method hasNext is used to iterate through all the fields of the RION class."", ""RION"")"
You can read a RION Bytes field using the RionReader readBytes() method.,"(""RionReader"", ""The readBytes method is a function of the RionReader class."", ""readBytes""); (""RION"", ""Bytes is a field type that can be read in the RION class."", ""Bytes"")"
The readBytes() method will read the bytes of the RION Bytes field into this byte array.,"(""ReadBytes"", ""The ReadBytes method reads the bytes of the RION Bytes class."", ""RION Bytes"")"
Here is an example of reading a RION Bytes field with the readBytes() method:,"(""RION Bytes"", ""The readBytes() method is used to read a field from the RION Bytes class."", ""readBytes"")"
The value returned by the readBytes() method is the number of bytes read into the destination byte array.,"(""readBytes"", ""The readBytes method returns the number of bytes read into the destination byte array."", ""number of bytes"")"
"The readBytes() method also comes in a version where you can specify the offset into the destination byte array to start writing the Bytes field value, and a maximal length (number of bytes) to read.","(""ReadBytes"", ""The ReadBytes method is used to read the Bytes field value."", ""Bytes"")"
Here is an example of reading a RION Bytes field using that readBytes() method:,"(""RION"", ""The readBytes method is used to read a field from the RION class."", ""readBytes""); (""Bytes"", ""The readBytes method is specifically used to read a Bytes field."", ""readBytes"")"
"This example tells the readBytes() method to start writing the Bytes field value into the destination array from offset 2, and to maximally read 10 bytes.","(""ReadBytes"", ""The ReadBytes method is used to write the Bytes field value into the destination array."", ""Bytes"")"
To read a RION Boolean field you can use the RionReader readBoolean() method.,"(""RionReader"", ""The readBoolean method is a function of the RionReader class."", ""readBoolean""); (""RION"", ""RION and Boolean are both classes mentioned in the context of reading fields."", ""Boolean"")"
Here is an example of reading RION Boolean field using the RionReader readBoolean() method:,"(""RionReader"", ""The readBoolean method is a function of the RionReader class."", ""readBoolean""); (""RION"", ""RION and Boolean are both mentioned as classes in the context of reading a field."", ""Boolean"")"
Here is an example of reading a Java Boolean object using the RionReader readBooleanObj() method:,"(""RionReader"", ""The readBooleanObj is a method of the RionReader class."", ""readBooleanObj""); (""Java Boolean"", ""The readBooleanObj method is used to read a Java Boolean object."", ""readBooleanObj"")"
To read a RION Int64 field you can use the RionReader readInt64() method.,"(""RionReader"", ""The readInt64 method is used by the RionReader class to read an Int64 field."", ""readInt64""); (""RION"", ""The Int64 field is a part of the RION class."", ""Int64"")"
Here is an example of reading a RION Int64 field using the RionReader readInt64() method:,"(""RionReader"", ""The readInt64() method is a function of the RionReader class."", ""readInt64""); (""RION"", ""The Int64 class is part of the RION package."", ""Int64""); (""RION"", ""The RionReader class is part of the RION package."", ""RionReader"")"
Here is an example of reading a RION Int64 field into a Java Long object using the RionReader readInt64Obj() method:,"(""RION"", ""RION is the package that contains the Int64 class."", ""Int64""); (""Java"", ""Java is the package that contains the Long class."", ""Long""); (""RionReader"", ""readInt64Obj is a method of the RionReader class."", ""readInt64Obj""); (""RionReader"", ""RionReader is used to read Int64 fields."", ""Int64""); (""readInt64Obj"", ""The readInt64Obj method is used to read Int64 fields."", ""Int64""); (""readInt64Obj"", ""The readInt64Obj method reads Int64 fields into a Long object."", ""Long"")"
These methods are named readFloat32() and readFloat64() Here are two examples of reading a RION Float field into a Java float and double variable:,"(""readFloat32"", ""The method readFloat32 is used to read a RION Float field."", ""RION""); (""readFloat64"", ""The method readFloat64 is used to read a RION Float field."", ""RION""); (""readFloat32"", ""The method readFloat32 reads a RION Float field into a Java float variable."", ""Java""); (""readFloat64"", ""The method readFloat64 reads a RION Float field into a Java double variable."", ""Java"")"
Use the readFloat32Obj() or readFloat64Obj() methods if the RION Float field can be set to null in your concrete use case.,"(""readFloat32Obj"", ""The method readFloat32Obj is related to the RION class as it is used to handle RION Float fields."", ""RION""); (""readFloat64Obj"", ""The method readFloat64Obj is related to the RION class as it is used to handle RION Float fields."", ""RION"")"
The RionReader class has a method named readUtf8String() which can read a RION UTF-8 field into a Java String.,"(""RionReader"", ""The method readUtf8String() is a part of the RionReader class."", ""readUtf8String""); (""readUtf8String"", ""The method readUtf8String() is used to read a RION UTF-8 field."", ""RION""); (""readUtf8String"", ""The method readUtf8String() reads data into a Java String."", ""String"")"
Here is an example of reading a RION UTF-8 field into a Java String with readUtf8String() :,"(""RION"", ""The method readUtf8String() is used to read a field from the RION package."", ""readUtf8String""); (""readUtf8String"", ""The method readUtf8String() reads a UTF-8 field."", ""UTF-8""); (""readUtf8String"", ""The method readUtf8String() converts the UTF-8 field into a Java String."", ""String""); (""Java"", ""String is a class in the Java package."", ""String"")"
The readUtcCalendar() method of the RionReader class can read a RION UTC field as a Java Calendar instance.,"(""ReadUtcCalendar"", ""The ReadUtcCalendar method belongs to the RionReader class."", ""RionReader"")"
When reading a composite RION field you need to use the RionReader moveInto() and moveOutOf() methods.,"(""RionReader"", ""The moveInto method is a part of the RionReader class, used for reading composite RION fields."", ""moveInto""); (""RionReader"", ""The moveOutOf method is a part of the RionReader class, used for reading composite RION fields."", ""moveOutOf"")"
"The moveInto() method will move the RionReader's internal state ""into"" the given RION field.","(""MoveInto"", ""The MoveInto method is a function that operates on the RionReader class, affecting its internal state."", ""RionReader""); (""RionReader"", ""The RionReader class is part of the Rion package, as indicated by its name."", ""Rion"")"
"That means, that the hasNext() method now returns true as long as the RION field you moved into has more nested fields.","(""HasNext"", ""The HasNext method is related to the RION class because it returns true when the RION field has more nested fields."", ""RION"")"
"The moveOutOf() method moves the RionReader's internal state ""out of"" the given RION field.","(""moveOutOf"", ""The moveOutOf method is a function that operates on the RionReader class, affecting its internal state."", ""RionReader"")"
Now the hasNext() method will return true if the parent scope (parent RION field or the total source byte array for the RionReader) has more RION fields.,"(""hasNext"", ""The hasNext method is used in the context of the RionReader to determine if there are more RION fields to read."", ""RionReader"")"
"At the outer nesting level (top level) of the above RION field sequence, the RionReader hasNext() will return true, as long as there are RION fields at this nesting level.","(""RionReader"", ""The method hasNext() is a function of the class RionReader, indicating that it is used to check for the presence of RION fields at a certain nesting level."", ""hasNext"")"
"Now the RionReader hasNext() method returns true 2 times, because there are 2 nested RION fields inside the RION Object field.","(""RionReader"", ""The hasNext method is a function of the RionReader class."", ""hasNext""); (""RION"", ""The RionReader class is likely part of the RION package."", ""RionReader"")"
"Once the hasNext() method returns false, you ""move out of"" the composite RION field again.","(""HasNext"", ""The HasNext method is used to iterate over elements, and once it returns false, it indicates that you have moved out of the composite RION field."", ""RION"")"
You can improve on the above code in various ways - e.g.,NULL
"To read a RION Table field, you have to ""move into"" it with moveInto(), then read the first field which is an Int64 RION field representing the row count, and then 1 to N Key or Key Short fields representing the column headers (column names / keys) of the table, and then finally 1 to N fields per row.","(""RION"", ""The Table class is part of the RION package, as it is referred to as a RION Table."", ""Table""); (""moveInto"", ""The moveInto method is used to interact with the Table class, as it is necessary to 'move into' the Table to read its fields."", ""Table""); (""Int64"", ""The Int64 class is used within the Table class to represent the row count, indicating a relationship between the two."", ""Table"")"
The RionReader class contains a method named isNull() which will tell you if the current RION field pointed to by the RionReader has the field value null.,"(""RionReader"", ""The isNull method is a function contained within the RionReader class."", ""isNull"")"
Here is an example of checking if a given RION field is null via the RionReader isNull() method:,"(""RionReader"", ""The isNull method is a function that belongs to the RionReader class, used to check if a RION field is null."", ""isNull"")"
"The RION Ops RionWriter class, com.nanosai.rionops.rion.write.RionWriter, enables you to write RION fields easily and efficiently.","(""RionWriter"", ""The RionWriter class is part of the com.nanosai.rionops.rion.write.RionWriter package."", ""com.nanosai.rionops.rion.write.RionWriter"")"
You set the destination byte array of the RionWriter using the setDestination() method.,"(""RionWriter"", ""The setDestination method is used to set the destination byte array for the RionWriter class."", ""setDestination"")"
The RionWriter contains a method named writeBytes() which can be used to write a RION Bytes field to the destination byte array.,"(""RionWriter"", ""The method writeBytes() is a part of the RionWriter class."", ""writeBytes""); (""writeBytes"", ""The method writeBytes() is used to write a RION Bytes field."", ""RION"")"
Here is a Java example of writing a RION Bytes field from a byte array using the RionWriter writeBytes() method:,"(""RionWriter"", ""The writeBytes method is a function of the RionWriter class."", ""writeBytes"")"
The writeBytes() method also exists in a version that takes a source offset and source length which specifies from what offset and how many bytes forward in the source byte array to write to the RION Bytes field in the destination byte array.,"(""WriteBytes"", ""The WriteBytes method writes to the RION Bytes field in the destination byte array."", ""RION Bytes"")"
The RionWriter method writeBoolean() writes a boolean value (true / false) as a RION Boolean field to the destination byte array.,"(""RionWriter"", ""The writeBoolean method is a part of the RionWriter method, indicating that it is a function or operation within RionWriter."", ""writeBoolean""); (""writeBoolean"", ""The writeBoolean method writes a boolean value as a RION Boolean field, indicating that it interacts with or manipulates RION data."", ""RION"")"
Here is a Java example of writing a RION Boolean field using the RionWriter writeBoolean() method:,"(""RionWriter"", ""The writeBoolean method is a function of the RionWriter class."", ""writeBoolean""); (""Java"", ""RION is a class used within the Java package."", ""RION""); (""Java"", ""RionWriter is a class used within the Java package."", ""RionWriter"")"
The RionWriter method writeInt64() will write a 64 bit integer as a RION IntPos or IntNeg field to the destination byte array.,"(""RionWriter"", ""The writeInt64 method is a part of the RionWriter class."", ""writeInt64""); (""writeInt64"", ""The writeInt64 method writes a 64-bit integer as a RION IntPos or IntNeg field."", ""RION"")"
"Here are two examples of writing int64 values (long values) as RION IntPos and IntNeg fields to the destination byte array, using the RionWriter writeInt64() method:","(""RionWriter"", ""The writeInt64 method is a function provided by the RionWriter class."", ""writeInt64""); (""RION"", ""The RionWriter class is part of the RION package."", ""RionWriter"")"
The RionWriter methods writeFloat32() and writeFloat64() writes a 32 bit and 64 bit floating point number as a RION Float field to the destination byte array.,"(""RionWriter"", ""The method writeFloat32() is a part of the RionWriter class."", ""writeFloat32""); (""RionWriter"", ""The method writeFloat64() is a part of the RionWriter class."", ""writeFloat64"")"
"Here are two examples of writing a 32 bit and 64 bit floating point number as RION Float fields to the destination byte array, using the RionWriter writeFloat32() and writeFloat64() methods:","(""RionWriter"", ""The writeFloat32 method is a function of the RionWriter class, used to write 32-bit floating point numbers."", ""writeFloat32""); (""RionWriter"", ""The writeFloat64 method is a function of the RionWriter class, used to write 64-bit floating point numbers."", ""writeFloat64"")"
The RionWriter method writeUtf8() writes a Java String as a RION UTF-8 or UTF-8-Short field to the destination byte array.,"(""RionWriter"", ""The writeUtf8 method is a function of the RionWriter class."", ""writeUtf8""); (""writeUtf8"", ""The writeUtf8 method writes a Java String as a RION UTF-8 or UTF-8-Short field."", ""RION"")"
Here is an example of writing a RION UTF-8 field to a byte array using the RionWriter writeUtf8() method:,"(""RionWriter"", ""The writeUtf8 method is a function of the RionWriter class, indicating that it is used to perform operations related to RionWriter."", ""writeUtf8"")"
The RionWriter method writeUtc() method writes a date and time in the shape of a Java Calendar as a RION UTC field (UTC date-time) to the destination byte array.,"(""RionWriter"", ""The writeUtc method is a function of the RionWriter class."", ""writeUtc""); (""Java"", ""Calendar is a class within the Java package."", ""Calendar""); (""RION"", ""The writeUtc method writes data in the RION format."", ""writeUtc"")"
Here is an example of writing a Java Calendar as a RION UTC field to the destination byte array using the RionWriter writeUtc() method:,"(""RionWriter"", ""The writeUtc method is a function provided by the RionWriter class."", ""writeUtc""); (""Java Calendar"", ""The Java Calendar is being written as a RION UTC field, indicating a transformation or usage relationship."", ""RION UTC""); (""writeUtc"", ""The writeUtc method is used to write data in the RION UTC format."", ""RION UTC"")"
The RionWriter class has functionality that helps you reserve length bytes for composite RION fields and jump back up and fill them in correctly later.,"(""RionWriter"", ""The RionWriter class has functionality to reserve length bytes for composite RION fields."", ""reserve length bytes""); (""RionWriter"", ""The RionWriter class can jump back up and fill in the reserved length bytes correctly later."", ""jump back up and fill them in"")"
One of the mechanisms in the RionWriter class that helps you reserve length bytes and set their value correctly later requires an internal stack to keep track of where the reserved length bytes are located.,"(""RionWriter"", ""The RionWriter class has a mechanism to reserve length bytes and set their value correctly."", ""length bytes"")"
Here is an example of setting the nested field stack for a RionWriter via its setNestedFieldStack() method:,"(""RionWriter"", ""The method setNestedFieldStack is a method of the class RionWriter, as indicated by the phrase 'via its setNestedFieldStack() method'."", ""setNestedFieldStack"")"
"However, it is possible for all RION fields to take the value null, so it is possible to include e.g.",NULL
"The writeObjectBeginPush() method writes the beginning of the RION Object field, and reserves and reserve as many length bytes as you pass to it as parameter (2 in the example above).","(""WRITEOBJECTBEGINPUSH"", ""The method WRITEOBJECTBEGINPUSH writes the beginning of the RION OBJECT FIELD."", ""RION OBJECT FIELD"")"
"The writeObjectEndPop() method pops the RION Object field start index off the nested field stack, calculates the total length of the Object field and writes the total Object field length into its reserved length bytes.","(""WRITEOBJECTENDPOP"", ""The WRITEOBJECTENDPOP method is associated with the RION class as it operates on RION Object fields."", ""RION"")"
There are also versions of the writeObjectBegin() and writeObjectEnd() method that does not use the internal nested field stack.,"(""WRITEOBJECTBEGIN"", ""Both are methods mentioned in the context of handling object writing operations."", ""WRITEOBJECTEND"")"
The String arguments passed to the main() method are the command line arguments passed to the application when it is executed.,"(""main()"", ""The main() method takes String arguments, indicating a relationship where String is used as a parameter type in the main() method."", ""String"")"
The Main argument is the name of the object to run the main() method of.,"(""Main"", ""The main() method is a function that is executed within the Main class."", ""main()"")"
"The arguments ""arg1"" and ""arg2"" are passed in the String array to the main() method.","(""Main"", ""The String array is passed as an argument to the main() method."", ""String"")"
The until keyword makes sure to only iterate until myArray.length - 1.,"(""until"", ""The 'until' keyword is used to iterate over 'myArray' until a certain condition is met."", ""myArray"")"
"If you had needed i to also take the value of myArray.length in the final iteration, you could have used the to keyword instead of the until keyword.","(""myArray"", ""The method 'length' is used to determine the size of the class 'myArray'."", ""length"")"
"This means that you can define classes in Scala, and instantiate objects of these classes.","(""Classes"", ""Objects are instances of classes"", ""Objects"")"
"That means, that a class defines what information objects of that class holds, and what behaviour (methods) it exposes.","(""Class"", ""Methods are behaviors that a class exposes."", ""Methods"")"
The other aspects of Scala classes will be covered in separate texts.,"(""Scala"", ""The text refers to aspects of Scala classes, indicating a relationship between Scala and classes."", ""classes"")"
Here I have just shown you how to declare a method inside a class.,"(""Method"", ""A method is declared inside a class, indicating a structural relationship between the two."", ""Class"")"
"Notice how this addToMyField() method does not have the equals sign, and no return type specified.","(""addToMyField"", ""The text explicitly refers to addToMyField as a method."", ""method"")"
"When an exception is thrown from inside the throwsException() method, the execution is interrupted and the execution jumps to the catch clause surrounding the code that threw the exception.","(""throwsException"", ""The throwsException method is related to the exception because it is the method from which the exception is thrown."", ""exception"")"
"In the example above, when the throwsException() method is called, and it throws an exception, the statement below the throwsException() method call is never executed.","(""throwsException"", ""The text describes the behavior of the throwsException method when it is called and throws an exception."", ""throwsException"")"
"In the example above, only one exception is caught, Exception which is the superclass of most exceptions.","(""Exception"", ""Exception is described as the superclass of most exceptions, indicating a hierarchical relationship."", ""Exception"")"
"Rather than compute the .toUpperCase() value twice, by nesting them inside each if-statement, the uppercase version of aString is computed just once, and assigned to the variable aStringUC.","(""TOUPPERCASE"", ""The method TOUPPERCASE is used to compute the uppercase version of the variable ASTRING, which is then assigned to the variable ASTRINGUC."", ""ASTRINGUC""); (""ASTRING"", ""The variable ASTRING is transformed to uppercase and the result is stored in the variable ASTRINGUC."", ""ASTRINGUC"")"
"You can thus use all the classes of the Java SDK's in Scala, and also your own, custom Java classes, or your favourite Java open source projects.","(""Java SDK"", ""Java SDK is a package that can be used in Scala."", ""Scala""); (""Java SDK"", ""Java SDK contains Java classes."", ""Java""); (""Java"", ""Java classes can be used in Scala."", ""Scala"")"
"Instead a Scala class can have what is called a singleton object, or sometime a companion object.","(""Scala"", ""A Scala class can have a singleton object, indicating a relationship between them."", ""singleton object""); (""Scala"", ""A Scala class can have a companion object, indicating a relationship between them."", ""companion object"")"
"When a singleton object is named the same as a class, it is called a companion object.","(""Singleton Object"", ""A singleton object named the same as a class is referred to as a companion object."", ""Companion Object"")"
A companion object must be defined inside the same source file as the class.,"(""Companion Object"", ""A companion object is defined inside the same source file as the class."", ""Class""); (""Source File"", ""The source file contains the class definition."", ""Class"")"
"In this class you can both instantiate Main and call sayHelloWorld() or call the sayHi() method on the companion object directly, like this:","(""Main"", ""The method sayHelloWorld() can be called on an instance of the Main class."", ""sayHelloWorld""); (""Main"", ""The method sayHi() can be called on the companion object of the Main class."", ""sayHi"")"
This also means that you can use all Java classes in your Scala code.,"(""Java"", ""Java classes can be used within Scala code, indicating interoperability between the two."", ""Scala"")"
The Scala version used in the examples in this tutorial is Scala 2.8.0 .,"(""Scala"", ""Scala 2.8.0 is a specific version of the Scala package"", ""Scala 2.8.0"")"
"The Stream Ops StreamOps class, com.nanosai.streamops.StreamOps, provides a convenient facade for the Stream Ops API.","(""StreamOps"", ""The StreamOps class is part of the com.nanosai.streamops.StreamOps package."", ""com.nanosai.streamops.StreamOps""); (""StreamOps"", ""The StreamOps class provides a facade for the Stream Ops API."", ""Stream Ops API"")"
The StreamOps class can create the most commonly used components of the Stream Ops API.,"(""StreamOps"", ""The StreamOps class is part of the Stream Ops API, as it creates components for it."", ""Stream Ops API"")"
"Thus, the StreamOps class is a good place to start, both when using Stream Ops, but also when exploring what you can do with Stream Ops and how it works.","(""StreamOps"", ""Stream Ops is mentioned as a context where the StreamOps class is used and explored."", ""Stream Ops"")"
In this tutorial we will only go over the components the StreamOps and related factory classes can create.,"(""StreamOps"", ""StreamOps is related to factory as it can create components using factory classes."", ""factory"")"
"You can create instances of these classes via the new operator, or you can use a StreamStorageFactory.","(""StreamStorageFactory"", ""The new operator is used to create instances of the StreamStorageFactory class."", ""new operator"")"
You can create a StreamStorageFS instance via the StreamStorageFactory createStreamStorageFS() method.,"(""StreamStorageFactory"", ""The createStreamStorageFS method is a part of the StreamStorageFactory class."", ""createStreamStorageFS""); (""createStreamStorageFS"", ""The createStreamStorageFS method is used to create an instance of the StreamStorageFS class."", ""StreamStorageFS"")"
Here is an example of creating a StreamStorageFS instance via the createStreamStorageFS() method:,"(""createStreamStorageFS"", ""The method createStreamStorageFS is used to create an instance of the class StreamStorageFS."", ""StreamStorageFS"")"
You can create a StreamStorageRootFS instance via the StreamStorageFactory createStreamStorageRootFS() method.,"(""StreamStorageFactory"", ""The createStreamStorageRootFS method is a part of the StreamStorageFactory class."", ""createStreamStorageRootFS""); (""createStreamStorageRootFS"", ""The createStreamStorageRootFS method is used to create an instance of the StreamStorageRootFS class."", ""StreamStorageRootFS"")"
"The Stream Ops StreamStorageFS class, com.nanosai.streamops.storage.file.StreamStorageFS, provides disk storage for a data stream.","(""Stream Ops StreamStorageFS"", ""The class Stream Ops StreamStorageFS is part of the package com.nanosai.streamops.storage.file.StreamStorageFS."", ""com.nanosai.streamops.storage.file.StreamStorageFS"")"
"More specifically, the StreamStorageFS class can write an ordered sequence of records to disk, and later read the records from disk again in the exact same order.","(""StreamStorageFS"", ""The StreamStorageFS class is responsible for writing an ordered sequence of records to disk."", ""write""); (""StreamStorageFS"", ""The StreamStorageFS class is responsible for reading the records from disk in the exact same order."", ""read"")"
The StreamStorageFS class is one of the core classes of the Stream Ops data storage engine.,"(""StreamStorageFS"", ""The StreamStorageFS class is part of the Stream Ops data storage engine, indicating it belongs to the Stream Ops package."", ""Stream Ops"")"
Many of the other classes in the Stream Ops data storage engine revolve around this class.,"(""Stream Ops"", ""The Stream Ops class is part of the data storage engine, indicating a functional relationship."", ""data storage engine"")"
To use the StreamStorageFS class you must first create a StreamStorageFS instance.,"(""StreamStorageFS"", ""The StreamStorageFS class is used to create a StreamStorageFS instance."", ""StreamStorageFS"")"
"Once a StreamStorageFS instance is open for appending records, you can append a record to the stream via the append() method.","(""StreamStorageFS"", ""The append method is used to append a record to the stream of a StreamStorageFS instance."", ""append"")"
You can obtain a list of StreamStorageBlockFS instances from a StreamStorageFS by calling getStorageBlocks().,"(""StreamStorageFS"", ""StreamStorageFS provides instances of StreamStorageBlockFS"", ""StreamStorageBlockFS""); (""getStorageBlocks"", ""getStorageBlocks is a method of StreamStorageFS"", ""StreamStorageFS"")"
The StreamStorageFS class contains a method to read bytes from a stream block file.,"(""StreamStorageFS"", ""The method 'read' is contained within the 'StreamStorageFS' class."", ""read"")"
"The readBytes() method reads bytes from the file represented by the given StreamStorageBlockFS instance, into the byte[] array passed as parameter.","(""ReadBytes"", ""The ReadBytes method reads bytes from a file represented by an instance of the StreamStorageBlockFS class."", ""StreamStorageBlockFS""); (""ReadBytes"", ""The ReadBytes method reads bytes into the Byte[] array passed as a parameter."", ""Byte[]"")"
The readBytes() method will start fromByte bytes into the block file.,"(""readBytes"", ""The readBytes method operates on the block file by reading bytes from it."", ""block file"")"
The Stream Ops for Java class named StreamStorageRootFS (com.nanosai.streamops.engine.storage.file.StreamStorageRootFS) class represents the root of a file based stream storage system.,"(""StreamStorageRootFS"", ""The class StreamStorageRootFS is part of the package com.nanosai.streamops.engine.storage.file.StreamStorageRootFS."", ""com.nanosai.streamops.engine.storage.file.StreamStorageRootFS"")"
You can always obtain the root directory path a StreamStorageRootFS was created with via its getRootDirPath() method.,"(""StreamStorageRootFS"", ""The getRootDirPath method is associated with the StreamStorageRootFS class as it is a method that can be called on instances of this class."", ""getRootDirPath"")"
Here is an example of obtaining the root directory path of a StreamStorageRootFS via its getRootDirPath() method:,"(""StreamStorageRootFS"", ""The method getRootDirPath is used to obtain the root directory path of the StreamStorageRootFS class."", ""getRootDirPath"")"
"When you write records to a stream via the StreamStorageFS instance, the StreamStorageFS class will divide the records into multiple files.","(""StreamStorageFS"", ""The StreamStorageFS instance is an instance of the StreamStorageFS class."", ""StreamStorageFS""); (""StreamStorageFS"", ""The StreamStorageFS class is responsible for dividing records into multiple files when written to a stream."", ""StreamStorageFS"")"
Creating a Buffer is done using the static buffer() method in the Buffer interface.,"(""Buffer"", ""The buffer method is a static method used to create a Buffer."", ""buffer""); (""Buffer"", ""The buffer method is part of the Buffer interface."", ""Buffer"")"
If you want the bytes stored in the Buffer to be encoded using a special encoding (e.g.,"(""Buffer"", ""class"")"
"you can specify the encoding as the second parameter to the buffer() method, like this:","(""BUFFER"", ""The BUFFER method can take ENCODING as its second parameter."", ""ENCODING"")"
You can read the length of a Buffer using its length() method.,"(""Buffer"", ""The length method is used to read the length of a Buffer class."", ""length"")"
You can write to a specific position inside a buffer using one of the set...() methods.,"(""Buffer"", ""The Set...() methods are used to write to a specific position inside a Buffer."", ""Set...()"")"
You can also write data to a Buffer using one of the append...() methods.,"(""Buffer"", ""The append...() methods are used to write data to the Buffer class."", ""append...()"")"
You can read the data stored in a Buffer using the many get...() methods.,"(""Buffer"", ""The get...() methods are used to read data stored in a Buffer class."", ""get...() methods"")"
After the vertx run part of the command you must write the fully qualified class name of the verticle to deploy.,"(""VERTX"", ""The method 'RUN' is part of the 'VERTX' package."", ""RUN""); (""VERTICLE"", ""The 'RUN' method is used to deploy the 'VERTICLE' class."", ""RUN"")"
To deploy a verticle class you must run the vertx run classname command from the root directory of the compiled classes for the verticle to deploy.,"(""Verticle"", ""The Verticle class is deployed using the Vertx package, as indicated by the command 'vertx run classname'."", ""Vertx"")"
"Thus, the root directory of your classes becomes the classpath for deploying the verticle.","(""Root Directory"", ""The root directory is used as the classpath for deploying the verticle."", ""Classpath""); (""Classpath"", ""The classpath is used for deploying the verticle."", ""Verticle"")"
Whatever directory you run the vertx run command from is automatically added to the classpath when looking for the verticle class.,NULL
You can also run a Java verticle class which is located inside a JAR file.,"(""Java Verticle"", ""The Java Verticle class is located inside the JAR package."", ""JAR"")"
Sometimes you need a classpath which contains more than one directory or JAR file.,"(""CLASSPATH"", ""A classpath can contain one or more directories."", ""DIRECTORY""); (""CLASSPATH"", ""A classpath can contain one or more JAR files."", ""JAR FILE"")"
In those situations you can provide a normal classpath string as the -cp argument value.,"(""Classpath"", ""Classpath is provided as the -cp argument value"", ""Argument"")"
Each entry (directory or JAR file) in the classpath string must be separated by either a semicolon (on Windows) or a colon (on Unix / Linux).,NULL
This example contains two JAR files in the classpath separated by a semicolon.,"(""JAR"", ""JAR files are included in the classpath for execution or compilation purposes"", ""classpath"")"
"If you have a very long classpath your command line may get very long, and thus be hard to read in a text editor.","(""CLASSPATH"", ""CLASSPATH is mentioned as a part of the COMMAND LINE, indicating a relationship where the classpath is included in the command line."", ""COMMAND LINE""); (""COMMAND LINE"", ""COMMAND LINE is described as being hard to read in a TEXT EDITOR, suggesting a relationship where the command line is viewed or edited using a text editor."", ""TEXT EDITOR"")"
"Instead you can build the classpath up as an environment variable, one entry per line, and use that environment variable in the command line.","(""CLASSPATH"", ""The CLASSPATH environment variable is used in the command line to build the classpath."", ""COMMAND LINE"")"
run.cmd and you can execute it from a Windows command line.,NULL
Notice the use of / as directory separator and the use of : as classpath entry separator.,"(""classpath"", ""The classpath is related to the directory as it uses '/' as a directory separator."", ""directory""); (""classpath"", ""The classpath is related to the entry as it uses ':' as a classpath entry separator."", ""entry"")"
That might be useful if you deploy a class file that is written in Groovy or Scala (but which are compiled into Java classes).,"(""Groovy"", ""Groovy is compiled into Java classes."", ""Java""); (""Scala"", ""Scala is compiled into Java classes."", ""Java"")"
The first parameter to the getNow() method is the TCP port to connect to the remote HTTP server on.,"(""getNow"", ""The getNow method uses TCP as a parameter, indicating a connection to a remote server."", ""TCP""); (""getNow"", ""The getNow method connects to a remote HTTP server, as indicated by the context."", ""HTTP"")"
The getNow() method exists in a version where you can leave the port out.,"(""GetNow"", ""The text explicitly mentions 'getNow()' as a method."", ""Method"")"
The second parameter to the getNow() method is the domain name of the remote HTTP server to connect to.,"(""getNow"", ""The getNow method connects to a remote HTTP server, indicating a relationship between the method and the HTTP protocol."", ""HTTP"")"
The third parameter to the getNow() method is the URI to the resource to retrieve.,"(""GetNow"", ""The GetNow method uses the Uri class as its third parameter to specify the resource to retrieve."", ""Uri"")"
The Handler implementation passed to the getNow() method is called when the headers of the HTTP response are received.,"(""getNow"", ""The getNow method uses the Handler class to process the headers of the HTTP response."", ""Handler""); (""HTTP"", ""The getNow method is related to the HTTP package as it deals with HTTP response headers."", ""getNow"")"
"However, if you do need to access the body of the HTTP response, you need to register another handler on the HttpClientResponse that is passed as parameter to the first Handler's handle() method.","(""HttpClientResponse"", ""HttpClientResponse is passed as a parameter to the Handler's handle() method."", ""Handler""); (""Handler"", ""handle is a method of the Handler class."", ""handle"")"
The Handler implementation passed to the bodyHandler() method of the HttpClientResponse is called when the full HTTP response body is received.,"(""bodyHandler"", ""The bodyHandler method is associated with the HttpClientResponse class as it is a method that operates on the response."", ""HttpClientResponse""); (""Handler"", ""The Handler class is related to the bodyHandler method as it is the implementation passed to this method."", ""bodyHandler"")"
"Once you have created the HTTP server, you can start it using its listen() method.","(""HTTP Server"", ""The listen() method is used to start the HTTP Server."", ""listen()"")"
"The HttpServer class has more versions of the listen() method too, which gives you different options for starting the HTTP server.","(""HttpServer"", ""The listen() method is a function of the HttpServer class, providing options for starting the HTTP server."", ""listen()"")"
"Every time an HTTP request arrives at the HTTP server, the handle() method of the Handler object is called.","(""handle"", ""The handle() method is a function of the Handler class."", ""Handler""); (""HTTP"", ""The handle() method is invoked when an HTTP request arrives at the server."", ""handle"")"
Inside the handle() method you can execute the code needed to handle the HTTP request.,"(""Handle"", ""The handle method is used to process or manage the HTTP request."", ""HTTP Request"")"
You can access HTTP headers and parameters from the HttpServerRequest object passed as parameter to the handle() method.,"(""HttpServerRequest"", ""The HttpServerRequest object is passed as a parameter to the handle() method."", ""handle"")"
"After writing the headers back you can write the response body back via the write() method, like this:","(""WRITE"", ""The write() method is used to write the response body back."", ""RESPONSE BODY"")"
You can call write() multiple times to add more data to the response body.,"(""write"", ""The method 'write' is used to add data to the response body."", ""response body"")"
The write() method is asynchronous and returns immediately after queuing up the string or buffer.,"(""Write"", ""The Write method is described as being asynchronous in its operation."", ""Asynchronous""); (""Write"", ""The Write method returns immediately after queuing up the string or buffer."", ""Returns"")"
This is done by calling the end() method as shown in the previous example.,"(""END"", ""The text refers to calling the end() method, indicating that 'end' is a method."", ""METHOD"")"
The end() method can take either a String or Buffer as parameter.,"(""END"", ""The end() method can take a String as a parameter."", ""STRING""); (""END"", ""The end() method can take a Buffer as a parameter."", ""BUFFER"")"
To close an HTTP server you simply call its close() method like this:,"(""HTTP Server"", ""The close method is used to close an instance of the HTTP Server class."", ""close"")"
"The close() method executes asynchronously, so the HTTP server may not be fully closed by the time the close() method returns.","(""Close"", ""The close() method is used to close the HTTP server."", ""Http Server"")"
"You can pass a close handler as parameter to the close() method, to be notified when the HTTP server is fully closed.","(""Close()"", ""The close() method can take a close handler as a parameter, indicating a relationship where the method utilizes the handler."", ""Close Handler""); (""Close()"", ""The close() method is related to the HTTP server as it is used to notify when the server is fully closed."", ""HTTP Server"")"
"You can just unzip the zip file and add these JAR files to the classpath of your Java application, and you are good to go.","(""Java"", ""Java is a programming language, and classpath is a parameter that tells the Java Virtual Machine or the Java compiler where to look for user-defined classes and packages."", ""classpath"")"
As long as the JAR files are available on the classpath of your application.,"(""JAR"", ""JAR files need to be available on the classpath for the application to function properly"", ""classpath"")"
You connect to a remote server by calling the connect() method.,"(""Connect"", ""method"")"
You obtain a reference to the NetSocket connected to the remote server via the AsyncResult instance passed to the handler's handle() method.,"(""AsyncResult"", ""The AsyncResult instance is passed to the handle() method."", ""handle""); (""NetSocket"", ""The NetSocket is connected to the remote server via the AsyncResult instance."", ""AsyncResult"")"
You can write data to the TCP connection via the NetSocket write() method.,"(""NetSocket"", ""The write() method is a function of the NetSocket class, allowing data to be written to a TCP connection."", ""write""); (""NetSocket"", ""NetSocket is used to manage TCP connections, indicating a relationship between the class and the package."", ""TCP"")"
The data may not be sent by the time the write() method returns.,"(""WRITE"", ""The term 'write()' refers to a method, indicating a relationship where 'write' is the name of the method."", ""METHOD"")"
The Handler's handle() method will get called when data is received from the remote server.,"(""Handler"", ""The handle method belongs to the Handler class."", ""handle"")"
You close the TCP client by calling the close() method of the NetClient instance.,"(""close"", ""The close method is called on the NetClient instance to close the TCP client."", ""NetClient""); (""TCP Client"", ""The TCP client is an instance of the NetClient class."", ""NetClient"")"
"Again, the NetClient's close() method is asynchronous, so the underlying TCP connection may not yet be closed by the time the close() method returns.","(""NetClient"", ""The close method is a part of the NetClient class, indicating that it is a method belonging to this class."", ""close""); (""close"", ""The close method is related to the TCP package as it deals with closing a TCP connection."", ""TCP"")"
"Once you have created the TCP server, you can start it using its listen() method.","(""TCP Server"", ""The listen method is used to start the TCP Server."", ""listen"")"
This example starts the server and instructs it to listen on TCP port 10.000 .,"(""Server"", ""The server is instructed to listen on a TCP port, indicating a relationship between the server class and the TCP package."", ""TCP"")"
The NetServer class contains more versions of the listen() method which gives you different options for starting the TCP server.,"(""NetServer"", ""The listen() method is a function within the NetServer class, providing options for starting the TCP server."", ""listen"")"
The handle() method of the connect handler is called whenever a new TCP connection is created by a client of the TCP server.,"(""Handle"", ""The handle() method is a function within the Connect Handler class."", ""Connect Handler""); (""Connect Handler"", ""The Connect Handler class is used by the TCP Server to manage new connections."", ""TCP Server"")"
The NetSocket object passed as parameter to the handle() method gives access to the incoming connection (socket etc.,"(""NetSocket"", ""The NetSocket class is passed as a parameter to the handle method, indicating a relationship where the method utilizes the class."", ""handle"")"
You can do so via the NetSocket instance passed to the connect handler's handle() method.,"(""NetSocket"", ""The NetSocket class is used in the connect handler method."", ""connect handler""); (""connect handler"", ""The connect handler method uses the handle method."", ""handle"")"
The NetSocket class contains more versions of the write() method which enables you to write e.g.,"(""NetSocket"", ""The write method is a function within the NetSocket class."", ""write"")"
When you are finished with the TCP server you can close it using its close() method.,"(""TCP Server"", ""The Close method is used to close the TCP Server."", ""Close"")"
"Closing the TCP server is an asynchronous actions, so the close() method may exit before the TCP server is actually closed.","(""TCP Server"", ""The close() method is used to close the TCP server."", ""close()"")"
"If you need to be notified of when the TCP server has shut down, you can pass a Handler to the close() method.","(""TCP Server"", ""The close() method is used to shut down the TCP server."", ""close""); (""Handler"", ""A Handler can be passed to the close() method to receive notifications when the TCP server shuts down."", ""close"")"
"The setTimer() method takes a time interval in milliseconds as first parameter, and a Handler implementation as second parameter.","(""SetTimer"", ""The SetTimer method requires a Handler implementation as its second parameter, indicating a relationship between the method and the class."", ""Handler"")"
The Handler's handle() method is called when the time interval has elapsed.,"(""Handler"", ""The handle() method belongs to the Handler class."", ""handle"")"
This timer ID is also passed as parameter to the Handler's handle() method.,"(""Handler"", ""The handle method belongs to the Handler class."", ""handle""); (""Timer ID"", ""The Timer ID is passed as a parameter to the handle method."", ""handle"")"
"The setPeriodic() method takes a time interval in milliseconds as first parameter, and a Handler implementation as second parameter.","(""setPeriodic"", ""The setPeriodic method takes a Handler implementation as its second parameter, indicating a relationship where the method utilizes the class."", ""Handler"")"
The Handler's handle() method is called every time the time interval has elapsed.,"(""Handler"", ""The handle method belongs to the Handler class."", ""handle"")"
This timer ID is also passed to the Handler's handle() method whenever it is called.,"(""Timer ID"", ""The Timer ID is passed to the handle() method whenever it is called, indicating a functional relationship."", ""handle""); (""Handler"", ""The handle() method is associated with the Handler class, suggesting it is a method belonging to this class."", ""handle"")"
Support for Scala and Clojure should be arriving soon (it was originally planned for v. 3.0 but I am not sure if they got it in).,"(""Scala"", ""class""); (""Clojure"", ""class"")"
You don't have to learn both a language and a new platform (e.g.,NULL
You will see later in this tutorial how to use both versions of the start() method.,"(""Start"", ""The text refers to the 'start()' as a method, indicating that 'Start' is a method entity."", ""Method"")"
Here is an example of overriding the stop() method in your own verticle:,"(""stop"", ""The stop method is being overridden in the verticle, indicating a relationship between the method and the class."", ""verticle"")"
Sending messages via the event bus can be done via either the send() or publish() method on the event bus.,"(""Send"", ""The Send method is used on the Event Bus to send messages."", ""Event Bus""); (""Publish"", ""The Publish method is used on the Event Bus to publish messages."", ""Event Bus"")"
The send() method sends the message to just one of the listening verticles.,"(""Send"", ""The Send method is responsible for sending the message."", ""Message""); (""Send"", ""The Send method sends the message to one of the listening verticles."", ""Verticles"")"
This is useful for distributing work load over multiple verticles (e.g.,NULL
"The first message is sent via the publish() method, so both consumers receive the message.","(""Publish"", ""The publish() method is used to send messages to consumers."", ""Consumers"")"
"The second message is sent via the send() method, so only one of the consumers will receive the message.","(""Send"", ""The send() method is used to send messages to consumers."", ""Consumers"")"
A verticle has a start() and a stop() method which are called when the verticle is deployed and when it is undeployed.,"(""Verticle"", ""The Start method is called when the Verticle is deployed, indicating a lifecycle relationship."", ""Start""); (""Verticle"", ""The Stop method is called when the Verticle is undeployed, indicating a lifecycle relationship."", ""Stop"")"
"You should perform any necessary initialization work inside the start() method, and any necessary cleanup work inside the stop() method.","(""Start"", ""Both methods are related as they are used for initialization and cleanup work respectively."", ""Stop"")"
"For instance, you can specify how many verticle instances of a given verticle class to deploy.","(""Verticle"", ""The text refers to deploying instances of a given verticle class, indicating a relationship between the concept of verticle and the class entity."", ""Verticle"")"
The startsWith() and endsWith() methods check if the String starts with a certain substring,"(""STARTSWITH"", ""The STARTSWITH method is used to check if a STRING starts with a certain substring."", ""STRING""); (""ENDSWITH"", ""The ENDSWITH method is used to check if a STRING ends with a certain substring."", ""STRING"")"
In the above example the two methods getTime() and setTime() can access the time member variable,"(""getTime"", ""Both methods are related as they can access the same member variable 'time'."", ""setTime""); (""setTime"", ""Both methods are related as they can access the same member variable 'time'."", ""getTime"")"
The convertToInt() method has the same signature as the deserialize() method of the Deserializer deserialize() method,"(""ConvertToInt"", ""Both are methods mentioned in the text, indicating they might be related in functionality or usage."", ""Deserialize""); (""Deserialize"", ""The Deserialize method is part of the Deserializer class, as indicated by the text."", ""Deserializer"")"
Deque.removeLast() is different from pollLast() which returns null if the Deque is empty,"(""Deque"", ""The method removeLast is a member of the class Deque"", ""removeLast""); (""Deque"", ""The method pollLast is a member of the class Deque"", ""pollLast""); (""removeLast"", ""Both removeLast and pollLast are methods of the class Deque and are compared in terms of their behavior when the Deque is empty"", ""pollLast"")"
The floor() method does the opposite of the ceiling() method meaning it returns the greatest element that is less than or equal to the given parameter value,"(""Floor"", ""The Floor method is related to the Ceiling method as they perform opposite operations in terms of rounding values."", ""Ceiling"")"
You can also specify METHOD or FIELD or you can leave the target out alltogether so the annotation can be used for both classes methods and fields,"(""METHOD"", ""METHOD is related to METHODS as they both refer to the same type of entity, indicating a plural form relationship."", ""METHODS""); (""FIELD"", ""FIELD is related to FIELDS as they both refer to the same type of entity, indicating a plural form relationship."", ""FIELDS""); (""CLASSES"", ""CLASSES and METHODS are related as they are both types of entities that can be annotated."", ""METHODS""); (""CLASSES"", ""CLASSES and FIELDS are related as they are both types of entities that can be annotated."", ""FIELDS""); (""METHODS"", ""METHODS and FIELDS are related as they are both types of entities that can be annotated."", ""FIELDS"")"
For instance finest() finer() fine() info() warning() and severe() each corresponds to one of the log levels,"(""finest"", ""The method 'finest' corresponds to a log level."", ""log levels""); (""finer"", ""The method 'finer' corresponds to a log level."", ""log levels""); (""fine"", ""The method 'fine' corresponds to a log level."", ""log levels""); (""info"", ""The method 'info' corresponds to a log level."", ""log levels""); (""warning"", ""The method 'warning' corresponds to a log level."", ""log levels""); (""severe"", ""The method 'severe' corresponds to a log level."", ""log levels"")"
You can encrypt or decrypt data into an existing byte array by passing the destination byte array as parameter to the update() and or doFinal() method,"(""Update"", ""Both are methods used for processing data in cryptographic operations"", ""DoFinal"")"
Second if the lock is locked the threads are blocked in the wait() call inside the while(isLocked) loop in the lock() method,"(""Lock"", ""The Wait method is called when the Lock is locked, causing threads to be blocked."", ""Wait""); (""Lock"", ""The IsLocked method is used within the Lock class to check the lock status."", ""IsLocked""); (""Lock"", ""The Lock method is part of the Lock class, used to initiate the locking process."", ""Lock"")"
Deque.removeFirst() is different from pollFirst() which returns null if the Deque is empty,"(""Deque"", ""The method removeFirst is a member of the class Deque"", ""removeFirst""); (""Deque"", ""The method pollFirst is a member of the class Deque"", ""pollFirst""); (""removeFirst"", ""Both removeFirst and pollFirst are methods of the class Deque and are compared in terms of their behavior when the Deque is empty"", ""pollFirst"")"
The peek() works like the element() method except it does not throw an exception if the Queue is empty,"(""PEEK"", ""The PEEK method works like the ELEMENT method, indicating a functional similarity or equivalence."", ""ELEMENT""); (""PEEK"", ""The PEEK method is used in the context of a QUEUE, as it checks elements within it."", ""QUEUE""); (""ELEMENT"", ""The ELEMENT method is used in the context of a QUEUE, as it retrieves elements from it."", ""QUEUE"")"
The addAll() method takes a Collection as parameter so you can pass either a List or Java Set as parameter,"(""AddAll"", ""The AddAll method takes a Collection as a parameter."", ""Collection""); (""Collection"", ""A List can be passed as a parameter to the Collection class."", ""List""); (""Collection"", ""A Java Set can be passed as a parameter to the Collection class."", ""Java Set"")"
The Java Properties class java.util.Properties is like a Java Map of Java String key and value pairs,"(""Properties"", ""The Properties class is part of the java.util.Properties package."", ""java.util.Properties""); (""Properties"", ""The Properties class is described as being like a Map."", ""Map""); (""Properties"", ""The Properties class uses String for key and value pairs."", ""String""); (""Map"", ""The Map is described as containing String key and value pairs."", ""String"")"
java.io.InputStream means that you use the Java FileInputStream as an InputStream (FileInputStream behaves like an InputStream),"(""Java FileInputStream"", ""Java FileInputStream is used as an InputStream, indicating a relationship where FileInputStream behaves like an InputStream."", ""Java.io.InputStream""); (""Java.io.InputStream"", ""Java.io.InputStream is the type that Java FileInputStream is used as, showing a relationship where InputStream is the expected interface."", ""Java FileInputStream"")"
Since PipedInputStream is a subclass of InputStream PipedInputStream has the same basic methods and use patterns as an InputStream,"(""PipedInputStream"", ""PipedInputStream is a subclass of InputStream, indicating an inheritance relationship."", ""InputStream"")"
Choice.select(int pos) is done by having a different thread call the Selector.wakeup() method on the Selector which the first thread has called select() on,"(""Choice"", ""The select method is associated with the Choice class, indicating that it is a method belonging to or used by this class."", ""select""); (""Selector"", ""The wakeup method is associated with the Selector class, indicating that it is a method belonging to or used by this class."", ""wakeup""); (""Selector"", ""The select method is called on the Selector class, indicating a relationship where Selector is the class that utilizes or contains the select method."", ""select"")"
While isLocked is true the thread calling lock() is parked waiting in the wait() call,"(""isLocked"", ""The lock() method is related to the isLocked class because it checks the state of isLocked to determine if the thread should be parked."", ""lock""); (""lock"", ""The lock() method is related to the wait() method because it uses wait() to park the thread when isLocked is true."", ""wait""); (""isLocked"", ""The wait() method is related to the isLocked class because it is used to park the thread when isLocked is true."", ""wait"")"
The AtomicInteger class is located in the java.util.concurrent.atomic package so the full class name is java.util.concurrent.atomic.AtomicInteger,"(""AtomicInteger"", ""The AtomicInteger class is part of the java.util.concurrent.atomic package, indicating its location within the package structure."", ""java.util.concurrent.atomic"")"
But no thread can actually execute unlock() until the thread waiting in lock() leaves the outer synchronized block,"(""UNLOCK"", ""The method UNLOCK is related to the method LOCK because UNLOCK cannot execute until the thread waiting in LOCK leaves the synchronized block."", ""LOCK"")"
The System class also has a getProperty() and setProperty() method which are shortcuts to the Properties getProperty() and setProperty() methods of the System Properties instance.,"(""System"", ""The getProperty method is associated with the System class as a shortcut method."", ""getProperty""); (""System"", ""The setProperty method is associated with the System class as a shortcut method."", ""setProperty""); (""Properties"", ""The getProperty method is associated with the Properties class as a method of the System Properties instance."", ""getProperty""); (""Properties"", ""The setProperty method is associated with the Properties class as a method of the System Properties instance."", ""setProperty""); (""System Properties"", ""System Properties is an instance of the Properties class."", ""Properties"")"
Closeable.close() closes the Selector and invalidates all SelectionKey instances registered with this Selector,"(""close"", ""The method 'close' is responsible for closing the 'Selector'."", ""Selector""); (""Selector"", ""The 'Selector' is associated with 'SelectionKey' instances, which are invalidated when the 'Selector' is closed."", ""SelectionKey"")"
Any.stream() is similar to how you obtain an Iterator by calling the items.iterator() method but a Stream is a different animal than an Iterator,"(""Any"", ""The method 'stream()' is associated with the class 'Any'."", ""stream""); (""items"", ""The method 'iterator()' is associated with the class 'items'."", ""iterator""); (""Stream"", ""The text compares 'Stream' and 'Iterator', indicating a conceptual relationship between the two classes."", ""Iterator""); (""stream"", ""The text describes 'stream()' and 'iterator()' as similar methods for obtaining different types of objects."", ""iterator"")"
An interesting aspect to note about the BufferedInputStream is that is supports the mark() and reset() methods inherited from the InputStream,"(""BufferedInputStream"", ""The method 'mark' is supported by the class 'BufferedInputStream'."", ""mark""); (""BufferedInputStream"", ""The method 'reset' is supported by the class 'BufferedInputStream'."", ""reset""); (""BufferedInputStream"", ""The class 'BufferedInputStream' inherits methods from the class 'InputStream'."", ""InputStream"")"
"You can search for an object on the stack to get it's index, using the search() method. The object's equals() method is called on every object on the Stack to determine if the searched-for object is present on the Stack.","(""Search"", ""The search() method is used to find an object within the Stack class."", ""Stack""); (""Equals"", ""The equals() method is called on objects within the Stack class to determine equality."", ""Stack"")"
Actually java.sql.Timestamp extends java.util.Date so anything you can do with a java.util.Date you can also do with a java.sql.Timestamp,"(""Java.sql.Timestamp"", ""Java.sql.Timestamp extends Java.util.Date, indicating an inheritance relationship where Timestamp is a subclass of Date."", ""Java.util.Date"")"
"If the Deque is empty, removeFirst() will throw an exception. This is different from pollFirst() which returns null if the Deque is empty.","(""removeFirst"", ""The method removeFirst is associated with the class Deque as it operates on it."", ""Deque""); (""pollFirst"", ""The method pollFirst is associated with the class Deque as it operates on it."", ""Deque"")"
You read bytes from a Java ByteArrayInputStream just like you would from a regular InputStream via its read() method,"(""ByteArrayInputStream"", ""ByteArrayInputStream is a type of InputStream, indicating a class hierarchy relationship."", ""InputStream""); (""InputStream"", ""InputStream uses the read() method to read bytes, indicating a functional relationship."", ""read"")"
You create a DateFormat using the getDateInstance() and getTimeInstance() method of the DateFormat class,"(""getDateInstance"", ""The getDateInstance method is used to create a DateFormat, indicating it is a method of the DateFormat class."", ""DateFormat""); (""getTimeInstance"", ""The getTimeInstance method is used to create a DateFormat, indicating it is a method of the DateFormat class."", ""DateFormat"")"
You can use addBatch() and executeBatch() methods to execute batch updates.,"(""addBatch"", ""Both are methods used to execute batch updates"", ""executeBatch"")"
The Java FileOutputStream class is a subclass of Java OutputStream meaning you can use a FileOutputStream as an OutputStream,"(""FileOutputStream"", ""FileOutputStream is a subclass of OutputStream, indicating an inheritance relationship."", ""OutputStream"")"
In the example above I passed it a FileInputStream connected to a file named myfile.zip,"(""FileInputStream"", ""FileInputStream is connected to the file named myfile.zip"", ""myfile.zip"")"
java.util.logging.LogRecord Throwable is either passed as parameter to a Logger log method or set directly on a LogRecord which is then passed to a Logger,"(""Throwable"", ""Throwable is passed as a parameter to a Logger log method."", ""Logger""); (""LogRecord"", ""LogRecord is passed to a Logger."", ""Logger""); (""Throwable"", ""Throwable is set directly on a LogRecord."", ""LogRecord"")"
As you can see a new StringBuilder is created passing along the first String to its constructor and the second String to its append() method before finally calling the toString() method,"(""StringBuilder"", ""StringBuilder is instantiated using its constructor."", ""constructor""); (""StringBuilder"", ""The append() method is called on the StringBuilder instance."", ""append""); (""StringBuilder"", ""The toString() method is called on the StringBuilder instance to convert it to a String."", ""toString"")"
A thread cannot call wait() notify() or notifyAll() without holding the lock on the object the method is called on,"(""Wait"", ""Both methods are related as they are synchronization methods that require holding a lock on the object."", ""Notify""); (""Wait"", ""Both methods are related as they are synchronization methods that require holding a lock on the object."", ""NotifyAll""); (""Notify"", ""Both methods are related as they are synchronization methods that require holding a lock on the object."", ""NotifyAll"")"
The AtomicReferenceArray in the java.util.concurrent.atomic package is an array of object references which can be updated atomically,"(""AtomicReferenceArray"", ""The class AtomicReferenceArray is part of the java.util.concurrent.atomic package"", ""java.util.concurrent.atomic"")"
Spin locks and the methods wait() and notify() are covered in more detail in the text Thread Signaling,"(""Spin Locks"", ""The method Wait is likely used within the context of Spin Locks for thread synchronization."", ""Wait""); (""Spin Locks"", ""The method Notify is likely used within the context of Spin Locks for thread signaling."", ""Notify""); (""Wait"", ""The method Wait is discussed in the context of Thread Signaling, indicating its role in signaling threads."", ""Thread Signaling""); (""Notify"", ""The method Notify is discussed in the context of Thread Signaling, indicating its role in signaling threads."", ""Thread Signaling"")"
The AtomicLong class is located in the java.util.concurrent.atomic package so the full class name is java.util.concurrent.atomic.AtomicLong,"(""AtomicLong"", ""The AtomicLong class is part of the java.util.concurrent.atomic package, indicating its location within the package structure."", ""java.util.concurrent.atomic"")"
"The Arrays class contains a set of methods called binarySearch(). This method helps you perform a binary search in an array. The array must first be sorted. You can do so yourself, or via the Arrays.sort() method covered earlier in this text.","(""Arrays"", ""The binarySearch method is part of the Arrays class."", ""binarySearch""); (""Arrays"", ""The sort method is part of the Arrays class."", ""sort""); (""binarySearch"", ""The binarySearch method requires the array to be sorted, which can be done using the sort method."", ""sort"")"
The Java Reader (java.io.Reader) and Java Writer class (java.io.Writer) in Java IO work much like the InputStream and OutputStream with the exception that Reader and Writer are character based,"(""Java Reader"", ""Java Reader is part of the Java IO package"", ""Java IO""); (""Java Writer"", ""Java Writer is part of the Java IO package"", ""Java IO""); (""Java Reader"", ""Java Reader works similarly to InputStream"", ""InputStream""); (""Java Writer"", ""Java Writer works similarly to OutputStream"", ""OutputStream"")"
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicInteger,"(""GetAndIncrement"", ""The method GetAndIncrement is used to modify the value of the AtomicInteger."", ""AtomicInteger""); (""IncrementAndGet"", ""The method IncrementAndGet is used to modify the value of the AtomicInteger."", ""AtomicInteger""); (""GetAndAdd"", ""The method GetAndAdd is used to modify the value of the AtomicInteger."", ""AtomicInteger""); (""AddAndGet"", ""The method AddAndGet is used to modify the value of the AtomicInteger."", ""AtomicInteger"")"
"The tailSet() method works the same way as the headSet() method, except it returns all elements that are equal to or higher than the given parameter element","(""TAILSET"", ""Both are methods that operate on sets, with TAILSET returning elements equal to or higher than a given parameter, while HEADSET returns elements lower than a given parameter."", ""HEADSET"")"
If a different thread calls wakeup() and no thread is currently blocked inside select() the next thread that calls select() will wake up immediately,"(""wakeup"", ""The wakeup method affects the behavior of the select method by causing the next thread that calls select to wake up immediately if no thread is currently blocked inside select."", ""select"")"
HashMap maps a key and a value. It does not guarantee any order of the elements stored internally in the map.TreeMap also maps a key and a value. Furthermore it guarantees the order in which keys or values are iterated - which is the sort order of the keys or values.,"(""HashMap"", ""Both HashMap and TreeMap map a key and a value, indicating they are related in functionality."", ""TreeMap""); (""TreeMap"", ""Both TreeMap and HashMap map a key and a value, indicating they are related in functionality."", ""HashMap"")"
It is worth noting that both unlockRead() and unlockWrite() calls notifyAll() rather than notify(),"(""unlockRead"", ""The method unlockRead calls notifyAll, indicating a relationship where unlockRead uses notifyAll to notify all waiting threads."", ""notifyAll""); (""unlockWrite"", ""The method unlockWrite calls notifyAll, indicating a relationship where unlockWrite uses notifyAll to notify all waiting threads."", ""notifyAll""); (""unlockRead"", ""The method unlockRead is mentioned in the context of notify, suggesting a comparison or alternative usage between notifyAll and notify."", ""notify""); (""unlockWrite"", ""The method unlockWrite is mentioned in the context of notify, suggesting a comparison or alternative usage between notifyAll and notify."", ""notify"")"
Notice the call to update() and then doFinal() for these two blocks of data,"(""update"", ""The methods update and doFinal are related as they are called sequentially to process blocks of data."", ""doFinal"")"
You simply pass an offset and length to the update() and or doFinal() method,"(""UPDATE"", ""Both UPDATE and DOFINAL are methods mentioned in the context of passing an offset and length, indicating they are related in functionality."", ""DOFINAL"")"
The Java Collections addAll() method can add a variable number of elements to a Collection (typically either a List or a Set,"(""Java Collections"", ""The addAll method is part of the Java Collections package."", ""addAll""); (""addAll"", ""The addAll method is used to add elements to a Collection class."", ""Collection""); (""Collection"", ""List is a type of Collection class."", ""List""); (""Collection"", ""Set is a type of Collection class."", ""Set"")"
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block,"(""Thread"", ""A thread interacts with the wait() method to pause its execution until a specific condition is met."", ""Wait""); (""Thread"", ""A thread interacts with the notify() method to signal other threads that a condition has changed."", ""Notify""); (""Wait"", ""The wait() and notify() methods are related as they are used together to manage thread synchronization."", ""Notify"")"
java.lang.ThreadLocal is possible to set an initial value for a Java ThreadLocal which will get used the first time get() is called before set() has been called with a new value,"(""Java.lang.ThreadLocal"", ""The Get method is used to retrieve the initial value from the Java.lang.ThreadLocal class."", ""Get""); (""Java.lang.ThreadLocal"", ""The Set method is used to assign a new value to the Java.lang.ThreadLocal class."", ""Set"")"
The Reader and Writer classes are stream oriented classes that enable a Java application to read and write streams of characters,"(""Reader"", ""Both Reader and Writer are stream oriented classes used for reading and writing streams of characters in a Java application"", ""Writer"")"
If the doNotify() method had called notifyAll() instead of notify() all waiting threads had been awakened and checked for signals in turn,"(""doNotify"", ""The doNotify method calls the notifyAll method."", ""notifyAll""); (""doNotify"", ""The doNotify method calls the notify method."", ""notify"")"
The run() method is what is executed by the thread after you call start(),"(""Run"", ""The run() method is executed by the thread after the start() method is called, indicating a sequence of execution."", ""Start"")"
You can convert Strings to uppercase and lowercase using the methods toUpperCase() and toLowerCase(),"(""Strings"", ""The method toUpperCase() is used to convert Strings to uppercase."", ""toUpperCase""); (""Strings"", ""The method toLowerCase() is used to convert Strings to lowercase."", ""toLowerCase"")"
To make the Calculator class thread safe you could have declared the getValue() setValue() and add() methods synchronized,"(""Calculator"", ""The getValue method is a part of the Calculator class, as it is mentioned in the context of making the class thread safe."", ""getValue""); (""Calculator"", ""The setValue method is a part of the Calculator class, as it is mentioned in the context of making the class thread safe."", ""setValue""); (""Calculator"", ""The add method is a part of the Calculator class, as it is mentioned in the context of making the class thread safe."", ""add"")"
"If the call to take() happens before the call to release() the thread calling release() will still know that take() was called, because the signal is stored internally in the signal variable.","(""take"", ""The methods 'take' and 'release' are related because they are part of a sequence where 'take' is called before 'release'."", ""release""); (""release"", ""The method 'release' is related to the 'signal' variable because it stores the signal internally."", ""signal"")"
The getAndAdd() method does the same as the addAndGet() method except the getAndAdd() method returns the value of the element before a value is added to it,"(""GetAndAdd"", ""Both are methods that perform similar operations, with a difference in the return value."", ""AddAndGet"")"
Adding and getting elements to a generic Map is done using the put() and get() methods just like you have always done,"(""Map"", ""The put method is used to add elements to the Map class."", ""put""); (""Map"", ""The get method is used to retrieve elements from the Map class."", ""get"")"
When guarding a critical section with a ReadWriteLock and the critical section may throw exceptions it is important to call the readUnlock() and writeUnlock() methods from inside a finallyclause,"(""ReadWriteLock"", ""The readUnlock method is used in conjunction with the ReadWriteLock class to release a read lock."", ""readUnlock""); (""ReadWriteLock"", ""The writeUnlock method is used in conjunction with the ReadWriteLock class to release a write lock."", ""writeUnlock"")"
The FileChannel class has a transferTo() and a transferFrom() method which does this for you,"(""FileChannel"", ""The transferTo method is a part of the FileChannel class."", ""transferTo""); (""FileChannel"", ""The transferFrom method is a part of the FileChannel class."", ""transferFrom"")"
To generate a KeyPair with a KeyPairGenerator you call the generateKeyPair() method,"(""KeyPairGenerator"", ""The generateKeyPair() method is called on the KeyPairGenerator class to generate a KeyPair."", ""generateKeyPair()""); (""generateKeyPair()"", ""The generateKeyPair() method is used to generate a KeyPair."", ""KeyPair"")"
You can convert a OutputStream to a character based Writer using the Java OutputStreamWriter class,"(""OutputStream"", ""OutputStreamWriter is used to convert an OutputStream to a character-based Writer"", ""OutputStreamWriter""); (""OutputStreamWriter"", ""OutputStreamWriter is a type of Writer"", ""Writer"")"
If you created your SortedSet with a Comparator you can obtain that Comparator via the SortedSet comparator() method,"(""SortedSet"", ""SortedSet can be created with a Comparator, indicating a relationship between the two classes."", ""Comparator""); (""SortedSet"", ""The comparator() method is associated with the SortedSet class, allowing retrieval of the Comparator."", ""comparator"")"
"In order to update the database you need to use a Statement. But, instead of calling the executeQuery() method, you call the executeUpdate() method.","(""Statement"", ""The executeQuery method is typically used with a Statement to execute a query on the database."", ""executeQuery""); (""Statement"", ""The executeUpdate method is used with a Statement to update the database."", ""executeUpdate"")"
Instances of this class are used together with UDP DatagramSockets and normal Socket and ServerSocket,"(""Class"", ""The Class is used together with UDPSocket."", ""UDPSocket""); (""Class"", ""The Class is used together with DatagramSocket."", ""DatagramSocket""); (""Class"", ""The Class is used together with Socket."", ""Socket""); (""Class"", ""The Class is used together with ServerSocket."", ""ServerSocket"")"
The Java InputStreamReader class java.io.InputStreamReader wraps a Java InputStream thereby turning the byte based InputStream into a character based Reader,"(""java.io.InputStreamReader"", ""java.io.InputStreamReader is a specific implementation of the InputStreamReader class"", ""InputStreamReader""); (""java.io.InputStreamReader"", ""java.io.InputStreamReader wraps a Java InputStream"", ""InputStream""); (""java.io.InputStreamReader"", ""java.io.InputStreamReader turns an InputStream into a character based Reader"", ""Reader"")"
The Math is located in the java.lang package and not in the java.math package,"(""Math"", ""The Math class is located in the java.lang package."", ""java.lang""); (""Math"", ""The Math class is mentioned in relation to the java.math package, indicating it is not located there."", ""java.math"")"
The Java StringReader class enables you to turn an ordinary String into a Reader,"(""StringReader"", ""StringReader is a class that extends or implements the Reader class, enabling it to function as a Reader."", ""Reader""); (""StringReader"", ""StringReader is used to convert a String into a Reader, indicating a functional relationship between the two classes."", ""String"")"
All elements inserted into the PriorityBlockingQueue must implement the java.lang.Comparable interface,"(""PriorityBlockingQueue"", ""All elements inserted into the PriorityBlockingQueue must implement the java.lang.Comparable interface, indicating a relationship between the class and the interface."", ""java.lang.Comparable"")"
As mentioned earlier the DataInputStream class is often used together with a DataOutputStream,"(""DataInputStream"", ""The DataInputStream class is often used together with the DataOutputStream class, indicating a functional relationship between the two classes."", ""DataOutputStream"")"
java.io.FileReader works much like the FileInputStream except the FileInputStream reads bytes whereas the FileReader reads characters,"(""Java.io.Filereader"", ""Java.io.Filereader and Fileinputstream are related because both are classes used for reading data, with Fileinputstream reading bytes and Filereader reading characters."", ""Fileinputstream"")"
Deque.pollLast() is different than removeLast() which throws an exception if the Deque is empty,"(""Deque"", ""pollLast is a method of the Deque class"", ""pollLast""); (""Deque"", ""removeLast is a method of the Deque class"", ""removeLast""); (""pollLast"", ""pollLast and removeLast are methods that handle elements in a Deque, with different behaviors when the Deque is empty"", ""removeLast"")"
The java.util.concurrent.locks package has the following implementations of the Lock interface,"(""Java.util.concurrent.locks"", ""The Java.util.concurrent.locks package contains implementations of the Lock class."", ""Lock"")"
The methods start() and end() will give the indexes into the text where the found match starts and ends,"(""START"", ""Both methods are used to determine the indexes of where a match starts and ends in the text"", ""END"")"
The tailSet() method works the same way as the headSet() method except it returns all elements that are equal to or higher than the given parameter element,"(""TailSet"", ""Both methods are used to return subsets of elements based on a given parameter, with TailSet returning elements equal to or higher, and HeadSet returning elements lower."", ""HeadSet"")"
A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object,"(""Wait"", ""The Wait method becomes inactive until the Notify method is called on the same object"", ""Notify"")"
Here is an example of listing all files in a directory via the Java File list() and listFiles() methods,"(""File"", ""The list method is a method of the File class used to list all files in a directory."", ""list""); (""File"", ""The listFiles method is a method of the File class used to list all files in a directory."", ""listFiles"")"
You can peek at the element at the head of a Queue without taking the element out of the Queue. This is done via the Queue element() or peek() methods.,"(""Queue"", ""The method 'element' is used to access the head of the Queue without removing it."", ""element""); (""Queue"", ""The method 'peek' is used to access the head of the Queue without removing it."", ""peek"")"
The methods Class.getField(String name) and Class.getFields() methods only return public fields so they wont work,"(""Class"", ""The method getField is associated with the class Class as it is a method of this class."", ""getField""); (""Class"", ""The method getFields is associated with the class Class as it is a method of this class."", ""getFields"")"
When you do so you can call connect() read() and write() in asynchronous mode,"(""Connect"", ""Both Connect and Read are methods that can be called in asynchronous mode."", ""Read""); (""Connect"", ""Both Connect and Write are methods that can be called in asynchronous mode."", ""Write""); (""Read"", ""Both Read and Write are methods that can be called in asynchronous mode."", ""Write"")"
"if you are writing a component that needs to read input from a stream, try to make our component depend on an InputStream, rather than any of it's subclasses (e.g. FileInputStream).","(""FileInputStream"", ""FileInputStream is a subclass of InputStream, indicating a hierarchical relationship."", ""InputStream"")"
For inexplicable reasons it is possible for threads to wake up even if notify() and notifyAll() has not been called,NULL
The applyLocalizedPattern() does the same as applyPattern() except it interpretes the characters in the pattern according to the Locale the DecimalFormat was created with,"(""applyLocalizedPattern"", ""applyLocalizedPattern does the same as applyPattern except for interpreting characters according to Locale"", ""applyPattern""); (""applyLocalizedPattern"", ""applyLocalizedPattern interprets characters in the pattern according to the Locale"", ""Locale""); (""DecimalFormat"", ""DecimalFormat is created with a specific Locale"", ""Locale"")"
"You can access these two parts of the duration using the Duration methods:getNano(),getSeconds()","(""Duration"", ""The method getNano() is a part of the Duration class, allowing access to the nanoseconds part of the duration."", ""getNano""); (""Duration"", ""The method getSeconds() is a part of the Duration class, allowing access to the seconds part of the duration."", ""getSeconds"")"
If you look back at the doSynchronized() method you will notice that the comment between lock() and unlock() states that the code in between these two calls take a long time to execute,"(""doSynchronized"", ""The lock method is called within the doSynchronized method to manage synchronization."", ""lock""); (""doSynchronized"", ""The unlock method is called within the doSynchronized method to release the lock after synchronization."", ""unlock""); (""lock"", ""The lock and unlock methods are related as they are used together to manage and release synchronization locks."", ""unlock"")"
When the thread calling lock() right after calls queueObject.wait() it will remain blocked until some other thread calls unlock() which may never happen,"(""Lock"", ""The method 'Lock' is related to 'Wait' because the thread calls 'Lock' before calling 'Wait'."", ""Wait""); (""Wait"", ""The method 'Wait' is related to 'Unlock' because 'Wait' remains blocked until 'Unlock' is called."", ""Unlock""); (""QueueObject"", ""The method 'Wait' is associated with the class 'QueueObject' as it is called on it."", ""Wait"")"
Creating a pipe using Java IO is done via the PipedOutputStream and PipedInputStream classes. A PipedInputStream should be connected to a PipedOutputStream. The data written to the PipedOutputStream by one thread can be read from the connected PipedInputStream by another thread.,"(""PipedOutputStream"", ""A PipedInputStream should be connected to a PipedOutputStream, allowing data written to the PipedOutputStream by one thread to be read from the connected PipedInputStream by another thread."", ""PipedInputStream"")"
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block.,"(""Thread"", ""A thread is involved in the wait() method call."", ""Wait""); (""Thread"", ""A thread is involved in the notify() method call."", ""Notify""); (""Wait"", ""The wait() and notify() methods are related as they are part of the thread synchronization process."", ""Notify"")"
"TreeSet also guarantees the order of the elements when iterated, but the order is the sorting order of the elements. In other words, the order in which the elements whould be sorted if you used a Collections.sort() on a List or array containing these elements. This order is determined either by their natural order (if they implement Comparable), or by a specific Comparator implementation","(""TreeSet"", ""TreeSet is related to Collections as it guarantees the order of elements similar to how Collections.sort() would sort them."", ""Collections""); (""sort"", ""The sort method is part of the Collections package, used for sorting elements."", ""Collections""); (""TreeSet"", ""TreeSet can use a Comparator implementation to determine the order of its elements."", ""Comparator""); (""TreeSet"", ""TreeSet can determine the order of its elements using their natural order if they implement Comparable."", ""Comparable""); (""TreeSet"", ""TreeSet's order is compared to the order of elements in a List when sorted using Collections.sort()."", ""List"")"
"You can also obtain an Iterator from many of the Java Collection data structures, e.g. a List, Set, Map, Queue, Deque or Map.","(""Iterator"", ""Iterator is a class that can be obtained from many of the Java Collection data structures."", ""Java Collection""); (""Iterator"", ""Iterator can be obtained from a List, which is a type of Java Collection."", ""List""); (""Iterator"", ""Iterator can be obtained from a Set, which is a type of Java Collection."", ""Set""); (""Iterator"", ""Iterator can be obtained from a Map, which is a type of Java Collection."", ""Map""); (""Iterator"", ""Iterator can be obtained from a Queue, which is a type of Java Collection."", ""Queue""); (""Iterator"", ""Iterator can be obtained from a Deque, which is a type of Java Collection."", ""Deque"")"
Instead the critical section is guarded by the lock.lock() and lock.unlock() calls,"(""Lock"", ""The method lock.lock() is a function of the Lock class, used to acquire the lock."", ""Lock.lock()""); (""Lock"", ""The method lock.unlock() is a function of the Lock class, used to release the lock."", ""Lock.unlock()"")"
The methods mark() and reset() methods are typically used when implementing parsers,"(""Mark"", ""Both methods are typically used together when implementing parsers"", ""Reset"")"
Once you have obtained a Field reference you can get and set its values using the Field.get() and Field.set()methods like this,"(""Field"", ""The 'get' method is used to retrieve values from a Field object."", ""get""); (""Field"", ""The 'set' method is used to assign values to a Field object."", ""set"")"
The poll() and remove() both removes the first element in the Queue,"(""Poll"", ""Poll is a method that operates on the Queue class to remove the first element."", ""Queue""); (""Remove"", ""Remove is a method that operates on the Queue class to remove the first element."", ""Queue"")"
Any other thread calling lock() will be blocked until the thread that locked the lock calls unlock(),"(""LOCK"", ""The LOCK method is related to the UNLOCK method because a thread calling LOCK will be blocked until the thread that locked the lock calls UNLOCK."", ""UNLOCK"")"
The java.text.DateFormat class is used to format dates as strings according to a specific Locale,"(""DateFormat"", ""The DateFormat class uses the format method to format dates as strings."", ""format""); (""DateFormat"", ""The DateFormat class is part of the java.text package."", ""java.text""); (""DateFormat"", ""The DateFormat class formats dates according to a specific Locale."", ""Locale"")"
The InputStream class has two methods called mark() and reset() which subclasses of InputStream may or may not support,"(""InputStream"", ""The method 'mark' is associated with the 'InputStream' class as it is one of its methods."", ""mark""); (""InputStream"", ""The method 'reset' is associated with the 'InputStream' class as it is one of its methods."", ""reset"")"
java.nio.channels.Selector is not the Channel that pushes the data into the Selector and from there into the component even if that is what the above diagram suggests,"(""Selector"", ""The Selector is related to the Channel as it is mentioned that data is pushed from the Channel into the Selector."", ""Channel"")"
When connected you can also use the read() and write() method as if you were using a traditional channel,"(""READ"", ""Both are methods that can be used when connected to a channel"", ""WRITE"")"
"The mark() sets a mark internally in the InputStream which marks the point in the stream to which data has been read so far. The code using the InputStream can then continue reading data from it. If the code using the InputStream wants to go back to the point in the stream where the mark was set, the code calls reset() on the InputStream.","(""Mark"", ""The method 'mark()' is used to set a mark in the 'InputStream'."", ""InputStream""); (""Reset"", ""The method 'reset()' is called on the 'InputStream' to return to the marked point."", ""InputStream""); (""Mark"", ""The 'mark()' method sets a point in the stream, and 'reset()' is used to return to that point."", ""Reset"")"
These two types of tasks are represented by the RecursiveAction and RecursiveTask classes,"(""RecursiveAction"", ""Both are types of tasks represented by classes"", ""RecursiveTask"")"
The java.util.concurrent package has the following implementations of the BlockingQueue interface,"(""Java.util.concurrent"", ""The BlockingQueue class is implemented within the Java.util.concurrent package"", ""BlockingQueue"")"
If the objects in the Java List do not implement the Comparable interface or if you want to sort the objects in another order than their compare() implementation then you need to use a Comparator implementation (java.util.Comparator),"(""Java List"", ""Java List objects can implement the Comparable interface to define a natural ordering."", ""Comparable""); (""Java List"", ""Java List objects can use a Comparator implementation to define a custom ordering."", ""Comparator""); (""Comparator"", ""The Comparator interface is implemented in the java.util.Comparator package."", ""java.util.Comparator"")"
The Java SimpleDateFormat class is also capable of formatting a Date object into a StringBuffer instead of returning an individual String with the date formatted,"(""SimpleDateFormat"", ""The SimpleDateFormat class is used to format Date objects."", ""Date""); (""SimpleDateFormat"", ""The SimpleDateFormat class can format a Date object into a StringBuffer."", ""StringBuffer""); (""SimpleDateFormat"", ""The SimpleDateFormat class can return a formatted date as a String."", ""String"")"
If the markSupported() method returns false then mark() and reset() are not supported,"(""markSupported"", ""The markSupported method determines if the mark method is supported."", ""mark""); (""markSupported"", ""The markSupported method determines if the reset method is supported."", ""reset"")"
The Matcher replaceAll() and replaceFirst() methods can be used to replace parts of the string the Matcher is searching through,"(""Matcher"", ""The replaceAll method is a function of the Matcher class."", ""replaceAll""); (""Matcher"", ""The replaceFirst method is a function of the Matcher class."", ""replaceFirst"")"
In that way the PrintWriter is a bit different from other Writer subclasses which tend to have mostly constructors that can take other Writer instances as parameters (except for a few like OutputStreamWriter),"(""PrintWriter"", ""PrintWriter is a subclass of Writer."", ""Writer""); (""OutputStreamWriter"", ""OutputStreamWriter is mentioned as an exception among Writer subclasses."", ""Writer"")"
The reduce() method can be combined with the filter() method too,"(""Reduce"", ""Both are methods that can be combined in usage"", ""Filter"")"
In case you prefer to use Java NIO instead of Java Networking (standard API) then you can also use a ServerSocketChannel instead of the java.net.ServerSocket,"(""Java NIO"", ""Java NIO provides the ServerSocketChannel class for network operations."", ""ServerSocketChannel""); (""Java Networking"", ""Java Networking includes the java.net.ServerSocket class for network operations."", ""java.net.ServerSocket""); (""ServerSocketChannel"", ""ServerSocketChannel can be used as an alternative to java.net.ServerSocket for network operations."", ""java.net.ServerSocket"")"
The problem is that since the doNotify() call only calls notify() and not notifyAll() only one thread is awakened even if 4 threads are waiting on the same string instance (the empty string),"(""doNotify"", ""The doNotify method calls the notify method."", ""notify""); (""doNotify"", ""The doNotify method does not call the notifyAll method, which is relevant to the problem described."", ""notifyAll"")"
You can convert a FileOutputStream to a character based Writer using the Java OutputStreamWriter class,"(""FileOutputStream"", ""OutputStreamWriter is used to convert a FileOutputStream to a character-based Writer."", ""OutputStreamWriter""); (""OutputStreamWriter"", ""OutputStreamWriter is a class that acts as a bridge to convert byte streams to character streams, thus related to Writer."", ""Writer""); (""OutputStreamWriter"", ""OutputStreamWriter is a class within the Java package."", ""Java"")"
The channel returned by the SelectionKey.channel() method should be cast to the channel you need to work with a ServerSocketChannel or SocketChannel etc,"(""SelectionKey"", ""The channel method is part of the SelectionKey class, as indicated by the SelectionKey.channel() syntax."", ""channel""); (""channel"", ""The channel method can return a ServerSocketChannel, suggesting a relationship between them."", ""ServerSocketChannel""); (""channel"", ""The channel method can return a SocketChannel, suggesting a relationship between them."", ""SocketChannel"")"
java.io.Writer works just like combining the Reader with InputStream or the Writer with OutputStream,"(""Writer"", ""Writer is related to Reader as they are both used for handling input and output operations in Java."", ""Reader""); (""Writer"", ""Writer is related to InputStream as they are both used for handling input operations in Java."", ""InputStream""); (""Writer"", ""Writer is related to OutputStream as they are both used for handling output operations in Java."", ""OutputStream"")"
Object.wait(long timeout) means that the majority of the time waited to be able to lock the lock and enter the critical section is spent waiting in the wait() call inside the lock() method not being blocked trying to enter the lock() method,"(""wait"", ""The wait method is called inside the lock method, indicating a direct relationship where wait is used within lock."", ""lock""); (""Object"", ""The wait method is associated with the Object class, as indicated by the notation Object.wait()."", ""wait""); (""Object"", ""The lock method is likely associated with the Object class, as it is mentioned in the context of Object.wait()."", ""lock"")"
Remember that even if the 4 threads call wait() and notify() on the same shared string instance the signals from the doWait() and doNotify() calls are stored individually in the two MyWaitNotify instances,"(""WAIT"", ""The method doWait() likely calls or is related to the wait() method."", ""DOWAIT""); (""NOTIFY"", ""The method doNotify() likely calls or is related to the notify() method."", ""DONOTIFY""); (""DOWAIT"", ""The doWait() method is part of the MyWaitNotify class."", ""MYWAITNOTIFY""); (""DONOTIFY"", ""The doNotify() method is part of the MyWaitNotify class."", ""MYWAITNOTIFY"")"
The rest of the components like Pipe and FileLock are merely utility classes to be used in conjunction with the three core components,"(""Pipe"", ""Both Pipe and FileLock are utility classes mentioned together as components."", ""FileLock"")"
java.io.PrintStream example first creates a PrintStream which is connected to an OutputStream,"(""Java.io.PrintStream"", ""PrintStream is a class within the Java.io.PrintStream package"", ""PrintStream""); (""PrintStream"", ""PrintStream is connected to an OutputStream"", ""OutputStream"")"
"If the Deque is empty, pollLast() returns null. This is different than removeLast() which throws an exception if the Deque is empty.","(""pollLast"", ""pollLast is a method that operates on the Deque class"", ""Deque""); (""removeLast"", ""removeLast is a method that operates on the Deque class"", ""Deque""); (""pollLast"", ""Both pollLast and removeLast are methods that handle the scenario when the Deque is empty, but in different ways"", ""removeLast"")"
The Map computeIfAbsent() method works similarly to the compute() method but the lambda expression is only called if no entry exists already for the given key,"(""computeIfAbsent"", ""Both are methods that perform computations on map entries."", ""compute""); (""Map"", ""computeIfAbsent is a method of the Map class."", ""computeIfAbsent""); (""Map"", ""compute is a method of the Map class."", ""compute"")"
You can get and set the nanoseconds using the getNanos() and setNanos(),"(""getNanos"", ""Both methods are related as they are used to get and set the nanoseconds, indicating they operate on the same data or object."", ""setNanos"")"
This OutputStream write() example first creates a FileOutputStream to which the data will be written. Then the example enters a while loop. The condition to exit the while loop is the return value of the method hasMoreData().,"(""OutputStream"", ""The method write() is associated with the OutputStream class as it is a common method used to write data to an output stream."", ""write""); (""FileOutputStream"", ""FileOutputStream is a subclass of OutputStream, used specifically for writing data to a file."", ""OutputStream""); (""hasMoreData"", ""The method hasMoreData() is used as a condition to exit the while loop, indicating its role in controlling the loop execution."", ""while loop"")"
Since the BufferedWriter collects the characters written internally in a buffer before writing them to the underlying Writer the speedup is not as noticeable as with other Writer classes (that do not use buffering),"(""BufferedWriter"", ""BufferedWriter is a class that uses an underlying Writer to perform its operations"", ""Writer""); (""BufferedWriter"", ""BufferedWriter is compared to other Writer classes in terms of speedup due to buffering"", ""Writer"")"
The Java compiler then generates the corresponding fields getter methods and a hashCode() and equals() method,"(""Java"", ""The compiler is part of the Java package."", ""compiler""); (""compiler"", ""The compiler generates fields."", ""fields""); (""fields"", ""Getter methods are generated for fields."", ""getter methods""); (""compiler"", ""The compiler generates the hashCode() method."", ""hashCode()""); (""compiler"", ""The compiler generates the equals() method."", ""equals()"")"
The bigger the result String grows the longer it takes to copy the characters from it into a new StringBuilder and again copy the characters from the StringBuilder into the temporary String created by the toString() method,"(""StringBuilder"", ""The toString() method is used to create a temporary String from the StringBuilder."", ""toString""); (""String"", ""Characters are copied from the String into a new StringBuilder."", ""StringBuilder""); (""StringBuilder"", ""Characters are copied from the StringBuilder into a temporary String created by the toString() method."", ""String"")"
"Instead of calling the stop() method you will have to implement your thread code so it can be stopped, you can implements Runnable which contains an extra method called doStop() which signals to the Runnable to stop.","(""Runnable"", ""The DoStop method is part of the Runnable class, signaling it to stop."", ""DoStop""); (""Stop"", ""The Stop method is mentioned as an alternative to implementing the Runnable class for stopping a thread."", ""Runnable"")"
The logp() methods work like the log() methods except each method take an extra two parameters The sourceClass and sourceMethod parameter,"(""LOGP"", ""The LOGP methods work like the LOG methods, indicating a functional similarity or extension."", ""LOG""); (""LOGP"", ""The LOGP methods take SOURCECLASS as an extra parameter, indicating a dependency or input requirement."", ""SOURCECLASS""); (""LOGP"", ""The LOGP methods take SOURCEMETHOD as an extra parameter, indicating a dependency or input requirement."", ""SOURCEMETHOD"")"
But since the thread waiting in lock() has not yet called queueObject.wait() the call to queueObject.notify() passes into oblivion,"(""LOCK"", ""The method LOCK is related to QUEUEOBJECT.WAIT as the thread is waiting in LOCK before calling QUEUEOBJECT.WAIT."", ""QUEUEOBJECT.WAIT""); (""QUEUEOBJECT.WAIT"", ""The method QUEUEOBJECT.WAIT is related to QUEUEOBJECT.NOTIFY because QUEUEOBJECT.NOTIFY is called after QUEUEOBJECT.WAIT."", ""QUEUEOBJECT.NOTIFY"")"
It is possible to compare two buffers using equals() and compareTo(),"(""EQUALS"", ""Both EQUALS and COMPARETO are methods used to compare two buffers."", ""COMPARETO"")"
The names take() and release() may seem a bit odd when using a semaphore for signaling,"(""TAKE"", ""The method TAKE is used in the context of a SEMAPHORE for signaling."", ""SEMAPHORE""); (""RELEASE"", ""The method RELEASE is used in the context of a SEMAPHORE for signaling."", ""SEMAPHORE"")"
If you need to read and write the date and time to a database use the java.sql.Date and java.sql.Timestamp classes,"(""Java.Sql.Date"", ""Both classes are used for handling date and time in database operations."", ""Java.Sql.Timestamp"")"
Since PipedOutputStream is a subclass of OutputStream PipedOutputStream has the same basic methods and use patterns as an OutputStream,"(""PipedOutputStream"", ""PipedOutputStream is a subclass of OutputStream, indicating an inheritance relationship."", ""OutputStream""); (""PipedOutputStream"", ""PipedOutputStream shares the same basic methods and use patterns as OutputStream, suggesting a functional relationship."", ""OutputStream"")"
In the following sections I will explain how to use the ReentrantLock class as a Lock,"(""ReentrantLock"", ""ReentrantLock is used as a Lock, indicating a relationship between the two classes"", ""Lock"")"
In contrast to the signaling use case the methods take() and release() are now called by the same thread,"(""TAKE"", ""Both methods are called by the same thread, indicating a sequential or related operation."", ""RELEASE"")"
The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called,"(""Notify"", ""Both are methods mentioned in the text that relate to thread notification."", ""NotifyAll"")"
The Matcher appendReplacement() and appendTail() methods are used to replace string tokens in an input text and append the resulting string to a StringBuffer,"(""Matcher"", ""The appendReplacement method belongs to the Matcher class."", ""appendReplacement""); (""Matcher"", ""The appendTail method belongs to the Matcher class."", ""appendTail""); (""appendReplacement"", ""The appendReplacement method appends the resulting string to a StringBuffer."", ""StringBuffer""); (""appendTail"", ""The appendTail method appends the resulting string to a StringBuffer."", ""StringBuffer"")"
The Java BufferedReader class is a subclass of the Java Reader class so you can use a BufferedReader anywhere a Reader is required,"(""BufferedReader"", ""BufferedReader is a subclass of Reader, indicating an inheritance relationship."", ""Reader"")"
You can convert a Java Set to a Java List by creating a List and calling its addAll() method passing the Set as parameter to the addAll() method,"(""List"", ""The addAll method is called on a List to add elements from another collection."", ""addAll""); (""Set"", ""The addAll method takes a Set as a parameter to add its elements to a List."", ""addAll""); (""Set"", ""A Set is converted to a List by using the addAll method."", ""List"")"
The add() and offer() methods differ in how the behave if the Queue is full so no more elements can be added,"(""Add"", ""The Add method is related to the Queue class as it is a method that operates on a Queue."", ""Queue""); (""Offer"", ""The Offer method is related to the Queue class as it is a method that operates on a Queue."", ""Queue"")"
The Collections binarySearch() method can search a Java List for an element using a binary search algorithm. The List must be sorted in ascending order before you search it using binarySearch() .,"(""Collections"", ""The binarySearch method is part of the Collections package."", ""binarySearch""); (""binarySearch"", ""The binarySearch method is used to search a List class."", ""List""); (""Collections"", ""The Collections package contains methods that operate on the List class."", ""List"")"
If unlockWrite() was not called from inside a finallyclause and an exception was thrown from the critical section the ReadWriteLock would remain write locked forever causing all threads calling lockRead() or lockWrite() on that ReadWriteLock instance to halt indefinately,"(""unlockWrite"", ""The method unlockWrite is related to the class ReadWriteLock as it is a method that operates on instances of this class."", ""ReadWriteLock""); (""lockRead"", ""The method lockRead is related to the class ReadWriteLock as it is a method that operates on instances of this class."", ""ReadWriteLock""); (""lockWrite"", ""The method lockWrite is related to the class ReadWriteLock as it is a method that operates on instances of this class."", ""ReadWriteLock"")"
Third the characters written to the StringWriter are obtained via the two methods toString() and getBuffer(),"(""StringWriter"", ""The method toString() is used to obtain characters written to the StringWriter class."", ""toString""); (""StringWriter"", ""The method getBuffer() is used to obtain characters written to the StringWriter class."", ""getBuffer"")"
The decrementAndGet() subtracts 1 from the AtomicInteger value and returns its value after the subtraction. The getAndDecrement() also subtracts 1 from the AtomicInteger value but returns the value the AtomicInteger had before the subtraction.,"(""DecrementAndGet"", ""The method DecrementAndGet operates on the AtomicInteger class by subtracting 1 from its value and returning the new value."", ""AtomicInteger""); (""GetAndDecrement"", ""The method GetAndDecrement operates on the AtomicInteger class by subtracting 1 from its value and returning the original value before subtraction."", ""AtomicInteger"")"
"If the Deque is empty, removeLast() will throw an exception. This is different from pollLast() which returns null if the Deque is empty.","(""removeLast"", ""The method removeLast is associated with the class Deque as it operates on it."", ""Deque""); (""pollLast"", ""The method pollLast is associated with the class Deque as it operates on it."", ""Deque""); (""removeLast"", ""Both methods removeLast and pollLast are related as they provide different behaviors when the Deque is empty."", ""pollLast"")"
You may be familiar with these two wellknown PrintStream instances in Java System.out and System.err,"(""System"", ""The 'out' method is a well-known instance of the System class in Java."", ""out""); (""System"", ""The 'err' method is a well-known instance of the System class in Java."", ""err"")"
"If adding the element fails, for instance if the Deque is full, the push() method will throw an exception. This is similar to how the addFirst() method works.","(""push()"", ""The push() method is associated with the Deque class as it operates on it."", ""Deque""); (""addFirst()"", ""The addFirst() method is associated with the Deque class as it operates on it."", ""Deque"")"
Finally you can access the localized values in the ResourceBundle via its different getString() and getObject() etc,"(""ResourceBundle"", ""The getString method is used to access localized values from the ResourceBundle class."", ""getString""); (""ResourceBundle"", ""The getObject method is used to access localized values from the ResourceBundle class."", ""getObject"")"
"The tailMap() method is similar to the headMap() method, except that tailMap() returns all elements that are equal to or higher than the given parameter element.","(""tailMap"", ""Both are methods that deal with elements based on a given parameter, with tailMap() returning elements equal to or higher, and headMap() presumably returning elements lower."", ""headMap"")"
That you would not call wait() and notify() on an internal monitor object but rather on the This is probably true,"(""WAIT"", ""Both WAIT and NOTIFY are methods that are typically used together for thread synchronization."", ""NOTIFY"")"
You can parse a String into a java.util.Date instance using the parse() method of the SimpleDateFormat instance,"(""parse()"", ""The parse() method is a function of the SimpleDateFormat class"", ""SimpleDateFormat""); (""java.util.Date"", ""The parse() method is used to convert a String into a java.util.Date instance"", ""parse()""); (""String"", ""The parse() method takes a String as input to convert it into a java.util.Date"", ""parse()"")"
"If the Deque is empty, peekFirst() returns null. This is similar to how peek() works","(""Deque"", ""peekFirst is a method that operates on the Deque class"", ""peekFirst""); (""Deque"", ""peek is a method that operates on the Deque class"", ""peek"")"
When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start() like this,"(""Thread"", ""The run method is associated with the Thread class as it is a method that can be called on a Thread instance."", ""run""); (""Thread"", ""The start method is associated with the Thread class as it is a method that can be called on a Thread instance."", ""start""); (""run"", ""Both run and start are methods related to the Thread class, often used in the context of thread execution."", ""start"")"
java.util.logging.Handler is not a Filter even though it has the same effect,"(""Handler"", ""Handler is part of the java.util.logging package"", ""java.util.logging""); (""Handler"", ""Handler is mentioned in the context of having a similar effect to Filter"", ""Filter"")"
The Java PrintStream class contains the powerful format() and printf() methods (they do exactly the same but the name printf is more familiar to Cprogrammers),"(""PrintStream"", ""The method 'format' is part of the 'PrintStream' class."", ""format""); (""PrintStream"", ""The method 'printf' is part of the 'PrintStream' class."", ""printf""); (""format"", ""The methods 'format' and 'printf' perform the same function, making them related."", ""printf"")"
java.util.TreeSet Comparator will then decide the ordering of the elements in the TreeSet,"(""TreeSet"", ""The Comparator is used to decide the ordering of the elements in the TreeSet."", ""Comparator""); (""TreeSet"", ""TreeSet is part of the java.util package."", ""java.util"")"
Exactly how to handle the calls to commit() and or rollback() is covered in the JDBC Transactions Tutorial,"(""commit()"", ""The method commit() is discussed in the JDBC Transactions Tutorial."", ""JDBC Transactions Tutorial""); (""rollback()"", ""The method rollback() is discussed in the JDBC Transactions Tutorial."", ""JDBC Transactions Tutorial"")"
You may be tempted then to always call notifyAll() instead notify() but this is a bad idea performance wise,"(""NotifyAll"", ""Both are methods that can be called, but NotifyAll is suggested to be used cautiously due to performance concerns."", ""Notify"")"
The File class contains the method mkdir() and mkdirs() for that purpose,"(""File"", ""The mkdir method is contained within the File class."", ""mkdir""); (""File"", ""The mkdirs method is contained within the File class."", ""mkdirs"")"
The lock() method locks the Lock instance so that all threads calling lock() are blocked until unlock() is executed,"(""lock"", ""The lock() method is a function that operates on the Lock class to lock the instance."", ""Lock""); (""unlock"", ""The unlock() method is a function that operates on the Lock class to unlock the instance."", ""Lock"")"
The call to read() reads a character from the PushbackReader just like from any other Reader,"(""Read"", ""The method 'read' is used to read a character from the 'PushbackReader' class."", ""PushbackReader""); (""Read"", ""The method 'read' is used to read a character from the 'Reader' class, similar to how it operates with 'PushbackReader'."", ""Reader"")"
java.io.BufferedInputStream is typically much faster than reading a single byte at a time from an InputStream especially for disk access and larger data amounts,"(""BufferedInputStream"", ""BufferedInputStream is a class that enhances the performance of reading from an InputStream by buffering the input, making it faster for disk access and larger data amounts."", ""InputStream"")"
Even though the Java Networking APIs enable you to open and close network connections via sockets all communication happens via the Java IO classes InputStream and OutputStream,"(""Java Networking APIs"", ""Java Networking APIs use InputStream for network communication."", ""InputStream""); (""Java Networking APIs"", ""Java Networking APIs use OutputStream for network communication."", ""OutputStream"")"
The tailMap() method is similar to the headMap() method except that tailMap() returns all elements that are equal to or higher than the given parameter element,"(""TailMap"", ""Both TailMap and HeadMap are methods that deal with elements based on a given parameter, with TailMap returning elements equal to or higher than the parameter."", ""HeadMap"")"
Again here the first() and next() methods return the unicode index of the found word boundary,"(""FIRST"", ""Both FIRST and NEXT are methods mentioned in the context of returning the unicode index of a found word boundary."", ""NEXT"")"
"The `getAndIncrement()` method does the same as the `incrementAndGet()` method, except the `getAndIncrement()` method returns the value of the element *before* it is incremented.","(""GetAndIncrement"", ""Both methods perform similar operations, but GetAndIncrement returns the value before incrementing, while IncrementAndGet returns the value after incrementing."", ""IncrementAndGet"")"
When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start(),"(""Thread"", ""The run method is a function that can be called on the Thread class."", ""run""); (""Thread"", ""The start method is a function that can be called on the Thread class."", ""start"")"
Obviously if the input parameter to contains() is null the contains() method will not use the equals() method to compare against each element but rather use the == operator,"(""CONTAINS"", ""The CONTAINS method uses the EQUALS method to compare elements when the input parameter is not null."", ""EQUALS"")"
Thus you can use the return values of start() and end() inside a String.substring() call,"(""start"", ""The method 'start' is used to provide a return value that can be used as an argument in the 'substring' method."", ""substring""); (""end"", ""The method 'end' is used to provide a return value that can be used as an argument in the 'substring' method."", ""substring""); (""String"", ""The 'substring' method is a method of the 'String' class."", ""substring"")"
The PrintWriter class has all the same methods as the PrintStream except for the methods to write raw bytes,"(""PrintWriter"", ""The PrintWriter class has methods."", ""methods""); (""PrintStream"", ""The PrintStream class has methods."", ""methods""); (""PrintWriter"", ""The PrintWriter class has all the same methods as the PrintStream class except for the methods to write raw bytes."", ""PrintStream"")"
"The Java SortedMap interface, java.util.SortedMap, is a subtype of the java.util.Map interface, with the addition that the elements stored in a Java SortedMap map are sorted internally. This means you can iterate the elements stored in a SortedMap in the sort order.","(""SortedMap"", ""The SortedMap class is part of the java.util.SortedMap package."", ""java.util.SortedMap""); (""Map"", ""The Map class is part of the java.util.Map package."", ""java.util.Map""); (""SortedMap"", ""SortedMap is a subtype of the Map class."", ""Map"")"
Similarly the compareTo() method should throw a ClassCastException if the input parameter is not of the same class as the class of the object compareTo() is called on,"(""compareTo"", ""The compareTo method throws a ClassCastException if the input parameter is not of the same class."", ""ClassCastException""); (""compareTo"", ""The compareTo method is called on an object of a certain class."", ""class"")"
The class java.lang.Object defines three methods wait() notify() and notifyAll() to facilitate this,"(""Java.Lang.Object"", ""The method Wait is defined in the class Java.Lang.Object"", ""Wait""); (""Java.Lang.Object"", ""The method Notify is defined in the class Java.Lang.Object"", ""Notify""); (""Java.Lang.Object"", ""The method NotifyAll is defined in the class Java.Lang.Object"", ""NotifyAll"")"
Both Java File and FileChannel works but in case you want a pure Java NIO solution use the Java NIO FileChannel class,"(""Java File"", ""Both are classes mentioned as working solutions in the context of Java NIO."", ""FileChannel""); (""FileChannel"", ""FileChannel is a class that is part of the Java NIO package."", ""Java NIO"")"
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicLong,"(""GETANDINCREMENT"", ""The method getAndIncrement() is related to the class AtomicLong as it operates on its value."", ""ATOMICLONG""); (""INCREMENTANDGET"", ""The method incrementAndGet() is related to the class AtomicLong as it operates on its value."", ""ATOMICLONG""); (""GETANDADD"", ""The method getAndAdd() is related to the class AtomicLong as it operates on its value."", ""ATOMICLONG""); (""ADDANDGET"", ""The method addAndGet() is related to the class AtomicLong as it operates on its value."", ""ATOMICLONG"")"
"celingEntry(), floorEntry(), higherEntry(), lowerEntry(),The NavigableMap also has methods to get the entry for a given key, rather than the key itself. These methods behave like the ceilingKey() etc. methods, except they return a Map.Entry instead of the key object itself.","(""celingEntry()"", ""The method celingEntry() is part of the NavigableMap class."", ""NavigableMap""); (""floorEntry()"", ""The method floorEntry() is part of the NavigableMap class."", ""NavigableMap""); (""higherEntry()"", ""The method higherEntry() is part of the NavigableMap class."", ""NavigableMap""); (""lowerEntry()"", ""The method lowerEntry() is part of the NavigableMap class."", ""NavigableMap"")"
The Java GZIPOutputStream class (java.util.zip.GZIPOutStream) can be used to GZIP compress data and write it to an OutputStream,"(""GZIPOutputStream"", ""GZIPOutputStream is part of the java.util.zip package"", ""java.util.zip""); (""GZIPOutputStream"", ""GZIPOutputStream writes compressed data to an OutputStream"", ""OutputStream"")"
Object.wait(long timeout) allows other threads to call wait() or notify() too since these methods must be called from inside a synchronized block,"(""Object"", ""The method 'wait' is a member of the class 'Object'."", ""wait""); (""Object"", ""The method 'notify' is a member of the class 'Object'."", ""notify""); (""wait"", ""Both 'wait' and 'notify' are methods that must be called from inside a synchronized block, indicating they are related in their usage context."", ""notify"")"
The java.util.TimeZone class is used in conjunction with the java.util.Calendar class,"(""TimeZone"", ""The TimeZone class is part of the java.util package"", ""java.util""); (""Calendar"", ""The Calendar class is part of the java.util package"", ""java.util""); (""TimeZone"", ""The TimeZone class is used in conjunction with the Calendar class"", ""Calendar"")"
You do so by calling the Cipher update() or doFinal() methods,"(""Cipher"", ""The update method is a function that belongs to the Cipher class"", ""update""); (""Cipher"", ""The doFinal method is a function that belongs to the Cipher class"", ""doFinal"")"
The BlockingDeque interface in the java.util.concurrent class represents a deque which is thread safe to put into and take instances from,"(""BlockingDeque"", ""The BlockingDeque class is part of the java.util.concurrent package, which provides thread-safe utilities."", ""java.util.concurrent"")"
Here are two examples of taking an element from a Java Queue using its poll() and remove() methods,"(""Queue"", ""The poll() method is used to take an element from a Java Queue."", ""poll()""); (""Queue"", ""The remove() method is used to take an element from a Java Queue."", ""remove()"")"
If you need an integer value use the round() floor() or ceil() method,"(""Round"", ""Both are methods used to obtain integer values from a number."", ""Floor""); (""Round"", ""Both are methods used to obtain integer values from a number."", ""Ceil""); (""Floor"", ""Both are methods used to obtain integer values from a number."", ""Ceil"")"
Notice how it is possible to change that reference through both the setValue() and add() methods,"(""SETVALUE"", ""Both are methods that can change a reference"", ""ADD"")"
a given date is or convert dates and times between time zones use the java.util.Calendar and java.util.GregorianCalendar classes,"(""Java.util.Calendar"", ""Both are classes used for handling dates and times in Java, and they are likely part of the same package or used together for similar purposes."", ""Java.util.GregorianCalendar"")"
If the call to take() happens before the call to release() the thread calling release() will still know that take() was called because the signal is stored internally in the signal variable,"(""TAKE"", ""The TAKE method is related to the RELEASE method because the call to TAKE happens before the call to RELEASE, indicating a sequence of operations."", ""RELEASE""); (""TAKE"", ""The TAKE method is related to the SIGNAL variable because the signal is stored internally when TAKE is called."", ""SIGNAL""); (""RELEASE"", ""The RELEASE method is related to the SIGNAL variable because the thread calling RELEASE will know that TAKE was called due to the signal being stored."", ""SIGNAL"")"
The compareAndSet() method can compare the reference stored in the AtomicReference instance with an expected reference and if they two references are the same (not equal as in equals() but same as in ==) then a new reference can be set on the AtomicReference instance,"(""compareAndSet"", ""The compareAndSet method is used within the AtomicReference class to compare and set references."", ""AtomicReference"")"
Anders Hejlsberg on checked vs. unchecked exceptions httpwww.artima.comintvhandcuffs.html James Gosling on checked exceptions httpwww.artima.comintvsolid.html Bill Venners on Exceptions httpwww.artima.cominterfacedesignexceptions.html Bruce Eckel on checked exceptions httpwww.artima.comintvtypingP.html Designing with Exceptions (Bill Venners www.artima.com) httpwww.artima.comdesigntechniquesdesexcept.html Effective Java (Joshua Bloch Addison Wesley 2001) Daniel Pietraru in favor of checked exceptions Exceptional Java Checked exceptions are priceless茂驴�?For everything else there is the RuntimeException,"(""Checked Exceptions"", ""Both are types of exceptions discussed in the context of Java programming."", ""Unchecked Exceptions""); (""Checked Exceptions"", ""RuntimeException is mentioned as an alternative to checked exceptions."", ""RuntimeException""); (""Effective Java"", ""Effective Java discusses the use of checked exceptions."", ""Checked Exceptions""); (""Exceptional Java"", ""Exceptional Java is in favor of using checked exceptions."", ""Checked Exceptions"")"
But the thread waiting in the lock() method will not leave that block until the isLocked is set to false and a monitorObject.notify() is executed as it happens in unlock(),"(""Lock"", ""The Lock method is related to the IsLocked method because the thread waiting in the Lock method will not proceed until IsLocked is set to false."", ""IsLocked""); (""MonitorObject"", ""The MonitorObject class is related to the Notify method because the Notify method is executed on a MonitorObject."", ""Notify""); (""Lock"", ""The Lock method is related to the Unlock method because the Unlock method is responsible for setting conditions that allow the Lock method to proceed."", ""Unlock"")"
As you saw in the previous section when you register a Channel with a Selector the register() method returns a SelectionKey objects,"(""Channel"", ""A Channel is registered with a Selector using the register() method."", ""Selector""); (""register"", ""The register() method returns a SelectionKey object."", ""SelectionKey"")"
By walking through all directories and deleting all files (inside visitFile()) in each directory and afterwards delete the directory itself (inside postVisitDirectory()) you can delete a directory with all subdirectories and files,"(""visitFile"", ""Both methods are used in the process of deleting directories and their contents, with visitFile() handling file deletion and postVisitDirectory() handling directory deletion."", ""postVisitDirectory"")"
The lower() method does the opposite of the higher() method meaning it returns the highest element that is less than (not equal to) the given parameter,"(""Lower"", ""The Lower method is related to the Higher method as they perform opposite operations."", ""Higher"")"
In many cases though you can replace the use of the File class with use of the Path interface,"(""File"", ""The File class can be replaced by the Path interface, indicating a relationship where one can substitute the other."", ""Path"")"
Once the Mac instance is initialized you can calculate a MAC from data by calling the update() and doFinal() method,"(""Mac"", ""The update method is called on the Mac class to calculate a MAC from data."", ""update""); (""Mac"", ""The doFinal method is called on the Mac class to complete the MAC calculation."", ""doFinal"")"
Deque.offerFirst(E e) is different from the addFirst() method which will throw an exception is adding an element to the beginning of the Deque fails,"(""offerFirst"", ""Both are methods related to adding elements to the beginning of the Deque class"", ""addFirst""); (""offerFirst"", ""The offerFirst method is a part of the Deque class"", ""Deque""); (""addFirst"", ""The addFirst method is a part of the Deque class"", ""Deque"")"
The main difference between the Runnable run() method and the Callable call() method is that the call() method can return an Object from the method call,"(""Runnable"", ""The run() method is associated with the Runnable class."", ""run()""); (""Callable"", ""The call() method is associated with the Callable class."", ""call()""); (""run()"", ""Both run() and call() are methods that are being compared in terms of their functionality."", ""call()""); (""call()"", ""The call() method can return an Object from the method call."", ""Object"")"
The toNanos() is different from the getNano() in that the getNano() only returns the part of the Duration which is less than one second,"(""toNanos"", ""Both are methods that deal with nanoseconds in the context of time durations."", ""getNano""); (""getNano"", ""getNano is a method that operates on the Duration class."", ""Duration"")"
Collection.add(E e) is different from the offer() method which will return false if it cannot insert the element,"(""Collection"", ""The add method is associated with the Collection class as it is a method that operates on collections."", ""add""); (""Collection"", ""The offer method is associated with the Collection class as it is a method that operates on collections."", ""offer""); (""add"", ""Both add and offer are methods that deal with inserting elements into a collection, indicating a functional relationship."", ""offer"")"
To take an element from a Java Queue you can call either its poll() or remove() method,"(""Queue"", ""The poll method is a function that can be called on a Queue class to take an element from it."", ""poll""); (""Queue"", ""The remove method is a function that can be called on a Queue class to take an element from it."", ""remove"")"
java.util.TreeMap Comparator will then be used to sort the keys of the key value pairs stored in the SortedMap,"(""TreeMap"", ""TreeMap uses Comparator to sort the keys of the key-value pairs."", ""Comparator""); (""TreeMap"", ""TreeMap stores key-value pairs in a SortedMap."", ""SortedMap""); (""TreeMap"", ""TreeMap is part of the java.util package."", ""java.util""); (""Comparator"", ""Comparator is part of the java.util package."", ""java.util""); (""SortedMap"", ""SortedMap is part of the java.util package."", ""java.util"")"
If a thread calls lock() twice without calling unlock() in between the second call to lock() will block,"(""Lock"", ""The Lock method is related to the Unlock method because calling Lock twice without calling Unlock in between will block the second call."", ""Unlock"")"
The start() call will return as soon as the thread is started. It will not wait until the run() method is done.,"(""Start"", ""The Start method initiates the execution of the Run method in a separate thread."", ""Run"")"
"If the Deque is empty, peekFirst() returns null. This is similar to how peek() works, but the method name peekFirst() is a bit more saying about which end of the Deque you peek at.","(""peekFirst"", ""The method peekFirst is used to interact with the Deque class, specifically to peek at the first element."", ""Deque""); (""peek"", ""The method peek is used to interact with the Deque class, similar to peekFirst, but without specifying the end."", ""Deque"")"
If isLocked is true however the thread calling lock() is parked waiting in the monitorObject.wait() call,"(""lock"", ""The method lock() is related to the method wait() as it involves waiting in the monitorObject."", ""wait""); (""monitorObject"", ""The class monitorObject is related to the method wait() as it is used in the wait() call."", ""wait"")"
The remove() method will use the o.equals() to decide if the object o passed as parameter matches a given element in the BlockingQueue.,"(""Remove"", ""The remove() method uses the o.equals() method to determine if the object matches a given element."", ""O.equals""); (""Remove"", ""The remove() method is used to remove elements from the BlockingQueue."", ""BlockingQueue"")"
"In general you can call the?markSupported()?method to find out if?mark()?and?reset()are supported on a given?InputStream?or not, but the?BufferedInputStream?supports them.","(""MarkSupported"", ""The MarkSupported method is used to determine if the Mark method is supported."", ""Mark""); (""MarkSupported"", ""The MarkSupported method is used to determine if the Reset method is supported."", ""Reset""); (""BufferedInputStream"", ""BufferedInputStream supports the Mark method."", ""Mark""); (""BufferedInputStream"", ""BufferedInputStream supports the Reset method."", ""Reset""); (""BufferedInputStream"", ""BufferedInputStream is a type of InputStream."", ""InputStream"")"
If you compare the Lock and FairLock classes you will notice that there is somewhat more going on inside the lock() and unlock() in the FairLock class,"(""FairLock"", ""The method lock() is part of the FairLock class."", ""lock""); (""FairLock"", ""The method unlock() is part of the FairLock class."", ""unlock""); (""Lock"", ""Both Lock and FairLock are classes being compared."", ""FairLock"")"
The third variant of getConnection() takes a database URL and a Properties object as parameter,"(""getConnection"", ""The method getConnection takes a Properties object as a parameter"", ""Properties"")"
"You can get the current line number from the?LineNumberReader?by calling the?getLineNumber()method. You can also set the current line number, should you need to, by calling the?setLineNumber()?method","(""LineNumberReader"", ""The getLineNumber method is called on the LineNumberReader class to retrieve the current line number."", ""getLineNumber""); (""LineNumberReader"", ""The setLineNumber method is called on the LineNumberReader class to set the current line number."", ""setLineNumber"")"
Executing unlock() sets isLocked back to false and notifies (awakens) one of the threads waiting in the wait() call in the lock() method if any,"(""UNLOCK"", ""The unlock() method sets the isLocked class back to false."", ""ISLOCKED""); (""UNLOCK"", ""The unlock() method notifies one of the threads waiting in the wait() method."", ""WAIT""); (""WAIT"", ""The wait() method is called within the lock() method."", ""LOCK"")"
The SimpleDateFormat class does this via a version of the format() method that takes the Date StringBuffer and a FieldPosition instance as parameters,"(""SimpleDateFormat"", ""The format method is a member of the SimpleDateFormat class"", ""format"")"
The getAndIncrement() method does the same as the incrementAndGet() method except the getAndIncrement() method returns the value of the element before it is incremented,"(""GetAndIncrement"", ""Both methods perform similar operations, with the difference being the return value timing."", ""IncrementAndGet"")"
java.util.TreeMap Comparator will then be used to sort the keys of the key value pairs stored in the NavigableMap,"(""TreeMap"", ""TreeMap uses Comparator to sort the keys of the key-value pairs."", ""Comparator""); (""TreeMap"", ""TreeMap stores key-value pairs in a NavigableMap."", ""NavigableMap"")"
In other words the calling thread must call wait() or notify() from inside a synchronized block,"(""WAIT"", ""Both WAIT and NOTIFY are methods that must be called from inside a synchronized block, indicating they are related in terms of synchronization control."", ""NOTIFY""); (""WAIT"", ""WAIT must be called from inside a SYNCHRONIZED BLOCK, indicating a relationship between the method and the class."", ""SYNCHRONIZED BLOCK""); (""NOTIFY"", ""NOTIFY must be called from inside a SYNCHRONIZED BLOCK, indicating a relationship between the method and the class."", ""SYNCHRONIZED BLOCK"")"
As you can see both the waiting and notifying thread calls wait() and notify() from within a synchronized block,"(""WAIT"", ""Both methods are used in thread synchronization within a synchronized block"", ""NOTIFY"")"
However unless you need to specify all these parameters explicitly for your ThreadPoolExecutor it is often easier to use one of the factory methods in the java.util.concurrent.Executors class as shown in the ExecutorService text,"(""java.util.concurrent.Executors"", ""The factory methods are part of the java.util.concurrent.Executors package."", ""factory methods""); (""ThreadPoolExecutor"", ""The factory methods can be used to create or configure a ThreadPoolExecutor."", ""factory methods""); (""ExecutorService"", ""The factory methods are used in the context of ExecutorService."", ""factory methods"")"
"You can choose between the following Deque implementations in the Java Collections API:java.util.LinkedList,java.util.ArrayDeque","(""Deque"", ""java.util.LinkedList is an implementation of the Deque class"", ""java.util.LinkedList""); (""Deque"", ""java.util.ArrayDeque is an implementation of the Deque class"", ""java.util.ArrayDeque""); (""java.util.LinkedList"", ""java.util.LinkedList is part of the Java Collections API package"", ""Java Collections API""); (""java.util.ArrayDeque"", ""java.util.ArrayDeque is part of the Java Collections API package"", ""Java Collections API"")"
Put shortly the thread waiting in lock() needs an unlock() call to execute successfully for it to exit lock() and the synchronized blocks inside it,"(""lock"", ""The method 'lock' requires the method 'unlock' to be called for it to execute successfully and exit."", ""unlock""); (""lock"", ""The method 'lock' contains synchronized blocks inside it."", ""synchronized blocks"")"
Java NIO has more classes and components than these but the Channel Buffer and Selector forms the core of the API in my opinion,"(""Java NIO"", ""Channel is a core component of the Java NIO package."", ""Channel""); (""Java NIO"", ""Buffer is a core component of the Java NIO package."", ""Buffer""); (""Java NIO"", ""Selector is a core component of the Java NIO package."", ""Selector"")"
The DateTimeFormatter is located in the java.time.format package so the fully qualified class name is java.time.format.DateTimeFormatter,"(""DateTimeFormatter"", ""The DateTimeFormatter class is located in the java.time.format package."", ""java.time.format"")"
The ceilingEntry() is thus similar to the ceilingKey() method except the ceilingKey() method only returns the key and ceilingKey() returns a Map.Entry object containing both the key and value,"(""CeilingEntry"", ""CeilingEntry is similar to CeilingKey as both are methods dealing with ceiling operations."", ""CeilingKey""); (""CeilingKey"", ""CeilingKey returns a Map.Entry object, indicating a relationship between the method and the class."", ""Map.Entry"")"
"unless you need to specify all these parameters explicitly for your ThreadPoolExecutor, it is often easier to use one of the factory methods in the java.util.concurrent.Executors class","(""factory methods"", ""The factory methods are part of the java.util.concurrent.Executors class."", ""java.util.concurrent.Executors""); (""ThreadPoolExecutor"", ""The factory methods can be used to create or configure a ThreadPoolExecutor."", ""factory methods"")"
Once the read operation has completed the data read into the ByteBuffer and then into a String and printed to System.out,"(""ByteBuffer"", ""Data is read from ByteBuffer into a String"", ""String""); (""String"", ""String is printed to System.out"", ""System.out"")"
javax.lang.model.util.Elements is possible to specify generic types for most (if not all) of the components in the Java Collections API,"(""Elements"", ""Elements is a class that can specify generic types for components in the Java Collections API"", ""Java Collections API"")"
The Java PrintWriter class contains the powerful format() and printf() methods,"(""PrintWriter"", ""The method 'format' is part of the 'PrintWriter' class"", ""format""); (""PrintWriter"", ""The method 'printf' is part of the 'PrintWriter' class"", ""printf"")"
If an InputStream subclass supports the mark() and reset() methods then that subclass should override the markSupported() to return true,"(""InputStream"", ""The InputStream class supports the mark method."", ""mark""); (""InputStream"", ""The InputStream class supports the reset method."", ""reset""); (""InputStream"", ""The InputStream class should override the markSupported method."", ""markSupported"")"
Not until a thread has called release() will the thread calling take() be allowed to deliver its signal,"(""RELEASE"", ""The method RELEASE must be called by a thread before the method TAKE can deliver its signal."", ""TAKE"")"
The poll() and remove() both removes the first element in the Queue. They differ in how they behave if the Queue is empty. The poll() method returns null if the Queue is empty. The remove() method throws an exception if the Queue is empty.,"(""Poll"", ""The Poll method operates on the Queue class by removing the first element."", ""Queue""); (""Remove"", ""The Remove method operates on the Queue class by removing the first element."", ""Queue""); (""Poll"", ""Both Poll and Remove methods are used to remove the first element in the Queue, but they differ in behavior when the Queue is empty."", ""Remove"")"
Notice how the execute() method will throw an IllegalStateException if execute() is called after stop() has been called,"(""Execute"", ""The Execute method will throw an IllegalStateException if it is called after the Stop method has been called."", ""IllegalStateException""); (""Execute"", ""The Execute method is related to the Stop method because calling Execute after Stop has been called will result in an IllegalStateException."", ""Stop"")"
The methods hashCode() and equals() play a distinct role in the objects you insert into Java collections,"(""HASHCODE"", ""HASHCODE is a method that affects how objects are stored and retrieved in JAVA COLLECTIONS"", ""JAVA COLLECTIONS""); (""EQUALS"", ""EQUALS is a method that determines object equality, impacting their behavior in JAVA COLLECTIONS"", ""JAVA COLLECTIONS"")"
Notice the two synchronized blocks inside the set() and get() method,"(""Set"", ""Both methods are mentioned together in the context of synchronized blocks, indicating they are related in functionality or usage."", ""Get"")"
Therefore if a thread calls notify() before the thread to signal has called wait() the signal will be missed by the waiting thread,"(""Notify"", ""Notify and Wait are related because Notify is used to signal a thread that is waiting, which is done using the Wait method."", ""Wait"")"
"celingEntry(), floorEntry(), higherEntry(), lowerEntry(),These methods behave like the ceilingKey() etc. methods, except they return a Map.Entry instead of the key object itself.","(""celingEntry()"", ""The method celingEntry() returns a Map.Entry object."", ""Map.Entry""); (""floorEntry()"", ""The method floorEntry() returns a Map.Entry object."", ""Map.Entry""); (""higherEntry()"", ""The method higherEntry() returns a Map.Entry object."", ""Map.Entry""); (""lowerEntry()"", ""The method lowerEntry() returns a Map.Entry object."", ""Map.Entry""); (""celingEntry()"", ""The method celingEntry() behaves like the ceilingKey() method."", ""ceilingKey()""); (""floorEntry()"", ""The method floorEntry() behaves like the ceilingKey() method."", ""ceilingKey()""); (""higherEntry()"", ""The method higherEntry() behaves like the ceilingKey() method."", ""ceilingKey()""); (""lowerEntry()"", ""The method lowerEntry() behaves like the ceilingKey() method."", ""ceilingKey()"")"
By default the ConsoleHandler uses a SimpleFormatter to format the messages before writing them to System.err,"(""ConsoleHandler"", ""ConsoleHandler uses SimpleFormatter to format messages"", ""SimpleFormatter""); (""ConsoleHandler"", ""ConsoleHandler writes messages to System.err"", ""System.err"")"
The hashCode() method of objects is used when you insert them into a HashTable HashMap or HashSet,"(""HashCode"", ""The HashCode method is a method of the Objects class."", ""Objects""); (""HashCode"", ""The HashCode method is used when inserting objects into a HashTable."", ""HashTable""); (""HashCode"", ""The HashCode method is used when inserting objects into a HashMap."", ""HashMap""); (""HashCode"", ""The HashCode method is used when inserting objects into a HashSet."", ""HashSet"")"
So as you can see a combination of the hashCode() and equals() methods are used when storing and when looking up objects in a hashtable,"(""HashCode"", ""Both methods are used together when storing and looking up objects in a hashtable."", ""Equals""); (""HashCode"", ""The hashCode method is used when storing and looking up objects in a hashtable."", ""Hashtable""); (""Equals"", ""The equals method is used when storing and looking up objects in a hashtable."", ""Hashtable"")"
Here is a modified version of MySignal called MyWaitNotify that uses wait() and notify(),"(""MyWaitNotify"", ""The class MyWaitNotify uses the method wait()."", ""wait()""); (""MyWaitNotify"", ""The class MyWaitNotify uses the method notify()."", ""notify()"")"
To set a new System stream use one of th emethods System.setIn() System.setOut() or System.setErr(),"(""System"", ""The method setIn is a part of the System class, used to set the input stream."", ""setIn""); (""System"", ""The method setOut is a part of the System class, used to set the output stream."", ""setOut""); (""System"", ""The method setErr is a part of the System class, used to set the error stream."", ""setErr"")"
"The add() and offer() methods differ in how the behave if the Queue is full, so no more elements can be added. The add() method throws an exception in that case, whereas the offer() method just returns false.","(""Add"", ""The Add method is related to the Queue class as it is a method that operates on a Queue."", ""Queue""); (""Offer"", ""The Offer method is related to the Queue class as it is a method that operates on a Queue."", ""Queue"")"
Both the Pattern and Matcher classes are covered in detail in their own texts,"(""Pattern"", ""Both are classes that are covered in detail in their own texts"", ""Matcher"")"
The Java Set interface as a method called removeAll() which removes all elements in the Set which are also present in another Collection,"(""Set"", ""The removeAll method is a part of the Set class, as it is a method that operates on Set instances."", ""removeAll""); (""removeAll"", ""The removeAll method interacts with the Collection class by removing elements from the Set that are also present in another Collection."", ""Collection"")"
The Map compute() method takes a key object and a lambda expression as parameters. The lambda expression must implement the java.util.function.BiFunction interface.,"(""Map"", ""The compute method is a part of the Map class."", ""compute""); (""compute"", ""The compute method uses a lambda expression that must implement an interface from the java.util.function package."", ""java.util.function""); (""java.util.function"", ""The BiFunction interface is part of the java.util.function package."", ""BiFunction""); (""compute"", ""The compute method requires a lambda expression that implements the BiFunction interface."", ""BiFunction"")"
java.text.CollationKey is faster than the stringwise comparison the RuleBasedCollator uses normally,"(""CollationKey"", ""CollationKey is used for faster comparison than the stringwise comparison normally used by RuleBasedCollator"", ""RuleBasedCollator"")"
The ForkJoinPool located in the java.util.concurrent package so the full class name is java.util.concurrent.ForkJoinPool,"(""ForkJoinPool"", ""ForkJoinPool is a class located in the java.util.concurrent package"", ""java.util.concurrent"")"
Notice how notifyAll() is only called from enqueue() and dequeue() if the queue size is equal to the size bounds (0 or limit),"(""NotifyAll"", ""NotifyAll is called from Enqueue when certain conditions are met."", ""Enqueue""); (""NotifyAll"", ""NotifyAll is called from Dequeue when certain conditions are met."", ""Dequeue"")"
In other words you can add all elements from a List or Set into a List with addAll(),"(""addAll"", ""The addAll method is used to add elements into a List."", ""List""); (""addAll"", ""The addAll method can add elements from a Set into a List."", ""Set""); (""List"", ""Elements from a Set can be added into a List using the addAll method."", ""Set"")"
Since only one thread is allowed to take the semaphore all other threads calling take() will be blocked until release() is called,"(""Semaphore"", ""The method Take is called on the Semaphore class, indicating a relationship where Take is a method of Semaphore."", ""Take""); (""Semaphore"", ""The method Release is called on the Semaphore class, indicating a relationship where Release is a method of Semaphore."", ""Release""); (""Take"", ""The methods Take and Release are related as they are both operations that manage the state of the Semaphore, with Take blocking threads and Release allowing them to proceed."", ""Release"")"
The format() and printf() methods allow you to mix text and data in very advanced ways using a formatting string,"(""FORMAT"", ""Both FORMAT and PRINTF are methods that allow text and data formatting."", ""PRINTF"")"
The Collections replaceAll() method uses the equals() method of each element to determine if the element is equal to the element to replace or not,"(""Collections"", ""The replaceAll method is a part of the Collections class."", ""replaceAll""); (""replaceAll"", ""The replaceAll method uses the equals method to determine if an element is equal to the element to replace."", ""equals"")"
The call to unread() pushes a character back into the PushbackReader. The next time read() is called the pushed back characters will be read first.,"(""Unread"", ""The method Unread is used to push a character back into the Pushbackreader class."", ""Pushbackreader""); (""Read"", ""The method Read is called on the Pushbackreader class to read characters, including those pushed back by Unread."", ""Pushbackreader"")"
java.sql.ResultSet ResultSet has 3 different columns (Name Age Gender) and 3 records with different values for each column,"(""ResultSet"", ""Name is a column in the ResultSet class"", ""Name""); (""ResultSet"", ""Age is a column in the ResultSet class"", ""Age""); (""ResultSet"", ""Gender is a column in the ResultSet class"", ""Gender"")"
First the ResourceBundle class will look for a ListResourceBundle and then for a PropertyResourceBundle,"(""ResourceBundle"", ""ResourceBundle class looks for a ListResourceBundle"", ""ListResourceBundle""); (""ResourceBundle"", ""ResourceBundle class looks for a PropertyResourceBundle"", ""PropertyResourceBundle"")"
The returned long value can be used to initialize java.util.Date java.sql.Date java.sql.Timestamp and java.util.GregorianCalendar objects,"(""Long"", ""The Long class is used to initialize Java.util.Date objects."", ""Java.util.Date""); (""Long"", ""The Long class is used to initialize Java.sql.Date objects."", ""Java.sql.Date""); (""Long"", ""The Long class is used to initialize Java.sql.Timestamp objects."", ""Java.sql.Timestamp""); (""Long"", ""The Long class is used to initialize Java.util.GregorianCalendar objects."", ""Java.util.GregorianCalendar"")"
In fact the implementation of the ExecutorService interface present in the java.util.concurrent package is a thread pool implementation,"(""ExecutorService"", ""ExecutorService is implemented within the java.util.concurrent package"", ""java.util.concurrent"")"
Notice how the Collections.sort() method now takes a java.util.Comparator as parameter in addition to the List,"(""Collections.sort()"", ""The Collections.sort() method takes a java.util.Comparator as a parameter."", ""java.util.Comparator""); (""Collections.sort()"", ""The Collections.sort() method takes a List as a parameter."", ""List"")"
For instance ordinary debug trace logging calls to entering() and exiting() would be called at the beginning and end of a method call,"(""ENTERING"", ""Both are methods used for logging at the beginning and end of a method call"", ""EXITING"")"
Each of the methods ceilingEntry() floorEntry() higherEntry() and lowerEntry() will be covered in the following sections,"(""CeilingEntry"", ""Both are methods that will be covered in the following sections"", ""FloorEntry""); (""CeilingEntry"", ""Both are methods that will be covered in the following sections"", ""HigherEntry""); (""CeilingEntry"", ""Both are methods that will be covered in the following sections"", ""LowerEntry""); (""FloorEntry"", ""Both are methods that will be covered in the following sections"", ""HigherEntry""); (""FloorEntry"", ""Both are methods that will be covered in the following sections"", ""LowerEntry""); (""HigherEntry"", ""Both are methods that will be covered in the following sections"", ""LowerEntry"")"
java.text.SimpleDateFormat is not exactly clear how the FieldPosition instance is used,"(""SimpleDateFormat"", ""The text suggests that the SimpleDateFormat class interacts with the FieldPosition class, indicating a relationship between them."", ""FieldPosition"")"
The LocalDate Java class is located in the java.time package so its fully qualified class name is java.time.LocalDate,"(""LocalDate"", ""The LocalDate class is located in the java.time package, indicating that it belongs to this package."", ""java.time"")"
If there is no more data to read from the underlying Reader then the BufferedReader readLine() method will return null,"(""BufferedReader"", ""The readLine method belongs to the BufferedReader class."", ""readLine""); (""BufferedReader"", ""BufferedReader reads data from the underlying Reader."", ""Reader"")"
java.util.List is different from a Java Set where each element can occur only once,"(""Java.util.List"", ""Both are Java collection classes with different characteristics regarding element uniqueness"", ""Java Set"")"
Deque.addLast(E e) is different from the offerLast() method which will return false if the element cannot be added to the Deque,"(""addLast"", ""Both are methods related to adding elements to the Deque class, but they have different behaviors when the element cannot be added."", ""offerLast""); (""Deque"", ""The addLast method is a part of the Deque class."", ""addLast""); (""Deque"", ""The offerLast method is a part of the Deque class."", ""offerLast"")"
Do not confuse this class with the java.util.Arrays class in the Java Collections suite which contains utility methods for sorting arrays converting them to collections etc,"(""Java.util.Arrays"", ""The Java.util.Arrays class is part of the Java Collections package."", ""Java Collections""); (""Sorting"", ""The Sorting method is a utility method provided by the Java.util.Arrays class."", ""Java.util.Arrays""); (""Converting"", ""The Converting method is a utility method provided by the Java.util.Arrays class."", ""Java.util.Arrays"")"
You obtain a Collection of the values stored in a Map via the values() method,"(""values"", ""The values() method is used to obtain the values stored in a Map."", ""Map""); (""Collection"", ""The values() method returns a Collection of the values."", ""values"")"
Unfortunately if an exception is thrown during the write() call in the example above that exception will cause the program flow to break before the close() method is called,"(""WRITE"", ""The WRITE method is called before the CLOSE method in the program flow."", ""CLOSE"")"
Being a subclass of Hashtable you can actually use the get() and put() method of the Hashtable class which allow the use of nonstring keys and values,"(""Hashtable"", ""The get() method is a method of the Hashtable class."", ""get()""); (""Hashtable"", ""The put() method is a method of the Hashtable class."", ""put()"")"
"A Java Properties instance clearly is as Hashtable, but it should not share the Hashtable interface. So - the ""Is a"" part of this rule should be interpreted as ""Should be usable as a"" instead. Using that formulation, Properties would not have been made a subclass of Hashtable, because Properties should not be usable as a Hashtable .","(""Properties"", ""Properties is related to Hashtable because it is mentioned as a subclass of Hashtable, indicating an inheritance relationship."", ""Hashtable"")"
"I mean, only the same, single thread is ever allowed to call inc(). Multiple threads can call count().","(""Inc"", ""Both are methods that can be called by threads, with Inc being restricted to a single thread and Count being accessible by multiple threads."", ""Count"")"
"If the Deque is empty, poll() returns null. This is different than remove() which throws an exception if the Deque is empty.","(""Poll"", ""Poll is a method that operates on the Deque class."", ""Deque""); (""Remove"", ""Remove is a method that operates on the Deque class."", ""Deque"")"
The peek() works like the element() method except it does not throw an exception if the Queue is empty. Instead it just returns null.,"(""PEEK"", ""The PEEK method works like the ELEMENT method, indicating a functional similarity or equivalence."", ""ELEMENT""); (""PEEK"", ""The PEEK method is used in the context of a QUEUE, as it checks if the QUEUE is empty."", ""QUEUE"")"
Notice the doStop() and keepRunning() methods. The doStop() is intended to be called from another thread than the thread executing the MyRunnable's run() method. The keepRunning() method is called internally by the thread executing the MyRunnable's run() method. As long as doStop() has not been called the keepRunning() method will return true - meaning the thread executing the run() method will keep running.,"(""doStop"", ""The doStop() method affects the behavior of the keepRunning() method by determining when it should return true or false."", ""keepRunning""); (""doStop"", ""The doStop() method is intended to be called from a different thread than the one executing the run() method."", ""run""); (""keepRunning"", ""The keepRunning() method is called internally by the thread executing the run() method."", ""run""); (""MyRunnable"", ""The run() method is a part of the MyRunnable class."", ""run"")"
System.err works like System.out except it is normally only used to output error texts,"(""System.err"", ""System.err and System.out are related because they both are classes used for output, with System.err specifically for error texts."", ""System.out"")"
To do so set the upper bound to 1 and have the call to take() and release() guard the critical section,"(""take"", ""Both methods are used to guard the critical section, indicating they are related in managing access to shared resources."", ""release"")"
java.io.InputStream method is useful if you need to read all bytes from a file via a FileInputStream into a byte array,"(""InputStream"", ""InputStream is a class within the java.io package."", ""java.io""); (""FileInputStream"", ""FileInputStream is a class within the java.io package."", ""java.io""); (""read"", ""The read method is associated with the InputStream class for reading bytes."", ""InputStream""); (""FileInputStream"", ""FileInputStream is a subclass of InputStream, used to read bytes from a file."", ""InputStream"")"
Notice how the getMonth() and getDayOfWeek() methods return an enum instead of an int,"(""GetMonth"", ""Both are methods mentioned in the text that return an enum instead of an int"", ""GetDayOfWeek"")"
java.io.InputStreamReader example first creates a FileInputStream and then wraps it in an InputStreamReader,"(""FileInputStream"", ""FileInputStream is wrapped in an InputStreamReader, indicating a relationship where InputStreamReader uses FileInputStream."", ""InputStreamReader""); (""InputStreamReader"", ""InputStreamReader is part of the java.io package."", ""java.io"")"
Deque.offerLast(E e) is different from the addLast() method which will throw an exception is adding an element to the end of the Deque fails,"(""offerLast"", ""Both are methods related to adding elements to the end of the Deque class"", ""addLast""); (""Deque"", ""offerLast is a method of the Deque class"", ""offerLast""); (""Deque"", ""addLast is a method of the Deque class"", ""addLast"")"
Java has 3 streams called System.in System.out and System.err which are commonly used to provide input to and output from Java applications,"(""Java"", ""System.in is a class used within the Java package for input operations."", ""System.in""); (""Java"", ""System.out is a class used within the Java package for output operations."", ""System.out""); (""Java"", ""System.err is a class used within the Java package for error output operations."", ""System.err""); (""System.in"", ""System.in and System.out are related as they both handle input and output operations in Java."", ""System.out""); (""System.out"", ""System.out and System.err are related as they both handle output operations, with System.err specifically for error output."", ""System.err"")"
To access a private field you will need to call the Class.getDeclaredField(String name) or Class.getDeclaredFields() method,"(""Class"", ""The getDeclaredField method is a method of the Class class, used to access a specific field by name."", ""getDeclaredField""); (""Class"", ""The getDeclaredFields method is a method of the Class class, used to access all declared fields."", ""getDeclaredFields"")"
"If the Deque is empty, pollFirst() returns null. This is different than removeFirst() which throws an exception if the Deque is empty.","(""pollFirst"", ""The method pollFirst is associated with the Deque class as it operates on it."", ""Deque""); (""removeFirst"", ""The method removeFirst is associated with the Deque class as it operates on it."", ""Deque""); (""pollFirst"", ""Both pollFirst and removeFirst are methods that handle the situation when the Deque is empty, but they behave differently."", ""removeFirst"")"
Once you have opened a socket (network connection) though you read and write data to and from it via Java IO InputStream and OutputStream classes,"(""Socket"", ""The InputStream class is used to read data from a Socket."", ""InputStream""); (""Socket"", ""The OutputStream class is used to write data to a Socket."", ""OutputStream""); (""Java IO"", ""The InputStream class is part of the Java IO package."", ""InputStream""); (""Java IO"", ""The OutputStream class is part of the Java IO package."", ""OutputStream"")"
java.util.Set is different from a Java List where each element can occur more than once,"(""Java.util.Set"", ""Java.util.Set and Java List are both classes in Java collections framework, but they have different characteristics regarding element uniqueness."", ""Java List"")"
Keep in mind that if some of the operations in the transaction fail you would most likely want to call the rollback() method instead of commit(),"(""Rollback"", ""Both are methods used in transaction management, where Rollback is used to undo operations if a transaction fails, and Commit is used to finalize successful transactions."", ""Commit"")"
The min() and max() methods return an Optional instance which has a get() method on which you use to obtain the value,"(""Min"", ""The Min method returns an Optional instance."", ""Optional""); (""Max"", ""The Max method returns an Optional instance."", ""Optional""); (""Optional"", ""The Optional class has a Get method to obtain the value."", ""Get"")"
Only one thread can execute inside any of the two add() and subtract() methods at any given time,"(""Add"", ""Both methods are mentioned as being mutually exclusive in terms of execution by a single thread."", ""Subtract"")"
A Java Callable is different from a Runnable in that the Runnable interface run() method does not return a value and it cannot throw checked exceptions (only RuntimeExceptions),"(""Java Callable"", ""Java Callable is compared to Runnable in terms of functionality differences"", ""Runnable""); (""Runnable interface"", ""The run() method is part of the Runnable interface"", ""run()"")"
The ConcurrentHashMap is very similar to the java.util.HashTable class except that ConcurrentHashMap offers better concurrency than HashTable does,"(""ConcurrentHashMap"", ""ConcurrentHashMap is compared to java.util.HashTable in terms of concurrency features"", ""java.util.HashTable""); (""ConcurrentHashMap"", ""ConcurrentHashMap offers better concurrency than HashTable"", ""ConcurrentHashMap"")"
You shut down a ScheduledExecutorService using the shutdown() or shutdownNow() methods which are inherited from the ExecutorService interface,"(""ScheduledExecutorService"", ""The shutdown method is used to shut down a ScheduledExecutorService."", ""shutdown""); (""ScheduledExecutorService"", ""The shutdownNow method is used to shut down a ScheduledExecutorService."", ""shutdownNow""); (""ScheduledExecutorService"", ""ScheduledExecutorService inherits methods from the ExecutorService interface."", ""ExecutorService""); (""shutdown"", ""The shutdown method is inherited from the ExecutorService interface."", ""ExecutorService""); (""shutdownNow"", ""The shutdownNow method is inherited from the ExecutorService interface."", ""ExecutorService"")"
It is the last line of this example that calls the List stream() method to obtain the Stream representing the elements in the List.Once you have obtained a Stream from a List you can iterate the Stream by calling its forEach() method.,"(""List"", ""The stream() method is called on the List class to obtain a Stream."", ""stream()""); (""Stream"", ""The forEach() method is used to iterate over the elements in the Stream."", ""forEach()"")"
Using that formulation Properties would not have been made a subclass of Hashtable because Properties should not be usable as a Hashtable,"(""Properties"", ""Properties is mentioned as a subclass of Hashtable, indicating a relationship between the two classes"", ""Hashtable"")"
Many of the core components in the Java Collection API rely on the correct implementation of the `hashCode()` and `equals()` methods.,"(""Java Collection API"", ""The hashCode method is a core component that the Java Collection API relies on for correct implementation."", ""hashCode""); (""Java Collection API"", ""The equals method is a core component that the Java Collection API relies on for correct implementation."", ""equals"")"
System.in System.out and System.err are initialized by the Java runtime when a Java VM starts up so you dont have to instantiate any streams yourself (although you can exchange them at runtime),"(""Java runtime"", ""Java runtime initializes the Java VM when it starts up"", ""Java VM""); (""System.in"", ""System.in is initialized by the Java runtime"", ""Java runtime""); (""System.out"", ""System.out is initialized by the Java runtime"", ""Java runtime""); (""System.err"", ""System.err is initialized by the Java runtime"", ""Java runtime""); (""System.in"", ""System.in is available when a Java VM starts up"", ""Java VM""); (""System.out"", ""System.out is available when a Java VM starts up"", ""Java VM""); (""System.err"", ""System.err is available when a Java VM starts up"", ""Java VM"")"
"In case the write() method throws an exception, the close() method will never get called.","(""WRITE"", ""The CLOSE method is mentioned as not being called if the WRITE method throws an exception."", ""CLOSE"")"
You create a Path instance using a static method in the Paths class (java.nio.file.Paths) named Paths.get(),"(""Paths"", ""The method Paths.get() is a static method in the Paths class."", ""Paths.get()""); (""java.nio.file.Paths"", ""The Paths class is part of the java.nio.file.Paths package."", ""Paths""); (""Path"", ""The Paths.get() method is used to create an instance of the Path class."", ""Paths.get()"")"
"If no permits are available, the acquire() call will block until a permit is released by another thread. Similarly, a release() calls is blocked if no more permits can be released into this semaphore.","(""acquire"", ""The acquire() method is related to the release() method as they both manage permits in a semaphore, with acquire() blocking until a permit is available and release() adding a permit back."", ""release"")"
The submaps are the maps returned by various methods like headMap() subMap() and tailMap(),"(""headMap"", ""Both are methods that return submaps."", ""subMap""); (""headMap"", ""Both are methods that return submaps."", ""tailMap""); (""subMap"", ""Both are methods that return submaps."", ""tailMap"")"
If your Java SortedMap was created using a Comparator you can obtain the Comparator used via the SortedMap comparator() method,"(""SortedMap"", ""The SortedMap class can be created using a Comparator, indicating a relationship where Comparator is used in the creation of SortedMap."", ""Comparator""); (""SortedMap"", ""The comparator() method is associated with the SortedMap class, allowing retrieval of the Comparator used."", ""comparator"")"
You can change this pattern later using the applyPattern() or applyLocalizedPattern() method,"(""applyPattern"", ""Both are methods that can be used to change the pattern"", ""applyLocalizedPattern"")"
The AtomicBoolean class is located in the java.util.concurrent.atomic package so the full class name is java.util.concurrent.atomic.AtomicBoolean,"(""AtomicBoolean"", ""The AtomicBoolean class is part of the java.util.concurrent.atomic package."", ""java.util.concurrent.atomic"")"
java.io.InputStreamReader example creates a FileInputStream and wraps it in a InputStreamReader,"(""java.io"", ""InputStreamReader is part of the java.io package"", ""InputStreamReader""); (""FileInputStream"", ""FileInputStream is wrapped in an InputStreamReader"", ""InputStreamReader"")"
When the process() method of the subclass is called the full process is executed including the stepBefore() and stepAfter() of the abstract superclass and the action() method of the subclass,"(""PROCESS"", ""The process method is a method of the subclass."", ""SUBCLASS""); (""STEPBEFORE"", ""The stepBefore method is part of the abstract superclass."", ""SUPERCLASS""); (""STEPAFTER"", ""The stepAfter method is part of the abstract superclass."", ""SUPERCLASS""); (""ACTION"", ""The action method is a method of the subclass."", ""SUBCLASS""); (""PROCESS"", ""The process method includes the execution of the stepBefore method."", ""STEPBEFORE""); (""PROCESS"", ""The process method includes the execution of the stepAfter method."", ""STEPAFTER""); (""PROCESS"", ""The process method includes the execution of the action method."", ""ACTION"")"
If you want to set a different offset for the dest byte array there is a version of update() and doFinal() which takes an offset parameter extra,NULL
java.security.cert.X509Certificate class represents an X.509 certificate which is used as identity certificate in HTTPS and TLS,"(""X509Certificate"", ""The X509Certificate class is part of the java.security.cert package."", ""java.security.cert"")"
java.io.PrintWriter example first creates a PrintWriter instance which is connected to a FileWriter,"(""Java.io.PrintWriter"", ""PrintWriter is a class within the Java.io.PrintWriter package"", ""PrintWriter""); (""PrintWriter"", ""PrintWriter is connected to a FileWriter instance"", ""FileWriter"")"
The Java CharArrayReader is handy when you have data in a char array but need to pass that data to some component which can only read from a Reader (or a Reader subclass),"(""CharArrayReader"", ""CharArrayReader is a subclass of Reader"", ""Reader""); (""CharArrayReader"", ""CharArrayReader is used to pass data to components that can read from a Reader"", ""Reader"")"
The compareAndSet() method can compare the reference stored in the AtomicStampedReference instance with an expected reference and the stored stamp with an expected stamp and if they two references and stamps are the same (not equal as in equals() but same as in ==) then a new reference can be set on the AtomicStampedReference instance,"(""CompareAndSet"", ""The CompareAndSet method is used to compare and set references within the AtomicStampedReference class."", ""AtomicStampedReference""); (""CompareAndSet"", ""The CompareAndSet method operates on instances of the AtomicStampedReference class to perform its operations."", ""AtomicStampedReference"")"
The BoundedSemaphore class shown below has two testandset methods take() and release(),"(""BoundedSemaphore"", ""The BoundedSemaphore class contains the testandset method."", ""testandset""); (""BoundedSemaphore"", ""The BoundedSemaphore class contains the take method."", ""take""); (""BoundedSemaphore"", ""The BoundedSemaphore class contains the release method."", ""release""); (""testandset"", ""The testandset method is related to the take method as they are both mentioned together."", ""take""); (""testandset"", ""The testandset method is related to the release method as they are both mentioned together."", ""release"")"
For a 100% precise description of how to implement equals() and hashCode() you should check out the official JavaDoc,"(""equals()"", ""Both are methods that are often implemented together to ensure correct behavior in collections."", ""hashCode()""); (""equals()"", ""The JavaDoc provides official documentation on how to implement the equals() method."", ""JavaDoc""); (""hashCode()"", ""The JavaDoc provides official documentation on how to implement the hashCode() method."", ""JavaDoc"")"
You could view the LocalDateTime as a combination of the LocalDate and LocalTime classes of the Java 8 date time API,"(""LocalDateTime"", ""LocalDateTime is a combination of the LocalDate class."", ""LocalDate""); (""LocalDateTime"", ""LocalDateTime is a combination of the LocalTime class."", ""LocalTime""); (""LocalDateTime"", ""LocalDateTime is part of the Java 8 date time API package."", ""Java 8 date time API""); (""LocalDate"", ""LocalDate is part of the Java 8 date time API package."", ""Java 8 date time API""); (""LocalTime"", ""LocalTime is part of the Java 8 date time API package."", ""Java 8 date time API"")"
InputStream.read() example creates an AsynchronousFileChannel and then creates a ByteBuffer which is passed to the read() method as parameter along with a position of 0,"(""InputStream"", ""The read method is associated with the InputStream class as it is a method that operates on input streams."", ""read""); (""AsynchronousFileChannel"", ""The ByteBuffer is used in conjunction with the AsynchronousFileChannel to read data asynchronously."", ""ByteBuffer""); (""read"", ""The read method takes ByteBuffer as a parameter to store the data being read."", ""ByteBuffer"")"
When the thread that locked the Lock in the first place tries to unlock it by calling unlock() it will be blocked trying to enter the synchronized(this) block in the unlock() method,"(""unlock"", ""The unlock method is related to the synchronized block because it attempts to enter this block when trying to unlock the Lock."", ""synchronized""); (""Lock"", ""The unlock method is used to unlock the Lock class, indicating a direct functional relationship."", ""unlock"")"
Of course you could do this with the start() and end() methods but it is easier to do so with the group functions,"(""START"", ""Both are methods mentioned together as alternatives for achieving a task."", ""END""); (""START"", ""Both are methods mentioned in the context of performing similar tasks."", ""GROUP""); (""END"", ""Both are methods mentioned in the context of performing similar tasks."", ""GROUP"")"
java.lang.StringBuffer text explains how to use the SimpleDateFormat class to format dates,"(""StringBuffer"", ""StringBuffer is part of the java.lang package"", ""java.lang""); (""SimpleDateFormat"", ""SimpleDateFormat is part of the java.lang package"", ""java.lang""); (""StringBuffer"", ""The text explains how to use the SimpleDateFormat class, which may involve using StringBuffer for string manipulation"", ""SimpleDateFormat"")"
The Java?ExecutorService?submit(Callable)?method is similar to the?submit(Runnable)?method except it takes a?Java Callable?instead of a?Runnable.?,"(""ExecutorService"", ""The submit method is a part of the ExecutorService class."", ""submit""); (""submit"", ""The submit method can take a Callable as an argument."", ""Callable""); (""submit"", ""The submit method can also take a Runnable as an argument."", ""Runnable"")"
Just to make it clear You should NOT use the put() and get() method of the Properties class!,"(""PUT"", ""The PUT method is a method of the PROPERTIES class."", ""PROPERTIES""); (""GET"", ""The GET method is a method of the PROPERTIES class."", ""PROPERTIES"")"
The Java compiler auto generates getter methods toString() hashcode() and equals() methods for these data fields so you dont have to write that boilerplate code yourself,"(""Java Compiler"", ""The Java compiler auto generates getter methods."", ""Getter Methods""); (""Java Compiler"", ""The Java compiler auto generates the toString() method."", ""ToString""); (""Java Compiler"", ""The Java compiler auto generates the hashcode() method."", ""Hashcode""); (""Java Compiler"", ""The Java compiler auto generates the equals() method."", ""Equals"")"
java.nio.channels.Selector means that you cannot use FileChannel with a Selector since FileChannel cannot be switched into nonblocking mode,"(""FileChannel"", ""FileChannel cannot be used with Selector because it cannot be switched into nonblocking mode"", ""Selector"")"
Just set a new InputStream for System.in or a new OutputStream for System.out or System.err and all further data will be read written to the new stream,"(""InputStream"", ""System.in is a method that can be set with a new InputStream to change the input stream source."", ""System.in""); (""OutputStream"", ""System.out is a method that can be set with a new OutputStream to change the output stream destination."", ""System.out""); (""OutputStream"", ""System.err is a method that can be set with a new OutputStream to change the error stream destination."", ""System.err"")"
Creating a pipe using Java IO is done via the PipedOutputStream and PipedInputStream classes,"(""PipedOutputStream"", ""PipedOutputStream and PipedInputStream are related as they are used together to create a pipe in Java IO"", ""PipedInputStream""); (""PipedOutputStream"", ""PipedOutputStream is a class within the Java IO package"", ""Java IO""); (""PipedInputStream"", ""PipedInputStream is a class within the Java IO package"", ""Java IO"")"
The biggest difference between java.sql.Date and java.sql.Timestamp is that the java.sql.Date only keeps the date not the time of the date it represents,"(""Java.Sql.Date"", ""Java.Sql.Date and Java.Sql.Timestamp are related because they are both classes in the java.sql package and represent date and time data types."", ""Java.Sql.Timestamp"")"
Since the parameters of the Finder.find() and MyClass.doFind() methods match it is possible to create a lambda expression that implements Finder.find() and references the MyClass.doFind() method,"(""Finder.find()"", ""The parameters of both methods match, allowing a lambda expression to implement Finder.find() and reference MyClass.doFind()."", ""MyClass.doFind()""); (""Finder.find()"", ""Finder.find() is a method belonging to the Finder class."", ""Finder""); (""MyClass.doFind()"", ""MyClass.doFind() is a method belonging to the MyClass class."", ""MyClass"")"
Here is an example of obtaining the Comparator used by a SortedMap via its comparator() method,"(""SortedMap"", ""The comparator() method is used by the SortedMap to obtain the Comparator."", ""comparator""); (""Comparator"", ""The Comparator is used by the SortedMap."", ""SortedMap"")"
"The getAndDecrement() method does the same as the decrementAndGet() method, except the getAndDecrement() method returns the value of the element before it is decremented.","(""GetAndDecrement"", ""Both methods perform similar operations, with the difference being the return value timing."", ""DecrementAndGet"")"
The Matcher lookingAt() method works like the matches() method with one major difference,"(""Matcher"", ""The lookingAt() method belongs to the Matcher class"", ""lookingAt""); (""Matcher"", ""The matches() method belongs to the Matcher class"", ""matches""); (""lookingAt"", ""The lookingAt() method is compared to the matches() method, indicating a functional relationship"", ""matches"")"
In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not but the BufferedInputStream supports them,"(""markSupported"", ""The markSupported method is used to check if the mark method is supported."", ""mark""); (""markSupported"", ""The markSupported method is used to check if the reset method is supported."", ""reset""); (""BufferedInputStream"", ""BufferedInputStream supports the mark method."", ""mark""); (""BufferedInputStream"", ""BufferedInputStream supports the reset method."", ""reset""); (""BufferedInputStream"", ""BufferedInputStream can use the markSupported method to check support for mark and reset."", ""markSupported""); (""InputStream"", ""The markSupported method is used to check if mark and reset are supported on a given InputStream."", ""markSupported"")"
Lock.lock() result is that any thread calling either lock() or unlock() will become blocked indefinately,"(""Lock"", ""The method lock() is associated with the class Lock as it is a function that can be called on instances of this class."", ""lock""); (""Lock"", ""The method unlock() is associated with the class Lock as it is a function that can be called on instances of this class."", ""unlock"")"
The getAndDecrement() method does the same as the decrementAndGet() method except the getAndDecrement() method returns the value of the element before it is decremented,"(""getAndDecrement"", ""Both are methods that perform similar operations, with a difference in the return value timing."", ""decrementAndGet"")"
The Collection interface has two methods to check if a Collection contains one or more certain elements. These are the contains() and containsAll() methods.,"(""Collection"", ""The contains method is used to check if a Collection contains a certain element."", ""contains""); (""Collection"", ""The containsAll method is used to check if a Collection contains all elements of a specified collection."", ""containsAll"")"
"The newLine() method which can write a new-line character to the underlying Writer. In addition, you may need to call flush() if you need to be absolutely sure that the characters written until now is flushed out of the buffer and onto the network or disk.","(""NewLine"", ""Both are methods that deal with writing and managing output in a Writer context."", ""Flush"")"
To calculate a MAC value you call the Mac update() or doFinal() method,"(""Mac"", ""The update method is a function that belongs to the Mac class, used to process data for MAC value calculation."", ""update""); (""Mac"", ""The doFinal method is a function that belongs to the Mac class, used to complete the MAC value calculation."", ""doFinal"")"
The java.util.concurrent package has the following implementations of the BlockingDeque interface,"(""Java.util.concurrent"", ""The BlockingDeque class is implemented within the Java.util.concurrent package"", ""BlockingDeque"")"
Notice how the calculate() method both locks the Calculator instance Lock before performing any calculations and also call the add() and subtract() methods which also locks the lock,"(""Calculate"", ""The Calculate method is associated with the Calculator class as it operates on its instance."", ""Calculator""); (""Calculate"", ""The Calculate method calls the Add method as part of its operations."", ""Add""); (""Calculate"", ""The Calculate method calls the Subtract method as part of its operations."", ""Subtract"")"
After calling read() the example loops until the isDone() method of the returned Future returns true,"(""READ"", ""The ISDONE method is called after the READ method in the example."", ""ISDONE""); (""ISDONE"", ""The ISDONE method is a method of the FUTURE class."", ""FUTURE"")"
Deque.pollFirst() is different than removeFirst() which throws an exception if the Deque is empty,"(""Deque"", ""pollFirst is a method of the Deque class"", ""pollFirst""); (""Deque"", ""removeFirst is a method of the Deque class"", ""removeFirst""); (""pollFirst"", ""pollFirst and removeFirst are methods of the Deque class and are compared in terms of behavior when the Deque is empty"", ""removeFirst"")"
Adding and getting elements to a generic Map is done using the put() and get() methods,"(""Map"", ""The put method is used to add elements to the Map class."", ""put""); (""Map"", ""The get method is used to retrieve elements from the Map class."", ""get"")"
Java IO contains many subclasses of the InputStream OutputStream Reader and Writer classes,"(""Java IO"", ""Java IO is a package that contains the InputStream class"", ""InputStream""); (""Java IO"", ""Java IO is a package that contains the OutputStream class"", ""OutputStream""); (""Java IO"", ""Java IO is a package that contains the Reader class"", ""Reader""); (""Java IO"", ""Java IO is a package that contains the Writer class"", ""Writer"")"
Even if you can get get() and put() to work I would recommend that you do not use these methods,"(""GET"", ""Both are methods mentioned in the text that are related to each other as they are often used together in programming contexts."", ""PUT"")"
Lock.unlock() will remain blocked until the thread waiting in lock() leaves the synchronized(this) block,"(""Lock"", ""The method 'unlock' is associated with the class 'Lock' as it is a method that operates on instances of this class."", ""unlock""); (""Lock"", ""The method 'lock' is associated with the class 'Lock' as it is a method that operates on instances of this class."", ""lock"")"
The Path interface is located in the java.nio.file package so the fully qualified name of the Java Path interface is java.nio.file.Path,"(""Path"", ""The Path class is located within the java.nio.file package."", ""java.nio.file"")"
Here are two examples of adding elements to a Java Queue via its add() and offer() methods,"(""Queue"", ""The add() method is used to add elements to the Queue class."", ""add()""); (""Queue"", ""The offer() method is used to add elements to the Queue class."", ""offer()"")"
The methods Class.getMethod(String name Class[] parameterTypes) and Class.getMethods() methods only return public methods so they wont work,"(""Class"", ""The method getMethod is associated with the class Class as it is a method of this class."", ""getMethod""); (""Class"", ""The method getMethods is associated with the class Class as it is a method of this class."", ""getMethods""); (""getMethod"", ""Both getMethod and getMethods are methods of the class Class and are mentioned together in the context of returning public methods."", ""getMethods"")"
"BlockingQueue.offer(E e, long timeout, TimeUnit unit) is different from the add() method which will throw an exception is adding an element to the end of the Deque fails","(""BlockingQueue"", ""The method 'offer' is a part of the 'BlockingQueue' class."", ""offer""); (""BlockingQueue"", ""The method 'add' is mentioned in relation to 'BlockingQueue', indicating it is likely a method of this class."", ""add""); (""offer"", ""The 'offer' method is compared to the 'add' method, suggesting they are related in functionality."", ""add""); (""Deque"", ""The 'add' method is mentioned in the context of adding an element to the 'Deque', indicating a relationship."", ""add"")"
The ByteArrayInputStream class is a subclass of the InputStream class so you can use a ByteArrayInputStream as an InputStream,"(""ByteArrayInputStream"", ""The ByteArrayInputStream class is a subclass of the InputStream class, indicating an inheritance relationship."", ""InputStream"")"
If you need to set a date on a java.sql.PreparedStatement or get a date from a java.sql.ResultSet you will interact with java.sql.Date,"(""PreparedStatement"", ""PreparedStatement is part of the java.sql package"", ""java.sql""); (""ResultSet"", ""ResultSet is part of the java.sql package"", ""java.sql""); (""Date"", ""Date is part of the java.sql package"", ""java.sql""); (""PreparedStatement"", ""PreparedStatement can set a date using the Date class"", ""Date""); (""ResultSet"", ""ResultSet can get a date using the Date class"", ""Date"")"
The java.nio.file.Files class works with java.nio.file.Path instances so you need to understand the Path class before you can work with the Files class,"(""Files"", ""The Files class works with Path instances, indicating a functional relationship between them."", ""Path""); (""Files"", ""The Files class is part of the java.nio.file package."", ""java.nio.file""); (""Path"", ""The Path class is part of the java.nio.file package."", ""java.nio.file"")"
Both PipedInputStream and PipedOutputStream has a connect() method that can connect one to the other,"(""PipedInputStream"", ""The connect() method can connect a PipedInputStream to a PipedOutputStream."", ""PipedOutputStream""); (""PipedOutputStream"", ""The connect() method can connect a PipedOutputStream to a PipedInputStream."", ""PipedInputStream"")"
java.awt.List is the last line of this example that calls the List stream() method to obtain the Stream representing the elements in the List,"(""Java.awt.List"", ""Java.awt.List is a specific implementation or usage of the List class."", ""List""); (""List"", ""The List class calls the Stream() method to obtain a Stream."", ""Stream()""); (""Stream()"", ""The Stream() method is used to obtain a Stream representing the elements."", ""Stream"")"
Queue.poll() is different than remove() which throws an exception if the Deque is empty,"(""Queue"", ""The method 'poll' is associated with the class 'Queue'."", ""poll""); (""Queue"", ""The method 'remove' is associated with the class 'Queue'."", ""remove""); (""Deque"", ""The method 'remove' is associated with the class 'Deque'."", ""remove""); (""poll"", ""The methods 'poll' and 'remove' are compared in terms of their behavior when the Deque is empty."", ""remove"")"
java.util.Collection represents an ordered sequence of objects just like a Java List but its intended use is slightly different,"(""Java.util.Collection"", ""Java.util.Collection is compared to Java List as both represent ordered sequences of objects, indicating a conceptual relationship."", ""Java List"")"
Another difference between call() and run() is that call() can throw an exception whereas run() cannot (except for unchecked exceptions subclasses of RuntimeException),"(""Call"", ""Call can throw an Exception, indicating a relationship where Call may result in an Exception being thrown."", ""Exception""); (""Run"", ""Run cannot throw exceptions except for unchecked exceptions which are subclasses of RuntimeException, indicating a relationship where Run is associated with RuntimeException."", ""RuntimeException"")"
As you can see the key Iterator returns every key stored in a Java Map one by one (one for each call to next()),"(""Iterator"", ""The Iterator class uses the next method to return each key stored in a Map one by one."", ""next""); (""Map"", ""The Iterator class is used to iterate over the keys stored in a Map."", ""Iterator"")"
The awaitTermination() method is typically called after calling shutdown() or shutdownNow(),"(""AwaitTermination"", ""The awaitTermination() method is typically called after calling the shutdown() method."", ""Shutdown""); (""AwaitTermination"", ""The awaitTermination() method is typically called after calling the shutdownNow() method."", ""ShutdownNow"")"
Collection.remove(Object o) is different from poll() which returns null if the Deque is empty,"(""Collection"", ""The method 'remove' is associated with the 'Collection' class."", ""remove""); (""remove"", ""The 'remove' method takes an 'Object' as a parameter."", ""Object""); (""poll"", ""The method 'poll' is associated with the 'Deque' class."", ""Deque""); (""Collection"", ""The 'poll' method is mentioned in the context of 'Collection', indicating a comparison or relationship."", ""poll"")"
The Java GZIPInputStream and GZIPOutputStream classes are used to ZIP compress a single file,"(""GZIPInputStream"", ""Both classes are used for ZIP compression of files in Java"", ""GZIPOutputStream"")"
The java.util.concurrent package contains the following implementations of the ConcurrentMap interface,"(""Java.util.concurrent"", ""The Java.util.concurrent package contains implementations of the ConcurrentMap interface"", ""ConcurrentMap"")"
Receiving data via a DatagramSocket is done by first creating a DatagramPacket and then receiving data into it via the DatagramSocket receive() method,"(""DatagramSocket"", ""The receive method is a function of the DatagramSocket class, used to receive data."", ""receive""); (""DatagramSocket"", ""Data is received into a DatagramPacket using the DatagramSocket class."", ""DatagramPacket"")"
"Notice how the while loop continues until a -1 value is read from the ByteArrayInputStream read() method. After that, the while loop exits, and the ByteArrayInputStream close() method is called.","(""ByteArrayInputStream"", ""The read method is associated with the ByteArrayInputStream class as it is used to read data from it."", ""read""); (""ByteArrayInputStream"", ""The close method is associated with the ByteArrayInputStream class as it is used to close the stream."", ""close"")"
Notice how we can call the addAndReturn() method using both String and Integer and their corresponding collections,"(""addAndReturn"", ""The addAndReturn method can be called using the String class."", ""String""); (""addAndReturn"", ""The addAndReturn method can be called using the Integer class."", ""Integer"")"
"As you can see, the DecimalFormat is created with a formatting pattern. You can change this pattern later using the applyPattern() or applyLocalizedPattern() method.","(""DecimalFormat"", ""The applyPattern method is used to change the formatting pattern of the DecimalFormat class."", ""applyPattern""); (""DecimalFormat"", ""The applyLocalizedPattern method is used to change the formatting pattern of the DecimalFormat class."", ""applyLocalizedPattern"")"
For that you need to use the find() start() and end() methods,"(""FIND"", ""The methods FIND and START are related as they are both mentioned as methods to be used together."", ""START""); (""FIND"", ""The methods FIND and END are related as they are both mentioned as methods to be used together."", ""END""); (""START"", ""The methods START and END are related as they are both mentioned as methods to be used together."", ""END"")"
The Java Stack class actually implements the Java List interface but you rarely use a Stack as a List except perhaps if you need to inspect all elements currently stored on the stack,"(""Java Stack"", ""The Java Stack class implements the Java List interface"", ""Java List"")"
In Java 6 to 13 there is only one implementation of the NavigableSet interface in the java.util package The java.util.TreeSet class,"(""NavigableSet"", ""TreeSet is an implementation of the NavigableSet interface"", ""TreeSet""); (""TreeSet"", ""TreeSet is part of the java.util package"", ""java.util"")"
In many ways the java.nio.file.Path interface is similar to the java.io.File class but there are some minor differences,"(""Java.Nio.File.Path"", ""The Java.Nio.File.Path interface is compared to the Java.Io.File class, indicating a relationship in functionality or usage."", ""Java.Io.File"")"
java.io.CharArrayReader is also possible to write data to an ByteArrayOutputStream or CharArrayWriter,"(""CharArrayReader"", ""Both are classes used for handling character and byte arrays in Java I/O operations."", ""ByteArrayOutputStream""); (""CharArrayReader"", ""Both are classes used for handling character arrays in Java I/O operations."", ""CharArrayWriter""); (""ByteArrayOutputStream"", ""Both are classes used for handling byte and character arrays in Java I/O operations."", ""CharArrayWriter"")"
"The first method, addAndGet() adds a number to the AtomicInteger and returns its value after the addition. The second method, getAndAdd() also adds a number to the AtomicInteger but returns the value the AtomicInteger had before the value was added.","(""AddAndGet"", ""The method AddAndGet adds a number to the AtomicInteger and returns its value after the addition."", ""AtomicInteger""); (""GetAndAdd"", ""The method GetAndAdd adds a number to the AtomicInteger and returns the value it had before the addition."", ""AtomicInteger"")"
Here is an example of obtaining the Comparator used by a SortedSet via the comparator() method,"(""comparator"", ""The comparator() method is used to obtain the Comparator used by a SortedSet."", ""SortedSet""); (""Comparator"", ""The Comparator is used by the SortedSet to determine the order of its elements."", ""SortedSet"")"
You will call take() instead of notify() and release() instead of wait(),"(""TAKE"", ""The method TAKE is used as an alternative to the method NOTIFY."", ""NOTIFY""); (""RELEASE"", ""The method RELEASE is used as an alternative to the method WAIT."", ""WAIT"")"
The problem with calling wait() and notify() on the empty string or any other constant string is that the JVMCompiler internally translates constant strings into the same object,"(""Wait"", ""Both are methods that can be called on objects in Java for thread communication."", ""Notify""); (""JVMCompiler"", ""JVMCompiler is related to Wait because it handles the translation of constant strings, which can affect how Wait is called."", ""Wait""); (""JVMCompiler"", ""JVMCompiler is related to Notify because it handles the translation of constant strings, which can affect how Notify is called."", ""Notify"")"
"if the Deque is full, the offerFirst() method returns false. This is different from the addFirst() method which will throw an exception is adding an element to the beginning of the Deque fails.","(""offerFirst"", ""The offerFirst method is associated with the Deque class as it operates on it."", ""Deque""); (""addFirst"", ""The addFirst method is associated with the Deque class as it operates on it."", ""Deque""); (""offerFirst"", ""Both offerFirst and addFirst are methods that perform similar operations on the Deque class, with different behaviors when the Deque is full."", ""addFirst"")"
You read characters from a Java PushbackReader just like you do from a Java Reader because PushbackReader is a Java Reader subclass,"(""PushbackReader"", ""PushbackReader is a subclass of Reader"", ""Reader"")"
Since the Map does not contain any object stored by the key E the given default value will be returned which is the String default value passed as the last parameter to the getOrDefault() method,"(""getOrDefault"", ""The getOrDefault method is used to retrieve values from the Map class."", ""Map""); (""String"", ""The String class is related to the getOrDefault method as it is the type of the default value parameter."", ""getOrDefault"")"
When you call select() or selectNow() on the Selector it gives you only the SelectableChannel instances that actually has data to read,"(""SELECT"", ""The method SELECT is called on the SELECTOR class."", ""SELECTOR""); (""SELECTNOW"", ""The method SELECTNOW is called on the SELECTOR class."", ""SELECTOR""); (""SELECTOR"", ""The SELECTOR class provides instances of the SELECTABLECHANNEL class that have data to read."", ""SELECTABLECHANNEL"")"
"For the SortedSet to be able to determine the natural order of the elements, the elements must implement the java.lang.Comparable interface.","(""SortedSet"", ""The SortedSet class requires elements to implement the java.lang.Comparable interface to determine their natural order."", ""java.lang.Comparable"")"
For the SortedSet to be able to determine the natural order of the elements the elements must implement the java.lang.Comparable interface,"(""SortedSet"", ""The SortedSet class requires elements to implement the java.lang.Comparable interface to determine their natural order."", ""java.lang.Comparable"")"
java.util.concurrent.RecursiveTask example is similar to the RecursiveAction example except it returns a result,"(""Java.Util.Concurrent"", ""RecursiveTask is a class within the Java.Util.Concurrent package"", ""RecursiveTask""); (""Java.Util.Concurrent"", ""RecursiveAction is a class within the Java.Util.Concurrent package"", ""RecursiveAction""); (""RecursiveTask"", ""Both RecursiveTask and RecursiveAction are examples used in a similar context, indicating they are related classes"", ""RecursiveAction"")"
Notice the two synchronized blocks inside the set() and get() method. Notice how the blocks are placed last and first in the two methods.,"(""Set"", ""Both methods contain synchronized blocks, indicating a relationship in their functionality or usage."", ""Get"")"
This Keytool delete command will remove the KeyStore entry with the alias testkey from the KeyStore stored in the file keystore.jks,"(""Keytool"", ""The delete method is a command associated with the Keytool package."", ""delete""); (""delete"", ""The delete method is used to remove an entry from the KeyStore class."", ""KeyStore""); (""KeyStore"", ""The testkey is an entry within the KeyStore class."", ""testkey""); (""KeyStore"", ""The KeyStore is stored in the file keystore.jks."", ""keystore.jks"")"
Deque.addFirst(E e) is different from the offerFirst() method which will return false if an element cannot be inserted in the beginning of the Deque,"(""addFirst"", ""Both are methods related to inserting elements at the beginning of the Deque class"", ""offerFirst""); (""Deque"", ""addFirst is a method of the Deque class"", ""addFirst""); (""Deque"", ""offerFirst is a method of the Deque class"", ""offerFirst"")"
To access a private method you will need to call the Class.getDeclaredMethod(String name Class[] parameterTypes) or Class.getDeclaredMethods() method,"(""Class"", ""The getDeclaredMethod is a method that belongs to the Class entity, used to access a specific method by name and parameter types."", ""getDeclaredMethod""); (""Class"", ""The getDeclaredMethods is a method that belongs to the Class entity, used to access all declared methods."", ""getDeclaredMethods"")"
There are several overridden versions of both update() and doFinal() which takes different parameters,"(""update"", ""Both are methods that have overridden versions with different parameters"", ""doFinal"")"
If you look at the example in the previous section imagine what happens if an exception is thrown between the call to lock.lock() and lock.unlock(),"(""Lock"", ""The method 'lock' is called on the class 'Lock', indicating a relationship between the method and the class."", ""Lock""); (""Lock"", ""The method 'unlock' is called on the class 'Lock', indicating a relationship between the method and the class."", ""Unlock"")"
"The replace() method will only insert the new value if there is already an existing value mapped to the key. If no existing value is mapped to the given key, no value is inserted. This is different from how put() works, which always insert the value no matter what.","(""Replace"", ""Both are methods that handle value insertion in different ways."", ""Put""); (""Replace"", ""The replace() method is described in the text."", ""Replace""); (""Put"", ""The put() method is described in the text."", ""Put"")"
The logrb() methods work like the log() methods too except they can obtain the log messages from a resource bundle,"(""LOGRB"", ""The LOGRB methods work like the LOG methods, indicating a functional similarity or shared purpose."", ""LOG"")"
a stop() or pause() method too) then you can no longer create your Runnable implementation with a Java lambda expression,"(""STOP"", ""The STOP method is related to the RUNNABLE class as it is likely a method that can be called on a Runnable object."", ""RUNNABLE""); (""PAUSE"", ""The PAUSE method is related to the RUNNABLE class as it is likely a method that can be called on a Runnable object."", ""RUNNABLE""); (""RUNNABLE"", ""The RUNNABLE class is part of the JAVA package, as it is a common class used in Java programming."", ""JAVA"")"
java.security.KeyStore example loads the KeyStore file located in the keystore.ks file,"(""java.security"", ""The KeyStore class is part of the java.security package"", ""KeyStore"")"
The queueObject.doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout so another thread can actually call unlock() when no thread is executing inside the synchronized(this) block in lock() method,"(""QueueObject"", ""The method DoWait is called on the class QueueObject."", ""DoWait""); (""QueueObject"", ""The method Unlock is called on the class QueueObject."", ""Unlock""); (""QueueObject"", ""The method Lock is associated with the class QueueObject."", ""Lock""); (""Lock"", ""The method DoWait is mentioned in the context of the Lock method."", ""DoWait""); (""Lock"", ""The method Unlock is mentioned in the context of the Lock method."", ""Unlock"")"
The read() and write() calls on the streams are blocking meaning if you try to use the same thread to both read and write this may result in the thread deadlocking itself,"(""READ"", ""Both are methods that operate on streams and are mentioned together in the context of blocking calls."", ""WRITE""); (""READ"", ""The read method is related to the thread as it can cause the thread to block."", ""THREAD""); (""WRITE"", ""The write method is related to the thread as it can cause the thread to block."", ""THREAD"")"
"mutiple blocks from a large file, you call the update() once for each block of data, and finish with a call to doFinal() with the last data loce","(""update"", ""The methods update() and doFinal() are related as they are both called in sequence to process data blocks, with update() handling each block and doFinal() finalizing the process."", ""doFinal"")"
That means that when a thread invokes a read() or write() that thread is blocked until there is some data to read or the data is fully written,"(""read"", ""Both are methods that involve thread operations related to data reading and writing"", ""write"")"
You can convert a Java List to a Java Array using the List toArray() method,"(""List"", ""The toArray() method is used to convert a List to an Array."", ""toArray""); (""toArray"", ""The toArray() method converts a List into an Array."", ""Array"")"
When the thread is done with the code in the critical section (the code between lock() and unlock()) the thread calls unlock(),"(""lock"", ""The methods lock() and unlock() are related as they are used in conjunction to manage access to a critical section of code."", ""unlock"")"
The LinkedList class is a pretty standard Deque and Queue implementation,"(""LinkedList"", ""The LinkedList class is described as a Deque implementation."", ""Deque""); (""LinkedList"", ""The LinkedList class is described as a Queue implementation."", ""Queue"")"
The System class also has a getProperty() and setProperty() method which are shortcuts to the Properties getProperty() and setProperty() methods of the System Properties instance,"(""System"", ""The getProperty method is part of the System class."", ""getProperty""); (""System"", ""The setProperty method is part of the System class."", ""setProperty""); (""Properties"", ""The getProperty method is part of the Properties class."", ""getProperty""); (""Properties"", ""The setProperty method is part of the Properties class."", ""setProperty""); (""System Properties"", ""The getProperty method is part of the System Properties class."", ""getProperty""); (""System Properties"", ""The setProperty method is part of the System Properties class."", ""setProperty"")"
The Handler in the Java Logging API use a java.util.logging.Formatter to format the LogRecord before writing it to an external system,"(""Handler"", ""The Handler uses a Formatter to format the LogRecord."", ""java.util.logging.Formatter""); (""Handler"", ""The Handler formats the LogRecord before writing it to an external system."", ""LogRecord""); (""Java Logging API"", ""The Handler is part of the Java Logging API."", ""Handler""); (""java.util.logging.Formatter"", ""The Formatter is used to format the LogRecord."", ""LogRecord"")"
The compare() method returns an int with the same meaning as the String.compareTo() method,"(""COMPARE"", ""Both COMPARE and STRING.COMPARETO are methods that return an int and have similar functionality."", ""STRING.COMPARETO"")"
The method getBuffer() returns the StringBuffer used by the StringWriter to build the string from the written characters,"(""getBuffer"", ""The method getBuffer() returns the StringBuffer used by the StringWriter to build the string."", ""StringBuffer""); (""getBuffer"", ""The method getBuffer() is associated with the StringWriter as it uses the StringBuffer to build the string."", ""StringWriter"")"
java.io.Writer is faster to write an array of characters to a Java BufferedWriter than writing one character at a time,"(""Java.io.Writer"", ""Java.io.Writer is used to write an array of characters to a Java BufferedWriter"", ""Java BufferedWriter"")"
java.util.Stack Java example pushes a Java String with the text 1 onto the Stack,"(""Java.util.Stack"", ""The method 'Pushes' is used to add elements to the 'Java.util.Stack' class."", ""Pushes""); (""Java"", ""The 'Java' class is related to the 'String' class as it is a fundamental data type in Java."", ""String"")"
Deque.peekFirst() is similar to how peek() works but the method name peekFirst() is a bit more saying about which end of the Deque you peek at,"(""peekFirst"", ""The method peekFirst is associated with the class Deque as it is a method that operates on instances of Deque."", ""Deque""); (""peek"", ""The method peek is associated with the class Deque as it is a method that operates on instances of Deque."", ""Deque"")"
To sort a collection of strings according to the rules of a certain Locale you use a java.text.Collator instance created for that specific Locale,"(""Java.text.Collator"", ""Java.text.Collator is used to sort strings according to the rules of a specific Locale"", ""Locale""); (""Java.text.Collator"", ""Java.text.Collator sorts a collection of strings"", ""String"")"
