The Java Collection interface (java.util.Collection) is one of the root interfaces of the Java Collection API.,"(""Collection interface"", ""The Collection interface is a component of the java.util package."", ""java.util"")"
Adding an element to a Collection is done via the add() method.,NULL
"The add() method adds the given element to the collection, and returns true if the Collection changed as a result of calling the add() method.",NULL
"On the other hand, if you called add() on a List and the List already contained that element, the element would then exist twice in the List.","(""Add"", ""The method 'Add' is invoked on the class 'List' to add an element."", ""List"")"
"The remove() method removes the given element from the Collection and returns true if the removed element was present in the Collection, and was removed.",NULL
"If the element was not present, the remove() method returns false.","(""Remove"", ""The remove method returns false if the element was not present."", ""false"")"
You can also add a collection of objects to a Java Collection using the addAll().,"(""Java Collection"", ""The method 'addAll' is used to add a collection of objects to an instance of 'Java Collection'."", ""addAll"")"
The Java Collection addAll() adds all elements found in the Collection passed as parameter to the method.,NULL
"If you had called add() with the Collection as parameter instead, the Collection object itself would have been added, not its elements.","(""Add"", ""The method 'add()' is invoked with 'Collection' as a parameter, indicating a use relationship."", ""Collection"")"
Exactly how the addAll() method behaves depends on the Collection subtype.,"(""AddAll"", ""The addAll method is defined or operates on the Collection class or its subtype."", ""Collection""); (""AddAll"", ""The addAll method is defined or operates on the Collection class or its subtype."", ""Collection"")"
The Java Collection removeAll() removes all elements found the Collection passed as parameter to the method.,NULL
"contains() returns true if the collection contains the element, and false if not.",NULL
"containsAll() returns true if the collection contains all the elements in the parameter collection, and false if not.",NULL
You can check the size of a collection using the size() method.,"(""Size"", ""The 'size' method is used to check the size of a 'collection', indicating a direct functional relationship."", ""Collection"")"
The Java Stream API provides a more functional programming approach to iterating and processing elements of e.g.,NULL
You obtain a stream from a collection by calling the stream() method of the given collection.,NULL
Then a Stream of strings is obtained by calling the items.stream() method.,NULL
"This is similar to how you obtain an Iterator by calling the items.iterator() method, but a Stream is a different animal than an Iterator.",NULL
The Predicate interface contains a function called test() which the lambda expression passed as parameter above is matched against.,"(""Predicate"", ""The Predicate interface defines a method named test() that can be implemented."", ""test""); (""test"", ""The test() method is utilized by lambda expressions as parameters to evaluate conditions."", ""lambda expression"")"
"If you look at the lambda expression above, you can see that it takes a single parameter item and returns a boolean - the result of the item.startsWith(""o"") method call.","(""Item"", ""Item is the class on which the method StartsWith is invoked."", ""Item.StartsWith""); (""Item"", ""Item is the class on which the method StartsWith is invoked."", ""Item.StartsWith"")"
"When you call the filter() method on a Stream, the filter passed as parameter to the filter() method is stored internally.","(""Filter"", ""The filter() method is called on a Stream, indicating that the method is associated with the Stream class."", ""Stream"")"
"The parameter passed to the filter() function determines what items in the stream should be processed, and which that should be excluded from the processing.",NULL
"If the Predicate.test() method of the parameter passed to filter() returns true for an item, that means it should be processed.","(""Predicate"", ""The test method belongs to the Predicate class as indicated by Predicate.test() notation."", ""test""); (""filter"", ""The test method is used as a parameter within the filter method, linking their functionality."", ""test"")"
The collect() method is one of the stream processing methods on the Stream interface.,NULL
"The min() and max() methods return an Optional instance which has a get() method on, which you use to obtain the value.","(""Min"", ""The min() method returns an Optional instance, indicating that their relationship is based on the method's return type."", ""Optional""); (""Max"", ""The max() method returns an Optional instance, indicating that their relationship is based on the method's return type."", ""Optional""); (""Optional"", ""The get() method is used on an Optional instance to obtain the value, indicating a method belonging to the class."", ""Get"")"
In case the stream has no elements the get() method will return null.,NULL
The Comparator.comparing() method creates a Comparator based on the lambda expression passed to it.,"(""Comparator"", ""The comparing() method is used in conjunction with the Comparator class to create a Comparator."", ""comparing()"")"
"In fact, the comparing() method takes a Function which is a functional interface suited for lambda expressions.",NULL
The count() method simply returns the number of elements in the stream after filtering has been applied.,"(""Count"", ""The Count method is used to return the number of elements in the stream."", ""Stream"")"
The count() method returns a long which is the count of elements in the stream after filtering etc.,NULL
The reduce() method can reduce the elements of a stream to a single value.,"(""Reduce"", ""The reduce method is a function that operates on the elements of a stream."", ""Stream"")"
"The reduce() method takes a BinaryOperator as parameter, which can easily be implemented using a lambda expression.","(""Reduce"", ""The Reduce method takes a BinaryOperator as a parameter."", ""BinaryOperator"")"
The BinaryOperator.apply() method is the method implemented by the lambda expression above.,"(""BinaryOperator"", ""The apply() method is part of the BinaryOperator class as indicated by the dot notation, which is typical for class methods."", ""apply()"")"
"Thus, the value created by the reduce() function is the accumulated value after processing the last element in the stream.","(""Reduce"", ""The reduce() method operates on elements of a stream to produce a single aggregated value."", ""Stream"")"
The reduce() method taking a BinaryOperator as parameter returns an Optional .,"(""Reduce"", ""The reduce() method takes a BinaryOperator as a parameter"", ""BinaryOperator""); (""Reduce"", ""The reduce() method returns an Optional"", ""Optional""); (""Reduce"", ""The reduce() method takes a BinaryOperator as a parameter"", ""BinaryOperator""); (""Reduce"", ""The reduce() method returns an Optional"", ""Optional"")"
"In case the stream contains no elements, the Optional.get() returns null.","(""stream"", ""The method Optional.get() is used on a stream to handle its elements."", ""Optional.get()"")"
"This version of the reduce() method returns the accumulated value directly, and not an Optional.","(""Reduce"", ""method""); (""Reduce"", ""method"")"
The reduce() method can be combined with the filter() method too.,"(""Reduce"", ""The reduce() method can be used in combination with the filter() method, indicating they can work together in a sequence or pipeline in programming."", ""Filter"")"
"The Java Collections class, java.util.Collections, contains a long list of utility methods for working with collections in Java.",NULL
The Java Collections addAll() method can add a variable number of elements to a Collection (typically either a List or a Set .,NULL
Here is a java code example of calling the Collections addAll() method:,NULL
The Collections binarySearch() method can search a Java List for an element using a binary search algorithm.,"(""Collections"", ""The binarySearch method is part of the Collections class"", ""binarySearch""); (""binarySearch"", ""The binarySearch method operates on a Java List"", ""List"")"
The List must be sorted in ascending order before you search it using binarySearch() .,NULL
Here is an example of searching a List using the Collections binarySearch() method:,"(""List"", ""The binarySearch() method is used to search within a List."", ""binarySearch()""); (""Collections"", ""The binarySearch() method is part of the Collections package."", ""binarySearch()"")"
The Collections copy() method can copy all elements of a List into another List.,NULL
Here is a Java example of calling the Collections copy() method:,"(""Collections"", ""The copy() method is a part of the Collections class."", ""copy()""); (""Collections"", ""The copy() method is a part of the Collections class."", ""copy()"")"
The Collections reverse() method can reverse the elements in a Java List.,"(""Collections"", ""The reverse method belongs to the Collections class."", ""reverse""); (""reverse"", ""The reverse method operates on elements in a Java List."", ""List"")"
The Collections shuffle() method can shuffle the elements of a List.,"(""shuffle"", ""The shuffle method is part of the Collections package."", ""Collections""); (""shuffle"", ""The shuffle method operates on a List class to shuffle its elements."", ""List"")"
Here is an example of shuffling a list with the Collections shuffle() method:,"(""Collections"", ""The 'Shuffle' method is part of the 'Collections' class, indicating a direct association typically found in object-oriented programming where a method belongs to a class."", ""Shuffle"")"
Here is an example of sorting a Java List using Collections sort() method:,"(""Collections"", ""The sort() method is a static method of the Collections class."", ""sort()""); (""sort()"", ""The sort() method is used to sort a List."", ""List"")"
The Java Collections copy() method can copy one List into another.,"(""Java Collections"", ""The copy method is part of the Java Collections package."", ""copy""); (""copy"", ""The copy method is used to copy elements between List objects."", ""List""); (""Java Collections"", ""The copy method is part of the Java Collections package."", ""copy""); (""copy"", ""The copy method is used to copy elements between List objects."", ""List"")"
You provide the source and destination List instances as parameters to the copy() method.,"(""copy"", ""The copy method operates on instances of the List class, using them as its source and destination parameters."", ""List"")"
The Collections min() method can find the minimum element in a List according to the natural ordering of the elements (see my Java List sorting tutorial).,"(""Collections"", ""The min method is part of the Collections package, as it is referred to as Collections min() method."", ""min""); (""min"", ""The min method operates on a List class to find the minimum element."", ""List"")"
Here is an example of finding the minimum element in a Java List using Collections min() method:,"(""Collections"", ""The min() method is part of the Collections package, as it is used in conjunction with Collections."", ""min()""); (""List"", ""The min() method is applied to a List to find the minimum element, indicating that min() operates on List objects."", ""min()"")"
The Collections max() method can find the maximum element in a List according to the natural order of the elements (see my Java List sorting tutorial).,NULL
The Java Collections replaceAll() method can replace all occurrences of one element with another element.,"(""replaceAll()"", ""The replaceAll() method is part of the Collections package."", ""Collections""); (""replaceAll()"", ""The replaceAll() method is part of the Collections package."", ""Collections"")"
You pass the element to replace and the element to replace it with as parameters to the replaceAll() method.,"(""ReplaceAll"", ""The ReplaceAll method is used to replace one element with another as described by the parameters"", ""Element"")"
"The Collections replaceAll() method returns true if any elements were replaced, and false if not.",NULL
The Collections replaceAll() method uses the equals() method of each element to determine if the element is equal to the element to replace or not.,"(""Collections"", ""The 'replaceAll' method is associated with the 'Collections' class as it is referred to as 'Collections replaceAll()'."", ""replaceAll""); (""replaceAll"", ""The 'replaceAll' method uses the 'equals' method to determine if one element is equal to another element."", ""equals"")"
I have a written a few more details about how the equals() method works in my section about the Java equals() method.,NULL
The unmodifiableSet() method in the Java Collections class can create an immutable (unmodifiable) Set from a normal Java Set .,NULL
"The Java Comparable interface,java.lang.Comparable, represents an object which can be compared to other objects.","(""Java Comparable"", ""Java Comparable is a class represented by the package java.lang.Comparable, indicating the connection between the class and package."", ""java.lang.Comparable""); (""Java Comparable"", ""Java Comparable is a class represented by the package java.lang.Comparable, indicating the connection between the class and package."", ""java.lang.Comparable"")"
Several of the built-in classes in Java implements the Java Comparable interface.,"(""Comparable"", ""The Comparable class is part of the Java language as it is part of its built-in classes."", ""Java"")"
"You can also implement the Java Comparable interface yourself, to make your own classes comparable.",NULL
"When a class implements the Java Comparable interface, this means that instances (objects) of that class can be compared to each other, as mentioned above.",NULL
Please keep in mind that the Comparable interface is intended for comparison of objects of the same class.,"(""Comparable"", ""The Comparable interface is used for comparison of objects of the same class."", ""class""); (""Comparable"", ""The Comparable interface is used for comparison of objects of the same class."", ""class"")"
In the following section I will explain how the compareTo() method works.,"(""compareTo"", ""method"")"
The Java Comparable compareTo() method takes a single object as parameter and returns an int value.,NULL
"The int returned signal whether the object the compareTo() method is called on is larger than, equal to or smaller than the parameter object.","(""CompareTo"", ""method"")"
"The Java Integer class implements the Comparable interface, so you can call compareTo() Here is an example:","(""Integer"", ""The Integer class can use the compareTo method because it implements the Comparable interface."", ""compareTo"")"
Since the value 45 is smaller than 99 - the first comparison ( valA.compareTo(valB) = 45.compareTo(99) ) results in the value -1 being returned.,"(""VALA"", ""VALA uses the method COMPARETO to compare itself with another value."", ""COMPARETO""); (""VALB"", ""VALB is being compared to using the method COMPARETO."", ""COMPARETO"")"
"In the second comparison, when 99 is compared to 45 ( valB.compareTo(valA) = 99.compareTo(45) ) the result is 1 - because 99 is larger than 45.",NULL
Here is an example of a Spaceship class which can compare itself to other Spaceship instances:,NULL
This way you can implement compareTo() to compare base on multiple factors.,"(""CompareTo"", ""Method""); (""CompareTo"", ""Method"")"
"By specifying a type parameter when implementing the Comparable interface, the compareTo() method parameter changes from Object to whatever type you have specified.",NULL
"Notice how there is no type parameter specified after the ""implements Comparable"" interface in the class declaration.",NULL
"Notice also, how the parameter type of the compareTo() object is no longer Spaceship, but Object.","(""Compareto"", ""The Compareto method's parameter type has changed to Object, indicating a direct relationship."", ""Object"")"
"Finally, also notice how it is now necessary to cast the parameter of the compareTo() method to Spaceship explicitly.","(""compareTo"", ""The compareTo method uses Spaceship as a parameter that needs to be explicitly cast."", ""Spaceship"")"
"Notice too, that the compareTo() method should throw a NullPointerException if the parameter object is null.","(""COMPARETO"", ""The COMPARETO method throws a NULLPOINTEREXCEPTION when the parameter object is null, indicating a direct relationship between the two entities."", ""NULLPOINTEREXCEPTION"")"
"Similarly, the compareTo() method should throw a ClassCastException if the input parameter is not of the same class as the class of the object compareTo() is called on.","(""COMPARETO"", ""The compareTo method is used to compare objects of the same class."", ""CLASS""); (""COMPARETO"", ""The compareTo method is used to compare objects of the same class."", ""CLASS"")"
You can just cast to the desired class (as in the example above).,NULL
"If the classes do not match, the Java VM will throw a ClassCastException.","(""Java VM"", ""The Java VM throws a ClassCastException when classes do not match"", ""ClassCastException"")"
"The Java Comparator interface, java.util.Comparator, represents a component that can compare two objects so they can be sorted using sorting functionality in Java.","(""Comparator"", ""The class 'Comparator' is represented by its fully qualified name 'java.util.Comparator'."", ""java.util.Comparator""); (""java.util.Comparator"", ""The class 'java.util.Comparator' is part of the 'java.util' package."", ""java.util"")"
When sorting e.g a Java List you can pass a Java Comparator to the sorting method.,"(""List"", ""The sorting method is applied to the List to arrange its elements in a particular order."", ""sorting method""); (""Comparator"", ""The Comparator is used by the sorting method to determine the order of the List elements."", ""sorting method"")"
"This method, the compare() method, takes two objects which the Comparator implementation is intended to compare.",NULL
The compare() method returns an int which signals which of the two objects was larger.,"(""Compare"", ""The compare() method returns an int, indicating a direct relationship between the method and its return type."", ""Int"")"
Imagine you have the following Spaceship class that you would like to be able to compare instances of:,"(""Spaceship"", ""class"")"
"Notice that the Spaceship class already implements the Comparable interface which compares Spaceship objects on spaceshipClass first, and then registrationNo.",NULL
"First, notice how the SpaceshipComparator class implements the Comparator interface with the type Spaceship specified inside the < > characters ( implements Comparator<Spaceship> ).","(""SpaceshipComparator"", ""SpaceshipComparator implements the Comparator interface."", ""Comparator""); (""SpaceshipComparator"", ""SpaceshipComparator uses Spaceship as the type parameter in the Comparator interface."", ""Spaceship"")"
"Setting the generic type of the Comparator implementation to Spaceship means that the parameter types of the compare() method can be set to Spaceship, and not Object as it would have been - if no generic type had been specified ( implements Comparator ).",NULL
"A Java Comparator implementation is pretty much always specialized to be able to compare objects of a specific type (class), so specifying a generic type in your Comparator implementation almost always makes sense.",NULL
"Second, notice how the compare() method returns the registrationNo of the first Spaceship parameter compared to the registrationNo of the second Spaceship parameter.",NULL
"Imagine if the registrationNo variable of the Spaceship class was an int instead, so getRegistrationNo() would return an int.","(""Spaceship"", ""The method 'getRegistrationNo' is likely a part of the 'Spaceship' class as implied by the context."", ""getRegistrationNo"")"
"The Java Deque interface, java.util.Deque, represents a double ended queue, meaning a queue where you can add and remove elements to and from both ends of the queue.",NULL
The LinkedList class is a pretty standard Deque and Queue implementation.,"(""LinkedList"", ""The LinkedList class implements the Deque interface."", ""Deque""); (""LinkedList"", ""The LinkedList class implements the Queue interface."", ""Queue"")"
The Java ArrayDeque class stores its elements internally in an array.,"(""ArrayDeque"", ""The ArrayDeque class stores its elements internally in an array, indicating a relationship between the class and the array it uses."", ""array"")"
Before you can use a Java Deque you must create an instance of one of the classes that implements the Deque interface.,NULL
You add elements to the beginning end of a Deque using the add() method.,NULL
"If the element cannot be inserted into the Deque, the add() method will throw an exception.",NULL
"This is different from the offer() method, which will return false if it cannot insert the element.",NULL
The addLast() method also adds an element to the end (tail) of a Java Deque.,"(""AddLast"", ""The AddLast method is a function that operates on the Deque class, adding an element to the end of the Deque collection."", ""Deque"")"
This is the Deque interface's equivalent of the add() method inherited from the Queue interface.,"(""Deque"", ""The add() method is mentioned as being equivalent in the context of the Deque interface."", ""add()""); (""Deque"", ""The Deque interface is compared to or derived from the Queue interface regarding the add() method."", ""Queue"")"
Here is an example of adding an element to a Java Deque instance using the addLast() method:,"(""Deque"", ""The addLast() method is associated with the Deque class in Java for adding elements."", ""addLast()"")"
"If the element cannot be inserted into the Deque, the addLast() method will throw an exception.",NULL
This is different from the offerLast() method which will return false if the element cannot be added to the Deque.,NULL
To add an element at the beginning (head) instead of the end of a Java Deque you call the addFirst() method instead.,"(""addFirst()"", ""addFirst() is a method used to add an element at the beginning of a Java Deque."", ""Java Deque"")"
"If the element cannot be added to the beginning of the Deque, the addFirst() method will throw an exception.",NULL
This is different from the offerFirst() method which will return false if an element cannot be inserted in the beginning of the Deque.,"(""OfferFirst"", ""The offerFirst method operates on the Deque class by inserting elements at the beginning."", ""Deque""); (""OfferFirst"", ""The offerFirst method operates on the Deque class by inserting elements at the beginning."", ""Deque"")"
The offer() method adds an element to the end (tail) of the Deque.,"(""Offer"", ""The offer method is associated with the Deque class because it adds elements to this class."", ""Deque"")"
This is different from the add() method which will throw an exception is adding an element to the end of the Deque fails.,NULL
Here is an example of how to add an element to the end of a Java Deque using the offer() method:,"(""offer()"", ""The offer() method is used to add an element to the end of a Deque in Java"", ""Deque"")"
"The offerLast() method adds an element to the end (tail) of the Deque, just like offer().","(""Offerlast"", ""The OfferLast method operates on the Deque class by adding an element to its tail."", ""Deque""); (""Offer"", ""The Offer method operates on the Deque class in a similar manner to OfferLast, by adding an element."", ""Deque"")"
The method name offerLast() is just a bit more saying about where the element is added to the Deque.,"(""offerLast()"", ""The method offerLast() adds an element to the Deque."", ""Deque"")"
This is different from the addLast() method which will throw an exception is adding an element to the end of the Deque fails.,NULL
Here is an example of how to add an element to the end of a Java Deque using the offerLast() method:,"(""Java Deque"", ""The offerLast() method is used to add an element to the end of a Java Deque."", ""offerLast()"")"
The offerFirst() method adds an element to the beginning (head) of the Deque.,"(""OfferFirst"", ""The OfferFirst method is designed to add an element to the beginning of the Deque class, indicating a functional relationship between the method and the class."", ""Deque"")"
This is different from the addFirst() method which will throw an exception is adding an element to the beginning of the Deque fails.,NULL
Here is an example of how to add an element to the beginning of a Java Deque using the offerFirst() method:,NULL
The push() method adds an element to the beginning (head) of a Java Deque method.,"(""Push"", ""The push() method is a method of the Java Deque class."", ""Deque"")"
"If adding the element fails, for instance if the Deque is full, the push() method will throw an exception.","(""Deque"", ""The push method is a part of the Deque class and is used to add elements to it."", ""push""); (""Deque"", ""The push method is a part of the Deque class and is used to add elements to it."", ""push"")"
Here is an example of adding an element to the beginning of a Java Deque using the push() method:,NULL
The peek() method returns the first element from the beginning (head) of a Java Deque without removing it.,"(""Peek"", ""The Peek method is a member of the Deque class."", ""Deque""); (""Deque"", ""The Deque class is part of the Java package."", ""Java"")"
Here is an example of peeking at the first element of a Java Deque using the peek() method:,"(""Deque"", ""The peek() method is used to access the first element of the Java Deque class."", ""peek"")"
The peekFirst() method returns the first element from the beginning (head) of a Java Deque without removing it.,"(""PEEKFIRST"", ""The method peekFirst() acts on the Deque class by returning the first element from it."", ""DEQUE"")"
"This is similar to how peek() works, but the method name peekFirst() is a bit more saying about which end of the Deque you peek at.",NULL
Here is an example of peeking at the first element of a Java Deque using the peekFirst() method:,"(""Deque"", ""The peekFirst method is used to access the first element of the Deque class."", ""peekFirst"")"
To peek at the last element of a Java Deque you can use the peekLast() method.,NULL
Here is an example of peeking at the last element of a Java Deque using the peekLast() method:,"(""peekLast"", ""The peekLast method is used on the Java Deque class to peek at the last element."", ""Java Deque"")"
The getFirst() method returns the first element from the beginning (head) of a Java Deque without removing it.,"(""GetFirst"", ""The GetFirst method is a function applicable to instances of the Java Deque class, allowing it to return the first element."", ""Java Deque"")"
Here is an example of peeking at the first element of a Java Deque using the getFirst() method:,"(""getFirst"", ""The method getFirst is used to access the first element of the Deque class in Java."", ""Deque"")"
To peek at the last element of a Java Deque you can use the getLast() method.,"(""getLast"", ""The getLast method is used with the Deque class to access its last element."", ""Deque"")"
Here is an example of peeking at the last element of a Java Deque using the getLast() method:,"(""Deque"", ""The getLast method is used to access elements of the Deque class."", ""getLast"")"
The remove() method removes the first element of a Java Deque.,"(""Remove"", ""The remove method is applied to the Deque class to remove its first element."", ""Deque""); (""Remove"", ""The remove method is part of the collection of methods available in Java."", ""Java"")"
The remove() method returns the element that is removed from the Deque.,NULL
Here is an example of removing the first element a Java Deque using the remove() method:,"(""Remove"", ""The remove() method is applied to the Java Deque class to remove its first element."", ""Deque"")"
This is different from poll() which returns null if the Deque is empty.,"(""Poll"", ""The method 'poll()' is associated with 'Deque', indicating it operates on or is part of it."", ""Deque"")"
The removeFirst() method also removes the first element from a Deque - the element at the head of the Deque.,"(""RemoveFirst"", ""RemoveFirst is a method that operates on the Deque class to remove the first element."", ""Deque"")"
Here is an example of removing the first element of a Java Deque using the removeFirst() method:,NULL
This is different from pollFirst() which returns null if the Deque is empty.,NULL
The removeLast() method removes the last element of a Deque - meaning the element at the tail of the Deque.,"(""RemoveLast"", ""The method removeLast() operates on an instance of the Deque class by removing its last element."", ""Deque"")"
Here is an example of removing the last element of a Java Deque using the removeLast() method:,"(""Deque"", ""The removeLast() method is a function that operates on the Deque class to remove the last element."", ""removeLast()"")"
After running this Java example the removedElement variable will point to the String object element 2 - since that element was the last element of the Deque when removeLast() was called.,NULL
This is different from pollLast() which returns null if the Deque is empty.,"(""PollLast"", ""PollLast is a method associated with the Deque class as it operates on Deque objects."", ""Deque""); (""PollLast"", ""PollLast is a method associated with the Deque class as it operates on Deque objects."", ""Deque"")"
The poll() method removes an element from the beginning of the Deque.,NULL
This is different than remove() which throws an exception if the Deque is empty.,"(""Remove"", ""The method remove() is associated with the Exception class because it throws an exception when the Deque is empty."", ""Exception"")"
Here is an example of removing the first element from a Java Deque using the poll() method:,"(""Java Deque"", ""The poll() method is used to remove the first element from the Java Deque class."", ""poll"")"
"The pollFirst() method removes an element from the beginning of the Deque, just like poll().","(""PollFirst"", ""PollFirst is a method that operates on the Deque class to remove elements from the beginning."", ""Deque""); (""PollFirst"", ""PollFirst is similar to the Poll method in functionality."", ""Poll"")"
The method name pollFirst() is just a bit more saying about from where the method removes elements.,NULL
This is different than removeFirst() which throws an exception if the Deque is empty.,NULL
Here is an example of removing the first element from a Java Deque using the pollFirst() method:,"(""Deque"", ""The pollFirst method is used on the Deque class to remove the first element."", ""pollFirst"")"
The pollLast() method removes an element from the end (tail) of the Deque.,NULL
This is different than removeLast() which throws an exception if the Deque is empty.,NULL
Here is an example of removing the last element from a Java Deque using the pollLast() method:,"(""Deque"", ""The method 'pollLast' is used in the context of a 'Deque'."", ""pollLast"")"
The pop() method removes an element from the beginning (head) of a Java Deque.,"(""Pop"", ""The method Pop is used to remove an element from the Deque class."", ""Deque"")"
"If removing the element fails, for instance if the Deque is empty, the pop() method will throw an exception.","(""Deque"", ""The `pop()` method is used to remove an element from a `Deque`, indicating a functional relationship."", ""pop()"")"
Here is an example of removing the first element from a Java Deque using the pop() method:,NULL
You can use the Java Deque contains() method to check if a Deque contains a given element.,NULL
"The contains() method will return true if the Deque contains the element, and false if not.","(""Contains"", ""The Contains method is checking for the presence of an element in the Deque class"", ""Deque"")"
Here is an example of checking if a Java Deque contains a specific element using the contains() method:,"(""Deque"", ""The contains method is used to check if a specific element is present in the Deque class."", ""contains"")"
The Java Deque size() method returns the number of elements stored in the Java Deque at the time you invoke the method.,NULL
Here is an example of obtaining the number of elements in a Java Deque using its size() method:,NULL
After running this code the size variable will contain the value 2 because the Deque contains 2 element at the time size() is called.,"(""Deque"", ""The method size() is called on the Deque class to obtain the number of elements it contains."", ""size"")"
"When you have specified a generic type for a Java collection, that generic type also works for the Iterator returned by the iterator() method.",NULL
Notice how it is not necessary to cast the String returned from the iterator.next() method call.,"(""iterator"", ""The next method is called on the iterator object, indicating the relationship between the iterator class and the next method."", ""next""); (""next"", ""The next method returns a String, indicating the output type relationship between the method and the class."", ""String"")"
"Because the Iterator has its generic type set to String, the Java compiler already knows that next() will return a String.",NULL
The methods hashCode() and equals() play a distinct role in the objects you insert into Java collections.,"(""HashCode"", ""The method hashCode() is important for objects inserted into Java collections."", ""Java Collections""); (""Equals"", ""The method equals() is important for objects inserted into Java collections."", ""Java Collections"")"
equals() is used in most collections to determine if a collection contains a given element.,NULL
"The ArrayList iterates all its elements and execute ""123"".equals(element) to determine if the element is equal to the parameter object ""123"".","(""ArrayList"", ""The method 'equals' is used by the class 'ArrayList' to perform element comparison."", ""equals"")"
It is the String.equals() implementation that determines if two strings are equal.,NULL
"The ArrayList again iterates all its elements and execute ""123"".equals(element) to determine if the element is equal to the parameter object ""123"".","(""ArrayList"", ""The ArrayList class uses the equals method to compare its elements with the parameter object '123' to check for equality."", ""equals""); (""ArrayList"", ""The ArrayList class uses the equals method to compare its elements with the parameter object '123' to check for equality."", ""equals"")"
"As you can see, a proper implementation of .equals() is essential for your own classes to work well with the Java Collection classes.",NULL
"That depends on your application, the classes, and what you are trying to do.","(""Classes"", ""class""); (""Classes"", ""class"")"
"The hashCode() method of objects is used when you insert them into a HashTable, HashMap or HashSet.","(""HashCode"", ""The HashCode method is used when inserting objects into a HashTable."", ""HashTable""); (""HashCode"", ""The HashCode method is used when inserting objects into a HashMap."", ""HashMap""); (""HashCode"", ""The HashCode method is used when inserting objects into a HashSet."", ""HashSet"")"
"If you do not know the theory of how a hashtable works internally, you can read about hastables on Wikipedia.org.","(""Hashtable"", ""The class Hashtable can be studied in detail further using resources available on Wikipedia.org"", ""Wikipedia.org"")"
The hashtable then iterates this area (all keys with the same hash code) and uses the key's equals() method to find the right key.,"(""Equals"", ""The equals() method is used to find the right key by comparing keys in the hash code area."", ""Key"")"
"So, as you can see, a combination of the hashCode() and equals() methods are used when storing and when looking up objects in a hashtable.","(""HashCode"", ""The HashCode and Equals methods are often used together to ensure objects are correctly stored and retrieved in data structures like hashtables."", ""Equals""); (""HashCode"", ""The HashCode method is used in conjunction with hashtables to optimize object storage and retrieval."", ""Hashtable""); (""Equals"", ""The Equals method is crucial in hashtables for comparing object equality during lookup operations."", ""Hashtable"")"
"Here are two rules that are good to know about implementing the hashCode() method in your own classes, if the hashtables in the Java Collections API are to work correctly:",NULL
Here are two example implementation of the hashCode() method matching the equals() methods shown earlier:,NULL
For a 100% precise description of how to implement equals() and hashCode() you should check out the official JavaDoc's.,"(""EQUALS"", ""Both methods are commonly implemented together in Java classes for object equality and hashing purposes."", ""HASHCODE""); (""EQUALS"", ""The JavaDoc is the official documentation providing guidance on implementing the method equals()."", ""JAVADOC""); (""HASHCODE"", ""The JavaDoc is the official documentation providing guidance on implementing the method hashCode()."", ""JAVADOC""); (""EQUALS"", ""Both methods are commonly implemented together in Java classes for object equality and hashing purposes."", ""HASHCODE""); (""EQUALS"", ""The JavaDoc is the official documentation providing guidance on implementing the method equals()."", ""JAVADOC""); (""HASHCODE"", ""The JavaDoc is the official documentation providing guidance on implementing the method hashCode()."", ""JAVADOC"")"
The purpose of this text was mostly to explain how they are used by the Java Collection classes.,"(""Java Collection"", ""Java Collection is being used with Java Collection classes"", ""Classes"")"
"This means, that a class that implements the Java Iterable interface can have its elements iterated.","(""Class"", ""A class implements the Iterable interface"", ""Iterable""); (""Iterable"", ""The Iterable interface belongs to the package Java"", ""Java"")"
"You can iterate the objects of a Java Iterable in three ways: Via the , by obtaining a Java Iterator from the Iterable, or by calling the Java Iterable forEach() method.",NULL
"Then it uses a for-each loop to iterate the elements of the List, and print out the toString() value of each element.",NULL
The second way you can iterate the elements of a Java Iterable is by obtaining a Java Iterator from it by calling the Iterable iterator() method.,NULL
The third way to iterate the elements of a Java Iterable is via its forEach() method.,"(""Iterable"", ""The forEach method is used to iterate through the elements of the Iterable class."", ""forEach""); (""forEach"", ""The forEach method is associated with Java as it is part of the Java API for iteration."", ""Java"")"
Here is an example of iterating the elements of an Iterable via its forEach() method:,"(""Iterable"", ""The forEach method is used to iterate over the elements of the Iterable class."", ""forEach"")"
The Java Iterable interface (java.lang.Iterable) is one of the root interfaces of the Java Collections API.,"(""Iterable"", ""The Iterable class is part of the Java Collections API."", ""Collections API"")"
"Therefore, there are several classes in Java that implements the Java Iterable interface.","(""Java"", ""Java implements the Iterable interface, indicating a direct relationship between the class Java and the interface Iterable."", ""Iterable"")"
You can obtain a Java Spliterator from a Java Iterable via its spliterator() method.,"(""Iterable"", ""The method spliterator() is called on the Iterable class to obtain a Spliterator."", ""spliterator()"")"
"If you are writing some code that needs to iterate a collection lots of times in a tight loop, let's say iterate a Java List thousands of times per second, iterating the List via the Java for-each loop is slower than iterating the list via a standard for-loop as seen here: () .",NULL
"The reason the for-each loop is slower is, that each iteration will call the List iterator() method, which will create a new Iterator object.","(""List"", ""The 'iterator' method is called by instances of the 'List' class."", ""iterator"")"
The standard Java collection interface Collection contains a method called iterator().,NULL
By calling iterator() you can obtain an iterator from the given Collection.,"(""iterator"", ""The method 'iterator()' is used to obtain an iterator from the 'Collection' class."", ""Collection"")"
"You can also obtain an Iterator from many of the Java Collection data structures, e.g.","(""Collection"", ""An Iterator can be obtained from a Collection, indicating an operational relationship between these two classes."", ""Iterator""); (""Java"", ""The Collection class is part of the Java package, suggesting a hierarchical or ownership relationship."", ""Collection""); (""Collection"", ""An Iterator can be obtained from a Collection, indicating an operational relationship between these two classes."", ""Iterator""); (""Java"", ""The Collection class is part of the Java package, suggesting a hierarchical or ownership relationship."", ""Collection"")"
The first method is the Iterator hasNext() method which returns true if the Iterator contains more elements.,NULL
"In other words, if the Iterator has not yet iterated over all of the elements in the collection the Iterator was obtained from - the hasNext() method will return true.",NULL
If the Iterator has iterated over all elements in the underlying collection - the hasNext() method returns false.,"(""Iterator"", ""The hasNext() method is likely a member function of the Iterator class, checking the availability of more elements."", ""hasNext"")"
The second method to pay attention to is the next() method.,"(""Next"", ""Method"")"
The next() method returns the next element of the collection the Iterator is iterating over.,"(""Next"", ""The next() method is associated with the Iterator class because it is used to return the next element in the collection that the Iterator is iterating over."", ""Iterator"")"
In that case you will get a ConcurrentModificationException the next time you call the Iterator next() method.,"(""Iterator"", ""The 'next()' method is called on an instance of the 'Iterator' class."", ""next()""); (""next()"", ""Calling the 'next()' method can result in a 'ConcurrentModificationException'."", ""ConcurrentModificationException"")"
The Java Iterator interface has a remove() method which lets you remove the element just returned by next() from the underlying collection.,"(""Iterator"", ""The method remove() is part of the Iterator interface."", ""remove()""); (""Iterator"", ""The method next() is part of the Iterator interface."", ""next()""); (""remove()"", ""The remove() method operates on the element returned by the next() method."", ""next()"")"
"The Java Iterator forEachRemaining() method can iterate over all of the elements remaining in the Iterator internally, and for each element call a Java Lambda Expression passed as parameter to forEachRemaining() .","(""Iterator"", ""The forEachRemaining method belongs to or operates on the Iterator class."", ""forEachRemaining""); (""forEachRemaining"", ""The forEachRemaining method can call a Lambda Expression, indicating an interaction or usage relationship."", ""Lambda Expression""); (""Iterator"", ""The forEachRemaining method belongs to or operates on the Iterator class."", ""forEachRemaining""); (""forEachRemaining"", ""The forEachRemaining method can call a Lambda Expression, indicating an interaction or usage relationship."", ""Lambda Expression"")"
Here is an example of using the Java Iterator forEachRemaining() method:,"(""Java Iterator"", ""The forEachRemaining method is a function that belongs to the Java Iterator class, indicating functionality typically associated with iterating over elements."", ""forEachRemaining"")"
"The Java List interface, java.util.List, represents an ordered sequence of objects.","(""Java List"", ""The Java List interface is part of the package java.util.List, which indicates a package-class relationship."", ""java.util.List"")"
"If the List is not typed, using Java Generics, then you can even mix objects of different types (classes) in the same List.","(""List"", ""The List is not typed by Java Generics, indicating a relationship between the data structure and the package managing types."", ""Java Generics"")"
These List implementations are explained in more detail in my java.util.concurrent tutorial .,"(""java.util.concurrent"", ""The class List is implemented in the package java.util.concurrent as part of Java's concurrent utilities."", ""List"")"
You create a List instance by creating an instance of one of the classes that implements the List interface.,"(""List"", ""The List class is related to the List interface as the class implements the interface."", ""List"")"
"Remember, most often you will use the ArrayList class, but there can be cases where using one of the other implementations might make sense.","(""ArrayList"", ""class"")"
"Thus, you need to cast them to the concrete class (or interface) that you know the object to be of.","(""Class"", ""class""); (""Class"", ""class"")"
You insert elements (objects) into a Java List using its add() method.,"(""Java List"", ""The add() method is used to insert elements (objects) into a Java List, indicating a functional relationship between the class and the method."", ""add()"")"
Here is an example of adding elements to a Java List using the add() method:,"(""List"", ""The add() method is used by the List class to add elements to it."", ""add()""); (""List"", ""The add() method is used by the List class to add elements to it."", ""add()"")"
The first three add() calls add a String instance to the end of the list.,NULL
"The List interface has a version of the add() method that takes an index as first parameter, and the element to insert as the second parameter.",NULL
"The addAll() method takes a Collection as parameter, so you can pass either a List or Java Set as parameter.","(""AddAll"", ""The AddAll method takes a Collection as a parameter."", ""Collection""); (""Collection"", ""List is a type of Collection."", ""List""); (""Collection"", ""Java Set is a type of Collection."", ""Java Set"")"
"In other words, you can add all elements from a List or Set into a List with addAll() .",NULL
The indexOf() method finds the index of the first occurrence in the List of the given element.,NULL
The lastIndexOf() method finds the index of the last occurrence in the List of a given element.,"(""Lastindexof"", ""The Lastindexof method operates on a List by finding the index of the last occurrence of a given element."", ""List"")"
You can check if a Java List contains a given element using the List contains() method.,"(""List"", ""The 'contains()' method is used to check if a List class contains a given element."", ""contains()"")"
Here is an example of checking if a Java List contains an element using the contains() method:,"(""Java List"", ""The contains() method is used to check if an element is present within the Java List class."", ""contains()"")"
"Obviously, if the input parameter to contains() is null, the contains() method will not use the equals() method to compare against each element, but rather use the == operator.",NULL
The Java List interface contains a clear() method which removes all elements from the list when called.,NULL
Here is simple example of removing all elements from a List (clearing) with the clear() method:,NULL
"After the clear() method has been called, the List will be completely empty.",NULL
The Java List interface has a method called retainAll() which is capable of retaining all elements from one List which are also present in another List.,NULL
"In other words, the retain() method removes all the elements from the target List which are not found in the other List.","(""Retain"", ""The Retain method operates on List objects to remove certain elements."", ""List"")"
Here is a Java example of calling the List retainAll() method:,"(""List"", ""The method retainAll() is called on the class List in Java."", ""retainAll()"")"
"Third, the retainAll() method is called on list, passing otherList as parameter.",NULL
"After list.retainAll(otherList) has finished executing, the list will only contain those elements which were both present in list and otherList before retainAll() was called.","(""List"", ""The `retainAll` method is called on the list, indicating that it belongs to or is used by the List class."", ""RetainAll""); (""List"", ""The operation `retainAll` compares elements between the list and otherList, indicating a relationship where both lists are involved in the operation."", ""OtherList"")"
You can obtain the number of elements in the List by calling the size() method.,NULL
The Java List interface has a method called subList() which can create a new List with a subset of the elements from the original List.,NULL
The subList() method takes 2 parameters: A start index and and end index.,NULL
Here is a Java example of creating a sublist of elements from another List using the subList() method:,"(""Sublist"", ""The subList() method is associated with the Sublist class."", ""Sublist""); (""Sublist"", ""The subList() method is used to create a sublist from a List."", ""List""); (""Sublist"", ""The subList() method is associated with the Sublist class."", ""Sublist""); (""Sublist"", ""The subList() method is used to create a sublist from a List."", ""List"")"
"After executing the list.subList(1,3) instruction the sublist will contain the elements at index 1 and 2.",NULL
"The list.subList(1,3) call will include index 1, but exclude index 3, thereby keeping the elements at index 1 and 2.",NULL
You can convert a Java List to a Java Array using the List toArray() method.,"(""List"", ""The toArray() method is used on the List class to convert it to an Array."", ""toArray"")"
"Note that even if we pass a String array of size 0 to the toArray(), the array returned will have all the elements in the List in it.","(""ToArray"", ""The toArray method is related to the List class because the method is being used to convert the elements of a List into an array."", ""List""); (""String"", ""The String class is used as a parameter to the toArray method to specify the type of the array being returned."", ""ToArray"")"
It is the Arrays.asList() method that converts the array to a List.,"(""Arrays.asList()"", ""The Arrays.asList() method is used to convert the array to a List."", ""List"")"
You can sort a Java List using the Collections sort() method.,"(""Collections"", ""The sort() method is part of the Collections package."", ""sort()""); (""Java List"", ""The sort() method is used to sort a Java List."", ""sort()"")"
"If the List contains objects that implement the Comparable interface (java.lang.Comparable), then the objects can compare themselves to each other.","(""List"", ""List contains objects that implement the Comparable interface, allowing them to compare to each other."", ""Comparable""); (""List"", ""List contains objects that implement the Comparable interface, allowing them to compare to each other."", ""Comparable"")"
"The Java String class implements the Comparable interface, you can sort them in their natural order, using the Collections sort() method.",NULL
"If the objects in the Java List do not implement the Comparable interface, or if you want to sort the objects in another order than their compare() implementation, then you need to use a Comparator implementation (java.util.Comparator).","(""Java List"", ""Java List may need to implement Comparable Interface to ensure sorting using compare()"", ""Comparable Interface""); (""Java List"", ""Java List can use a Comparator Implementation to sort objects if they do not implement Comparable"", ""Comparator Implementation""); (""Comparator Implementation"", ""Comparator Implementation refers to the package Java Util Comparator"", ""Java Util Comparator"")"
You obtain an Iterator by calling the iterator() method of the List interface.,"(""List"", ""The iterator() method is part of the List class."", ""iterator()""); (""iterator()"", ""The Iterator is obtained by calling the iterator() method."", ""Iterator"")"
Once you have obtained an Iterator you can keep calling its hasNext() method until it returns false.,"(""Iterator"", ""The hasNext() method is a function that belongs to the Iterator class, used to check if there are more elements to iterate over."", ""hasNext"")"
Calling hasNext() is done inside a while loop as you can see.,NULL
Inside the while loop you call the Iterator next() method of the Iterator interface to obtain the next element pointed to by the Iterator.,NULL
"Inside the for loop the example accesses the elements in the List via its get() method, passing the incrementing variable i as parameter.","(""GET"", ""The GET method is used to access elements from the LIST class."", ""LIST"")"
"Again, if the List is typed using Java Generics to e.g.",NULL
"Hence, the compiler knows that only a String can be returned from the get() method.",NULL
Therefore you do not need to cast the element returned by get() to String.,NULL
Obtaining a Stream from a List in Java is done by calling the List stream() method.,NULL
It is the last line of this example that calls the List stream() method to obtain the Stream representing the elements in the List.,"(""List"", ""The List class is calling the stream() method to obtain a Stream object."", ""stream""); (""stream"", ""The stream() method is used to obtain a Stream, indicating a functional transformation from a List to a Stream."", ""Stream"")"
Once you have obtained a Stream from a List you can iterate the Stream by calling its forEach() method.,NULL
Here is an example of iterating the elements of a List using the Stream forEach() method:,NULL
"Calling the forEach() method will make the Stream iterate all the element of the Stream internally, and call the Consumer passed as parameter to the forEach() method for each element in the Stream.","(""ForEach"", ""The forEach method is called on the Stream class to iterate through its elements."", ""Stream""); (""ForEach"", ""The forEach method receives a Consumer as a parameter to be invoked for each element in the Stream."", ""Consumer"")"
"The Java Map interface, java.util.Map, represents a mapping between a key and a value.","(""Java Map Interface"", ""The Java Map Interface is described in the package java.util.Map, indicating it is a part of or implemented in that package."", ""java.util.Map"")"
To create a Java Map you must create an instance of one the classes that implement the Java Map interface.,"(""Java Map"", ""Java Map is a class that is implemented by the Java Map Interface."", ""Java Map Interface"")"
To add elements to a Map you call its put() method.,"(""Map"", ""The put() method is called on the Map class, indicating it's a method of the Map class."", ""Put"")"
The three put() calls maps a string value to a string key.,"(""Put"", ""The put() calls are related as they all appear to be examples of method calls mapping string values to string keys."", ""Put"")"
Here is an example of auto-boxing primitive parameters passed to the put() method:,"(""PUT"", ""method""); (""PUT"", ""method"")"
The value passed to the put() method in the above example is a primitive int.,NULL
"Java auto-boxes it inside an Integer instance though, because the put() method requires an Oject instance as both key and value.","(""Put"", ""The put() method requires an Object instance as both key and value."", ""Object"")"
Auto-boxing would also happen if you passed a primitive as key to the put() method.,NULL
"If you call put() more than once with the same key, the latest value passed to put() for that key will overwrite what is already stored in the Map for that key.","(""Put"", ""The method 'put' is a function that operates on the class 'Map', where it is used to insert values associated with specific keys."", ""Map"")"
To obtain the value stored by the null key you call the get() method with null as parameter value.,"(""Get"", ""The get method is used to obtain the value stored by the null key."", ""Null Key"")"
Just keep in mind that you will get a null out when you call get() later with that key - so this will return null:,NULL
The Java Map interface has a method called putAll() which can copy all key + value pairs (entries) from another Map instance into itself.,"(""Map"", ""The putAll method is a part of the Map interface, allowing it to copy key-value pairs from another Map."", ""putAll"")"
Here is an example of copying all entries from one Java Map into another via putAll():,"(""PUTALL"", ""The method putAll is used with the Java class Map to copy all entries from one map to another."", ""MAP"")"
"Calling mapB.putAll(mapA) will only copy entries from mapA into mapB, not from mapB into mapA.",NULL
"To copy entries the other way, you would have to execute the code mapA.putAll(mapB).","(""PutAll"", ""method"")"
"To get a specific element stored in a Java Map you call its get() method, passing along the key for that element as parameter.","(""Map"", ""The get method is a function used to retrieve a specific element stored in a Map class."", ""get"")"
"Notice that the get() method returns a Java Object, so we have to cast it to a String (because we know the value is a String).","(""Get"", ""The get() method is part of a Java class involving object retrieval and handling."", ""Java""); (""Get"", ""The get() method is used to retrieve a Java Object that is explicitly cast to a String."", ""String"")"
"If we had specified a generic type for the key and value of the Map, then it would not have been necessary to cast the object returned by get() method.","(""Map"", ""The 'get' method is used to retrieve a value from the 'Map' class based on a specified key."", ""get"")"
The Java Map interface has a getOrDefault() method which can return a default value supplied by you - in case no value is stored in the Map by the given key.,NULL
"This example creates a Map and stores three values in it using the keys A, B and C. Then the example calls the Map getOrDefault() method, passing the String E as key, along with a default value - the String default value.",NULL
Since the Map does not contain any object stored by the key E the given default value will be returned - which is the String default value passed as the last parameter to the getOrDefault() method.,"(""GetOrDefault"", ""The getOrDefault method returns a default value of type String."", ""String""); (""GetOrDefault"", ""The getOrDefault method is used with the Map class to retrieve values."", ""Map""); (""GetOrDefault"", ""The getOrDefault method returns a default value of type String."", ""String""); (""GetOrDefault"", ""The getOrDefault method is used with the Map class to retrieve values."", ""Map"")"
You can check if a Java Map contains a specific key using the containsKey() method.,NULL
You can iterate all the keys of a Java Map via its keySet() method.,"(""Java Map"", ""The keySet() method is a method of the Java Map class that allows iteration over all the keys."", ""keySet()"")"
"As you can see, the key Iterator returns every key stored in a Java Map, one by one (one for each call to next()).","(""Iterator"", ""The Iterator class is used to iterate through entries in a Map class."", ""Map""); (""Iterator"", ""The next method is called on an Iterator instance to return the next key in the sequence."", ""next""); (""Iterator"", ""The Iterator class is used to iterate through entries in a Map class."", ""Map""); (""Iterator"", ""The next method is called on an Iterator instance to return the next key in the sequence."", ""next"")"
"Once you have the key, you can obtain the element stored for that key using the Map get() method.","(""Map"", ""The get() method belongs to the Map class, as it is used to retrieve elements stored in the map."", ""get"")"
"In the example above, the Iterator next() method returns an Object - and so does the get() method.","(""Iterator next()"", ""The Iterator next() method returns an Object, indicating a call relationship."", ""Object""); (""get()"", ""The get() method returns an Object, indicating a call relationship."", ""Object""); (""Iterator next()"", ""The Iterator next() method returns an Object, indicating a call relationship."", ""Object""); (""get()"", ""The get() method returns an Object, indicating a call relationship."", ""Object"")"
Notice how a generic type is now also specified for the Iterator obtained from map.keySet().iterator().,NULL
You obtain a Collection of the values stored in a Map via the values() method.,"(""Map"", ""The values() is a method that is used to retrieve the values stored in a Map."", ""values()""); (""values()"", ""The values() method returns a Collection of the values stored in a Map."", ""Collection"")"
Notice how the key and value can be obtained from each Map.Entry instance.,NULL
You can remove all entries in a Java Map using the clear() method.,NULL
It is possible to replace an element in a Java Map using the replace() method.,"(""Map"", ""The replace() method is used to operate on the Map class."", ""replace()"")"
The replace() method will only insert the new value if there is already an existing value mapped to the key.,NULL
"This is different from how put() works, which always insert the value no matter what.",NULL
Here is an example of replacing one value with another using the Java Map replace() method:,"(""Map"", ""The replace method is used on the Map class to replace a value with another."", ""replace""); (""replace"", ""The replace method is part of the Java package."", ""Java"")"
You can read the number of entries in a Java Map using the size() method.,NULL
The number of entries in a Java Map is also referred to as the Map size - hence the method name size() .,"(""Map"", ""The method 'size()' is related to the 'Map' class because it is used to determine the number of entries in a Map."", ""size"")"
Here is an example of reading the number of entries in a Map using the size() method:,"(""Map"", ""The size() method is used to determine the number of entries in a Map class."", ""size()""); (""Map"", ""The size() method is used to determine the number of entries in a Map class."", ""size()"")"
This method is called isEmpty() and it returns either true or false.,"(""IsEmpty"", ""method"")"
The isEmpty() method will return false if the Map instance contains 1 or more entries.,NULL
The Map compute() method takes a key object and a lambda expression as parameters.,"(""Map"", ""The compute() method belongs to the Map class, indicating that compute is a method within the Map class."", ""compute"")"
Here is an example of calling the Java Map compute() method:,"(""Map"", ""The 'compute()' method is part of the 'Map' class."", ""Compute"")"
"The compute() method will call the lambda expression internally, passing the key object and whatever value is stored in the Map for that key object, as parameters to the lambda expression.",NULL
"In the example above you can see that the lambda expression checks if the value mapped to the given key is null or not, before calling toString().toUpperCase() on it.","(""toString"", ""Method toString is used to convert an object to a string format before toUpperCase is applied to convert that string to uppercase."", ""toUpperCase""); (""toString"", ""Method toString is used to convert an object to a string format before toUpperCase is applied to convert that string to uppercase."", ""toUpperCase"")"
"The Map computeIfAbsent() method works similarly to the compute() method, but the lambda expression is only called if no entry exists already for the given key.",NULL
"However, the lambda expression could have calculated the value in any way it needed to - e.g.",NULL
"The Map merge() method takes a key, a value, and a lambda expression implementing the BiFunction interface as parameters.","(""Map"", ""The merge() method belongs to the Map class."", ""merge()""); (""merge()"", ""The merge() method uses a BiFunction lambda expression as a parameter."", ""BiFunction"")"
"If the Map does not have an entry for the key, or if the value for the key is null, the value passed as parameter to the merge() method is inserted for the given key.","(""Merge"", ""The merge method is a function or operation that is applied to an instance of the Map class to modify or update its entries based on given parameters."", ""Map"")"
"The Java NavigableMap interface, java.util.NavigableMap, is a sub-interface of the Java SortedMap interface.",NULL
The java.util package only has one implementation of the NavigableMap interface: The java.util.TreeMap class.,NULL
"There is a Java NavigableMap implementation in the java.util.concurrent package too, but that is outside the scope of this tutorial.",NULL
To create a Java NavigableMap you must create an instance of one of the classes that implements the NavigableMap interface.,NULL
Here is an example of creating an instance of the Java TreeMap class which implements the NavigableMap interface:,"(""TreeMap"", ""TreeMap implements the NavigableMap interface"", ""NavigableMap"")"
The first interesting navigation method of NavigableMap is the descendingKeySet() method.,"(""NavigableMap"", ""The method 'descendingKeySet()' belongs to the class 'NavigableMap'."", ""descendingKeySet()"")"
The descendingKeySet() method returns a NavigableSet in which the order of the elements is reversed compared to the original key set.,"(""descendingKeySet"", ""The method descendingKeySet is related to NavigableSet because it returns an object of type NavigableSet."", ""NavigableSet"")"
The descendingMap() method returns a NavigableMap which is a view of the original Map.,"(""DescendingMap"", ""The descendingMap() method returns a NavigableMap, indicating a functional relationship where descendingMap() creates or works with NavigableMap."", ""NavigableMap""); (""NavigableMap"", ""NavigableMap is described as a view of the original Map, indicating an inheritance or reference relationship."", ""Map"")"
"The headMap() method returns a view of the original NavigableMap which only contains elements that are ""less than"" the given element.","(""headMap()"", ""The headMap() method is associated with NavigableMap, as it returns a view of a subset of elements from this class."", ""NavigableMap"")"
"The tailMap() method is similar to the headMap() method, except that tailMap() returns all elements that are equal to or higher than the given parameter element.",NULL
"The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys ""c"", ""d"" and ""e"", as these keys are considered equal to or larger than the parameter value ""c"" passed to the tailMap() method.","(""TailMap"", ""TailMap is assigned the result of invoking the TailMap() method"", ""TailMap()""); (""SortedMap"", ""TailMap stores key-value pairs from a NavigableMap into a SortedMap"", ""NavigableMap"")"
The subMap() allows you to pass two parameters demarcating the boundaries of the view map to return.,NULL
The ceilingKey() method returns the least (smallest) key in this map that is greater than or equal to the element passed as parameter to the ceilingKey() method.,"(""CeilingKey"", ""The CeilingKey is a method in the context provided."", ""Method"")"
"Thus, floorKey() returns the greatest key which is less than or equal to the parameter value passed to ceilingKey().","(""FloorKey"", ""FloorKey and CeilingKey are related as they both deal with key comparisons based on provided parameter values"", ""CeilingKey"")"
The higherKey() method returns the least (smallest) element in this map that is greater than (not equal too) the element passed as parameter to the higherKey() method.,NULL
"Thus, lowerKey() returns the greatest key which is lower than the parameter value passed to the lowerKey() method.",NULL
"In the example above, the returned lowerKey will be ""1"", as this is the highest key which is lower than the parameter value ""2"" passed to the lowerKey() method.",NULL
"methods, except they return a Map.Entry instead of the key object itself.",NULL
"Each of the methods ceilingEntry(), floorEntry(), higherEntry() and lowerEntry() will be covered in the following sections.",NULL
The ceilingEntry() method returns the key + value stored for the least (smallest) key in the NavigableMap which is higher than or equal to the parameter value passed to the ceilingEntry() method.,NULL
"The ceilingEntry() is thus similar to the ceilingKey() method, except the ceilingKey() method only returns the key, and ceilingKey() returns a Map.Entry object containing both the key and value.","(""ceilingEntry()"", ""Both are methods related to keys in data structures, with similar functionality."", ""ceilingKey()""); (""ceilingKey()"", ""ceilingKey() returns a Map.Entry, indicating a return-type relationship."", ""Map.Entry""); (""Map.Entry"", ""Map.Entry is an inner class of the Map package."", ""Map""); (""ceilingEntry()"", ""Both are methods related to keys in data structures, with similar functionality."", ""ceilingKey()""); (""ceilingKey()"", ""ceilingKey() returns a Map.Entry, indicating a return-type relationship."", ""Map.Entry""); (""Map.Entry"", ""Map.Entry is an inner class of the Map package."", ""Map"")"
"In the example above the returned ceilingEntry will contain the key ""c"" and the value ""3"", since the key ""c"" is the smallest key that is greater than or equal to the parameter value ""c"" passed to ceilingEntry() .",NULL
The floorEntry() method returns the key + value for the greatest key which is equal to or lower than the parameter value passed to the floorEntry() method.,"(""FloorEntry"", ""The relationship is between the method name 'floorEntry' in the text, referring to its description and functionality."", ""FloorEntry"")"
"The floorEntry returned in the example above will contain the key + value pair ""c"" + ""3"" , because key ""c"" is the greatest key which is lower than or equal to the parameter value ""c"" passed to the floorEntry() method.","(""FLOORENTRY"", ""The floorEntry method uses the parameter 'c'."", ""C""); (""C"", ""The key 'c' is associated with the value '3'."", ""3"")"
The higherEntry() method returns the key + value stored for the smallest key that is higher than the parameter value passed to the higherEntry() method.,NULL
"The higherEntry returned in the example above will contain the key + value pair ""d"" + ""4"" because the key ""d"" is the lowest key which is higher than the parameter value ""c"" passed to the higherEntry() method.",NULL
The lowerEntry() method in the NavigableMap interface returns the key + value pair for the highest key which is lower than the parameter value passed to the lowerEntry() method.,"(""LowerEntry"", ""The lowerEntry() method is a method within the NavigableMap interface, which suggests a clear association between the two."", ""NavigableMap"")"
"The lowerEntry returned in this example will be the key + value pair ""a"" + ""1"" since ""a"" is the highest key which is lower than the parameter value ""b"" passed to the lowerEntry() method.","(""LowerEntry"", ""The `lowerEntry` method requires a parameter value for operation, as indicated by the example involving the parameter 'b'."", ""Parameter"")"
"The pollFirstEntry() method returns and removes the ""first"" entry (key + value) in the NavigableMap or null if the map is empty.","(""PollFirstEntry"", ""The PollFirstEntry method operates on the NavigableMap to remove and return its first entry if it exists."", ""NavigableMap"")"
"The pollLastEntry() returns and removes the ""last"" element in the map or null if the map is empty.",NULL
"The Java NavigableSet interface, java.util.NavigableSet, is a subtype of the Java SortedSet interface.","(""NavigableSet"", ""The NavigableSet interface is a subtype of the SortedSet interface in Java, indicating an inheritance relationship."", ""SortedSet"")"
In Java 6 to 13 there is only one implementation of the NavigableSet interface in the java.util package: The java.util.TreeSet class.,NULL
There is an implementation in the java.util.concurrent package called ConcurrentSkipListSet but that is outside the scope of this trail.,"(""ConcurrentSkipListSet"", ""ConcurrentSkipListSet is implemented within the java.util.concurrent package."", ""java.util.concurrent"")"
To create a Java NavigableSet you must create an instance of one of the classes implementing the NavigableSet interface.,"(""NavigableSet"", ""The class implements the NavigableSet interface"", ""NavigableSet"")"
Here is an example of creating an instance of the class TreeSet which implements the NavigableSet interface:,NULL
The descendingSet() method returns a NavigableSet in which the order of the elements is reversed compared to this one.,"(""descendingSet"", ""The method 'descendingSet()' returns an instance of the 'NavigableSet' class, indicating a relationship where the method manipulates or produces objects of this class."", ""NavigableSet"")"
"The descendingIterator() method allows you to iterate the elements of the NavigableSet (which is also a SortedSet) in reverse order, without changing the order of the elements internally.",NULL
"The headSet() method returns a view of the original NavigableSet which only contains elements that are ""less than"" the given element.","(""HEADSET"", ""The headSet() method is a member of the NavigableSet class."", ""NAVIGABLESET"")"
"The tailSet() method works the same way as the headSet() method, except it returns all elements that are equal to or higher than the given parameter element.",NULL
The subSet() method allows you to pass two parameters demarcating the boundaries of the view set to return.,"(""SubSet"", ""The text explicitly refers to 'subSet()' as a method, indicating that 'subSet' is an instance of the class 'Method'."", ""Method"")"
The ceiling() method returns the least (smallest) element in this set that is greater than or equal to the element passed as parameter to the ceiling() method.,"(""Ceiling"", ""The ceiling() method is described to return an element from the set, thereby establishing its interaction with the set."", ""Set"")"
"The floor() method does the opposite of the ceiling() method, meaning it returns the greatest element that is less than or equal to the given parameter value.","(""Floor()"", ""The floor() method is mentioned as performing the opposite function of the ceiling() method"", ""Ceiling()"")"
The higher() method returns the least (smallest) element in this set that is greater than (not equal too) the element passed as parameter to the higher() method.,NULL
"The lower() method does the opposite of the higher() method, meaning it returns the highest element that is less than (not equal to) the given parameter.","(""Lower"", ""The 'lower()' method performs the opposite function of the 'higher()' method."", ""Higher""); (""Lower"", ""The 'lower()' method performs the opposite function of the 'higher()' method."", ""Higher"")"
"The pollFirst() method returns and removes the ""first"" element in the NavigableSet or null if the set is empty.",NULL
"The pollLast() method returns and removes the ""last"" element in the NavigableSet.","(""PollLast"", ""The method PollLast operates on the NavigableSet class by returning and removing the last element within it."", ""NavigableSet"")"
"The Java Properties class, java.util.Properties, is like a Java Map of Java String key and value pairs.","(""Properties"", ""The Properties class is part of the java.util package."", ""java.util.Properties""); (""Properties"", ""The Properties class is described as similar to a Map."", ""Map""); (""Map"", ""The Map is used in conjunction with String keys and values in the description."", ""String"")"
"The Java Properties class can write the key, value pairs to a properties file on disk, and read the properties back in again.",NULL
To use the Java Properties class you must first create a Properties instance.,"(""Properties"", ""class"")"
To set properties in a Java Properties instance you use the setProperty() method.,"(""Properties"", ""The setProperty method is used to set properties in a Properties class instance."", ""setProperty""); (""Properties"", ""The setProperty method is used to set properties in a Properties class instance."", ""setProperty"")"
"To get properties from a Java Properties object you use the getProperty() method, passing the key of the property to get as parameter.",NULL
"You can remove a property from a Java Properties instance using its remove() method, passing as parameter to remove() the key for the property to remove.",NULL
You store the contents of a Properties object via its store() method.,"(""Properties"", ""The store() method is a function of the Properties class, indicating a class-method relationship."", ""store()"")"
Notice the first line of the properties file is actually the comment that was passed as second parameter to the store() method call in the code example in the previous section about storing properties to a property file.,NULL
You can also load properties stored in a property file back into a Java Properties object via its load() method.,NULL
By default the load() method will assume that the loaded file is encoded using ISO-8859-1 (Latin-1).,"(""Load"", ""The Load is explicitly described as a method for processing files with specific encoding."", ""Method"")"
The Java Properties class can also write the key-value pairs stored in it to an XML file via its storeToXML().,NULL
"Notice how the comment passed to the storeToXML() method is enclosed in a comment XML element, and not in an XML comment (<!-- -->) .","(""StoreToXML"", ""The method storeToXML() utilizes comment XML elements within its function as described in the text."", ""comment XML element"")"
You can load properties from an XML property file into a Java Properties object via its loadFromXML() method.,NULL
By default the loadFromXML() method will assume that the XML file is stored using the UTF-8 encoding.,"(""LoadFromXML"", ""The method loadFromXML operates on the XML file to load its contents."", ""XML File"")"
It is possible to load properties into a Java Properties from a file that is available on the classpath.,"(""Properties"", ""Properties are loaded from a file available on the classpath."", ""Classpath"")"
"That file could thus be located inside the same JAR file as the application loading the properties, or inside another JAR file or directory available on the Java classpath when your Java application is executed.",NULL
To load properties from a file available on the classpath you need to obtain a Class instance first.,"(""Class"", ""A Class instance needs to be obtained to load properties from a file on the classpath."", ""load properties"")"
In the example below I obtain it from the class that contains the main() method of my application:,"(""Main"", ""The Main method is contained within the Class."", ""Class"")"
Once I have the Class instance I can call its getResourceAsStream() method which returns a Java InputStream referencing the file.,"(""Class"", ""The getResourceAsStream is a method of the Class entity."", ""getResourceAsStream""); (""getResourceAsStream"", ""The getResourceAsStream method returns an InputStream, establishing a relationship between the method and the InputStream class."", ""InputStream"")"
Here is an example of obtaining a reference to a file from the classpath:,NULL
The file would have to be located in the root directory of the classpath.,"(""CLASSPATH"", ""PACKAGE"")"
"If you put it into a subdirectory, the path passed to getResourceAsStream() should reflect that.","(""getResourceAsStream"", ""The path is passed as an argument to the getResourceAsStream method, suggesting a parameter-method relationship."", ""Path""); (""getResourceAsStream"", ""The path is passed as an argument to the getResourceAsStream method, suggesting a parameter-method relationship."", ""Path"")"
"Using the InputStream you can load the file into a Java Properties instance, using either the load() or loadFromXML() methods explained earlier in this Java Properties tutorial.","(""load()"", ""The load() method is a function that can be used with the Java Properties class to load properties."", ""Java Properties""); (""loadFromXML()"", ""The loadFromXML() method allows for loading properties from an XML file, which is a functionality of the Java Properties class."", ""Java Properties""); (""InputStream"", ""The InputStream is used as an input source for the load() method to load data into a Java Properties object."", ""load()""); (""InputStream"", ""The InputStream is also used as input for the loadFromXML() method to load XML data into a Java Properties object."", ""loadFromXML()"")"
"The ResourceBundle class is covered as part of that tutorial, in the Java ResourceBundle tutorial.",NULL
The Java Properties class has the ability to provide default property values for properties that do not have any key registered in the Properties instance.,"(""Properties"", ""The Properties class provides default property values when a key is not registered."", ""Default Property Values""); (""Default Property Values"", ""Default property values are used by the Properties class within Properties instances."", ""Properties Instance"")"
The getProperty() method comes in a version that takes an extra parameter which is the default value to return in case the Properties instance does not contain a value for the given key.,"(""getProperty()"", ""The getProperty() method likely operates on an instance of the Properties class."", ""Properties"")"
Here is an example of calling getProperty() with a default value:,"(""getProperty"", ""method""); (""getProperty"", ""method"")"
"If the Properties instance does not contain a property for the key preferredLanguage, then the value Danish will be returned - instead of returning null which would have been returned if no default value had been passed to getProperty().","(""Properties"", ""The getProperty method is a function associated with the Properties class, used to retrieve a property value."", ""getProperty""); (""Properties"", ""The getProperty method is a function associated with the Properties class, used to retrieve a property value."", ""getProperty"")"
The Java Properties class can be instantiated with another Properties instance containing default values to use when the newly created Properties instance does not contain a value for a requested property key.,"(""Properties"", ""A Properties instance can be instantiated with another Properties instance to provide default values."", ""Properties"")"
The System class also has a getProperty() and setProperty() method which are shortcuts to the Properties getProperty() and setProperty() methods of the System Properties instance.,"(""System"", ""getProperty is a method of the System class."", ""getProperty""); (""System"", ""setProperty is a method of the System class."", ""setProperty""); (""Properties"", ""getProperty is a method of the Properties class."", ""getProperty""); (""Properties"", ""setProperty is a method of the Properties class."", ""setProperty""); (""System"", ""System utilizes Properties for its getProperty() and setProperty() methods."", ""Properties""); (""System Properties"", ""System Properties is an instance of the Properties class."", ""Properties"")"
"The Java Properties class is a subclass of the Java Hashtable class, and as I will show you - this is actually a design mistake!","(""Properties"", ""The Properties class is a subclass of the Hashtable class."", ""Hashtable"")"
"It is a great example of when the classic ""Is a / Has a"" OOP rule about when to use inheritance vs. composition fails.",NULL
"Being a subclass of Hashtable, you can actually use the get() and put() method of the Hashtable class, which allow the use of non-string keys and values.",NULL
"This defeats the purpose of the Properties class, which is to function as a string,string map.",NULL
Notice how it is possible to call put() with non-string values.,"(""put"", ""method""); (""put"", ""method"")"
Just to make it clear: You should NOT use the put() and get() method of the Properties class!,"(""put()"", ""The put() method is used in the Properties class to add or update key-value pairs."", ""Properties""); (""get()"", ""The get() method is used in the Properties class to retrieve the value associated with a specified key."", ""Properties""); (""put()"", ""The put() method is used in the Properties class to add or update key-value pairs."", ""Properties""); (""get()"", ""The get() method is used in the Properties class to retrieve the value associated with a specified key."", ""Properties"")"
"If instead the value passed to put() had been two strings, then it would have worked as expected.",NULL
Notice how the second value passed to put() is now also a string.,NULL
"Even if you can get get() and put() to work, I would recommend that you do not use these methods.",NULL
"Using that formulation, Properties would not have been made a subclass of Hashtable, because Properties should not be usable as a Hashtable .","(""Properties"", ""Properties is mentioned as not being a subclass of Hashtable, indicating a discussion about inheritance or class relationship."", ""Hashtable"")"
"Instead, the Properties class should have just had an internal Hashtable to keep the property key,value pairs in.","(""Properties"", ""Properties class uses Hashtable to store key,value pairs internally."", ""Hashtable"")"
"The Java Queue interface, java.util.Queue represents a data structure designed to have elements inserted at the end of the queue, and elements removed from the beginning of the queue.","(""java.util.Queue"", ""The package java.util.Queue includes the class Queue as part of its data structure offerings."", ""Queue""); (""java.util.Queue"", ""The package java.util.Queue includes the class Queue as part of its data structure offerings."", ""Queue"")"
"There are also Queue implementations in the java.util.concurrent package, but I will leave the concurrency utilities out of this tutorial.","(""Queue"", ""Queue is mentioned as being implemented within the java.util.concurrent package"", ""java.util.concurrent"")"
"The add() and offer() methods differ in how the behave if the Queue is full, so no more elements can be added.","(""Add"", ""The add method interacts with the Queue when adding elements."", ""Queue""); (""Offer"", ""The offer method interacts with the Queue when adding elements."", ""Queue"")"
"The add() method throws an exception in that case, whereas the offer() method just returns false.",NULL
Here are two examples of adding elements to a Java Queue via its add() and offer() methods:,"(""Queue"", ""The add method is used to add elements to the Queue."", ""add""); (""Queue"", ""The offer method is used to add elements to the Queue."", ""offer"")"
To take an element from a Java Queue you can call either its poll() or remove() method.,"(""Queue"", ""The poll() method is associated with the Queue class as a way to retrieve elements."", ""poll()""); (""Queue"", ""The remove() method is associated with the Queue class as a way to retrieve elements."", ""remove()"")"
The poll() and remove() both removes the first element in the Queue.,"(""Poll"", ""Poll method operates on the Queue class to remove the first element."", ""Queue""); (""Remove"", ""Remove method operates on the Queue class to remove the first element."", ""Queue"")"
The remove() method throws an exception if the Queue is empty.,"(""Remove"", ""The remove method is explicitly associated with the Queue class in terms of functionality."", ""Queue"")"
Here are two examples of taking an element from a Java Queue using its poll() and remove() methods:,NULL
"The call to poll() will remove the first element of the Queue - which is the first Java String instance added - ""element 1"".",NULL
"The call to rmove() will remove the second element of the Queue - which after the first poll() call is now the String instance added - ""element 2"".","(""Rmove()"", ""Rmove() is a method that operates on the Queue class to remove elements from it."", ""Queue""); (""Poll()"", ""Poll() is a method that is called on the Queue class to manipulate its elements."", ""Queue""); (""Queue"", ""String is an instance of the data structure represented by the Queue class."", ""String"")"
"If the Queue is empty, the element() method throws a NoSuchElementException.","(""element()"", ""The element() method throws a NoSuchElementException when the Queue is empty."", ""NoSuchElementException""); (""element()"", ""The element() method operates on the Queue class."", ""Queue"")"
Here is an example of peeking at the first element of a Java Queue using the element() method:,NULL
The peek() works like the element() method except it does not throw an exception if the Queue is empty.,NULL
Here is an example of peeking at the first element of a Queue using the peek() method:,"(""Queue"", ""The 'peek()' method is associated with the 'Queue' class for accessing elements."", ""peek()"")"
"To remove elements from a Java Queue, you call the remove() method.","(""Queue"", ""The remove() method is used to operate on the Queue class by removing elements from it."", ""remove() method""); (""Queue"", ""The remove() method is used to operate on the Queue class by removing elements from it."", ""remove() method"")"
You can remove all elements from a Java Queue using its clear() method.,"(""Java Queue"", ""The 'clear' method is used to remove all elements from a Java Queue."", ""clear"")"
Here is an example of removing all elements from a Java Queue via its clear() method:,"(""Queue"", ""The method clear() is called on the Queue class to remove all elements."", ""clear"")"
You can read the number of elements stored in a Java Queue via its size() method.,"(""Queue"", ""The size() method is a part of the Queue class, used to determine the number of elements it contains."", ""size"")"
Here is an example of obtaining the size of a Java Queue via its size() method:,NULL
After running this code the size variable should contain the value 3 - because the Queue contains 3 elements at the time size() is called.,"(""size"", ""The method size is related to the class Queue as it refers to getting the number of elements in the Queue."", ""Queue""); (""size()"", ""The method call size() is related to the class Queue as it involves counting elements in the Queue."", ""Queue"")"
You can check if a Java Queue contains a certain element via its contains() method.,NULL
"The contains() method will return true if the Queue contains the given element, and false if not.",NULL
"The contains() method is actually inherited from the Collection interface, but in practice that doesn't matter.",NULL
"The Java Set interface, java.util.Set, represents a collection of objects where each object in the Java Set is unique.","(""Java Set"", ""Java Set is represented by the java.util.Set package."", ""java.util.Set"")"
"If the Set is not typed, using Java Generics, then you can even mix objects of different types (classes) in the same Set.",NULL
This example creates a HashSet which is one of the classes in the Java APIs that implement the Set interface.,"(""HashSet"", ""HashSet is a class that implements the Set interface, meaning it provides concrete methods for operations defined by the Set."", ""Set""); (""HashSet"", ""HashSet is one of the classes included within the Java APIs, indicating that it is a standard part of Java's library offerings."", ""Java APIs""); (""Set"", ""Set is an interface found within the Java APIs, suggesting it is a fundamental part of Java's collection framework."", ""Java APIs"")"
"In other words, the order in which the elements whould be sorted if you used a Collections.sort() on a List or array containing these elements.",NULL
"There are also Set implementations in the java.util.concurrent package, but I will leave the concurrency utilities out of this tutorial.","(""Set"", ""Set is implemented within the java.util.concurrent package"", ""java.util.concurrent"")"
The Java Set static factory methods are called of() and take either zero or more parameters.,"(""Java"", ""The Set class is part of the Java package, as implied by the context."", ""Set""); (""Set"", ""The of() method is a static factory method associated with the Set class, as mentioned in the text."", ""of()"")"
"Here is first an example of creating an empty, immutable Set using Set.of() :",NULL
Specifying a generic type of the Set returned by Set.of() looks like this:,"(""Set.of()"", ""The method Set.of() returns an object of type Set"", ""Set"")"
Here is an example of how creating a Set containing elements using the Set.of() method looks:,"(""Set"", ""The Set.of method is used to create an instance of the Set class."", ""Set.of"")"
To add elements to a Set you call its add() method.,"(""Set"", ""The add() method is used to add elements to an instance of the Set class."", ""add()"")"
The three add() calls add a String instance to the set.,NULL
You obtain an Iterator from a Set by calling the iterator() method.,NULL
You can remove all elements from a Java Set using the clear() method.,NULL
The Java List interface has a method called addAll() which adds all elements from another Collection (List or Set) to the Set.,NULL
The Java Set interface as a method called removeAll() which removes all elements in the Set which are also present in another Collection.,NULL
"The element three has been removed, because it was present in set2, which was given as parameter to set.removeAll(set2) .","(""RemoveAll"", ""The RemoveAll method is applied on a Set class."", ""Set""); (""RemoveAll"", ""Set2 is passed as an argument to the RemoveAll method."", ""Set2""); (""RemoveAll"", ""The RemoveAll method is applied on a Set class."", ""Set""); (""RemoveAll"", ""Set2 is passed as an argument to the RemoveAll method."", ""Set2"")"
You can check the size of a Java Set using the size() method.,NULL
"You can check if a Java Set is empty, meaning it contains no elements, by calling the isEmpty() method on the Set.","(""Set"", ""The isEmpty() method is used to check if a Set is empty or contains no elements."", ""isEmpty()"")"
You can also check if a Set is empty by comparing the value returned by the size() method with 0.,"(""Set"", ""The size() method is used to check the number of elements in a Set, making them related entities."", ""size()"")"
"After running this Java code the isEmpty variable will contain the value true, because the Set size() method returns 0 - because the Set in the example contains no elements.","(""Set"", ""The size() method is called on the Set class to determine the number of elements it contains"", ""size"")"
You can check if a Java Set contains a given element (object) by calling the contains() method.,NULL
"You can convert a Java Set to a Java List by creating a List and calling its addAll() method, passing the Set as parameter to the addAll() method.","(""List"", ""The addAll() method is called on the List to add elements."", ""addAll""); (""Set"", ""The Set is passed as a parameter to the addAll() method."", ""addAll"")"
"The Java SortedMap interface, java.util.SortedMap, is a subtype of the java.util.Map interface, with the addition that the elements stored in a Java SortedMap map are sorted internally.",NULL
Java comes with a built-in implementation of the Java SortedMap interface called TreeMap (java.util.TreeMap).,"(""SortedMap"", ""TreeMap is an implementation of the SortedMap interface."", ""TreeMap""); (""Java"", ""java.util.TreeMap is a part of the Java package."", ""java.util.TreeMap"")"
"The order of the sorting in a Java SortedMap is either the natural sorting order of the elements (if they implement java.lang.Comparable), or the order determined by a Comparator that you can give to the SortedSet.","(""SortedMap"", ""SortedMap uses the natural sorting order if the elements implement java.lang.Comparable."", ""java.lang.Comparable""); (""SortedMap"", ""SortedMap uses a Comparator to determine the order if provided."", ""Comparator"")"
But it is also possible to iterate the elements in descending order using the method TreeMap.descendingKeySet().,"(""TreeMap"", ""The 'descendingKeySet' method is part of the 'TreeMap' class."", ""descendingKeySet"")"
"You iterate the keys of a SortedMap by calling its keySet() method, like this:","(""SortedMap"", ""The keySet() method is used to iterate over the keys of a SortedMap."", ""keySet()"")"
"Remember, if you want to iterate the keys in descending order rather than ascending order, use the sortedMap.descendingKeySet().iterator() method, like this:",NULL
"If your Java SortedMap was created using a Comparator, you can obtain the Comparator used via the SortedMap comparator() method.",NULL
Here is an example of obtaining the Comparator used by a SortedMap via its comparator() method:,"(""SortedMap"", ""The comparator() method is used to obtain the Comparator associated with the SortedMap."", ""comparator()""); (""Comparator"", ""The Comparator is used by the SortedMap to determine the order of its elements."", ""SortedMap"")"
Here is an example of obtaining the first key of a SortedMap via its firstKey() method:,"(""SortedMap"", ""The firstKey() method is a function available within the SortedMap class."", ""firstKey()""); (""SortedMap"", ""The firstKey() method is a function available within the SortedMap class."", ""firstKey()"")"
Here is an example of obtaining the last key of a SortedMap via its lastKey() method:,NULL
The SortedMap interface has a method named headMap() which returns a new Map which contains the first elements of the SortedMap according to the sort order used.,"(""SortedMap"", ""The headMap method is part of the SortedMap interface."", ""headMap""); (""headMap"", ""The headMap method returns a new Map."", ""Map"")"
The headMap() method takes a parameter that acts as a delimiter for what elements gets included in the returned head map.,NULL
All elements with a key that is smaller than / earlier than the parameter passed to the headMap() method.,"(""headMap"", ""The headMap method retrieves elements with keys smaller than the specified parameter."", ""elements and keys""); (""headMap"", ""The headMap method retrieves elements with keys smaller than the specified parameter."", ""elements and keys"")"
Here is an example of obtaining a head map from a SortedMap via its headMap() method:,NULL
The SortedMap interface has a method named tailMap() which returns a new Map which contains the last elements of the SortedMap according to the sort order used.,NULL
The tailMap() method takes a parameter that acts as a delimiter for what elements gets included in the returned tail map.,"(""TailMap"", ""The tailMap method requires a parameter to determine which elements are included in the returned result"", ""Parameter"")"
All elements with a key that is equal to or larger than the parameter passed to the tailMap() method.,NULL
Here is an example of obtaining a tail map from a SortedMap via its tailMap() method:,NULL
"The tail map returned will contain the key, value pairs (""c"", ""3""), (""d"", ""4"") and (""e"", ""5""), since ""c"", ""d"" and ""e"" are larger than or equal to the ""c"" passed as parameter to tailMap() .","(""tailMap"", ""The character 'c' is passed as a parameter to the tailMap() method, and it is used to determine which key, value pairs are included in the returned map."", ""c"")"
The Java SortedMap also has a method named subMap() which can return a new Map which is a submap of the SortedMap.,NULL
The subMap() method takes two parameters which act as delimiters for what elements are included in the returned submap.,"(""SubMap"", ""Method""); (""SubMap"", ""Method"")"
Here is an example of obtaining a submap from a Java SortedMap via its subMap() method:,NULL
"The Java SortedSet interface, java.util.SortedSet, is a subtype of the java.util.Set interface.","(""SortedSet"", ""SortedSet interface is a subtype of the Set interface"", ""Set""); (""java.util.SortedSet"", ""Both are part of the java.util package"", ""java.util.Set"")"
The Java Collections API only has one implementation of the Java SortedSet interface - the java.util.TreeSet class.,"(""Java Collections API"", ""The Java SortedSet Interface is a component of the Java Collections API."", ""Java SortedSet Interface""); (""Java SortedSet Interface"", ""The java.util.TreeSet class is an implementation of the Java SortedSet Interface."", ""java.util.TreeSet"")"
"The java.util.concurrent package also has an implementation of this interface, but I will leave the concurrency utilities out of this trail.","(""Java.util.concurrent"", ""Package"")"
"It it possible to pass a Comparator, java.util.Comparator implementation to the constructor of the TreeSet.","(""Comparator"", ""Comparator is an implementation of the java.util.Comparator package."", ""java.util.Comparator""); (""Comparator"", ""Comparator is passed to the constructor of TreeSet."", ""TreeSet"")"
"For the SortedSet to be able to determine the natural order of the elements, the elements must implement the java.lang.Comparable interface.","(""SortedSet"", ""SortedSet requires elements to implement the java.lang.Comparable interface to determine the natural order."", ""java.lang.Comparable"")"
But it is also possible to iterate the elements in descending order using the method TreeSet.descendingIterator().,"(""TreeSet"", ""The method descendingIterator is a function of the class TreeSet."", ""descendingIterator"")"
"If you created your SortedSet with a Comparator, you can obtain that Comparator via the SortedSet comparator() method.","(""SortedSet"", ""The SortedSet class can be created with a Comparator, indicating a relationship between these two classes."", ""Comparator""); (""SortedSet"", ""The comparator() method is associated with the SortedSet class to obtain the Comparator."", ""comparator()""); (""SortedSet"", ""The SortedSet class can be created with a Comparator, indicating a relationship between these two classes."", ""Comparator""); (""SortedSet"", ""The comparator() method is associated with the SortedSet class to obtain the Comparator."", ""comparator()"")"
Here is an example of obtaining the Comparator used by a SortedSet via the comparator() method:,"(""SortedSet"", ""The SortedSet uses the Comparator to determine the order of its elements."", ""Comparator""); (""comparator()"", ""The comparator() method is used to obtain the Comparator used by the SortedSet."", ""Comparator"")"
You add elements to a Java SortedSet in the same way you do with a normal Java Set - via its add() method.,NULL
"To remove an element from a SortedSet you call its remove() method, passing the element to remove as parameter.",NULL
You can get the first element of a SortedSet according to its sort order by calling the first() method of the SortedSet.,NULL
You can get the last element of a SortedSet according to its sort order by calling the last() method of the SortedSet.,"(""SortedSet"", ""The last method is part of the SortedSet class, allowing retrieval of the last element according to sort order."", ""last"")"
"You call the SortedSet iterator() method which returns an Iterator, and then you can iterate the elements via that.",NULL
"The Java SortedSet interface has a method named headSet() which returns another SortedSet with all elements that are smaller than (ahead of) a given parameter value, according to the sort order used by the SortedSet.",NULL
Here is an example of obtaining a head set from a Java SortedSet via its headSet() method:,NULL
"After running this code the headSet will contain the elements ""a"" and ""b"" since these two elements are smaller than (ahead of) the parameter value ""c"" that was passed to the headSet() method.",NULL
"The Java SortedSet interface has a method named setSet() which returns another SortedSet with all elements that are greater than or equal to (tailing) a given parameter value, according to the sort order used by the SortedSet.","(""SortedSet"", ""The method setSet() is a function defined within the SortedSet class."", ""setSet""); (""Java"", ""SortedSet is an interface in the Java package."", ""SortedSet""); (""SortedSet"", ""The method setSet() is a function defined within the SortedSet class."", ""setSet""); (""Java"", ""SortedSet is an interface in the Java package."", ""SortedSet"")"
Here is an example of obtaining a tail set from a Java SortedSet via its tailSet() method:,"(""SortedSet"", ""The tailSet() method is used to obtain a tail set from the SortedSet class."", ""tailSet""); (""SortedSet"", ""SortedSet is a class that is part of the Java package."", ""Java"")"
"After running this code the tailSet will contain the elements ""c"", ""d"" and ""e"", since these three elements are greater than or equal to (tailing) the parameter value ""c"" that was passed to the tailSet() method.",NULL
The Java SortedSet interface has a method named subSet() method which will return a new SortedSet which is a subset of the SortedSet the subSet() method is called on.,NULL
The subSet() method takes two parameter values which specify what elements the returned SortedSet should contain.,"(""Subset"", ""The Subset method returns a collection of elements within the SortedSet that match specified criteria."", ""Sortedset"")"
Here is an example of obtaining a subset of a Java SortedSet via its subSet() method:,"(""SortedSet"", ""The subSet() method is used to obtain a subset from a SortedSet class."", ""subSet"")"
Notice how there is no longer a cast of the object returned from iterator.next() needed.,NULL
"Because the generic type of the SortedSet is String, the compiler knows that the iterator is an Iterato<String>, so next() return String objects.",NULL
You can sort a Java List collections using the java.util.Collections.sort() method.,NULL
For objects to have a natural order they must implement the interface java.lang.Comparable.,NULL
"The compareTo() method should compare this object to another object, return an int value.",NULL
"So, if a string is less than another string by alphabetic comparison it will return a negative number from the compareTo() method.","(""String"", ""The CompareTo method is being used to compare strings alphabetically."", ""CompareTo"")"
When you implement the compareTo() method in your own classes you will have to decide how these objects should be compared to each other.,"(""CompareTo"", ""The compareTo method is implemented within classes."", ""Classes"")"
Notice how the Collections.sort() method now takes a java.util.Comparator as parameter in addition to the List.,"(""Collections.sort()"", ""The Collections.sort() method uses the java.util.Comparator as a parameter to determine the order of sorting."", ""java.util.Comparator""); (""Collections.sort()"", ""The Collections.sort() method sorts elements within a List."", ""List"")"
The compare() method compares two objects to each other and should:,"(""Compare"", ""Method""); (""Compare"", ""Method"")"
"There are a few more requirements to the implementation of the compare() method, but these are the primary requirements.",NULL
"If you want to compare objects by more than one factor, start by comparing by the first factor (e.g first name).",NULL
"Then, if the first factors are equal, compare by the second factor (e.g.",NULL
"The Java Stack class, java.util.Stack, is a classical stack data structure.","(""Stack"", ""The Stack class is a part of the java.util.Stack package."", ""java.util.Stack"")"
"The Java Stack class actually implements the Java List interface, but you rarely use a Stack as a List - except perhaps if you need to inspect all elements currently stored on the stack.",NULL
"Please note, that the Java Stack class is a subclass of Vector, an older Java class which is synchronized.",NULL
"Additionally, the Vector class uses several older (no longer recommended) parts of Java, like the Enumeration which is superseded by the Iterator interface.",NULL
To use a Java Stack you must first create an instance of the Stack class.,NULL
You push elements onto a Java Stack using its push() method.,"(""Java Stack"", ""The method 'push()' is used to add elements to the 'Java Stack' class."", ""push()"")"
You pop an element off a Java Stack using the pop() method.,"(""Java Stack"", ""The pop method is used to remove the top element from a Java Stack class."", ""pop"")"
Here is an example of popping an element off a Stack using the pop() method:,NULL
"The Java Stack class has a method called peek() which enables you to see what the top element on the Stack is, without popping off the element.",NULL
After running this Java example the topElement variable will contain the String object 1 which was pushed onto the Stack just before peek() was called.,"(""Stack"", ""The peek() method is called on the Stack class to access the top element without removing it."", ""peek()"")"
The String object is still present on the Stack after calling peek().,"(""PEEK"", ""The method 'peek()' is being called on the 'String' object, suggesting interaction."", ""STRING""); (""PEEK"", ""The method 'peek()' relates to the 'Stack', indicating it may act upon or retrieve something from the 'Stack'."", ""STACK"")"
"You can search for an object on the stack to get it's index, using the search() method.","(""SEARCH"", ""The search method operates on the object."", ""OBJECT""); (""SEARCH"", ""The search method is used to find an object's index in the stack."", ""STACK"")"
The object's equals() method is called on every object on the Stack to determine if the searched-for object is present on the Stack.,"(""Equals"", ""The equals() method is used on the Stack class to determine if a specific object is present."", ""Stack"")"
"You can obtain the size of a Java Stack, meaning the number of elements currently stored on the Stack, via the Stack size() method.","(""Stack"", ""The size() method is used to obtain the number of elements currently stored on the Stack, indicating an operational relationship."", ""size()"")"
Here is an example of obtaining the size of a Java Stack via its size() method:,NULL
"After running this code the size variable will contain the value 3, since the Stack in the example contains 3 elements at the time its size() method is called.",NULL
You do so by first obtaining a Stream from the Stack via the stream() method.,"(""Stack"", ""The stream() method is used to obtain a Stream from a Stack."", ""stream()""); (""stream()"", ""The stream() method is used to obtain a Stream from a Stack."", ""Stream""); (""Stack"", ""The stream() method is used to obtain a Stream from a Stack."", ""stream()""); (""stream()"", ""The stream() method is used to obtain a Stream from a Stack."", ""Stream"")"
"Notice, that this example uses a Java Lambda as parameter to the Stream.forEach() method.","(""Stream"", ""The forEach method belongs to the Stream class, as it is a method applied to a Stream instance."", ""forEach""); (""Stream"", ""The Stream class is part of the java.util.stream package, which provides support for functional-style operations on streams of elements."", ""java.util.stream"")"
The non-parallelizable part of the programs is 40% which out of a total time of 1 is equal to 0.4 .,NULL
The parallelizable part is thus equal to 1 - 0.4 = 0.6 .,NULL
"If B is 0.4, O is 2 and N is 5, then the calculation looks like this:",NULL
"With B = 0.4, O = 2 and N = 5, the calculation becomes:",NULL
"That means, that if you optimize the non-parallelizable (sequential) part by a factor of 2, and paralellize the parallelizable part by a factor of 5, the new optimized version of the program or algorithm would run a maximum of 2.77777 times faster than the old version.",NULL
Note: The content of this text is a part result of a M.Sc.,NULL
Once a thread want to notify the waiting threads it calls notifyAll() on the object the waiting threads called wait() on.,"(""Thread"", ""The Thread class can call the notifyAll method to notify waiting threads."", ""notifyAll""); (""Thread"", ""The Thread class uses the wait method associated with an Object."", ""wait""); (""Object"", ""The wait method is called on an Object while threads wait."", ""wait""); (""Object"", ""The notifyAll method is called on an Object to notify all waiting threads."", ""notifyAll""); (""Thread"", ""The Thread class can call the notifyAll method to notify waiting threads."", ""notifyAll""); (""Thread"", ""The Thread class uses the wait method associated with an Object."", ""wait""); (""Object"", ""The wait method is called on an Object while threads wait."", ""wait""); (""Object"", ""The notifyAll method is called on an Object to notify all waiting threads."", ""notifyAll"")"
Just have the notifying thread call notify() on the object the waiting threads have called wait() on.,"(""Notify"", ""The notify() method is called by the notifying thread on the same object the waiting threads have called wait() on."", ""Wait"")"
"To achive this each waiting thread must call wait() on its own, separate object.","(""WAIT"", ""The method `wait` is called by each `thread`, indicating a relationship where `wait` is a method used by threads for coordination in the text."", ""THREAD"")"
When the notifying thread wants to notify a specific waiting thread it will call notify() on the object this specific thread has called wait() on.,"(""Notify"", ""Notify method is called to signal or notify a thread that has called Wait on an object."", ""Wait"")"
The lockWrite() method of a ReadWriteLock class shown below is an example of a test-and-set method.,"(""lockWrite"", ""The lockWrite method is a member or function of the ReadWriteLock class, indicating a typical class-method relationship."", ""ReadWriteLock"")"
Threads calling lockWrite() first sets the state before the test (writeRequests++).,"(""lockWrite"", ""The method 'lockWrite' modifies or interacts with 'writeRequests' by increasing its count."", ""writeRequests"")"
Then it tests the internal state against the access condition in the canGrantWriteAccess() method.,NULL
The BoundedSemaphore class shown below has two test-and-set methods: take() and release().,"(""BoundedSemaphore"", ""The take() is a method of the BoundedSemaphore class."", ""take""); (""BoundedSemaphore"", ""The release() is a method of the BoundedSemaphore class."", ""release"")"
A typical example of a set method is the unlock() method of a Lock class.,NULL
Java 5 comes with blocking queue implementations in the java.util.concurrent package.,"(""Blocking Queue Implementations"", ""Blocking Queue Implementations are implemented within the java.util.concurrent package"", ""java.util.concurrent"")"
Notice how notifyAll() is only called from enqueue() and dequeue() if the queue size is equal to the size bounds (0 or limit).,"(""Notifyall"", ""Notifyall is called from Enqueue when certain conditions are met"", ""Enqueue""); (""Notifyall"", ""Notifyall is also called from Dequeue under specific conditions"", ""Dequeue"")"
"If the queue size is not equal to either bound when enqueue() or dequeue() is called, there can be no threads waiting to either enqueue or dequeue items.","(""Enqueue"", ""Both methods are involved in manipulating a queue size."", ""Dequeue"")"
"As you can see, the lock() method first checks if the locked member variable is equal to false (check), and if it is it ses locked to true (then act).","(""Lock"", ""The lock() method is being described in the text, relating its checks and actions when called."", ""Lock"")"
"If multiple threads had access to the same MyLock instance, the above lock() function would not be guaranteed to work.",NULL
Here is the code example from earlier with the lock() method turned into an atomic block of code using the synchronized keyword:,NULL
Now the lock() method is synchronized so only one thread can executed it at a time on the same MyLock instance.,NULL
"The atomic lock() method is actually an example of ""compare and swap"".","(""Lock"", ""The lock() method is an example of the compare and swap class concept"", ""Compare and Swap"")"
"The lock() method compares the variable locked to the expected value false and if locked is equal to this expected value, it swaps the variable's value to true .","(""LOCK"", ""The 'lock' method operates on the 'locked' variable, comparing its value and potentially swapping it."", ""LOCKED"")"
From Java 5 you can get access to these functions in the CPU via some of the new atomic classes in the java.util.concurrent.atomic package.,"(""Java 5"", ""Java 5 provides access to the atomic classes as part of its features."", ""Atomic Classes""); (""Atomic Classes"", ""Atomic classes are part of the java.util.concurrent.atomic package."", ""Java.util.concurrent.atomic"")"
Here is an example showing how to implement the lock() method shown earlier using the AtomicBoolean class:,"(""lock()"", ""The method lock() is implemented using the AtomicBoolean class."", ""AtomicBoolean""); (""lock()"", ""The method lock() is implemented using the AtomicBoolean class."", ""AtomicBoolean"")"
"This class has a compareAndSet() function which will compare the value of the AtomicBoolean instance to an expected value, and if has the expected value, it swaps the value with a new value.",NULL
"The compareAndSet() method returns true if the value was swapped, and false if not.","(""COMPAREANDSET"", ""METHOD""); (""COMPAREANDSET"", ""METHOD"")"
Many of the concurrency utilities in the java.util.concurrent Java package are designed for use with this model.,NULL
Non-blocking IO means that when a worker starts an IO operation (e.g.,NULL
"When the IO operation finishes, the result of the IO operation ( e.g.",NULL
It just needs to know what channel to forward the job to (or send the message to etc.).,NULL
"The main disadvantage of the assembly line concurrency model is that the execution of a job is often spread out over multiple workers, and thus over multiple classes in your project.",NULL
"Of course parallel worker code may also be spread over many different classes, but the execution sequence is often easier to read from the code.","(""Classes"", ""Class"")"
With Java 7 we got the java.util.concurrent package contains the ForkAndJoinPool which can help you implement something similar to functional parallelism.,"(""Java.util.concurrent"", ""The ForkAndJoinPool is a class contained within the java.util.concurrent package."", ""ForkAndJoinPool"")"
"However, if the system is concurrently executing multiple other tasks (like e.g.",NULL
when a Java application is started its main() method is executed by the main thread - a special thread that is created by the Java VM to run your application.,"(""Main"", ""The main() method is executed by the main thread created by the Java VM to run the application."", ""Java VM"")"
"Threads are instances of class java.lang.Thread, or instances of subclasses of this class.","(""THREAD"", ""THREAD is a subclass of JAVA.LANG.THREAD, indicating an inheritance relationship between them."", ""JAVA.LANG.THREAD"")"
"To start the Java thread you will call its start() method, like this:","(""Thread"", ""The start() method is invoked on the Thread class to begin its execution."", ""Start"")"
The first is to create a subclass of Thread and override the run() method.,NULL
The second method is to pass an object that implements Runnable (java.lang.Runnable to the Thread constructor.,"(""Runnable"", ""Runnable is used in the Thread constructor to provide the execution logic."", ""Thread""); (""Runnable"", ""Runnable belongs to the java.lang package."", ""java.lang"")"
"The first way to specify what code a thread is to run, is to create a subclass of Thread and override the run() method.",NULL
The run() method is what is executed by the thread after you call start().,"(""RUN"", ""The run() method is executed by the thread after you call start()."", ""THREAD"")"
The start() call will return as soon as the thread is started.,NULL
The run() method will execute as if executed by a different CPU.,"(""Run"", ""The run() method appears to involve CPU execution, suggesting a relationship."", ""CPU"")"
"When the run() method executes it will print out the text ""MyThread running"".","(""run"", ""The 'run' method is associated with the 'MyThread' class, as methods are typically executed within the context of a class that likely defines its behavior."", ""MyThread""); (""run"", ""The 'run' method is associated with the 'MyThread' class, as methods are typically executed within the context of a class that likely defines its behavior."", ""MyThread"")"
You can also create an anonymous subclass of Thread like this:,NULL
"This example will print out the text ""Thread running"" once the run() method is executed by the new thread.",NULL
The second way to specify what code a thread should run is by creating a class that implements the java.lang.Runnable interface.,"(""Runnable"", ""The Runnable class implements the java.lang.Runnable interface."", ""java.lang""); (""Runnable"", ""Runnable is used to specify what code a thread should run."", ""thread"")"
Whatever the thread is supposed to do when it executes must be included in the implementation of the run() method.,"(""Thread"", ""The 'run' method is what the thread executes to perform its task, indicating a functional relationship between 'Thread' and 'Run'."", ""Run"")"
The first way to implement the Java Runnable interface is by creating your own Java class that implements the Runnable interface.,"(""Java Class"", ""The Java class implements the Runnable interface, indicating an implementation relationship."", ""Runnable"")"
Here is an example of a custom Java class that implements the Runnable interface:,NULL
"After printing that text, the run() method exits, and the thread running the run() method will stop.",NULL
Here is an example of an anonymous Java class that implements the Runnable interface:,"(""Runnable"", ""The anonymous Java class implements the Runnable interface"", ""anonymous Java class"")"
"Apart from being an anononymous class, this example is quite similar to the example that used a custom class to implement the Runnable interface.",NULL
"To have the run() method executed by a thread, pass an instance of a class, anonymous class or lambda expression that implements the Runnable interface to a Thread in its constructor.","(""Run"", ""The run() method is executed by an instance that is passed to a Thread."", ""Thread""); (""Runnable"", ""The Runnable interface is implemented by an instance passed to the constructor of a Thread."", ""Thread""); (""Constructor"", ""An instance implementing Runnable can be passed to a Thread via its constructor."", ""Thread""); (""Run"", ""The run() method is executed by an instance that is passed to a Thread."", ""Thread""); (""Runnable"", ""The Runnable interface is implemented by an instance passed to the constructor of a Thread."", ""Thread""); (""Constructor"", ""An instance implementing Runnable can be passed to a Thread via its constructor."", ""Thread"")"
When the thread is started it will call the run() method of the MyRunnable instance instead of executing it's own run() method.,NULL
Sometimes you may have to implement Runnable as well as subclass Thread.,"(""Runnable"", ""Runnable is implemented while Thread is subclassed, indicating a typical way to create threads in Java."", ""Thread"")"
"For instance, if creating a subclass of Thread that can execute more than one Runnable.","(""Subclass of Thread"", ""The Subclass of Thread is designed to execute more than one Runnable, indicating an implementation relationship where the subclass uses Runnable instances."", ""Runnable"")"
"When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start(), like this:","(""Thread"", ""The run method is associated with the Thread class as it defines the entry point of the thread."", ""run""); (""Thread"", ""The start method is associated with the Thread class as it is used to begin the execution of the thread."", ""start"")"
At first you may not notice anything because the Runnable's run() method is executed like you expected.,"(""Runnable"", ""The 'run' method is a member of the 'Runnable' class, indicating a functional relationship where the method is executed in the context of the class."", ""run"")"
Instead the run() method is executed by the thread that created the thread.,NULL
"To have the run() method of the MyRunnable instance called by the new created thread, newThread, you MUST call the newThread.start() method.","(""Run"", ""The Run method is part of the MyRunnable class which implements its functionality."", ""Myrunnable""); (""Start"", ""The Start method is called on the NewThread class to begin execution."", ""Newthread"")"
"For instance, if multiple threads write to System.out it can be handy to see which thread wrote the text.","(""System.out"", ""class"")"
"Notice however, that since the MyRunnable class is not a subclass of Thread, it does not have access to the getName() method of the thread executing it.","(""MyRunnable"", ""The MyRunnable class is related to Thread because it indicates it is not a subclass of Thread."", ""Thread""); (""getName"", ""The getName method is related to Thread since it is a method of the thread executing MyRunnable."", ""Thread"")"
The Thread.currentThread() method returns a reference to the Thread instance executing currentThread() .,"(""Thread"", ""The method currentThread() is a member of the class Thread."", ""currentThread"")"
First it prints out the name of the thread executing the main() method.,"(""Main"", ""Method""); (""Main"", ""Method"")"
"Note that even if the threads are started in sequence (1, 2, 3 etc.)",NULL
"they may not execute sequentially, meaning thread 1 may not be the first thread to write its name to System.out.","(""System.out"", ""package""); (""System.out"", ""package"")"
A thread can pause itself by calling the static method Thread.sleep() .,NULL
The sleep() method will attempt to sleep that number of milliseconds before resuming execution.,"(""SLEEP"", ""METHOD""); (""SLEEP"", ""METHOD"")"
"The Thread sleep() is not 100% precise, but it is pretty good still.",NULL
Here is an example of pausing a Java thread for 3 seconds (3.000 millliseconds) by calling the Thread sleep() method:,"(""Thread"", ""The sleep method is associated with the Thread class, allowing a thread to pause execution."", ""sleep"")"
"The thread executing the Java code above, will sleep for approximately 10 seconds (10.000 milliseconds).","(""Thread"", ""Class""); (""Java"", ""Package"")"
"The Java Thread class contains a stop() method, but it is deprecated.","(""Thread"", ""The stop() method is a member of the Thread class, indicating a class-method relationship."", ""stop"")"
The original stop() method would not provide any guarantees about in what state the thread was stopped.,NULL
Instead of calling the stop() method you will have to implement your thread code so it can be stopped.,"(""Stop"", ""The method Stop is intended to be used within the context of managing the Thread execution."", ""Thread"")"
Here is an example of a class that implements Runnable which contains an extra method called doStop() which signals to the Runnable to stop.,"(""Runnable"", ""The method doStop() is part of the Runnable class and is used to signal the Runnable to stop."", ""doStop"")"
The doStop() is intended to be called from another thread than the thread executing the MyRunnable's run() method.,"(""dostop"", ""The doStop() method is called from a different thread than the one executing the run() method."", ""run""); (""run"", ""The run() method is a part of the MyRunnable class."", ""myrunnable""); (""dostop"", ""The doStop() method is called from a different thread than the one executing the run() method."", ""run""); (""run"", ""The run() method is a part of the MyRunnable class."", ""myrunnable"")"
The keepRunning() method is called internally by the thread executing the MyRunnable's run() method.,NULL
As long as doStop() has not been called the keepRunning() method will return true - meaning the thread executing the run() method will keep running.,"(""keepRunning"", ""The keepRunning() method returns a boolean value that determines whether the thread should continue executing the run() method."", ""run"")"
"Here is an example of starting a Java thread that executes an instance of the above MyRunnable class, and stopping it again after a delay:","(""MyRunnable"", ""Java thread executes an instance of the MyRunnable class"", ""Java thread""); (""MyRunnable"", ""Java thread executes an instance of the MyRunnable class"", ""Java thread"")"
"Then the thread executing the main() method (the main thread) sleeps for 10 seconds, and then calls the doStop() method of the MyRunnable instance.","(""Main"", ""The main method executes the doStop method."", ""DoStop""); (""DoStop"", ""The doStop method is a method of the MyRunnable class."", ""MyRunnable"")"
"This will cause the thread executing the MyRunnable method to stop, because the keepRunning() will return false after doStop() has been called.",NULL
Please keep in mind that if your Runnable implementation needs more than just the run() method (e.g.,NULL
"a stop() or pause() method too), then you can no longer create your Runnable implementation with a Java lambda expression.","(""Stop"", ""The Stop method is closely related to Runnable, implying it is used to control or modify the behavior of a Runnable object."", ""Runnable""); (""Pause"", ""The Pause method, like Stop, is used within the context of a Runnable object, indicating a functional relationship."", ""Runnable""); (""Runnable"", ""Runnable is a key component or interface in the Java programming language."", ""Java"")"
"Instead you must use a custom class, or a custom interface that extends Runnable which has the extra methods, and which is implemented by an anonymous class.","(""Custom Class"", ""The custom class or interface extends Runnable, meaning it is related as it builds upon or uses functionality defined in Runnable."", ""Runnable"")"
You will have to create a custom lock class or use one of the Java 5 concurrency constructs in the java.util.concurrency package.,"(""Custom Lock"", ""Custom lock class may utilize concurrency utilities from this package."", ""Java.util.concurrency""); (""Concurrency Constructs"", ""Concurrency constructs are likely implemented or related to this package."", ""Java.util.concurrency"")"
"Every time a thread takes a lock it is noted in a data structure (map, graph etc.)",NULL
Here is an example of a TreeNode class that call synchronized methods in different instances:,"(""TreeNode"", ""The TreeNode class calls synchronized methods, indicating a functional relationship between the class and these methods."", ""methods"")"
"If a thread (1) calls the parent.addChild(child) method at the same time as another thread (2) calls the child.setParent(parent) method, on the same parent and child instances, a deadlock can occur.",NULL
Here is some pseudo code that illustrates this: Thread 1: parent.addChild(child); //locks parent --> child.setParentOnly(parent); Thread 2: child.setParent(parent); //locks child --> parent.addChildOnly() First thread 1 calls parent.addChild(child).,"(""Parent"", ""The method `AddChild` is called on the `Parent` class, indicating that `AddChild` is a method of `Parent`."", ""AddChild""); (""Child"", ""The method `SetParentOnly` is called on the `Child` class, indicating that `SetParentOnly` is a method of `Child`."", ""SetParentOnly""); (""Child"", ""The method `SetParent` is called on the `Child` class, suggesting that `SetParent` is a method of `Child`."", ""SetParent""); (""Parent"", ""The method `AddChildOnly` is called on the `Parent` class, suggesting that `AddChildOnly` is a method of `Parent`."", ""AddChildOnly"")"
Since addChild() is synchronized thread 1 effectively locks the parent object for access from other treads.,"(""AddChild"", ""The method AddChild is used in the context of locking the Parent class for access control in multi-threaded environments."", ""Parent"")"
Since setParent() is synchronized thread 2 effectively locks the child object for acces from other threads.,NULL
"Next thread 1 tries to call child.setParentOnly() method, but the child object is locked by thread 2, so the method call just blocks.","(""Thread 1"", ""Thread 1 is attempting to call the SetParentOnly method."", ""SetParentOnly""); (""Child"", ""The SetParentOnly method is being called on the Child class."", ""SetParentOnly""); (""Thread 2"", ""Thread 2 has locked the child object, preventing other threads from accessing it."", ""Child"")"
"Thread 2 also tries to call parent.addChildOnly() but the parent object is locked by thread 1, causing thread 2 to block on that method call.","(""Thread 2"", ""Thread 2 interacts with the parent class by trying to call the method addChildOnly."", ""parent""); (""Thread 2"", ""Thread 2 tries to call the method addChildOnly on the parent class."", ""addChildOnly""); (""parent"", ""addChildOnly is a method associated with the parent class."", ""addChildOnly"")"
"Note: The two threads must call parent.addChild(child) and child.setParent(parent) at the same time as described above, and on the same two parent and child instances for a deadlock to occur.",NULL
Thread 1: parent.addChild(child); //locks parent --> child.setParentOnly(parent); Thread 2: child.setParent(parent); //locks child --> parent.addChildOnly() First thread 1 calls parent.addChild(child).,NULL
By far the best book on the java.util.concurrent package in Java 5 and forward.,"(""Java.util.concurrent"", ""Package"")"
"https://lmax-exchange.github.io/disruptor/ The LMAX Disrupter concurrent data structure (a single reader, single writer queue-like structure with high concurrency).",NULL
In the following code example I have created an example of such a communication mechanism - a Java class called FrameExchanger.,"(""FrameExchanger"", ""class"")"
It is not important how this class looks in order to understand how the FrameExchanger works.,"(""FrameExchanger"", ""The text references the FrameExchanger as a class, indicating its role or importance."", ""FrameExchanger"")"
"The producing thread will call storeFrame() continuously, and the drawing thread will call takeFrame() continuously.",NULL
Notice how the three instructions inside the storeFrame() method seem like they do not depend on each other.,NULL
"That means, that if the drawing thread is waiting in the while-loop in the takeFrame() method, the drawing thread could exit that while-loop, and take the old Frame object.","(""TAKEFRAME"", ""The takeFrame() method is directly interacting with the Frame class in the context described, as it operates on Frame objects within its functionality."", ""FRAME""); (""TAKEFRAME"", ""The takeFrame() method is directly interacting with the Frame class in the context described, as it operates on Frame objects within its functionality."", ""FRAME"")"
Notice that the first instruction is a read of a volatile variable (other.volatileVarC).,"(""volatile variable"", ""volatileVarC is an instance of the class volatile variable represented in the code snippet."", ""volatileVarC"")"
"When other.volatileVarC is read in from main memory, the other.nonVolatileB and other.nonVolatileA are also read in from main memory.",NULL
"To illustrate why this guarantee is necessary, let us modify the FrameExchanger class from earlier in this tutorial to have the hasNewFrame variable be declared volatile:",NULL
"Additionally, every time the drawing thread reads the hasNewFrame variable in the while-loop inside the takeFrame() method, the frame and framesStoredCount will also be refreshed from main memory.",NULL
"Imagine if the Java VM reordered the instructions inside the storeFrame() method, like this:","(""StoreFrame"", ""method"")"
"This means, that the drawing thread executing the takeFrame() method may exit the while-loop before the new value is assigned to the frame variable.","(""TakeFrame()"", ""Method"")"
"As you can see, the reordering of the instructions inside storeFrame() method may make the application malfunction.","(""STOREFRAME"", ""METHOD"")"
"In the case of the storeFrame() method that means that the two first write instructions cannot be reordered to happen after the last write to hasNewFrame, since hasNewFrame is a volatile variable.","(""storeFrame"", ""The storeFrame method involves operations on the hasNewFrame variable indicating a relationship through method functionality respecting volatility."", ""hasNewFrame""); (""storeFrame"", ""The storeFrame method involves operations on the hasNewFrame variable indicating a relationship through method functionality respecting volatility."", ""hasNewFrame"")"
"This reordering does not break the code in the takeFrame() method, as the frame variable is still written to before the hasNewFrame variable is written to.",NULL
"Because of the volatile read visibility guarantee, when this.volatileVarA is read from main memory, so are all other variables visible to the thread at that time.","(""volatiliatevara"", ""method""); (""volatiliatevara"", ""method"")"
"Thus, this.nonVolatileVarB and this.nonVolatileVarC are also read in from main memory at the same time.",NULL
"With regards to the takeFrame() method, the first read of a volatile variable is the read of the hasNewFrame field inside the while-loop.","(""TakeFrame"", ""The method 'takeFrame' interacts with the 'hasNewFrame' class by checking the volatile variable within a while-loop."", ""HasNewFrame"")"
Notice the two synchronized blocks inside the set() and get() method.,"(""Set"", ""Both 'Set' and 'Get' are methods mentioned in the context of synchronized blocks."", ""Get"")"
In the set() method the synchronized block at the end of the method will force all the variables to be synchronized to main memory after being updated.,"(""Set"", ""The synchronized block is part of the set method, ensuring variables are updated to main memory"", ""Synchronized Block"")"
In the get() method the synchronized block is placed at the beginning of the method.,NULL
"When the thread calling get() enters the synchronized block, all variables are re-read in from main memory.",NULL
"To illustrate why, I will use the get() method of the ValueExchanger shown earlier:","(""GET"", ""The GET method is used in the context of the VALUEEXCHANGER class, indicating a functional relationship where the method retrieves or manipulates data from the class."", ""VALUEEXCHANGER"")"
"As you can see, the synchronized block at the beginning of the method will guarantee that all of the variables this.valC, this.valB and this.valA are refreshed (read in) from main memory.",NULL
"To illustrate why, I will use the set() method of the ValueExchanger shown earlier:","(""Set"", ""The set() method is a function within the ValueExchanger class."", ""ValueExchanger"")"
"As you can see, the synchronized block at the end of the method will guarantee that all of the changed variables this.valA, this.valB and this.valC will be written back to (flushed) to main memory when the thread calling set() exits the synchronized blocks.","(""set"", ""The method 'set' interacts with the variable 'this.valA' by ensuring it is flushed to main memory."", ""this.valA""); (""set"", ""The method 'set' interacts with the variable 'this.valB' by ensuring it is flushed to main memory."", ""this.valB""); (""set"", ""The method 'set' interacts with the variable 'this.valC' by ensuring it is flushed to main memory."", ""this.valC"")"
"The original Java memory model was insufficient, so the Java memory model was revised in Java 1.5.","(""JAVA MEMORY MODEL"", ""The Java memory model is part of the Java language and defines how threads interact through memory, making them intrinsically related."", ""JAVA""); (""JAVA MEMORY MODEL"", ""The Java memory model is part of the Java language and defines how threads interact through memory, making them intrinsically related."", ""JAVA"")"
Static class variables are also stored on the heap along with the class definition.,"(""Static class variables"", ""Static class variables are part of the class definition, which explains why they are stored together on the heap."", ""class definition"")"
If two threads were executing the run() method then the diagram shown earlier would be the outcome.,NULL
methodOne() declares a primitive local variable (localVariable1 of type int) and an local variable which is an object reference (localVariable2).,"(""MethodOne"", ""MethodOne declares a primitive local variable named LocalVariable1."", ""LocalVariable1""); (""MethodOne"", ""MethodOne declares a local variable named LocalVariable2, which is an object reference."", ""LocalVariable2"")"
Each thread executing methodOne() will create its own copy of localVariable1 and localVariable2 on their respective thread stacks.,NULL
Each thread executing methodOne() will also create their own copy of localVariable2.,"(""Methodone"", ""Methodone creates a copy of Localvariable2 for each thread executing it"", ""Localvariable2"")"
The localVariable1 reference will be stored in one copy per thread executing methodTwo().,"(""Methodtwo"", ""Methodtwo is implied to be contained within a package as it is described with an associated action, 'executing.'"", ""Package"")"
The Integer objects created inside methodTwo() correspond to Object 1 and Object 5 in the diagram above.,"(""MethodTwo"", ""Method""); (""MethodTwo"", ""Method"")"
Notice also the two member variables in the class MySharedObject of type long which is a primitive type.,"(""MySharedObject"", ""class"")"
That is why Java 5 got a whole set of concurrency utility classes to help developers implement more fine grained concurrency control than what you get with synchronized.,"(""Java"", ""The concurrency utility classes are part of the Java package, which provides the necessary tools for concurrency control."", ""concurrency utility classes"")"
Notice the use of the synchronized keyword in the add() method declaration.,"(""Add"", ""The 'Add' method uses the 'Synchronized' keyword to ensure thread safety."", ""Synchronized"")"
Also here the synchronized keyword tells Java that the add() method is synchronized.,NULL
Synchronized static methods are synchronized on the class object of the class the synchronized static method belongs to.,"(""Synchronized Static Methods"", ""Synchronized static methods are synchronized on the class object to which they belong."", ""Class Object"")"
"Since only one class object exists in the Java VM per class, only one thread can execute inside a static synchronized method in the same class.","(""Class"", ""The method is within the class, and a class object allows the execution of a method."", ""Method""); (""Java VM"", ""The class is instantiated within the Java VM environment."", ""Class"")"
"In case a class contains more than one static synchronized method, only one thread can execute inside any of these methods at the same time.",NULL
Only one thread can execute inside any of the two add() and subtract() methods at any given time.,"(""Add"", ""The methods 'Add' and 'Subtract' are related because they are mentioned together in the context of thread execution, suggesting mutual exclusivity for execution within a thread."", ""Subtract"")"
If Thread A is executing add() then Thread B cannot execute neither add() nor subtract() until Thread A has exited add().,NULL
"If the static synchronized methods are located in different classes, then one thread can execute inside the static synchronized methods of each class.","(""Methods"", ""The methods are part of the classes, as they are being referenced in connection with the classes."", ""Classes"")"
One thread per class regardless of which static synchronized method it calls.,NULL
These methods are synchronized on the class object of the class the methods belong to:,NULL
"Had the second synchronized block been synchronized on a different object than MyClass.class, then one thread could execute inside each method at the same time.","(""MyClass"", ""The MyClass class is likely to contain or define the methods mentioned, indicating a relationship between the class and the methods."", ""method"")"
It is even possible to use synchronized blocks inside a Java Lambda Expression as well as inside anonymous classes.,"(""Java Lambda Expression"", ""Both Java Lambda Expression and anonymous class can contain synchronized blocks and are part of Java language constructs."", ""anonymous class"")"
Notice that the synchronized block is synchronized on the class object of the class containing the lambda expression.,NULL
"It could have been synchronized on another object too, if that would have made more sense (given a specific use case), but using the class object is fine for this example.","(""Class"", ""class""); (""Class"", ""class"")"
"Here are the two classes used in the example above, Counter and CounterThread.",NULL
"The Counter.add() method is synchronized on the instance, because the add method is an instance method, and marked as synchronized.","(""add"", ""The method 'add' belongs to the 'Counter' class as indicated by 'Counter.add()'."", ""Counter"")"
Therefore only one of the threads can call the add() method at a time.,"(""add"", ""method"")"
"The other thread will wait until the first thread leaves the add() method, before it can execute the method itself.","(""Thread"", ""The Thread class interacts with the Add method by synchronizing execution, ensuring one thread waits for another to leave the method."", ""Add""); (""Add"", ""The Add method affects the execution flow of threads, requiring synchronization to ensure that one thread finishes before another begins."", ""Thread"")"
"If the two threads had referenced two separate Counter instances, there would have been no problems calling the add() methods simultaneously.",NULL
Calling add() on counterA will thus not block a call to add() on counterB.,"(""Add"", ""The method Add is called on the class CounterA."", ""CounterA""); (""Add"", ""The method Add is called on the class CounterB."", ""CounterB"")"
Without the use of the synchronized keyword (or the Java volatile keyword) there is no guarantee that when one thread changes the value of a variable shared with other threads (e.g.,"(""Synchronized Keyword"", ""Both are methods in Java used for managing concurrent access to shared resources by multiple threads"", ""Java Volatile Keyword"")"
"If you call Integer.valueOf(1) multiple times, it might actually return the same wrapper object instance for the same input parameter values.","(""Integer"", ""valueOf is a method that belongs to the Integer class"", ""valueOf"")"
"That means, that if you are synchronizing multiple blocks on the same primitive wrapper object (e.g.","(""Primitive Wrapper Object"", ""class""); (""Primitive Wrapper Object"", ""class"")"
"use Integer.valueOf(1) multiple times as monitor object), then you risk that those synchronized blocks all get synchronized on the same object.","(""Integer.valueOf"", ""Integer.valueOf is being used to create an object that serves as a monitor"", ""monitor"")"
"To be on the safe side, synchronize on this - or on a new Object() .","(""synchronize"", ""The synchronize method is used to lock an object, which in this context is the Object class."", ""Object"")"
Java actually comes with a built in ReadWriteLock class you can use.,"(""ReadWriteLock"", ""class""); (""ReadWriteLock"", ""class"")"
Java actually comes with a built-in Java Semaphore class you can use.,"(""Java Semaphore"", ""The Java Semaphore class is part of the Java programming language and libraries."", ""Java"")"
Just focus on how inside the synchronized block inside the count() method calls the count() method recursively.,NULL
"Thus, the thread calling count() may eventually enter the same synchronized block multiple times.",NULL
The Java ThreadLocal class enables you to create variables that can only be read and written by the same thread.,"(""ThreadLocal"", ""The term 'ThreadLocal' is directly associated with 'class', as it is explicitly referred to as the 'ThreadLocal class' in the text."", ""class"")"
"Thus, the Java ThreadLocal class provides a simple way to make code thread safe that would not otherwise be so.","(""ThreadLocal"", ""class""); (""ThreadLocal"", ""class"")"
Once a ThreadLocal has been created you can set the value to be stored in it using its set() method.,NULL
You read the value stored in a ThreadLocal using its get() method.,"(""ThreadLocal"", ""The 'get' method is used to read the value stored in the ThreadLocal class."", ""get"")"
"Additionally, you do not have to typecast the value returned by get().","(""Get"", ""Method"")"
It is possible to set an initial value for a Java ThreadLocal which will get used the first time get() is called - before set() has been called with a new value.,"(""ThreadLocal"", ""The method 'get' is used in conjunction with the class 'ThreadLocal', indicating it is a method associated with or utilizing its functionality."", ""get""); (""ThreadLocal"", ""The method 'set' is associated with the class 'ThreadLocal', as it is described to be called to assign a new value, implying a class-method relationship."", ""set"")"
The first way to specify an initial value for a Java ThreadLocal variable is to create a subclass of ThreadLocal which overrides its initialValue() method.,NULL
"The easiest way to create a subclass of ThreadLocal is to simply create an anonymous subclass, right where you create the ThreadLocal variable.","(""ThreadLocal"", ""Creating a subclass of ThreadLocal implies an inheritance relationship where ThreadLocal serves as the parent class."", ""Subclass""); (""ThreadLocal"", ""Creating a subclass of ThreadLocal implies an inheritance relationship where ThreadLocal serves as the parent class."", ""Subclass"")"
Here is an example of creating an anonymous subclass of ThreadLocal which overrides the initialValue() method:,"(""ThreadLocal"", ""The method initialValue is overridden in a subclass of the class ThreadLocal."", ""initialValue"")"
"Only if you return the exact same object from the initialValue() method, will all threads see the same object.","(""Initialvalue"", ""Method""); (""Initialvalue"", ""Method"")"
"Here is an example of creating a ThreadLocal using its withInitial() static factory method, passing a simple Supplier implementation as parameter:","(""ThreadLocal"", ""The `withInitial()` is a static factory method of the `ThreadLocal` class, which is used to create a `ThreadLocal` instance."", ""withInitial()""); (""withInitial()"", ""The `withInitial()` method takes a `Supplier` implementation as a parameter, indicating a dependency or interaction between the method and the class."", ""Supplier"")"
Here is how providing a Supplier implementation as a lambda expression to withInitial() looks:,"(""Supplier"", ""The withInitial() method uses an implementation of the Supplier class as a parameter, indicated by the lambda expression example."", ""withInitial"")"
Notice how the format() method calls the getThreadLocalSimpleDateFormat() method to obtain a Java SimpleDatFormat instance.,NULL
"The SimpleDateFormat class is not thread safe, so multiple threads cannot use it at the same time.","(""SimpleDateFormat"", ""class"")"
"To solve this problem, the MyDateFormatter class above creates a SimpleDateFormat per thread, so each thread calling the format() method will use its own SimpleDateFormat instance.",NULL
"Both threads execute the run() method, and thus sets different values on the ThreadLocal instance.","(""Run"", ""The run() method sets different values on the ThreadLocal instance, indicating a method-to-class relationship."", ""ThreadLocal"")"
"If the access to the set() call had been synchronized, and it had not been a ThreadLocal object, the second thread would have overridden the value set by the first thread.",NULL
"The udpate() method writes three variables, of which only days is volatile.",NULL
Notice the totalDays() method starts by reading the value of days into the total variable.,"(""TOTALDAYS"", ""The totalDays method reads the value of days into the total variable, indicating an interaction between them."", ""DAYS"")"
Let us look at the MyClass class from the example earlier in this Java volatile tutorial:,NULL
"Once the update() method writes a value to days, the newly written values to years and months are also written to main memory.","(""Update"", ""The update() method writes a value to days."", ""Days""); (""Update"", ""The update() method affects the years by writing new values."", ""Years""); (""Update"", ""The update() method affects the months by writing new values."", ""Months""); (""Years"", ""Newly written values to years are written to main memory."", ""Main Memory""); (""Months"", ""Newly written values to months are written to main memory."", ""Main Memory"")"
As an alternative to a synchronized block you could also use one of the many atomic data types found in the java.util.concurrent package.,"(""Synchronized block"", ""The text suggests that atomic data types in the java.util.concurrent package can be an alternative to using synchronized blocks for concurrency control."", ""Java.util.concurrent"")"
"From Java 5 the package java.util.concurrent.locks contains several lock implementations, so you may not have to implement your own locks.","(""java.util.concurrent.locks"", ""The package java.util.concurrent.locks contains several lock implementations."", ""lock implementations"")"
"The Counter class could have been written like this instead, using a Lock instead of a synchronized block:",NULL
The lock() method locks the Lock instance so that all threads calling lock() are blocked until unlock() is executed.,NULL
Spin locks and the methods wait() and notify() are covered in more detail in the text Thread Signaling.,NULL
"While isLocked is true, the thread calling lock() is parked waiting in the wait() call.",NULL
"In case the thread should return unexpectedly from the wait() call without having received a notify() call (AKA a Spurious Wakeup) the thread re-checks the isLocked condition to see if it is safe to proceed or not, rather than just assume that being awakened means it is safe to proceed.",NULL
"If isLocked is false, the thread exits the while(isLocked) loop, and sets isLocked back to true, to lock the Lock instance for other threads calling lock().","(""Lock"", ""The lock() method is being called on an instance of the Lock class to initiate the locking mechanism."", ""lock()"")"
"When the thread is done with the code in the critical section (the code between lock() and unlock()), the thread calls unlock().",NULL
"Executing unlock() sets isLocked back to false, and notifies (awakens) one of the threads waiting in the wait() call in the lock() method, if any.","(""Unlock"", ""The unlock() method affects the isLocked class by setting it back to false."", ""IsLocked""); (""Unlock"", ""The unlock() method notifies one of the threads waiting in the wait() method."", ""Wait""); (""Wait"", ""The wait() method is called within the context of the lock() method."", ""Lock"")"
"Notice how both outer() and inner() are declared synchronized, which in Java is equivalent to a synchronized(this) block.","(""Outer"", ""Both Outer and Inner are methods declared as synchronized, indicating a relationship in concurrency control."", ""Inner"")"
"If a thread calls outer() there is no problem calling inner() from inside outer(), since both methods (or blocks) are synchronized on the same monitor object (""this"").","(""Outer"", ""Inner is called from inside Outer"", ""Inner"")"
"However, even if synchronized blocks are reentrant, the Lock class shown earlier is not reentrant.",NULL
"If we rewrite the Reentrant class like below, the thread calling outer() will be blocked inside the lock.lock() in the inner() method.","(""outer"", ""Both outer and inner methods are part of the Reentrant class."", ""inner"")"
Inside the inner() method the thread will again try to lock the Lock instance.,NULL
"This will fail (meaning the thread will be blocked), since the Lock instance was locked already in the outer() method.",NULL
"The reason the thread will be blocked the second time it calls lock() without having called unlock() in between, is apparent when we look at the lock() implementation:",NULL
It is the condition inside the while loop (spin lock) that determines if a thread is allowed to exit the lock() method or not.,"(""Lock"", ""The method 'Lock' is part of the operation described as 'spin lock'"", ""Spin Lock"")"
To make the Lock class reentrant we need to make a small change:,"(""Lock"", ""class"")"
"If either the lock is unlocked (isLocked = false) or the calling thread is the thread that locked the Lock instance, the while loop will not execute, and the thread calling lock() will be allowed to exit the method.",NULL
"Otherwise, a single call to unlock() will unlock the lock, even if the lock has been locked multiple times.",NULL
"We don't want the lock to be unlocked until the thread that locked it, has executed the same amount of unlock() calls as lock() calls.",NULL
"When guarding a critical section with a Lock, and the critical section may throw exceptions, it is important to call the unlock() method from inside a finally-clause.",NULL
"If unlock() was not called from inside a finally-clause, and an exception was thrown from the critical section, the Lock would remain locked forever, causing all threads calling lock() on that Lock instance to halt indefinately.",NULL
"If you click a button that starts a long task, and the thread executing the task is the thread updating the windows, buttons etc., then the application will appear unresponsive while the task executes.",NULL
"Imagine then, that one of the clients sends a request that takes a long time to process - e.g.",NULL
"Notice how the lock() method first synchronizes on ""this"", then synchronizes on the monitorObject member.","(""Lock"", ""The lock() method synchronizes on monitorObject, showing dependency for synchronization."", ""MonitorObject""); (""Lock"", ""The lock() method synchronizes on monitorObject, showing dependency for synchronization."", ""MonitorObject"")"
"If isLocked is true however, the thread calling lock() is parked waiting in the monitorObject.wait() call.","(""isLocked"", ""The lock method's behavior depends on the state of the isLocked class."", ""lock""); (""thread"", ""The thread uses the monitorObject.wait method to pause its execution."", ""monitorObject.wait"")"
"The problem with this is, that the call to monitorObject.wait() only releases the synchronization monitor on the monitorObject member, and not the synchronization monitor associated with ""this"".","(""MonitorObject"", ""The wait() method is invoked on the MonitorObject, suggesting a method call relationship."", ""wait()""); (""MonitorObject"", ""The wait() method is invoked on the MonitorObject, suggesting a method call relationship."", ""wait()"")"
When the thread that locked the Lock in the first place tries to unlock it by calling unlock() it will be blocked trying to enter the synchronized(this) block in the unlock() method.,"(""unlock"", ""The method unlock() is intended to operate on the Lock class, usually as part of its interface for managing locking."", ""Lock""); (""synchronized"", ""The method synchronized is used within the unlock() method to manage locking operations, preventing threads from accessing certain sections of code simultaneously."", ""unlock"")"
It will remain blocked until the thread waiting in lock() leaves the synchronized(this) block.,NULL
"But the thread waiting in the lock() method will not leave that block until the isLocked is set to false, and a monitorObject.notify() is executed, as it happens in unlock().","(""Lock"", ""Lock and Unlock are related as they are methods involved in lock management."", ""Unlock""); (""MonitorObject"", ""notify() is a method that operates on MonitorObject."", ""notify""); (""Lock"", ""Lock and Unlock are related as they are methods involved in lock management."", ""Unlock""); (""MonitorObject"", ""notify() is a method that operates on MonitorObject."", ""notify"")"
"Put shortly, the thread waiting in lock() needs an unlock() call to execute successfully for it to exit lock() and the synchronized blocks inside it.",NULL
"But, no thread can actually execute unlock() until the thread waiting in lock() leaves the outer synchronized block.","(""Unlock"", ""Unlock() cannot execute until lock() is released, indicating a dependency between the methods."", ""Lock""); (""Unlock"", ""Unlock() cannot execute until lock() is released, indicating a dependency between the methods."", ""Lock"")"
This result is that any thread calling either lock() or unlock() will become blocked indefinately.,NULL
"That you would not call wait() and notify() on an internal monitor object, but rather on the This is probably true.","(""Wait"", ""Method""); (""Notify"", ""Method""); (""Wait"", ""Method""); (""Notify"", ""Method"")"
"When doing so you want each thread to call wait() on each their own queue object, so that you can notify the threads one at a time.","(""Wait"", ""The method 'Wait' is called on the 'Queue' class object to coordinate threading actions."", ""Queue"")"
"At first glance this implementation may look fine, but notice how the lock() method calls queueObject.wait(); from inside two synchronized blocks.",NULL
"When a thread calls queueObject.wait()it releases the lock on the QueueObject instance, but not the lock associated with ""this"".","(""QueueObject"", ""The 'wait' method is being called on an instance of the 'QueueObject' class."", ""wait""); (""thread"", ""A thread interacts with the 'QueueObject' by calling its method."", ""QueueObject"")"
"Notice too, that the unlock() method is declared synchronized which equals a synchronized(this) block.","(""Unlock"", ""The Unlock method is declared to be synchronized, indicating a concurrency control relationship."", ""Synchronized"")"
"This means, that if a thread is waiting inside lock() the monitor object associated with ""this"" will be locked by the waiting thread.","(""Lock"", ""Method"")"
"All threads calling unlock() will remain blocked indefinately, waiting for the waiting thread to release the lock on ""this"".",NULL
"But this will never happen, since this only happens if a thread succeeds in sending a signal to the waiting thread, and this can only be sent by executing the unlock() method.",NULL
"For instance, the different implementations of the java.util.concurrent.BlockingQueue interface are all blocking data structures.","(""BlockingQueue"", ""BlockingQueue is part of the java.util.concurrent package."", ""java.util.concurrent"")"
"Other threads will read the value of the volatile from main memory every time, instead of from e.g.",NULL
"Thus, this code may still lead to race conditions if performed by more than one thread: volatile myVar = 0; ... int temp = myVar; temp++; myVar = temp; First the value of the volatile variable myVar is read from main memory into a temp variable.","(""Volatile"", ""MyVar is declared as a volatile, indicating it is a volatile variable."", ""MyVar""); (""MyVar"", ""The value of MyVar is stored in the Temp variable, forming a read-mutate-write sequence."", ""Temp""); (""Thread"", ""Multiple threads reading or writing to the MyVar can cause race conditions due to concurrent execution."", ""MyVar"")"
"If two threads execute this code and both of them read the value of myVar, add one to it and write the value back to main memory, then you risk that instead of 2 being added to the myVar variable, only 1 will be added (e.g.",NULL
"Here is a single writer counter which does not use synchronization but is still concurrent: public class SingleWriterCounter { private volatile long count = 0; /** * Only one thread may ever call this method, * or it will lead to race conditions.","(""SingleWriterCounter"", ""The method 'count' is a member of the class 'SingleWriterCounter', indicating it operates within or is related to the class."", ""count"")"
"I mean, only the same, single thread is ever allowed to call inc().","(""Inc"", ""The method 'Inc' is restricted to be called by a single thread, indicating controlled access for synchronization."", ""Thread"")"
"Here is a simple double writer counter class that shows how that could look: public class DoubleWriterCounter { private volatile long countA = 0; private volatile long countB = 0; /** * Only one (and the same from thereon) thread may ever call this method, * or it will lead to race conditions.",NULL
"*/ public void incA() { this.countA++; } /** * Only one (and the same from thereon) thread may ever call this method, * or it will lead to race conditions.","(""incA"", ""The method 'incA' should only be called by one thread to prevent race conditions."", ""thread"")"
"*/ public void incB() { this.countB++; } /** * Many reading threads may call this method */ public long countA() { return this.countA; } /** * Many reading threads may call this method */ public long countB() { return this.countB; } } As you can see, the DoubleWriterCounter now contains two volatile variables, and two pairs of incrementation and read methods.","(""DoubleWriterCounter"", ""The `incB` method is part of the `DoubleWriterCounter` class."", ""IncB""); (""DoubleWriterCounter"", ""The `countA` method is part of the `DoubleWriterCounter` class."", ""CountA""); (""DoubleWriterCounter"", ""The `countB` method is part of the `DoubleWriterCounter` class."", ""CountB""); (""DoubleWriterCounter"", ""The `incB` method is part of the `DoubleWriterCounter` class."", ""IncB""); (""DoubleWriterCounter"", ""The `countA` method is part of the `DoubleWriterCounter` class."", ""CountA""); (""DoubleWriterCounter"", ""The `countB` method is part of the `DoubleWriterCounter` class."", ""CountB"")"
"Only a single thread may ever call incA(), and only a single thread may ever call incB().","(""Inca"", ""Both methods are designed to be called by a single thread, implying they may be related by their synchronized or isolated nature in multi-threading contexts."", ""Incb"")"
This is how such exclusive access could look using a synchronized block in Java: public class SynchronizedCounter { long count = 0; public void inc() { synchronized(this) { count++; } } public long count() { synchronized(this) { return this.count; } } } Notice how the inc() and count() methods both contain a synchronized block.,"(""SynchronizedCounter"", ""The inc method is defined within the SynchronizedCounter class."", ""inc""); (""SynchronizedCounter"", ""The count method is defined within the SynchronizedCounter class."", ""count""); (""inc"", ""Both inc and count methods use a synchronized block to manage exclusive access in the class."", ""count""); (""SynchronizedCounter"", ""The inc method is defined within the SynchronizedCounter class."", ""inc""); (""SynchronizedCounter"", ""The count method is defined within the SynchronizedCounter class."", ""count""); (""inc"", ""Both inc and count methods use a synchronized block to manage exclusive access in the class."", ""count"")"
This is what we want to avoid - synchronized blocks and wait() - notify() calls etc.,"(""WAIT"", ""WAIT and NOTIFY methods are related as they are both used in thread synchronization in Java."", ""NOTIFY"")"
What is interesting about this version is the implementation of the inc() method.,NULL
"Instead it contains these lines: boolean updated = false; while(!updated){ long prevCount = this.count.get(); updated = this.count.compareAndSet(prevCount, prevCount + 1); } These lines are not an atomic operation.",NULL
"That means, that it is possible for two different threads to call the inc() method and execute the long prevCount = this.count.get() statement, and thus both obtain the previous count for the counter.","(""Inc"", ""The method 'Inc' operates on or is part of the class 'Count', as it involves obtaining the previous count using this class."", ""Count"")"
The compareAndSet() method is typically supported by compare-and-swap instructions directly in the CPU.,NULL
"Since compareAndSet() is an atomic operation, the threads will execute this method sequentially (one at a time).","(""COMPAREANDSET()"", ""The threads will execute the method compareAndSet() sequentially due to its atomic nature."", ""threads"")"
"If no other thread has called inc() in the meantime, the second iteration will succeed in updating the AtomicLong to 22.","(""Inc"", ""The method inc() interacts with the class AtomicLong to update its value."", ""AtomicLong"")"
Instead Java provides the AtomicStampedReference class which can swap a reference and a stamp atomically using a compare-and-swap operation.,"(""AtomicStampedReference"", ""The AtomicStampedReference class uses the compare-and-swap operation method to swap a reference and a stamp atomically."", ""compare-and-swap operation"")"
"import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicStampedReference; public class NonblockingTemplate { public static class IntendedModification { public AtomicBoolean completed = new AtomicBoolean(false); } private AtomicStampedReference<IntendedModification> ongoingMod = new AtomicStampedReference<IntendedModification>(null, 0); //declare the state of the data structure here.","(""NonblockingTemplate"", ""IntendedModification is a nested static class within NonblockingTemplate."", ""IntendedModification""); (""IntendedModification"", ""IntendedModification uses AtomicBoolean for the field named completed."", ""AtomicBoolean""); (""NonblockingTemplate"", ""NonblockingTemplate contains a field ongoingMod which is of type AtomicStampedReference."", ""AtomicStampedReference""); (""AtomicStampedReference"", ""AtomicStampedReference is parameterized with IntendedModification."", ""IntendedModification""); (""NonblockingTemplate"", ""IntendedModification is a nested static class within NonblockingTemplate."", ""IntendedModification""); (""IntendedModification"", ""IntendedModification uses AtomicBoolean for the field named completed."", ""AtomicBoolean""); (""NonblockingTemplate"", ""NonblockingTemplate contains a field ongoingMod which is of type AtomicStampedReference."", ""AtomicStampedReference""); (""AtomicStampedReference"", ""AtomicStampedReference is parameterized with IntendedModification."", ""IntendedModification"")"
"public void modify() { while(!attemptModifyASR()); } public boolean attemptModifyASR(){ boolean modified = false; IntendedModification currentlyOngoingMod = ongoingMod.getReference(); int stamp = ongoingMod.getStamp(); if(currentlyOngoingMod == null){ //copy data structure state - for use //in intended modification //prepare intended modification IntendedModification newMod = new IntendedModification(); boolean modSubmitted = ongoingMod.compareAndSet(null, newMod, stamp, stamp + 1); if(modSubmitted){ //complete modification via a series of compare-and-swap operations.","(""Modify"", ""The method 'Modify' calls the method 'AttemptModifyASR'."", ""AttemptModifyASR""); (""AttemptModifyASR"", ""The method 'AttemptModifyASR' works with 'IntendedModification' to handle modifications."", ""IntendedModification""); (""AttemptModifyASR"", ""The method 'AttemptModifyASR' interacts with 'OngoingMod' through its methods."", ""OngoingMod""); (""Modify"", ""The method 'Modify' calls the method 'AttemptModifyASR'."", ""AttemptModifyASR""); (""AttemptModifyASR"", ""The method 'AttemptModifyASR' works with 'IntendedModification' to handle modifications."", ""IntendedModification""); (""AttemptModifyASR"", ""The method 'AttemptModifyASR' interacts with 'OngoingMod' through its methods."", ""OngoingMod"")"
"Multiple threads can access the same instance of this counter, as long as only one thread calls inc().","(""Inc"", ""The method inc() is called on an instance of the Counter class."", ""Counter"")"
Here is a simple double writer counter class that shows how that could look:,NULL
Notice how the inc() and count() methods both contain a synchronized block.,"(""Inc"", ""Both methods use synchronized blocks to ensure thread safety when accessing shared resources."", ""Count"")"
Here is how the same counter class could look using an AtomicLong instead:,"(""Counter"", ""The Counter class uses AtomicLong to implement its functionality."", ""AtomicLong""); (""Counter"", ""The Counter class uses AtomicLong to implement its functionality."", ""AtomicLong"")"
"The check-then-act pattern means, that two or more threads check a given condition, for instance if a Map contains a given value, and then go on to act based on that information, e.g.",NULL
"Imagine if two threads, A and B, are executing the add method on the same instance of the Counter class.",NULL
The code in the add() method is not executed as a single atomic instruction by the Java virtual machine.,"(""Add"", ""The Add method is executed by the Java Virtual Machine."", ""Java Virtual Machine"")"
"Instead of 5, the value left in this.count will be the value written by the last thread to write its value.",NULL
The code in the add() method in the example earlier contains a critical section.,NULL
"If two or more threads call the checkThenAct() method on the same CheckThenActExample object, then two or more threads may execute the if-statement at the same time, evaluate sharedMap.containsKey(""key"") to true, and thus move into the body code block of the if-statement.","(""CheckThenActExample"", ""The method 'checkThenAct' is associated with the 'CheckThenActExample' class as it is called on such an object."", ""checkThenAct"")"
Thread synchronization can also be achieved using other synchronization constructs like locks or atomic variables like java.util.concurrent.atomic.AtomicInteger.,NULL
Notice how the add() method adds values to two different sum member variables.,NULL
Now two threads can execute the add() method at the same time.,"(""Threads"", ""Threads execute the Add method concurrently."", ""Add""); (""Threads"", ""Threads execute the Add method concurrently."", ""Add"")"
This way threads will have to wait less for each other to execute the add() method.,NULL
Java 5 comes with read / write lock implementations in the java.util.concurrent package.,"(""Read/Write Lock Implementations"", ""The Read/Write Lock Implementations are part of the Java.util.concurrent package"", ""Java.util.concurrent"")"
The rules for read access are implemented in the lockRead() method.,"(""LockRead"", ""The LockRead method is implementing rules for read access."", ""Read"")"
The rules for write access are implemented in the lockWrite() method.,"(""LOCKWRITE"", ""METHOD"")"
It is worth noting that both unlockRead() and unlockWrite() calls notifyAll() rather than notify().,NULL
"If a thread awakened by notify() was a read access thread, it would be put back to waiting because there are threads waiting for write access.","(""Notify"", ""Notify is a method that awakens Thread entities."", ""Thread""); (""Read Access Thread"", ""Read Access Thread and Write Access are related as types of access that threads may request."", ""Write Access"")"
By calling noftifyAll() all waiting threads are awakened and check if they can get the desired access.,"(""NotifyAll"", ""Method""); (""NotifyAll"", ""Method"")"
"If multiple threads are waiting for read access and none for write access, and unlockWrite() is called, all threads waiting for read access are granted read access at once - not one by one.","(""UnlockWrite"", ""The method UnlockWrite is related to Threads as it grants read access to threads waiting for read access."", ""Threads"")"
Here is how the lockRead() and unlockRead() methods looks after that change:,NULL
Here is how the lockWrite() and unlockWrite() methods look after that change:,"(""LockWrite"", ""Both methods are likely related as they are part of a locking mechanism, typically used in concurrent programming to manage write operations."", ""UnlockWrite"")"
To achieve this the writeLock() method should be changed a bit.,"(""WriteLock"", ""METHOD"")"
Here is how the canGrantReadAccess() method will look with that change:,"(""CanGrantReadAccess"", ""Method"")"
"When guarding a critical section with a ReadWriteLock, and the critical section may throw exceptions, it is important to call the readUnlock() and writeUnlock() methods from inside a finally-clause.",NULL
"If unlockWrite() was not called from inside a finally-clause, and an exception was thrown from the critical section, the ReadWriteLock would remain write locked forever, causing all threads calling lockRead() or lockWrite() on that ReadWriteLock instance to halt indefinately.","(""UnlockWrite"", ""UnlockWrite is expected to be called from inside a finally-clause to prevent issues if an exception occurs."", ""Finally-clause""); (""ReadWriteLock"", ""LockRead is a method that operates on an instance of ReadWriteLock."", ""LockRead""); (""ReadWriteLock"", ""LockWrite is a method that operates on an instance of ReadWriteLock."", ""LockWrite"")"
"The only thing that could unlock the ReadWriteLockagain would be if the ReadWriteLock is reentrant, and the thread that had it locked when the exception was thrown, later succeeds in locking it, executing the critical section and calling unlockWrite() again afterwards.",NULL
Calling unlockWrite() from a finally-clause is a much more robust solution.,NULL
"If a thread calls lock() twice without calling unlock() in between, the second call to lock() will block.",NULL
Java 5 comes with semaphore implementations in the java.util.concurrent package so you don't have to implement your own semaphores.,"(""Java.util.concurrent"", ""The `java.util.concurrent` package contains implementations of the `Semaphore` class."", ""Semaphore"")"
"You can read more about it in the java.util.concurrent.Semaphore text, in my java.util.concurrent tutorial.",NULL
The take() method sends a signal which is stored internally in the Semaphore.,"(""Take"", ""The take method interacts with an instance of the Semaphore class by sending a signal."", ""Semaphore"")"
"When received the signal flag is cleared again, and the release() method exited.","(""RELEASE"", ""The term release is explicitly mentioned as a method, suggesting a direct relationship where 'RELEASE' is an action or function implemented as a 'METHOD'"", ""METHOD"")"
You will call take() instead of notify() and release() instead of wait().,NULL
"If the call to take() happens before the call to release() the thread calling release() will still know that take() was called, because the signal is stored internally in the signal variable.","(""Take"", ""Release is typically called after Take to indicate the completion of an action initiated by Take."", ""Release"")"
The names take() and release() may seem a bit odd when using a semaphore for signaling.,"(""Take"", ""Both are methods used for semaphore signaling"", ""Release"")"
The Semaphore implementation in the previous section does not count the number of signals sent to it by take() method calls.,"(""Semaphore"", ""The take() method calls are used to send signals to the Semaphore class"", ""take"")"
Notice how the take() method now blocks if the number of signals is equal to the upper bound.,NULL
"Not until a thread has called release() will the thread calling take() be allowed to deliver its signal, if the BoundedSemaphore has reached its upper signal limit.",NULL
"To do so, set the upper bound to 1, and have the call to take() and release() guard the critical section.","(""Take"", ""Both methods are involved in guarding the critical section."", ""Release"")"
In contrast to the signaling use case the methods take() and release() are now called by the same thread.,NULL
"Since only one thread is allowed to take the semaphore, all other threads calling take() will be blocked until release() is called.","(""Take"", ""The methods 'take' and 'release' are related as they both manage thread access to a semaphore where 'take' acquires the semaphore and 'release' allows other threads to acquire it after being blocked."", ""Release"")"
The call to release() will never block since there has always been a call to take() first.,NULL
The relase() method is called from inside a finally-block to make sure it is called even if an exception is thrown from the critical section.,"(""Release"", ""The release() method is related to the finally-block as it is explicitly mentioned to be called inside it to ensure execution even during exceptions."", ""Finally-block"")"
In a classic multi-threaded architecture you will typically assign each task to a separate thread for execution.,"(""Architecture"", ""In a multi-threaded architecture, threads are used, indicating a direct relationship."", ""Thread""); (""Thread"", ""Threads are assigned tasks for execution, suggesting a direct relationship."", ""Task"")"
A classic multi-threaded architecture can also sometimes lead to congestion when multiple threads try to access the same data structure at the same time.,"(""Multi-threaded Architecture"", ""class"")"
The alternative to a classic multithreaded architecture is a single-threaded or same-threaded.,"(""Classic multithreaded architecture"", ""Classic multithreaded architecture and Single-threaded are alternative approaches to multithreading"", ""Single-threaded""); (""Classic multithreaded architecture"", ""Classic multithreaded architecture and Same-threaded are alternative approaches to multithreading"", ""Same-threaded"")"
"This kind of thread loop is both used in server applications (web services, services etc.)",NULL
"For instance, the task executor could keep the tasks in different lists internally, and e.g.",NULL
"If a one-off task is waiting for some asynchronous operation to finish, e.g.",NULL
"Imagine that isLocked is false, and two threads call lock() at the same time.",NULL
"Notice how the synchronized(queueObject) with its queueObject.wait() call is nested inside the synchronized(this) block, resulting in the nested monitor lockout problem.",NULL
"Note: Only the lock() method is shown, since it is the only method I have changed.",NULL
The first synchronized(this) block checks the condition by setting mustWait = isLocked || waitingThreads.get(0) != queueObject.,"(""synchronized(this)"", ""The synchronized(this) method determines the mustWait entity by checking conditions."", ""mustWait""); (""waitingThreads"", ""The waitingThreads class calls the get method."", ""get""); (""waitingThreads"", ""The waitingThreads class contains or is associated with the queueObject."", ""queueObject"")"
Imagine what will happen if two threads call lock() at the same time when the lock is unlocked.,"(""threads"", ""Threads use the lock method to manage concurrent access, indicating a relationship where threads interact with the lock method."", ""lock"")"
Imagine that the FairLock instance is locked when a thread calls lock().,"(""FairLock"", ""The lock() method is called on an instance of the FairLock class, indicating a functional relationship."", ""lock()"")"
"Then imagine that the thread calling lock() is preempted, and the thread that locked the lock calls unlock().",NULL
"If you look at the unlock() implementation shown earlier, you will notice that it calls queueObject.notify().","(""Unlock"", ""The implementation of the method Unlock calls the method Notify, indicating a functional relationship between these methods."", ""Notify""); (""QueueObject"", ""The method Notify is associated with the class QueueObject as it is called on an instance of this class."", ""Notify""); (""Unlock"", ""The implementation of the method Unlock calls the method Notify, indicating a functional relationship between these methods."", ""Notify""); (""QueueObject"", ""The method Notify is associated with the class QueueObject as it is called on an instance of this class."", ""Notify"")"
"But, since the thread waiting in lock() has not yet called queueObject.wait(), the call to queueObject.notify() passes into oblivion.","(""Queueobject"", ""Notify is a method called on the Queueobject"", ""Notify""); (""Queueobject"", ""Wait is a method associated with the Queueobject"", ""Wait"")"
"When the thread calling lock() right after calls queueObject.wait() it will remain blocked until some other thread calls unlock(), which may never happen.",NULL
The missed signals problems is the reason that the FairLock implementation shown in the text Starvation and Fairness has turned the QueueObject class into a semaphore with two methods: doWait() and doNotify().,NULL
"That way the signal is not missed, even if doNotify() is called before doWait().","(""DONOTIFY"", ""DONOTIFY is related to DOWAIT as it is part of a sequence where signals are managed; doNotify() is called before doWait()"", ""DOWAIT"")"
The notify() method makes no guarantee about what thread is awakened if multiple thread have called wait() on the object notify() is called on.,NULL
"If more than one thread call the doSynchronized() method, some of them will be blocked until the first thread granted access has left the method.","(""DoSynchronized"", ""Method"")"
Instead the critical section is guarded by the lock.lock() and lock.unlock() calls.,NULL
A simple implementation of the Lock class could look like this:,"(""Lock"", ""class"")"
"If you look at the Synchronizer class above and look into this Lock implementation you will notice that threads are now blocked trying to access the lock() method, if more than one thread calls lock() simultanously.","(""Synchronizer"", ""The Lock class is part of the implementation related to the Synchronizer class."", ""Lock""); (""Lock"", ""The lock method is a functionality within the Lock class."", ""lock""); (""Synchronizer"", ""The Lock class is part of the implementation related to the Synchronizer class."", ""Lock""); (""Lock"", ""The lock method is a functionality within the Lock class."", ""lock"")"
"Second, if the lock is locked, the threads are blocked in the wait() call inside the while(isLocked) loop in the lock() method.","(""Lock"", ""The Lock method is part of the Lock class, handling locking logic."", ""Lock""); (""Lock"", ""The Wait method is likely used within the Lock mechanism for thread handling."", ""Wait"")"
"Remember that a thread calling wait() releases the synchronization lock on the Lock instance, so threads waiting to enter lock() can now do so.",NULL
The result is that multiple threads can end up having called wait() inside lock().,"(""Wait"", ""The method wait() is often used within the context of synchronization, which the Lock class provides."", ""Lock"")"
"If you look back at the doSynchronized() method you will notice that the comment between lock() and unlock() states, that the code in between these two calls take a ""long"" time to execute.","(""doSynchronized"", ""The lock() method is used within the doSynchronized() method to manage synchronization."", ""lock""); (""doSynchronized"", ""The unlock() method is used within the doSynchronized() method to release the lock after synchronization."", ""unlock"")"
Let us further assume that this code takes long time to execute compared to entering the lock() method and calling wait() because the lock is locked.,NULL
"This means that the majority of the time waited to be able to lock the lock and enter the critical section is spent waiting in the wait() call inside the lock() method, not being blocked trying to enter the lock() method.","(""Lock"", ""The method lock() is part of the Lock class, implementing its function of controlling access to critical sections."", ""Lock""); (""Lock"", ""The wait() method is invoked within the Lock class for synchronization purposes."", ""Wait""); (""Lock"", ""The wait() method is utilized in the lock() method to facilitate the locking mechanism by pausing operations."", ""Wait"")"
Nor does wait() make any guarantees about what thread is awakened when notify() is called.,NULL
"So, the current version of the Lock class makes no different guarantees with respect to fairness than synchronized version of doSynchronized().","(""Lock"", ""The Lock class is being compared to the synchronized version of the doSynchronized() method in terms of fairness guarantees."", ""doSynchronized"")"
The current version of the Lock class calls its own wait() method.,"(""Lock"", ""The Lock class contains the wait() method and calls it."", ""wait()"")"
"If instead each thread calls wait() on a separate object, so that only one thread has called wait() on each object, the Lock class can decide which of these objects to call notify() on, thereby effectively selecting exactly what thread to awaken.",NULL
Below is shown the previous Lock class turned into a fair lock called FairLock.,NULL
You will notice that the implementation has changed a bit with respect to synchronization and wait() / notify() compared to the Lock class shown earlier.,"(""Lock"", ""class"")"
"Exactly how I arrived at this design beginning from the previous Lock class is a longer story involving several incremental design steps, each fixing the problem of the previous step: Nested Monitor Lockout, Slipped Conditions, and Missed Signals.",NULL
"What is important is, that every thread calling lock() is now queued, and only the first thread in the queue is allowed to lock the FairLock instance, if it is unlocked.",NULL
First you might notice that the lock() method is no longer declared synchronized.,"(""Lock"", ""Method""); (""Lock"", ""Method"")"
FairLock creates a new instance of QueueObject and enqueue it for each thread calling lock().,NULL
"The thread calling unlock() will take the top QueueObject in the queue and call doNotify() on it, to awaken the thread waiting on that object.",NULL
The doWait() and doNotify() methods store the signal internally in the QueueObject.,"(""DoWait"", ""The doWait method interacts with QueueObject to store signals."", ""QueueObject""); (""DoNotify"", ""The doNotify method interacts with QueueObject to store signals."", ""QueueObject"")"
"This is done to avoid missed signals caused by a thread being preempted just before calling queueObject.doWait(), by another thread which calls unlock() and thereby queueObject.doNotify().",NULL
"The queueObject.doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout, so another thread can actually call unlock() when no thread is executing inside the synchronized(this) block in lock() method.",NULL
"Finally, notice how the queueObject.doWait() is called inside a try - catch block.",NULL
"In case an InterruptedException is thrown the thread leaves the lock() method, and we need to dequeue it.","(""InterruptedException"", ""An InterruptedException affects the execution flow of the lock method."", ""lock""); (""InterruptedException"", ""An InterruptedException affects the execution flow of the lock method."", ""lock"")"
If you compare the Lock and FairLock classes you will notice that there is somewhat more going on inside the lock() and unlock() in the FairLock class.,NULL
Threads waiting on an object (called wait() on it) remain waiting indefinitely,NULL
"In a desktop app the foreground thread (UI thread) could be responding to the user events - a.g. opening a file, or downloading a file, or saving a file etc.",NULL
"Each thread consumes a certain amount of computer resources, such as memory (RAM), so if you have too many threads active at the same time, the total amount of resources (e.g.",NULL
RAM) that is consumed may cause the computer to slow down - e.g.,NULL
"Java comes with built in thread pools in the java.util.concurrent package, so you don't have to implement your own thread pool.","(""Thread Pools"", ""Thread Pools is a class provided within the Java.util.concurrent package, enabling users to manage threads efficiently without needing to implement their own."", ""Java.util.concurrent"")"
You can read more about it in my text on the java.util.concurrent.ExecutorService.,NULL
"Below here is the PoolThreadRunnable class which implements the Runnable interface, so it can be executed by a Java thread:",NULL
"A ThreadPool class which is the public interface to the thread pool, and a PoolThread class which implements the threads that execute the tasks.",NULL
To execute a task the method ThreadPool.execute(Runnable r) is called with a Runnable implementation as parameter.,NULL
Then each thread in the pool is stopped by calling doStop() on each thread.,"(""doStop"", ""The method doStop is called on each thread to stop it."", ""thread"")"
Notice how the execute() method will throw an IllegalStateException if execute() is called after stop() has been called.,NULL
"This makes sure that a thread blocked in a wait() call inside the taskQueue.dequeue() call breaks out of the wait() call, and leaves the dequeue() method call with an InterruptedException thrown.","(""TaskQueue"", ""The dequeue() method is being called on an instance of the TaskQueue class, indicating a relationship where the method dequeue is likely a member function of the TaskQueue class."", ""Dequeue""); (""Dequeue"", ""The dequeue() method throws an InterruptedException, indicating a handling mechanism where the method can be interrupted and needs to handle this specific exception."", ""InterruptedException"")"
"This exception is caught in the PoolThread.run() method, reported, and then the isStopped variable is checked.","(""PoolThread.run"", ""method""); (""PoolThread.run"", ""method"")"
"Since isStopped is now true, the PoolThread.run() will exit and the thread dies.","(""Poolthread"", ""The method run() is a part of the PoolThread class, indicating an implementation relationship."", ""Run"")"
"Notice how the add() method returns a new ImmutableValue instance with the result of the add operation, rather than adding the value to itself.","(""Add"", ""The Add method returns a new instance of the ImmutableValue class as a result of the add operation."", ""ImmutableValue"")"
Notice how it is possible to change that reference through both the setValue() and add() methods.,NULL
"Therefore, even if the Calculator class uses an immutable object internally, it is not itself immutable, and therefore not thread safe.","(""Calculator"", ""The Calculator class uses an immutable object internally."", ""immutable object"")"
"In other words: The ImmutableValue class is thread safe, but the use of it is not.","(""ImmutableValue"", ""class"")"
"To make the Calculator class thread safe you could have declared the getValue(), setValue(), and add() methods synchronized.","(""Calculator"", ""The getValue method is part of the Calculator class to retrieve its value."", ""getValue""); (""Calculator"", ""The setValue method is part of the Calculator class to set its value."", ""setValue""); (""Calculator"", ""The add method is part of the Calculator class to perform addition."", ""add"")"
"The LocalObject instance in this example is not returned from the method, nor is it passed to any other objects that are accessible from outside the someMethod() method.",NULL
Each thread executing the someMethod() method will create its own LocalObject instance and assign it to the localObject reference.,"(""SomeMethod"", ""The SomeMethod method is responsible for creating instances of the LocalObject class."", ""LocalObject""); (""SomeMethod"", ""The SomeMethod method is responsible for creating instances of the LocalObject class."", ""LocalObject"")"
"Even if the LocalObject instance is passed as parameter to other methods in the same class, or in other classes, the use of it is thread safe.",NULL
If two threads call the add() method simultaneously on the same NotThreadSafe instance then it leads to race conditions.,"(""Add"", ""The method Add is being called on an instance of the class NotThreadSafe."", ""NotThreadSafe""); (""Add"", ""The method Add is being called on an instance of the class NotThreadSafe."", ""NotThreadSafe"")"
"Therefore, when they call the add() method on the NotThreadSafe instance it leads to race condition.",NULL
"However, if two threads call the add() method simultaneously on different instances then it does not lead to race condition.",NULL
"In other words, it is waiting for a signal from thread A which causes hasDataToProcess() to return true.","(""Thread A"", ""Thread A signals or interacts with hasDataToProcess() to determine if there is data to process."", ""hasDataToProcess()"")"
Notice how the while loop keeps executing until hasDataToProcess() returns true.,"(""While Loop"", ""The while loop keeps executing until the hasDataToProcess() method returns true."", ""Has Data To Process"")"
"The class java.lang.Object defines three methods, wait(), notify(), and notifyAll(), to facilitate this.","(""Java.lang.Object"", ""The class java.lang.Object defines the method wait()."", ""Wait()""); (""Java.lang.Object"", ""The class java.lang.Object defines the method notify()."", ""Notify()""); (""Java.lang.Object"", ""The class java.lang.Object defines the method notifyAll()."", ""NotifyAll()"")"
A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object.,"(""WAIT"", ""The method wait() is invoked on an object to make a thread inactive."", ""OBJECT""); (""NOTIFY"", ""The method notify() is called on an object to wake up a waiting thread."", ""OBJECT""); (""WAIT"", ""A thread calls the wait() method to become inactive."", ""THREAD""); (""NOTIFY"", ""A thread calls the notify() method to activate another thread."", ""THREAD"")"
In order to call either wait() or notify the calling thread must first obtain the lock on that object.,"(""Wait"", ""Both methods are related because they require the calling thread to obtain a lock on the object they are invoked upon."", ""Notify""); (""Wait"", ""Both methods are related because they require the calling thread to obtain a lock on the object they are invoked upon."", ""Notify"")"
"In other words, the calling thread must call wait() or notify() from inside a synchronized block.",NULL
Here is a modified version of MySignal called MyWaitNotify that uses wait() and notify().,"(""MyWaitNotify"", ""MyWaitNotify uses the wait() method for execution control."", ""wait()""); (""MyWaitNotify"", ""MyWaitNotify uses the notify() method to manage synchronization."", ""notify()"")"
"The waiting thread would call doWait(), and the notifying thread would call doNotify().",NULL
"When a thread calls notify() on an object, one of the threads waiting on that object are awakened and allowed to execute.",NULL
There is also a notifyAll() method that will wake all threads waiting on a given object.,NULL
As you can see both the waiting and notifying thread calls wait() and notify() from within a synchronized block.,"(""Wait()"", ""Wait() is called within a Synchronized Block, which is necessary for ensuring that the thread holds the appropriate lock before waiting."", ""Synchronized Block""); (""Notify()"", ""Notify() is called within a Synchronized Block, which is necessary to safely notify threads waiting on the same lock."", ""Synchronized Block"")"
"A thread cannot call wait(), notify() or notifyAll() without holding the lock on the object the method is called on.",NULL
Will the waiting thread not block the notifying thread from ever entering the synchronized block in doNotify()?,NULL
Once a thread calls wait() it releases the lock it holds on the monitor object.,NULL
"This allows other threads to call wait() or notify() too, since these methods must be called from inside a synchronized block.","(""Wait"", ""Both methods are used in synchronization contexts and are usually called within synchronized blocks to manage thread communication."", ""Notify"")"
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block.,"(""Thread"", ""The Thread is directly involved in the wait() method as it is put into a waiting state."", ""Wait""); (""Thread"", ""The Notify method is used by the Thread to be awakened from the waiting state."", ""Notify""); (""Thread"", ""The Thread is directly involved in the wait() method as it is put into a waiting state."", ""Wait""); (""Thread"", ""The Notify method is used by the Thread to be awakened from the waiting state."", ""Notify"")"
"In other words: The awakened thread must reobtain the lock on the monitor object before it can exit the wait() call, because the wait call is nested inside a synchronized block.","(""Wait Call"", ""The wait call is nested inside the monitor object, indicating a synchronization mechanism requiring the monitor to manage access to the wait operation."", ""Monitor Object""); (""Synchronized Block"", ""The synchronized block requires obtaining the lock on the monitor object to manage concurrent access to the code block, ensuring thread safety."", ""Monitor Object"")"
"If multiple threads are awakened using notifyAll() only one awakened thread at a time can exit the wait() method, since each thread must obtain the lock on the monitor object in turn before exiting wait().","(""NotifyAll"", ""NotifyAll awakens threads that may exit the Wait method."", ""Wait"")"
The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called.,"(""Notify"", ""Both methods involve notifying threads and their functionality is linked in the context of thread synchronization"", ""NotifyAll"")"
"Therefore, if a thread calls notify() before the thread to signal has called wait(), the signal will be missed by the waiting thread.",NULL
To avoid losing signals they should be stored inside the signal class.,"(""Signal"", ""class"")"
Notice how the doNotify() method now sets the wasSignalled variable to true before calling notify().,NULL
"Also, notice how the doWait() method now checks the wasSignalled variable before calling wait().",NULL
In fact it only calls wait() if no signal was received in between the previous doWait() call and this.,NULL
For inexplicable reasons it is possible for threads to wake up even if notify() and notifyAll() has not been called.,"(""Notify"", ""Both are methods used to communicate between threads."", ""NotifyAll""); (""Thread"", ""The Notify method is invoked on Thread objects."", ""Notify""); (""Thread"", ""The NotifyAll method is invoked on Thread objects."", ""NotifyAll"")"
If a spurious wakeup occurs in the MyWaitNofity2 class's doWait() method the waiting thread may continue processing without having received a proper signal to do so!,"(""MyWaitNofity2"", ""The doWait method is part of the MyWaitNofity2 class."", ""doWait"")"
Notice how the wait() call is now nested inside a while loop instead of an if-statement.,"(""Wait"", ""Method"")"
"The while loop is also a nice solution if you have multiple threads waiting, which are all awakened using notifyAll(), but only one of them should be allowed to continue.","(""NotifyAll"", ""Method"")"
"Only one thread at a time will be able to obtain the lock on the monitor object, meaning only one thread can exit the wait() call and clear the wasSignalled flag.",NULL
"Once this thread then exits the synchronized block in the doWait() method, the other threads can exit the wait() call and check the wasSignalled member variable inside the while loop.","(""doWait()"", ""The doWait() method involves exiting a synchronized block, allowing other threads to exit the wait() call, indicating a procedural relationship in thread synchronization."", ""wait()"")"
"An earlier version of this text had an edition of the MyWaitNotify example class which used a constant string ( """" ) as monitor object.",NULL
"The problem with calling wait() and notify() on the empty string, or any other constant string is, that the JVM/Compiler internally translates constant strings into the same object.",NULL
This also means that threads calling doWait() on the first MyWaitNotify instance risk being awakened by doNotify() calls on the second MyWaitNotify instance.,NULL
"Remember, that even if the 4 threads call wait() and notify() on the same shared string instance, the signals from the doWait() and doNotify() calls are stored individually in the two MyWaitNotify instances.","(""wait()"", ""Both methods are synchronization mechanisms that can be called on a shared object to manage thread communication."", ""notify()""); (""doWait()"", ""Both methods are actions related to thread signaling within the context of the MyWaitNotify class."", ""doNotify()""); (""MyWaitNotify"", ""doWait() is a method that is part of the MyWaitNotify class, suggesting a specific implementation context."", ""doWait()""); (""MyWaitNotify"", ""doNotify() is a method that is part of the MyWaitNotify class, suggesting a specific implementation context."", ""doNotify()"")"
"A doNotify() call on the MyWaitNotify 1 may wake threads waiting in MyWaitNotify 2, but the signal will only be stored in MyWaitNotify 1.","(""MyWaitNotify 1"", ""The doNotify() call on MyWaitNotify 1 may wake threads waiting in MyWaitNotify 2, indicating a signaling relationship between the two classes."", ""MyWaitNotify 2"")"
"After all, if doNotify() is called on the second MyWaitNotify instance all that can really happen is that Thread A and B are awakened by mistake.","(""DoNotify"", ""The method DoNotify is called on an instance of the class MyWaitNotify."", ""MyWaitNotify""); (""MyWaitNotify"", ""The instances of MyWaitNotify are associated with actions that involve Threads A and B."", ""Thread"")"
"This awakened thread (A or B) will check its signal in the while loop, and go back to waiting because doNotify() was not called on the first MyWaitNotify instance, in which they are waiting.",NULL
"The problem is, that since the doNotify() call only calls notify() and not notifyAll(), only one thread is awakened even if 4 threads are waiting on the same string instance (the empty string).",NULL
"If the doNotify() method had called notifyAll() instead of notify(), all waiting threads had been awakened and checked for signals in turn.","(""doNotify"", ""The doNotify method can call the notifyAll method to wake up all waiting threads."", ""notifyAll""); (""doNotify"", ""The doNotify method can call the notify method to wake up a single waiting thread."", ""notify"")"
"Thread A and B would have gone back to waiting, but one of either C or D would have noticed the signal and left the doWait() method call.",NULL
"The other of C and D would go back to waiting, because the thread discovering the signal clears it on the way out of doWait().","(""SIGNAL"", ""The doWait method is involved in clearing a signal during its execution."", ""DOWAIT"")"
"You may be tempted then to always call notifyAll() instead notify(), but this is a bad idea performance wise.",NULL
"For instance, each MyWaitNotify3 (example from earlier sections) instance has its own MonitorObject instance rather than using the empty string for wait() / notify() calls.",NULL
"The AtomicBoolean class provides you with a boolean variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().",NULL
"The AtomicBoolean class is located in the java.util.concurrent.atomic package, so the full class name is java.util.concurrent.atomic.AtomicBoolean .","(""AtomicBoolean"", ""The AtomicBoolean class is located in the java.util.concurrent.atomic package."", ""java.util.concurrent.atomic"")"
You can get the value of an AtomicBoolean using the get() method.,NULL
You can set the value of an AtomicBoolean using the set() method.,NULL
You can swap the value of an AtomicBoolean using the getAndSet() method.,NULL
"The getAndSet() method returns the AtomicBoolean's current value, and sets a new value for it.","(""getAndSet"", ""The 'getAndSet' method is related to the 'AtomicBoolean' class as it manipulates its current value."", ""AtomicBoolean""); (""getAndSet"", ""The 'getAndSet' method is related to the 'AtomicBoolean' class as it manipulates its current value."", ""AtomicBoolean"")"
"The method compareAndSet() allows you to compare the current value of the AtomicBoolean to an expected value, and if current value is equal to the expected value, a new value can be set on the AtomicBoolean.","(""CompareAndSet"", ""The method compareAndSet() operates on the AtomicBoolean class to compare and set its values based on a condition."", ""AtomicBoolean"")"
"The compareAndSet() method is atomic, so only a single thread can execute it at the same time.","(""CompareAndSet"", ""Method"")"
"Thus, the compareAndSet() method can be used to implemented simple synchronizers like locks.","(""CompareAndSet"", ""The compareAndSet method can be used to implement synchronizers like locks, indicating a functional relationship."", ""Locks"")"
"The AtomicInteger class provides you with a int variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().",NULL
"The AtomicInteger class is located in the java.util.concurrent.atomic package, so the full class name is java.util.concurrent.atomic.AtomicInteger .","(""AtomicInteger"", ""The AtomicInteger class is located in the java.util.concurrent.atomic package, indicating a containment or definition relationship."", ""java.util.concurrent.atomic"")"
You can get the value of an AtomicInteger instance via the get() method.,NULL
You can set the value of an AtomicInteger instance via the set() method.,"(""AtomicInteger"", ""The set method is a function that operates on an instance of the AtomicInteger class."", ""set"")"
The AtomicInteger class contains a few methods you can use to add a value to the AtomicInteger and get its value returned.,NULL
"The first method, addAndGet() adds a number to the AtomicInteger and returns its value after the addition.",NULL
"The second method, getAndAdd() also adds a number to the AtomicInteger but returns the value the AtomicInteger had before the value was added.","(""getAndAdd"", ""The method getAndAdd is related to the class AtomicInteger because it performs operations on it."", ""AtomicInteger"")"
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicInteger.,"(""GetAndIncrement"", ""The method GetAndIncrement operates on the AtomicInteger class."", ""AtomicInteger""); (""IncrementAndGet"", ""The method IncrementAndGet operates on the AtomicInteger class."", ""AtomicInteger""); (""GetAndAdd"", ""The method GetAndAdd operates on the AtomicInteger class."", ""AtomicInteger""); (""AddAndGet"", ""The method AddAndGet operates on the AtomicInteger class."", ""AtomicInteger"")"
The AtomicInteger class also contains a few methods for subtracting values from the AtomicInteger value atomically.,"(""AtomicInteger"", ""The class AtomicInteger contains methods related to subtracting values."", ""subtracting"")"
The decrementAndGet() subtracts 1 from the AtomicInteger value and returns its value after the subtraction.,NULL
The getAndDecrement() also subtracts 1 from the AtomicInteger value but returns the value the AtomicInteger had before the subtraction.,"(""Getanddecrement"", ""The method getAndDecrement is used to interact with the AtomicInteger class by decrementing its value."", ""Atomicinteger"")"
The Java AtomicIntegerArray class (java.util.concurrent.atomic.AtomicIntegerArray) represents an array of int .,NULL
You can get the value of a given element using the get() method on the AtomicIntegerArray.,"(""Get"", ""The 'get' method is used to retrieve the value from an instance of the 'AtomicIntegerArray' class."", ""AtomicIntegerArray"")"
Here is an example showing how calling the get() method looks:,"(""GET"", ""method""); (""GET"", ""method"")"
You can set the value of a given element using the set() method on the AtomicIntegerArray.,"(""SET"", ""The set method is used on an instance of the AtomicIntegerArray class to set the value of an element."", ""ATOMICINTEGERARRAY"")"
Here is an example showing how calling the set() method looks:,"(""Set"", ""method""); (""Set"", ""method"")"
"The compareAndSet() method is used to compare the value of a given element with a specified value, and if the two values are equal, set a new value for that element.","(""CompareAndSet()"", ""Method"")"
Only one thread at a time can execute the compareAndSet() method.,"(""CompareAndSet"", ""method""); (""CompareAndSet"", ""method"")"
"The compareAndSet() method returns a boolean with the value true if the element had a new value set, and false if not (if the element did not have the expected value).","(""CompareAndSet"", ""Method"")"
Calling addAndGet() is also an atomic operation (like all operations on the AtomicIntegerArray).,NULL
"The getAndAdd() method does the same as the addAndGet() method, except the getAndAdd() method returns the value of the element before a value is added to it.","(""getAndAdd"", ""getAndAdd is related to addAndGet because they perform similar operations, with a difference in the return value."", ""addAndGet"")"
The incrementAndGet() method increments (adds 1) to the value of a given element and returns the new value of that element.,NULL
"The getAndIncrement() method does the same as the incrementAndGet() method, except the getAndIncrement() method returns the value of the element before it is incremented.","(""GetAndIncrement()"", ""Both are methods that deal with incrementing, but they differ in whether the current or incremented value is returned."", ""IncrementAndGet()"")"
The decrementAndGet() method decrements (subtracts 1) to the value of a given element and returns the new value of that element.,"(""decrementAndGet()"", ""method""); (""decrementAndGet()"", ""method"")"
"The getAndDecrement() method does the same as the decrementAndGet() method, except the getAndDecrement() method returns the value of the element before it is decremented.","(""getAndDecrement"", ""getAndDecrement and decrementAndGet are both methods that perform a decrement operation, but they differ in what value they return."", ""decrementAndGet"")"
You should check out the JavaDoc for the AtomicIntegerArray class to learn more about those methods.,"(""AtomicIntegerArray"", ""Methods are functions that belong to the class AtomicIntegerArray."", ""methods"")"
"The AtomicLong class provides you with a long variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().",NULL
"The AtomicLong class is located in the java.util.concurrent.atomic package, so the full class name is java.util.concurrent.atomic.AtomicLong .","(""AtomicLong"", ""The class AtomicLong is located in the java.util.concurrent.atomic package."", ""java.util.concurrent.atomic"")"
You can get the value of an AtomicLong instance via the get() method.,"(""AtomicLong"", ""The get() method is used to retrieve the value from an instance of the AtomicLong class."", ""get()"")"
You can set the value of an AtomicLong instance via the set() method.,NULL
The AtomicLong class contains a few methods you can use to add a value to the AtomicLong and get its value returned.,"(""AtomicLong"", ""The 'add' method is used to add a value to the 'AtomicLong' class."", ""add""); (""AtomicLong"", ""The 'get' method is used to retrieve the value from the 'AtomicLong' class."", ""get"")"
"The first method, addAndGet() adds a number to the AtomicLong and returns its value after the addition.","(""AddAndGet"", ""The method addAndGet() operates on an instance of the AtomicLong class by adding a number to it and returning the resulting value."", ""AtomicLong""); (""AddAndGet"", ""The method addAndGet() operates on an instance of the AtomicLong class by adding a number to it and returning the resulting value."", ""AtomicLong"")"
"The second method, getAndAdd() also adds a number to the AtomicLong but returns the value the AtomicLong had before the value was added.","(""getAndAdd"", ""The method getAndAdd is related to the AtomicLong class as it operates on instances of this class."", ""AtomicLong"")"
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicLong.,"(""getAndIncrement"", ""The methods perform similar actions of incrementing by 1."", ""incrementAndGet""); (""getAndAdd"", ""Both methods involve adding values to the current value."", ""addAndGet""); (""getAndIncrement"", ""The method operates on the AtomicLong class."", ""AtomicLong""); (""incrementAndGet"", ""The method operates on the AtomicLong class."", ""AtomicLong""); (""getAndAdd"", ""The method operates on the AtomicLong class."", ""AtomicLong""); (""addAndGet"", ""The method operates on the AtomicLong class."", ""AtomicLong"")"
The AtomicLong class also contains a few methods for subtracting values from the AtomicLong value atomically.,NULL
The decrementAndGet() subtracts 1 from the AtomicLong value and returns its value after the subtraction.,"(""DecrementAndGet"", ""The method decrementAndGet() is applied to the AtomicLong class by subtracting 1 from its value and returning the result."", ""AtomicLong"")"
The getAndDecrement() also subtracts 1 from the AtomicLong value but returns the value the AtomicLong had before the subtraction.,NULL
The Java AtomicLongArray class (java.util.concurrent.atomic.AtomicLongArray) represents an array of long .,"(""java.util.concurrent.atomic"", ""The AtomicLongArray class is contained within the java.util.concurrent.atomic package, indicating a package-class relationship."", ""AtomicLongArray"")"
You can get the value of a given element using the get() method on the AtomicLongArray.,"(""source_entity"", ""relationship_description"", ""target_entity""); (""xxx"", ""xxxxxxxxxxxxxxxxxxxxxxxxx"", ""xxx""); (""xxx"", ""xxxxxxxxxxxxxxxxxxxxxxxxx"", ""xxx""); (""Get"", ""The get method is used on the AtomicLongArray class"", ""AtomicLongArray"")"
You can set the value of a given element using the set() method on the AtomicLongArray.,"(""Set"", ""The set method belongs to or is used on an instance of the AtomicLongArray class."", ""AtomicLongArray"")"
Calling addAndGet() is also an atomic operation (like all operations on the AtomicLongArray).,"(""AddAndGet"", ""The method AddAndGet is an operation of the class AtomicLongArray, indicating it belongs to this class."", ""AtomicLongArray"")"
You should check out the JavaDoc for the AtomicLongArray class to learn more about those methods.,"(""AtomicLongArray"", ""The AtomicLongArray class contains the methods being referenced."", ""methods""); (""JavaDoc"", ""JavaDoc is a package where documentation for the AtomicLongArray class can be found."", ""AtomicLongArray"")"
The AtomicReference class provides an object reference variable which can be read and written atomically.,"(""AtomicReference"", ""class"")"
By atomic is meant that multiple threads attempting to change the same AtomicReference (e.g.,"(""AtomicReference"", ""class"")"
"AtomicReference even has an advanced compareAndSet() method which lets you compare the reference to an expected value (reference) and if they are equal, set a new reference inside the AtomicReference object.",NULL
You can get the reference stored in an AtomicReference using the AtomicReference's get() method.,"(""AtomicReference"", ""The get() method is a function of the AtomicReference class, used to retrieve the stored reference."", ""get()"")"
If you have an untyped AtomicReference then the get() method returns an Object reference.,"(""AtomicReference"", ""The get method is a member function of the AtomicReference class, allowing retrieval of the contained object."", ""get"")"
If you have a typed AtomicReference then get() returns a reference to the type you declared on the AtomicReference variable when you created it.,"(""AtomicReference"", ""The method get() is associated with the AtomicReference class as it is used to return a reference to the type declared on the AtomicReference variable."", ""get()""); (""AtomicReference"", ""The method get() is associated with the AtomicReference class as it is used to return a reference to the type declared on the AtomicReference variable."", ""get()"")"
Notice how it is necessary to cast the reference returned by get() to a String because get() returns an Object reference when the AtomicReference is untyped.,"(""Get"", ""The get() method requires casting to String since it returns an Object reference."", ""String""); (""Get"", ""The get() method returns an Object reference when called."", ""Object""); (""AtomicReference"", ""The get() method is a component of the AtomicReference class."", ""Get"")"
Notice how it is no longer necessary to cast the referenced returned by get() because the compiler knows it will return a String reference.,"(""GET"", ""The method get() returns a reference to the class String, indicating a return type relationship."", ""STRING"")"
You can set the reference stored in an AtomicReference instance using its set() method.,NULL
In an untyped AtomicReference instance the set() method takes an Object reference as parameter.,NULL
In a typed AtomicReference the set() method takes whatever type as parameter you declared as its type when you declared the AtomicReference.,"(""AtomicReference"", ""The set method is a function that operates on the AtomicReference class."", ""set"")"
There is no difference to see in the use of the set() method for an untyped or typed reference.,"(""Set"", ""Method""); (""Set"", ""Method"")"
"The compareAndSet() method can compare the reference stored in the AtomicReference instance with an expected reference, and if they two references are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicReference instance.","(""CompareAndSet"", ""The compareAndSet() method operates on instances of the AtomicReference class to manage references."", ""AtomicReference"")"
If compareAndSet() sets a new reference in the AtomicReference the compareAndSet() method returns true.,"(""CompareAndSet"", ""The method compareAndSet is used within the context of the AtomicReference class to set a new reference and determine the outcome of the operation."", ""AtomicReference"")"
"Then it calls comparesAndSet() two times to compare the stored reference to the initial reference, and set a new reference if the stored reference is equal to the initial reference.",NULL
"The second time the stored reference is the new reference just set in the call to compareAndSet() before, so the stored reference is of course not equal to the initial reference.",NULL
"Thus, a new reference is not set on the AtomicReference and the compareAndSet() method returns false.",NULL
The AtomicReferenceArray in the java.util.concurrent.atomic package is an array of object references which can be updated atomically.,"(""AtomicReferenceArray"", ""AtomicReferenceArray is part of the java.util.concurrent.atomic package"", ""java.util.concurrent.atomic""); (""AtomicReferenceArray"", ""AtomicReferenceArray is part of the java.util.concurrent.atomic package"", ""java.util.concurrent.atomic"")"
"The second constructor takes a E[] array as parameter, where E is the type (class) of the object references.","(""E"", ""class"")"
The get() method returns the value of the element with the given index.,"(""GET"", ""The GET method returns the value of an element."", """"); (""GET"", ""The GET method returns the value of an element."", """")"
"If the AtomicReferenceArray has a generic type, the get() method returns objects of that type.",NULL
"For instance, if the generic type is String, then you can call get() like this:",NULL
The set() method sets the value of an element with a specific index.,NULL
The index and value is passed as parameters to the set() method.,"(""Index"", ""The index is a parameter of the set method, indicating a positional input in the operation."", ""Set""); (""Value"", ""The value is a parameter of the set method, specifying the data to be inserted or manipulated."", ""Set"")"
"The compareAndSet() method of the AtomicReferenceArray can compare the current reference stored in a given element with an expected reference, and if the references are the same, swap the current reference with a new reference.","(""CompareAndSet"", ""The method CompareAndSet belongs to the class AtomicReferenceArray as it is described as a method of this class."", ""AtomicReferenceArray"")"
You should check out the JavaDoc for the AtomicReferenceArray class to learn more about those methods.,"(""AtomicReferenceArray"", ""class""); (""AtomicReferenceArray"", ""class"")"
The AtomicStampedReference class provides an object reference variable which can be read and written atomically.,"(""AtomicStampedReference"", ""The AtomicStampedReference class provides an object reference variable, indicating a relationship where AtomicStampedReference uses or contains the object reference variable atomically."", ""object reference variable"")"
"The reference and stamp can be swapped using a single atomic compare-and-swap operation, via the compareAndSet() method.",NULL
You can get the reference stored in an AtomicStampedReference using the AtomicStampedReference's getReference() method.,"(""AtomicStampedReference"", ""getReference is a method that belongs to the AtomicStampedReference class"", ""getReference"")"
If you have an untyped AtomicStampedReference then the getReference() method returns an Object reference.,"(""AtomicStampedReference"", ""The method getReference() is used with the class AtomicStampedReference to retrieve an Object reference."", ""getReference()"")"
If you have a typed AtomicStampedReference then getReference() returns a reference to the type you declared on the AtomicStampedReference variable when you created it.,"(""AtomicStampedReference"", ""The getReference() method is associated with the AtomicStampedReference class, providing access to the reference of the type declared."", ""getReference"")"
Notice how it is necessary to cast the reference returned by getReference() to a String because getReference() returns an Object reference when the AtomicStampedReference is untyped.,NULL
Notice how it is no longer necessary to cast the referenced returned by getReference() because the compiler knows it will return a String reference.,NULL
The AtomicStampedReference also contains a getStamp() method which can be used to obtain the internally stored stamp.,"(""AtomicStampedReference"", ""The getStamp method is part of the AtomicStampedReference class, indicating a class-method relationship."", ""getStamp"")"
"You can obtain both reference and stamp from an AtomicStampedReference in a single, atomic operation using the get() method.","(""AtomicStampedReference"", ""The get() method is used to perform an atomic operation on the AtomicStampedReference class."", ""get"")"
The get() method returns the reference as return value from the method.,NULL
The stamp is inserted into an int[] array that is passed as parameter to the get() method.,NULL
You can set the reference stored in an AtomicStampedReference instance using its set() method.,NULL
In an untyped AtomicStampedReference instance the set() method takes an Object reference as first parameter.,"(""AtomicStampedReference"", ""The set method is associated with the AtomicStampedReference class as it operates on instances of this class."", ""set""); (""AtomicStampedReference"", ""The set method is associated with the AtomicStampedReference class as it operates on instances of this class."", ""set"")"
In a typed AtomicStampedReference the set() method takes whatever type as parameter you declared as its type when you declared the AtomicStampedReference.,"(""AtomicStampedReference"", ""The 'set' method is a function that operates on instances of the 'AtomicStampedReference' class."", ""set"")"
"The compareAndSet() method can compare the reference stored in the AtomicStampedReference instance with an expected reference, and the stored stamp with an expected stamp, and if they two references and stamps are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicStampedReference instance.","(""CompareAndSet"", ""The compareAndSet method is a part of the functionality provided by the AtomicStampedReference class, as it operates on instances of this class to compare and set references."", ""AtomicStampedReference"")"
If compareAndSet() sets a new reference in the AtomicStampedReference the compareAndSet() method returns true.,NULL
This example first creates an AtomicStampedReference and then uses compareAndSet() to swap the reference and stamp.,"(""AtomicStampedReference"", ""The compareAndSet() method is used to swap the reference and stamp of the AtomicStampedReference class."", ""compareAndSet()"")"
After the first compareAndSet() call the example attempts to swap the reference and stamp two times without success.,"(""CompareAndSet"", ""Both methods are involved in modifying a reference and stamp, with CompareAndSet being called first followed by Swap."", ""Swap"")"
"The first time the initialRef is passed as expected reference, but the internally stored reference is newRef at this time, so the compareAndSet() call fails.","(""compareAndSet"", ""compareAndSet method is used in context to perform an atomic operation based on the stored reference."", ""References"")"
"The second time the initialStamp is passed as the expected stamp, but the internally stored stamp is newStamp at this time, so the compareAndSet() call fails.","(""initialStamp"", ""The initialStamp is used as an expected stamp in the comparison process"", ""expected stamp""); (""initialStamp"", ""The internally stored stamp transitioned from initialStamp to newStamp"", ""newStamp""); (""newStamp"", ""The compareAndSet method uses newStamp to perform its operation"", ""compareAndSet"")"
"The final compareAndSet() call will succeed, because the expected reference is newRef and the expected stamp is newStamp.",NULL
Thread 1 can copy the reference and stamp out of the AtomicStampedReference atomically using get().,"(""Thread 1"", ""Thread 1 interacts with AtomicStampedReference to obtain atomic reference and stamp."", ""AtomicStampedReference""); (""AtomicStampedReference"", ""The method 'get' is used to retrieve the reference and stamp from AtomicStampedReference atomically."", ""get"")"
"If another thread changes the reference from A to B and then back to A, then the stamp will have changed (provided threads update the stamp sensibly - e.g increment it).",NULL
"The BlockingDeque interface in the java.util.concurrent class represents a deque which is thread safe to put into, and take instances from.",NULL
"The BlockingDeque class is a Deque which blocks threads tring to insert or remove elements from the deque, in case it is either not possible to insert or remove elements from the deque.","(""BlockingDeque"", ""The BlockingDeque class is described as a type of Deque, establishing a relationship where BlockingDeque is a specialized version of Deque."", ""Deque"")"
The java.util.concurrent package has the following implementations of the BlockingDeque interface:,"(""Java.util.concurrent"", ""Package""); (""BlockingDeque"", ""Class"")"
The java.util.concurrent.ConcurrentMap interface represents a Map which is capable of handling concurrent access (puts and gets) to it.,NULL
"The ConcurrentMap has a few extra atomic methods in addition to the methods it inherits from its superinterface, java.util.Map.","(""ConcurrentMap"", ""ConcurrentMap inherits methods from java.util.Map, indicating a superclass relationship."", ""java.util.Map"")"
The java.util.concurrent package contains the following implementations of the ConcurrentMap interface:,"(""java.util.concurrent"", ""The java.util.concurrent package contains implementations of the ConcurrentMap interface."", ""ConcurrentMap"")"
"The ConcurrentHashMap is very similar to the java.util.HashTable class, except that ConcurrentHashMap offers better concurrency than HashTable does.","(""ConcurrentHashMap"", ""ConcurrentHashMap is compared to java.util.HashTable in terms of concurrency"", ""java.util.HashTable""); (""ConcurrentHashMap"", ""ConcurrentHashMap is mentioned regarding its concurrency advantages over HashTable"", ""HashTable"")"
"The java.util.concurrent.ConcurrentNavigableMap class is a java.util.NavigableMap with support for concurrent access, and which has concurrent access enabled for its submaps.","(""ConcurrentNavigableMap"", ""ConcurrentNavigableMap is a type of NavigableMap with support for concurrent access"", ""NavigableMap""); (""ConcurrentNavigableMap"", ""ConcurrentNavigableMap is part of the java.util.concurrent package"", ""java.util.concurrent""); (""NavigableMap"", ""NavigableMap is part of the java.util package"", ""java.util"")"
"The ""submaps"" are the maps returned by various methods like headMap(), subMap() and tailMap().","(""SubMap"", ""Both are methods involved in manipulating submaps."", ""HeadMap""); (""SubMap"", ""Both are methods involved in manipulating submaps."", ""TailMap""); (""HeadMap"", ""Both are methods involved in manipulating submaps."", ""TailMap""); (""SubMap"", ""Both are methods involved in manipulating submaps."", ""HeadMap""); (""SubMap"", ""Both are methods involved in manipulating submaps."", ""TailMap""); (""HeadMap"", ""Both are methods involved in manipulating submaps."", ""TailMap"")"
Here is an example illustrating the use of the headMap() method.,NULL
Here is an example illustrating the use of the tailMap() method:,NULL
"The subMap() method returns a view of the original map which contains all keys from (including), to (excluding) two keys given as parameters to the method.","(""subMap"", ""method"")"
A java.util.concurrent.CountDownLatch is a concurrency construct that allows one or more threads to wait for a given set of operations to complete.,"(""CountDownLatch"", ""CountDownLatch is part of the java.util.concurrent package"", ""java.util.concurrent"")"
Threads waiting for this count to reach zero can call one of the await() methods.,"(""await()"", ""The method 'await()' is described as one that can be called by threads waiting for a count to reach zero."", ""await()"")"
"After the Decrementer has called countDown() 3 times on the CountDownLatch, the waiting Waiter is released from the await() call.",NULL
The java.util.concurrent.CyclicBarrier class is a synchronization mechanism that can synchronize threads progressing through some algorithm.,NULL
The threads wait for each other by calling the await() method on the CyclicBarrier.,"(""Await"", ""The await() method is a function associated with the CyclicBarrier class, used by threads to wait for each other."", ""CyclicBarrier"")"
The value returned by the getDelay() method should be the delay remaining before this element can be released.,NULL
"If 0 or a negative value is returned, the delay will be considered expired, and the element released at the next take() etc.",NULL
The TimeUnit instance passed to the getDelay() method is an Enum that tells which time unit the delay should be returned in.,"(""Timeunit"", ""TimeUnit instance passed to the getDelay() method, indicating a functional relationship."", ""Getdelay()""); (""Enum"", ""TimeUnit is described as an Enum, suggesting a type relationship."", ""Timeunit"")"
"The Delayed interface also extends the java.lang.Comparable interface, as you can see, which means that Delayed objects can be compared to each other.",NULL
You will have to create your own implementation of the Delayed interface to use the DelayQueue class.,"(""DelayQueue"", ""The DelayQueue class requires an implementation of the Delayed interface to function correctly."", ""Delayed"")"
The java.util.concurrent.Exchanger class represents a kind of rendezvous point where two threads can exchange objects.,"(""Exchanger"", ""The Exchanger class is part of the java.util.concurrent package."", ""java.util.concurrent"")"
Exchanging objects is done via one of the two exchange() methods.,"(""Exchange"", ""The text indicates that 'exchange' refers to a method used for exchanging objects."", ""Exchange"")"
"The Java BlockingQueue interface, java.util.concurrent.BlockingQueue, represents a queue which is thread safe to put elements into, and take elements out of from.","(""java.util.concurrent"", ""BlockingQueue is part of the package java.util.concurrent as indicated by the naming convention in Java"", ""BlockingQueue"")"
The java.util.concurrent package has the following implementations of the BlockingQueue interface:,"(""Java.util.concurrent"", ""The package java.util.concurrent includes implementations for the BlockingQueue interface"", ""BlockingQueue"")"
"First, the BlockingQueueExample class which starts a Producer and a Consumer in separate threads.","(""BlockingQueueExample"", ""BlockingQueueExample class starts a Producer in a separate thread."", ""Producer""); (""BlockingQueueExample"", ""BlockingQueueExample class starts a Consumer in a separate thread."", ""Consumer"")"
"It just takes out the objects from the queue, and prints them to System.out.",NULL
The Java BlockingQueue add() method will add the element passed as parameter to this method if the BlockingQueue has space for it internally.,"(""BlockingQueue"", ""The add() method is related to the BlockingQueue class as it is a method that operates on or is used with instances of this class."", ""add()"")"
"If the BlockingQueue does not have space internally for this new element, the add() method throws an IllegalStateException.","(""add()"", ""The add() method throws an IllegalStateException if the BlockingQueue does not have space for a new element."", ""IllegalStateException""); (""BlockingQueue"", ""The BlockingQueue is related to the add() method as it operates on this class."", ""add()"")"
The BlockingQueue offer() method will add the element passed as parameter to this method if the BlockingQueue has space for it internally.,"(""BlockingQueue"", ""The method 'offer' belongs to the 'BlockingQueue' class as it is a BlockingQueue's method to add elements."", ""offer"")"
"If the BlockingQueue does not have space internally for this new element, the offer() method return false.","(""offer()"", ""The offer() method interacts with the BlockingQueue class by returning a value based on its state."", ""BlockingQueue"")"
The BlockingQueue offer() method exists in a version which takes a time out as parameter.,NULL
"This version of the offer() method will add the element passed as parameter if the BlockingQueue has space for it internally, or space becomes available.","(""Offer"", ""The method 'offer' operates within the context of the 'BlockingQueue' class, as it attempts to add an element to this type of queue if space is available."", ""BlockingQueue"")"
"If the BlockingQueue does not have or get space internally for this new element within the time out, this version of the offer() method returns false.",NULL
The BlockingQueue put() method inserts the element into the BlockingQueue if it has space for it internally.,"(""BlockingQueue"", ""The put method is a function of the BlockingQueue class, used for inserting elements."", ""put"")"
"If the BlockingQueue does not have space for the new element, the put() method will block the thread calling the put() method until the BlockingQueue as space internally for the new element.",NULL
The Java BlockingQueue take() method will remove the first element in the BlockingQueue.,"(""BlockingQueue"", ""The method 'take()' is a function that is called on the 'BlockingQueue' class to remove the first element."", ""take()""); (""BlockingQueue"", ""The method 'take()' is a function that is called on the 'BlockingQueue' class to remove the first element."", ""take()"")"
"If the BlockingQueue does not contain any elements, the take() method will block the thread calling take() until an element is inserted into the BlockingQueue.",NULL
The BlockingQueue poll() method will remove the first element in the BlockingQueue.,"(""BlockingQueue"", ""The poll() method is a function that operates on instances of the BlockingQueue class."", ""poll()"")"
"If the BlockingQueue does not contain any elements, the poll() method will return null.","(""poll()"", ""The poll() method operates on the BlockingQueue class, suggesting it is a method belonging to or interacting with it."", ""BlockingQueue""); (""poll()"", ""The poll() method operates on the BlockingQueue class, suggesting it is a method belonging to or interacting with it."", ""BlockingQueue"")"
"If the BlockingQueue does not contain any elements, this version of the poll() method will wait for an element to become available for the given amount of time passed to it as parameter.","(""BlockingQueue"", ""The method poll() is being used in the context of the BlockingQueue class, suggesting a functionality relationship between them."", ""poll()"")"
The remove() method will use the o.equals(element) to decide if the object o passed as parameter matches a given element in the BlockingQueue.,"(""Remove"", ""The remove() method is used to remove elements from the BlockingQueue class."", ""BlockingQueue""); (""Equals"", ""The equals() method is used within the remove() method to determine if the object matches an element."", ""Remove""); (""Equals"", ""The equals() method checks if the object o is equivalent to a given element."", ""Element""); (""Element"", ""The elements managed by BlockingQueue are being compared using the equals() method."", ""BlockingQueue"")"
"The remove() method will return true if an element was removed, and false if not.","(""Remove"", ""Method"")"
The BlockingQueue peek() method will return the first element of the BlockingQueue without removing it.,"(""BlockingQueue"", ""The peek() method operates on the BlockingQueue class, allowing it to retrieve the first element without removal."", ""peek()"")"
"If the BlockingQueue does not contain any elements, the peek() method will return null.","(""BlockingQueue"", ""The 'peek()' method is a function of the 'BlockingQueue' class as it describes an operation on instances of this class."", ""peek()""); (""BlockingQueue"", ""The 'peek()' method is a function of the 'BlockingQueue' class as it describes an operation on instances of this class."", ""peek()"")"
The BlockingQueue element() method will return the first element of the BlockingQueue without removing it.,NULL
"If the BlockingQueue does not contain any elements, the element() method will throw a NoSuchElementException.",NULL
The BlockingQueue contains(Object o) method will return true if the BlockingQueue contains an object matching the object passed as parameter to the contains() method.,"(""BlockingQueue"", ""The 'contains' method is a function that belongs to the 'BlockingQueue' class."", ""contains"")"
"The Objects.equals(o, element) statement is used to check if the parameter object o matches a given element in the BlockingQueue.","(""Objects"", ""The 'equals' method is part of the 'Objects' class; it is used to compare the object o with a given element."", ""equals""); (""BlockingQueue"", ""The element being checked is a part of the 'BlockingQueue' class, as the text refers to elements within a 'BlockingQueue'."", ""element"")"
The BlockingQueue size() method returns the number of elements stored in BlockingQueue.,"(""BlockingQueue"", ""The size method is part of the BlockingQueue class."", ""size"")"
The BlockingQueue remainingCapacity() method returns the remaining (unused) capacity of the BlockingQueue.,"(""BlockingQueue"", ""The method 'remainingCapacity' is a member or function of the class 'BlockingQueue'."", ""remainingCapacity"")"
"The Java Callable interface, java.util.concurrent.Callable, represents an asynchronous task which can be executed by a separate thread.","(""Callable"", ""The entity 'java.util.concurrent.Callable' is a specific representation or implementation of the more general 'Callable' class, indicating a relationship between the two."", ""java.util.concurrent.Callable"")"
The call() method is called in order to execute the asynchronous task.,"(""Call"", ""The call method is used to execute the asynchronous task"", ""Asynchronous Task"")"
The call() method can also thrown an Exception in case the task fails during execution.,NULL
The result of that is that the call() method will return a String.,NULL
The call() implementation just returns a String representation of the current time in milliseconds.,"(""Call"", ""The 'Call' method returns a 'String' representation."", ""String"")"
"A Java Callable is different from a Runnable in that the Runnable interface's run() method does not return a value, and it cannot throw checked exceptions (only RuntimeExceptions).",NULL
"Additionally, a Runnable was originally designed for long running concurrent execution, e.g.","(""Runnable"", ""class"")"
"Java 5 added a new Java package to the Java platform, the java.util.concurrent package.",NULL
This package contains a set of classes that makes it easier to develop concurrent (multithreaded) applications in Java.,NULL
"Before this package was added, you would have to program your utility classes yourself.",NULL
"In this tutorial I will take you through the new java.util.concurrent classes, one by one, so you can learn how to use them.","(""Java.util.concurrent"", ""The classes belong to the package java.util.concurrent, as they are part of the tutorial on this package."", ""Classes"")"
Here is a list of the topics covered in this java.util.concurrent trail.,"(""Java.util.concurrent"", ""package""); (""Java.util.concurrent"", ""package"")"
"If you disagree with anything I write here about the java.util.concurrent utilities, or just have comments, questions, etc, feel free to send me an email.",NULL
"The Java ExecutorService interface, java.util.concurrent.ExecutorService, represents an asynchronous execution mechanism which is capable of executing tasks concurrently in the background.",NULL
First an ExecutorService is created using the Executors newFixedThreadPool() factory method.,"(""Executors"", ""The newFixedThreadPool is a method provided by the Executors package to create an ExecutorService."", ""newFixedThreadPool"")"
"Second, an anonymous implementation of the Runnable interface is passed to the execute() method.","(""Runnable"", ""The Runnable class is being used as an argument to the execute method, indicating a relationship where Runnable is executed by the execute method."", ""execute"")"
"In fact, the implementation of the ExecutorService interface present in the java.util.concurrent package is a thread pool implementation.","(""ExecutorService"", ""ExecutorService is an interface that is implemented in the java.util.concurrent package, indicating a usage or containment relationship."", ""java.util.concurrent"")"
"However, you can use the Executors factory class to create ExecutorService instances too.","(""Executors"", ""Executors is a factory class used to create instances of the ExecutorService class."", ""ExecutorService"")"
"The Java ExecutorService execute(Runnable) method takes a java.lang.Runnable object, and executes it asynchronously.","(""ExecutorService"", ""The execute(Runnable) method is a method of the ExecutorService class."", ""execute(Runnable)""); (""execute(Runnable)"", ""The execute(Runnable) method takes a Runnable object as a parameter."", ""Runnable""); (""Runnable"", ""The Runnable class is part of the java.lang package."", ""java.lang"")"
The submit() method returns a Java Future object which can be used to check when the Runnable has completed.,NULL
"The invokeAny() method takes a collection of Callable objects, or subinterfaces of Callable.","(""Invokeany"", ""The invokeAny() method is related to the Callable class because it takes a collection of Callable objects as input."", ""Callable"")"
"If one Callable finishes, so that a result is returned from invokeAny(), then the rest of the Callable instances are cancelled.",NULL
The invokeAll() method invokes all of the Callable objects you pass to it in the collection passed as parameter.,"(""InvokeAll"", ""The InvokeAll method is used to invoke Callable objects as per the given description."", ""Callable"")"
The invokeAll() returns a list of Future objects via which you can obtain the results of the executions of each Callable.,NULL
The main difference between the Runnable run() method and the Callable call() method is that the call() method can return an Object from the method call.,NULL
"Another difference between call() and run() is that call() can throw an exception, whereas run() cannot (except for unchecked exceptions - subclasses of RuntimeException).","(""Call"", ""Call can throw an Exception."", ""Exception""); (""Run"", ""Run cannot throw an Exception, except for unchecked exceptions."", ""Exception""); (""Exception"", ""Unchecked exceptions are subclasses of RuntimeException."", ""RuntimeException"")"
You can cancel a task (Runnable or Callable) submitted to a Java ExecutorService by calling the cancel() method on the Future returned when the task is submitted.,"(""ExecutorService"", ""A task is submitted to an ExecutorService, which returns a Future object representing the result of the task execution."", ""Future""); (""Future"", ""The cancel() method is called on a Future object to cancel the task represented by the Future."", ""cancel"")"
Here is an example of cancelling a task by calling the Future.cancel() method:,"(""Future"", ""The method 'cancel' is associated with the 'Future' class as a way to perform the task of cancelling a Future task or operation."", ""cancel"")"
"If your application is started via a main() method and your main thread exits your application, the application will keep running if you have an active ExexutorService in your application.",NULL
To terminate the threads inside the ExecutorService you call its shutdown() method.,NULL
"All tasks submitted to the ExecutorService before shutdown() is called, are executed.","(""ExecutorService"", ""shutdown() is a method of the ExecutorService class"", ""shutdown()"")"
"If you want to shut down the ExecutorService immediately, you can call the shutdownNow() method.","(""ExecutorService"", ""The shutdownNow() method is used to immediately shut down the ExecutorService."", ""shutdownNow()"")"
"The ExecutorService awaitTermination() method will block the thread calling it until either the ExecutorService has shutdown completely, or until a given time out occurs.","(""ExecutorService"", ""The awaitTermination method is a part of the ExecutorService, indicating it operates on or is associated with this class."", ""awaitTermination"")"
The awaitTermination() method is typically called after calling shutdown() or shutdownNow().,"(""AwaitTermination()"", ""awaitTermination() is typically called after calling shutdown()"", ""Shutdown()""); (""AwaitTermination()"", ""awaitTermination() is typically called after calling shutdownNow()"", ""ShutdownNow()"")"
"The ForkJoinPool located in the java.util.concurrent package, so the full class name is java.util.concurrent.ForkJoinPool.","(""ForkJoinPool"", ""ForkJoinPool is a class located within the java.util.concurrent package."", ""java.util.concurrent"")"
These two types of tasks are represented by the RecursiveAction and RecursiveTask classes.,"(""RecursiveAction"", ""Both are classes representing types of tasks in the context"", ""RecursiveTask"")"
"If the workLoad is above a certain threshold, the work is split into subtasks which are also scheduled for execution (via the .fork() method of the subtasks.","(""fork()"", ""The fork() method is used to manage the splitting and execution of tasks within Workload."", ""Workload""); (""fork()"", ""The fork() method is used to manage the splitting and execution of tasks within Workload."", ""Workload"")"
The class MyRecursiveTask extends RecursiveTask<Long> which means that the result returned from the task is a Long .,"(""MyRecursiveTask"", ""MyRecursiveTask is a class that extends RecursiveTask, indicating an inheritance relationship where MyRecursiveTask is a subclass of RecursiveTask."", ""RecursiveTask""); (""RecursiveTask"", ""RecursiveTask is mentioned in the context of returning a Long result, suggesting a relationship where RecursiveTask operations return Long values."", ""Long"")"
"The MyRecursiveTask example also breaks the work down into subtasks, and schedules these subtasks for execution using their fork() method.",NULL
"Additionally, this example then receives the result returned by each subtask by calling the join() method of each subtask.","(""Join"", ""The join() method is applied to each subtask to receive the result returned by it."", ""Subtask"")"
Notice how you get the final result out from the ForkJoinPool.invoke() method call.,"(""ForkJoinPool"", ""The invoke() method is part of or called on the ForkJoinPool class"", ""invoke()""); (""ForkJoinPool"", ""The invoke() method is part of or called on the ForkJoinPool class"", ""invoke()"")"
"A Java Future, java.util.concurrent.Future, represents the result of an asynchronous computation.",NULL
"To obtain the result, you call one of the two get() methods on the Future.","(""Future"", ""The 'get()' method is called on an instance of the 'Future' class to obtain the result."", ""get()"")"
"The get() methods both return an Object, but the return type can also be a generic return type (meaning an object of a specific class, and not just an Object).","(""GET"", ""METHOD"")"
Here is an example of obtaining the result from a Java Future via its get() method:,"(""Future"", ""The get() method is a way to obtain results from a Future instance."", ""get"")"
"If you call the get() method before the asynchronous task has completed, the get() method will block until the result is ready.","(""Get"", ""The get() method is mentioned twice in the text as it is explaining the blocking behavior triggered by the method when called before the task has completed."", ""Get"")"
There is a version of the get() method which can time out after an amount of time has passed which you can specify via method parameters.,NULL
You can cancel the asynchronous task represented by a Java Future instance by calling the Future cancel() method.,"(""Future"", ""The method 'cancel' is used to stop the asynchronous task encapsulated by the 'Future' class."", ""cancel"")"
Here is an example of canceling a task via the Java Future cancel() method:,"(""Cancel"", ""The method 'cancel' is used with tasks that are represented by the 'Future' class."", ""Future""); (""Future"", ""The 'Future' class is part of the 'Java' package."", ""Java"")"
You can check if the asynchronous task is done (and a result available) by calling the Future isDone() method.,"(""Future"", ""The isDone method is a member of the Future class, providing functionality to check the completion status of asynchronous tasks."", ""isDone"")"
Here is an example of calling the Java Future isDone() method:,NULL
"The Java Lock interface, java.util.concurrent.locks.Lock, represents a concurrent lock which can be used to guard against race conditions inside critical sections.","(""Java Lock"", ""Java Lock is a representation of the class java.util.concurrent.locks.Lock"", ""java.util.concurrent.locks.Lock"")"
You must create an instance of a class that implements the Lock interface.,"(""class"", ""The class implements the Lock interface, implying a usage or implementation relationship between the class and Lock."", ""Lock""); (""class"", ""The class implements the Lock interface, implying a usage or implementation relationship between the class and Lock."", ""Lock""); (""class"", ""The class implements the Lock interface, implying a usage or implementation relationship between the class and Lock."", ""Lock"")"
The java.util.concurrent.locks package has the following implementations of the Lock interface:,"(""java.util.concurrent.locks"", ""The Lock interface is implemented within the java.util.concurrent.locks package."", ""Lock"")"
In the following sections I will explain how to use the ReentrantLock class as a Lock.,NULL
"To create an instance of the ReentrantLock class you simply use the new operator, like this:",NULL
To lock the Lock instance you must call its lock() method.,"(""Lock"", ""The lock() method is a function that locks the Lock class instance to ensure mutual exclusion."", ""lock()"")"
To unlock the Lock instance you must call its unlock() method.,"(""Lock"", ""The unlock method is associated with the Lock class."", ""unlock"")"
Any other thread calling lock() will be blocked until the thread that locked the lock calls unlock().,"(""Lock"", ""The lock method is associated with the Lock class, indicating that it is a function of this class."", ""Lock""); (""Lock"", ""The unlock method is associated with the Lock class, indicating that it is a function that releases or modifies the state of the Lock class."", ""Unlock"")"
"Finally unlock() is called, and the Lock is now unlocked so other threads can lock it.","(""Unlock"", ""The method unlock() interacts with the Lock class by unlocking it, allowing other threads to acquire the lock."", ""Lock""); (""Unlock"", ""The method unlock() interacts with the Lock class by unlocking it, allowing other threads to acquire the lock."", ""Lock"")"
"If you look at the example in the previous section, imagine what happens if an exception is thrown between the call to lock.lock() and lock.unlock() .","(""Lock"", ""These methods are part of a typical lock/unlock sequence, managing access to resources."", ""Unlock"")"
"The exception would interrupt the program flow, and the call to lock.unlock() would never be executed.","(""Exception"", ""The exception interrupts the program flow."", ""Program Flow""); (""Lock"", ""The method unlock() is called on the lock class."", ""Unlock"")"
"To better understand how using a Lock looks different from using a synchronized block, I have created two simple concurrent Counter classes which protects their internal count in different ways.","(""Lock"", ""Lock is used within the Counter class to ensure thread-safe operations on the internal count"", ""Counter"")"
"The first class uses a synchronized block, and the second class uses a Java Lock:","(""The first class"", ""The first class could be using Java Lock within its synchronized block."", ""Java Lock""); (""The second class"", ""The second class directly uses Java Lock for synchronization."", ""Java Lock"")"
Notice that the CounterLock class is longer than the CounterSynchronized class.,"(""CounterLock"", ""Both are class entities referenced in the sentence and compared in terms of length."", ""CounterSynchronized"")"
"Notice how the calculate() method both locks the Calculator instance's Lock before performing any calculations, and also call the add() and subtract() methods which also locks the lock.",NULL
The ReentrantLock class has a constructor that takes a boolean parameter specifying whether the ReentrantLock should provide fairness or not to waiting threads.,"(""ReentrantLock"", ""The ReentrantLock class has a constructor, indicating a relationship where the constructor is a member method of the class."", ""Constructor"")"
"Please note, that the method tryLock() (covered later in this Java Lock tutorial) with no parameters does not respect the fairness mode of the ReentrantLock.",NULL
"If the Lock instance is already locked, the thread calling lock() is blocked until the Lock is unlocked.","(""Lock"", ""The method lock() is called on an instance of the Lock class, indicating that lock() belongs to or operates on Lock."", ""lock()"")"
The lockInterruptibly() method locks the Lock unless the thread calling the method has been interrupted.,"(""LOCKINTERRUPTIBLY"", ""The LockInterruptibly method interacts with the Lock class as it locks the Lock unless interrupted."", ""LOCK"")"
"The tryLock(long timeout, TimeUnit timeUnit) works like the tryLock() method, except it waits up the given timeout before giving up trying to lock the Lock.","(""TryLock"", ""TryLock method attempts to acquire a lock on the Lock class."", ""Lock""); (""TryLock"", ""TryLock method uses the TimeUnit class to specify the timeout period."", ""TimeUnit"")"
The Java ReentrantLock getHoldCount() method returns the number of times a given thread has locked this Lock instance.,"(""getHoldCount"", ""The getHoldCount method is used to determine the number of times a thread has locked a Lock instance."", ""Lock""); (""ReentrantLock"", ""The ReentrantLock class provides a getHoldCount method to retrieve hold information."", ""getHoldCount"")"
The ReentrantLock getQueueLength() method returns the number of threads waiting to lock the Lock.,NULL
"The ReentrantLock hasQueuedThreads() method returns true if any threads are queued up waiting to lock this Lock, and false if not.",NULL
"The ReentrantLock isFair() method returns true if this Lock guarantees fairness among threads waiting to lock it, and false if not.","(""ReentrantLock"", ""The method isFair() is associated with the class ReentrantLock because it checks the fairness property related to the lock."", ""isFair""); (""ReentrantLock"", ""The method isFair() is associated with the class ReentrantLock because it checks the fairness property related to the lock."", ""isFair"")"
"The ReentrantLock isHeldByCurrentThread() method returns true if the Lock is held (locked) by the thread calling isHeldByCurrentThread(), and false if not.",NULL
"The ReentrantLock isLocked() method returns true if the Lock is currently locked, and false if not.","(""ReentrantLock"", ""The isLocked method belongs to the ReentrantLock class"", ""isLocked""); (""isLocked"", ""The isLocked method checks the state of the Lock class"", ""Lock"")"
"If no upper bound is specified, Integer.MAX_VALUE is used as the upper bound.",NULL
All elements inserted into the PriorityBlockingQueue must implement the java.lang.Comparable interface.,"(""PriorityBlockingQueue"", ""PriorityBlockingQueue requires its elements to implement the java.lang.Comparable interface to maintain priority order"", ""java.lang.Comparable"")"
Notice that the PriorityBlockingQueue does not enforce any specific behaviour for elements that have equal priority (compare() == 0).,"(""PriorityBlockingQueue"", ""class"")"
"The java.util.concurrent.ScheduledExecutorService is an ExecutorService which can schedule tasks to run after a delay, or to execute repeatedly with a fixed interval of time in between each execution.","(""ScheduledExecutorService"", ""ScheduledExecutorService is an implementation or specific type of ExecutorService"", ""ExecutorService""); (""ScheduledExecutorService"", ""ScheduledExecutorService is part of the package java.util.concurrent"", ""java.util.concurrent""); (""ScheduledExecutorService"", ""ScheduledExecutorService is an implementation or specific type of ExecutorService"", ""ExecutorService""); (""ScheduledExecutorService"", ""ScheduledExecutorService is part of the package java.util.concurrent"", ""java.util.concurrent"")"
Then an anonymous implementation of the Callable interface is created and passed to the schedule() method.,NULL
"Since ScheduledExecutorService is an interface, you will have to use its implementation in the java.util.concurrent package, in order to use it.","(""ScheduledExecutorService"", ""ScheduledExecutorService is implemented in the java.util.concurrent package."", ""java.util.concurrent"")"
"However, you can use the Executors factory class to create ScheduledExecutorService instances too.","(""Executors"", ""Executors is used to create instances of ScheduledExecutorService, indicating a utility or factory relationship."", ""ScheduledExecutorService""); (""Executors"", ""Executors is used to create instances of ScheduledExecutorService, indicating a utility or factory relationship."", ""ScheduledExecutorService"")"
"This method works like the method version taking a Callable as parameter, except a Runnable cannot return a value, so the ScheduledFuture.get() method returns null when the task is finished.",NULL
This method works very much like scheduleAtFixedRate() except that the period is interpreted differently.,"(""scheduleAtFixedRate"", ""method"")"
"In the scheduleAtFixedRate() method the period is interpreted as a delay between the start of the previous execution, until the start of the next execution.",NULL
You shut down a ScheduledExecutorService using the shutdown() or shutdownNow() methods which are inherited from the ExecutorService interface.,NULL
For each call to acquire() a permit is taken by the calling thread.,"(""Acquire"", ""The method acquire() is invoked by the calling thread to take a permit"", ""Calling Thread"")"
For each call to release() a permit is returned to the semaphore.,"(""Release"", ""The method 'release' returns a 'permit' to the semaphore."", ""Permit""); (""Permit"", ""A 'permit' is associated with the 'semaphore'."", ""Semaphore"")"
"Thus, at most N threads can pass the acquire() method without any release() calls, where N is the number of permits the semaphore was initialized with.","(""Acquire"", ""Acquire and Release are methods that relate to the process of managing permits in a semaphore."", ""Release""); (""Acquire"", ""Acquire is a method used within the Semaphore class to manage thread permits."", ""Semaphore""); (""Release"", ""Release is a method used within the Semaphore class to manage thread permits."", ""Semaphore"")"
"If you use a semaphore to send signals between threads, then you would typically have one thread call the acquire() method, and the other thread to call the release() method.","(""Semaphore"", ""The Acquire method is likely a part of the Semaphore class, used to signal that a resource is being acquired."", ""Acquire""); (""Semaphore"", ""The Release method is likely a part of the Semaphore class, used to signal that a resource is being released."", ""Release"")"
"If no permits are available, the acquire() call will block until a permit is released by another thread.",NULL
"Similarly, a release() calls is blocked if no more permits can be released into this semaphore.","(""Release"", ""The method 'release' is related to the class 'Semaphore' as it represents an action that interacts with the semaphore mechanism."", ""Semaphore"")"
"For instance, if acquire was called after Thread 1 had inserted an object in a shared list, and Thread 2 had called release() just before taking an object from that list, you had essentially created a blocking queue.",NULL
"That is, there is no guarantee that the first thread to call acquire() is also the first thread to obtain a permit.","(""Acquire()"", ""Method"")"
"If you want to enforce fairness, the Semaphore class has a constructor that takes a boolean telling if the semaphore should enforce fairness.","(""Semaphore"", ""The 'Constructor' is a method within the 'Semaphore' class to create its instances which can enforce fairness."", ""Constructor"")"
Calling this class a queue is a bit of an overstatement.,NULL
"However, unless you need to specify all these parameters explicitly for your ThreadPoolExecutor, it is often easier to use one of the factory methods in the java.util.concurrent.Executors class, as shown in the ExecutorService text.","(""java.util.concurrent.Executors"", ""The factory methods are part of the java.util.concurrent.Executors package."", ""Factory Methods""); (""Factory Methods"", ""Factory methods are used to create instances of the ThreadPoolExecutor class."", ""ThreadPoolExecutor""); (""ExecutorService"", ""Factory methods are mentioned in the context of the ExecutorService, indicating they are used to simplify certain operations with it."", ""Factory Methods"")"
"A Java Certificate class instance contains name plus other details of the entity it identifies, plus possibly a digital signature from a Certificate Authority (CA).","(""Certificate"", ""The Certificate class may include a digital signature, which is typically provided by a Certificate Authority."", ""Certificate Authority"")"
"The Java Certificate class is an abstract class, so while you may use Certificate as variable type, your variable will always point to a subclass of Certificate.","(""Certificate"", ""class""); (""Certificate"", ""class"")"
The Java Certificate class has one subclass - the X509Certificate class.,"(""Certificate"", ""The Certificate class is a superclass of the X509Certificate class"", ""X509Certificate"")"
This class represents an X.509 certificate which is used as identity certificate in HTTPS and TLS.,"(""This Class"", ""This Class represents an X.509 Certificate"", ""X.509 Certificate"")"
The Java Certificate getEncoded() method returns an encoded version of the Certificate as a byte array.,"(""Certificate"", ""The getEncoded method returns an encoded version of the Certificate."", ""getEncoded"")"
"For instance, if the Certificate is an X509Certificate the returned byte array will contain an X.590 (ASN.1 DER) encoded version of the Certificate instance.",NULL
The Java Certificate getPublicKey() method returns the PublicKey of this Certificate instance.,"(""Certificate"", ""The getPublicKey is a method of the Certificate class, used to retrieve the public key from a Certificate instance."", ""getPublicKey""); (""getPublicKey"", ""The getPublicKey method returns an instance of the PublicKey class, indicating a relationship between them."", ""PublicKey"")"
The Java Certificate getType() method returns the type of the Certificate instance.,NULL
The Java CertificateFactory class (java.security.cert.CertificateFactory) is capable of creating Java Certificate instances from binary certificate encodings like X.509 (ASN.1 DER).,NULL
"To read more about the Java Certificate class, see the Java Certificate tutorial.","(""Java Certificate"", ""The Java Certificate tutorial provides more information or instructions about the use of the Java Certificate class."", ""Java Certificate tutorial"")"
See the Java CertPath tutorial for more information about the CertPath class.,NULL
This example creates a CertificateFactory instance capable of creating X.509 certificate instances (X509Certificate - a subclass of Certificate).,"(""X509Certificate"", ""X509Certificate is a subclass of Certificate"", ""Certificate"")"
You create a CertPath instance by calling the CertificateFactory generateCertPath() method.,"(""CertificateFactory"", ""The generateCertPath is a method that belongs to the CertificateFactory class."", ""generateCertPath""); (""generateCertPath"", ""Calling the generateCertPath method results in the creation of a CertPath instance."", ""CertPath"")"
"The Java CertPath class (java.security.cert.CertPath represents a chain of cryptographic identity certificates (Java Certificate objects), where each certificate is the digital signer of the next certificate in the chain.","(""CertPath"", ""The CertPath class is part of the java.security.cert package."", ""java.security.cert""); (""CertPath"", ""The CertPath class is closely associated with its method representation."", ""CertPath"")"
The Java CertPath class is typically used to verify an identity certificate along with the certificates of the Certificate Authorities (CAs) that signed the certificate.,"(""CertPath"", ""The CertPath class is used to verify identity certificates along with those issued by Certificate Authorities."", ""Certificate Authorities"")"
Once you have a Java CertPath instance you can obtain the Certificate instances the CertPath consists of by calling the CertPath getCertificates() method.,NULL
The CertPath getType() method returns a string telling what type of certificates (e.g.,NULL
Here is an example of obtaining the CertPath type via getType():,NULL
That is why the Java class is called Cipher and not e.g.,"(""Cipher"", ""class"")"
This Java Cipher tutorial will explain how the Cipher class of the Java Cryptography API works.,"(""Cipher"", ""The Cipher class is part of the Java Cryptography API, indicating it belongs to or is implemented within this package."", ""Java Cryptography API""); (""Cipher"", ""The Cipher class is part of the Java Cryptography API, indicating it belongs to or is implemented within this package."", ""Java Cryptography API"")"
Before you can use a Java Cipher you just create an instance of the Cipher class.,NULL
You create a Cipher instance by calling its getInstance() method with a parameter telling what type of encryption algorithm you want to use.,NULL
There are several overridden versions of both update() and doFinal() which takes different parameters.,NULL
"If you have to encrypt or decrypt a single block of data, just call the doFinal() with the data to encrypt or decrypt.",NULL
"If you have to encrypt or decrypt multiple blocks of data, e.g.",NULL
"multiple blocks from a large file, you call the update() once for each block of data, and finish with a call to doFinal() with the last data block.",NULL
"The reason a call to doFinal() is needed for the last block of data is, that some encryption algorithms need to pad the the data to fit a certain cipher block size (e.g.","(""doFinal"", ""method""); (""doFinal"", ""method"")"
"Hence the calls to update() for intermediate blocks of data, and the call to doFinal() for the last block of data.",NULL
"When decrypting multiple blocks of data you also call the Cipher update() method for intermediate data blocks, and the doFinal() method for the last block.","(""Cipher"", ""The update() method is a function of the Cipher class used for processing intermediate data blocks."", ""update()""); (""Cipher"", ""The doFinal() method is a function of the Cipher class used to process the final block of data."", ""doFinal()"")"
The Java Cipher class encryption and decryption methods can encrypt or decrypt part of the data stored in a byte array.,"(""Cipher"", ""The Cipher class contains the encryption method, which suggests a functional relationship where the encryption method is part of the class."", ""encryption""); (""Cipher"", ""The Cipher class includes the decryption method, indicating a similar relationship where the decryption method is part of the class."", ""decryption"")"
You simply pass an offset and length to the update() and / or doFinal() method.,NULL
You can encrypt or decrypt data into an existing byte array by passing the destination byte array as parameter to the update() and / or doFinal() method.,"(""Update"", ""Both methods handle encryption or decryption operations."", ""DoFinal"")"
If you want to set a different offset for the dest byte array there is a version of update() and doFinal() which takes an offset parameter extra.,"(""Update"", ""Both methods have a version that takes an offset parameter as additional input for modifying a dest byte array."", ""DoFinal"")"
Here is an example of calling the doFinal() method with an offset into the dest array:,"(""doFinal"", ""method"")"
"When you call the doFinal() method on a Cipher instance, the Cipher instance is returned to the state it had just after initialization.","(""DoFinal"", ""DoFinal is a method that can be called on an instance of the Cipher class"", ""Cipher"")"
Notice the call to update() and then doFinal() for these two blocks of data.,NULL
This is done with the doFinal() call with the third data block.,"(""doFinal"", ""method"")"
After this doFinal() call you can encrypt yet another block of data with the same Java Cipher instance.,"(""DOFINAL"", ""The method doFinal() is a function that is called on the Cipher class to perform an encryption operation."", ""CIPHER""); (""CIPHER"", ""The Cipher class is part of the Java package, which provides cryptographic operations."", ""JAVA"")"
JCA is structured around some central general purpose classes and interfaces.,"(""JCA"", ""JCA encapsulates general purpose classes"", ""classes""); (""JCA"", ""JCA encapsulates general purpose interfaces"", ""interfaces"")"
"Thus, you may use a Cipher class to encrypt and decrypt some data, but the concrete cipher implementation (encryption algorithm) depends on the concrete provider used.",NULL
The most commonly used of these classes are covered throughout the rest of this Java Cryptography tutorial.,"(""Java Cryptography"", ""package""); (""Java Cryptography"", ""package"")"
The Provider (java.security.Provider) class is a central class in the Java cryptography API.,"(""Provider"", ""The 'Provider' class is a central part of the 'java.security.Provider' package."", ""java.security.Provider"")"
"The Cipher class is explained in more detail in the text on the Java Cipher class, but I will give a brief introduction to the Cipher class in the following sections.","(""Cipher"", ""The Cipher class is discussed in the context of the Java package, suggesting it is part of or related to Java."", ""Java"")"
"The Cipher.getInstance(...) method take a String identifying which encryption algorithm to use, as well as a few other configurations of the algorithm.","(""Cipher"", ""getInstance is a method of the Cipher class that facilitates obtaining a Cipher object based on the specified algorithm and configuration."", ""getInstance"")"
"To initialize a Cipher instance to decrypt data you have to use the Cipher.DECRYPT_MODE, like this:","(""Cipher"", ""The Cipher class uses the DECRYPT_MODE method to specify the operation mode for decrypting data."", ""DECRYPT_MODE"")"
You do so by calling the Cipher update() or doFinal() methods.,"(""Cipher"", ""The 'update' method is part of the 'Cipher' class, indicating a functional relationship where the method operates on or is utilized by the class."", ""update""); (""Cipher"", ""The 'doFinal' method is part of the 'Cipher' class, suggesting a functional relationship where the method interacts with or completes operations started by the class."", ""doFinal"")"
The update() method is used if you are encrypting or decrypting part of a bigger chunk of data.,NULL
"The doFinal() method is called when you are encrypting the last part of the big chunk of data, or if the block you pass to doFinal() represents the complete data block to encrypt.",NULL
Here is an example of encrypting some data with the doFinal() method,NULL
To decrypt data you would have passed cipher text (encrypted data) into the doFinal() or doUpdate() method instead.,"(""DOFINAL"", ""Both DOFINAL and DOUPDATE are methods involved in processing encrypted data for decryption"", ""DOUPDATE"")"
"The example in the previous section about the Cipher class used a very simple, hardcoded key.","(""Cipher"", ""class"")"
You can use the Java KeyGenerator class to generate more random encryption keys.,"(""KeyGenerator"", ""KeyGenerator belongs to the Java language or standard library"", ""Java"")"
"The resulting SecretKey instance can be passed to the Cipher.init() method, like this:","(""SecretKey"", ""SecretKey is used as an argument for Cipher.init()"", ""Cipher.init()""); (""SecretKey"", ""SecretKey is used as an argument for Cipher.init()"", ""Cipher.init()"")"
To generate an asymmetric key pair you can use the KeyPairGenerator (java.security.KeyPairGenerator).,"(""KeyPairGenerator"", ""KeyPairGenerator is specified as a class within the java.security package."", ""java.security.KeyPairGenerator"")"
The KeyStore class is quite advanced so it is described in more detail in its own Java KeyStore Tutorial.,NULL
You can use the Java MessageDigest (java.security.MessageDigest) to calculate message digests.,"(""java.security.MessageDigest"", ""The MessageDigest class is part of the java.security package."", ""MessageDigest""); (""java.security.MessageDigest"", ""The MessageDigest class is part of the java.security package."", ""MessageDigest""); (""java.security.MessageDigest"", ""The MessageDigest class is part of the java.security package."", ""MessageDigest"")"
In order to calculate a message digest of some data you call the update() or digest() method.,"(""Update"", ""Both update() and digest() are methods mentioned as callable for calculating a message digest."", ""Digest"")"
"The update() method can be called multiple times, and the message digest is updated internally.","(""Update"", ""The 'update' method updates the message digest internally."", ""Message Digest""); (""Update"", ""The 'update' method updates the message digest internally."", ""Message Digest""); (""Update"", ""The 'update' method updates the message digest internally."", ""Message Digest"")"
"When you have passed all the data you want to include in the message digest, you call digest() and get the resulting message digest data out.","(""Digest"", ""Digest is called as part of the Message class to get the resulting message digest data"", ""Message"")"
Here is an example of calling update() several times followed by a digest() call:,"(""Update"", ""The text describes calling `update()` several times followed by a call to `digest()`, indicating a sequence of operations where `update()` prepares data that `digest()` processes."", ""Digest"")"
You can also call digest() a single time passing all the data to calculate the message digest from.,NULL
The Java Mac class is used to create a MAC from a message.,"(""Mac"", ""The Mac class is part of the Java package contextually."", ""Java"")"
"The Mac class is described in more detail in the Java Mac tutorial, but below is a short introduction.","(""Mac"", ""The Mac class is taught or referenced within the context of the Java package in the tutorial."", ""Java"")"
"You create a Java Mac instance by calling the Mac.getInstance() method, passing as parameter the name of the algorithm to use.","(""Mac"", ""The method getInstance is used to create an instance of the Mac class."", ""getInstance"")"
Once the Mac instance is initialized you can calculate a MAC from data by calling the update() and doFinal() method.,"(""Mac"", ""update is a method that belongs to the Mac class and is used to calculate a MAC from data."", ""update""); (""Mac"", ""doFinal is a method that belongs to the Mac class and is used to finalize the MAC calculation from data."", ""doFinal"")"
"If you have all the data to calculate the MAC for, you can call the doFinal() method immediately.","(""doFinal()"", ""method"")"
"If you only have the access to the data in separate blocks, call update() multiple times with the data, and finish off with a call to doFinal().","(""Update"", ""The method `update()` is called multiple times to process data in blocks, and `doFinal()` is called to finalize the process, indicating a sequence in using these methods."", ""DoFinal""); (""Update"", ""The method `update()` is called multiple times to process data in blocks, and `doFinal()` is called to finalize the process, indicating a sequence in using these methods."", ""DoFinal"")"
You do so by calling the initSign(...) method passing the private key to use to sign the data.,NULL
You do so by calling update() passing the data to sign as parameter.,"(""update"", ""The method 'update' receives 'parameter' as its input."", ""parameter"")"
You can call the update() method several times with more data to include when creating the signature.,NULL
When all the data has been passed to the update() method you call the sign() method to obtain the digital signature.,"(""Update"", ""The 'Sign' method is called after the 'Update' method to obtain the digital signature, indicating a sequential process."", ""Sign"")"
This is done by calling the initVerify(...) method passing as parameter the public key to use to verify the signature.,"(""Initverify"", ""Method""); (""Initverify"", ""Method"")"
"Once initialized into verification mode, you call the update() method with the data the signature is signing, and finish with a call to verify() which returns true or false depending on whether the signature could be verified or not.","(""Update"", ""The update method is called with the data, and the process finishes with a call to verify to determine if the signature is verified or not."", ""Verify"")"
Here is a full example of both creating and verifying a digital signature with the Signature class:,"(""Signature"", ""class""); (""Signature"", ""class"")"
The Java KeyGenerator class (javax.crypto.KeyGenerator) is used to generate symmetric encryption keys.,NULL
Before you can use the Java KeyGenerator class you must create a KeyGenerator instance.,"(""Java KeyGenerator"", ""To use a KeyGenerator instance, a Java KeyGenerator class must be instantiated."", ""KeyGenerator instance""); (""Java KeyGenerator"", ""To use a KeyGenerator instance, a Java KeyGenerator class must be instantiated."", ""KeyGenerator instance"")"
You create a KeyGenerator instance by calling the static method getInstance() passing as parameter the name of the encryption algorithm to create a key for.,NULL
Initializing a KeyGenerator instance is done by calling its init() method.,"(""KeyGenerator"", ""The init() method is associated with initializing an instance of the KeyGenerator class"", ""init""); (""KeyGenerator"", ""The init() method is associated with initializing an instance of the KeyGenerator class"", ""init"")"
"The KeyGenerator init() method takes two parameters: The bit size of the keys to generate, and a SecureRandom that is used during key generation.","(""KeyGenerator"", ""The init() method is part of the KeyGenerator class as it describes functionality specific to it"", ""init()""); (""init()"", ""The init() method takes SecureRandom as a parameter, indicating a usage relationship"", ""SecureRandom"")"
Generating a key is done by calling the KeyGenerator generateKey() method.,"(""KeyGenerator"", ""The generateKey() method is a member of the KeyGenerator class"", ""generateKey()"")"
You can access the PublicKey of a KeyPair by calling its getPublic() method.,"(""KeyPair"", ""The getPublic method is called on the KeyPair to access the public key."", ""getPublic""); (""PublicKey"", ""The getPublic method returns an instance of the PublicKey class."", ""getPublic"")"
You can access the PrivateKey of a KeyPair by calling the getPrivate() method.,"(""getPrivate"", ""The method getPrivate is used to access the PrivateKey of a KeyPair."", ""PrivateKey""); (""PrivateKey"", ""PrivateKey is a part of a KeyPair that can be accessed using the getPrivate method."", ""KeyPair"")"
The Java KeyPairGenerator class (java.security.KeyPairGenerator) is used to generate asymmetric encryption / decryption key pairs.,NULL
Creating a KeyPairGenerator instance is done by calling the method getInstance() method.,"(""KeyPairGenerator"", ""Creating an instance of the class 'KeyPairGenerator' is done by calling the 'getInstance' method."", ""getInstance"")"
The getInstance() method takes the name of the encryption algorithm to generate the key pair for.,"(""getInstance"", ""method"")"
To generate a KeyPair with a KeyPairGenerator you call the generateKeyPair() method.,NULL
This makes the KeyStore class a useful mechanism to handle encryption keys securely.,NULL
You can create a Java KeyStore instance by calling its getInstance() method.,NULL
It is also possible to create other types of KeyStore instance by passing a different parameter to the getInstance() method.,NULL
That is why the KeyStore class assumes that you must read its data in before you can use it.,NULL
Loading the KeyStore data from a file or other storage is done by calling the KeyStore load() method.,"(""KeyStore"", ""The load() method is called to perform an action on the KeyStore class, indicating an association where the method belongs to or operates on the class"", ""load"")"
This example loads the KeyStore file located in the keystore.ks file.,"(""KeyStore"", ""class"")"
You can get the keys of a Java KeyStore instance via its getEntry() method.,NULL
"Thus, to access a key you must pass the key alias and password to the getEntry() method.","(""Getentry"", ""The getEntry method is typically accessed through its package."", ""Package"")"
"If you know that the key entry you want to access is a private key, you can cast the KeyStore.Entry instance to a KeyStore.PrivateKeyEntry.",NULL
"After casting to a KeyStore.PrivateKeyEntry you can access the private key, certificate and certificate chain via these methods:","(""KeyStore.PrivateKeyEntry"", ""The private key is accessed via methods within the KeyStore.PrivateKeyEntry class."", ""private key""); (""KeyStore.PrivateKeyEntry"", ""The certificate is accessed via methods within the KeyStore.PrivateKeyEntry class."", ""certificate""); (""KeyStore.PrivateKeyEntry"", ""The certificate chain is accessed via methods within the KeyStore.PrivateKeyEntry class."", ""certificate chain"")"
"Sometimes you may want to store a KeyStore to some storage (disk, database etc.)","(""KeyStore"", ""KeyStore is related to storage as it is stated to be stored in it"", ""storage"")"
"To execute it, open a command line (cmd, console, shell etc.).",NULL
This Keytool -delete command will remove the KeyStore entry with the alias testkey from the KeyStore stored in the file keystore.jks .,"(""Keytool"", ""The 'delete' method is a command used with the Keytool to perform operations."", ""delete""); (""Keytool"", ""Keytool operates on the KeyStore to perform actions like deletions."", ""KeyStore""); (""delete"", ""The 'delete' method targets entries within the KeyStore for removal."", ""KeyStore""); (""KeyStore"", ""The KeyStore is stored in the keystore.jks file."", ""keystore.jks"")"
"Once generated, the certificate request should be sent to the CA you want to create a certificate for you (e.g.",NULL
"This command will generate a certificate request for the key stored with alias testkey in the keystore file keystore.jks, and write the certificate request into the file named certreq.certreq .","(""Keystore"", ""Keystore stores the certificate request"", ""Certificate"")"
The Java Mac (javax.crypto.Mac class can create a Message Authentication Code (MAC) from binary data.,"(""javax.crypto.Mac"", ""javax.crypto.Mac is used to create a Message Authentication Code (MAC)."", ""Message Authentication Code (MAC)"")"
Before you can use the Java Mac class you must create a Mac instance.,NULL
The String parameter passed to the Mac getInstance() method contains the name of the MAC algorithm to use.,NULL
You initialize the Mac instance by calling its init() method passing as parameter the secret key to be used by the Mac instance.,"(""Mac"", ""The init() method is a function associated with the Mac class, used to initialize it with a secret key."", ""init"")"
To calculate a MAC value you call the Mac update() or doFinal() method.,"(""Mac"", ""The update() method is a part of the Mac class."", ""update()""); (""Mac"", ""The doFinal() method is a part of the Mac class."", ""doFinal()"")"
"If you only have a single block of data to calculate the MAC for, you can call doFinal() directly, like this:","(""DoFinal"", ""Method"")"
"If you have multiple blocks of data to calculate the MAC for, e.g.",NULL
"if you are reading a file block by block, then you must call the update() method with each block, and finish with a call to doFinal().",NULL
The Java MessageDigest class represents a cryptographic hash function which can calculate a message digest from binary data.,NULL
This tutorial only explains how to use the Java Cryptography API representation of a message digest in the MessageDigest class.,"(""MessageDigest"", ""class"")"
To create a Java MessageDigest instance you call the static getInstance() method of the MessageDigest class.,"(""getInstance"", ""The getInstance method is associated with the MessageDigest class as it is a static method used to create an instance of the class."", ""MessageDigest"")"
The text parameter passed to the getInstance() method is the name of the concrete message digest algorithm to use.,NULL
"If you have a single block of data to calculate a message digest from, use the digest() method.",NULL
"If you have multiple blocks of data to include in the same message digest, call the update() method and finish off with a call to digest().",NULL
The Java Signature class (java.security.Signature) can create a digital signature for binary data.,"(""Signature"", ""The class 'Signature' belongs to the package 'java.security.Signature'"", ""java.security.Signature"")"
Before you can use the Java Signature class you must create a Signature instance.,NULL
You create a Signature instance by calling the static getInstance() method.,"(""getInstance"", ""The getInstance() method is called to create an instance of the Signature class."", ""Signature"")"
The String passed as parameter to the getInstance() method is the name of the digital signature algorithm to use.,NULL
"You create a digital signature by calling the update() method one or more times, finishing with a call to sign().",NULL
Therefore I have put together this little trail on Java's date and time classes.,"(""Java"", ""package""); (""date and time"", ""class"")"
Hopefully that will help you get an overview of Java's date and time classes.,"(""Java"", ""Date is a class within the Java package, particularly related to date manipulation."", ""Date""); (""Java"", ""Time is a class within the Java package, used for time manipulation."", ""Time"")"
I also hope it may clear up some of the confusion Sun has created with Java's many date and time classes.,"(""Java"", ""The date class is a part of the Java package or programming environment."", ""date""); (""Java"", ""The time class is a part of the Java package or programming environment."", ""time""); (""Sun"", ""Sun, as a company, is associated with the creation and distribution of Java."", ""Java"")"
"Actually, the Java date time API has been changed (cleaned up) in Java 8 with the introduction of a whole new set of classes.","(""Classes"", ""class"")"
The new Java date time API is located in the Java package java.time which is part of the standard Java 8 class library.,"(""Java date time API"", ""The Java date time API is part of the Java package java.time."", ""java.time""); (""java.time"", ""The java.time package is part of the Java 8 class library."", ""Java 8"")"
You will see this new date and time representation in many of the classes in the new Java date time API.,"(""Java date time API"", ""The Java date time API contains many classes for date and time representation"", ""Class"")"
The java.time package also contains a set of subpackages which contain more utilities etc.,"(""Java.time"", ""Package"")"
"For instance the java.time.chrono contains classes to work with Japanese, Thai, Taiwanese and Islamic calendars.",NULL
The java.time.format package contains classes used to parse and format dates from and to strings.,NULL
The core of the Java 8 date time API consists of the following classes:,NULL
Java 7 has the following date and time classes and methods.,NULL
"Each of these classes are also explained in their own pages, later.","(""Classes"", ""class""); (""Classes"", ""class"")"
If you need to do simple timing the System.currentTimeMillis() method will do just fine.,"(""System"", ""The method currentTimeMillis is a static method of the System class."", ""currentTimeMillis"")"
"If you just need an object to hold a date, for instance as a property in a simple domain model object, you can use the java.util.Date class.",NULL
"If you need to read and write the date and time to a database, use the java.sql.Date and java.sql.Timestamp classes.","(""Java.sql.Date"", ""Both are classes used for handling date and time in databases, suggesting they serve related functionality."", ""Java.sql.Timestamp"")"
"If you need to do date calculations like adding days or months to another date, or check what weekday (monday, tuesday etc.)",NULL
"a given date is, or convert dates and times between time zones, use the java.util.Calendar and java.util.GregorianCalendar classes.","(""Calendar"", ""GregorianCalendar is a specific implementation of Calendar, used for manipulating dates and times."", ""GregorianCalendar"")"
The Java DateTimeFormatter class is used to parse and format dates represented with the classes in the Java 8 date time API.,"(""Java DateTimeFormatter"", ""Java DateTimeFormatter is part of the Java 8 date time API, which provides classes and utilities for handling date and time."", ""Java 8 date time API"")"
The DateTimeFormatter is located in the java.time.format package so the fully qualified class name is java.time.format.DateTimeFormatter.,NULL
The DateTimeFormatter class contains a set of predefined (constant) instances which can parse and format dates from standard date formats.,"(""DateTimeFormatter"", ""The DateTimeFormatter class can use the parse method to interpret dates from standard date formats."", ""parse""); (""DateTimeFormatter"", ""The DateTimeFormatter class uses the format method to apply formatting to dates based on predefined instances."", ""format"")"
You can read about them in the JavaDoc for the DateTimeFormatter class.,"(""JavaDoc"", ""JavaDoc provides documentation for the DateTimeFormatter class"", ""DateTimeFormatter"")"
Once you have an instance of a DateTimeFormatter you can format a date using its format() method.,NULL
A Duration object (java.time.Duration) represents a period of time between two Instant objects.,"(""Duration"", ""Duration represents the time period between two Instant objects."", ""Instant""); (""Duration"", ""Duration is part of the java.time package."", ""java.time"")"
The Duration class was added to the Java date time API from Java 8.,"(""Duration"", ""The Duration class is part of the Java date time API."", ""Java"")"
Creating a Duration object is done using one of the Duration class factory methods.,"(""Duration"", ""The Duration class is used to create a Duration object."", ""Duration object""); (""Duration"", ""The Duration class has factory methods to create Duration objects."", ""factory methods"")"
Here is an example of how to create a Duration object using the between() method:,NULL
This is somewhat different from what we are used to with System.getCurrentTimeMillis() where a moment in time (or a period between two moments) is represented as a number of milliseconds.,"(""System.getCurrentTimeMillis"", ""method"")"
The toNanos() is different from the getNano() in that the getNano() only returns the part of the Duration which is less than one second.,"(""TONANOS"", ""Both methods are related as they deal with nanoseconds in the context of time measurement."", ""GETNANO""); (""GETNANO"", ""The getNano() method is part of the Duration class."", ""DURATION""); (""TONANOS"", ""The toNanos() method is conceptually connected to the Duration class as it likely converts time to nanoseconds."", ""DURATION"")"
The toNanos() method returns the full time interval converted to nanoseconds.,NULL
You might be asking yourself if there is not a toSeconds() method.,"(""toSeconds"", ""method"")"
You can obtain the seconds part of the Duration using the getSeconds() method as explained earlier.,"(""getSeconds"", ""The getSeconds method accesses or manipulates the Duration class to obtain the seconds part."", ""Duration"")"
The Duration class contains a set of methods you can use to perform calculations based on a Duration object.,"(""Duration"", ""The Duration class contains a set of methods."", ""methods""); (""methods"", ""The methods perform calculations based on a Duration object."", ""Duration"")"
The Instant class in the Java date time API (java.time.Instant) represents a specific moment on the time line.,"(""Instant"", ""The Instant class is a part of the Java package as it is referred to in the context of the Java date time API."", ""Java"")"
"Time is measured using 86.400 seconds per day, moving forward from the origin.",NULL
You create an Instant instance using one of the Instant class factory methods.,"(""create"", ""The 'create' method is used to instantiate the Instant class."", ""Instant""); (""factory"", ""Factory methods are specific methods used to create instances of the Instant class."", ""Instant"")"
"For instance, to create an Instant which represents this exact moment of now, call Instant.now(), like this:","(""Instant"", ""The 'now' method is called on the 'Instant' class to create an instance representing the current moment."", ""now"")"
The Instant class also has several methods which can be used to make calculations relative to an Instant.,NULL
The LocalDate class in the Java 8 date time API represents a local date which is a date without time zone information.,"(""LocalDate"", ""The LocalDate class is part of the Java package, as it is mentioned with respect to the Java 8 date time API which suggests it belongs to the Java framework."", ""Java""); (""LocalDate"", ""The LocalDate class is part of the Java package, as it is mentioned with respect to the Java 8 date time API which suggests it belongs to the Java framework."", ""Java"")"
"The LocalDate Java class is located in the java.time package, so its fully qualified class name is java.time.LocalDate.",NULL
Here is an example of creating a LocalDate using the now() method:,"(""LocalDate"", ""The entity 'now()' is a method used to instantiate or retrieve the current date as a LocalDate object."", ""now()"")"
"The LocalDate's of() method creates a LocalDate instance representing a specific day of a specific month of a specific year, but without time zone information.","(""of"", ""The 'of()' method is associated with the 'LocalDate' class as it creates an instance of it."", ""LocalDate"")"
Notice how the getMonth() and getDayOfWeek() methods return an enum instead of an int.,"(""GetMonth"", ""Both GetMonth and GetDayOfWeek are methods that return an enum instead of an int."", ""GetDayOfWeek"")"
From these enums you can obtain their information as int values by calling their getValue() methods.,"(""GetValue"", ""The method getValue() is used to obtain their information as int values."", ""Int Values"")"
You can perform a set of simple date calculations with the LocalDate class using one or more of the following methods:,NULL
The LocalDateTime class in the Java 8 date time API (java.time.LocalDateTime) represents a local date and time without any time zone information.,NULL
You could view the LocalDateTime as a combination of the LocalDate and LocalTime classes of the Java 8 date time API.,NULL
Here is an example that shows how to create a LocalDateTime object via the now() method:,"(""LocalDateTime"", ""The now() method is used to create instances of the LocalDateTime class."", ""now"")"
"The parameters to the of() method are year, month, day (of month), hours, minutes, seconds and nanoseconds.","(""OF"", ""The text explicitly mentions the 'of' method."", ""METHOD"")"
Via the methods that return an enum you can get an int representation of the enum by calling the getValue() of the enum .,"(""METHOD"", ""The text suggests that the method could be using the getValue() function to obtain an int representation of the enum."", ""GETVALUE"")"
The LocalTime class in the Java 8 date time API represents a specific time of day without any time zone information.,"(""LocalTime"", ""LocalTime is a class within the Java 8 date time API package"", ""Java 8 date time API"")"
"The LocalTime class is immutable, so all calculations on LocalTime objects return a new LocalTime instance.","(""LocalTime"", ""LocalTime is a type of class that is used as a reference for objects of its type."", ""LocalTime objects""); (""LocalTime objects"", ""LocalTime objects return a new LocalTime instance when calculations are performed on them."", ""LocalTime instance"")"
"There are also other versions of the of() method that only takes hours and minutes, or hours, minutes and seconds as parameters.",NULL
The LocalTime class contains a set of methods that enable you to perform local time calculations.,"(""LocalTime"", ""LocalTime class contains a set of methods for local time calculations"", ""methods"")"
The static method System.currentTimeMillis() returns the time since January 1st 1970 in milliseconds.,NULL
"The returned long value can be used to initialize java.util.Date, java.sql.Date, java.sql.Timestamp and java.util.GregorianCalendar objects.","(""Java.sql.Date"", ""Both classes can be initialized with a long value and are part of the Java API dealing with date and time."", ""Java.util.Date""); (""Java.sql.Timestamp"", ""Both are SQL-related date-time classes in Java and can be initialized with a long value."", ""Java.sql.Date""); (""Java.util.GregorianCalendar"", ""Both are part of the java.util package and can be initialized with a long value."", ""Java.util.Date"")"
The granularity of the System.currentTimeMillis() method is larger than 1 millisecond.,"(""System.currentTimeMillis()"", ""method""); (""System.currentTimeMillis()"", ""method"")"
Measuring time in Java is easiest to do with the System.currentTimeMillis() method.,"(""System"", ""currentTimeMillis is a method of the System class"", ""currentTimeMillis""); (""System"", ""System is a class in the Java package"", ""Java"")"
The variable totalTime will now contain the total time it took to execute the callOperationToTime() method.,"(""CallOperationToTime"", ""method""); (""CallOperationToTime"", ""method"")"
"Because System.currentTimeMillis() does not return the time that accurately, it is a good idea to execute the operation to measure more than once.",NULL
"Another good reason to repeat the operation to measure a lot of times is to allow the Java virtual machine to load the classes containing the code, JIT-compile it, and perhaps even optimize it.","(""Java Virtual Machine"", ""The Java Virtual Machine runs the code as it executes Java applications."", ""Code""); (""Java Virtual Machine"", ""JIT-compilation is a technique used by the Java Virtual Machine to improve performance by compiling bytecode into native machine code."", ""JIT-compile"")"
"The calculations listed earlier in this text are rather trivial yet tedious to do, and could be encapsulated in a Timer class.","(""Timer"", ""class"")"
The ZonedDateTime class in the Java 8 date time API represents a date and time with time zone information.,"(""ZonedDateTime"", ""The ZonedDateTime class is a part of the Java 8 date time API."", ""Java 8 date time API""); (""ZonedDateTime"", ""The ZonedDateTime class is a part of the Java 8 date time API."", ""Java 8 date time API"")"
The first way is to call the now() method of the ZonedDateTime class.,"(""now"", ""The method now() is used within the class ZonedDateTime to retrieve the current date and time."", ""ZonedDateTime"")"
Here is an example of creating a ZonedDateTime object using the now() method:,NULL
Another way to create a ZonedDateTime object is to use the of() method which can create a ZonedDateTime object from a concrete date and time.,NULL
Here is an example of creating a ZonedDateTime object using the of() method:,NULL
From the enums you can return an int representation of their value using their getValue() methods.,"(""ENUM"", ""The ENUM class has a method called GETVALUE to retrieve its value."", ""GETVALUE""); (""ENUM"", ""ENUM can be represented as an INT, indicating a relationship between these classes."", ""INT"")"
The ZonedDateTime class contains a set of methods used for date time calculations.,NULL
The time zones are represented by the ZoneId class as shown in the earlier example.,"(""ZoneId"", ""ZoneId class is used to represent time zones"", ""time zones"")"
The parameter passed to the of() method is the ID of the time zone to create a ZoneId for.,"(""Of"", ""The 'of' method is used to create a ZoneId instance by accepting a time zone ID as its parameter."", ""Zoneid"")"
"You can find the UTC offset for the desired time zone and create an ID matching it by combining ""UTC"" with the offset (e.g.",NULL
"If you need to set a date on a java.sql.PreparedStatement or get a date from a java.sql.ResultSet, you will interact with java.sql.Date.","(""PreparedStatement"", ""PreparedStatement can set a date using the Date class."", ""Date""); (""ResultSet"", ""ResultSet can retrieve a date using the Date class."", ""Date""); (""PreparedStatement"", ""PreparedStatement is contained within the java.sql package."", ""java.sql""); (""ResultSet"", ""ResultSet is contained within the java.sql package."", ""java.sql""); (""Date"", ""Date is contained within the java.sql package."", ""java.sql"")"
"Actually, java.sql.Date extends java.util.Date, so anything you can do with a java.util.Date you can also do with a java.sql.Date.","(""Java.sql.Date"", ""Java.sql.Date extends Java.util.Date, indicating an inheritance relationship where Java.sql.Date is a subclass of Java.util.Date."", ""Java.util.Date"")"
"The biggest difference between java.sql.Date and java.util.Date is that the java.sql.Date only keeps the date, not the time, of the date it represents.","(""Java.sql.Date"", ""Java.sql.Date is a class within the Java.sql package"", ""Java.sql""); (""Java.util.Date"", ""Java.util.Date is a class within the Java.util package"", ""Java.util"")"
"So, for instance, if you create a java.sql.Date using the date and time 2009-12-24 23:20, then the time (23:20) would be cut off.",NULL
"If you need to keep the time, use a java.sql.Timestamp instead.",NULL
"If you need to set a date + time on a java.sql.PreparedStatement or get a date + time from a java.sql.ResultSet, you will interact with java.sql.Timestamp.",NULL
"Actually, java.sql.Timestamp extends java.util.Date, so anything you can do with a java.util.Date you can also do with a java.sql.Timestamp.","(""Java.sql.Timestamp"", ""Java.sql.Timestamp is related to Java.util.Date because it extends it, indicating an inheritance relationship."", ""Java.util.Date""); (""Java.sql.Timestamp"", ""Java.sql.Timestamp is related to Java.util.Date because it extends it, indicating an inheritance relationship."", ""Java.util.Date"")"
"The biggest difference between java.sql.Date and java.sql.Timestamp is that the java.sql.Date only keeps the date, not the time, of the date it represents.","(""Java.sql.Date"", ""Java.sql.Date and Java.sql.Timestamp are related because they are both classes used to handle date and time in SQL-related packages."", ""Java.sql.Timestamp"")"
One difference in the java.sql.Timestamp from its superclass java.util.Date is its ability to hold the nanoseconds of a date too.,NULL
You can get and set the nanoseconds using the getNanos() and setNanos().,NULL
Java's java.util.Calendar class is used to do date and time arithmetic.,"(""Java.Util.Calendar"", ""The Calendar class is used to perform date arithmetic."", ""Date""); (""Java.Util.Calendar"", ""The Calendar class is used to perform time arithmetic."", ""Time"")"
"Whenever you have something slightly more advanced than just representing a date and time, this is the class to use.",NULL
"Java only comes with a Gregorian calendar implementation, the java.util.GregorianCalendar class.","(""java.util"", ""The GregorianCalendar class is part of the java.util package as per the Java API conventions."", ""GregorianCalendar"")"
"The Calendar class has a couple of methods you can use to access the year, month, day, hour, minutes, seconds, milliseconds and time zone of a given date.",NULL
The Calendar class has a corresponding set() method so you can set these fields too.,NULL
"The add() method is really handy when doing date arithmetics like adding or subtracting years, months, days, hours etc.","(""Add"", ""method""); (""Add"", ""method"")"
"To subtract from the fields call the add() method with negative values, like this:","(""Add"", ""The 'add' method is used to modify the fields by subtracting values."", ""Fields"")"
There are a few minor traps in the Calendar class that you should be aware of to avoid unnecessary headaches.,"(""Calendar"", ""class"")"
The MONTH field of the Calendar class does not go from 1 to 12 like they do when we write dates otherwise.,NULL
"That means that 1 = sunday, 2 = monday, ..., 7 = saturday.",NULL
If you need to do heavy or complex date and time calculations it is a good idea to read the class documentation for java.util.Calendar in the official JavaDoc's.,NULL
The class documentation contains more detail about the specific behaviour of the class.,"(""Class"", ""The class is mentioned twice with reference to its documentation and behavior."", ""Class"")"
Today most of the methods in the class are deprecated in favor of the java.util.Calendar class.,"(""Methods"", ""Most of the methods belong to the class that they are part of."", ""Class""); (""Java.util.Calendar"", ""The java.util.Calendar class is mentioned as the preferred alternative to the current class methods."", ""Class"")"
You can still use the java.util.Date class to represent a date though.,"(""java.util"", ""The Date class is part of the java.util package, indicating an 'is-a-part-of' relationship."", ""Date""); (""java.util"", ""The Date class is part of the java.util package, indicating an 'is-a-part-of' relationship."", ""Date"")"
"You can access the date and time contained in a java.util.Date instance using the getTime() method, like this:",NULL
"You can also create a java.util.Date from a time in milliseconds, like this:","(""Java.util.Date"", ""class""); (""Java.util.Date"", ""class"")"
You can compare java.util.Date instance because the class implements the java.lang.Comparable interface.,"(""Java.Util.Date"", ""Java.Util.Date is related to Java.Lang.Comparable because it implements the Java.Lang.Comparable interface."", ""Java.Lang.Comparable"")"
"The comparison follows the rules for the Comparable interface, meaning the compareTo() method returns:","(""compareTo"", ""The compareTo() method is a rule-following method of the Comparable interface"", ""Comparable"")"
"The Java TimeZone class is a class that represents time zones, and is helpful when doing calendar arithmetics across time zones.","(""TIMEZONE"", ""TIMEZONE is a CLASS according to the description that it represents time zones."", ""CLASS"")"
The java.util.TimeZone class is used in conjunction with the java.util.Calendar class.,"(""TimeZone"", ""The TimeZone class is used in conjunction with the java.util.Calendar class, indicating they are related."", ""java.util.Calendar"")"
Note: In the Java 8 date time API the time zones are represented by the java.time.ZoneId class.,"(""ZoneId"", ""ZoneId is part of the java.time package, indicating it is structured within or associated with this package."", ""java.time"")"
But you only need to use the ZoneId class if you are using the Java 8 date time classes (like the ZonedDateTime class).,"(""ZoneId"", ""Both are classes used in Java 8 date and time API for time zone management."", ""ZonedDateTime""); (""ZoneId"", ""ZoneId is a class provided as part of the Java package."", ""Java""); (""ZonedDateTime"", ""ZonedDateTime is a class included within the Java package."", ""Java"")"
If you use a Calendar (from the Java 7 and earlier date time API) you can still use the java.util.TimeZone class.,NULL
The first method (TimeZone.getDefault()) returns the default time zone for the system (computer) this program is running on.,"(""TimeZone"", ""The method 'getDefault' belongs to the 'TimeZone' class"", ""getDefault"")"
"The second method (TimeZone.getTimeZone(""Europe/Copenhagen"")) returns the TimeZone corresponding to the given time zone ID (in this example ""Europe/Copenhagen"").",NULL
"The getOffset() method returns the offset in milliseconds for the given time zone to UTC, at the given time.","(""GETOFFSET"", ""METHOD""); (""GETOFFSET"", ""METHOD"")"
The Calendar class is capable of converting the date and time between time zones.,"(""Calendar"", ""class"")"
"Here is a list of the available time zone ids in the TimeZone class, printed as returned by TimeZone.getAvailableIDs().","(""TimeZone"", ""The method getAvailableIDs is associated with the TimeZone class as it is mentioned as returned by TimeZone."", ""getAvailableIDs"")"
"It is possible to both parse dates from strings, and format dates to strings, using Java's java.text.SimpleDateFormat class.","(""SimpleDateFormat"", ""The SimpleDateFormat class is part of the java.text package"", ""java.text"")"
It is also possible to parse and format dates using the newer Java DateTimeFormatter which is able to parse and format dates from and to the newer date time classes added in Java 8.,"(""Java DateTimeFormatter"", ""Java DateTimeFormatter is able to parse and format dates from and to the newer date time classes."", ""date time""); (""Java DateTimeFormatter"", ""Java DateTimeFormatter is part of the features added in Java 8."", ""Java 8"")"
"Even though both classes for parsing and formatting dates are covered in more detail in their own texts, I will show you a few examples of how to use them below.","(""Classes"", ""Parsing is a method that belongs to classes for parsing dates."", ""Parsing""); (""Classes"", ""Formatting is a method that belongs to classes for formatting dates."", ""Formatting"")"
Here is an example of how to format and parse a date using the SimpleDateFormat class.,"(""SimpleDateFormat"", ""The SimpleDateFormat class is mentioned as an example of how to format and parse a date."", ""SimpleDateFormat""); (""SimpleDateFormat"", ""The SimpleDateFormat class is mentioned as an example of how to format and parse a date."", ""SimpleDateFormat"")"
The string passed as parameter to the SimpleDateFormat class is a pattern that tells how the instance is to parse and format dates.,"(""SimpleDateFormat"", ""class""); (""SimpleDateFormat"", ""class"")"
"For a full list, see the official JavaDoc for the SimpleDateFormat class.","(""SimpleDateFormat"", ""JavaDoc provides documentation for the SimpleDateFormat class."", ""JavaDoc"")"
Another way to format dates is to use the DateTimeFormatter which works with the newer date time classes added in Java 8.,NULL
In the example above we use the DateTimeFormatter.BASIC_ISO_DATE instance which is configured to parse and format dates using the ISO date time format.,"(""DateTimeFormatter"", ""BASIC_ISO_DATE is an instance of the DateTimeFormatter class, used to parse and format dates."", ""BASIC_ISO_DATE""); (""BASIC_ISO_DATE"", ""BASIC_ISO_DATE is configured to use the ISO date time format."", ""ISO date time format"")"
"Exceptions are regular Java classes that extends java.lang.Exception, or any of the other built-in exception classes.","(""Exceptions"", ""Exceptions are regular Java classes that extend java.lang.Exception."", ""java.lang.Exception"")"
"If a method declares that it throws an exception A, then it is also legal to throw subclasses of A.",NULL
"In the example above the ""System.out.println(result);"" statement will not get executed if an exception is thrown fromt the divide method.",NULL
"In the example above the ""System.out.println(""Division attempt done"");"" statement will always get executed.","(""System"", ""The method println is a part of the System class, used to print messages to the console."", ""println""); (""System"", ""The method println is a part of the System class, used to print messages to the console."", ""println"")"
Here is how the callDivide() method would look in that case.,"(""CALLDIVIDE"", ""METHOD"")"
"Thus the ""System.out.println(result);"" method will not get executed if an exception is thrown from the divide method.","(""System.out.println"", ""System.out.println will not execute if an exception occurs in divide, indicating an execution flow dependency"", ""divide"")"
"If the reader.read() method call throws an IOException, the following System.out.println((char) i ); is not executed.",NULL
"Neither is the last reader.close() or the System.out.println(""--- File End ---""); statements.","(""Reader"", ""The method 'close()' is associated with the 'Reader' class to close resources."", ""Close""); (""System.out.println"", ""The method 'System.out.println' is used for output, related to 'Reader' for logging."", ""Reader"")"
Instead the program skips directly to the catch(IOException e){ ... } catch clause.,NULL
"If an exception is thrown from the reader.read() method then program execution is halted, and the exception is passed up the call stack to the method that called openFile().","(""READER.READ()"", ""The method OPENFILE() calls the method READER.READ(), and an exception from READER.READ() is propagated upwards to OPENFILE()."", ""OPENFILE()"")"
"If the calling method also just throws the method on, the calling method is also interrupted at the openFile() method call, and the exception passed on up the call stack.","(""Calling Method"", ""The Calling Method is interrupted at the openFile() method call."", ""openFile()""); (""Calling Method"", ""The Calling Method is interrupted at the openFile() method call."", ""openFile()"")"
That is why the previous example had the reader.close() method call in the finally block wrapped in a try-catch block:,"(""Reader.close"", ""method"")"
"That way the System.out.println(""--- File End ---""); method call will always be executed.",NULL
Notice how the two exception class names in the first catch block are separated by the pipe character |.,NULL
The pipe character between exception class names is how you declare multiple exceptions to be caught by the same catch clause.,NULL
If storeDataFromUrl() wants to call readDataFromUrl() it has only two choices.,"(""Storedatafromurl"", ""The method Storedatafromurl calls the method Readdatafromurl as part of its process."", ""Readdatafromurl""); (""Storedatafromurl"", ""The method Storedatafromurl calls the method Readdatafromurl as part of its process."", ""Readdatafromurl"")"
Notice how the readDataFromUrl() method no longer declares that it throws BadUrlException.,"(""ReadDataFromUrl"", ""The method 'ReadDataFromUrl' previously declared that it throws the class 'BadUrlException', indicating a relationship between the method and the class involving exception handling."", ""BadUrlException"")"
"The storeDataFromUrl() method can still choose to catch the exception but it no longer has to, and it no longer has to declare that it propagates the exception.","(""StoreDataFromUrl"", ""Method"")"
As you can see the readNumberFromUrl() needs to declare throwing both the BadUrlException and the BadNumberException that are thrown from the readDataFromUrl() and converData() methods.,"(""readNumberFromUrl"", ""The readNumberFromUrl() method declares throwing the BadUrlException class."", ""BadUrlException""); (""readNumberFromUrl"", ""The readNumberFromUrl() method declares throwing the BadNumberException class."", ""BadNumberException""); (""readDataFromUrl"", ""The BadUrlException is thrown from the readDataFromUrl() method."", ""BadUrlException""); (""converData"", ""The BadNumberException is thrown from the converData() method."", ""BadNumberException"")"
Imagine how many exceptions would need to be declared at the top level methods of an application with thousands of classes.,NULL
As you can see the readNumberFromUrl() method now only declares throwing ApplicationException.,NULL
Notice how the readNumberFromUrl() method does not declare throwing the ApplicationException even if it throws it.,"(""ReadNumberFromUrl"", ""The method readNumberFromUrl() may throw the ApplicationException, indicating a relationship where the method potentially raises an exception of this class."", ""ApplicationException"")"
All exceptions thrown in the application must be a subclass of the base exception.,NULL
As you know a method throwing Exception may also throw any subclass of Exception.,"(""Method"", ""A method can throw an exception"", ""Exception""); (""Exception"", ""An exception may throw any subclass of itself"", ""Subclass"")"
They are subclasses of the ApplicationException so they will get propagated up the call stack.,NULL
Argument 5 (Pro Unchecked Exceptions) Checked exceptions declared on methods become part of a the class or interface contract.,"(""Methods"", ""Checked exceptions declared on methods suggest an interaction or dependency on unchecked exceptions."", ""Unchecked Exceptions""); (""Methods"", ""Methods are typically part of a class, forming part of the class contract."", ""Class""); (""Methods"", ""Methods can be part of an interface definition, impacting the interface contract."", ""Interface"")"
The only requirement is that the new exceptions thrown are subclasses of the base exception.,"(""New Exceptions"", ""New Exceptions are described as subclasses of the Base Exception"", ""Base Exception"")"
Anders Hejlsberg on checked vs. unchecked exceptions http://www.artima.com/intv/handcuffs.html James Gosling on checked exceptions http://www.artima.com/intv/solid.html Bill Venners on Exceptions http://www.artima.com/interfacedesign/exceptions.html Bruce Eckel on checked exceptions http://www.artima.com/intv/typingP.html Designing with Exceptions (Bill Venners - www.artima.com) http://www.artima.com/designtechniques/desexcept.html Effective Java (Joshua Bloch - Addison Wesley 2001) Daniel Pietraru - in favor of checked exceptions Exceptional Java - Checked exceptions are priceless茂驴�?For everything else there is the RuntimeException,"(""Anders Hejlsberg"", ""Both are mentioned in the context of discussions about exceptions."", ""Bill Venners""); (""James Gosling"", ""Both are mentioned alongside each other in discussions about checked exceptions."", ""Bill Venners""); (""Bill Venners"", ""Both discuss checked exceptions in articles on Artima."", ""Bruce Eckel""); (""Joshua Bloch"", ""Joshua Bloch is the author of 'Effective Java', which is related to exceptions."", ""Exceptional Java""); (""Daniel Pietraru"", ""Daniel Pietraru is an advocate for checked exceptions, relevant to 'Exceptional Java'."", ""Exceptional Java"")"
Checked exceptions declared on methods become part of a the class or interface contract.,NULL
As you can see the method1() throws an EnrichableException which is a superclass for enrichable exceptions.,NULL
"Notice how method2() calls the addInfo() method on the caught EnrichableException, and rethrow it afterwards.","(""METHOD2"", ""METHOD2 calls the ADDINFO method."", ""ADDINFO""); (""METHOD2"", ""METHOD2 interacts with ENRICHABLEEXCEPTION by calling a method on it."", ""ENRICHABLEEXCEPTION"")"
"Notice how method1() adds the code ""ERROR1"" to the thrown EnrichableException to uniquely identify that error cause.",NULL
But notice too that method1() is called from both method2() and method3().,"(""Method2"", ""Method2 calls Method1"", ""Method1""); (""Method3"", ""Method3 calls Method1"", ""Method1"")"
"Though the error may seem the same to method1() no matter which of method2() and method3() that called it, this may important to know for the developer investigating the error.","(""Method1"", ""Method1 is called by Method2, which may cause an error to be investigated by a developer."", ""Method2""); (""Method1"", ""Method1 is called by Method3, which may cause an error to be investigated by a developer."", ""Method3""); (""Method1"", ""Method1 is called by Method2, which may cause an error to be investigated by a developer."", ""Method2""); (""Method1"", ""Method1 is called by Method3, which may cause an error to be investigated by a developer."", ""Method3"")"
Here is an example where the addInfo() method has been changed to accommodate this:,NULL
Two new parameters have been added to the addInfo() method and the constructor of the EnrichableException.,"(""AddInfo"", ""The method is part of the functionality provided by the EnrichableException class."", ""EnrichableException"")"
An error identification for an exception thrown by method1() when called from method2() will now look like this:,NULL
When method1() is called from method3() the error identification will look like this:,NULL
As you can see it is now possible to distinguish an exception thrown from method1() via method2() from the same exception thrown from method1() via method3().,"(""Method1"", ""Method1 can throw exceptions via Method2"", ""Method2""); (""Method1"", ""Method1 can throw exceptions via Method3"", ""Method3"")"
"Here is an example where method1() catches a non-enrichable exception and wraps it in an enrichable exception, and throws the enrichable exception:","(""Method1"", ""Method1 catches a non-enrichable exception and wraps it in an enrichable exception"", ""Exception""); (""Method1"", ""Method1 throws the enrichable exception"", ""Exception"")"
Exceptions caught in the program will be passed to the handleException() which will decide what concrete exception to throw instead.,"(""Exceptions"", ""Exceptions caught in the program are passed to the handleException method for processing."", ""handleException"")"
If the EnrichableException is unchecked it is not necessary to declare it in the handleException() method.,NULL
You may need to change the class definition to suit your own needs.,NULL
"If an exception is thrown from within the try block, and another exception is thrown from the input.close() call in the finally block, both exceptions are preserved in the MyException instance, and propagated up the call stack.","(""MyException"", ""The 'close' method is called in the context where a MyException instance is involved, implying that the exceptions are managed within the MyException class."", ""close"")"
"RuntimeExceptions thrown from the try-block are not preserved, if the input.close() call also throws an exception.","(""RuntimeExceptions"", ""RuntimeExceptions are thrown from the try-block."", ""try-block""); (""input.close()"", ""input.close() is called within the try-block."", ""try-block"")"
Notice how the process() method calls the doProcess() method inside the try-catch block.,"(""Process"", ""The Process method calls the DoProcess method within the try-catch block."", ""DoProcess"")"
"You will use the template by subclassing it, and overriding the doProcess() method.",NULL
"This example creates an anonymous subclass of the InputStreamProcessingTemplate class, instantiates an instance of the subclass, and calls its process() method.","(""InputStreamProcessingTemplate"", ""The process method is associated with the InputStreamProcessingTemplate class and is called on an instance of its subclass."", ""process"")"
"You will typically also get more help from your IDE's code completion when writing it, because the IDE will recognize both the doProcess() and process() methods.",NULL
Instead of subclassing the InputStreamProcessingTempate you could rewrite it to take an instance of an InputStreamProcessor interface.,NULL
"This is the InputStreamProcessor, which is called from inside the try block (processor.process(input)).","(""InputStreamProcessor"", ""The method 'process' is called on an instance of 'InputStreamProcessor', indicating a relationship between the class and the method."", ""process"")"
"It doesn't look much different from the previous usage, except the call to the InputStreamProcessingTemplate.process() method is now closer to the top of the code.","(""InputStreamProcessingTemplate"", ""The method process is a member of the class InputStreamProcessingTemplate, as indicated by the dot notation in InputStreamProcessingTemplate.process."", ""process"")"
Notice how the call to the template's process() method is now a static method call.,NULL
"The advantage of exception hierarchies is that if you decide to catch (using try-catch) a certain exception in the hierarchy, then you will automatically also catch all subclasses of that exception too.","(""Exception Hierarchies"", ""The exception hierarchies organize or categorize exceptions."", ""Exception""); (""Exception"", ""Subclasses are specific types of exceptions, indicating an 'is-a' relationship."", ""Subclasses""); (""Try-Catch"", ""The try-catch method is used to handle exceptions, showing a direct operational relationship."", ""Exception"")"
"In the example with FileNotFoundException, if you catch IOException which is the superclass of FileNotFoundException, you will also catch FileNotFoundException.","(""IOException"", ""IOException is the superclass of FileNotFoundException, indicating an inheritance relationship."", ""FileNotFoundException"")"
"But, multiple catch blocks can also be used in the case where all the exceptions thrown inside the try-block are the same type or subclasses of that type.","(""Exceptions"", ""Subclasses are specialized derivations of the Exceptions class."", ""Subclasses"")"
"The fact that FileNotFoundException is a subclass of IOException gives us the choice of either treating all IOExceptions the same, or catch some of IOExceptions subclasses individually, as is done in the code example above.","(""FileNotFoundException"", ""FileNotFoundException is a subclass of IOException"", ""IOException"")"
"If the catch(FileNotFoundException e) block is removed any FileNotFoundException will be caught by the catch(IOException e) block, since FileNotFoundException is a subclass of IOException.",NULL
"If a method can throw either a certain exception A, or any subclasses of A (Asub), then it is enough to declare in the method declaration that the method throws A.","(""Method"", ""The method can throw Exception A directly."", ""Exception A""); (""Method"", ""The method can throw subclasses of Exception A, represented by Asub."", ""Asub"")"
It is then allowed to throw subclasses of A from the method too.,"(""A"", ""The class A can be thrown from the method, indicating a functional relationship where the method handles or processes the class A."", ""method"")"
"You are allowed to declare the subclasses in the throws clause of the method, even if you don't really need to.",NULL
"As long as the superclass of any declared exception is also declared thrown, it doesn't have any effect on the code to include the throwing of the subclass.",NULL
"It is still possible to handle the two exceptions with each their own catch-block as shown earlier, even if only the superclass is declared thrown.",NULL
"If you need more granularity on the exceptions thrown, for instance because you think the exceptions may be handled differently, then add new exceptions as subclasses of your API or application base exception.",NULL
"In Mr. Persister we could add a ConnectionOpenException, QueryException, UpdateException, CommitException, and ConnectionCloseException as subclasses of PersistenceException.",NULL
Summary In this text we have seen that exception hierarchies can be created by subclassing exception classes.,"(""Exception"", ""Exception can be subclassed, indicating a hierarchical relationship with Method"", ""Method"")"
"It is a good idea to create a base exception for your API or application, and have all other exceptions subclass this base exception.",NULL
Individual subclasses makes it possible (but not obligatory) to catch and handle these individual exceptions differently.,"(""Subclasses"", ""Subclasses imply a collection of exceptions that can be handled individually."", ""Exceptions"")"
In this text we have seen that exception hierarchies can be created by subclassing exception classes.,NULL
Exception wrapping is a standard feature in Java since JDK 1.4.,"(""Exception Wrapping"", ""Exception wrapping is a method used in Java."", ""Java""); (""Exception Wrapping"", ""Exception wrapping became a standard starting from JDK 1.4."", ""JDK 1.4"")"
They also have a getCause() method that will return the wrapped exception.,"(""Getcause"", ""Method"")"
"When a request is successfully processed, you can write the whole execution context object to a log file, as a single, coherent structure (e.g.","(""Execution Context Object"", ""class""); (""Execution Context Object"", ""class"")"
"It's implemented as a single class called ExecutionContext, which keeps all calls to it internally in a list.","(""ExecutionContext"", ""The ExecutionContext class keeps all calls internally in a list."", ""list"")"
Notice how each method ( level1() to level3() ) calls the ExecutionContext.,"(""Level1"", ""Level1 calls the ExecutionContext"", ""ExecutionContext""); (""Level2"", ""Level2 calls the ExecutionContext"", ""ExecutionContext""); (""Level3"", ""Level3 calls the ExecutionContext"", ""ExecutionContext"")"
"Therefore, I have developed an ExecutionContextTree class, which can contain this information.","(""ExecutionContextTree"", ""class""); (""ExecutionContextTree"", ""class"")"
"The pre() call creates a new node, and attaches it to the parent node (if any).","(""Pre"", ""The method pre() creates a new node."", ""Node""); (""Node"", ""The node is attached to the parent node."", ""Parent Node"")"
"Any calls to pre() after this one, will result in new nodes being attached to the newly created node.",NULL
The post() call removes the node as the current parent in the execution tree.,"(""Post"", ""The post() method interacts with the Node class by removing the node as the current parent in the execution tree."", ""Node"")"
The next call to pre() will now attach a node to the parent of the node just removed as parent node.,NULL
"As you can see, the pre() and post() calls are very often insert at the start and end of a method call.","(""Pre"", ""Both are method calls that are often used together at the start and end of an execution block"", ""Post"")"
"If the input.close() call fails, and an IOException is thrown, then it is caught, wrapped and rethrown.","(""Close"", ""The method 'close' can throw an exception of type 'IOException' during execution."", ""IOException"")"
All classes implementing this interface can be used inside the try-with-resources construct.,NULL
The Java try-with-resources construct does not just work with Java's built-in classes.,"(""Java"", ""class""); (""Java's built-in classes"", ""class"")"
"You can also implement the java.lang.AutoCloseable interface in your own classes, and use them with the try-with-resources construct.",NULL
Any class that implements this interface can be used with the Java try-with-resources construct.,NULL
Here is the output printed to System.out when the method myAutoClosable() is called:,"(""myAutoClosable"", ""The method myAutoClosable is called, and its output is printed to System.out, indicating an interaction."", ""System.out"")"
"If an exception is thrown both from inside the try-with-resources block, and when a resource is closed (when close() is called), the exception thrown inside the try block will be propagated up the call stack.","(""Close"", ""The method close() is called when a resource is closed and can result in an exception being thrown."", ""Exception"")"
"In that case, the exception thrown when attempted closed will be propagated up the call stack to the main() method where the try-catch block will catch it.",NULL
"In that case, the Throwable array returned from e.getSuppessed() will be an empty array (size of 0).",NULL
"In case the parameter to resourceOne.doOp() was changed to true also, the doOp() method would throw an exception.","(""ResourceOne"", ""ResourceOne class contains the method doOp"", ""doOp"")"
"In that case, it is this exception that is propagated up the call stack to the main() method.","(""MAIN"", ""The main() method is the only method mentioned and is part of a typical programming structure."", ""METHOD"")"
The exception thrown when attempting to close the resource would be available inside the Throwable array returned by e.getSuppressed().,NULL
"However, in the example above I have forced both resources to throw an exception when attempted closed, and the first resource to throw an exception when used (when doOp() is called).","(""doOp"", ""method""); (""doOp"", ""method"")"
The two exceptions thrown when attempting to close the resources are available in the Throwable array returned by e.getSuppressed().,"(""e"", ""e is the object on which the method getSuppressed is called."", ""getSuppressed""); (""Throwable"", ""Throwable is related to e because it contains exceptions thrown, accessible via e's methods."", ""e"")"
"In case an exception is thrown when attempting to close one of the resources, these exceptions will be available from the exception's getSuppressed() method inside the catch block.","(""getSuppressed"", ""getSuppressed is a method used to retrieve suppressed exceptions from an exception"", ""exception"")"
"In the example above, the AutoClosableResource is configured to throw an exception both when doOp() is called, and when it is attempted closed (via close()).",NULL
"The exception thrown from doOp() is caught in the catch block, its getSuppressed() method returns an array with the exception thrown when the resource was attempted closed.",NULL
"The getSuppressed() method of that exception will return an empty array, since no exceptions where suppressed.","(""getSuppressed"", ""method"")"
The Throwable class has a method named addSuppressed() which takes a Throwable object as parameter.,"(""Throwable"", ""The addSuppressed method belongs to the Throwable class."", ""addSuppressed""); (""Throwable"", ""The addSuppressed method belongs to the Throwable class."", ""addSuppressed"")"
"Using the addSuppressed() method it is possible to add suppressed exceptions to another exception, in case you need that.","(""addSuppressed"", ""method""); (""addSuppressed"", ""method"")"
"To understand why, look at the following method which reads a file and prints it to the System.out:",NULL
"The InputStream's close() method may throw an exception too, if closing it fails.","(""InputStream"", ""The close method is a method that can be called on the InputStream class to perform an operation."", ""close"")"
You will have to code your own exception class in order to make exception enrichment possible.,"(""Exception Class"", ""class"")"
"However, the ExceptionHandler can throw all the unchecked exceptions it wants (RuntimeException and subclasses of it).",NULL
"In contrast, inside a DAO class you will most likely not be able to interact with the user to correct the error.","(""DAO"", ""class"")"
In this example the validate() method throws an exception as soon as an validation error is found.,"(""Validate"", ""The Validate method is mentioned in the context of throwing an exception."", ""Exception"")"
"Notice how it is not necessary to cast the object obtained from the List.get() method call, as is normally necessary.",NULL
Notice how it is not necessary to cast the object returned from the iterator.next() next call.,NULL
"Adding and getting elements to a generic Map is done using the put() and get() methods, just like you have always done:","(""Map"", ""The put method is used to add elements to the Map, implying usage within the Map class."", ""put""); (""Map"", ""The get method is used to retrieve elements from the Map, indicating usage with the Map class."", ""get"")"
Also notice how it is not necessary to cast the String instance returned by the get() method.,"(""get"", ""The 'get' method returns an instance of the 'String' class, as indicated by the text."", ""String"")"
Most often you iterate the key Set and access the values for each key via the Map.get() method.,"(""Set"", ""A key Set is iterated to access values in a Map, indicating a usage relationship where Set provides keys for accessing Map entries."", ""Map""); (""Map"", ""The get method is used on a Map to retrieve the value associated with a specific key, showing that get is an operation utilized within Map."", ""get"")"
"Adding elements to a generic Set is done using the add() method, just like you have always done:","(""add"", ""The add method is used to add elements to the Set class."", ""Set"")"
Generics is not restricted to the predefined classes in the Java API's.,"(""Generics"", ""Generics are a feature within the Java package that allows for parameterization of classes with types"", ""Java"")"
The <T> is a type token that signals that this class can have a type set when instantiated.,NULL
Notice how it is not necessary to cast the object returned from the factory.createInstance() method.,NULL
Notice how we can call the addAndReturn() method using both String's and Integer's and their corresponding collections.,NULL
"Java Generic's wildcards is a mechanism in Java Generics aimed at making it possible to cast a collection of a certain class, e.g A, to a collection of a subclass or superclass of A.","(""Java Generics"", ""Java Generics is used to handle types that are subclasses or superclasses of A."", ""A""); (""Collection"", ""Collections can be cast to collections of a subclass or superclass of A."", ""A""); (""Java Generics"", ""Java Generics is used to handle types that are subclasses or superclasses of A."", ""A""); (""Collection"", ""Collections can be cast to collections of a subclass or superclass of A."", ""A"")"
"In listA you can insert objects that are either instances of A, or subclasses of A (B and C).",NULL
When you then try to take objects out of listB you could risk to get non-B objects out (e.g.,NULL
Thus you could insert non-B objects into a list declared to hold B (or B subclass) instances.,"(""B"", ""class""); (""list"", ""class"")"
"Imagine you have a method that processes the elements of a List, e.g.","(""List"", ""class"")"
The processElements() method can now be called with any generic List as parameter.,NULL
"When you know that the instances in the collection are of instances of A or subclasses of A, it is safe to read the instances of the collection and cast them to A instances.","(""A"", ""The text indicates that instances of the 'Collection' can be cast to instances of 'A' or its subclasses, suggesting that 'A' is the expected type for elements within 'Collection'."", ""Collection"")"
"You can now call the processElements() method with either a List<A>, List<B> or List<C>.",NULL
"super A> means that the list is typed to either the A class, or a superclass of A.","(""A"", ""A is either a class or a superclass of A."", ""superclass of A"")"
"When you know that the list is typed to either A, or a superclass of A, it is safe to insert instances of A or subclasses of A (e.g.",NULL
"All of the elements inserted here are either A instances, or instances of A's superclass.",NULL
"Since both B and C extend A, if A had a superclass, B and C would also be instances of that superclass.",NULL
"You can now call insertElements() with either a List<A>, or a List typed to a superclass of A.",NULL
"The insertElements() method cannot read from the list though, except if it casts the read objects to Object.",NULL
"The elements already present in the list when insertElements() is called could be of any type that is either an A or superclass of A, but it is not possible to know exactly which class it is.","(""InsertElements"", ""insertElements is a method that operates on elements which could be of class A or its superclass."", ""A"")"
"However, since any class eventually subclass Object you can read objects from the list if you cast them to Object.",NULL
Here are a few examples of calls to the getInstance() method:,NULL
As you can see the return type changes depending on what class object you pass in as parameter to the method.,NULL
It is possible to use your own collection type classes with the new for-loop.,"(""Collection Type"", ""The collection type is used within the new for-loop as an iteration construct."", ""For-loop"")"
And here is the corresponding implementation skeleton of the MyIterator class:,"(""MyIterator"", ""class""); (""MyIterator"", ""class"")"
Generics add a way to specify concrete types to general purpose classes and methods that operated on Object before.,NULL
"Note: Java generics can be used with other classes than the collection classes, but it is easiest to show the basics of Java generics using collections.","(""Java Generics"", ""Java Generics are often used with Collection Classes to illustrate their usage."", ""Collection Classes"")"
"When you just write a diamond operator as generic type, the Java compiler will assume that the class instantiated is to have the same type as the variable it is assigned to.",NULL
This for-loop is shorter than original while-loop where you would iterate the collections Iterator and call Iterator.next() to obtain the next instance.,NULL
It is of course possible to use Generics for other classes than the Java collections.,NULL
"Using Java generics in your own classes is described in more detail in the tutorials about generic classes, generic methods and using class objects as type literals.",NULL
The java.text.DateFormat class is used to format dates as strings according to a specific Locale.,"(""DateFormat"", ""DateFormat is a class within the java.text package."", ""java.text""); (""DateFormat"", ""DateFormat relies on Locale to format dates according to specific regional settings."", ""Locale"")"
You create a DateFormat using the getDateInstance() and getTimeInstance() method of the DateFormat class.,NULL
The date format parameter can be chosen among the following constants in the DateFormat class:,"(""DateFormat"", ""class"")"
"In order to format only time and not the date itself, you need a time instance of the DateFormat class.","(""DateFormat"", ""A time instance is a specific use or feature of the DateFormat class to format only time."", ""time instance"")"
The java.text.DecimalFormat class is used to format numbers using a formatting pattern you specify yourself.,"(""JAVA.TEXT.DECIMALFORMAT"", ""The class is used to format numbers using a specified pattern."", ""FORMAT NUMBERS"")"
This text explains how to use the DecimalFormat class to format different types of numbers.,"(""DecimalFormat"", ""The DecimalFormat class is used to format different types of numbers."", ""numbers"")"
You can change this pattern later using the applyPattern() or applyLocalizedPattern() method.,"(""ApplyPattern"", ""Both are methods that can be used to change the pattern."", ""ApplyLocalizedPattern"")"
The applyPattern() method simply applies a new pattern to the DecimalFormat instance as if it were created with that pattern.,"(""ApplyPattern"", ""The ApplyPattern method is applied to the DecimalFormat instance, indicating a functional relationship where the method operates on the class."", ""DecimalFormat"")"
The applyLocalizedPattern() does the same as applyPattern() except it interpretes the characters in the pattern according to the Locale the DecimalFormat was created with.,"(""ApplyLocalizedPattern"", ""ApplyLocalizedPattern is related to ApplyPattern as both are methods that handle patterns, and the former interprets patterns according to a specific Locale."", ""ApplyPattern""); (""ApplyLocalizedPattern"", ""ApplyLocalizedPattern is related to DecimalFormat because it uses the Locale associated with the DecimalFormat instance."", ""DecimalFormat""); (""ApplyPattern"", ""ApplyPattern is related to DecimalFormat as it is a method intended for handling pattern interpretation within this class."", ""DecimalFormat"")"
You format a number using the format() method of the DecimalFormat instance.,NULL
"For a full explanation of what these methods do, see the JavaDoc for the DecimalFormatSymbols class.","(""DecimalFormatSymbols"", ""The methods are likely associated with the DecimalFormatSymbols class, as suggested by the mention of the JavaDoc for the class."", ""methods"")"
The DecimalFormat class has a method called setGroupingSize() which sets how many digits of the integer part to group.,NULL
"The java.text.BreakIterator class is used to find character, word and sentence boundaries across different languages.","(""BreakIterator"", ""The BreakIterator class is part of the java.text package."", ""java.text"")"
You create an instance that can recognize one of the above boundaries using the corresponding factory method in the BreakIterator class.,"(""factory method"", ""The factory method belongs to the BreakIterator class."", ""BreakIterator"")"
"A character instance of the BreakIterator class finds character boundaries for user characters, not unicode characters.",NULL
"This example creates a BreakIterator targeted at the British language, and sets the text to find character breaks in using the setText() method.","(""BreakIterator"", ""The setText() method is used with the BreakIterator class to set the text for finding character breaks."", ""setText"")"
"Again, here the first() and next() methods return the unicode index of the found word boundary.",NULL
"Notice how the isWord() method uses the Character.isLetterOrDigit() method to determine if a character is a letter or digit, or something else (like semicolon, quote etc.).",NULL
"The Character.isLetterOrDigit() checks according to the unicode characters if a character is a letter or digit - and thus not just in the english language, but also in other languages.",NULL
Java has some methods in the java.lang.Character class that are useful in internationalization of Java applications.,"(""Character"", ""The Character class contains various useful methods."", ""methods""); (""java.lang"", ""The Character class is part of the java.lang package."", ""Character"")"
"To safely check if a character is a letter, number or space character you need to use the methods in java.lang.Character to do so.","(""Character"", ""The Character class provides methods to check if a character is a letter, number, or space character."", ""check""); (""java.lang"", ""The Character class is part of the java.lang package."", ""Character"")"
The Character class also has a getType() method which returns the type of a certain character.,"(""Character"", ""getType is a method that belongs to the Character class and is responsible for returning the type of a certain character."", ""GetType"")"
The returned type is an int which matches a set of predefined constants in the Character class.,"(""Character"", ""class""); (""Character"", ""class"")"
Look in the JavaDoc for the Character class for more constants.,"(""Character"", ""class"")"
The Character class also has a method that enables you to determine if the value of a given int defines a character in unicode.,NULL
"Thus, simply using the String.compareTo() method may not work for all languages.",NULL
"To sort a collection of strings according to the rules of a certain Locale, you use a java.text.Collator instance created for that specific Locale.",NULL
To compare two strings using the Collator instance you call the compare() method.,"(""Collator"", ""The compare method is called on an instance of the Collator class."", ""compare"")"
The compare() method returns an int with the same meaning as the String.compareTo() method:,"(""Compare"", ""Both are methods performing comparison, and 'Compare' is noted to return an int with the same meaning as the 'String.compareTo' method."", ""String.compareTo"")"
A 0 means that the two strings have the same order - e.g.,NULL
There are more rules you can use with the RuleBasedCollator class.,"(""RuleBasedCollator"", ""class"")"
You normalize a string using the static normalize() method of the java.text.Normalizer class.,"(""NORMALIZE"", ""The normalize method is a static method of the java.text.Normalizer class, indicating a direct relationship as part of the class's functionality."", ""JAVA.TEXT.NORMALIZER"")"
The first parameter to the normalize() method is the text to normalize.,"(""Normalize"", ""The 'Normalize' method takes 'Text' as its first parameter to perform normalization."", ""Text"")"
You can use the String class to convert a byte array to a String instance.,NULL
You can convert the text of a String to another format using the getBytes() method.,"(""String"", ""The getBytes() method is used to convert the text of a String class to another format."", ""getBytes"")"
The Reader and Writer classes are stream oriented classes that enable a Java application to read and write streams of characters.,NULL
This is done using the second constructor paramter in the InputStreamReader class.,"(""InputStreamReader"", ""class"")"
"Input is everything that your application receives from its users, either directly through the user interface, sent to it via service calls (e.g.",NULL
"The internationalization layer should convert from whatever character encoding the input comes in (ascii, UTF-8 etc.)","(""Internationalization Layer"", ""The internationalization layer is responsible for handling the conversion of character encodings in the input."", ""Character Encoding"")"
Java has a set of built-in classes that can help you handle internationalization of your application.,"(""Java"", ""Java provides classes that handle internationalization tasks"", ""internationalization"")"
Each of these classes are covered in more detail in later texts in this trail.,"(""Classes"", ""class""); (""Classes"", ""class"")"
In Java you can convert between time zones using the java.util.Calendar class.,"(""Java"", ""The Calendar class is part of the Java package."", ""Calendar"")"
"Please not, that the Calendar.getTimeInMillis() always returns the time in UTC, regardless of the time zone set on the Calendar instance.","(""Calendar"", ""The getTimeInMillis() method is used by the Calendar class to return the time in milliseconds."", ""getTimeInMillis()"")"
"As you saw in the example, you get the time zone from the java.util.TimeZone class.",NULL
You can obtain a list of the available time zone ID's using the TimeZone.getAvailableIDs() .,NULL
"This examples obtains all the available time zone ID's, and then prints them to System.out.","(""System"", ""The 'out' method is part of the 'System' class for output operations."", ""out""); (""System"", ""The 'out' method is part of the 'System' class for output operations."", ""out"")"
"I have described the java.util.TimeZone class in more detail in my Java Date Time tutorial, in the TimeZone class.",NULL
"This Java internationalization tutorial is ""work in progress"", so if you spot a a missing description of a feature etc., please be patient.","(""Java"", ""The Java class utilizes the internationalization package to handle multiple languages and locales in applications."", ""internationalization"")"
"The Java Locale class, java.util.Locale, is used to represent a ""geographical, political or cultural"" region to localize a given text, number, date or operation to.","(""Locale"", ""The Locale class is part of the java.util package, which is evident from the conventional Java naming convention."", ""java.util.Locale"")"
The Locale class cannot do any internationalization or localization by itself.,"(""Locale"", ""class"")"
"The Locale class complies with the BCP 47 (IETF BCP 47, ""Tags for Identifying Languages"") standard.",NULL
"The Locale class also has support for the LDML (UTS#35 ""Unicode Locale Data Markup Language"") standard, which is a BCP 47-compatible extension for locale data exchange.","(""Locale"", ""The Locale class supports the LDML standard"", ""LDML"")"
"Language codes are case insensitive, but the Locale class always use lowercase versions of the language codes.","(""Locale"", ""The Locale class is mentioned in the context of using language codes, suggesting it interacts with or processes these codes."", ""language codes"")"
"Script codes are case insensitive, but the Locale class always uses a version with the first letter in uppercase, and the rest in lowercase.","(""Locale"", ""class"")"
"The country code is a 2 character code following the ISO 3166 standard, or a UN M.49 numeric area code.","(""Country Code"", ""The Country Code follows the ISO 3166 Standard."", ""ISO 3166 Standard""); (""Country Code"", ""The Country Code includes the UN M.49 Numeric Area Code."", ""UN M.49 Numeric Area Code"")"
"The country code is case insensitive, but the Locale class uses an uppercase version of the country code.","(""Locale"", ""The Locale class uses an uppercase version of the country code, indicating a relationship between the class and the concept of country code."", ""country code"")"
See the JavaDoc for the Locale class for more detail about variant.,"(""Locale"", ""The JavaDoc contains documentation details about the Locale class providing more information about its variant."", ""JavaDoc"")"
"For instance, what calendar to use when displaying dates (Gregorian, Arab, Japanese etc.).","(""Calendar"", ""The 'Gregorian' calendar is a specific type of calendar used for displaying dates."", ""Gregorian""); (""Calendar"", ""The 'Arab' calendar is a specific type of calendar used for displaying dates."", ""Arab""); (""Calendar"", ""The 'Japanese' calendar is a specific type of calendar used for displaying dates."", ""Japanese"")"
See the JavaDoc for the Locale class for more detail about extensions.,"(""JavaDoc"", ""The Locale class is documented in the JavaDoc package."", ""Locale"")"
Creating a java.util.Locale instance can be done in four different ways:,NULL
The java.util.Locale class contains a set of constants that represent the most commonly used languages in the world.,"(""java.util"", ""The class Locale is part of the java.util package, indicating a package-class relationship."", ""Locale"")"
You can also create a java.util.Locale instance by using one of its constructors.,"(""Locale"", ""The class 'Locale' is part of the package 'java.util'."", ""java.util""); (""Locale"", ""The 'Locale' class can be instantiated using its 'constructors'."", ""constructors"")"
From Java 7 you can use the Locale.Builder class to build a Locale instance.,NULL
The factory method Locale.forLanguageTag() can also be used to create a Locale instance.,NULL
The ResourceBundle class is covered in more detail in the text about the ResourceBundle class.,"(""ResourceBundle"", ""The ResourceBundle class is mentioned in relation to itself as it is the primary topic of the text."", ""ResourceBundle"")"
"Finally, I may want to show how a given application works to a person who doesn't speak the language that my application is localized to (e.g.",NULL
"English or Danish), so I may want to temporarily change language to e.g.",NULL
The java.text.NumberFormat class is used to format numbers according to a specific Locale.,NULL
Formatting a number using a NumberFormatter is done using the format() method.,"(""NumberFormatter"", ""The format() method is used in conjunction with the NumberFormatter class to format a number."", ""format"")"
"Notice that numbers like 100.00 might be formatted without the decimals, as 100.",NULL
Formatting a number as a currency is still done using the format() method.,"(""Format"", ""Method"")"
"You can also set the Currency object to use for formatting a number as a currency, using the setCurrency() method on the NumberFormat class.","(""setCurrency"", ""The setCurrency() method is used on the NumberFormat class to install a Currency object for formatting."", ""NumberFormat"")"
Formatting a number as a percentage is also done using the format() method.,NULL
You can set the rounding mode using the setRoundingMode() method of the NumberFormat class.,"(""setRoundingMode"", ""The setRoundingMode method is a part of the NumberFormat class, as it is used for setting the rounding mode."", ""NumberFormat"")"
"Had the NumberFormat instance been created using a UK Locale instance, the number had been parsed to 10000, because the comma would have been interpreted as a integer separator (e.g.","(""NumberFormat"", ""NumberFormat is a class that can be configured with different locale settings, such as Locale."", ""Locale""); (""Locale"", ""Locale is associated with different regions, such as the UK package."", ""UK""); (""NumberFormat"", ""NumberFormat can use a UK locale setting for regional number formatting."", ""UK"")"
"The Java ResourceBundle class, java.util.ResourceBundle, is used to store texts and components that are locale sensitive.","(""ResourceBundle"", ""The ResourceBundle class is a part of the java.util.ResourceBundle package, indicating a hierarchical relationship between the class and the package."", ""java.util.ResourceBundle"")"
"A user's locale is represented by the Java Locale class, by the way.","(""Java Locale"", ""class"")"
This text takes a closer look at the ResourceBundle class and its subclasses.,"(""ResourceBundle"", ""The ResourceBundle class is related to its subclasses in an inheritance hierarchy, where ResourceBundle serves as the parent class."", ""subclasses"")"
The PropertyResourceBundle class stores localized texts in standard Java property files.,"(""PropertyResourceBundle"", ""PropertyResourceBundle is used within Java to handle localized property files."", ""Java"")"
Then you pass that Locale instance to the ResourceBundle.getBundle() method along with the name of the resource bundle to load.,"(""Locale"", ""The Locale class instance is used as an argument in the getBundle method to specify the locale for which a resource bundle is desired."", ""getBundle""); (""ResourceBundle"", ""The getBundle method is a static method of the ResourceBundle class that loads a resource bundle for the given base name and locale."", ""getBundle"")"
Finally you can access the localized values in the ResourceBundle via its different getString() and getObject() etc.,"(""ResourceBundle"", ""The getString() method is used to access localized values in the ResourceBundle class."", ""getString""); (""ResourceBundle"", ""The getObject() method is used to access localized values in the ResourceBundle class."", ""getObject"")"
"You are never actually creating a ResourceBundle instance, but an instance of one of its two subclasses.",NULL
"First the ResourceBundle class will look for a ListResourceBundle, and then for a PropertyResourceBundle.",NULL
"It does so by matching the name of the requested resource bundle (first parameter in the getBundle() method) against the class names of a ListResourceBundle first, and if none found, against a property file resource bundle.","(""GETBUNDLE"", ""The getBundle method matches the name of the requested resource bundle against the class names of a ListResourceBundle."", ""LISTRESOURCEBUNDLE"")"
For this example to work you should put a standard Java property file named MyBundle.properties in a Java package named i18n.,NULL
"Make sure this property file is available on your class path when you run the above code, meaning the property file should be located among the classes of your application, and in the i18n package.",NULL
The name of a resource bundle is like a class name.,"(""Resource Bundle"", ""The text states that the name of a resource bundle is like a class name, indicating a conceptual similarity or relationship between a resource bundle and a class."", ""Class"")"
"Thus, i18n.MyBundle means a property file named MyBundle.properties in the package (directory) i18n.",NULL
"In case no property file is available for the language (Locale) passed to the ResourceBundle.getBundle() method, and the system has no default Locale set (e.g.",NULL
You can also use a set of classes to contain your resources.,NULL
"Like with the property files, you create a set of classes with a bundle base name and language suffixes.",NULL
Here is an example implementation of the default bundle class file:,"(""Implementation"", ""The text discusses an implementation that pertains to the Default Bundle class."", ""Default Bundle"")"
"You can also obtain a set of all keys contained in the ResourceBundle using the keySet() method, like this:","(""ResourceBundle"", ""The keySet() method is used to obtain all keys from the ResourceBundle class."", ""keySet()"")"
The java.text.SimpleDateFormat class is used to both parse and format dates according to a formatting pattern you specify yourself.,NULL
This text explains how to use the SimpleDateFormat class to format dates.,"(""SimpleDateFormat"", ""The SimpleDateFormat class is used to format dates."", ""format dates"")"
Once you have created a SimpleDateFormat instance you can format dates using its format() method.,"(""SimpleDateFormat"", ""The method format() belongs to the SimpleDateFormat class, indicating that it is a method provided by instances of this class to format dates."", ""format"")"
The Date instance passed to the format() method is a java.util.Date instance.,NULL
"The Java SimpleDateFormat class is also capable of formatting a Date object into a StringBuffer, instead of returning an individual String with the date formatted.",NULL
"The SimpleDateFormat class does this via a version of the format() method that takes the Date, StringBuffer and a FieldPosition instance as parameters.","(""SimpleDateFormat"", ""The SimpleDateFormat class contains the format() method, which is part of its functionality to format dates."", ""format""); (""SimpleDateFormat"", ""The SimpleDateFormat class contains the format() method, which is part of its functionality to format dates."", ""format"")"
It seems the format() method appends the formatted String to the end of the StringBuffer no matter what the int value passed to the FieldPosition constructor is.,NULL
You can parse a String into a java.util.Date instance using the parse() method of the SimpleDateFormat instance.,NULL
"For instance, you can write either yy for a 2-character version of the year (e.g.",NULL
"12), or you can write yyyy for a 4-character version of the year (e.g.",NULL
"For more information about the patterns accepted, see the JavaDoc for the SimpleDateFormat class.","(""SimpleDateFormat"", ""class"")"
"The indices in this array must start from one, to be indexable by the Calendar.SUNDAY, Calendar.MONDAY etc.","(""Calendar"", ""SUNDAY is a class in the Calendar package"", ""SUNDAY""); (""Calendar"", ""MONDAY is a class in the Calendar package"", ""MONDAY"")"
See the JavaDoc for the java.text.DateFormatSymbols class for more details about these methods and symbols.,NULL
You can set the time zone of a SimpleDateFormat using its setTimeZone() method.,"(""SimpleDateFormat"", ""The setTimeZone() method is used to set the time zone for the SimpleDateFormat class."", ""setTimeZone()"")"
The setTimeZone() method takes an Java TimeZone instance (java.util.TimeZone) as parameter.,NULL
"Of these ISO time zone formats, the Java SimpleDateFormat class only supports the second format (+hhmm), or the format ending with the Z character.","(""Java"", ""SimpleDateFormat is a class within the Java package"", ""SimpleDateFormat"")"
"This is to make the SimpleDateFormat class treat them as literal characters to be inserted, instead of trying to interpret them as representing some part of the date.",NULL
"The Java BufferedInputStream class, java.io.BufferedInputStream, provides transparent reading of chunks of bytes and buffering for a Java InputStream, including any subclasses of InputStream.","(""BufferedInputStream"", ""BufferedInputStream is a subclass of InputStream, providing additional functionality like buffered reading."", ""InputStream""); (""BufferedInputStream"", ""The package 'java.io.BufferedInputStream' includes the class 'BufferedInputStream', indicating its location in the Java library."", ""java.io.BufferedInputStream""); (""BufferedInputStream"", ""BufferedInputStream is a subclass of InputStream, providing additional functionality like buffered reading."", ""InputStream""); (""BufferedInputStream"", ""The package 'java.io.BufferedInputStream' includes the class 'BufferedInputStream', indicating its location in the Java library."", ""java.io.BufferedInputStream"")"
"The BufferedInputStream creates a byte array internally, and attempts to fill the array by calling the InputStream.read(byte[]) methods on the underlying InputStream.","(""BufferedInputStream"", ""BufferedInputStream is related to InputStream as it uses an underlying InputStream for reading data."", ""InputStream""); (""BufferedInputStream"", ""BufferedInputStream calls read(byte[]) which is a method in InputStream to fill its byte array internally."", ""read(byte[])"")"
An interesting aspect to note about the BufferedInputStream is that is supports the mark() and reset() methods inherited from the InputStream.,"(""BufferedInputStream"", ""The BufferedInputStream class supports the mark() method."", ""mark""); (""BufferedInputStream"", ""The BufferedInputStream class supports the reset() method."", ""reset""); (""BufferedInputStream"", ""The BufferedInputStream class inherits methods, including mark() and reset(), from the InputStream class."", ""InputStream"")"
"In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not, but the BufferedInputStream supports them.","(""Marksupported"", ""The Marksupported method is used to determine if the Mark method is supported."", ""Mark""); (""Marksupported"", ""The Marksupported method is used to determine if the Reset method is supported."", ""Reset""); (""Bufferedinputstream"", ""The BufferedInputStream class supports the Mark method."", ""Mark""); (""Bufferedinputstream"", ""The BufferedInputStream class supports the Reset method."", ""Reset"")"
You close a BufferedInputStream by calling the close() method inherited from InputStream.,"(""BufferedInputStream"", ""The BufferedInputStream class uses the close method to close the stream."", ""close""); (""close"", ""The close method is inherited from the InputStream class."", ""InputStream"")"
Notice how the while loop continues until a -1 value is read from the BufferedInputStream read() method.,"(""BufferedInputStream"", ""The read() method is a function provided by the BufferedInputStream class."", ""read"")"
"After that, the while loop exits, and the BufferedInputStream close() method is called.","(""BufferedInputStream"", ""The close method is a function that is called on the BufferedInputStream class to terminate or close it after operations are completed."", ""close"")"
"If an exception is thrown while reading data from the BufferedInputStream, the close() method is never called.","(""BufferedInputStream"", ""The 'close()' method is associated with the BufferedInputStream class, as it is a method called to manage its resources."", ""close()""); (""BufferedInputStream"", ""The 'close()' method is associated with the BufferedInputStream class, as it is a method called to manage its resources."", ""close()"")"
Proper exception handling for use of Java IO classes is also explained in my tutorial on Java IO Exception Handling.,"(""Java IO"", ""Java IO classes require Exception Handling to manage input/output errors."", ""Exception Handling""); (""Exception Handling"", ""The Java IO Exception Handling tutorial is about applying Exception Handling to Java IO."", ""Java IO Exception Handling"")"
"The setSource() method actually returns a reference to the ReusableBufferedInputStream, so you can actually create a ReusableBufferedInputStream and set the source in a single instruction:",NULL
"Note, that this implementation only overrides the read() method of the InputStream class that it extends.","(""Read"", ""The Read method is part of, and specifically overrides a method in, the InputStream class."", ""InputStream"")"
"The Java BufferedOutputStream class, java.io.BufferedOutputStream, is used to capture bytes written to the BufferedOutputStream in a buffer, and write the whole buffer in one batch to an underlying Java OutputStream for increased performance.","(""BufferedOutputStream"", ""BufferedOutputStream writes its buffer to an underlying OutputStream to improve performance"", ""OutputStream""); (""java.io.BufferedOutputStream"", ""java.io.BufferedOutputStream is the fully qualified name of the BufferedOutputStream class"", ""BufferedOutputStream"")"
The only difference is that you may need to call flush() if you need to be absolutely sure that the data written until now is flushed out of the buffer and onto the network or disk.,"(""Flush"", ""Flush is called to ensure that data is cleared out of the Buffer and onto the network or disk"", ""Buffer"")"
To write data to a Java BufferedOutputStream you can use its write() method.,"(""BufferedOutputStream"", ""The write method is used within the BufferedOutputStream class to write data."", ""write"")"
The write() method takes an int which contains the byte value of the byte to write.,"(""Write"", ""The `Write` method takes an `Int` as an argument, indicating a usage relationship."", ""Int""); (""Int"", ""The `Int` class is used to represent or process `Byte` values."", ""Byte""); (""Write"", ""The `Write` method takes an `Int` as an argument, indicating a usage relationship."", ""Int""); (""Int"", ""The `Int` class is used to represent or process `Byte` values."", ""Byte"")"
Here is an example of writing data to a Java BufferedOutputStream using its write() method:,"(""BufferedOutputStream"", ""The write() method is a part of the BufferedOutputStream class"", ""write()"")"
"Since the Java BufferedOutputStream is a subclass of OutputStream, you can write arrays of bytes to the BufferedOutputStream too, instead of just a single byte at a time.","(""Java BufferedOutputStream"", ""The Java BufferedOutputStream is a subclass of OutputStream, indicating an inheritance relationship."", ""OutputStream"")"
If you want to make sure that all written data is written to disk without having to close the BufferedOutputStream you can call its flush() method.,"(""BufferedOutputStream"", ""The `flush` method is called on the `BufferedOutputStream` class to ensure all data is written to disk."", ""flush"")"
"Calling flush() will make sure that all data which has been written to the BufferedOutputStream so far, is fully written to the underlying OutputStream too, plus flush() will also have been called on the underlying OutputStream.","(""flush()"", ""The method flush() is explicitly called on the BufferedOutputStream to ensure data is fully written."", ""BufferedOutputStream""); (""flush()"", ""The method flush() ensures that it will also be called on the underlying OutputStream after being executed on the BufferedOutputStream."", ""OutputStream""); (""BufferedOutputStream"", ""BufferedOutputStream utilizes the underlying OutputStream to fully write the data."", ""OutputStream"")"
Here is an example of calling the Java BufferedOutputStream flush() method:,"(""BufferedOutputStream"", ""The flush() method is a function of the BufferedOutputStream class, indicating the class-method relationship."", ""flush""); (""BufferedOutputStream"", ""The flush() method is a function of the BufferedOutputStream class, indicating the class-method relationship."", ""flush"")"
"The concrete implementations of hasMoreData() and getMoreData() are left out, but they are not really super important to understand the principle of this example.","(""HasmoredData"", ""Both are methods involved in data handling mechanisms"", ""GetMoreData"")"
"What matters is, that once the while loop ends, and you are done writing data to the BufferedOutputStream, its close() method is called, which closes the BufferedOutputStream .","(""Close()"", ""The close() method is specifically called on the BufferedOutputStream, indicating a direct functional relationship where the method performs an action on the class."", ""BufferedOutputStream""); (""While Loop"", ""The while loop is mentioned in the context of writing data to and closing BufferedOutputStream, suggesting an operational sequence or context where the while loop is used to manage the data writing process to BufferedOutputStream."", ""BufferedOutputStream""); (""Close()"", ""The close() method is specifically called on the BufferedOutputStream, indicating a direct functional relationship where the method performs an action on the class."", ""BufferedOutputStream""); (""While Loop"", ""The while loop is mentioned in the context of writing data to and closing BufferedOutputStream, suggesting an operational sequence or context where the while loop is used to manage the data writing process to BufferedOutputStream."", ""BufferedOutputStream"")"
"In case the write() method throws an exception, the close() method will never get called.","(""WRITE"", ""The WRITE method and the CLOSE method are mentioned in the context of exception handling, indicating that they are related through their sequence of execution."", ""CLOSE"")"
"Once the try block is exited, the close() method of the BufferedOutputStream is called automatically, because the BufferedOutputStream was declared inside the parentheses of the try block.","(""BufferedOutputStream"", ""The close() method is called on the BufferedOutputStream class when the try block is exited, indicating an object-method relationship."", ""close"")"
"Even if an exception is thrown from inside the try block, the close() method is still called before the exception is propagated up the call stack.",NULL
"The Java BufferedReader class, java.io.BufferedReader, provides buffering for your Java Reader instances.","(""BufferedReader"", ""BufferedReader is a class within the java.io package"", ""java.io.BufferedReader""); (""BufferedReader"", ""BufferedReader provides buffering for Reader instances"", ""Reader"")"
"The Java BufferedReader class is a subclass of the Java Reader class, so you can use a BufferedReader anywhere a Reader is required.",NULL
Each character returned from read() is thus returned from this internal array.,NULL
The readLine() method will return a textual line (all text until at line break is found) read from the BufferedReader.,"(""readLine()"", ""The readLine() method operates on the BufferedReader class to read a line of text."", ""BufferedReader""); (""readLine()"", ""The readLine() method operates on the BufferedReader class to read a line of text."", ""BufferedReader"")"
"If there is no more data to read from the underlying Reader, then the BufferedReader's readLine() method will return null .","(""BufferedReader"", ""The readLine method belongs to the BufferedReader class, as it is a method that operates on instances of this class."", ""readLine""); (""BufferedReader"", ""BufferedReader uses an underlying Reader to read data, indicating a relationship where BufferedReader is dependent on the Reader for its functionality."", ""Reader"")"
The read() method of a Java BufferedReader returns an int which contains the char value of the next character read.,"(""Read"", ""The 'read' method is a part of the 'BufferedReader' class, as it is used in conjunction with it."", ""BufferedReader"")"
"If the read() method returns -1, there is no more data to read in the BufferedReader, and it can be closed.","(""Read"", ""The 'read' method is used to read data from the 'BufferedReader'"", ""BufferedReader"")"
"If not, it processes that char and continues reading until -1 is returned from the BufferedReader read() method.","(""BufferedReader"", ""The read method is a function of the BufferedReader class."", ""read""); (""BufferedReader"", ""The read method is a function of the BufferedReader class."", ""read"")"
"As mentioned earlier, the BufferedReader will actually read an array of characters from the underlying Reader and return these characters one by one, rather than forwarding every read() call to the underlying Reader.","(""BufferedReader"", ""BufferedReader reads an array of characters from the underlying Reader and returns these characters one by one"", ""Reader""); (""BufferedReader"", ""BufferedReader forwards every read() call to the underlying Reader"", ""read"")"
"The Java BufferedReader class also has a read() method that takes a char array as parameter, as well as a start offset and length.","(""BufferedReader"", ""The 'read' method belongs to the 'BufferedReader' class as it is described as a method within the class context."", ""read"")"
The char array is where the read() method will read the characters into.,NULL
The offset parameter is where in the char array the read() method should start reading into.,"(""Read"", ""The offset parameter indicates where the read method should start reading into the char array."", ""Offset"")"
The length parameter is how many characters the read() method should read into the char array from the offset and forward.,"(""Read"", ""The read() method reads data into the char array based on the specified length."", ""Char Array""); (""Read"", ""The read() method starts reading from the specified offset."", ""Offset"")"
The Java BufferedReader has a special read method named readLine() which reads a full line of text from the BufferedReader's internal buffer.,NULL
"If there are no more lines to read from the BufferedReader, the readLine() method returns null.",NULL
The Java BufferedReader class has a method named skip() which can be used to skip over a number of characters in the input that you do not want to read.,"(""BufferedReader"", ""The method skip() belongs to the BufferedReader class, indicating a class-method relationship."", ""skip"")"
You pass the number of characters to skip as parameter to the skip() method.,NULL
Notice how there is no longer any explicit close() method call.,NULL
"The setSource() method actually returns a reference to the ReusableBufferedReader, so you can actually create a ReusableBufferedReader and set the source in a single instruction:",NULL
"Note, that this implementation only overrides the read() and read(char[] dest, int offset, int length) methods of the Reader class that it extends.","(""Read"", ""The 'read' methods belong to the 'Reader' class, as they are overridden in this class."", ""Reader"")"
"The Java BufferedWriter is a Java Writer subclass, so it can be used anywhere a Writer is required.",NULL
The BufferedWriter adds one extra method though: The newLine() method which can write a new-line character to the underlying Writer.,"(""newLine"", ""The newLine method writes a new-line character to the underlying Writer class."", ""Writer""); (""BufferedWriter"", ""The BufferedWriter class adds the newLine method."", ""newLine"")"
"In addition, you may need to call flush() if you need to be absolutely sure that the characters written until now is flushed out of the buffer and onto the network or disk.",NULL
"Since the BufferedWriter collects the characters written internally in a buffer before writing them to the underlying Writer, the speedup is not as noticeable as with other Writer classes (that do not use buffering).","(""BufferedWriter"", ""BufferedWriter relies on the underlying Writer for output, indicating a dependency relationship."", ""Writer""); (""BufferedWriter"", ""BufferedWriter is a type of Writer class, indicating a classification or inheritance relationship."", ""Writer classes"")"
The Java BufferedWriter's flush() method flushes all data written to the BufferedWriter to the underlying data destination.,"(""flush()"", ""The flush() method is associated with the BufferedWriter class as it flushes all data written to the BufferedWriter to the underlying data destination."", ""BufferedWriter"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your BufferedWriter has).","(""flush()"", ""flush() is a method of the BufferedWriter class."", ""BufferedWriter""); (""flush()"", ""flush() is a method of the BufferedWriter class."", ""BufferedWriter"")"
Here is an example of flushing data written to a Java BufferedWriter by calling its flush() method:,NULL
"The Java ByteArrayInputStream class, java.io.ByteArrayInputStream, of the Java IO API enables you to read data from byte arrays as streams of bytes.",NULL
"In other words, the ByteArrayInputStream class can turn a byte array into an InputStream.","(""ByteArrayInputStream"", ""The ByteArrayInputStream class turns a byte array into an InputStream."", ""InputStream"")"
"The ByteArrayInputStream class is a subclass of the InputStream class, so you can use a ByteArrayInputStream as an InputStream.","(""ByteArrayInputStream"", ""The ByteArrayInputStream class is a subclass of the InputStream class."", ""InputStream"")"
The ByteArrayInputStream also has a set of additional methods that are specific to the ByteArrayInputStream class.,NULL
To use a Java ByteArrayInputStream you must first create an instance of the ByteArrayInputStream class.,NULL
"You read bytes from a Java ByteArrayInputStream just like you would from a regular InputStream, via its read() method.","(""ByteArrayInputStream"", ""ByteArrayInputStream is a type of InputStream in Java."", ""InputStream""); (""read"", ""The read method belongs to the ByteArrayInputStream class."", ""ByteArrayInputStream""); (""read"", ""The read method is used with InputStream classes."", ""InputStream"")"
"The read() will return the next byte from the byte array, or -1 if the end of the byte array (or byte array section) has been reached.","(""Read"", ""method""); (""Read"", ""method"")"
The Java ByteArrayInputStream available() method tells you how many bytes are still available in the ByteArrayInputStream.,NULL
The mark() method of the ByteArrayInputStream class sets an internal mark at the current byte position - meaning right after the previous byte read.,NULL
"The mark() method takes a parameter telling how many bytes can be read past this mark, before this mark becomes invalid.",NULL
Here is an example of setting a mark in a ByteArrayInputStream via its mark() method:,NULL
The reset() method of the ByteArrayInputStream resets how far it has read into the byte array.,"(""reset"", ""The reset method is part of the ByteArrayInputStream class, as it resets how far it has read into the byte array."", ""ByteArrayInputStream"")"
The Java ByteArrayInputStream skip() method enables you to skip over a number of bytes from the underlying byte array.,"(""ByteArrayInputStream"", ""The method 'skip' is part of the 'ByteArrayInputStream' class and is used to skip over bytes."", ""skip"")"
Here is an example of skipping over a number of bytes using the ByteArrayInputStream skip() method:,NULL
Notice how the while loop continues until a -1 value is read from the ByteArrayInputStream read() method.,NULL
"After that, the while loop exits, and the ByteArrayInputStream close() method is called.",NULL
"If an exception is thrown while reading data from the ByteArrayInputStream, the close() method is never called.","(""ByteArrayInputStream"", ""The close method is associated with the ByteArrayInputStream class as it pertains to the process of closing streams after data operations."", ""close"")"
"The Java ByteArrayOutputStream class, java.io.ByteArrayOutputStream of the Java IO API enables you to capture data written to a stream in a byte array.","(""ByteArrayOutputStream"", ""ByteArrayOutputStream is another way to refer to the java.io.ByteArrayOutputStream within the Java IO package, indicating they are the same class."", ""java.io.ByteArrayOutputStream""); (""java.io.ByteArrayOutputStream"", ""The java.io.ByteArrayOutputStream class is part of the Java IO package, indicating a hierarchical relationship."", ""Java IO"")"
You write your data to the ByteArrayOutputStream and when you are done you call the its toByteArray() method to obtain all the written data in a byte array.,"(""ByteArrayOutputStream"", ""The toByteArray method is used to obtain all the written data from a ByteArrayOutputStream."", ""toByteArray"")"
"Since the Java ByteArrayOutputStream class is a subclass of the Java OutputStream class, you write bytes to it using the same write methods that OutputStream has:","(""ByteArrayOutputStream"", ""ByteArrayOutputStream is a subclass of OutputStream."", ""OutputStream""); (""OutputStream"", ""The write method belongs to the OutputStream class."", ""write"")"
"Once you have finished writing to the ByteArrayOutputStream you can obtain all the bytes written as a Java byte array, using the ByteArrayOutputStream toByteArray() method.","(""ByteArrayOutputStream"", ""The toByteArray() method is a function of the ByteArrayOutputStream class used to retrieve the written byte data as a Java byte array."", ""toByteArray()"")"
Being a subclass of OutputStream the ByteArrayOutputStream also has a close() method.,NULL
But calling the close() method has no effect on the ByteArrayOutputStream.,"(""close()"", ""The method 'close()' is mentioned in context as having no effect on instances of the class 'ByteArrayOutputStream'."", ""ByteArrayOutputStream""); (""close()"", ""The method 'close()' is mentioned in context as having no effect on instances of the class 'ByteArrayOutputStream'."", ""ByteArrayOutputStream"")"
"The Java DataInputStream class, java.io.DataInputStream, enables you to read Java primitives (int, float, long etc.)","(""DataInputStream"", ""The class DataInputStream belongs to the package java.io."", ""java.io.DataInputStream"")"
"The Java DataInputStream class is a subclass of InputStream, so DataInputStream also has the basic read methods that enable you to read a single byte or an array of bytes from the underlying InputStream, in case you need that.","(""Java DataInputStream"", ""Java DataInputStream is a subclass of InputStream."", ""InputStream""); (""Java DataInputStream"", ""Java DataInputStream has read methods to read bytes from InputStream."", ""read"")"
"As mentioned earlier, the DataInputStream class is often used together with a DataOutputStream.","(""DataInputStream"", ""DataInputStream is often used together with DataOutputStream, indicating a functional relationship."", ""DataOutputStream""); (""DataInputStream"", ""DataInputStream is often used together with DataOutputStream, indicating a functional relationship."", ""DataOutputStream""); (""DataInputStream"", ""DataInputStream is often used together with DataOutputStream, indicating a functional relationship."", ""DataOutputStream"")"
You can read a Java boolean from the DataInputStream using its readBoolean() method.,"(""readBoolean"", ""The readBoolean method belongs to the DataInputStream class."", ""DataInputStream"")"
Here is an example of reading a boolean from a Java DataInputStream using readBoolean():,"(""readBoolean"", ""The method readBoolean belongs to the class DataInputStream, illustrating a class-method relationship."", ""DataInputStream"")"
You can read a Java byte from the DataInputStream using its readByte() method.,"(""DataInputStream"", ""The readByte method is used by the DataInputStream class to read a Java byte."", ""readByte"")"
Here is an example of reading a byte from a Java DataInputStream using readByte():,"(""DataInputStream"", ""The method readByte() is used by the class DataInputStream to read a byte from an input stream."", ""readByte()"")"
You can read a Java unsigned byte (only positive values) from the DataInputStream using its readUnsignedByte() method.,"(""DataInputStream"", ""The readUnsignedByte method belongs to the DataInputStream class."", ""readUnsignedByte"")"
Here is an example of reading an unsigned byte from a Java DataInputStream using readUnsignedByte():,"(""DataInputStream"", ""The readUnsignedByte method is a part of or used with the DataInputStream class in Java."", ""readUnsignedByte""); (""DataInputStream"", ""The readUnsignedByte method is a part of or used with the DataInputStream class in Java."", ""readUnsignedByte"")"
You can read a Java char from the DataInputStream using its readChar() method.,NULL
Here is an example of reading a char from a Java DataInputStream using readChar():,NULL
You can read a Java double from the DataInputStream using its readDouble() method.,NULL
Here is an example of reading a double from a Java DataInputStream using readDouble():,"(""DataInputStream"", ""The method readDouble() is used with the class DataInputStream to read a double value."", ""readDouble""); (""DataInputStream"", ""The method readDouble() is used with the class DataInputStream to read a double value."", ""readDouble"")"
You can read a Java float from the DataInputStream using its readFloat() method.,NULL
Here is an example of reading a float from a Java DataInputStream using readFloat():,"(""DataInputStream"", ""The method readFloat() is used to read a float from a DataInputStream."", ""readFloat"")"
You can read a Java short from the DataInputStream using its readShort() method.,"(""DataInputStream"", ""The readShort method belongs to the DataInputStream class, as it is called using its instance."", ""readShort"")"
Here is an example of reading a short from a Java DataInputStream using readShort():,"(""DataInputStream"", ""The method readShort() is used to read data from instances of the DataInputStream class."", ""readShort"")"
You can read a Java unsigned short (only positive values) from the DataInputStream using its readUnsignedShort() method.,NULL
Here is an example of reading an unsigned short from a Java DataInputStream using readUnsignedShort():,"(""DataInputStream"", ""The method readUnsignedShort is often used with the DataInputStream class to read an unsigned short value."", ""readUnsignedShort"")"
You can read a Java int from the DataInputStream using its readInt() method.,NULL
Here is an example of reading an int from a Java DataInputStream using readInt():,NULL
You can read a Java long from the DataInputStream using its readLong() method.,NULL
Here is an example of reading an int from a Java DataInputStream using readLong():,"(""DataInputStream"", ""The method readLong() is used in conjunction with the DataInputStream class, indicating a functional relationship where readLong() is likely a method callable on an instance of the DataInputStream class."", ""readLong"")"
You can read a Java String from the DataInputStream using its readUTF() method.,NULL
Here is an example of reading a String from a Java DataInputStream using readUTF():,"(""DataInputStream"", ""DataInputStream provides the readUTF method to read UTF-8 encoded text from a stream."", ""readUTF""); (""Java"", ""DataInputStream is a class within the Java package."", ""DataInputStream"")"
"The Java File class, java.io.File in the Java IO API gives you access to the underlying file system.","(""FILE"", ""The File class is a part of the java.io package, which is indicated by its naming convention java.io.File."", ""JAVA.IO.FILE""); (""FILE"", ""The File class is a component of the Java IO API, suggesting it provides file system access functionalities within this API."", ""JAVA IO API"")"
Note: The Java File class only gives you access to the file and directory meta data.,"(""File"", ""class""); (""File"", ""class"")"
Note: If you are want to Java NIO (Java's non-blocking IO API) you will have to use the java.nio.FileChannel class instead.,NULL
"Both Java File and FileChannel works, but in case you want a pure Java NIO solution use the Java NIO FileChannel class.","(""Java File"", ""The Java File works with Java NIO to provide functionalities in Java."", ""Java NIO""); (""FileChannel"", ""FileChannel is part of the Java NIO package, indicating its use in the NIO system for file operations."", ""Java NIO"")"
"Before you can do anything with the file system or File class, you must create a Java File instance.",NULL
The Java File class also has a few other constructors you can use to instantiate File instances in different ways.,NULL
You can check if a file referenced by a Java File object exists using the File exists() method.,"(""File"", ""The exists() method is a function provided by the File class."", ""exists""); (""Java"", ""The File class is part of the Java package."", ""File"")"
You can use the Java File class to create directories if they don't already exists.,NULL
The File class contains the method mkdir() and mkdirs() for that purpose.,"(""File"", ""The mkdir method is a function within the File class."", ""mkdir""); (""File"", ""The mkdirs method is a function within the File class."", ""mkdirs"")"
The mkdir() method creates a single directory if it does not already exist.,NULL
Here is an example of creating a single directory via the Java File class:,NULL
"The mkdir() returns true if the directory was created, and false if not.",NULL
The mkdirs() will create all directories that are missing in the path the File object represents.,"(""Mkdirs"", ""The method mkdirs() is related to the File class because it operates on File objects to create the directories in the specified path."", ""File"")"
Here is an example of creating multiple directories via the Java File class:,"(""File"", ""class""); (""File"", ""class""); (""File"", ""class"")"
"The mkdirs() method will return true if all the directories were created, and false if not.",NULL
The Java File class enables you to read the length in bytes of a file.,"(""Java"", ""The File class is a component of the Java package."", ""File""); (""File"", ""The File class provides the read method to access file content."", ""read"")"
"To read the length of a file, call the File length() method.","(""File"", ""The method length is called on the File class to read the file's length."", ""length"")"
Here is an example of reading the length of a file via the Java File length() method:,"(""File"", ""The length() method is a function of the File class that allows you to determine the size of the file."", ""length()""); (""Java"", ""The File class is part of the Java package, which provides functionality for working with files."", ""File"")"
"To rename (or move) a file, call the method renameTo() on the File class.",NULL
"As briefly mentioned earlier, the renameTo() method can also be used to move a file to a different directory.","(""RenameTo"", ""RenameTo method is used to move a file to a different directory"", ""File"")"
The new file name passed to the renameTo() method does not have to be in the same directory as the file was already residing in.,"(""RenameTo"", ""The renameTo method involves changing the name of a file, indicating a relationship between the method and the file."", ""File"")"
"The renameTo() method returns boolean (true or false), indicating whether the renaming was successful.",NULL
"The Java File renameTo() method also works for directories, by the way.","(""File"", ""The renameTo method is associated with the File class in Java, which allows file and directory renaming operations"", ""renameTo""); (""File"", ""The renameTo method is associated with the File class in Java, which allows file and directory renaming operations"", ""renameTo"")"
"The delete() method returns boolean (true or false), indicating whether the deletion was successful.","(""Delete"", ""The Delete method returns a Boolean value indicating the success of the deletion operation."", ""Boolean"")"
"The Java File delete() method also works for directories, meaning you can also delete directories with it.",NULL
The Java File delete() method can only delete a directory if the directory is empty.,"(""File"", ""The delete() method is a member of the File class."", ""delete()"")"
"You can check if a File object points to a file or directory, by calling its isDirectory() method.",NULL
You can obtain a list of all the files in a directory by calling either the Java File list() method or the listFiles() method.,"(""File"", ""The list method is related to the File class as it is a method under this class."", ""list""); (""File"", ""The listFiles method is related to the File class as it is another method available under this class."", ""listFiles""); (""File"", ""The list method is related to the File class as it is a method under this class."", ""list""); (""File"", ""The listFiles method is related to the File class as it is another method available under this class."", ""listFiles"")"
The list() method returns an array of String's with the file and / or directory names of directory the File object points to.,"(""List"", ""The list() method returns an array of String objects, indicating that list() generates or operates with String class objects."", ""String""); (""List"", ""The list() method is called on a File object, suggesting that this method is an operation belonging to or associated with the File class."", ""File"")"
The listFiles() returns an array of File objects representing the files and / or directories in the directory the File points to.,"(""listFiles()"", ""The method listFiles() returns an array of File objects, indicating a relationship where listFiles() outputs File instances."", ""File"")"
Here is an example of listing all files in a directory via the Java File list() and listFiles() methods:,NULL
"The Java FileInputStream class, java.io.FileInputStream, makes it possible to read the contents of a file as a stream of bytes.",NULL
"Note also, that since FileInputStream is a subclass of InputStream, we can cast the created FileInputStream to an InputStream everywhere we want to, as we do in the example above.","(""FileInputStream"", ""FileInputStream is a subclass of InputStream, indicating an inheritance relationship between the two."", ""InputStream"")"
The FileInputStream class has a three different constructors you can use to create a FileInputStream instance.,NULL
"Actually, in my experience Java will also understand if you use a / as directory separator on Windows (e.g.",NULL
The read() method of a FileInputStream returns an int which contains the byte value of the byte read.,"(""Read"", ""The read method is a function belonging to the FileInputStream class, indicating it operates on or is defined within this class."", ""FileInputStream"")"
"If the read() method returns -1, there is no more data to read in the FileInputStream, and it can be closed.","(""Read"", ""The read method is associated with FileInputStream as it reads data from the FileInputStream."", ""FileInputStream"")"
You use the read() method just like the read() method of an InputStream.,"(""Read"", ""The read() method is used in the context of InputStream, indicating a functional relationship where read() is a method belonging to InputStream."", ""InputStream"")"
Being an InputStream the FileInputStream also has two read() methods which can read data into a byte array.,NULL
"These methods are inherited from the Java InputStream class, by the way.",NULL
"If all bytes have been read from the FileInputStream, these read() methods will return -1.","(""FileInputStream"", ""The read method is related to the FileInputStream class because it is a method used to read bytes from an instance of this class."", ""read"")"
Therefore it is necessary to inspect the value returned from these read() method calls.,NULL
The doSomethingWithData() method implementation has been left out of this example to keep it short.,NULL
"Notice, that a BufferedInputStream is an InputStream subclass and can be used in any place where an InputStream can be used.",NULL
You close a FileInputStream by calling the close() method inherited from InputStream.,"(""FileInputStream"", ""FileInputStream is a subclass of InputStream, and thus inherits its methods, including close()"", ""InputStream""); (""close"", ""close is a method inherited from the InputStream class"", ""InputStream"")"
Notice how the while loop continues until a -1 value is read from the FileInputStream read() method.,"(""FileInputStream"", ""The 'read' method is associated with the 'FileInputStream' class for reading data."", ""read"")"
"After that, the while loop exits, and the FileInputStream close() method is called.",NULL
"If an exception is thrown while reading data from the FileInputStream, the close() method is never called.",NULL
"The Java FileOutputStream class, java.io.FileOutputStream, makes it possible to write a file as a stream of bytes.","(""FileOutputStream"", ""The class FileOutputStream belongs to the package java.io.FileOutputStream."", ""java.io.FileOutputStream"")"
The Java FileOutputStream class is a subclass of Java OutputStream meaning you can use a FileOutputStream as an OutputStream.,NULL
The Java FileOutputStream class contains a set of different useful constructors.,"(""FileOutputStream"", ""The 'FileOutputStream' class contains a set of constructors."", ""Constructors"")"
To write data to a Java FileOutputStream you can use its write() method.,"(""FileOutputStream"", ""The 'write' method is a function of the 'FileOutputStream' class used for writing data."", ""write"")"
Here is an example of writing data to a Java FileOutputStream using its write() method:,"(""FileOutputStream"", ""The write() method is used with the FileOutputStream class to write data."", ""write""); (""FileOutputStream"", ""The write() method is used with the FileOutputStream class to write data."", ""write"")"
"Since the Java FileOutputStream is a subclass of OutputStream, you can write arrays of bytes to the FileOutputStream too, instead of just a single byte at a time.","(""FileOutputStream"", ""FileOutputStream is a subclass of OutputStream, indicating an inheritance relationship."", ""OutputStream"")"
If you want to make sure that all written data is written to disk without having to close the FileOutputStream you can call its flush() method.,NULL
"Calling flush() will make sure that all data which has been written to the FileOutputStream so far, is fully written to disk too.","(""Flush"", ""The method 'flush()' is called on the FileOutputStream class to ensure all data is written to disk."", ""FileOutputStream"")"
Here is an example of calling the Java FileOutputStream flush() method:,NULL
Here is an example of closing a Java FileOutputStream by calling its close() method:,"(""Fileoutputstream"", ""The 'Close' method is called to close the 'Fileoutputstream'."", ""Close"")"
"Unfortunately, if an exception is thrown during the write() call in the example above, that exception will cause the program flow to break before the close() method is called.","(""WRITE"", ""An exception thrown during the write() method can prevent the call to the close() method, indicating an execution sequence."", ""CLOSE""); (""WRITE"", ""An exception thrown during the write() method can prevent the call to the close() method, indicating an execution sequence."", ""CLOSE"")"
"In other words, the FileOutputStream close() will be called automatically for you.","(""FileOutputStream"", ""The method 'close' is a function that operates within the class 'FileOutputStream'."", ""close"")"
You can convert a FileOutputStream to a character based Writer using the Java OutputStreamWriter class.,"(""FileOutputStream"", ""OutputStreamWriter is used to convert a FileOutputStream to a character-based Writer."", ""OutputStreamWriter""); (""OutputStreamWriter"", ""OutputStreamWriter is a type of Writer used for handling character-based writing."", ""Writer"")"
"The Java FileReader class, java.io.FileReader makes it possible to read the contents of a file as a stream of characters.","(""FILEREADER"", ""The FileReader class is part of the java.io.FileReader package, indicating a hierarchical relationship where the class is housed within the package."", ""JAVA.IO.FILEREADER"")"
"The Java FileReader is a subclass of the Java Reader class, so it has many of the same methods.",NULL
The read() method of the Java FileReader returns an int which contains the char value of the character read.,NULL
"If the read() method returns -1, there is no more data to read in the FileReader, and it can be closed.","(""READ"", ""The read method is executed on the FileReader class to check if there is more data to read."", ""FILEREADER"")"
"Notice, that a BufferedReader is a Reader subclass and can be used in any place where an Reader can be used.","(""BufferedReader"", ""BufferedReader is a subclass of Reader, indicating inheritance relationship"", ""Reader"")"
Notice how there is no longer any explicit close() method call to the FileReader instance.,"(""FileReader"", ""The close() method is typically associated with the FileReader class for closing the resource."", ""close()"")"
"The Java FileWriter class, java.io.FileWriter, makes it possible to write characters to a file.",NULL
"The Java FileWriter class is a subclass of the Java Writer class, by the way.",NULL
The Java FileWriter's flush() method flushes all data written to the FileWriter to the underlying file.,NULL
By calling flush() you can assure that any buffered data will be flushed (written) to disk.,"(""Flush"", ""method""); (""Flush"", ""method"")"
Here is an example of flushing data written to a Java FileWriter by calling its flush() method:,NULL
Notice how there is no longer any explicit close() method call to the FileWriter instance.,"(""FileWriter"", ""The close method is typically associated with handling instances of the FileWriter class to release resources."", ""close"")"
"The Java InputStream class, java.io.InputStream, represents an ordered stream of bytes.","(""InputStream"", ""The Java InputStream class is part of the java.io.InputStream package, representing their hierarchical relationship."", ""java.io.InputStream"")"
The Java InputStream class is the base class (superclass) of all input streams in the Java IO API.,"(""Java InputStream"", ""The Java InputStream class is a part of the Java IO API."", ""Java IO"")"
"Each subclass of InputStream typically has a very specific use, but can be used as an InputStream.",NULL
FileInputStream is a subclass of InputStream so it is safe to assign an instance of FileInputStream to an InputStream variable (the inputstream variable).,"(""FileInputStream"", ""FileInputStream is a subclass of InputStream, indicating an inheritance relationship between the two classes."", ""InputStream"")"
The read() method of an InputStream returns an int which contains the byte value of the byte read.,"(""Read"", ""The read method is a function of the InputStream class."", ""InputStream"")"
"If the read() method returns -1, the end of stream has been reached, meaning there is no more data to read in the InputStream.",NULL
The InputStream class also contains two read() methods which can read data from the InputStream's source into a byte array.,"(""InputStream"", ""The read methods are part of the InputStream class as they are used to read data from the InputStream's source."", ""read"")"
"Inside the while loop the doSomethingWithData() method is called, passing along the data byte array as well as how many bytes were read into the array as parameters.","(""DoSomethingWithData"", ""The method 'DoSomethingWithData' operates on the class 'Data'."", ""Data"")"
The Java InputStream class contains a method called readAllBytes() (since Java 9).,"(""InputStream"", ""The method readAllBytes() is part of the InputStream class."", ""readAllBytes""); (""Java"", ""The InputStream class is part of the Java package."", ""InputStream"")"
Here is an example of reading all bytes from a Java InputStream via readAllBytes():,NULL
The InputStream class has two methods called mark() and reset() which subclasses of InputStream may or may not support.,"(""InputStream"", ""The method mark() belongs to the InputStream class."", ""mark""); (""InputStream"", ""The method reset() belongs to the InputStream class."", ""reset"")"
"If an InputStream subclass supports the mark() and reset() methods, then that subclass should override the markSupported() to return true.",NULL
If the markSupported() method returns false then mark() and reset() are not supported.,"(""MarkSupported"", ""The Mark method depends on MarkSupported() to determine if it is supported."", ""Mark""); (""MarkSupported"", ""The Reset method is also dependent on MarkSupported() to determine if resetting the stream is supported."", ""Reset"")"
The mark() sets a mark internally in the InputStream which marks the point in the stream to which data has been read so far.,NULL
"If the code using the InputStream wants to go back to the point in the stream where the mark was set, the code calls reset() on the InputStream.",NULL
The methods mark() and reset() methods are typically used when implementing parsers.,NULL
Notice how the while loop continues until a -1 value is read from the InputStream read() method.,NULL
"After that, the while loop exits, and the InputStream close() method is called.",NULL
"If an exception is thrown while reading data from the InputStream, the close() method is never called.",NULL
"The Java InputStreamReader class, java.io.InputStreamReader, wraps a Java InputStream, thereby turning the byte based InputStream into a character based Reader.","(""InputStreamReader"", ""The InputStreamReader wraps the InputStream"", ""InputStream""); (""InputStreamReader"", ""The InputStreamReader turns an InputStream into a Reader"", ""Reader"")"
The Java InputStreamReader class is thus a subclass of the Java Reader class.,"(""InputStreamReader"", ""InputStreamReader is a subclass of Reader, establishing an inheritance relationship."", ""Reader"")"
You can get the character encoding used by a Java InputStreamReader instance via its getEncoding() method.,"(""InputStreamReader"", ""The getEncoding method is used to retrieve the character encoding of an instance of the InputStreamReader class."", ""getEncoding"")"
The read() method of an InputStreamReader returns an int which contains the char value of the char read.,"(""Read"", ""The Read method belongs to the InputStreamReader class."", ""InputStreamReader"")"
"If the read() method returns -1, the end of stream has been reached, meaning there is no more data to read in the InputStreamReader.",NULL
"As you can see, the while loop keeps running until a -1 is read from the InputStreamReader read() method.","(""InputStreamReader"", ""The method `read()` belongs to the class `InputStreamReader`."", ""read()"")"
"Once all the data is written to it, simply call the method toByteArray() or toCharArray, and all the data written is returned in array form.","(""toByteArray"", ""Both methods have a similar functionality of converting written data into arrays."", ""toCharArray"")"
The Java CharArrayReader class (java.io.CharArrayReader) enables you to read the contents of a char array as a character stream.,"(""CharArrayReader"", ""CharArrayReader is a class within the package java.io.CharArrayReader, which indicates its location within the Java library."", ""java.io.CharArrayReader"")"
"The Java CharArrayReader is handy when you have data in a char array, but need to pass that data to some component which can only read from a Reader (or a Reader subclass).","(""CharArrayReader"", ""CharArrayReader is used to pass data from a char array to a component that can read from a Reader"", ""Reader""); (""CharArrayReader"", ""CharArrayReader can also pass data to components that can read from a Reader subclass"", ""Reader subclass"")"
Closing a CharArrayReader can be done using the close() method like this:,NULL
Notice that there is no explicit close() call on the CharArrayReader.,NULL
The Java CharArrayWriter class (java.io.CharArrayWriter) makes it possible to write characters via the Writer methods (CharArrayWriter is a subclass of Writer) and convert the written characters into a char array.,NULL
"The Java CharArrayWriter class is handy when you have a component that can only write characters to a Writer, but you need the characters as a char array.","(""CharArrayWriter"", ""The CharArrayWriter class is related to Writer because it is designed to handle character writing functionalities."", ""Writer"")"
"Simply pass that component a CharArrayWriter and when all characters are written to it, call toCharArray() on the CharArrayWriter.",NULL
"Third, the written characters are obtained as a char array by calling the toCharArray() method on the CharArrayWriter.","(""toCharArray"", ""The toCharArray() method is called on the CharArrayWriter class to obtain written characters as a char array."", ""CharArrayWriter"")"
Notice how there is no longer any explicit close() method call to the CharArrayWriter instance.,NULL
The Java DataOutputStream class enables you to write Java primitives to OutputStream's instead of only bytes.,NULL
"As mentioned earlier, the DataOutputStream class is often used together with a DataInputStream.",NULL
But what happens if an exception is thrown from inside the doSomethingWithData() method?,"(""DOSOMETHINGWITHDATA"", ""METHOD"")"
"Well, to catch that situation you will have to wrap the call to close() in a try-catch block too, like this:",NULL
"But, what happens if an exception is also thrown from the input.close() method?",NULL
"Separate pages will describe each of these methods or classes in more detail, including examples of their usage etc.","(""Separate"", ""Separate is describing various methods"", ""methods""); (""Separate"", ""Separate is describing various classes"", ""classes"")"
The Java IO API contains the following classes which are relevant to working with files in Java:,NULL
"These classes are explained in more detail in their own texts, but the sections below will give a brief introduction to these classes.",NULL
"These two classes lets you read a file one byte or character at a time from the start to the end of the file, or read the bytes into an array of byte or char, again from start towards the end of the file.",NULL
"As I have already mentioned, you can get random access to files with Java IO via the RandomAccessFile class.",NULL
Both file and directory information is available via the File class.,"(""File"", ""class"")"
The FilterInputStream is a base class for implementing your own filtering input streams.,NULL
"It is intended to be a base class for your own subclasses, but in my opinion you might as well just subclass InputStream directly.",NULL
I cannot see that this class actually adds or changes any behaviour in InputStream except that it takes an InputStream in its constructor.,NULL
The FilterOutputStream is a base class for implementing your own filtering output streams.,NULL
I cannot see that this class actually adds or changes any behaviour in OutputStream except that it takes an OutputStream in its constructor.,"(""OutputStream"", ""The constructor method is used to initialize an instance of the OutputStream class."", ""constructor"")"
"If you choose to extend this class you might as well extend the OutputStream class directly, and avoid the extra class in the hierarchy.","(""Outputstream"", ""OutputStream is mentioned as a class that can be extended, indicating a relationship within the class hierarchy."", ""Outputstream"")"
The FilterReader is a base class for implementing your own filtering readers.,NULL
"Like with FilterInputStream, I see no sensible purpose for this class.","(""FilterInputStream"", ""FilterInputStream is explicitly mentioned as a class in the text"", ""Class""); (""source_entity"", ""relationship_description"", ""target_entity"")"
I cannot see that this class actually adds or changes any behaviour in Reader except that it takes a Reader in its constructor.,"(""Reader"", ""The 'Reader' class is instantiated using the 'Reader' method in its constructor"", ""Reader"")"
"If you choose to extend this class you might as well extend the Reader class directly, and avoid the extra class in the hierarchy.","(""Class"", ""The text suggests extending the 'Reader' class directly if extending another class, implying a subclassing relationship between the two."", ""Reader"")"
The FilterWriter is a base class for implementing your own filtering Writer's.,NULL
"Like with FilterOutputStream, I see no sensible purpose for this class.",NULL
I cannot see that this class actually adds or changes any behaviour in Writer except that it takes a Writer in its constructor.,"(""Writer"", ""Writer is taken in its constructor indicating a relationship"", ""Writer Constructor""); (""Writer"", ""Writer is taken in its constructor indicating a relationship"", ""Writer Constructor"")"
"If you choose to extend this class you might as well extend the Writer class directly, and avoid the extra class in the hierarchy.","(""Writer"", ""Writer is a part of or related to the hierarchy as it is suggested to extend it directly."", ""hierarchy"")"
Some of the classes in the Java IO API are designed to help you parse input.,NULL
The purpose was rather to give you above quick list of classes related to parsing of input data.,"(""Classes"", ""Class"")"
If you have to parse data you will often end up writing your own classes that use some of the classes in this list.,NULL
The Java LineNumberReader class (java.io.LineNumberReader is a BufferedReader that keeps track of line numbers of the read characters.,NULL
You can get the current line number from the LineNumberReader by calling the getLineNumber() method.,"(""LineNumberReader"", ""The getLineNumber method is a function that can be called on the LineNumberReader class to retrieve the current line number."", ""getLineNumber"")"
"You can also set the current line number, should you need to, by calling the setLineNumber() method.",NULL
Since FileOutputStream is a subclass of OutputStream this should be no problem.,NULL
In this example the process() method cannot see if the InputStream it gets as parameter comes from the file system or the network (the example only shows the file system version).,NULL
The Java ObjectInputStream class (java.io.ObjectInputStream) enables you to read Java objects from an InputStream instead of just raw bytes.,"(""ObjectInputStream"", ""ObjectInputStream reads Java objects from an InputStream"", ""InputStream""); (""java.io.ObjectInputStream"", ""The package java.io.ObjectInputStream contains the ObjectInputStream class"", ""ObjectInputStream"")"
"For this ObjectInputStream example to work the object you read must be an instance of MyClass, and must have been serialized into the file ""object.data"" via an ObjectOutputStream.",NULL
Before you can serialize and de-serialize objects the class of the object must implement java.io.Serializable.,"(""Class"", ""The class must implement the java.io.Serializable package to enable serialization and de-serialization of objects."", ""Java.io.Serializable""); (""Class"", ""The class must implement the java.io.Serializable package to enable serialization and de-serialization of objects."", ""Java.io.Serializable"")"
"After that the ObjectInputStream is also closed, and the values read into the Person object are printed to System.out.","(""ObjectInputStream"", ""The ObjectInputStream class is used to read data into the Person object."", ""Person""); (""Person"", ""The values read into the Person object are printed to the System.out package."", ""System.out"")"
The Java ObjectOutputStream class (java.io.ObjectOutputStream) enables you to write Java objects to an OutputStream instead of just raw bytes.,"(""Java ObjectOutputStream"", ""The class Java ObjectOutputStream belongs to the Java IO package as indicated by the package path."", ""Java IO"")"
In this text I will try to give you an overview of the classes in the Java IO (java.io) package.,"(""Java IO"", ""Java IO refers to the package java.io, indicating a naming relationship where 'Java IO' is an informal reference to the formal package 'java.io'."", ""java.io"")"
"More specifically, I will try to group the classes after their purpose.",NULL
"This grouping should make it easier for you in the future, to determine the purpose of a class, or find the class you need for a specific purpose.",NULL
"Java IO contains many subclasses of the InputStream, OutputStream, Reader and Writer classes.",NULL
"The reason is, that all of these subclasses are addressing various different purposes.",NULL
These purposes are nice to know about when reading through the Java IO classes.,"(""Java IO"", ""Java IO is a package that typically contains multiple classes within it."", ""Classes"")"
They make it somewhat easier to understand what the classes are targeting.,NULL
"Having discussed sources, destinations, input, output and the various IO purposes targeted by the Java IO classes, here is a table listing most (if not all) Java IO classes divided by input, output, being byte based or character based, and any more specific purpose they may be addressing, like buffering, parsing etc.",NULL
The PipedInputStream class makes it possible to read the contents of a pipe as a stream of bytes.,"(""PipedInputStream"", ""The PipedInputStream class allows reading data from a pipe as a stream of bytes."", ""stream"")"
The read() method of a PipedInputStream returns an int which contains the byte value of the byte read.,"(""PipedInputStream"", ""The read() method is likely part of the PipedInputStream class."", ""read()""); (""PipedInputStream"", ""The read() method is likely part of the PipedInputStream class."", ""read()"")"
"If the read() method returns -1, there is no more data to read in the stream, and it can be closed.",NULL
"Since PipedInputStream is a subclass of InputStream, PipedInputStream has the same basic methods and use patterns as an InputStream.",NULL
The PipedOutputStream class makes it possible to write to a Java pipe as a stream of bytes.,"(""PipedOutputStream"", ""PipedOutputStream is a class within the Java package that provides functionality for handling input/output operations."", ""Java"")"
The write() method of a PipedOutputStream takes an int which contains the byte value of the byte to write.,"(""Write"", ""The write() method is a member of the PipedOutputStream class."", ""PipedOutputStream"")"
"Since PipedOutputStream is a subclass of OutputStream, PipedOutputStream has the same basic methods and use patterns as an OutputStream.",NULL
The Java PipedReader class (java.io.PipedReader) makes it possible to read the contents of a pipe as a stream of characters.,"(""PipedReader"", ""The PipedReader class is part of the java.io package, which provides classes for system input and output through data streams, serialization, and the file system."", ""java.io"")"
The read() method of a Java PipedReader returns an int which contains the char value of the character read.,"(""Read"", ""The Read method is a function of the PipedReader class."", ""PipedReader"")"
"If the read() method returns -1, there is no more data to read in the PipedReader, and it can be closed.",NULL
Notice how there is no longer any explicit close() method call to the PipedReader instance.,"(""CLOSE"", ""The method 'close' is typically used to close or terminate resources associated with classes like 'PipedReader'."", ""PIPEDREADER"")"
The Java PipedWriter class (java.io.PipedWriter) makes it possible to write to a Java pipe as a stream of characters.,NULL
The write() method of a PipedWriter takes an int which contains the byte value of the byte to write.,NULL
"There are also versions of the write() method that take a String, char array etc.","(""Write"", ""Method""); (""Write"", ""Method""); (""Write"", ""Method"")"
Notice how there is no longer any explicit close() method call to the PipedWriter instance.,"(""Close"", ""The 'close' method is typically used to close instances of the 'PipedWriter' class."", ""PipedWriter"")"
Creating a pipe using Java IO is done via the PipedOutputStream and PipedInputStream classes.,"(""Java IO"", ""The PipedOutputStream class is part of the Java IO package."", ""PipedOutputStream""); (""Java IO"", ""The PipedInputStream class is part of the Java IO package."", ""PipedInputStream""); (""PipedOutputStream"", ""The PipedOutputStream class is used in conjunction with the PipedInputStream class to create a pipe."", ""PipedInputStream""); (""Java IO"", ""The PipedOutputStream class is part of the Java IO package."", ""PipedOutputStream""); (""Java IO"", ""The PipedInputStream class is part of the Java IO package."", ""PipedInputStream""); (""PipedOutputStream"", ""The PipedOutputStream class is used in conjunction with the PipedInputStream class to create a pipe."", ""PipedInputStream"")"
You can also connect the two pipe streams using their connect() methods.,NULL
Both PipedInputStream and PipedOutputStream has a connect() method that can connect one to the other.,NULL
"The read() and write() calls on the streams are blocking, meaning if you try to use the same thread to both read and write, this may result in the thread deadlocking itself.",NULL
The Java PrintStream class (java.io.PrintStream) enables you to write formatted data to an underlying OutputStream.,"(""PrintStream"", ""PrintStream is a class within the java.io.PrintStream package."", ""java.io.PrintStream""); (""PrintStream"", ""PrintStream writes formatted data to OutputStream, indicating a functional relationship."", ""OutputStream"")"
"The PrintStream class can format primitive types like int, long etc.",NULL
You may be familiar with these two well-known PrintStream instances in Java: System.out and System.err .,"(""PrintStream"", ""System.out is a well-known instance of the PrintStream class used for output in Java."", ""System.out""); (""PrintStream"", ""System.err is a well-known instance of the PrintStream class used for error output in Java."", ""System.err"")"
"The Java PrintStream class contains the powerful format() and printf() methods (they do exactly the same, but the name ""printf"" is more familiar to C-programmers).","(""PrintStream"", ""The method 'format' is part of the 'PrintStream' class."", ""format""); (""PrintStream"", ""The method 'printf' is part of the 'PrintStream' class."", ""printf"")"
The Java PrintWriter class (java.io.PrintWriter) enables you to write formatted data to an underlying Writer.,"(""PrintWriter"", ""The PrintWriter class writes data to an underlying Writer."", ""Writer""); (""PrintWriter"", ""PrintWriter is part of the java.io package, which provides classes and interfaces for system input and output through data streams, serialization, and the file system."", ""java.io"")"
The PrintWriter class has all the same methods as the PrintStream except for the methods to write raw bytes.,"(""PrintWriter"", ""The PrintWriter class contains methods that correspond to those in the PrintStream class."", ""Methods""); (""PrintStream"", ""The PrintStream class contains methods, which are almost the same as the methods in the PrintWriter class, except for those handling raw bytes."", ""Methods"")"
Being a Writer subclass the PrintWriter is intended to write text.,"(""Writer"", ""PrintWriter is a subclass of Writer, indicating an inheritance relationship."", ""PrintWriter"")"
"Third, the example calls the advanced printf() method of the PrintWriter which can insert formatted numbers into a text string.",NULL
"In that way the PrintWriter is a bit different from other Writer subclasses which tend to have mostly constructors that can take other Writer instances as parameters (except for a few, like OutputStreamWriter).",NULL
The Java PrintWriter class contains the powerful format() and printf() methods.,"(""PrintWriter"", ""The PrintWriter class contains the format method, indicating that it is used within or by the class."", ""format""); (""PrintWriter"", ""The PrintWriter class contains the printf method, indicating that it is used within or by the class."", ""printf"")"
"The format() and printf() methods allow you to mix text and data in very advanced ways, using a formatting string.",NULL
The Java Reader (java.io.Reader) and Java Writer class (java.io.Writer) in Java IO work much like the InputStream and OutputStream with the exception that Reader and Writer are character based.,NULL
The Java Reader is the base class of all Reader's in the Java IO API.,"(""Reader"", ""Reader is a class that is part of the Java IO API package"", ""Java IO API"")"
The Java Writer class is the base class of all Writers in the Java IO API.,"(""Writer"", ""The Writer class is part of the Java IO API, which groups related classes and interfaces for input and output operations."", ""Java IO API"")"
Before you can use the SequenceInputStream you must import it in your Java class.,NULL
"This import statement should be at the top of your Java class, right under the package declaration.","(""Java Class"", ""In Java, a class typically follows the package declaration in a source file."", ""Package Declaration"")"
"The FileInputStream extends the InputStream class, so they can be used with the SequenceInputStream.","(""FileInputStream"", ""FileInputStream extends InputStream"", ""InputStream""); (""FileInputStream"", ""FileInputStream can be used with SequenceInputStream"", ""SequenceInputStream""); (""InputStream"", ""InputStream can be used with SequenceInputStream"", ""SequenceInputStream"")"
"When there is no more data to read from the second InputStream, the SequenceInputStream read() method will return -1, just like any other InputStream does.","(""SequenceInputStream"", ""The SequenceInputStream class extends the InputStream class by reading data sequentially from multiple streams."", ""InputStream"")"
The Java Serializable interface (java.io.Serializable is a marker interface your classes must implement if they are to be serialized and deserialized.,"(""Java Serializable"", ""The Java Serializable class is part of the java.io package."", ""java.io"")"
"Therefore, a class implementing Serializable does not have to implement any specific methods.",NULL
Implementing Serializable thus just tells the Java serialization classes that this class is intended for object serialization.,NULL
Here is an example of a class that implements the Java Serializable interface:,"(""Class"", ""The class implements the Serializable interface, indicating they are related."", ""Serializable"")"
"As you can see, the Person class implements the Serializable interface, but does not actually implement any methods.",NULL
"In addition to implementing the Serializable interface, a class intended for serialization should also contain a private static final long variable named serialVersionUID.","(""Serializable"", ""class""); (""Serializable"", ""class"")"
"Here is the Person class from before, with a serialVersionUID variable added:","(""Person"", ""The serialVersionUID is a variable related to the Person class, presumably as a part of its implementation."", ""serialVersionUID"")"
"The serialVersionUID variable is used by Java's object serialization API to determine if a deserialized object was serialized (written) with the same version of the class, as it is now attempting to deserialize it into.",NULL
Now the serialized Person object may not correspond to the new version of the Person class.,"(""Person"", ""The Person object is an instance of the Person class."", ""Person"")"
To detect such problems a class implementing Serializable should contain a serialVersionUID field.,"(""Class"", ""A class implements the Serializable interface."", ""Serializable""); (""Class"", ""The class should contain a serialVersionUID field."", ""Serialversionuid"")"
"If you make big changes to the class, you should also change its serialVersionUID value.","(""Class"", ""The SerialVersionUID is a unique identifier associated with the Class to ensure compatibility during serialization."", ""SerialVersionUID"")"
"These other object serialization mechanisms typically do not require your Java classes to implement Serializable, by the way.",NULL
"They are typically using Java Reflection to inspect your class, so implementing the Serializable interface would be superflous - it would not add any useful information.","(""Class"", ""The Serializable class is mentioned in the context of implementing or not implementing Java interfaces related to the Class."", ""Serializable"")"
The class java.io.InputStream is the base class for all Java IO input streams.,"(""Java.IO.InputStream"", ""Class"")"
"If you are writing a component that needs to read input from a stream, try to make our component depend on an InputStream, rather than any of it's subclasses (e.g.","(""InputStream"", ""class""); (""InputStream"", ""class"")"
"Doing so makes your code able to work with all types of input streams, instead of only the concrete subclass.",NULL
Otherwise your code will not be able to call the unread() method on the PushbackInputStream.,"(""PushbackInputStream"", ""The unread() method is part of the PushbackInputStream class, as it is called on it."", ""unread"")"
You typically read data from an InputStream by calling the read() method.,NULL
The read() method returns a int containing the byte value of the byte read.,NULL
"If there is no more data to be read, the read() method typically returns -1;","(""Read"", ""Method""); (""Read"", ""Method"")"
The class java.io.OutputStream is the base class of all Java IO output streams.,"(""OutputStream"", ""The class OutputStream belongs to the java.io package, which is part of the Java IO infrastructure."", ""java.io"")"
"If you are writing a component that needs to write output to a stream, try to make sure that component depends on an OutputStream and not one of its subclasses.",NULL
You can even write your own stream classes to wrap the standard stream classes that comes with Java.,"(""Stream"", ""Stream classes are mentioned as being wrapped by standard stream classes"", ""Standard Stream""); (""Standard Stream"", ""Standard stream classes come with Java"", ""Java"")"
The Java StringReader class enables you to turn an ordinary String into a Reader.,"(""StringReader"", ""The StringReader class is related to the Reader class because it turns a String into a Reader."", ""Reader""); (""StringReader"", ""The StringReader class is related to String as it operates on an ordinary String to transform it."", ""String"")"
Closing a Java StringReader can be done using the close() method like this:,"(""StringReader"", ""The close() method is used to close a StringReader."", ""close()"")"
Notice that there is no explicit close() call on the StringReader.,"(""Close"", ""The method close() is being discussed in relation to the StringReader class, suggesting an operational relationship."", ""StringReader"")"
The Java StringWriter class (java.io.StringWriter) enables you to obtain the characters written to a Writer as a String.,"(""Java StringWriter"", ""Java StringWriter is synonymous with java.io.StringWriter as they refer to the same entity."", ""java.io.StringWriter""); (""Java StringWriter"", ""Java StringWriter is related to Writer because it enables obtaining characters as a String from a Writer."", ""Writer""); (""Java StringWriter"", ""Java StringWriter converts the characters to a String, hence it has a functional relationship with String."", ""String"")"
Third the characters written to the StringWriter are obtained via the two methods toString() and getBuffer().,"(""StringWriter"", ""The method toString() is used to obtain characters written to the StringWriter."", ""toString()""); (""StringWriter"", ""The method getBuffer() is used to obtain characters written to the StringWriter."", ""getBuffer()"")"
The method toString() returns the characters written to the StringWriter as a String.,NULL
The method getBuffer() returns the StringBuffer used by the StringWriter to build the string from the written characters.,NULL
Notice how there is no longer any explicit close() method call to the StringWriter instance.,"(""StringWriter"", ""The StringWriter class typically uses the close() method to finalize or release resources."", ""Close"")"
The Java IO API is located in the Java IO package (java.io).,NULL
If you look at the Java IO classes in the java.io package the vast amount of choices can be rather confusing.,"(""Java IO Classes"", ""The Java IO Classes are located within the java.io package"", ""java.io"")"
"The purpose of this tutorial is to try to give you an overview of how all these classes are grouped, and the purpose behind them, so you don't have to wonder whether you chose the right class, or whether a class already exists for your purpose.",NULL
"That tutorial gives you a quick overview of the central concepts in the Java IO API, and an overview of all the central classes in the Java IO API.",NULL
The java.io package doesn't actually address all types of input and output.,"(""Java.IO"", ""Package"")"
"Those types of input are covered elsewhere, for instance by the JFC classes in the Swing project, or the Servlet and HTTP packages in the Java Enterprise Edition.","(""JFC"", ""JFC is a class related to Swing, as JFC classes are part of the Swing project"", ""Swing""); (""Servlet"", ""Servlet is a package related to HTTP, as both are part of the Java Enterprise Edition"", ""HTTP"")"
"However, the Java IO package does not contain classes to open network sockets which are necessary for network communication.","(""Java IO"", ""The Java IO package is mentioned in context with network sockets, implying a relationship where classes from packages could involve network-related operations in other contexts."", ""network sockets"")"
"Once you have opened a socket (network connection) though, you read and write data to and from it via Java IO's InputStream and OutputStream classes.","(""Java IO"", ""InputStream is part of the Java IO package."", ""InputStream""); (""Java IO"", ""OutputStream is part of the Java IO package."", ""OutputStream"")"
"It contains classes that does much of the same as the Java IO and Java Networking APIs, but Java NIO can work in non-blocking mode.","(""Java IO"", ""Java NIO offers similar functionality to Java IO, but it can operate in non-blocking mode."", ""Java NIO""); (""Java Networking"", ""Java NIO provides some overlapping functionality with Java Networking but also supports non-blocking operations."", ""Java NIO"")"
The tutorial trail called Java How To's and Utilities also contain a few Java IO utilities - e.g.,NULL
"Here is a table listing most (if not all) Java IO classes divided by input, output, being byte based or character based, and any more specific purpose they may be addressing, like buffering, parsing etc.","(""Java IO"", ""Java IO is a package containing the Input class for handling input operations."", ""Input""); (""Java IO"", ""Java IO is a package containing the Output class for handling output operations."", ""Output"")"
"The Java OutputStream class, java.io.OutputStream, is the base class of all output streams in the Java IO API.",NULL
Subclasses of OutputStream include the Java BufferedOutputStream and the Java FileOutputStream among others.,NULL
Here are some of the well-known subclasses of the Java OutputStream class:,NULL
The write() method of an OutputStream takes an int which contains the byte value of the byte to write.,NULL
This OutputStream write() example first creates a FileOutputStream to which the data will be written.,NULL
The condition to exit the while loop is the return value of the method hasMoreData().,NULL
"The implementation of hasMoreData() is not shown, but imagine that it returns true if there is more data to write, and false if not.","(""HasMoreData"", ""The method checks if there is more data available to write."", ""Data"")"
"Inside the while loop the example calls the method getMoreData() to get the next data to write to the OutputStream, and then writes that data to the OutputStream.","(""GetMoreData"", ""GetMoreData is called to obtain data that is subsequently written to the OutputStream"", ""OutputStream"")"
The Java OutputStream's flush() method flushes all data written to the OutputStream to the underlying data destination.,"(""flush"", ""The 'flush' method is used by the 'OutputStream' class to flush data to the underlying data destination."", ""OutputStream"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your OutputStream has).",NULL
Here is an example of flushing data written to a Java OutputStream by calling its flush() method:,"(""OutputStream"", ""The flush() method is a function that can be called on an OutputStream to clear any buffered data."", ""flush()""); (""OutputStream"", ""The flush() method is a function that can be called on an OutputStream to clear any buffered data."", ""flush()"")"
"What matters is, that once the while loop ends, and you are done writing data to the OutputStream, its close() method is called, which closes the OutputStream .","(""OutputStream"", ""The close() method is associated with the OutputStream class as it is responsible for closing the OutputStream after data writing is done."", ""close()"")"
"Once the try block is exited, the close() method of the OutputStream is called automatically, because the OutputStream was declared inside the parentheses of the try block.","(""close"", ""The close method is a function that operates on or is a member of the OutputStream class."", ""OutputStream""); (""close"", ""The close method is a function that operates on or is a member of the OutputStream class."", ""OutputStream"")"
You can convert a OutputStream to a character based Writer using the Java OutputStreamWriter class.,"(""OutputStream"", ""OutputStreamWriter is used to convert an OutputStream to a Writer"", ""OutputStreamWriter""); (""OutputStreamWriter"", ""OutputStreamWriter is a type of Writer used for OutputStream"", ""Writer"")"
"The Java OutputStreamWriter class, java.io.OutputStreamWriter, is intended to wrap an Java OutputStream and thereby turning the byte based output stream into a character based Writer.","(""OutputStreamWriter"", ""OutputStreamWriter wraps OutputStream to convert it into a character-based Writer."", ""OutputStream""); (""OutputStreamWriter"", ""OutputStreamWriter acts as a Writer by converting byte-based output streams to character-based."", ""Writer""); (""OutputStreamWriter"", ""OutputStreamWriter is part of the java.io package."", ""java.io"")"
"The Java OutputStreamWriter is useful if you need to write characters to a file, encoded as e.g.","(""OutputStreamWriter"", ""OutputStreamWriter is used to write characters to a file."", ""file"")"
The Java OutputStreamWriter is a subclass of the Java Writer class.,"(""Java OutputStreamWriter"", ""The Java OutputStreamWriter is a subclass of the Java Writer class."", ""Java Writer"")"
"The Java OutputStreamWriter also has alternative constructors that allow you to specify the character set (ISO-Latin1, UTF-8, UTF-16 etc.)",NULL
The Java OutputStreamWriter's flush() method flushes all data written to the OutputStreamWriter to the underlying data destination.,"(""OutputStreamWriter"", ""The flush() method is a function provided by the OutputStreamWriter class to clear data to its underlying destination."", ""flush()""); (""OutputStreamWriter"", ""The Java OutputStreamWriter belongs to its corresponding package that is not specifically named."", ""OutputStreamWriter"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your OutputStreamWriter has).","(""flush"", ""The method flush() is used to assure that any buffered data within an OutputStreamWriter is written to its destination."", ""OutputStreamWriter""); (""flush"", ""The method flush() is used to assure that any buffered data within an OutputStreamWriter is written to its destination."", ""OutputStreamWriter"")"
Here is an example of flushing data written to a Java OutputStreamWriter by calling its flush() method:,"(""OutputStreamWriter"", ""The flush() method is a functionality of the OutputStreamWriter class, used to flush data written to the stream."", ""flush()"")"
These bytes will then be read again the next time you call read().,NULL
"The Java PushbackInputStream is a subclass of the Java InputStream so it inherits its public methods - read(), close() etc.",NULL
The call to read() reads a byte just like from an InputStream.,"(""Read"", ""The method read() is used to read a byte from the InputStream class"", ""InputStream"")"
The call to unread() pushes a byte back into the PushbackInputStream.,"(""unread"", ""The method unread() is related to the class PushbackInputStream because it operates on an instance of this class, allowing a byte to be pushed back into the stream."", ""PushbackInputStream"")"
The next time read() is called the pushed back bytes will be read first.,NULL
"If you push back multiple bytes into the PushbackInputStream, the latest byte pushed back will be returned first from read(), just like on a stack.","(""PushbackInputStream"", ""The PushbackInputStream class has a method called read(). This relationship is typical in object-oriented programming, where classes contain methods that operate on instances of those classes."", ""read"")"
"You read bytes from the Java PushbackInputStream via its read() method, just like you do from a regular InputStream .",NULL
"Notice, that once the PushbackInputStream has no more bytes to read, from its underlying PushbackInputStream, the read() method will return -1.","(""read"", ""The method 'read' is a function that operates on the class 'PushbackInputStream'."", ""PushbackInputStream"")"
To push a byte back into the Java PushbackInputStream you use the unread() method.,"(""unread"", ""The unread method is used to push a byte back into the Java PushbackInputStream."", ""Java PushbackInputStream"")"
"This example first reads a byte from the PushbackInputStream, then pushes it back into the PushbackInputStream, and then reads that byte back again with the final read() call.","(""PushbackInputStream"", ""The 'PushbackInputStream' class uses the 'read' method to read a byte."", ""read""); (""PushbackInputStream"", ""The 'PushbackInputStream' class uses the 'push back' method to return a byte into the stream."", ""push back"")"
"The Java PushbackReader class, java.io.PushbackReader, is intended to be used when you parse data from a Reader.",NULL
These characters will then be read again the next time you call read().,NULL
The call to read() reads a character from the PushbackReader just like from any other Reader.,"(""PushbackReader"", ""The method read() is used to read a character from the PushbackReader class, indicating a usage relationship between the class and the method."", ""read"")"
The call to unread() pushes a character back into the PushbackReader.,NULL
The next time read() is called the pushed back characters will be read first.,NULL
"If you push back multiple characters into the PushbackReader, the latest pushed back character will be returned first from the read() method, just like with a stack.",NULL
You read characters from a Java PushbackReader just like you do from a Java Reader - because PushbackReader is a Java Reader subclass.,"(""PushbackReader"", ""PushbackReader is a subclass of Reader, indicating an inheritance relationship in Java."", ""Reader"")"
"In other words, you use its read() method which is inherited from the Reader class.","(""Read"", ""The read method is inherited from the Reader class, indicating a parent-child relationship where 'Reader' is the class providing functionality to 'Read'."", ""Reader"")"
Here is an example of reading characters from a Java PushbackReader via its read() method:,"(""PushbackReader"", ""The read() method is used to read characters from a PushbackReader class."", ""read"")"
"The read() returns an int which you will have to cast to a char yourself, as shown in the example above.","(""Read"", ""The method read() returns an int."", ""Int""); (""Int"", ""You need to cast the int to a char."", ""Char"")"
When there are no characters available in the PushbackReader the read() method will return the int value -1.,"(""read"", ""The method read() is a function that belongs to or is called on the class PushbackReader."", ""PushbackReader"")"
To push a character back into a Java PushbackReader you must call its unread() method.,"(""PushbackReader"", ""The unread() method is a function that belongs to the PushbackReader class."", ""unread"")"
"This way the nextToken() method can ""sample"" the first character of the next token, and based on that decide what kind of token it is, and what read method to call for that kind of token.",NULL
"For the readSingleTokenWord() however, it is necessary, as the character read is the first character of the token's value.",NULL
"The implementations of the readDoubleQuotedToken(), readSingleQuotedToken() and readSingleWordToken() have been left out to keep the example short.",NULL
"Just imagine they read a token enclosed by double quotes (""), single quotes (') or a token which ends with a non-word character (e.g.",NULL
The Java RandomAccessFile class in the Java IO API allows you to move navigate a file and read from it or write to it as you please.,NULL
Before you can work with the RandomAccessFile class you must instantiate it.,NULL
You can obtain the current position of a Java RandomAccessFile using its getFilePointer() method.,NULL
Here is an example of obtaining the current position of a RandomAccessFile using its getFilePointer() method:,"(""RandomAccessFile"", ""The method getFilePointer() is used by the class RandomAccessFile to obtain the current position of the file pointer."", ""getFilePointer()"")"
Reading a byte from a Java RandomAccessFile is done using its read() method.,"(""RandomAccessFile"", ""The read() method is used to read a byte from a Java RandomAccessFile."", ""read()"")"
The read() method reads the byte located a the position in the file currently pointed to by the file pointer in the RandomAccessFile instance.,"(""Read"", ""The read() method is related to the RandomAccessFile class because it acts upon an instance of this class to perform its function."", ""RandomAccessFile"")"
Here is a thing the JavaDoc forgets to mention: The read() method increments the file pointer to point to the next byte in the file after the byte just read!,"(""Read"", ""The Read method is related to the File Pointer as it increments the file pointer to point to the next byte after reading."", ""File Pointer"")"
This means that you can continue to call read() without having to manually move the file pointer.,NULL
This example reads a sequence of bytes into the dest byte array passed as parameter to the read() method.,"(""Read"", ""The method 'read()' takes the 'dest' byte array as a parameter, indicating a functional relationship between the method and the class."", ""Dest""); (""Read"", ""The method 'read()' operates on a sequence of bytes, which is stored within a 'byte array', showing a data handling relationship."", ""Byte Array"")"
The read() method will start reading in the file from the current file position of the RandomAccessFile.,NULL
"The read() method will start writing data into the byte array starting from the array position provided by the offset parameter, and at most the number of bytes provided by the length parameter.",NULL
You can write a single byte to a RandomAccessFile using its write() method which takes an int as parameter.,"(""RandomAccessFile"", ""The write method is associated with the RandomAccessFile class."", ""write""); (""RandomAccessFile"", ""The write method is associated with the RandomAccessFile class."", ""write"")"
"Remember, calling this write() method will advance the file position of the RandomAccessFile by 1.","(""Write"", ""The write() method is called on the RandomAccessFile class to advance the file position."", ""RandomAccessFile"")"
Writing to a RandomAccessFile can be done using one it its many write() methods.,"(""RandomAccessFile"", ""The method 'write' is associated with the class 'RandomAccessFile', as indicated by the action of writing to an instance of this class."", ""write"")"
Just like with the read() method the write() method advances the file pointer after being called.,"(""Read"", ""Both Read and Write methods advance the file pointer after being called."", ""Write""); (""Read"", ""Both Read and Write methods advance the file pointer after being called."", ""Write"")"
The RandomAccessFile has a close() method which must be called when you are done using the RandomAccessFile instance.,"(""RandomAccessFile"", ""The close() method is part of the RandomAccessFile class that needs to be called to properly close the instance."", ""close"")"
You can see example of calls to close() in the examples above.,NULL
"The Java Reader class, java.io.Reader, is the base class for all Reader subclasses in the Java IO API.",NULL
"This is done when you instantiate the Reader (actually, when you instantiate one of its subclasses).",NULL
You will normally use a Reader subclass rather than a Reader directly.,"(""Reader"", ""class"")"
Here is an example of creating a Java FileReader which is a subclass of Java Reader:,"(""FileReader"", ""FileReader is a subclass of Reader"", ""Reader"")"
The read() method of a Java Reader returns an int which contains the char value of the next character read.,"(""Read"", ""The method 'Read' is a part of the 'Java Reader' class as it operates on this class to return a character value."", ""Java Reader"")"
"If the read() method returns -1, there is no more data to read in the Reader, and it can be closed.","(""Read"", ""The read method is called on the Reader class to obtain data."", ""Reader"")"
"If not, it processes that char and continues reading until -1 is returned from the Reader read() method.","(""Reader"", ""The read method is associated with the Reader class as it is invoked on instances of this class."", ""read"")"
"The Java Reader class also has a read() method that takes a char array as parameter, as well as a start offset and length.","(""Reader"", ""The read() method is a member of the Reader class, as described in the text."", ""read"")"
The Java Reader class has a method named skip() which can be used to skip over a number of characters in the input that you do not want to read.,NULL
The Java StreamTokenizer class (java.io.StreamTokenizer) can tokenize the characters read from a Reader into tokens.,"(""Java StreamTokenizer"", ""The Java StreamTokenizer class is represented by java.io.StreamTokenizer in the package hierarchy."", ""java.io.StreamTokenizer""); (""Java StreamTokenizer"", ""The Java StreamTokenizer class reads from a Reader to tokenize characters."", ""Reader""); (""java.io.StreamTokenizer"", ""The class java.io.StreamTokenizer is part of the java.io package."", ""java.io"")"
You do so by calling the nextToken() method of the StreamTokenizer inside a loop.,"(""StreamTokenizer"", ""The nextToken method is called within an instance of the StreamTokenizer class, indicating a method of the class."", ""nextToken"")"
"After each call to nextToken() the StreamTokenizer has several fields you can read to see what kind of token was read, it's value etc.",NULL
"Java has 3 streams called System.in, System.out, and System.err which are commonly used to provide input to, and output from Java applications.","(""System.in"", ""System.in provides input to Java applications"", ""Java applications""); (""System.out"", ""System.out provides output from Java applications"", ""Java applications""); (""System.err"", ""System.err provides output from Java applications"", ""Java applications"")"
Most commonly used is probably System.out for writing output to the console from console programs (command line applications).,NULL
"System.in, System.out and System.err are initialized by the Java runtime when a Java VM starts up, so you don't have to instantiate any streams yourself (although you can exchange them at runtime).",NULL
System.in is an InputStream which is typically connected to keyboard input of console programs.,NULL
"In other words, if you start a Java application from the command line, and you type something on the keyboard while the CLI console (or terminal) has focus, the keyboard input can typically be read via System.in from inside that Java application.",NULL
"However, it is only keyboard input directed to that Java application (the console / terminnal that started the application) which can be read via System.in.",NULL
Keyboard input for other applications cannot be read via System.in .,NULL
"System.in is not used as often since data is commonly passed to a command line Java application via command line arguments, files, or possibly via network connections if the application is designed for that.","(""System.in"", ""class""); (""System.in"", ""class"")"
System.out normally outputs the data you write to it to the CLI console / terminal.,NULL
System.out is often used from console-only programs like command line tools as a way to display the result of their execution to the user.,"(""System"", ""The method 'out' is a member of the class 'System', specifically it's a commonly used output stream in Java."", ""out"")"
System.err works like System.out except it is normally only used to output error texts.,"(""System.err"", ""System.err works like System.out, indicating a functional similarity between the two classes."", ""System.out""); (""System.err"", ""System.err is normally used to output error texts, establishing a usage relationship between the class and the package."", ""error texts"")"
"Some programs (like Eclipse) will show the output to System.err in red text, to make it more obvious that it is error text.","(""System.err"", ""The text identifies System.err as the entity related to error output within some programs."", ""System.err"")"
"Even if the 3 System streams are static members of the java.lang.System class, and are pre-instantiated at JVM startup, you can change what streams to use for each of them.",NULL
"Just set a new InputStream for System.in or a new OutputStream for System.out or System.err, and all further data will be read / written to the new stream.","(""InputStream"", ""System.in is a field that can utilize an InputStream to receive input data."", ""System.in""); (""OutputStream"", ""System.out is a field that can use an OutputStream for outputting data."", ""System.out""); (""OutputStream"", ""System.err is a field that can use an OutputStream for error output data."", ""System.err"")"
"To set a new System stream, use one of th emethods System.setIn(), System.setOut() or System.setErr().","(""System"", ""System.setIn() is a method provided by the System package"", ""System.setIn()""); (""System"", ""System.setOut() is a method provided by the System package"", ""System.setOut()""); (""System"", ""System.setErr() is a method provided by the System package"", ""System.setErr()"")"
"Now all data written to System.out should be redirected into the file ""c:\\data\\system.out.txt"".","(""System"", ""The 'out' method is part of the 'System' class in Java, where all output to the console is handled."", ""out"")"
"Keep in mind though, that you should make sure to flush System.out and close the file before the JVM shuts down, to be sure that all data written to System.out is actually flushed to the file.","(""flush"", ""The flush method is mentioned in the context of ensuring that all data written to System.out is flushed to the file."", ""System.out""); (""close"", ""The close method is mentioned in relation to the file to ensure it is closed before the JVM shuts down."", ""file"")"
The Java Writer class (java.io.Writer) is the base class for all Writer subclasses in the Java IO API.,"(""Writer"", ""The Java Writer class is a general term for the specific java.io.Writer class"", ""java.io.Writer""); (""Writer"", ""The Writer class is part of the Java IO package as the base class for Writer subclasses"", ""Java IO""); (""java.io.Writer"", ""The java.io.Writer class belongs to the Java IO package, representing its specific implementation"", ""Java IO"")"
"The Java Writer subclasses can normally handle UTF-8 and UTF-16 encoding for you, so you don't have to worry about that.","(""Writer"", ""class"")"
You will normally use a Writer subclass rather than a Writer directly.,NULL
The Java Writer's flush() method flushes all data written to the Writer to the underlying data destination.,"(""Writer"", ""The flush method belongs to the Writer class as it's a method used by Writer to flush data."", ""flush"")"
"By calling flush() you can assure that any buffered data will be flushed (written) to disk (or network, or whatever else the destination of your Writer has).",NULL
Here is an example of flushing data written to a Java Writer by calling its flush() method:,"(""Flush"", ""The Flush method is related to the Java Writer class because it is used to flush data written to a Writer object."", ""Java Writer"")"
"The concrete implementations of hasMoreCharacters() and getNextCharacter() are left out, but they are not really super important to understand the principle of this example.","(""hasMoreCharacters"", ""Both methods are mentioned as part of the same discussion about concrete implementations, indicating they are related in terms of functionality or example context."", ""getNextCharacter""); (""hasMoreCharacters"", ""Both methods are mentioned as part of the same discussion about concrete implementations, indicating they are related in terms of functionality or example context."", ""getNextCharacter"")"
"What matters is, that once the while loop ends, and you are done writing data to the Writer, its close() method is called, which closes the Writer .","(""close()"", ""The close() method is called to close the Writer."", ""Writer""); (""close()"", ""The close() method is called to close the Writer."", ""Writer"")"
"Once the try block is exited, the close() method of the Writer is called automatically, because the Writer was declared inside the parentheses of the try block.","(""Writer"", ""The close() method is a member of the Writer class and is called on it."", ""close()""); (""try block"", ""The Writer class is used within the try block, indicating they are related through usage context."", ""Writer"")"
"The SQL dialect used by the various different databases will vary slightly, so to be 100% database independent, you SQL must also be 100% database independent (i.e.",NULL
The Java String parameter passed to the Class forName() method is the name of the JDBC driver class for the given JDBC driver.,NULL
You will have to find the right class name for the JDBC driver you are using.,NULL
"Typically, each database has its own JDBC driver, so you will have to look up what the JDBC driver class name is (if you are using pre Java 6).","(""JDBC driver"", ""The JDBC driver needs to be referenced by its class name for usage."", ""JDBC driver class name"")"
"First you add the SQL statements to be executed in the batch, using the addBatch() method.","(""AddBatch"", ""The addBatch() method is used to add SQL statements to be executed in the batch, indicating a functional relationship between the method and the class it operates on."", ""SQL"")"
The int[] array returned by the executeBatch() method is an array of int telling how many records were affected by each executed SQL statement in the batch.,NULL
"Second, each set of parameter values are inserted into the preparedStatement, and the addBatch() method is called.",NULL
"Third, the executeBatch() method is called, which executes all the batch updates.",NULL
"By the way, imagine that the used Person class looks like this:",NULL
A java.sql.CallableStatement is used to call stored procedures in a database.,"(""Java.Sql.CallableStatement"", ""Java.Sql.CallableStatement is used to call stored procedures in a database."", ""Stored Procedures"")"
"A stored procedure is like a function or method in a class, except it lives inside the database.",NULL
You create an instance of a CallableStatement by calling the prepareCall() method on a connection object.,"(""prepareCall"", ""The prepareCall method is used to create an instance of CallableStatement."", ""CallableStatement""); (""prepareCall"", ""The prepareCall method is called on a connection object."", ""connection"")"
"If the stored procedure returns a ResultSet, and you need a non-default ResultSet (e.g.","(""ResultSet"", ""class""); (""ResultSet"", ""class"")"
The executeQuery() method is used if the stored procedure returns a ResultSet.,"(""executeQuery()"", ""The method executeQuery() is used to return a ResultSet, indicating a relationship of invocation and output."", ""ResultSet"")"
"If the stored procedure just updates the database, you can call the executeUpdate() method instead, like this:","(""executeUpdate"", ""method""); (""executeUpdate"", ""method"")"
"The JDBC Connection class, java.sql.Connection, represents a database connection to a relational database.","(""JDBC Connection"", ""JDBC Connection is a term that refers to the java.sql.Connection class, describing its role in representing a database connection."", ""java.sql.Connection"")"
Each JDBC driver has a primary driver class that initializes the driver when it is loaded.,NULL
You open a JDBC Connection by call the java.sql.DriverManager class method getConnection().,"(""java.sql.DriverManager"", ""The method getConnection() is part of the java.sql.DriverManager class."", ""getConnection""); (""getConnection"", ""The getConnection() method is used to open a JDBC Connection."", ""JDBC Connection"")"
This is how calling getConnection() only with the URL as parameter looks:,"(""getConnection"", ""method"")"
"The second variant of getConnection() takes both a database URL, a user name and a password as parameters.",NULL
Here is an example of calling that variant of getConnection() :,"(""GETCONNECTION"", ""method"")"
The third variant of getConnection() takes a database URL and a Properties object as parameter.,NULL
"The JDBC Connection setAutoCommit() method is used to switch the connection into, or out of, auto commit mode.","(""Connection"", ""The setAutoCommit method is a function that operates on a Connection instance to manage auto commit settings."", ""setAutoCommit""); (""Connection"", ""The setAutoCommit method is a function that operates on a Connection instance to manage auto commit settings."", ""setAutoCommit"")"
"When not in auto commit mode, each database transaction must be explicitly committed by calling the Connection commit() method.","(""Connection"", ""The commit method is called on the Connection class to explicitly commit a transaction."", ""commit"")"
"Keep in mind, that if some of the operations in the transaction fail, you would most likely want to call the rollback() method instead of commit().",NULL
The Java JDBC Connection rollback() method rolls back the operations executed within the currently ongoing transaction.,"(""Java JDBC Connection"", ""The rollback() method is associated with the Java JDBC Connection class, managing transaction control."", ""rollback()""); (""Java JDBC Connection"", ""The rollback() method is associated with the Java JDBC Connection class, managing transaction control."", ""rollback()"")"
Exactly how to handle the calls to commit() and / or rollback() is covered in the JDBC Transactions Tutorial.,NULL
Here is a simple example of calling the JDBC Connection rollback() method:,"(""JDBC Connection"", ""The rollback() method is called on the JDBC Connection to revert to the last committed state."", ""rollback() method"")"
Notice how rollback() is called within the catch-block of a try-catch block.,NULL
Here is an example of creating a JDBC Statement instance via the JDBC Connection createStatement() method:,"(""JDBC"", ""The JDBC package contains the Statement class"", ""Statement""); (""Connection"", ""The createStatement method is a member of the Connection class and is used to create a Statement instance"", ""createStatement""); (""JDBC"", ""The JDBC package contains the Statement class"", ""Statement""); (""Connection"", ""The createStatement method is a member of the Connection class and is used to create a Statement instance"", ""createStatement"")"
Here is an example of creating a JDBC PreparedStatement instance via the JDBC Connection prepareStatement() method:,NULL
The JDBC Connection getMetaData() method returns a JDBC DatabaseMetaData object which can be used to introspect the database the JDBC Connection is connected to.,NULL
Here is an example of creating a JDBC DatabaseMetaData object via the JDBC Connection getMetaData() method:,"(""Connection"", ""The method getMetaData() is called on the Connection class."", ""getMetaData""); (""Connection"", ""A DatabaseMetaData object is created through the Connection class."", ""DatabaseMetaData"")"
Through the java.sql.DatabaseMetaData interface you can obtain meta data about the database you have connected to.,"(""sql"", ""The DatabaseMetaData interface is part of the sql package."", ""DatabaseMetaData""); (""java"", ""The sql package is part of the java package, representing a hierarchy."", ""sql"")"
"First you call the getTables() method, passing it 4 parameters which are all null.","(""GetTables"", ""The term 'getTables' is identified as a method based on its context within the text."", ""Method"")"
The ResultSet returned from the getTables() method contains a list of table names matching the 4 given parameters (which were all null).,NULL
The ResultSet returned by the getColumns() method contains a list of columns for the given table.,"(""ResultSet"", ""The getColumns method returns a ResultSet containing a list of columns for the given table."", ""getColumns"")"
The column type is an integer matching one of the type constants found in java.sql.Types,"(""column type"", ""column type is represented as an integer, as indicated by the text."", ""integer""); (""Types"", ""Types is likely a package containing type constants which include the integer type."", ""integer"")"
"First you call the getPrimaryKeys() method, passing 3 parameters to it.","(""getPrimaryKeys"", ""The method getPrimaryKeys is called with three parameters."", ""parameters"")"
The ResultSet returned by the getPrimaryKeys() method contains a list of columns which make up the primary key of the given table.,"(""getPrimaryKeys"", ""The getPrimaryKeys method returns a ResultSet, indicating a relationship where the method produces an instance of the class ResultSet as its output."", ""ResultSet"")"
"A JDBC driver is a set of Java classes that implement the JDBC interfaces, targeting a specific database.",NULL
A JDBC driver is a collection of Java classes that enables you to connect to a certain database.,"(""JDBC Driver"", ""The JDBC Driver is described as a collection of Java classes."", ""Java classes"")"
"This works for executing queries too, using the executeQuery() method, which returns a ResultSet.",NULL
"The ResultSet.next() method moves to the next row in the ResultSet, if there are anymore rows.","(""ResultSet"", ""The 'next' method is associated with the 'ResultSet' class as it operates on the ResultSet to move to the next row."", ""next"")"
You need to call next() at least one time before you can read any data.,"(""next"", ""The method 'next' needs to be called to read any data."", ""data"")"
Before the first next() call the ResultSet is positioned before the first row.,NULL
"You can get column data for the current row by calling some of the getXXX() methods, where XXX is a primitive data type.","(""getXXX()"", ""The method getXXX() is mentioned as a way to retrieve column data for the current row."", ""getXXX()"")"
The column name to get the value of is passed as parameter to any of these getXXX() method calls.,NULL
"You can get the index of a given column by calling the ResultSet.findColumn() method, like this:",NULL
The text about queries shows how the result of a query is returned as a java.sql.ResultSet.,"(""Query"", ""The ResultSet is the return type of the Query, indicating a direct relationship."", ""ResultSet""); (""ResultSet"", ""ResultSet is part of the java.sql package, indicating a package-class relationship."", ""java.sql"")"
"The next() method returns true if the ResultSet has a next record, and moves the ResultSet to point to the next record.",NULL
"If there were no more records, next() returns false, and you can no longer.","(""Next"", ""Method""); (""Next"", ""Method"")"
"Once the next() method has returned false, you should not call it anymore.",NULL
Here is an example of iterating a ResultSet using the next() method:,"(""ResultSet"", ""The next() method is used to iterate over the ResultSet, indicating a clear relationship between the class and the method."", ""next"")"
"As you can see, the next() method is actually called before the first record is accessed.","(""Next"", ""The term 'next()' refers to a method."", ""Method"")"
"Once next() has been called once, it points at the first record.",NULL
"Similarly, when next() is called and returns false, the ResultSet is actually pointing after the last record.","(""Next"", ""The method 'next()' is a functional component of the 'ResultSet' class, often used to iterate through its data."", ""ResultSet""); (""Next"", ""The method 'next()' is a functional component of the 'ResultSet' class, often used to iterate through its data."", ""ResultSet"")"
You do so by calling one or more of the many getXXX() methods.,NULL
"You pass the name of the column to get the value of, to the many getXXX() methods.","(""Column"", ""The getXXX() methods are used to retrieve values from a Column."", ""getXXX"")"
"There are a lot of getXXX() methods you can call, which return the value of the column as a certain data type, e.g.",NULL
Here is a list of quick examples of these getXXX() methods:,"(""GETXXX"", ""METHOD"")"
The getXXX() methods also come in versions that take a column index instead of a column name.,"(""GETXXX"", ""METHOD"")"
"If you do not know the index of a certain column you can find the index of that column using the ResultSet.findColumn(String columnName) method, like this:","(""ResultSet"", ""The findColumn method is a member of the ResultSet class."", ""findColumn"")"
The DatabaseMetaData.supportsResultSetType(int type) method returns true or false depending on whether the given type is supported or not.,NULL
The DatabaseMetaData.supportsResultSetConcurrency(int concurrency) method returns true or false depending on whether the given concurrency mode is supported or not.,"(""DatabaseMetaData"", ""The method supportsResultSetConcurrency is a part of the DatabaseMetaData class."", ""supportsResultSetConcurrency"")"
It is when updateRow() is called that the database is updated with the values of the row.,"(""UpdateRow"", ""The method updateRow() interacts with the Database to update it with row values"", ""Database"")"
"If you call updateRow() inside a transaction, the data is not actually committed to the database until the transaction is committed.","(""UpdateRow"", ""The method UpdateRow is used within the context of a Transaction."", ""Transaction""); (""Transaction"", ""A Transaction interacts with the Database to commit or rollback changes."", ""Database"")"
"The row pointed to after calling moveToInsertRow() is a special row, a buffer, which you can use to build up the row until all column values has been set on the row.","(""MoveToInsertRow"", ""The 'moveToInsertRow' method relates to the 'special row' as it directly points to this buffer row when invoked."", ""Special Row"")"
"Once the row is ready to be inserted into the ResultSet, call the insertRow() method.","(""ResultSet"", ""The insertRow() method is used to insert a row into the ResultSet class."", ""insertRow"")"
"If you need to insert another row, explicitly call moveToInsertRow() to signal this to the ResultSet.","(""moveToInsertRow"", ""The method moveToInsertRow is called on the class ResultSet to insert another row."", ""ResultSet"")"
The ResultSet holdability determines if a ResultSet is closed when the commit() method of the underlying connection is called.,"(""ResultSet"", ""The ResultSet is related to the commit method because the holdability of the ResultSet determines its closure when the commit method is invoked."", ""commit"")"
The DatabaseMetaData.supportsResultSetHoldability(int holdability) returns true or false depending on whether the given holdability mode is supported or not.,"(""DATABASEMETADATA"", ""SUPPORTSRESULTSETHOLDABILITY is a method of the class DATABASEMETADATA"", ""SUPPORTSRESULTSETHOLDABILITY"")"
The CLOSE_CURSORS_OVER_COMMIT holdability means that all ResultSet instances are closed when connection.commit() method is called on the connection that created the ResultSet.,"(""CLOSE_CURSORS_OVER_COMMIT"", ""The holdability CLOSE_CURSORS_OVER_COMMIT affects all instances of the class ResultSet by closing them."", ""ResultSet""); (""connection.commit()"", ""The method connection.commit() is called on the connection that creates the ResultSet instances."", ""ResultSet""); (""connection.commit()"", ""The method connection.commit() is invoked on the connection object."", ""connection"")"
The HOLD_CURSORS_OVER_COMMIT holdability means that the ResultSet is kept open when the connection.commit() method is called on the connection that created the ResultSet.,"(""ResultSet"", ""ResultSet is created by a connection in order to execute queries and hold their results."", ""connection""); (""commit"", ""The commit method is invoked on the connection to finalize transactions."", ""connection""); (""HOLD_CURSORS_OVER_COMMIT"", ""HOLD_CURSORS_OVER_COMMIT affects the behavior of the commit method, determining whether cursors remain open after commit."", ""commit""); (""ResultSet"", ""ResultSet is created by a connection in order to execute queries and hold their results."", ""connection""); (""commit"", ""The commit method is invoked on the connection to finalize transactions."", ""connection""); (""HOLD_CURSORS_OVER_COMMIT"", ""HOLD_CURSORS_OVER_COMMIT affects the behavior of the commit method, determining whether cursors remain open after commit."", ""commit"")"
"Thus, you can open a ResultSet, update rows in it, call connection.commit() and still keep the same ResultSet open for future transactions on the same rows.","(""ResultSet"", ""The method connection.commit() is used to commit transactions on the ResultSet, ensuring the results are finalized while keeping the ResultSet open for further operations."", ""connection.commit()""); (""ResultSet"", ""The method connection.commit() is used to commit transactions on the ResultSet, ensuring the results are finalized while keeping the ResultSet open for further operations."", ""connection.commit()"")"
"The Java JDBC Statement, java.sql.Statement, interface is used to execute SQL statements against a relational database.",NULL
"You do so by calling its executeQuery() method, passing an SQL statement as parameter.",NULL
The Statement executeQuery() method returns a Java JDBC ResultSet which can be used to navigate the response of the query.,NULL
Here is an example of calling the Java JDBC Statement executeQuery() and navigating the returned ResultSet:,"(""Statement"", ""The executeQuery() method is a function of the Statement class used to execute SQL queries."", ""executeQuery()""); (""executeQuery()"", ""The executeQuery() method executes a query and returns the result as a ResultSet."", ""ResultSet"")"
"The rowsAffected returned by the statement.executeUpdate(sql) call, tells how many records in the database were affected by the SQL statement.","(""Statement"", ""The executeUpdate method is called on the Statement class."", ""ExecuteUpdate""); (""ExecuteUpdate"", ""The executeUpdate method is used to execute the given SQL statement."", ""Sql"")"
The classic example of when transactions are necessary is the example of bank accounts.,NULL
"But, instead of calling the executeQuery() method, you call the executeUpdate() method.","(""ExecuteQuery"", ""Both are methods that are alternatives to each other in context, possibly serving a similar purpose or functioning within the same class or package."", ""ExecuteUpdate"")"
The executeUpdate() method is used for both of these types of updates.,NULL
"Again, the rowsAffected returned by the statement.executeUpdate(sql) call, tells how many records in the database were affected by the SQL statement.","(""Statement"", ""The 'executeUpdate' method is part of the 'Statement' class, as it is the method called on a 'Statement' object."", ""ExecuteUpdate""); (""Sql"", ""The 'executeUpdate' method is used to execute the 'SQL' statement provided as an argument, indicating interaction between the SQL package functionality and the method."", ""ExecuteUpdate"")"
"Once you have installed the Java SDK, test that you have it working by opening a command prompt (textual interface to your computer, ala Unix Shell, Windows CMD etc.)","(""Java SDK"", ""The command prompt can be used to test the installation and functionality of the Java SDK."", ""command prompt"")"
"A Java abstract class is a class which cannot be instantiated, meaning you cannot create new instances of an abstract class.","(""Java Abstract Class"", ""Java Abstract Class is a type of Class which cannot be instantiated"", ""Class"")"
The purpose of an abstract class is to function as a base for subclasses.,"(""Abstract Class"", ""An abstract class serves as a base for subclasses, indicating a hierarchical relationship."", ""Subclass"")"
"This Java abstract class tutorial explains how abstract classes are created in Java, what rules apply to them.","(""Abstract Class"", ""The Abstract Class is a type of class that is implemented within the Java package."", ""Java"")"
This tutorial gets into the purpose of abstract classes in Java in more detail towards the end of this text.,NULL
In Java you declare that a class is abstract by adding the abstract keyword to the class declaration.,NULL
That is all there is to declaring an abstract class in Java.,"(""Abstract Class"", ""An abstract class is a concept that is directly related to Java as it is part of Java's object-oriented features."", ""Java"")"
"If you try to compile the code above the Java compiler will generate an error, saying that you cannot instantiate MyAbstractClass because it is an abstract class.","(""Java compiler"", ""The Java compiler generates an error when MyAbstractClass is instantiated because it is an abstract class."", ""MyAbstractClass"")"
"If a class has an abstract method, the whole class must be declared abstract.",NULL
Not all methods in an abstract class have to be abstract methods.,"(""Abstract Class"", ""Abstract classes can contain methods, including abstract methods, within them."", ""Method""); (""Abstract Class"", ""Abstract classes can define abstract methods that need to be implemented by subclasses."", ""Abstract Methods"")"
An abstract class can have a mixture of abstract and non-abstract methods.,NULL
Subclasses of an abstract class must implement (override) all abstract methods of its abstract superclass.,"(""Subclass"", ""A subclass must implement the abstract methods of the abstract class"", ""Abstract Class""); (""Abstract Class"", ""An abstract class contains abstract methods that must be implemented by subclasses"", ""Abstract Method"")"
The non-abstract methods of the superclass are just inherited as they are.,NULL
Notice how MySubClass has to implement the abstract method abstractMethod() from its abstract superclass MyAbstractClass.,"(""MySubClass"", ""MySubClass implements the abstract method abstractMethod."", ""abstractMethod""); (""MySubClass"", ""MySubClass is a subclass of the abstract superclass MyAbstractClass."", ""MyAbstractClass"")"
"The only time a subclass of an abstract class is not forced to implement all abstract methods of its superclass, is if the subclass is also an abstract class.","(""Subclass"", ""A subclass can inherit from an abstract class and may not implement all methods if it is abstract."", ""Abstract Class""); (""Abstract Method"", ""Abstract methods are defined within an abstract class."", ""Abstract Class"")"
The purpose of abstract classes is to function as base classes which can be extended by subclasses to create a full implementation.,NULL
"If the steps before and after the action are always the same, the 3-step process could be implemented in an abstract superclass with this Java code:","(""SUPERCLASS"", ""SUPERCLASS is implemented using JAVA code in the given context"", ""JAVA"")"
Subclasses of MyAbstractProcess can now extend MyAbstractProcess and just override the action() method.,"(""MyAbstractProcess"", ""The action method can be overridden in subclasses of MyAbstractProcess, indicating a relationship between the class and the method."", ""action"")"
"When the process() method of the subclass is called, the full process is executed, including the stepBefore() and stepAfter() of the abstract superclass, and the action() method of the subclass.",NULL
"Of course, the MyAbstractProcess did not have to be an abstract class to function as a base class.","(""MyAbstractProcess"", ""class"")"
"However, by making the method to implement abstract, and thus the class too, you signal clearly to users of this class that this class should not be used as it is.","(""Class"", ""The method is abstract, affecting the behavior and usage of the class."", ""Method"")"
"Instead it should be used as a base class for a subclass, and that the abstract method should be implemented in the subclass.","(""Base Class"", ""A base class is intended to be extended by a subclass."", ""Subclass""); (""Abstract Method"", ""An abstract method should be implemented in a subclass."", ""Subclass"")"
The above example did not have a default implementation for the action() method.,NULL
In some cases your superclass might actually have a default implementation for the method that subclasses are supposed to override.,"(""Superclass"", ""A subclass inherits from a superclass, indicating a clear hierarchy and relationship between the two."", ""Subclass""); (""Subclass"", ""Subclasses are supposed to override methods, indicating a relationship where methods define or influence subclass behavior."", ""Method"")"
"You can still make the superclass abstract though, even if it contains no abstract methods.","(""Superclass"", ""A superclass can be defined as abstract without containing abstract methods."", ""Abstract Methods"")"
"Notice how the processURLData() is an abstract method, and that URLProcessorBase is an abstract class.","(""ProcessURLData"", ""The method processURLData is associated with the abstract class URLProcessorBase as an abstract method."", ""URLProcessorBase"")"
Subclasses of URLProcessorBase have to implement the processURLData() method because it is an abstract method.,NULL
Subclasses of URLProcessorBase abstract class can process data downloaded from URLs without worrying about opening and closing the network connection to the URL.,NULL
Subclasses only need to worry about processing the data from the InputStream passed to the processURLData() method.,NULL
This makes it easier to implement classes that processes data from URLs.,"(""Classes"", ""Classes process data coming from URLs"", ""URLs"")"
"Notice how the subclass only implements the processURLData() method, and nothing more.",NULL
The rest of the code is inherited from the URLProcessorBase superclass.,"(""URLProcessorBase"", ""class"")"
Here is an example of how to use the URLProcessorImpl class:,NULL
"The process() method is called, which is implemented in the URLProcessorBase superclass.","(""Process"", ""The method is part of the class as it is implemented there."", ""URLProcessorBase""); (""Process"", ""The method is part of the class as it is implemented there."", ""URLProcessorBase"")"
This method in turn calls the processURLData() in the URLProcessorImpl class.,"(""PROCESSURLDATA"", ""The method processURLData() is called within the URLProcessorImpl class, indicating a functional association where the class implements or contains this method."", ""URLPROCESSORIMPL"")"
The example I showed you above with the URLProcessorBase class is actually an example of the Template Method design pattern.,"(""URLProcessorBase"", ""The URLProcessorBase class is mentioned as using the Template Method design pattern, which relates it to the concept of a method."", ""Method"")"
"The Template Method design pattern provides a partial implementation of some process, which subclasses can complete when extending the Template Method base class.","(""Template Method"", ""class"")"
"A Java access modifier specifies which classes can access a given class and its fields, constructors and methods.",NULL
"Access modifiers can be specified separately for a class, its constructors, fields and methods.","(""Class"", ""Constructors are typically defined within a class to initialize objects."", ""Constructors""); (""Class"", ""Fields are variables defined within a class representing its state."", ""Fields""); (""Class"", ""Methods are functions defined within a class to perform operations or actions."", ""Methods"")"
"Assigning an access modifier to a class, constructor, field or method is also sometimes referred to as ""marking"" that class, constructor, field or method as that which the access modifier specifies.",NULL
"If a method or variable is marked as private (has the private access modifier assigned to it), then only code inside the same class can access the variable, or call the method.","(""Private"", ""Private methods can only be accessed within the same Class"", ""Class"")"
"Code inside subclasses cannot access the variable or method, nor can code from any external class.","(""Subclasses"", ""Code inside subclasses cannot access the variable, indicating a relationship between these entities."", ""Variable""); (""Subclasses"", ""Code inside subclasses cannot access the method, indicating a relationship between these entities."", ""Method""); (""External Class"", ""Code from any external class cannot access the variable, indicating a relationship between these entities."", ""Variable""); (""External Class"", ""Code from any external class cannot access the method, indicating a relationship between these entities."", ""Method"")"
"Marking a class with the private access modifier would mean that no other class could access it, which means that you could not really use the class at all.","(""Class"", ""The sentence discusses the accessibility of a class when marked with a private modifier, indicating a connection between the class and its accessibility."", ""Class"")"
"That means, that the member variable time inside the Clock class cannot be accessed from code outside the Clock class.","(""Clock"", ""Time is a member variable (or method) within the Clock class, indicating a component relationship in object-oriented programming."", ""Time"")"
"In some cases the fields are truly private, meaning they are only used internally in the class.","(""Class"", ""class"")"
In other cases the fields can be accessed via accessor methods (e.g.,"(""Accessor Methods"", ""Method""); (""Accessor Methods"", ""Method""); (""Accessor Methods"", ""Method"")"
In the above example the two methods getTime() and setTime() can access the time member variable.,"(""GetTime"", ""Both methods are shown to interact with the 'time' member variable, suggesting a relationship in accessing and possibly modifying this shared resource."", ""SetTime"")"
"If a constructor in a class is assigned the private Java access modifier, that means that the constructor cannot be called from anywhere outside the class.","(""Constructor"", ""A constructor is a method that belongs to a class."", ""Class"")"
"A private constructor can still get called from other constructors, or from static methods in the same class.","(""Constructor"", ""Constructors are methods defined within a class, and they can be called from other constructors or static methods in the same class."", ""Class"")"
This version of the Clock class contains a private constructor and a public constructor.,NULL
The private constructor is called from the public constructor (the statement this();).,NULL
The private constructor is also called from the static method newClock().,NULL
The above example only serves to show you that a private constructor can be called from public constructors and from static methods inside the same class.,"(""Constructor"", ""Constructors can be declared within a class."", ""Class""); (""Method"", ""Static methods can be declared within a class."", ""Class"")"
"The default access modifier means that code inside the class itself as well as code inside classes in the same package as this class, can access the class, field, constructor or method which the default access modifier is assigned to.",NULL
"Subclasses cannot access methods and member variables (fields) in the superclass, if they these methods and fields are marked with the default access modifier, unless the subclass is located in the same package as the superclass.",NULL
"The time field in the Clock class has no access modifier, which means that it is implicitly assigned the default / package access modifier.",NULL
"Therefore, the ClockReader class can read the time member variable of the Clock object, provided that ClockReader and Clock are located in the same Java package.",NULL
"The protected access modifier provides the same access as the default access modifier, with the addition that subclasses can access protected methods and member variables (fields) of the superclass.",NULL
This is true even if the subclass is not located in the same package as the superclass.,NULL
In the above example the subclass SmartClock has a method called getTimeInSeconds() which accesses the time variable of the superclass Clock.,NULL
"The Java access modifier public means that all code can access the class, field, constructor or method, regardless of where the accessing code is located.","(""Class"", ""Methods are often defined within classes, indicating a relationship where the method is a member or function of the class"", ""Method"")"
The accessing code can be in a different class and different package.,"(""Class"", ""class""); (""Package"", ""package"")"
The time field in the Clock class is marked with the public Java access modifier.,"(""time"", ""The 'time' field is an attribute of the 'Clock' class."", ""Clock"")"
"Therefore, the ClockReader class can access the time field in the Clock no matter what package the ClockReader is located in.",NULL
"It is important to keep in mind that the Java access modifier assigned to a Java class takes precedence over any access modifiers assigned to fields, constructors and methods of that class.","(""Java"", ""The fields are components that belong to the Java class."", ""fields""); (""Java"", ""The constructors are used to initialize objects of the Java class."", ""constructors""); (""Java"", ""The methods define behaviors for the Java class."", ""methods"")"
"If the class is marked with the default access modifier, then no other class outside the same Java package can access that class, including its constructors, fields and methods.","(""Class"", ""The class is marked with a default access modifier which restricts access to other classes outside the same Java package."", ""Package""); (""Class"", ""The class has methods that are mentioned as being inaccessible if the class has default package access."", ""Method"")"
The Java access modifiers private and protected cannot be assigned to a class.,"(""Java"", ""Java is mentioned in context to class access modifiers, indicating a relationship with classes being part of Java packages"", ""class"")"
Java interfaces are meant to specify fields and methods that are publicly available in classes that implement the interfaces.,"(""Java Interface"", ""A Java interface specifies methods that a class implementing it must define."", ""Class""); (""Field"", ""Fields can be declared in a Java interface to be used by implementing classes."", ""Java Interface"")"
"When you create a subclass of some class, the methods in the subclass cannot have less accessible access modifiers assigned to them than they had in the superclass.",NULL
"For instance, if a method in the superclass is public then it must be public in the subclass too, in case the subclass overrides the method.","(""Superclass"", ""The subclass can override methods of the superclass, indicating an inheritance relationship between the two classes."", ""Subclass""); (""Subclass"", ""The subclass contains or overrides the method, indicating a relationship where the method is implemented in the subclass."", ""Method"")"
If a method in the superclass is protected then it must be either protected or public in the subclass.,"(""Method"", ""The method is part of the superclass."", ""Superclass""); (""Method"", ""The method must be protected or public in the subclass."", ""Subclass"")"
"For instance, if a method is assigned the default access modifier in the superclass, then it is allowed to assign the overridden method in the subclass the public access modifier.","(""METHOD"", ""A method is typically associated with a class, which in this case is the 'superclass'."", ""SUPERCLASS""); (""METHOD"", ""A method is typically associated with a class, which in this case is the 'subclass'."", ""SUBCLASS"")"
"The build process includes generating source code, compiling the source, generating XML files (e.g.",NULL
"You can place Java annotations above classes, interfaces, methods, method parameters, fields and local variables.","(""Java"", ""Java annotations can be applied to classes, indicating a usage link."", ""class""); (""Java"", ""Java annotations can also be used with methods, showing a similar usage pattern."", ""method"")"
"Here is a bigger example with annotations above both the class, fields, methods, parameters and local variables:","(""Class"", ""The term 'methods' is related to 'class' as methods are typically defined within classes in object-oriented programming."", ""Methods"")"
"If your code uses deprecated classes, methods or fields, the compiler will give you a warning.","(""Classes"", ""Classes often contain methods, establishing an inherent relationship between them"", ""Methods"")"
"If the method does not match a method in the superclass, the compiler will give you an error.","(""Method"", ""The method is being checked against the methods present in the superclass to ensure compatibility or correct overriding."", ""Superclass"")"
"In case someone changed the name of the overridden method in the superclass, your subclass method would no longer override it.",NULL
"In case the method doTheThing() in MySuperClass changes signature so that the same method in the subclass no longer overrides it, the compiler will generate an error.","(""MySuperClass"", ""The method doTheThing is defined within the class MySuperClass"", ""DoTheThing""); (""MySuperClass"", ""The method doTheThing is defined within the class MySuperClass"", ""DoTheThing"")"
"Annotations are defined in their own file, just like a Java class or interface.","(""Java Class"", ""class""); (""Java Class"", ""class"")"
"RetentionPolicy.CLASS means that the annotation is stored in the .class file, but not available at runtime.",NULL
"RetentionPolicy.SOURCE means that the annotation is only available in the source code, and not in the .class files and not a runtime.",NULL
"The second line declares an array of references to objects of the class MyClass, which symbolizes a class you have created yourself.","(""MyClass"", ""class"")"
Personally I prefer to locate the square brackets [] after the data type (e.g.,NULL
Java allows you to create an array of references to any type of object (to instances of any class).,NULL
Notice how the values to be inserted into the array are listed inside the { ... } block.,"(""Array"", ""Values are inserted into the Array"", ""Values"")"
"Of course, if the insertIntoArray() method is located in a different class than the above code, you would need an object of that class in order to be able to call the method.",NULL
"Or, if the insertIntoArray() method was static, you would need to put the class name and a dot in front of the method name.","(""InsertIntoArray"", ""The InsertIntoArray method requires the Class to be specified if it is static, indicating a relationship between the method and the class it belongs to."", ""Class"")"
"This removeFromArray() method takes two parameters: The array to remove the element from, and the index of the element to remove.",NULL
"Of course, if the removeFromArray() method is located in a different class than the above code, you would need an object of that class in order to be able to call the method.","(""removeFromArray"", ""The removeFromArray method is part of a class because methods belong to classes in object-oriented programming."", ""class""); (""removeFromArray"", ""The removeFromArray method is part of a class because methods belong to classes in object-oriented programming."", ""class"")"
"Or, if the removeFromArray() method was static, you would need to put the class name and a dot in front of the method name.","(""Class Name"", ""The method removeFromArray would be called with a class name if it were static, indicating a standard class-to-static-method relationship."", ""removeFromArray""); (""Class Name"", ""The method removeFromArray would be called with a class name if it were static, indicating a standard class-to-static-method relationship."", ""removeFromArray"")"
The example first sets the minVal to Integer.MAX_VALUE which is the highest possible value an int can take.,NULL
"Java contains a special utility class that makes it easier for you to perform many often used array operations like copying and sorting arrays, filling in data, searching in arrays etc.","(""utility class"", ""The utility class is part of the Java package, making it easier to perform array operations within the Java framework."", ""Java"")"
The utility class is called Arrays and is located in the standard Java package java.util.,NULL
I will cover a few of the methods found in this class in the following sections.,"(""methods"", ""The 'methods' are contained within or are part of the 'class'."", ""class"")"
"Remember, in order to use java.util.Arrays in your Java classes you must import it.","(""Java.Util.Arrays"", ""The package Java.Util.Arrays is often imported and used within Java classes for array manipulation."", ""Java"")"
Here is how importing java.util.Arrays could look in a Java class of your own:,NULL
It is this statement that imports the class java.util.Arrays into your Java class.,"(""Java.util"", ""Java.util.Arrays is a class that is part of the Java.util package."", ""Java.util.Arrays"")"
The second method to copy a Java array is to use the Arrays.copyOf() method.,"(""Arrays.copyOf()"", ""The Arrays.copyOf() method is used to copy a Java array."", ""Java array"")"
The third method to copy a Java array is to use the Arrays.copyOfRange() method.,"(""Method"", ""The text refers to Arrays.copyOfRange() as a method that can copy a Java array, which makes it related to the general concept of a method in programming."", ""Arrays.copyOfRange()"")"
"The Arrays.copyOfRange() method copies a range of an array, not necessarily the full array.",NULL
Here is how copying a full array using Arrays.copyOfRange() in Java looks:,"(""Arrays"", ""copyOfRange is a method in the Arrays package"", ""copyOfRange""); (""copyOfRange"", ""copyOfRange is a method used in Java"", ""Java"")"
You can convert an Java array of primitive types to a String using the Arrays.toString() method.,"(""Arrays"", ""The toString method is a function belonging to the Arrays class."", ""toString"")"
Here is an example of how to convert an array of int to a String using Arrays.toString():,"(""Arrays"", ""The method toString is part of the Arrays package as indicated by the notation Arrays.toString()."", ""toString"")"
You can sort the elements of an array using the Arrays.sort() method.,"(""ARRAYS"", ""Arrays package offers the sort method for sorting collections or arrays."", ""SORT""); (""SORT"", ""Sort method is used to arrange the elements of an array."", ""ARRAY"")"
After the for loop the array is converted to a String using Arrays.toString() and printed out to the console (command line).,NULL
The Arrays.sort() example shown earlier only works for Java arrays of primitive data types.,"(""Arrays.sort()"", ""The Arrays.sort() method is used for sorting Java arrays"", ""Java"")"
Here is first the class for the objects we want to sort:,NULL
The class Employee is a simple model of an employee (I have created the Employee class).,NULL
Here is first an example of sorting an array of Employee objects by their name using the Arrays.sort() method:,NULL
The array is of type Employee - the class I showed you earlier.,"(""Employee"", ""class"")"
"As parameter to the Arrays.sort() method we pass the employee array, and a Comparator implementation which can determine the order of Employee objects.","(""Arrays.sort"", ""The employee array is passed as a parameter to the Arrays.sort method to be sorted."", ""employee array""); (""Comparator"", ""A Comparator implementation determines the order of Employee objects during sorting."", ""Employee"")"
Anonymous implementations of interfaces are covered in my text about nested classes in Java.,NULL
What is important to catch in this example is the implementation of the compare() method of the anonymous inner implementation of the Comparator interface.,"(""COMPARE"", ""The COMPARE method is implemented within the context of the COMPARATOR class, indicating a functional relationship where COMPARE acts as a method of COMPARATOR."", ""COMPARATOR"")"
In the example above we simply call the String.compare() method which does the comparison for us (compares the employee names).,"(""STRING"", ""The COMPARE method is used by the STRING class to perform a comparison operation."", ""COMPARE"")"
"Here is the example from before, with a modified implementation of the compare() method of the anonymous implementation of the Comparator interface:","(""COMPARE"", ""The compare method is an implementation detail of the Comparator interface, indicating that it defines or overrides a functionality within this interface."", ""COMPARATOR"")"
Notice how the compare() method returns the difference between the employee ids by subtracting one from the other.,"(""Compare"", ""The compare method operates on Employee Ids by calculating the difference between them."", ""Employee Ids"")"
"To compare the Employee objects in the array first by their name, and if that is the same, then by their employee id, the compare() implementation would look like this:",NULL
These Arrays.fill() methods can fill an array with a given value.,"(""Arrays.fill()"", ""The method 'Arrays.fill()' is used to fill an element of 'array' with a given value, indicating a relationship between the method and the array it operates on."", ""array"")"
Here is an example of using Arrays.fill() to fill an int array:,NULL
"There is a version of the Arrays.fill() method which takes a from and to index, so only elements with indexes in this interval are filled with the given value.","(""Arrays.fill"", ""method"")"
"You can do so yourself, or via the Arrays.sort() method covered earlier in this text.",NULL
The binarySearch() method will return the index in the array in which the element was found.,NULL
"If all elements in the array are smaller than the sought value, then binarySearch() will return - length of the array - 1.",NULL
Therefore binarySearch() will return -length (-6) - 1 = -6 -1 = -7.,NULL
The Arrays.binarySearch() method also exists in a version where you just search part of the array.,NULL
"This version of binarySearch() works just like the other version, except in the cases where no matching element is found.",NULL
"If no element is found matching within the index interval, then binarySearch() will still return the index of where the value should have been inserted.","(""binarySearch"", ""binarySearch is a method that operates within an index interval to search for elements"", ""index"")"
"But, if all values in the interval are smaller than the sought value, binarySearch() will return -toIndex -1 , and not -array length - 1.","(""BinarySearch"", ""The method binarySearch() is related to toIndex because it potentially returns a value based on toIndex in the process of searching."", ""ToIndex"")"
The java.util.Arrays class contains a set of methods called equals() which can be used to check if two Java arrays are equal.,NULL
"Java classes are some of the core building blocks of Java applications, toolkits, frameworks, APIs etc.","(""Java"", ""Java packages often contain and utilize Java classes as core components of their structure."", ""Classes""); (""Java"", ""Java packages often contain and utilize Java classes as core components of their structure."", ""Classes"")"
"A small Java application may consist of a single Java class with a main() method in, as covered in the Java main method tutorial.","(""Java Class"", ""The main method is a part of the Java class."", ""Main Method""); (""Main Method"", ""The Java main method tutorial covers details about the main method."", ""Java Main Method Tutorial""); (""Java Class"", ""The main method is a part of the Java class."", ""Main Method""); (""Main Method"", ""The Java main method tutorial covers details about the main method."", ""Java Main Method Tutorial"")"
"As your Java application grows, keeping all the code in the same class makes it harder and harder to keep an overview of the code.","(""Class"", ""class"")"
Therefore it might be beneficial to start splitting the Java code up into multiple classes.,"(""Java"", ""Java code is organized into multiple classes indicating a structure or design pattern in Java programming"", ""Classes""); (""Java"", ""Java code is organized into multiple classes indicating a structure or design pattern in Java programming"", ""Classes"")"
"A Java class is a single, coherent unit of Java code which belongs together.",NULL
A Java class may contain a mix of data (variables) and actions (methods).,"(""Java Class"", ""A Java class may contain methods, establishing a functional relationship between them"", ""Methods"")"
Grouping variables and operations on these variables into Java classes makes it easier to structure your Java program when it gets too big to fit comfortably inside a single Java class.,NULL
"Therefore, as the class grows, the file you are editing grows too, and becomes harder to keep an overview of in your head.",NULL
"Your Java application will typically have to contain at least a single Java class, but it may contain as many classes as you see fit to divide your application into.",NULL
"Java also comes with a lot of predefined classes for you, so you don't have to code every little function you might desire yourself.",NULL
"Fields are variables (data) that are local to the class, or instances (objects) of that class.","(""Class"", ""Methods are functions that belong to a class"", ""Method""); (""Class"", ""Packages can contain multiple classes"", ""Package"")"
Methods are operations that the class or instances of that class can perform.,NULL
Nested classes are Java classes that are defined inside another class.,NULL
"Nested classes are typically intended to either be used only internally be the Java class that contains them, or to be used in connection with the class that contains them.","(""Java Class"", ""Nested classes are intended to be used internally by the Java class or in connection with it."", ""Nested Classes"")"
Nested classes are covered in more detail in my Java nested class tutorial.,"(""Java"", ""The nested class is a feature described within the Java package or language context."", ""Nested Class"")"
"Sometimes you have classes that only contain fields (data), and sometimes you have classes that only contain methods (operations).",NULL
It depends on what the Java class is supposed to do.,NULL
All it takes to define a class in Java is this:,NULL
The above class definition should be put in its own file named MyClass.java.,NULL
"Java files should be named the same as the name of the class they contain, with the .java as file name extension.",NULL
Make sure you keep the same uppercase and lowercase characters from the class name in the file name too.,"(""Class Name"", ""class"")"
"Only put a single class definition in each Java file, unless your class contains inner classes of some kind.",NULL
"As mentioned earlier, a Java class can contain data in the shape of variables.","(""Java Class"", ""A Java Class can contain data in the shape of Variables, which implies a containment relationship."", ""Variable"")"
The next example shows a Java class which is to model a car.,NULL
A constructor is a special method that is called when an object of the given class is created (explained later).,"(""Constructor"", ""The constructor is a special method that is called when an object of the given class is created"", ""Object"")"
The purpose of a constructor is to initialize the fields in the class.,"(""Constructor"", ""A constructor is used to initialize the fields within a class."", ""Fields"")"
Here is an example of a Java class with two constructors:,"(""Java"", ""class"")"
"The constructors are the two methods that have the same name as the class, and which have no return type specified.",NULL
"A Java method contains Java instructions that typically perform some operations on a field in the class, or on one of the parameters (also variables) values passed to the method when the method was called.",NULL
"Here is the Java class, Car example from the previous section with a method added:",NULL
In the class definition above I have added a setColor() method.,"(""Class"", ""The setColor method is defined within the Class"", ""setColor"")"
"As mentioned earlier, you can define a nested class inside another Java class.",NULL
Here is an example of defining a nested class inside a Java class:,"(""Java"", ""A Nested Class is being defined inside a Java Class."", ""Nested Class"")"
"In the example above, the outer class is called MyClass and the nested class is called MyNestedClass .",NULL
"Neither of the classes in this example has any fields or methods, but both the outer and nested class could have as many fields and methods as you see fit.","(""CLASS"", ""The CLASS entity can contain METHOD as part of its structure."", ""METHOD""); (""OUTER CLASS"", ""The OUTER CLASS entity can contain the NESTED CLASS within its structure."", ""NESTED CLASS"")"
You can read more about nested classes in my tutorial about nested classes in Java,NULL
A Java class is a template for how objects of that class looks.,NULL
"In other words, the Car class in the previous section is a template for how Car objects look.",NULL
"To create objects of a certain class, you use the new keyword.","(""Class"", ""Class""); (""Class"", ""Class"")"
"This example creates 3 Car variables, and assign a new instance of the Car class to each variable.",NULL
"Thus, the fields of different objects (even of the same class) can vary independently of each other.",NULL
"After creating the 3 Car objects, the setColor() method is called on each object.","(""setColor"", ""The setColor method is invoked on Car objects."", ""Car"")"
"Creating an object of a certain class is also called ""instantiating"" an object.","(""object"", ""An object is an instance of a class in object-oriented programming."", ""Class""); (""object"", ""An object is an instance of a class in object-oriented programming."", ""Class"")"
"The object is thus also called an ""instance"" of the given class.",NULL
"For instance, each of the Car objects above are also called an instance of the Car class, or simply ""Car instances"".","(""Car"", ""Car class refers to the blueprint or template from which Car instances or objects are created."", ""Car"")"
What you have seen in this text only covers the very basics of Java classes.,NULL
"You need to learn about fields, constructors, methods nested classes, abstract classes, inheritance, access modifiers and interfaces too.",NULL
"Here is a simple example that creates an object, which results in the class constructor being called:",NULL
The example shows a very simple Java class with a single constructor.,"(""Java Class"", ""The Constructor is a method defined within the Java Class."", ""Constructor"")"
The second part of a Java constructor declaration is the name of the class the constructor belongs to.,NULL
Using the class name for the constructor signals to the Java compiler that this is a constructor.,"(""Class"", ""The mention of using the class name signals that the Constructor is related to the Class, indicating the relationship between them in Java programming."", ""Constructor"")"
The constructor parameters are declared inside the parentheses () after the class name part of the constructor .,"(""Constructor"", ""Parameters are declared as inputs within the Constructor class."", ""Parameters"")"
"A class can have multiple constructors, as long as their signature (the parameters they take) are not the same.","(""Class"", ""class""); (""Class"", ""class"")"
"When a Java class contains multiple constructors, we say that the constructor is overloaded (comes in multiple versions).",NULL
"This is what constructor overloading means, that a Java class contains multiple constructors.",NULL
The keyword this in front of the field name (this.number) is not necessary.,"(""THIS"", ""The keyword 'this' is used in front of the field name"", ""FIELD NAME"")"
"You don't have to define a constructor for a class, but if you don't define any constructor, the Java compiler will insert a default, no-argument constructor for you.","(""CLASS"", ""A constructor is usually a method used within a class."", ""METHOD""); (""JAVA COMPILER"", ""The Java compiler automatically inserts a default constructor if none is defined."", ""METHOD"")"
"Thus, once the class is compiled it will always at least have a no-argument constructor.",NULL
"If you do define a constructor for your class, then the Java compiler will not insert the default no-argument constructor into your class.","(""Constructor"", ""A constructor is defined for the class to initialize its objects."", ""Class""); (""Java Compiler"", ""The Java compiler inserts the default no-argument constructor into the class."", ""Class"")"
The parameters are passed to the constructor inside the parentheses after the class name on the right side of the equal sign.,"(""Constructor"", ""class"")"
"By default, if a parameter (or local variable) has the same name as a field in the same class, the parameter (or local variable) ""shadows"" for the field.",NULL
"Inside the constructor of the Employee class the firstName, lastName and birthYear identifiers now refer to the constructor parameters, not to the Employee fields with the same names.","(""constructor"", ""The constructor is a method associated with initializing instances of the Employee class."", ""Employee"")"
"To signal to the Java compiler that you mean the fields of the Employee class and not the parameters, put the this keyword and a dot in front of the field name.","(""Employee"", ""The 'this' keyword relates to the fields of the 'Employee' class, indicating which class attributes are being referenced."", ""this"")"
You call a constructor when you create a new instance of the class containing the constructor.,"(""Constructor"", ""A constructor is called when a new instance of the class is created"", ""Instance"")"
"In case you want to pass parameters to the constructor, you include the parameters between the parentheses after the class name, like this:","(""Constructor"", ""class"")"
The this keyword followed by parentheses and parameters means that another constructor in the same Java class is being called.,NULL
In this example it is the first constructor in the class that is being called.,NULL
"When a class extends another class it is also said to ""inherit"" from the class it extends.",NULL
"The class that extends is called the subclass, and the class being extended is called the superclass.",NULL
A class that extends another class does not inherit its constructors.,"(""Class"", ""Classes can have methods such as constructors that are not inherited when one class extends another"", ""Constructor"")"
"However, the subclass must call a constructor in the superclass inside of its the subclass constructors!",NULL
"If a subclass calls another constructor within itself, then the called constructor must call the superclass constructor.","(""Subclass"", ""A subclass can invoke a constructor within itself."", ""Constructor""); (""Constructor"", ""The called constructor must invoke the superclass constructor."", ""Superclass"")"
It calls the constructor in the superclass using this Java statement:,"(""Constructor"", ""The constructor is called in the superclass, indicating a relationship between a method and a class."", ""Superclass""); (""Java"", ""The constructor is invoked using a Java statement, connecting the method to the Java package."", ""Constructor"")"
Using the keyword super refers to the superclass of the class using the super keyword.,"(""SUPER"", ""The keyword 'super' is used to refer to its superclass."", ""SUPERCLASS"")"
"When super keyword is followed by parentheses like it is here, it refers to a constructor in the superclass.","(""Super"", ""The 'super' keyword is mentioned in the context of referring to a constructor in the superclass, indicating a relationship where 'super' is used to invoke or access properties of a superclass."", ""Superclass""); (""Super"", ""The 'super' keyword is mentioned in the context of referring to a constructor in the superclass, indicating a relationship where 'super' is used to invoke or access properties of a superclass."", ""Superclass"")"
In this case it refers to the constructor in the Vehicle class.,"(""constructor"", ""The constructor is a method that belongs to the Vehicle class."", ""Vehicle"")"
The access modifier of a constructor determines what classes in your application that are allowed to call that constructor.,"(""Class"", ""A class in the application can call the constructor based on its access modifier."", ""Constructor"")"
"For instance, if a constructor is declared protected then only classes in the same package, or subclasses of that class can call that constructor.",NULL
"A class can have multiple constructors, and each constructor can have its own access modifier.","(""Class"", ""A class can have multiple constructors"", ""Constructor"")"
"Thus, some constructors may be available to all classes in your application, while other constructors are only available to classes in the same package, subclasses, or even only to the class itself (private constructors).",NULL
Here is an example of a Java class with a constructor that can throw an exception:,"(""Java"", ""A constructor is a special method used to initialize objects, often operating within the context of a Java package."", ""Constructor""); (""Java"", ""A constructor is a special method used to initialize objects, often operating within the context of a Java package."", ""Constructor"")"
Making a constructor throw an exception can be a good idea if you want to prevent an object of the given class to be created in an invalid state.,"(""Constructor"", ""A constructor is a special method of a class used to create an instance of the class."", ""Class"")"
"A class can have fields, constructors and methods (plus more, but that is not important now).","(""Class"", ""A class comprises methods as part of its structure"", ""Methods"")"
"When you create an object, that object is of a certain class.","(""Object"", ""An object is instantiated from a class, indicating a relationship where the class defines the structure and behavior of the object."", ""Class""); (""Object"", ""An object is instantiated from a class, indicating a relationship where the class defines the structure and behavior of the object."", ""Class"")"
The class is like a template (or blueprint) telling how objects of that class should look.,"(""Class"", ""class"")"
"When you create an object, you say ""give me an object of this class"".",NULL
"If you think of a factory producing lots and lots of the same items, then the class would be the blueprint / manual of how the finished product should look, and the objects would be each of the finished products.",NULL
"If the factory produced cars, then the blueprint / design manual of the cars to produce corresponds to a Java class, and the physical cars produced corresponds to Java objects.","(""Class"", ""A Java class is a blueprint or template that defines the structure and behavior of Java objects, relating them fundamentally in object-oriented programming"", ""Object"")"
Here is a simple diagram illustrating the principle of objects being of a certain class.,"(""Objects"", ""Class"")"
The class determines what fields and methods the objects of that class have.,"(""Class"", ""A class determines what methods the objects of that class have, indicating that methods are defined within the class context."", ""Method"")"
"The Car class does not contain any fields, constructors or methods.","(""Car"", ""class"")"
The example primarily serves to show you an example of how a class declaration looks in Java code.,"(""Java"", ""The class declaration is an example of a Java code structure, demonstrating the relationship between Java as a language and class declarations as fundamental components within Java."", ""class declaration"")"
A field is a variable that belongs to a class or an object.,"(""Class"", ""class"")"
"For instance, a Car class could define the field brand which all Car objects would have.","(""Car"", ""The 'brand' is a field defined within the 'Car' class that all Car objects would have."", ""brand"")"
Here is the Car class declaration from above with a field name brand added:,"(""Car"", ""class""); (""Car"", ""class"")"
Constructors are a special kind of method that is executed when an object of that class is created.,NULL
Here is the Car class from before with a constructor that initializes the brand field:,NULL
"Here is the Car class from before with a single, simple method named getBrand added:","(""Car"", ""The getBrand method is a member function of the Car class."", ""getBrand""); (""Car"", ""The getBrand method is a member function of the Car class."", ""getBrand"")"
"When a class implements an interface, the class has to implement all the methods described in the interface.","(""Class"", ""A class must implement all the methods described in an interface it implements."", ""Method"")"
"Packages provides a handy way of grouping related classes and interfaces, thus making modularization of your Java code easier.","(""Packages"", ""Packages are used for grouping related classes."", ""Classes""); (""Packages"", ""Packages are used for grouping related interfaces."", ""Interfaces"")"
"That these are primitive data types means that they are not objects, nor references to objects (classes and objects are explained in later texts in this Java tutorial).",NULL
You can also create your own more complex data types by creating custom classes.,NULL
"More precisely, a Java enum type is a special kind of Java class.","(""Java enum type"", ""A Java enum type is described as a special kind of Java class, indicating a direct relationship between the two."", ""Java class"")"
Notice the enum keyword which is used in place of class or interface.,NULL
Replace the ... with the code to execute if the level variable matches the given Level constant value.,NULL
You can obtain an array of all the possible values of a Java enum type by calling its static values() method.,NULL
All enum types get a static values() method automatically by the Java compiler.,"(""Enum Types"", ""The values() method is automatically generated for enum types by the compiler."", ""Values()""); (""Values()"", ""The Java compiler generates the values() method for enum types."", ""Java Compiler"")"
An enum class automatically gets a toString() method in the class when compiled.,"(""Enum Class"", ""Enum Class automatically gets the ToString method when compiled."", ""ToString""); (""Enum Class"", ""An Enum Class is a type of Class in programming."", ""Class"")"
The toString() method returns a string value of the name of the given enum instance.,NULL
"Then the toString() method will get called behind the scenes, so the value that will be printed out is the textual name of the enum instance.",NULL
An enum class automatically gets a static valueOf() method in the class when compiled.,NULL
The valueOf() method can be used to obtain an instance of the enum class for a given String value.,NULL
The level variable will point to the Level.HIGH after executing this line.,"(""Level"", ""HIGH is an attribute or possible value within the Level class."", ""HIGH"")"
It is possible for a Java enum class to have abstract methods too.,"(""Java Enum Class"", ""A Java enum class can contain abstract methods, indicating a relationship between the two entities."", ""Abstract Methods"")"
"If an enum class has an abstract method, then each instance of the enum class must implement it.",NULL
Notice the abstract method declaration at the bottom of the enum class.,"(""Enum Class"", ""The abstract method is declared within the enum class"", ""Abstract Method"")"
It is the method getDescription() that comes from the interface MyInterface.,"(""Getdescription"", ""The method Getdescription() is part of the interface Myinterface, indicating a usage or implementation link between the method and the interface."", ""Myinterface"")"
"Java enums extend the java.lang.Enum class implicitly, so your enum types cannot extend another class.","(""ENUM"", ""ENUM is implicitly extending JAVA.LANG.ENUM, indicating inheritance from this class."", ""JAVA.LANG.ENUM"")"
"The purpose of this exercise is to verify that you know how to create classes, how to create instance variables inside the classes, how to create an array of objects and how to iterate that array while referencing the objects in it.",NULL
"For instance, in a class representing an employee, the Employee class might contain the following fields:","(""Employee"", ""class"")"
The access modifier determines which object classes that can access the field.,"(""Access Modifier"", ""The access modifier determines which classes can access the field."", ""Field"")"
"In Java, static fields belongs to the class, not instances of the class.",NULL
"Thus, all instances of any class will access the same static field variable.","(""Class"", ""All instances of any class can access the static field variable, indicating a relationship between the two."", ""Static Field Variable"")"
A non-static field value can be different for every object (instance) of a class.,"(""FIELD"", ""The field value is associated with the CLASS through instances in object-oriented programming."", ""CLASS"")"
The Java field access modifier determines whether the field can be accessed by classes other than the the class owning the field.,"(""Field"", ""The field is owned by a class and its accessibility from other classes is controlled by the access modifier."", ""Class""); (""Field"", ""The field is owned by a class and its accessibility from other classes is controlled by the access modifier."", ""Class"")"
The private access modifier means that only code inside the class itself can access this Java field.,"(""Class"", ""The class is self-referential as only code inside itself can access the private field."", ""Class"")"
"The package access modifier means that only code inside the class itself, or other classes in the same package, can access the field.","(""Access Modifier"", ""The 'access modifier' term is related to fields as it defines the access rules for these entities within a class."", ""Field""); (""Package"", ""The 'package' term relates to fields since fields can be accessed by classes in the same package."", ""Field""); (""Access Modifier"", ""The 'access modifier' term specifies rules that affect both the class and its fields within the same package."", ""Package"")"
"The protected access modifier is like the package modifier, except subclasses of the class can also access the field, even if the subclass is not located in the same package.","(""Package"", ""The subclass can access the field in a class even if it's not in the same package."", ""Subclass""); (""Class"", ""Subclasses of the class can access protected members whether or not they are in the same package."", ""Subclass""); (""Class"", ""Fields are members of a class that can have protected access."", ""Field""); (""Protected Access Modifier"", ""The protected access modifier allows access within the same package or subclass."", ""Package""); (""Package"", ""The subclass can access the field in a class even if it's not in the same package."", ""Subclass""); (""Class"", ""Subclasses of the class can access protected members whether or not they are in the same package."", ""Subclass""); (""Class"", ""Fields are members of a class that can have protected access."", ""Field""); (""Protected Access Modifier"", ""The protected access modifier allows access within the same package or subclass."", ""Package"")"
The public access modifier means that the field can be accessed by all classes in your application.,NULL
You would probably not use all access modifiers in the same class.,"(""Class"", ""Methods are typically contained within a class."", ""Method"")"
"For simple, data carrying classes you may declare all fields public.",NULL
"Thus, no matter how many objects you create of that class, there will only exist one field located in the class, and the value of that field is the same, no matter from which object it is accessed.","(""Class"", ""The text mentions that the field exists within the class and its value is accessed from the class, indicating a relationship where the field belongs to or is a part of the class."", ""Field"")"
"Static fields are located in the class, so you don't need an instance of the class to access static fields.",NULL
"Non-static Java fields, on the other hand, are located in the instances of the class.","(""Class"", ""Non-static Java fields are properties or attributes that belong to the instances of the Class."", ""Non-static Java fields"")"
Each instance of the class can have its own values for these fields.,"(""Class"", ""class"")"
To access a non-static field you need an instance of the class (an object) on which you can access it.,"(""Class"", ""You need an instance of the class to access the non-static field, indicating a relationship between the class and the field."", ""Field"")"
"That means, that even if the field belongs to objects (class instances), you cannot vary the value of the field from object to object.","(""Class"", ""Objects are instances or derivatives of a Class"", ""Object""); (""Class"", ""Objects are instances or derivatives of a Class"", ""Object"")"
"That way it only exists in the class, not in every object too.",NULL
"The first line creates a new Customer object (an instance of the Customer class), and stores it in a variable called customer.","(""Customer"", ""class"")"
A class is loaded the first time it is referenced in your program.,"(""Class"", ""class""); (""Class"", ""class"")"
"Inside the parentheses () after the for keyword, are three statements separated by semicolon (;).",NULL
"In this example, only the first System.out.println() statement is executed inside the for loop.","(""System"", ""The println() method is accessed through the System class via the out field, which is part of the System class."", ""println""); (""System"", ""The out is a static member of the System class."", ""out"")"
The second System.out.println() statement is not executed until after the for loop is finished.,"(""System"", ""System is a class that contains the out method"", ""out""); (""out"", ""out method is used to call the println method"", ""println"")"
"Second, inside the isValid() method the String.equals() method is used to test for equality to a certain string value.",NULL
The isValid() method could actually have been written in a shorter way.,NULL
Now the isValid() method returns the value returned by the value.equals() method call.,"(""isValid"", ""The isValid method returns the result of calling the value.equals() method, indicating a relationship of dependency or usage between these two methods."", ""value.equals"")"
Java inheritance refers to the ability in Java for one class to inherit from another class.,NULL
One class can extend another class and thereby inherit from that class.,NULL
"When one class inherits from another class in Java, the two classes take on certain roles.","(""Class"", ""A 'class' inherits from another 'class', indicating an inheritance relationship between two 'class' entities in Java."", ""Class"")"
The class that extends (inherits from another class) is the subclass and the class that is being extended (the class being inherited from) is the superclass .,NULL
"A subclass is a specialization of a superclass, and a superclass is a generalization of one or more subclasses.",NULL
"Inheritance can be an effective method to share code between classes that have some traits in common, yet allowing the classes to have some parts that are different.",NULL
"Here is diagram illustrating a class called Vehicle, which has two subclasses called Car and Truck.",NULL
The Vehicle class can contain those fields and methods that all Vehicles need (e.g.,"(""Vehicle"", ""class"")"
Note: Some people will claim that inheritance is a way to categorize your classes based on what they are.,"(""Classes"", ""Inheritance is a mechanism often used to categorize classes based on their characteristics or behaviors."", ""Inheritance"")"
"In practice, however, that is not how you determine which superclasses and subclasses your application needs to have.",NULL
Then it makes sense to have a common Vehicle superclass for the two classes.,"(""Vehicle"", ""class""); (""Vehicle"", ""class"")"
"If you never process Car and Truck objects in the same way, there is no point in having a common superclass for them, except perhaps to share code between them (to avoid writing duplicate code).",NULL
Superclasses and subclasses form an inheritance structure which is also called a class hierarchy.,"(""Superclass"", ""A hierarchy suggests that superclasses are higher in the structure and provide inherited properties to subclasses."", ""Subclass""); (""Subclass"", ""Subclasses are part of a class hierarchy, indicating their role in the overall structure."", ""Class Hierarchy"")"
At the top of the class hierarchy you have the superclasses.,"(""Class Hierarchy"", ""The superclasses are at the top of the class hierarchy, indicating a hierarchical relationship where superclasses derive or extend from the class hierarchy."", ""Superclasses"")"
At the bottom of the class hierarchy you have the subclasses.,NULL
"A class hierarchy may have multiple levels, meaning multiple levels of superclasses and subclasses.",NULL
A subclass may itself be a superclass of other subclasses etc.,NULL
"When a class inherits from a superclass, it inherits parts of the superclass methods and fields.",NULL
"When a subclass extends a superclass in Java, all protected and public fields and methods of the superclass are inherited by the subclass.",NULL
"By inherited is meant that these fields and methods are part of of the subclass, as if the subclass had declared them itself.",NULL
protected and public fields can be called and referenced just like the methods declared directly in the subclass.,"(""FIELDS"", ""Fields and methods are both elements that can be called or referenced within a subclass."", ""METHODS"")"
Fields and methods with default (package) access modifiers can be accessed by subclasses only if the subclass is located in the same package as the superclass.,"(""Subclasses"", ""Subclasses can access methods with default package access if they are in the same package."", ""Methods""); (""Subclasses"", ""Subclasses and superclasses need to be in the same package for field and method access."", ""Superclass"")"
Private fields and methods of the superclass can never be referenced directly by subclasses.,"(""Methods of the Superclass"", ""Subclasses cannot directly reference private methods"", ""Subclasses""); (""Private Fields"", ""Subclasses cannot directly reference private fields"", ""Subclasses""); (""Methods of the Superclass"", ""Subclasses cannot directly reference private methods"", ""Subclasses""); (""Private Fields"", ""Subclasses cannot directly reference private fields"", ""Subclasses"")"
"They can, however, be referenced indirectly via methods reachable from the subclass (e.g default (package), protected and public methods).",NULL
"Constructors are not inherited by subclasses, but a subclass constructor must call a constructor in the superclass.","(""Subclasses"", ""Subclasses cannot inherit Constructors."", ""Constructors""); (""Subclass Constructor"", ""Subclass Constructor must call a constructor in the Superclass."", ""Superclass Constructor"")"
The Java inheritance mechanism only allows a Java class to inherit from a single superclass (singular inheritance).,"(""Class"", ""A class in Java can inherit from a single superclass, demonstrating an inheritance relationship."", ""Superclass""); (""Class"", ""A class in Java can inherit from a single superclass, demonstrating an inheritance relationship."", ""Superclass"")"
"In some programming languages, like C++, it is possible for a subclass to inherit from multiple superclasses (multiple inheritance).",NULL
"the superclasses contain methods with the same names and parameters, multiple inheritance was left out in Java.","(""Superclasses"", ""Superclasses contain methods, indicating a class-method relationship."", ""Methods"")"
You declare that one class extends another class by using the extends keyword in the class definition.,"(""Class"", ""The keyword 'extends' is used in the context of class definitions to indicate that one class is extending or inheriting from another class."", ""Extends"")"
"The Car class in this example extends the Vehicle class, meaning the Car class inherits from the Vehicle class.","(""Car"", ""The Car class extends the Vehicle class, indicating that Car inherits from Vehicle."", ""Vehicle""); (""Car"", ""The Car class extends the Vehicle class, indicating that Car inherits from Vehicle."", ""Vehicle"")"
"Because the Car class extends the Vehicle class, the protected field licensePlate from the Vehicle class is inherited by the Car class.",NULL
"The licensePlate field is not actually being referenced from the Car class in the code above, but it could if we wanted to.","(""Car"", ""class""); (""Car"", ""class""); (""Car"", ""class"")"
In many cases it would have made sense to place the getLicensePlate() method in the Vehicle class where the licensePlate field is located.,"(""GetLicensePlate"", ""The method getLicensePlate() is logically associated with the Vehicle class where the licensePlate field is located."", ""Vehicle"")"
I just placed the getLicensePlate() method in the Car class to show that it is possible.,"(""GetLicensePlate"", ""The GetLicensePlate method is a function defined within the Car class."", ""Car"")"
It is possible to reference a subclass as an instance of one of its superclasses.,"(""Subclass"", ""Subclass is an instance of one of its Superclass."", ""Superclass"")"
"For instance, using the class definitions from the example in the previous section it is possible to reference an instance of the Car class as an instance of the Vehicle class.",NULL
"Because the Car class extends (inherits from) the Vehicle class, it is also said to be a Vehicle.",NULL
Here is a Java code example: Car car = new Car(); Vehicle vehicle = car; First a Car instance is created.,"(""Car"", ""Car instances can be assigned to a variable of type Vehicle, indicating an inheritance or interface implementation relationship in object-oriented programming."", ""Vehicle"")"
This is possible because the Car class inherits from the Vehicle class.,"(""Car"", ""The Car class inherits from the Vehicle class, indicating a class inheritance relationship."", ""Vehicle"")"
"As you can see, it is possible to use an instance of some subclass as if it were an instance of its superclass.","(""Subclass"", ""A subclass is related to its superclass because it inherits properties and methods from the superclass."", ""Superclass"")"
"That way, you don't need to know exactly what subclass the object is an instance of.","(""Subclass"", ""class"")"
The process of referencing an object of class as a different type than the class itself is called type casting.,"(""Class"", ""The text refers to referencing an object of a class as a different type, implicating an intrinsic relationship between class instances and class types."", ""Class"")"
Upcasting and Downcasting You can always cast an object of a subclass to one of its superclasses.,NULL
This is referred to as upcasting (from a subclass type to a superclass type).,"(""Subclass"", ""Upcasting involves converting an object of a subclass to a superclass type, indicating a relationship between subclass and superclass."", ""Superclass"")"
"It may also be possible to cast an object from a superclass type to a subclass type, but only if the object really is an instance of that subclass (or an instance of a subclass of that subclass).",NULL
This is referred to as downcasting (from a superclass type to a subclass type).,NULL
"Thus, this example of downcasting is valid: Car car = new Car(); // upcast to Vehicle Vehicle vehicle = car; // downcast to car again Car car2 = (Car) vehicle; However, the following downcast example is not valid.","(""Car"", ""Car is cast to a Vehicle and then downcast back to Car, illustrating upcasting and downcasting concepts."", ""Vehicle""); (""Car"", ""Car is cast to a Vehicle and then downcast back to Car, illustrating upcasting and downcasting concepts."", ""Vehicle"")"
"Truck truck = new Truck(); // upcast to Vehicle Vehicle vehicle = truck; // downcast to car again Car car = (Car) vehicle; The Truck object can be upcast to a Vehicle object, but it cannot be downcast to a Car object later.",NULL
Overriding Methods In a subclass you can override (redefine) methods defined in the superclass.,"(""Subclass"", ""A 'subclass' is related to a 'superclass' by being a specialized form or extension of it."", ""Superclass""); (""Subclass"", ""In the context of object-oriented programming, a 'subclass' has the ability to override 'methods' from its 'superclass'."", ""Overriding Methods"")"
Here is a Java method override example: public class Vehicle { String licensePlate = null; public void setLicensePlate(String licensePlate) { this.licensePlate = licensePlate; } } public class Car extends Vehicle { public void setLicensePlate(String license) { this.licensePlate = license.toLowerCase(); } } Notice how both the Vehicle class and the Car class defines a method called setLicensePlate().,"(""Vehicle"", ""The Vehicle class contains a method named setLicensePlate."", ""setLicensePlate""); (""Car"", ""The Car class extends Vehicle and overrides the setLicensePlate method."", ""setLicensePlate"")"
"Now, whenever the setLicensePlate() method is called on a Car object, it is the method defined in the Car class that is called.",NULL
To override a method the method signature in the subclass must be the same as in the superclass.,"(""Superclass"", ""A subclass inherits from a superclass, allowing method overriding in object-oriented programming."", ""Subclass""); (""Method"", ""A subclass can override methods to provide specific implementations different from its superclass."", ""Subclass"")"
"That means that the method definition in the subclass must have exactly the same name and the same number and type of parameters, and the parameters must be listed in the exact same sequence as in the superclass.","(""Method"", ""The Method is part of the Subclass, as it is described in how it must be defined within the Subclass."", ""Subclass""); (""Method"", ""The Method refers to a definition that exists in the Superclass, indicating the hierarchical relation between Superclass and Subclass."", ""Superclass"")"
Otherwise the method in the subclass will be considered a separate method.,NULL
"If the superclass calls a private method internally from some other method, it will continue to call that method from the superclass, even if you create a private method in the subclass with the same signature.",NULL
"It would be nice if the compiler could tell you that the method being overridden no longer overrides a method in the superclass, right?","(""METHOD"", ""The METHOD is part of the SUPERCLASS, as it refers to the method being overridden in the superclass."", ""SUPERCLASS"")"
"You can call superclass implementations from any method in a subclass, like above.","(""Subclass"", ""A subclass can call methods from its superclass"", ""Superclass""); (""Method"", ""Methods can be invoked from the superclass implementation"", ""Superclass"")"
"For instance, you could also have called super.setLicensePlate() from a method in the Car class called updateLicensePlate() which does not override the setLicensePlate() method.","(""Car"", ""The updateLicensePlate() method is in the Car class."", ""updateLicensePlate()""); (""Car"", ""The setLicensePlate() method is related to Car through a superclass."", ""setLicensePlate()""); (""updateLicensePlate()"", ""updateLicensePlate() method does not override setLicensePlate(), indicating a relationship in the class hierarchy."", ""setLicensePlate()""); (""Car"", ""The updateLicensePlate() method is in the Car class."", ""updateLicensePlate()""); (""Car"", ""The setLicensePlate() method is related to Car through a superclass."", ""setLicensePlate()""); (""updateLicensePlate()"", ""updateLicensePlate() method does not override setLicensePlate(), indicating a relationship in the class hierarchy."", ""setLicensePlate()"")"
The instanceof instruction can determine whether a given object is an instance of some class.,NULL
Here is a Java instanceof example: Car car = new Car(); boolean isCar = car instanceof Car; After this code has been executed the isCar variable will contain the value true.,"(""car"", ""The variable 'car' is an instance of the class 'Car', demonstrated using the 'instanceof' method."", ""Car"")"
The instanceof instruction can also be used determine if an object is a instance of a superclass of its class.,NULL
"Here is an instanceof example that checks if a Car object is an instance of Vehicle: Car car = new Car(); boolean isVehicle = car instanceof Vehicle; Assuming that the Car class extends (inherits from) the Vehicle class, the isVehicle variable will contain the value true after this code is executed.",NULL
A Car object is also a Vehicle object because Car is a subclass of Vehicle.,"(""Car"", ""Car is a subclass of Vehicle"", ""Vehicle"")"
"Look at this instanceof example: Car car = new Car(); Vehicle vehicle = car; boolean isCar = vehicle instanceof Car; Even though the vehicle variable is of type Vehicle, the object it ends up pointing to in this example is a Car object.",NULL
"Here is the same instanceof example, but using a Truck object instead of a Car object: Truck truck = new Truck(); Vehicle vehicle = truck; boolean isCar = vehicle instanceof Car; After executing this code the isCar will contain the value false.","(""Truck"", ""Truck is assigned to the Vehicle type, indicating Truck is a subclass or implementer of a Vehicle."", ""Vehicle""); (""Vehicle"", ""The instance of Vehicle is checked against the Car class using the instanceof operator, suggesting a relationship in the type hierarchy."", ""Car"")"
"Fields and Inheritance As mentioned earlier, in Java fields cannot be overridden in a subclass.",NULL
"If you define a field in a subclass with the same name as a field in the superclass, the field in the subclass will hide (shadow) the field in the superclass.",NULL
"If the subclass tries to access the field, it will access the field in the subclass.","(""Subclass"", ""The subclass accesses the field, suggesting a relationship between the two entities."", ""Field"")"
"If, however, the subclass calls up into a method in the superclass, and that method accesses the field with the same name as in the subclass, it is the field in the superclass that is accessed.",NULL
Both the Vehicle class and Car class has the methods setLicensePlate() and getLicensePlate().,"(""Vehicle"", ""The Vehicle class has the method setLicensePlate."", ""setLicensePlate""); (""Vehicle"", ""The Vehicle class has the method getLicensePlate."", ""getLicensePlate""); (""Car"", ""The Car class has the method setLicensePlate."", ""setLicensePlate""); (""Car"", ""The Car class has the method getLicensePlate."", ""getLicensePlate"")"
The methods in the Car class calls the corresponding methods in the Vehicle class.,"(""Car"", ""The Car class contains methods that perform specific actions or calculations."", ""methods""); (""Vehicle"", ""The Vehicle class contains methods that perform tasks related to vehicle operations."", ""methods""); (""methods"", ""The methods in the Car class call the corresponding methods in the Vehicle class, indicating a relationship where Car methods utilize or override Vehicle methods."", ""Vehicle"")"
"The result is, that eventually both set of methods access the licensePlate field in the Vehicle class.",NULL
"The updateLicensePlate() method in the Car class however, accesses the licensePlate field directly.","(""UpdateLicensePlate"", ""The updateLicensePlate method is a member of the Car class, indicating a method-class relationship."", ""Car"")"
"Therefore, you will not get the same result if you call setLicensePlate() as when you call the updateLicense() method.","(""setLicensePlate"", ""Both are methods called to likely perform operations, but they produce different results when invoked."", ""updateLicense""); (""setLicensePlate"", ""Both are methods called to likely perform operations, but they produce different results when invoked."", ""updateLicense"")"
"Look at the following lines of Java code: Car car = new Car(); car.setLicensePlate(""123""); car.updateLicensePlate(""abc""); System.out.println(""license plate: "" + car.getLicensePlate()); This Java code will print out the text 123.","(""setLicensePlate"", ""setLicensePlate is a method that belongs to the Car class, used to set the license plate."", ""Car""); (""updateLicensePlate"", ""updateLicensePlate is a method that belongs to the Car class, used to update the license plate."", ""Car""); (""getLicensePlate"", ""getLicensePlate is a method that belongs to the Car class, used to retrieve the license plate."", ""Car"")"
The updateLicensePlate() method sets the license plate value on the licensePlate field in the Car class.,"(""UpdateLicensePlate"", ""The method updateLicensePlate is associated with the Car class as it sets the license plate value on a field within this class."", ""Car""); (""UpdateLicensePlate"", ""The method updateLicensePlate is associated with the Car class as it sets the license plate value on a field within this class."", ""Car"")"
"The getLicensePlate() method, however, returns the value of the licensePlate field in the Vehicle class.","(""GETLICENSEPLATE"", ""The GETLICENSEPLATE method is associated with the VEHICLE class because it returns a value from a field within this class."", ""VEHICLE"")"
"Therefore, the value 123 which is set as value for the licensePlate field in the Vehicle class via the setLicensePlate() method, is what is printed out.",NULL
"In other words, constructors of a superclass are not inherited by subclasses.","(""Superclass"", ""Constructors of a superclass are related to subclasses because they are typically involved when instances of the subclasses are initialized, even if they are not inherited."", ""Subclasses""); (""Superclass"", ""Constructors of a superclass are related to subclasses because they are typically involved when instances of the subclasses are initialized, even if they are not inherited."", ""Subclasses"")"
Subclasses can still call the constructors in the superclass using the super() contruct.,NULL
"In fact, a subclass constructor is required to call one of the constructors in the superclass as the very first action inside the constructor body.",NULL
Here is how that looks: public class Vehicle { public Vehicle() { } } public class Car extends Vehicle{ public Car() { super(); //perform other initialization here } } Notice the call to super() inside the Car constructor.,NULL
You may have seen Java classes where the subclass constructors did not seem to call the constructors in the superclass.,NULL
"However, the subclass constructors have still called superclass constructors in those case.","(""SUBCLASS CONSTRUCTORS"", ""SUBCLASS CONSTRUCTORS inherit behavior from SUPERCLASS CONSTRUCTORS by calling them"", ""SUPERCLASS CONSTRUCTORS"")"
"Let me explain why: If a class does not have any explicit constructor defined, the Java compiler inserts an implicit no-arg constructor.","(""Class"", ""A constructor is a specific type of method associated with a class."", ""Constructor""); (""Java Compiler"", ""The Java compiler inserts an implicit no-arg constructor if none is explicitly defined."", ""Constructor"")"
"Therefore the following version of Vehicle is equivalent to the version shown just above: public class Vehicle { } Second, if a constructor does not explicitly call a constructor in the superclass, the Java compiler inserts an implicit call to the no-arg constructor in the superclass.",NULL
"That means that the following version of the Car class is actually equivalent to the version shown earlier: public class Car extends Vehicle{ public Car() { } } In fact, since the constructor is now empty, we could leave it out and the Java compiler would insert it, and insert an implicit call to the no-arg constructor in the superclass.","(""Car"", ""Car is a subclass of Vehicle as indicated by 'extends Vehicle'."", ""Vehicle"")"
"This is how the two classes would look then: public class Vehicle { } public class Car extends Vehicle{ } Even though no constructors are declared in these two classes, they both get a no-arg constructor, and the no-arg constructor in the Car class will call the no-arg constructor in the Vehicle class.","(""Car"", ""The Car class extends the Vehicle class, indicating an inheritance relationship."", ""Vehicle""); (""Car"", ""The Car class extends the Vehicle class, indicating an inheritance relationship."", ""Vehicle"")"
"If the Vehicle class did not have a no-arg constructor, but had another constructor which takes parameters, the Java compiler would complain.","(""Vehicle"", ""The Vehicle class is likely part of the Java package or framework."", ""Java"")"
"The Car class would then be required to declare a constructor, and inside that constructor call the constructor in the Vehicle class.","(""Car"", ""Car class is required to declare a constructor, indicating it has a method called constructor."", ""constructor""); (""Car"", ""Indicates that Car class's constructor calls the constructor in the Vehicle class, showing a relationship between these two classes through their constructors."", ""Vehicle"")"
Nested Classes and Inheritance The same Java inheritance rules apply to nested classes.,"(""Nested Classes"", ""Nested Classes and Inheritance are related as nested classes can follow inheritance rules."", ""Inheritance""); (""Inheritance"", ""Inheritance is a fundamental concept in Java programming and applies to its classes."", ""Java"")"
Nested classes with the default (package) access modifier are only accessible to subclasses if the subclass is located in the same package as the superclass.,NULL
Nested classes with the protected or public access modifier are always inherited by subclasses.,"(""Nested Classes"", ""Nested classes are inherited by subclasses when they have the protected or public access modifier."", ""Subclasses"")"
Here is a nested class inheritance example: class MyClass { class MyNestedClass { } } public class MySubclass extends MyClass { public static void main(String[] args) { MySubclass subclass = new MySubclass(); MyNestedClass nested = subclass.new MyNestedClass(); } } Notice how it is possible to create an instance of the nested class MyNestedClass which is defined in the superclass (MyClass) via a reference to the subclass (MySubclass).,NULL
Here is now that looks: public final class MyClass { } A final class cannot be extended.,"(""MyClass"", ""class"")"
"In other words, you cannot inherit from a final class in Java.",NULL
Abstract Classes and Inheritance In Java a class can be declared abstract.,"(""Abstract Classes"", ""Abstract Classes in the context of Java imply that Java supports the concept of abstract classes."", ""Java"")"
I have explained abstract classes in more detail in my Java abstract classes tutorial.,NULL
An abstract class is a class that does not contain the full implementation of whatever the abstract class should do.,"(""Abstract Class"", ""An abstract class is a type of class that does not contain a full implementation."", ""Class"")"
"In other words, you cannot create objects of an abstract class.","(""CLASS"", ""class"")"
In Java abstract classes are intended to be extended to create a full implementation.,"(""Abstract Classes"", ""class"")"
The Java inheritance rules are the same for abstract classes as for non-abstract classes.,NULL
You can always cast an object of a subclass to one of its superclasses.,NULL
In a subclass you can override (redefine) methods defined in the superclass.,"(""Subclass"", ""A subclass is a type of class that derives from a superclass, inheriting its methods."", ""Superclass""); (""Subclass"", ""In a subclass, you can override or redefine methods originally defined in the superclass."", ""Methods"")"
Notice how both the Vehicle class and the Car class defines a method called setLicensePlate().,"(""Vehicle"", ""The Vehicle class defines a method called setLicensePlate."", ""setLicensePlate""); (""Car"", ""The Car class defines a method called setLicensePlate."", ""setLicensePlate"")"
"If you override a method in a subclass, and the method is all of a sudden removed or renamed or have its signature changed in the superclass, the method in the subclass no longer overrides the method in the superclass.",NULL
"If you override a method in a subclass, but still need to call the method defined in the superclass, you can do so using the super reference, like this:",NULL
"In the above code example the method setLicensePlate() in the Car class, calls the setLicensePlate() method in the Vehicle class.","(""SetLicensePlate"", ""The SetLicensePlate method is a part of the Car class as it belongs to its functionality."", ""Car""); (""SetLicensePlate"", ""The SetLicensePlate method is also a part of the Vehicle class, indicating a hierarchy or inheritance relationship where Car might extend Vehicle."", ""Vehicle"")"
"Assuming that the Car class extends (inherits from) the Vehicle class, the isVehicle variable will contain the value true after this code is executed.",NULL
"As mentioned earlier, in Java fields cannot be overridden in a subclass.","(""Java"", ""package"")"
Here is Java inheritance example that illustrates how fields in subclasses shadow (hides) fields in superclasses:,NULL
"If a class does not have any explicit constructor defined, the Java compiler inserts an implicit no-arg constructor.","(""Java compiler"", ""The Java compiler inserts an implicit no-arg constructor into a class when no explicit constructor is defined."", ""Class"")"
"Second, if a constructor does not explicitly call a constructor in the superclass, the Java compiler inserts an implicit call to the no-arg constructor in the superclass.",NULL
That means that the following version of the Car class is actually equivalent to the version shown earlier:,"(""Car"", ""class""); (""Car"", ""class"")"
"In fact, since the constructor is now empty, we could leave it out and the Java compiler would insert it, and insert an implicit call to the no-arg constructor in the superclass.",NULL
"Even though no constructors are declared in these two classes, they both get a no-arg constructor, and the no-arg constructor in the Car class will call the no-arg constructor in the Vehicle class.","(""Car"", ""The Car class is related to the Vehicle class because the no-arg constructor in the Car class calls the no-arg constructor in the Vehicle class."", ""Vehicle"")"
Notice how it is possible to create an instance of the nested class MyNestedClass which is defined in the superclass (MyClass) via a reference to the subclass (MySubclass).,NULL
"The Java instanceof operator can determine if a given Java object is an instance of a given class, superclass or interface.","(""Java"", ""The Instanceof Operator is a method used within the Java programming environment."", ""Instanceof Operator""); (""Instanceof Operator"", ""The Instanceof Operator determines if an object is an instance of a Class or a Superclass or Interface."", ""Class"")"
The Java instanceof operator is also referred to as a type comparison operator because it compares the type of a given instance (object) with a specific type (class or interface).,NULL
"The expression map instanceof Object will evaluate to true if the map variable references an object that is an instance of class Object, or any subclass of class Object.","(""Object"", ""The map variable is an instance of the class Object or any subclass of the class Object."", ""Object"")"
"Since all classes in Java inherit from Object, this expression will evaluate to true.",NULL
"As mentioned earlier, the Java instanceof operator will evaluate to true if you compare an object to the exact class of that object.",NULL
Here is a Java instanceof example showing a comparison of an object to its exact class:,"(""Object"", ""The object is being compared to its class in the example using 'instanceof'."", ""Class""); (""Object"", ""The object is being compared to its class in the example using 'instanceof'."", ""Class"")"
"As also mentioned earlier, the Java instanceof operator also evaluates to true when comparing an object against a superclass of the type of that object.",NULL
"Since HashMap is a subclass of Object - even if not a direct subclass, the expression map instanceof Object evaluates to true.","(""HashMap"", ""The HashMap class is a subclass of the Object class."", ""Object"")"
"Note, that it does not matter how high up in the inheritance hierarchy the compared type is superclass of the type of the object.","(""Type"", ""A type is organized within an inheritance hierarchy in object-oriented programming."", ""Inheritance Hierarchy"")"
"As long as the type compared to is a superclass somewhere up the inheritance hierarchy, instanceof will evaluate to true.","(""Instanceof"", ""Instanceof checks whether an object is an instance of a specified superclass or subclass in the inheritance hierarchy."", ""Superclass"")"
The Java instanceof operator also works when comparing an object against an interface instead of a class.,NULL
"Notice, that even if the map variable is of type HashMap, the instanceof operator returns true for the expression map instanceof Map because the HashMap class implements the Map interface.","(""HashMap"", ""The HashMap class implements the Map interface, indicating a hierarchical relationship where HashMap is a subtype of Map."", ""Map""); (""map"", ""The instanceof operator is used to check if the map variable is an instance of a particular class, establishing a method-related relationship."", ""instanceof"")"
"The Java instanceof operator also evaluates to true when comparing an object against a superinterface which the class of the object, or a superclass of the object implements.","(""Instanceof Operator"", ""The instanceof operator is used to determine if the object is an instance of a specified class or its superclass."", ""Object""); (""Object"", ""The object is compared against the superinterface to evaluate if the instanceof operator returns true."", ""Superinterface""); (""Object"", ""The object may be an instance of the superclass implementing the superinterface."", ""Superclass""); (""Instanceof Operator"", ""The instanceof operator is used to determine if the object is an instance of a specified class or its superclass."", ""Object""); (""Object"", ""The object is compared against the superinterface to evaluate if the instanceof operator returns true."", ""Superinterface""); (""Object"", ""The object may be an instance of the superclass implementing the superinterface."", ""Superclass"")"
"The TreeMap class implements SortedMap, and thus also indirectly the Map interface.","(""TreeMap"", ""The TreeMap class implements the SortedMap class."", ""SortedMap""); (""TreeMap"", ""The TreeMap class indirectly implements the Map interface through SortedMap."", ""Map"")"
The Java instanceof operator always evaluates to false when a null variable is compared against any class or interface.,"(""Java"", ""The instanceof operator is part of the Java language syntax."", ""instanceof""); (""instanceof"", ""The instanceof operator is used to compare an object against a class."", ""class""); (""instanceof"", ""The instanceof operator can compare an object against an interface."", ""interface"")"
Here is a Java instanceof example illustrating the comparison of null against a class:,NULL
"That is because it is not the reference type that is compared against the target class or interface, but the actual type of the referenced object.",NULL
"Since a Java String object can never be an instance of the Java Integer class, the Java compiler will catch this an give you an error.",NULL
That means that the actual class of the referenced object could be pretty much any class (since all classes are subclasses of Object).,NULL
"In short, we can avoid the explicit downcast of an object when comparing it against a subclass.","(""Subclass"", ""class"")"
Notice the str variable after the String class name in the instanceof expression inside the if-statement.,"(""String"", ""The str variable is checked to see if it is an instance of the String class using the instanceof method."", ""str""); (""instanceof"", ""The relationship is that the instanceof method is being used to evaluate the str variable."", ""str"")"
"Since the right hand side of the expression is only evaluated if the left hand side evaluates to true, this cannot result in startsWith() being called on a non-String object.","(""startsWith"", ""The method startsWith is typically called on String objects."", ""String"")"
"A question I get a lot is what the difference is between Java interfaces and abstract classes, and when to use each.","(""Java"", ""Java interfaces are a feature of the Java programming language."", ""Interface""); (""Java"", ""Java abstract classes are a component of the Java programming framework."", ""Abstract Class"")"
"Having answered this question by email multiple times, I decided to write this tutorial about Java interfaces vs abstract classes.","(""Java"", ""Interfaces are a feature of the Java programming language"", ""Interfaces""); (""Java"", ""Abstract classes are a feature of the Java programming language"", ""Abstract Classes""); (""Interfaces"", ""Both provide mechanisms for abstraction in Java"", ""Abstract Classes""); (""Java"", ""Interfaces are a feature of the Java programming language"", ""Interfaces""); (""Java"", ""Abstract classes are a feature of the Java programming language"", ""Abstract Classes""); (""Interfaces"", ""Both provide mechanisms for abstraction in Java"", ""Abstract Classes"")"
"In other words, to make the classes using the interface independent of the classes implementing the interface.",NULL
"Thus, you can exchange the implementation of the interface, without having to change the class using the interface.","(""Class"", ""The class uses the interface, indicating a dependency relationship."", ""Interface"")"
Abstract classes are typically used as base classes for extension by subclasses.,"(""Abstract Class"", ""An abstract class is typically inherited by a subclass as a base class to provide a foundational structure for extension."", ""Subclass"")"
"Some programming languages use abstract classes to achieve polymorphism, and to separate interface from implementation, but in Java you use interfaces for that.","(""Abstract Classes"", ""Abstract classes in some programming languages serve a similar purpose to interfaces in Java by separating interface from implementation."", ""Interfaces""); (""Interfaces"", ""In Java, interfaces are used to achieve polymorphism."", ""Java"")"
"Remember, a Java class can only have 1 superclass, but it can implement multiple interfaces.","(""CLASS"", ""A Java class can only have one direct superclass in its inheritance structure."", ""SUPERCLASS""); (""CLASS"", ""A class can implement multiple interfaces to provide various functionalities."", ""INTERFACES"")"
"Thus, if a class already has a different superclass, it can implement an interface, but it cannot extend another abstract class.","(""Class"", ""A class can have a superclass indicating inheritance."", ""Superclass""); (""Class"", ""A class can implement an interface, showing a type of relationship between the class and the interface."", ""Interface""); (""Class"", ""A class cannot extend an abstract class if it already has a different superclass, indicating a restriction relationship."", ""Abstract Class"")"
"If you also need to provide a base class or default implementation of the interface, add an abstract class (or normal class) that implements the interface.",NULL
"Here is an example showing a class referencing an interface, an abstract class implementing that interface, and a subclass extending the abstract class.","(""Class"", ""A class can reference an interface."", ""Interface""); (""Abstract Class"", ""An abstract class can implement an interface."", ""Interface""); (""Subclass"", ""A subclass can extend an abstract class."", ""Abstract Class"")"
"Below are the code examples from the text on Java Abstract Classes, but with an interface added which is implemented by the abstract base class.",NULL
"Fourth, how to use the interface URLProcessor as variable type, even though it is the subclass UrlProcessorImpl that is instantiated.","(""URLProcessor"", ""UrlProcessorImpl is a subclass of URLProcessor."", ""UrlProcessorImpl"")"
Using both an interface and an abstract base class makes your code more flexible.,"(""Interface"", ""Interfaces and abstract base classes are both used to define contracts or templates for other classes, implying a connection in terms of usage and design."", ""Abstract Base Class"")"
It possible to implement simple URL processors simply by subclassing the abstract base class.,"(""URL Processors"", ""URL Processors is a subclass of the abstract base class, indicating a hierarchical relationship."", ""Base Class"")"
"A Java interface is a bit like a Java class, except a Java interface can only contain method signatures and fields.","(""Java interface"", ""A Java interface is compared to a Java class in terms of functionality."", ""Java class""); (""Java interface"", ""Java interface contains method signatures."", ""method"")"
"However, it is possible to provide default implememntations of a method in a Java interface, to make the implementation of the interface easier for classes implementing the interface.","(""Method"", ""A method can have default implementations in a Java interface, simplifying the implementation for classes."", ""Class"")"
"Just like with classes, a Java interface can be declared public or package scope (no access modifier).","(""Java interface"", ""The term 'package' appears in the context of describing the scope of a Java interface, indicating a relationship between Java interfaces and packages in terms of scope context."", ""package"")"
"As you can see, accessing a variable from an interface is very similar to accessing a static variable in a class.","(""Interface"", ""Accessing a variable from an interface is mentioned, suggesting a relationship between the two."", ""Variable""); (""Variable"", ""The text compares accessing a variable in a class to accessing a variable from an interface, implying a relationship between variables and classes."", ""Class"")"
"The method, however, needs to be implemented by some class before you can access it.","(""Method"", ""The method needs to be implemented by some class, indicating that classes provide implementations for methods."", ""Class"")"
"Before you can really use an interface, you must implement that interface in some Java class.",NULL
Here is a class that implements the MyInterface interface shown above:,NULL
This signals to the Java compiler that the MyInterfaceImpl class implements the MyInterface interface.,NULL
A class that implements an interface must implement all the methods declared in the interface.,"(""Class"", ""A class must implement all the methods declared in an interface it implements"", ""Method"")"
The class does not need to implement (declare) the variables of an interface.,"(""Class"", ""The class can implement the interface, indicating that they have a functional relationship."", ""Interface"")"
Once a Java class implements an Java interface you can use an instance of that class as an instance of that interface.,NULL
Java allows this because the class MyInterfaceImpl implements the MyInterface interface.,"(""MyInterfaceImpl"", ""MyInterfaceImpl implements MyInterface, indicating that MyInterfaceImpl is a specific implementation of the interface defined by MyInterface."", ""MyInterface"")"
You can then reference instances of the MyInterfaceImpl class as instances of the MyInterface interface.,"(""MyInterfaceImpl"", ""MyInterfaceImpl implements MyInterface"", ""MyInterface""); (""MyInterfaceImpl"", ""MyInterfaceImpl implements MyInterface"", ""MyInterface"")"
"You must always create an instance of some class that implements the interface, and reference that instance as an instance of the interface.","(""Class"", ""A class implements the interface, indicating a relationship of implementation."", ""Interface"")"
In that case the class must implement all the methods declared in all the interfaces implemented.,NULL
"If the interfaces are not located in the same packages as the implementing class, you will also need to import the interfaces.",NULL
Java interfaces are imported using the import instruction just like Java classes.,"(""Java Classes"", ""Java classes are brought into the environment using the import instruction."", ""Import Instruction""); (""Java Interfaces"", ""Interface types are related to classes as interfaces define behaviors that classes can implement."", ""Java Classes"")"
Here are the two Java interfaces implemented by the class above:,"(""Class Above"", ""class""); (""Class Above"", ""class""); (""Class Above"", ""class"")"
"If a Java class implements multiple Java interfaces, there is a risk that some of these interfaces may contain methods with the same signature (name + parameters).","(""Class"", ""A class can implement one or more interfaces"", ""Interface""); (""Interface"", ""Interfaces can contain method signatures"", ""Method""); (""Java"", ""Class is a construct in the Java language"", ""Class""); (""Java"", ""Interface is a construct in the Java language"", ""Interface"")"
"Since a Java class can only implement at method with a given signature once, this could potentially lead to some problems.","(""Java class"", ""A Java class can implement methods, implying a hierarchical relationship between the two"", ""method""); (""Java class"", ""A Java class can implement methods, implying a hierarchical relationship between the two"", ""method"")"
"Especially if those constants are to be used by the classes implementing the interface, e.g.","(""Classes"", ""class"")"
It is up to the classes implementing the interface to specify an implementation.,NULL
"If the API just adds the method to the desired interface, all classes that implements the interface must implement that new method.",NULL
That is fine if all implementing classes are located within the API.,NULL
"But if some implementing classes are located in client code of the API (the code that uses the API), then that code breaks.","(""Classes"", ""Classes are typically part of the API structure and can be defined within it or used by it."", ""API"")"
Look at this interface and imagine that it is part of e.g.,NULL
"If the developer of the API wants to add one more method to the ResourceLoader interface, then the FileLoader class will be broken when that project upgrades to the new version of the API.",NULL
"A class can override the implementation of a default method simply by implementing that method explicitly, as is done normally when implementing a Java interface.","(""Class"", ""A class can override the implementation of a default method by implementing it explicitly."", ""Method""); (""Class"", ""A class can implement a Java interface."", ""Interface"")"
Any implementation in a class takes precedence over interface default method implementations.,"(""Class"", ""A class can implement methods from an interface, overriding the default implementations provided by the interface."", ""Interface""); (""Class"", ""A class can provide its own implementation for a default method defined in an interface, taking precedence over it."", ""Default Method"")"
Calling a static method in an interface looks and works just like calling a static method in a class.,NULL
Here is an example of calling the static print() method from the above MyInterface interface:,"(""MyInterface"", ""The 'print' method is a static method that belongs to the 'MyInterface' interface."", ""print"")"
"It is possible for a Java interface to inherit from another Java interface, just like classes can inherit from other classes.","(""Java Interface"", ""The text indicates that Java interfaces can inherit from other Java interfaces similarly to how classes can inherit from other classes."", ""Classes"")"
"That then means, that if a class implements MySubInterface, that class has to implement all methods defined in both MySubInterface and MySuperInterface.","(""MySubInterface"", ""MySubInterface extends MySuperInterface, so classes implementing MySubInterface are indirectly implementing MySuperInterface."", ""MySuperInterface""); (""class"", ""Classes implementing MySubInterface must also implement all methods defined in MySuperInterface."", ""methods"")"
A class implementing an interface which inherits from multiple interfaces must implement all methods from the interface and its superinterfaces.,NULL
"While it is normally possible for a class to implement multiple interfaces even if the interfaces contain methods with the same signature, this is not possible if one or more of these methods are default methods.",NULL
"In other words, if two interfaces contain the same method signature (name + parameters) and one of the interfaces declare this method as a default method, a class cannot automatically implement both interfaces.","(""CLASS"", ""A class is related to methods as it implements interfaces which declare methods."", ""METHOD"")"
In both of the above situations the Java compiler requires that the class implementing the interface(s) explicitly implements the method which causes the problem.,"(""Class"", ""The class explicitly implements the method, indicating a relationship between the two."", ""Method"")"
That way there is no doubt about which implementation the class will have.,NULL
The implementation in the class takes precedence over any default implementations.,NULL
"Basically, polymorphism means that an instance of an class (an object) can be used as if it were of different types.","(""Polymorphism"", ""Polymorphism involves using an object as an instance of a class allowing it to take on multiple forms."", ""Object"")"
"The classes above are all parts of a model representing different types of vehicles and drivers, with fields and methods.",NULL
That is the responsibility of these classes - to model these entities from real life.,NULL
"Please forget for a while, that implementing this functionality as methods directly on the objects may lead to a messy class hierarchy.","(""Methods"", ""Implementing functionality as methods directly on the objects may lead to a messy class hierarchy."", ""Class Hierarchy"")"
"Where in the above diagram would you put these three methods, so they are accessible on all classes?","(""Methods"", ""Methods are intended to be accessible on all classes, indicating they serve some function across the classes."", ""Classes"")"
"One way to solve this problem would be to create a common superclass for the Vehicle and Driver class, which has the storage and serialization methods.",NULL
"The class hierarchy would no longer model vehicles and drivers, but also be tied to the storage and serialization mechanisms used in your application.",NULL
"A better solution would be to create some interfaces with the storage and serialization methods on, and let the classes implement these interfaces.","(""Storage"", ""Both are methods used within interfaces to perform specific functions related to data handling."", ""Serialization""); (""Classes"", ""Classes implement the Storage method as part of the interface functionality."", ""Storage""); (""Classes"", ""Classes implement the Serialization method as part of the interface functionality."", ""Serialization""); (""Storage"", ""Both are methods used within interfaces to perform specific functions related to data handling."", ""Serialization""); (""Classes"", ""Classes implement the Storage method as part of the interface functionality."", ""Storage""); (""Classes"", ""Classes implement the Serialization method as part of the interface functionality."", ""Serialization"")"
"When each class implements these two interfaces and their methods, you can access the methods of these interfaces by casting the objects to instances of the interface types.","(""Class"", ""Class implements Method"", ""Method""); (""Class"", ""Class implements Interface"", ""Interface"")"
"You don't need to know exactly what class a given object is of, as long as you know what interface it implements.","(""Class"", ""In object-oriented programming, a class implements an interface to ensure it has certain methods."", ""Interface"")"
"As you can probably imagine by now, interfaces provide a cleaner way of implementing cross cutting functionality in classes than inheritance.",NULL
A generic Java interface is an interface which can be typed - meaning it can be specialized to work with a specific type (e.g.,NULL
This interface represents an interface which contains a single method called produce() which can produce a single object.,"(""Interface"", ""The produce() method is a component of the interface as it is described within its context."", ""Produce"")"
"Since the return value of produce() is Object, it can return any Java object.","(""Produce"", ""The produce method returns a value of type Object, indicating a direct relationship where the method's return type is the Object class."", ""Object""); (""Object"", ""The Object class is part of the Java programming language, indicating it belongs to the Java package."", ""Java"")"
The implementation of the produce() method returns a new Car object every time it is called.,NULL
"Notice how the object returned from the carProducer.produce() method call has to be cast to a Car instance, because the produce() method return type is Object.","(""produce"", ""The produce() method returns an Object that needs to be cast to a Car instance."", ""Car"")"
"Now when I implement the MyProducer interface in the CarProducer class, I have to include the generic type declaration too, like this:",NULL
"As you can see, since the generic type for the CarProducer instance is set to Car, it is no longer necessary to cast the object returned from the produce() method, since the original method declaration in the MyProducer interface states, that this method returns the same type as is specified in the generic type when used.","(""CarProducer"", ""The CarProducer instance is parametrized with the generic type Car, indicating that CarProducer operates with or produces objects of type Car."", ""Car""); (""produce"", ""The produce method is declared in the MyProducer interface, meaning it is a part of the interface's contract."", ""MyProducer""); (""CarProducer"", ""The CarProducer instance is parametrized with the generic type Car, indicating that CarProducer operates with or produces objects of type Car."", ""Car""); (""produce"", ""The produce method is declared in the MyProducer interface, meaning it is a part of the interface's contract."", ""MyProducer"")"
But - now it is actually possible to specify another generic type for a CarProducer instance than the type it actually returns from it's produce() method implementation.,"(""CarProducer"", ""The produce() method is implemented in the CarProducer class and returns a type related to the instance."", ""produce()""); (""CarProducer"", ""The produce() method is implemented in the CarProducer class and returns a type related to the instance."", ""produce()"")"
"If you scroll up, you can see that the CarProducer.produce() implementation returns a Car object no matter what generic type you specify for it when you create it.","(""CarProducer"", ""The produce() method is implemented within the CarProducer class."", ""produce""); (""produce"", ""The produce() method returns an object of the Car class."", ""Car"")"
"Instead, you can lock down the generic type of the MyProducer interface already when you implement it, in the CarProducer class.","(""MyProducer"", ""CarProducer implements the MyProducer interface"", ""CarProducer""); (""MyProducer"", ""CarProducer implements the MyProducer interface"", ""CarProducer"")"
"As you can see, it is still not necessary to cast the object returned by produce(), as the CarProducer implementation declares that to be a Car instance.","(""Produce"", ""The method 'produce()' returns an instance of 'Car'."", ""Car""); (""CarProducer"", ""The 'produce()' method is associated with the 'CarProducer' class."", ""Produce""); (""Produce"", ""The method 'produce()' returns an instance of 'Car'."", ""Car""); (""CarProducer"", ""The 'produce()' method is associated with the 'CarProducer' class."", ""Produce"")"
A Java lambda expression is thus a function which can be created without belonging to any class.,NULL
Imagine you have a class called StateOwner which can register state event listeners.,"(""StateOwner"", ""class""); (""StateOwner"", ""class"")"
The lambda expression is matched against the parameter type of the addStateListener() method's parameter.,NULL
"For instance, the interface type of the parameter can be inferred from the method declaration of the addStateListener() method (the single method on the StateChangeListener interface).","(""AddStateListener"", ""The AddStateListener method is related to the StateChangeListener interface, as it is likely part of or operates on the interface."", ""StateChangeListener"")"
"In the example above, the compiler can infer their type from the onStateChange() method declaration.",NULL
"Thus, the type of the parameters oldState and newState are inferred from the method declaration of the onStateChange() method.",NULL
"In this case, these parameters have to match the parameters of the onStateChange() method of the StateChangeListener interface:","(""onStateChange"", ""The onStateChange method is a part of the StateChangeListener class as indicated by its reference in the interface."", ""StateChangeListener"")"
Here is an example class that creates a lambda which references a static variable from inside the lambda body:,"(""Class"", ""The class is responsible for creating the lambda expression."", ""Lambda""); (""Lambda"", ""The lambda references the static variable."", ""Variable""); (""Lambda"", ""The lambda body is where the static variable is referenced."", ""Lambda Body"")"
The class primarily serves to show you that a lambda can access static variables.,"(""Class"", ""A lambda is a method-like construct that can access variables, typically related when discussing class methods."", ""Lambda""); (""Class"", ""A lambda is a method-like construct that can access variables, typically related when discussing class methods."", ""Lambda"")"
"Since all the lambda body does is forward the string parameter to the System.out.println() method, we can replace the above lambda declaration with a method reference.","(""System.out.println()"", ""The statement suggests replacing a lambda with a method reference which involves System.out.println()"", ""method reference"")"
Whatever class or object that owns the referenced method comes before the double colons.,NULL
"Since the parameters of the Finder.find() and MyClass.doFind() methods match, it is possible to create a lambda expression that implements Finder.find() and references the MyClass.doFind() method.","(""Finder.find()"", ""The parameters of the Finder.find() and MyClass.doFind() methods match, suggesting a relationship where a lambda expression could be used to implement Finder.find() by referencing MyClass.doFind()."", ""MyClass.doFind()"")"
Here is an example of a Java lambda expression that calls String.indexOf() to search:,"(""String"", ""The method indexOf is a member of the class String"", ""indexOf"")"
The convertToInt() method has the same signature as the deserialize() method of the Deserializer deserialize() method.,"(""ConvertToInt"", ""Both methods have similar functionality as suggested by the phrase 'has the same signature'."", ""Deserialize""); (""Deserialize"", ""Deserialize method belongs to the Deserializer class, as implied by the text."", ""Deserializer"")"
"Because of that, we can create an instance of StringConverter and reference its convertToInt() method from a Java lambda expression, like this:",NULL
Finally it is possible to reference a constructor of a class.,NULL
"You do that by writing the class name followed by ::new, like this:","(""Class"", ""The 'new' method is typically associated with initializing or creating instances of a class, suggesting a creation or instantiation relationship."", ""::new"")"
The create() method of this interface matches the signature of one of the constructors in the String class.,NULL
"In Java, all instructions (code) have to be located inside a Java class.","(""Java"", ""In Java, all instructions must be contained within a class, indicating that classes are a fundamental part of the Java programming structure."", ""Class"")"
A class is a way of grouping data and instructions that belong together.,"(""CLASS"", ""class"")"
"Declaring a simple class without any variables, methods or any other instructions, looks like this in Java code:","(""Class"", ""A class can contain methods as part of its structure in Java."", ""Method"")"
This Java code needs to be located in a file with the same file name as the class and ending with the file suffix .java.,NULL
"Once the file is located in a file matching its class name and ending with .java, you can compile it with the Java compiler from the Java SDK, or from inside your Java IDE (which is much easier).",NULL
It is recommended that you locate your class in a Java package.,"(""Class"", ""A class is typically organized or located within a package in Java, which helps in namespace management and organizing classes logically."", ""Package"")"
"If you locate a Java class inside a Java package, you have to specify the package name at the top of the Java file.","(""Java Class"", ""A Java class is positioned within a Java package, which necessitates specifying the package name."", ""Java Package"")"
Here is how the class from earlier looks with a package declaration added:,"(""Class"", ""The class is typically part of or contained within a package, suggesting a structural relationship in code organization."", ""Package"")"
Note: The file MyClass.java must now be located in the directory myjavacode and contain the package declaration package myjavacode; .,"(""MyClass"", ""MyClass is defined within the package myjavacode, as indicated by the package declaration."", ""myjavacode"")"
A Java program starts by executing the main method of some class.,NULL
"You can choose the name of the class to execute, but not the name of the method.",NULL
Here is how the main method declaration looks when located inside the Java class declaration from earlier:,NULL
Just remember that a main() method declaration needs these three keywords.,"(""Main()"", ""Method"")"
"In the main() method example earlier I called the String array parameter args, and in the second example I called it stringArray.",NULL
"You call the java command that comes with the JRE, and tells it what Java class to execute, and what arguments to pass to the main() method.",NULL
The second and third arguments (-cp classes) tells the JVM in what directory the compiled Java classes are located (cp means class path).,"(""Java"", ""The JVM is responsible for running Java programs."", ""JVM"")"
In this case the compiled Java classes are located in a directory named classes.,"(""Classes"", ""Class"")"
The fourth argument is the name of the Java class the JVM is to execute.,"(""Java class"", ""The Java class is to be executed by the JVM, indicating a functional association between them."", ""JVM"")"
"Notice how the class name also contains the name of the package the class is located in (the ""fully qualified class name"").","(""Class"", ""The class is located in the package, indicating a containment relationship."", ""Package"")"
You can pass arguments from the command line to the main() method.,NULL
"When the JVM executes the main() method of the myjavacode.MyClass, the String array passed as parameter to the main() method will contain two Strings: ""Hello"" and ""World"".",NULL
The main() method can access the arguments from the command line like this:,NULL
"If only a single Java class in your Java program contains a main() method, then the class containing the main() method is often referred to as the main class.","(""Java Class"", ""A Java Class can contain a Main() Method as its entry point for execution."", ""Main() Method""); (""Java Class"", ""A Java Class is a component of a Java Program."", ""Java Program"")"
You can have as many classes as you want in your project with a main() method in.,"(""Main"", ""The main method is a specific function that must exist within a class, usually as the entry point for execution in a program."", ""Classes"")"
You can still call the other main() methods from inside the main() method the Java Virtual Machine executes (you haven't seen how yet) and you can also start up multiple virtual machines which each execute a single main() method.,"(""Main"", ""The Java Virtual Machine executes the main method."", ""Java Virtual Machine"")"
Therefore Java also contains the Java Math class which contains methods for performing more advanced math calculations in Java.,"(""Java Math"", ""The class Java Math provides the methods for math calculations."", ""performing more advanced math calculations""); (""Java Math"", ""Java Math is a class within the Java package."", ""Java"")"
This Java math tutorial will take a closer look at both Java's math operators as well as the Java Math class.,"(""Java Math"", ""Java Math is a class that likely contains or uses various methods to perform mathematical operations."", ""method"")"
"The result of this division would be 12.5 , but since the two numbers are integers, the .5 fraction is cut off.",NULL
"Even though the result variable is now a floating point type (double), the final result is still just 12 instead of 12.5 .",NULL
Now the result variable would end up with the value 12.5.,NULL
"The first System.out.println() statement correctly prints the value 0.0 , which is the start value of the the resultDbl3 variable.",NULL
"Adding the value 0.01 to 0 a total of 100 times should result in the value 1.0, right?",NULL
The Java Math class provides more advanced mathematical calculations than what the basic Java math operators provide.,"(""Math"", ""The Math class is part of the Java package and provides mathematical calculations."", ""Java"")"
"The Math class contains methods for finding the maximum or minimum of two values, rounding values, logarithmic functions, square root, and trigonometric functions (sin, cos, tan etc.","(""Math"", ""Math class contains various mathematical methods"", ""Methods""); (""Math"", ""Math class contains various mathematical methods"", ""Methods"")"
"The Math is located in the java.lang package, and not in the java.math package.",NULL
"Thus, the fully qualified class name of the Math class is java.lang.Math .",NULL
"Since many of the functions of the Math class are independent from each other, each method will be explained in its own section below.","(""Math"", ""The Math class contains multiple methods that perform independent functions."", ""method"")"
"The java.lang.Math contains a set of basic math functions for obtaining the absolute value, highest and lowest of two values, rounding of values, random values etc.",NULL
These basic math functions of the Java Math class will be covered in the following sections.,"(""Java Math"", ""class"")"
The Math.abs() function returns the absolute value of the parameter passed to it.,"(""Math"", ""The 'abs()' method is part of the 'Math' package."", ""abs()""); (""Math"", ""The 'abs()' method is part of the 'Math' package."", ""abs()"")"
Which of these methods are called depends on the type of the parameter passed to the Math.abs() method.,"(""Math.abs()"", ""The Math.abs() method is called depending on the type of the parameter passed to it."", ""parameter"")"
The Math.ceil() function rounds a floating point value up to the nearest integer value.,"(""Math"", ""The method 'ceil' is part of the 'Math' package."", ""ceil"")"
After executing this Java code the ceil variable will contain the value 8.0 .,"(""Ceil"", ""Variable"")"
The Math.floor() function rounds a floating point value down to the nearest integer value.,"(""Math"", ""The 'floor' method is part of the 'Math' package."", ""Floor"")"
After executing this Java code the floor variable will contain the value 7.0 .,NULL
"The Math.floorDiv() method divides one integer (int or long) by another, and rounds the result down to the nearest integer value.",NULL
"The floorDiv() method rounds down to the nearest negative integer, instead of the rounding up that would occur with fraction truncation.","(""FLOORDIV"", ""METHOD"")"
This shows the difference between the / division operator and Math.floorDiv() .,"(""Division Operator"", ""Both are methods related to performing division operations, but they differ in handling negative values."", ""Math.floorDiv"")"
The Math.min() method returns the smallest of two values passed to it as parameter.,"(""Math.min()"", ""The Math.min() method takes two values as parameters and returns the smallest one, indicating a relationship between the method and its parameters"", ""Two values"")"
The Math.max() method returns the largest of two values passed to it as parameter.,"(""Math.max()"", ""The Math.max() method returns the largest of two values as it’s designed to find the maximum of given parameters"", ""largest of two values"")"
The Math.round() method rounds a float or double to the nearest integer using normal math round rules (either up or down).,"(""Math"", ""The 'round' method is part of the 'Math' package, indicating it is a function provided by this package."", ""round"")"
"After executing these two Java statements the roundedDown variable will contain the value 23.0 , and the roundedUp variable will contain the value 24.0.","(""RoundedDown"", ""The variable RoundedDown is assigned the value 23.0 after execution."", ""23.0""); (""RoundedUp"", ""The variable RoundedUp is assigned the value 24.0 after execution."", ""24.0"")"
The Math.random() method returns a random floating point number between 0 and 1.,"(""Math"", ""The random method is a member of the Math class, providing functionality related to mathematical operations."", ""random"")"
"100, multiply the value returned by Math.random() with the maximum number (e.g.","(""Math"", ""The method random() is part of the Math package that provides mathematical functions."", ""random()"")"
"If you need an integer value, use the round(), floor() or ceil() method.",NULL
The Java Math class also contains a set of functions intended for exponential and logarithmic calculations.,"(""Math"", ""The Exponential and Logarithmic Calculations are methods contained within the Math class, indicating a method-class relationship."", ""Exponential and Logarithmic Calculations"")"
The Math.exp() function returns e (Euler's number) raised to the power of the value provided as parameter.,"(""Math"", ""The exp() method is a function within the Math package."", ""exp"")"
The Math.log10 method works like the Math.log() method except is uses 10 as is base for calculating the logarithm instead of e (Euler's Number).,NULL
"In other words, the Math.pow() example calculate the values of 22 and 28 which are 4 and 256.","(""Math"", ""pow is a method that belongs to the Math package, utilized to perform mathematical operations such as exponentiation."", ""pow"")"
The Math.sqrt() method calculates the square root of the parameter given to it.,"(""Math"", ""The Sqrt method is a function within the Math package."", ""Sqrt"")"
"If you are looking for a trigonometric function and you cannot find it here, check the JavaDoc for the Java Math class.","(""Java Math Class"", ""The Java Math class is documented in the JavaDoc package."", ""JavaDoc"")"
"The Math class just might have the function you are looking for, even if I have not described it here.","(""Math"", ""class"")"
The Math.PI constant is a double with a value that is very close to the value of PI - the mathematical definition of PI.,NULL
You will often need the Math.PI field when making trigonometric calculations.,"(""Math"", ""PI is a field belonging to the Math package, used for trigonometric calculations"", ""PI"")"
The Math.sin() method calculates the sine value of some angle value in radians.,"(""Math"", ""The method 'sin' is a part of the 'Math' package, which provides various mathematical operations."", ""sin"")"
The Math.cos() method calculates the cosine value of some angle value in radians.,NULL
The Math.tan() method calculates the tangens value of some angle value in radians.,"(""Math"", ""The tan method is part of the Math package"", ""tan"")"
The Math.asin() method calculates the arc sine value of a value between 1 and -1.,NULL
The Math.acos() method calculates the arc cosine value of a value between 1 and -1.,"(""Math"", ""The acos method is contained within the Math package."", ""acos"")"
The Math.atan() method calculates the arc tangens value of a value between 1 and -1.,"(""Math"", ""The method atan is part of the Math package."", ""atan"")"
The Math.sinh() method calculates the hyperbolic sine value of a value between 1 and -1.,NULL
The Math.cosh() method calculates the hyperbolic cosine value of a value between 1 and -1.,"(""cosh"", ""The 'cosh' method is part of the 'Math' package."", ""Math"")"
The Math.tanh() method calculates the hyperbolic tangens value of a value between 1 and -1.,"(""Math"", ""The 'tanh' method is part of the 'Math' package."", ""tanh"")"
Java methods are similar to what is called functions or procedures in other programming languages (e.g.,"(""Java"", ""The term 'Java methods' indicates that methods belong to or are a part of the Java package or language."", ""methods"")"
The example above defines a method called writeText inside a class named MyClass.,NULL
You can use any primitive data type or built-in Java class as data type for parameters.,NULL
"When the above Java code is executed, the writeText() method will get executed, and the parameters will contain the values ""Hello"" and ""World"".","(""WriteText"", ""The writeText() method is executed and involves parameters as part of its function execution."", ""Parameters"")"
"But, instead of returning to where the method was called from, the execution is resumed inside the first catch() { } clause surrounding the method, targeted at that exception.",NULL
"Notice how the method callSum() creates a variable called theSum, and assigns it the value returned by the add(1, 3) method call.",NULL
Before Java 9 and the Java Platform Module System you would have had to package all of the Java Platform APIs with your Java application because there was no official way of reliably checking what classes your Java application used.,NULL
"Since the Java Platform APIs have grown quite large over the years, your application would get a large amount of Java classes included in its distribution, many of which your application would probably not be using.",NULL
The unused classes makes your application distributable bigger than it needs to be.,"(""Classes"", ""class"")"
from a missing JAR file) would not be detected until the application actually tried to use the missing class.,"(""APPLICATION"", ""The application is trying to use the class."", ""CLASS"")"
This would happen sometime at runtime - depending on when the application tried to use the missing class.,"(""Class"", ""class""); (""Class"", ""class"")"
Having missing modules reported at application startup time is a big advantage compared to at runtime when trying to use the missing module / JAR / class.,"(""MODULE"", ""Modules can affect classes as missing modules (and JARs) at runtime may cause class-related issues."", ""CLASS"")"
"However, you should not use underscores (_) in module names (or package names, class names, method names, variable names etc.)","(""Class"", ""Class names often contain method definitions, creating a direct relationship between the two in object-oriented programming."", ""Method""); (""Package"", ""Classes are often grouped into packages, which serve as namespaces and organizational units for classes in many programming languages."", ""Class""); (""Package"", ""Methods are typically contained within classes, and classes are organized within packages as part of a structured codebase."", ""Method"")"
"Before Java 9 all Java classes for an application or API were nested directly inside a root class directory (which was added to the classpath), or directly inside a JAR file.",NULL
The module root directory is used both for the source files and compiled classes of a Java module.,"(""ROOT DIRECTORY"", ""The root directory contains the source files."", ""SOURCE FILES""); (""ROOT DIRECTORY"", ""The root directory also contains the compiled classes."", ""COMPILED CLASSES"")"
Each Java module needs a Java module descriptor named module-info.java which has to be located in the corresponding module root directory.,NULL
Notice also how the module descriptor is suffixed .java and yet it uses a hyphen in the file name (module-info.java).,NULL
"Hyphens are not normally allowed in Java class names, but in module descriptor file names they are required!",NULL
This example module descriptor declares that it requires the standard Java module named javafx.graphics.,"(""Module Descriptor"", ""The class 'Module Descriptor' uses the method 'Requires' to indicate a need for a module dependency."", ""Requires""); (""Requires"", ""The method 'Requires' specifies a dependency on the package 'Javafx.graphics'."", ""Javafx.graphics""); (""Module Descriptor"", ""The class 'Module Descriptor' uses the method 'Requires' to indicate a need for a module dependency."", ""Requires""); (""Requires"", ""The method 'Requires' specifies a dependency on the package 'Javafx.graphics'."", ""Javafx.graphics"")"
By split package is meant that the total content (classes) of the package is split between multiple modules.,NULL
"Inside that directory you will find a directory with the name of the module, and inside that directory you will find the compiled classes plus a compiled version of the module-info.java module descriptor named module-info.class.",NULL
"In order to run the main class of a Java module you use the java command, like this:","(""Main Class"", ""The main class is a part of the Java module that is executed."", ""Java Module""); (""Java Command"", ""The java command is used to run the main class."", ""Main Class"")"
The --module argument tells what module + main class to run.,"(""Module"", ""class""); (""Main Class"", ""class""); (""Module"", ""class""); (""Main Class"", ""class"")"
Notice how the module name and main class name are separated by a slash (/) character.,"(""Module Name"", ""The module name is a part of the main class name, indicating that the class belongs to the package represented by the module name."", ""Main Class Name"")"
You can still set the JAR main class when generating the module JAR file.,"(""JAR Main Class"", ""The 'JAR Main Class' is set during the generation of the 'Module JAR File'."", ""Module JAR File"")"
Here is an example of setting the main class of a Java module JAR file:,NULL
You can now run the main class of this JAR file with a shortcut.,NULL
Here is how you run the main class from a Java module JAR file:,"(""Main"", ""class""); (""Main"", ""class"")"
"If the Java module JAR file has a main class set (see a few sections earlier in this tutorial for how to do that), you can run the Java module main class with a little shorter command line.",NULL
Here is an example of running a Java module from a JAR file with a main class set:,NULL
The --module argument specifies which module plus main class to run.,"(""Module"", ""The --module argument specifies which module and main class to run"", ""Main Class"")"
"From Java 9 and forward, all Java classes must be located in a module for the Java VM to use them.","(""Java VM"", ""Java classes are executed by the Java VM which requires them to be part of a module in Java"", ""Java""); (""Java VM"", ""Java classes are executed by the Java VM which requires them to be part of a module in Java"", ""Java"")"
"But what do you do with older Java libraries where you just have the compiled classes, or a JAR file?","(""Class"", ""A JAR file contains compiled classes in Java libraries, establishing a containment relationship between the classes and the JAR package."", ""JAR File"")"
In Java 9 you can still use the -classpath argument to the Java VM when running an application.,"(""Java VM"", ""Java VM is a component within the Java platform introduced or used in Java 9."", ""Java 9"")"
"On the classpath you can include all your older Java classes, just like you have done before Java 9.","(""Java"", ""Java 9 is a newer version of the Java class, thus representing a temporal development relationship where 'Java 9' implies an evolution or an updated class from 'Java'."", ""Java 9"")"
All classes found on the classpath will be included in what Java calls the unnamed module.,"(""Classpath"", ""Classpath includes unnamed module as part of Java's mechanism for including all classes."", ""Unnamed Module"")"
"However, the classes in the unnamed module are only readable by other classes in the unnamed module - or from automatic modules (see next section).",NULL
No named module can read the classes of the unnamed module.,"(""Classes"", ""The unnamed module contains classes."", ""Module"")"
All classes in the unnamed module requires all modules found on the module path.,"(""Unnamed Module"", ""The Unnamed Module requires all modules found on the Module Path, suggesting a dependency relationship."", ""Module Path""); (""Unnamed Module"", ""The Unnamed Module requires all modules found on the Module Path, suggesting a dependency relationship."", ""Module Path"")"
"That way, all classes in the unnamed module can read all classes exported by all the Java modules found on the module path.","(""Unnamed Module"", ""The Unnamed Module can read all classes exported by Java Modules."", ""Java Modules"")"
"While you can include the third party library on the classpath and thus include it in the unnamed module, your own named modules cannot use it, because named modules cannot read classes from the unnamed module.","(""Unnamed Module"", ""The unnamed module can include the third-party library on the classpath."", ""Third Party Library""); (""Named Modules"", ""Named modules cannot use classes from the unnamed module."", ""Unnamed Module""); (""Named Modules"", ""Named modules cannot read classes from the unnamed module."", ""Classes""); (""Unnamed Module"", ""The unnamed module can include the third-party library on the classpath."", ""Third Party Library""); (""Named Modules"", ""Named modules cannot use classes from the unnamed module."", ""Unnamed Module""); (""Named Modules"", ""Named modules cannot read classes from the unnamed module."", ""Classes"")"
"An automatic module is made from a JAR file with Java classes that are not modularized, meaning the JAR file has no module descriptor.","(""JAR File"", ""An automatic module is made from a JAR file, indicating a compositional relationship."", ""Automatic Module""); (""JAR File"", ""JAR files contain Java classes, indicating a containment relationship."", ""Java Classes""); (""Java Classes"", ""Java classes in the JAR file are not modularized, meaning there is no module descriptor present."", ""Module Descriptor"")"
When you place an ordinary JAR file on the module path (not the classpath) the Java VM will convert it to an automatic module at runtime.,NULL
"If your application contains multiple automatic modules, each automatic module can read the classes of all other automatic modules.","(""Automatic Module"", ""An automatic module can read the classes of other automatic modules, indicating an inter-module reading relationship."", ""Automatic Module"")"
This is different from explicitly named modules (real Java modules) which cannot read classes in the unnamed module.,"(""Class"", ""The text mentions that the unnamed module cannot read classes, establishing a connection between these two entities."", ""Unnamed Module"")"
"An automatic module exports all its packages, so all named modules on the module path can use the classes of an automatic module.","(""Module"", ""Modules export packages, making them directly related."", ""Package"")"
"If a JAR file contains versioning in its file name, e.g.",NULL
"The service interface is typically located in a service interface Java module which only contains the service interface, plus any classes and interfaces related to the service interface.","(""Service Interface"", ""The Service Interface is typically located in the Java Module, indicating a containment relationship."", ""Java Module"")"
The com folder at the root level of the JAR file contains the compiled Java classes for pre Java 9 versions.,"(""Com"", ""The 'com' package contains compiled classes that are within the JAR file."", ""Jar""); (""Java"", ""The Java classes are compiled into the 'com' package."", ""Com""); (""Com"", ""The 'com' package contains compiled classes that are within the JAR file."", ""Jar""); (""Java"", ""The Java classes are compiled into the 'com' package."", ""Com"")"
Earlier versions of Java do not understand multi Java version JAR files so they use the classes found here.,NULL
The META-INF directory contains the MANIFEST.MF file and a directory named versions.,"(""META-INF"", ""META-INF contains the MANIFEST.MF file"", ""MANIFEST.MF""); (""META-INF"", ""META-INF contains a directory named versions"", ""Versions""); (""META-INF"", ""META-INF contains the MANIFEST.MF file"", ""MANIFEST.MF""); (""META-INF"", ""META-INF contains a directory named versions"", ""Versions"")"
The MANIFEST.MF file needs a special entry that marks the JAR file as a multi version JAR file.,"(""MANIFEST.MF"", ""class"")"
The versions directory which can contain the compiled classes for different versions of Java for your module.,"(""Versions Directory"", ""The versions directory contains compiled classes specific to different Java versions."", ""Java""); (""Versions Directory"", ""The versions directory is part of the module's structure, storing compiled classes."", ""Module"")"
"Upgrading utility libraries first to automatic modules, and later to full modules, starting at the bottom of the dependency hierarchy should assure that your libraries can still read each other during upgrade, plus be readable by the main applications on the classpath in the unnamed module or as an automatic or named module.","(""Upgrading utility libraries"", ""The utility libraries are initially categorized as automatic modules for easier upgrading."", ""automatic modules""); (""Upgrading utility libraries"", ""The utility libraries may be upgraded to full modules in a subsequent step."", ""full modules""); (""libraries"", ""The libraries are part of the dependency hierarchy that determines the upgrade order."", ""dependency hierarchy""); (""libraries"", ""Libraries must remain readable by the main applications during the upgrade."", ""main applications""); (""libraries"", ""Libraries can be read as an unnamed module in the classpath."", ""unnamed module""); (""libraries"", ""Libraries can be read as automatic modules if specified."", ""automatic modules""); (""libraries"", ""Libraries can also be part of a named module."", ""named module"")"
In Java nested classes are classes that are defined inside another class.,"(""Nested Classes"", ""Nested Classes are defined inside Classes"", ""Classes"")"
"The purpose of a nested class is to clearly group the nested class with its surrounding class, signaling that these two classes are to be used together.","(""Nested Class"", ""A nested class is meant to be clearly grouped with its surrounding class, indicating they are to be used together."", ""Surrounding Class"")"
Or perhaps that the nested class is only to be used from inside its enclosing (owning) class.,NULL
"Java developers often refer to nested classes as inner classes, but inner classes (non-static nested classes) are only one out of several different types of nested classes in Java.","(""Java"", ""Nested classes are a feature within the Java language package."", ""Nested Class""); (""Nested Class"", ""Inner classes are a specific type of nested classes in Java."", ""Inner Class""); (""Java"", ""Nested classes are a feature within the Java language package."", ""Nested Class""); (""Nested Class"", ""Inner classes are a specific type of nested classes in Java."", ""Inner Class"")"
In Java nested classes are considered members of their enclosing class.,NULL
"Thus, a nested class can be declared public, package (no access modifier), protected and private (see access modifiers for more info).","(""Nested Class"", ""class""); (""Nested Class"", ""class"")"
Therefore nested classes in Java can also be inherited by subclasses as explained in my tutorial about Java inheritance.,"(""Nested Classes"", ""Nested classes can be inherited by subclasses, indicating a relationship in the inheritance hierarchy."", ""Subclasses""); (""Tutorial"", ""The tutorial is about Java, establishing a contextual relationship."", ""Java"")"
You can create several different types of nested classes in Java.,"(""Nested Classes"", ""Nested classes are a type of class in the Java programming language."", ""Java"")"
All these types of nested classes will be covered in the following sections.,"(""Nested Classes"", ""class"")"
"In order to create an instance of the Nested class you must reference it by prefixing it with the Outer class name, like this:","(""Outer"", ""The Nested class is referenced by prefixing it with the Outer class name, indicating a relationship where Nested is a contained or inner class within Outer."", ""Nested"")"
In Java a static nested class is essentially a normal class that has just been nested inside another class.,NULL
"Being static, a static nested class can only access instance variables of the enclosing class via a reference to an instance of the enclosing class.","(""Static Nested Class"", ""The static nested class can access instance variables of the enclosing class via a reference to an instance of the enclosing class."", ""Enclosing Class"")"
Inner classes are associated with an instance of the enclosing class.,NULL
"Thus, you must first create an instance of the enclosing class to create an instance of an inner class.","(""Enclosing Class"", ""An instance of the enclosing class must be created to instantiate an inner class."", ""Inner Class"")"
Here is how you create an instance of the Inner class:,"(""Inner"", ""class""); (""Inner"", ""class"")"
Notice how you put new after the reference to the outer class in order to create an instance of the inner class.,NULL
"Non-static nested classes (inner classes) have access to the fields of the enclosing class, even if they are declared private.","(""Non-static Nested Classes"", ""Non-static nested classes are part of and have access to the enclosing class"", ""Enclosing Class""); (""Non-static Nested Classes"", ""Non-static nested classes have access to the fields of the enclosing class"", ""Fields"")"
Notice how the printText() method of the Inner class references the private text field of the Outer class.,NULL
"If a Java inner class declares fields or methods with the same names as field or methods in its enclosing class, the inner fields or methods are said to shadow over the outer fields or methods.","(""Inner Class"", ""An inner class is defined within an enclosing class"", ""Enclosing Class""); (""Fields"", ""Inner class declares fields"", ""Inner Class""); (""Methods"", ""Inner class declares methods"", ""Inner Class""); (""Fields"", ""Fields can exist in an enclosing class"", ""Enclosing Class""); (""Methods"", ""Methods can exist in an enclosing class"", ""Enclosing Class"")"
In the above example both the Outer and Inner class contains a field named text.,NULL
When the Inner class refers to text it refers to its own field.,NULL
"Java makes it possible though, for the Inner class to refer to the text field of the Outer class.",NULL
To do so it has to prefix the text field reference with Outer.this.,"(""Outer"", ""The 'text' field is referenced by prefixing it with 'Outer.this', indicating it belongs to the 'Outer' class in context."", ""text"")"
Now the Inner.printText() method will print both the Inner.text and Outer.text fields.,"(""Inner.printText()"", ""The method Inner.printText() is part of the Inner class."", ""Inner""); (""Inner.printText()"", ""The method Inner.printText() is part of the Inner class."", ""Inner""); (""Inner.text"", ""Inner.text is a field of the Inner class, implicitly related."", ""Inner""); (""Outer.text"", ""Outer.text is a field of the Outer class, implicitly related."", ""Outer""); (""Inner.printText()"", ""The method Inner.printText() accesses Outer.text, relating it to Outer."", ""Outer"")"
Local classes in Java are like inner classes (non-static nested classes) that are defined inside a method or scope block ({ ... }) inside a method.,NULL
Local classes can only be accessed from inside the method or scope block in which they are defined.,NULL
Local classes can access members (fields and methods) of its enclosing class just like regular inner classes.,"(""Local classes"", ""Local classes can access members of its enclosing class."", ""members""); (""Local classes"", ""Local classes can access methods of its enclosing class."", ""methods""); (""Local classes"", ""Local classes belong to an enclosing class."", ""enclosing class"")"
"Local classes can also access local variables inside the same method or scope block, provided these variables are declared final.",NULL
From Java 8 local classes can also access local variables and parameters of the method the local class is declared in.,NULL
In that case the local class only has access to the static parts of the enclosing class.,"(""Local Class"", ""The local class only has access to the static parts of the enclosing class, indicating a dependency or relationship in terms of access."", ""Enclosing Class"")"
"Local classes cannot contain all kinds of static declarations (constants are allowed - variables declared static final), because local classes are non-static in nature - even if declared inside a static method.","(""Static Declarations"", ""Static declarations are mentioned in the context of what local classes can contain."", ""Local Classes""); (""Constants"", ""Constants are specified as a type of static declaration that local classes can contain."", ""Static Declarations""); (""Variables"", ""Variables are referenced in the discussion about what constitutes static declarations."", ""Static Declarations""); (""Local Classes"", ""Local classes are discussed in relation to being inside a static method."", ""Static Method"")"
The same shadowing rules apply for local classes as for inner classes.,"(""Local Classes"", ""The text indicates that the same shadowing rules apply to both local and inner classes, suggesting a connection between the two."", ""Inner Classes"")"
Anonymous classes in Java are nested classes without a class name.,NULL
"They are typically declared as either subclasses of an existing class, or as implementations of some interface.",NULL
Here is an example that declares an anonymous subclass of a superclass called SuperClass:,"(""SuperClass"", ""class""); (""SuperClass"", ""class"")"
Running this Java code would result in Anonymous class doIt() being printed to System.out.,"(""Anonymous Class"", ""The method doIt() is part of the Anonymous Class"", ""doIt()""); (""doIt()"", ""The method doIt() prints its result to System.out"", ""System.out"")"
The anonymous class subclasses (extends) SuperClass and overrides the doIt() method.,NULL
A Java anonymous class can also implement an interface instead of extending a class.,"(""Anonymous Class"", ""An anonymous class can implement an interface, indicating a relationship where the anonymous class adopts the behavior defined by the interface."", ""Interface"")"
"As you can see, an anonymous class implementing an interface is pretty similar to an anonymous class extending another class.","(""Anonymous Class"", ""An anonymous class is implementing an interface, indicating a relationship between the two."", ""Interface"")"
"You can declare fields and methods inside an anonymous class, but you cannot declare a constructor.","(""Anonymous Class"", ""Methods can be declared inside an Anonymous Class"", ""Method"")"
"You can declare a static initializer for the anonymous class instead, though.",NULL
The same shadowing rules apply to anonymous classes as to inner classes.,"(""Anonymous Class"", ""The sentence states that the same shadowing rules apply to both anonymous classes and inner classes, indicating a relationship between the two."", ""Inner Class"")"
The benefits of Java nested classes are that you can group classes together that belong together.,NULL
"You could do so already by putting them in the same package, but putting one class inside another makes an even stronger grouping.",NULL
A nested class is typically only used by or with its enclosing class.,NULL
"Sometimes a nested class is only visible to the enclosing class, is only used internally, and is thus never visible outside the enclosing class.",NULL
"Other times the nested class is visible outside its enclosing class, but can only be used in conjunction with the enclosing class.","(""Nested Class"", ""The nested class is used in conjunction with, and is visible outside, the enclosing class, implying an inherent relationship between them."", ""Enclosing Class"")"
"Inside the Cache class you might declare a CacheEntry class which can contain information about a specific cache entry (cached value, time inserted, number of times accessed etc.).","(""Cache"", ""The CacheEntry class is declared within the Cache class."", ""CacheEntry"")"
"Users of the Cache class may never see the CacheEntry class, if they have no need to obtain information about the CacheEntry itself, but only the cached value.","(""Cache"", ""Cache utilizes CacheEntry for storing cached values"", ""CacheEntry"")"
"However, the Cache class may choose to make the CacheEntry class visible to the outside world, so they can access more than just the cached value (for instance information about when the value was last refreshed etc.",NULL
The first Cache class hides its CacheEntry nested class while the second Cache class exposes it.,NULL
You instantiate an object of a certain class using the new keyword.,"(""A Certain Class"", ""class""); (""A Certain Class"", ""class"")"
"This example declares a variable of the MyClass class (custom data type), and then creates a new MyClass instance and assigns a reference to this instance to myClassInstance variable.",NULL
"Inside the parantheses () after the for keyword, are three statements separated by semicolon (;).","(""Parantheses"", ""Class""); (""Statement"", ""Method"")"
"Here is a simple example of a class that has two methods, where one method calls the other:","(""Class"", ""Methods are defined within a class"", ""Methods""); (""Methods"", ""One method calls the other"", ""Methods"")"
"Notice how printBoth() calls the print() method two times, each time with a different of the parameters passed to the printBoth() method.","(""Printboth"", ""The Printboth method calls the Print method multiple times."", ""Print"")"
The print() method is thus a reusable block of code that can be called from anywhere.,"(""Print()"", ""Method""); (""Print()"", ""Method"")"
"When the print() method is finished executing, the program jumps back to after the line that called the print() method.","(""print()"", ""The statement indicates that the program jumps back to after the line that called the print() method, implying a relationship between execution and control flow related to the same method."", ""print()"")"
"Java packages are a mechanism to group Java classes that are related to each other, into the same ""group"" (package).","(""Java Packages"", ""Java Packages are used to group related Java Classes."", ""Java Classes"")"
"When a Java project grows bigger, for instance an app or API, it is useful to split the code into multiple Java classes, and the classes into multiple Java packages.",NULL
"When you divide classes into multiple Java packages, it becomes easier to figure out where a certain class you are looking for is.",NULL
All Java source and class files of classes belonging to the same package are located in the same directory.,"(""Class"", ""Classes belonging to the same package are grouped together."", ""Package""); (""Class"", ""Classes belonging to the same package are grouped together."", ""Package"")"
"Its a tree of packages, subpackages and classes inside these classes.","(""Packages"", ""Subpackages are smaller divisions within a package, indicating a hierarchical relationship."", ""Subpackages""); (""Subpackages"", ""Classes are components that exist within subpackages, showing an organization of classes inside subpackages."", ""Classes"")"
"I have expanded two of the sublevel Java packages, so you can see the classes inside.",NULL
"The classes are illustrated using a little blue circle with a C inside, in the screenshot above.","(""Class"", ""class"")"
"Similarly, the fully qualified name of a Java class includes its package name.",NULL
"For instance, the full qualified name of the ""Page"" class, is:","(""Page"", ""Class""); (""Page"", ""Class"")"
"In order to put add Java classes to packages, you must do two things:",NULL
Put the class files into the directory matching the package you want to add it to.,NULL
"When you have put your Java source file into the correct directory (matching the package the class should belong to), you have to declare inside that class file, that it belongs to that Java package.",NULL
"Not like Java classes, where the first letter is usually a capital letter.","(""Java"", ""class"")"
"If the classes A and B are located in the same Java package, there is no problem with the code above.",NULL
"If you need to use a lot of classes from a certain Java package, importing them one at a time results in a lot of import statements.","(""Package"", ""Classes can be grouped within a package, and importing a package allows you to access its classes."", ""Classes"")"
It is possible to import all classes of a package using the * character instead of a class name.,NULL
It is possible to use a class from another package without importing it with an import statement.,NULL
You can write the fully qualified class name instead of just the name of the class itself.,NULL
"The fully qualified class name consists of the full package path down to the subclass containing the class, and also including the class name itself.","(""Package"", ""The package provides the path in which the class is contained, indicating organizational hierarchy and namespace context."", ""Class""); (""Subclass"", ""The subclass is part of the class description, specifying a hierarchical relationship where the subclass extends or specializes the class."", ""Class""); (""Package"", ""The package provides the path in which the class is contained, indicating organizational hierarchy and namespace context."", ""Class""); (""Subclass"", ""The subclass is part of the class description, specifying a hierarchical relationship where the subclass extends or specializes the class."", ""Class"")"
The fully qualified class name is also what you would write in an import statement.,"(""Class Name"", ""The class name is used in the import statement."", ""Import Statement"")"
"You could use this fully qualified class name to reference the TimeUtil class inside another class, like this:","(""TimeUtil"", ""The TimeUtil class is referenced inside another class, indicating a likely relationship where TimeUtil is used or needed by another class."", ""another"")"
"You might be wondering how you decide on what Java packages to create, and how to divide your classes into these packages.",NULL
"The first method is to divide classes after what ""layer"" of the application they belong to.","(""Method"", ""Classes are often divided by the methods or strategies used within them, particularly in terms of their function or position within an application's architecture."", ""Classes"")"
All classes involved in communication with the database would then be located in the database package.,NULL
The second method is to divide your classes based on what part of the application functionality they belong to.,"(""Method"", ""A method is a function or routine that operates in conjunction with a class to define its behavior or operations"", ""Classes""); (""Method"", ""A method is a function or routine that operates in conjunction with a class to define its behavior or operations"", ""Classes"")"
"All classes involved in one way or another in the pension calculations would go into that package (or subpackages, if the number of classes in pension grow large).",NULL
"The ""divide by application functionality"" method of dividing classes into Java packages tends to work better than ""divide by layer"", as your application grows in number of classes.",NULL
"Instead of having a fixed number of layer packages which keep growing in number of classes, you get a growing number of application functionality packages with a smaller number of classes inside.",NULL
"These packages contain classes for all kinds of purposes that programmers often need, like reading and writing files from the local hard disk, sending and receiving data over networks and the internet, connecting to databases, and many, many other things.","(""Packages"", ""Packages contain classes for various programming purposes"", ""Classes"")"
"When you compile all the source code in the source, the compiler produces one .class file for each .java file.",NULL
It is the .class files that the Java Virtual Machine can execute.,"(""Class"", ""class"")"
Therefore it is normal to separate the .java files from the .class files.,NULL
This is normally done by instructing the compiler to write the .class files into a separate directory.,NULL
"This directory is often called classes, but again, it is not a requirement, and it depends on what build tool or IDE etc.","(""Classes"", ""The term 'classes' references a typical naming convention for a directory that contains class files"", ""Directory"")"
The *.java means the compiler should compile all files in the given directory.,"(""Compiler"", ""Class"")"
"Once the compiler has done its job, the classes directory will contain the compiled .class files.","(""Classes"", ""class"")"
The package structure (directory structure) from the source directory will be preserved under the class directory.,NULL
You can run any one of these .class files which have a main() method in it.,"(""Class"", ""The Main() method is typically contained within a class file."", ""Main()"")"
"You can run the .class from inside your Java IDE, or from the command line.","(""Java IDE"", ""class"")"
The -cp classes flag tells the Java Virtual Machine that all your classes are located under the directory called classes.,"(""Java Virtual Machine"", ""The Java Virtual Machine is instructed to find all the classes located under the 'classes' package or directory."", ""Classes""); (""Java Virtual Machine"", ""The Java Virtual Machine is instructed to find all the classes located under the 'classes' package or directory."", ""Classes"")"
The name of the class to run is the last argument in the above command - the myfirstapp.MyJavaApp part.,NULL
The JVM needs to know the fully qualified class name (all packages plus class name) to determine where the corresponding .class file is located.,NULL
When you run the the class your command line will look similar to this (including the output from the Java app):,"(""Class"", ""class"")"
A Java Record is a special kind of Java class which has a concise syntax for defining immutable data-only classes.,"(""Java Record"", ""Java Record is a kind of class defined within the Java package"", ""Java"")"
A Java Record consist of one or more data fields which corresponds to member variables in a regular Java class.,NULL
"The Java compiler auto generates getter methods, toString(), hashcode() and equals() methods for these data fields, so you don't have to write that boilerplate code yourself.","(""Getter methods"", ""The Java compiler generates getter methods automatically."", ""Java compiler""); (""toString"", ""The Java compiler generates the toString method automatically."", ""Java compiler""); (""hashcode"", ""The Java compiler generates the hashcode method automatically."", ""Java compiler""); (""equals"", ""The Java compiler generates the equals method automatically."", ""Java compiler"")"
"The Java compiler then generates the corresponding fields, getter methods and a hashCode() and equals() method.",NULL
You use a Java Record just like you use other Java classes - by creating instances of the record type using the Java new keyword.,NULL
"Notice how the Java compiler has generated a brand() method, a licensePlate() method and a toString() method for us.","(""Brand"", ""Both are methods generated by the Java compiler in the given context."", ""LicensePlate""); (""Brand"", ""Both are methods generated by the Java compiler in the given context."", ""ToString""); (""LicensePlate"", ""Both are methods generated by the Java compiler in the given context."", ""ToString"")"
"A Record type definition is final, meaning you cannot create subclasses (subrecords) of a Java Record type.","(""Record"", ""The text specifies that you cannot create subclasses (subrecords) of a Java Record type, implying a hierarchical or dependency relationship."", ""Subclasses"")"
You can add instance methods to a Java Record definition - just like you can with a regular Java class.,"(""Java Record"", ""Java Record can have instance methods added to it."", ""instance method""); (""instance method"", ""Instance methods can also be added to a regular Java class."", ""Java class"")"
Here is an example of the Vehicle Java Record definition from earlier sections with an instance method named brandAsLowerCase() added:,"(""Vehicle"", ""The method brandAsLowerCase is a part of the Vehicle class as an instance method."", ""brandAsLowerCase""); (""Vehicle"", ""The class Vehicle is defined within the Java package."", ""Java""); (""Vehicle"", ""The method brandAsLowerCase is a part of the Vehicle class as an instance method."", ""brandAsLowerCase""); (""Vehicle"", ""The class Vehicle is defined within the Java package."", ""Java"")"
Notice how the brandAsLowerCase() method calls the auto-generated brand() method internally.,"(""BrandAsLowerCase"", ""The BrandAsLowerCase method internally calls the Brand method, indicating a dependency or usage relationship."", ""Brand"")"
"That means, that even classes from different projects compiled separately, but which are used in the same application may share constant String objects.",NULL
"As you can see, a new StringBuilder is created, passing along the first String to its constructor, and the second String to its append() method, before finally calling the toString() method.",NULL
This code actually creates two objects: A StringBuilder instance and a new String instance returned from the toString() method.,NULL
"The bigger the result String grows, the longer it takes to copy the characters from it into a new StringBuilder, and again copy the characters from the StringBuilder into the temporary String created by the toString() method.","(""toString"", ""The toString() method is called to create a temporary String instance."", ""String""); (""StringBuilder"", ""StringBuilder is used to build a String more efficiently."", ""String"")"
You can obtain the length of a String using the length() method.,NULL
You do so using the substring() method of the String class.,"(""Substring"", ""The 'Substring' method is part of the 'String' class as indicated by the text."", ""String""); (""Substring"", ""The 'Substring' method is part of the 'String' class as indicated by the text."", ""String"")"
The last character in the string has has the index String.length() - 1.,NULL
You can search for substrings in Strings using the indexOf() method.,NULL
The indexOf() method returns the index of where the first character in the first matching substring is found.,"(""IndexOf"", ""Method"")"
"If the substring is not found within the string, the indexOf() method returns -1;","(""indexOf()"", ""method"")"
There is a version of the indexOf() method that takes an index from which the search is to start.,NULL
The Java String class also has a lastIndexOf() method which finds the last occurrence of a substring.,"(""String"", ""The lastIndexOf method belongs to the String class and is used to find the last occurrence of a substring."", ""lastIndexOf""); (""Java"", ""The String class is part of the Java package."", ""String"")"
"The Java String matches() method takes a regular expression as parameter, and returns true if the regular expression matches the string, and false if not.",NULL
The equals() method tests if two Strings are exactly equal to each other.,NULL
The String class also has a method called equalsIgnoreCase() which compares two strings but ignores the case of the characters.,"(""String"", ""The equalsIgnoreCase method belongs to the String class and is used to compare two strings while ignoring the case of the characters."", ""equalsIgnoreCase"")"
The startsWith() and endsWith() methods check if the String starts with a certain substring.,"(""StartsWith()"", ""The startsWith() method is a function that operates on instances of the String class to determine if the string starts with a specific substring."", ""String""); (""EndsWith()"", ""The endsWith() method is a function that operates on instances of the String class to determine if the string ends with a specific substring."", ""String"")"
"The compareTo() method compares the String to another String and returns an int telling whether this String is smaller, equal to or larger than the other String.","(""CompareTo"", ""The compareTo() method is used to compare one String object to another to determine their lexical order."", ""String""); (""CompareTo"", ""The compareTo() method is used to compare one String object to another to determine their lexical order."", ""String"")"
"If the String is earlier in sorting order than the other String, compareTo() returns a negative number.","(""String"", ""The compareTo() method is associated with the String class as it is used for comparing strings."", ""compareTo"")"
"If the String is equal in sorting order to the other String, compareTo() returns 0.",NULL
"If the String is after the other String in sorting order, the compareTo() metod returns a positive number.",NULL
You should be aware that the compareTo() method may not work correctly for Strings in different languages than English.,"(""compareTo"", ""The compareTo method is used in the context of String class to compare strings."", ""String"")"
The Java String class contains a method called trim() which can trim a string object.,"(""String"", ""The trim() method is part of the String class, allowing it to manipulate string objects."", ""trim()"")"
The trim() method can be very useful to trim text typed into input fields by a user.,"(""Trim"", ""Method"")"
The trim() method is an easy way to remove such extra white space characters.,NULL
The Java String class contains a method named replace() which can replace characters in a String.,"(""String"", ""The Replace method is part of the String class."", ""Replace"")"
The replace() method does not actually replace characters in the existing String.,NULL
"The replace() method will replace all character matching the character passed as first parameter to the method, with the second character passed as parameter to the replace() method.",NULL
The Java String replaceFirst() method returns a new String with the first match of the regular expression passed as first parameter with the string value of the second parameter.,"(""replaceFirst"", ""The method replaceFirst() is a part of the class String."", ""String"")"
The Java String replaceAll() method returns a new String with all matches of the regular expression passed as first parameter with the string value of the second parameter.,"(""String"", ""replaceAll is a method that belongs to the String class"", ""replaceAll"")"
The Java String class contains a split() method which can be used to split a String into an array of String objects.,"(""String"", ""The split method is a function contained within the String class."", ""split"")"
The parameter passed to the split() method is actually a Java regular expression.,NULL
The String split() method exists in a version that takes a limit as a second parameter.,NULL
Here is a Java String split() example using the limit parameter:,NULL
The Java String class contains a set of overloaded static methods named valueOf() which can be used to convert a number to a String.,NULL
"Since all Java classes extends (inherits from) the Object class, all objects have a toString() method.","(""Object"", ""The toString method is defined in the Object class, which all Java classes inherit from, and thus all objects have access to this method."", ""toString"")"
"Note: For the toString() method to return a sane String representation of the given object, the class of the object must have overridden the toString() method.",NULL
"If not, the default toString() method (inherited from the Object class) will get called.",NULL
The default toString() method does not provide that much useful information.,"(""ToString"", ""method"")"
It is possible to get a character at a certain index in a String using the charAt() method.,NULL
You can also get the byte representation of the String method using the getBytes() method.,"(""String"", ""The getBytes method provides the byte representation of the String method."", ""getBytes"")"
The first getBytes() call return a byte representation of the String using the default character set encoding on the machine.,NULL
The second getBytes() call return a UTF-8 byte representation of the String.,"(""getBytes"", ""The method getBytes is called on the class String to return its UTF-8 byte representation."", ""String"")"
You can convert Strings to uppercase and lowercase using the methods toUpperCase() and toLowerCase().,"(""String"", ""The method toUpperCase() is used to convert instances of the class String to uppercase."", ""toUpperCase""); (""String"", ""The method toLowerCase() is used to convert instances of the class String to lowercase."", ""toLowerCase"")"
From Java 13 the Java String class got a new method named formatted() which can be used to return a formatted version of the String formatted() is called on.,NULL
"The formatted() method is only a preview feature that was added together with Java Text Blocks in Java 13, so we do not yet know if it will stay in.","(""Formatted"", ""The formatted() method was added together with Text Blocks."", ""Text Blocks""); (""Formatted"", ""The formatted() method is a preview feature related to the Java package."", ""Java"")"
Here is an example of using the Java String formatted() method:,NULL
The parameter values passed to formatted() will be inserted into the returned String at the %s location of the input String.,"(""Formatted"", ""The 'formatted' method is used to insert parameter values into a 'String' at specified locations."", ""String"")"
"From Java 13 the Java String class got a new method named stripIndent() which can be used to strip out indentation, similarly to how indentation is stripped out of Java Text Blocks.","(""Java String"", ""The stripIndent() method is associated with the Java String class as a new method added in Java 13."", ""stripIndent()""); (""Java String"", ""The stripIndent() method is associated with the Java String class as a new method added in Java 13."", ""stripIndent()"")"
"The stripIndent() method is a preview feature, so we don't know if it will stay in Java yet.",NULL
Here is an example of using the new Java String stripIndent() method:,NULL
From Java 13 the Java String class got a new method called translateEscapes() which can translate escape codes that exist inside a String in the same way the Java compiler translates them.,"(""Java String"", ""The translateEscapes method is a new addition to the Java String class."", ""translateEscapes"")"
"For now, the translateEscapes() is a preview feature, so it is not yet sure that it will stay in Java.","(""TranslateEscapes"", ""The method translateEscapes is a feature related to the Java package, indicating that it belongs to or is used within the Java environment."", ""Java"")"
Here is an example of using the Java String translateEscapes() method:,"(""String"", ""The method translateEscapes() belongs to the String class, indicating its functionality is related to String objects."", ""translateEscapes()""); (""String"", ""The method translateEscapes() belongs to the String class, indicating its functionality is related to String objects."", ""translateEscapes()"")"
When calling the translateEscapes() method the \n part of the text will now be interpreted as a line break escape code.,"(""TranslateEscapes"", ""The TranslateEscapes method interprets text containing escape sequences such as the line break escape code."", ""Line Break Escape Code"")"
The String class has several other useful methods than the ones described in this tutorial.,"(""String"", ""The String class is related to methods because it contains several methods."", ""methods"")"
"The result of this is, that execution just ""falls through"" to the operation of the next case statement ( and the next etc.)",NULL
All Java code must reside inside a file with the extension .java .,NULL
"Below is an example .java file that contains all of the above elements, so you can see the basic syntax of a .java file:",NULL
The .java file should be located in a directory structure that matches the package name.,NULL
"Please note, that the code example does not actually use the Java HashMap class anywhere.","(""HashMap"", ""class"")"
Of course you should not import classes you do not use in a real project.,"(""CLASSES"", ""CLASSES are typically a part of a PROJECT when they are imported and used."", ""PROJECT"")"
"In Java a type is either a class, an abstract class an interface, an enum or an annotation.",NULL
A type (class / interface / enum) can have more than one field.,"(""A TYPE"", ""CLASS"")"
The fifth line (or block of lines) is a class initializer block.,"(""Class Initializer Block"", ""class""); (""Class Initializer Block"", ""class"")"
Inside this block you can put initialization code that is to be executed a instance of the class is created.,"(""Class"", ""A method is often used for initialization in a class."", ""Method"")"
"Then they are executed already when the class is loaded, and only once because the class is only loaded in the Java Virtual Machine once.",NULL
"Constructors are similar to class initializers, except they can take parameters.",NULL
"A class can have more than one constructor, although this example just shows one.","(""Class"", ""A class can have one or more constructors as methods to initialize objects."", ""Constructor"")"
When you create an instance of a class (an object) the object can have methods you can execute.,"(""Class"", ""Classes contain methods that can be executed by instances of the class, known as objects."", ""Method"")"
"A static method belongs to the class, not objects of the class.","(""Static Method"", ""A static method belongs to the class."", ""Class"")"
That means that you can call a static method without having an object of the class the static method belongs to.,"(""Static Method"", ""A static method belongs to a class and can be called without having an object of that class."", ""Class"")"
"In the example above, if case.equals(""uppercase"") evaluates to true then the ternary operator expression as a whole returns the String value JOHN.","(""String"", ""The String class is considered because JOHN is a string value."", ""JOHN""); (""String"", ""The String class is considered because JOHN is a string value."", ""JOHN"")"
"If case.equals(""uppercase"") evaluates to false then the ternary operator expression as a whole returns the String value john.","(""Case"", ""The 'equals' method is called on the 'Case' class to compare its value."", ""Equals""); (""Ternary Operator Expression"", ""The ternary operator expression returns a 'String' value based on the condition."", ""String"")"
"That means, that the String variable name will end up having the value JOHN or john depending on whether the expression case.equals(""uppercase"") evaluates to true or false.","(""String"", ""The String class is used in conjunction with the variable named 'name' to hold its value."", ""name"")"
"As you can see, both of these code examples avoid calling object.getValue() if the object reference is null, but the first code example is a bit shorter and more elegant.",NULL
You can achieve the same functionality as the Java Math max() function using a Java ternary operator.,NULL
Here is an example of achieving the Math.max() functionality using a Java ternary operator:,"(""Math"", ""The 'max()' method is a member of the 'Math' package"", ""max()""); (""Math"", ""The 'max()' method is a member of the 'Math' package"", ""max()"")"
The Java ternary operator can also be used to achieve the same effect as the Java Math min() function.,"(""Min"", ""The Min method belongs to the Java Math package"", ""Java Math""); (""Java Ternary Operator"", ""The Java Ternary Operator can be used to achieve the same effect as the Min method"", ""Min"")"
Here is an example of achieving the Math.min() functionality using a Java ternary operator:,"(""Math.min()"", ""The method Math.min() is an example of functionality that can be achieved using Java code."", ""Java"")"
The Java ternary operator can also be used to achieve the same effect as the Java Math abs() function.,NULL
Here is an example of achieving the Math.abs() functionality using a Java ternary operator:,"(""Math"", ""The abs() method is part of the Math package, as Math.abs() is a common method invocation in Java."", ""abs()""); (""abs()"", ""The method abs() is employed using Java, which suggests that the method is being executed in a Java context."", ""Java""); (""Math"", ""The Math package is used within the Java language framework."", ""Java"")"
"If the input String is not equal to the empty String, the second ternary operator returns the value of Integer.parseInt(input) .",NULL
"This can be any kind of information ranging from texts, codes (e.g.",NULL
"In the code example below, the main() method contains the declaration of a single integer variable named number.",NULL
"Non-static fields are also called instance variables, because they belong to instances (objects) of a class.","(""Instance Variables"", ""Instance variables are attributes or fields that belong to instances of a class."", ""Class"")"
A static field is a variable that belongs to a class.,NULL
The second line assigns the floating point value 199.99 to the floating point variable named myFloat.,NULL
"In this example, only the first System.out.println() statement is executed inside the while loop.","(""System"", ""println is a method that is likely called from the System class"", ""println""); (""System"", ""println is a method that is likely called from the System class"", ""println"")"
The second System.out.println() statement is not executed until after the while loop is finished.,NULL
"This is typically done via a command line interface (CLI), like e.g.",NULL
On the command line you tell the JVM what Java class (bytecode) to execute.,"(""Java Class"", ""class"")"
Only the full Java SDK contains the Java compiler which turns your .java source files into byte code .class files.,NULL
"Additionally, some Java servers may need some of the tools in the JDK to e.g.","(""Java"", ""The Java package is often associated with the JDK package, as the JDK is commonly used to build and run Java applications."", ""JDK"")"
"The Java Code Conventions are a set of conventions for how to format your Java code, and how to name classes, variables, files etc.","(""Java Code Conventions"", ""Java Code Conventions defines how to format Java code."", ""Java"")"
JavaFX was inspired by Flex (Flash) and Silverlight for .NET (Microsoft).,NULL
In this tutorial I will show you how to make your first Java app with IntelliJ IDEA community edition (free) version 2019.3.3.,NULL
"How you do that depends on what operating system you are running (Windows, Mac, Linux etc.)",NULL
"A Java package is just a directory inside which you can put one or more Java files (class, interface, annotation, enum etc.","(""Java"", ""Java files are contained within a Java package, indicating a hierarchical relationship where files are organized under packages."", ""Java files"")"
Now you must create a new class inside your newly created package.,NULL
"In the dialog that opens, type in a name for your new Java class.","(""Java"", ""class""); (""Java"", ""class"")"
"It is custom to have class names start with an uppercase character followed by lowercase characters, and a new uppercase character for each new word in the class name.","(""Class"", ""class"")"
"When you have typed in a name for your new Java class, click the ""OK"" button.",NULL
"Once you have created the new class, it will be empty.","(""Class"", ""class"")"
The part inside the /* ... */ are comments and are not part of the executed Java code.,"(""JAVA"", ""PACKAGE"")"
Before you can run your Java app you need to insert a main() method into the class.,"(""Main"", ""The main() method needs to be inserted into a class for the Java application to run."", ""Class"")"
Now your are ready to run your newly created Java class.,"(""Java"", ""class"")"
"You do so by right clicking the class source code in the editor, and choose ""Run..."", like this:",NULL
"When you click the ""Run..."" option, IntelliJ IDEA will first compile your Java class, and then run it.","(""IntelliJ IDEA"", ""IntelliJ IDEA compiles and runs the Java class"", ""Java Class"")"
"After you have executed the Java class main method, you will see an output at the bottom of the IntelliJ IDEA window similar to this:",NULL
"Don't worry if you don't yet understand what a main() method is, or classes, or packages.",NULL
The most common way of using the Java Logging API is to create a Logger in each class that needs to log.,NULL
"This instance is typically made static and final, meaning all instances of that class use the same Logger instance.",NULL
"As you can see from this example, it is common practice to use the class name including package name as name for the Logger.","(""Logger"", ""Logger is typically used with its corresponding package name in naming conventions."", ""package name"")"
The name of the Logger to create is passed as string parameter to the Logger.getLogger() method.,NULL
"For instance, ordinary debug trace logging calls to entering() and exiting() would be called at the beginning and end of a method call.",NULL
The initialization of the configuration is taken care of by the java.util.logging.LogManager class.,NULL
You can use a Java class to configure the Java Logging API.,"(""Java"", ""Java is related to Java Logging as it can be used to configure the Java Logging API"", ""Java Logging"")"
You do so by specifying the name of the class in the JVM parameter java.util.logging.config.class.,NULL
It is the constructor of that class that should load the configuration and apply it to the Logger's in the hierarchy.,"(""Constructor"", ""The constructor is used to load the configuration and apply it to the Logger, indicating a functional relationship between the method and the class."", ""Logger"")"
"If no configuration class is specified, you can instead specify a configuration file (but no configuration class can be specified then!",NULL
"The Java Logging API has a default logging configuration file located at ""lib/logging.properties"", inside the JRE directory.",NULL
You do so by setting the JVM property java.util.logging.config.file to point to this file.,NULL
You should double check the JavaDoc over time to see if any of this changes (e.g.,"(""JavaDoc"", ""package"")"
"If the isLoggable() method returns false, the LogRecord is not logged.",NULL
The Handler's in the Java Logging API use a java.util.logging.Formatter to format the LogRecord's before writing it to an external system.,"(""Handler"", ""Handler uses a Formatter to format LogRecord before writing it to an external system."", ""java.util.logging.Formatter""); (""java.util.logging.Formatter"", ""Formatter is used to format LogRecord."", ""LogRecord"")"
"The various Handler's in the Java Logging API use either of these two Formatter's by default, but you can also set your own custom Formatter subclass on a Handler.","(""Handler"", ""Handlers are a component of the Java Logging API, implying a relationship as part of the same package structure."", ""Java Logging API""); (""Handler"", ""Handlers use Formatters to format log messages, indicating a functional relationship."", ""Formatter""); (""Handler"", ""The Handler can use a custom Formatter subclass, showing a specialized use case relationship."", ""Formatter Subclass"")"
You can create your own Formatter by subclassing the java.util.logging.Formatter class.,"(""Formatter"", ""The Formatter class is part of the java.util.logging package."", ""java.util.logging"")"
The subclass must override the abstract format() method in the Formatter class.,NULL
The String returned by the format() is what is forwarded to the external system by the Handler.,"(""format()"", ""The method format() returns an object of type String."", ""String""); (""Handler"", ""The Handler forwards the String to the external system."", ""String"")"
The Formatter class also contains the convenience method formatMessage() which can be used to format the message using the ResourceBundle of the LogRecord.,"(""Formatter"", ""Formatter class contains the formatMessage method."", ""formatMessage""); (""formatMessage"", ""formatMessage method uses ResourceBundle."", ""ResourceBundle""); (""formatMessage"", ""formatMessage method uses LogRecord."", ""LogRecord"")"
By default the ConsoleHandler uses a SimpleFormatter to format the messages before writing them to System.err.,"(""ConsoleHandler"", ""The ConsoleHandler uses a SimpleFormatter to format messages."", ""SimpleFormatter""); (""ConsoleHandler"", ""The ConsoleHandler writes messages to System.err."", ""System.err"")"
"If no %g code has been specified and the file count of the FileHandler is greater than 1, then the generation number (file sequence number) will be appended to the end of the file name, after a dot (.)","(""FileHandler"", ""FileHandler uses file count to determine file operations"", ""file count""); (""generation number"", ""Generation number is another term for file sequence number in this context"", ""file sequence number"")"
You must set one using the method setOutputStream() before using the handler.,"(""setOutputStream"", ""The method 'setOutputStream' must be set before using the 'handler'."", ""handler"")"
You can also call the push() method to force the LogRecord's in the buffer to be flushed to the target Handler.,"(""Push"", ""The push method is called to force the LogRecord instances in the buffer to be flushed."", ""LogRecord""); (""LogRecord"", ""The LogRecord instances are flushed to the target Handler."", ""Handler""); (""Push"", ""The push method is called to force the LogRecord instances in the buffer to be flushed."", ""LogRecord""); (""LogRecord"", ""The LogRecord instances are flushed to the target Handler."", ""Handler"")"
This class contains a constant for each of the above log levels.,"(""Class"", ""class"")"
When you create a Logger you pass a name to the Logger.getLogger() method.,NULL
(Note: These levels are different from the log levels of the messages logged.).,NULL
If you call getParent() on that Logger you will get the Logger with the name com.,NULL
"... and call getParent() method, you will get the Logger with the name """".","(""getParent"", ""The getParent method is called to retrieve the Logger class."", ""Logger"")"
"The third message is being logged three times: Once by the 1.2 Logger, once by the 1 Logger, and once by the root Logger.",NULL
"Notice though, that the message propagated up the hierarchy from the Logger named 1.2 is still logged by the middle Logger, and still forwarded up to the root Logger.","(""Logger"", ""The Logger class is part of a hierarchy that forwards messages up to the Root Logger."", ""Root Logger"")"
"Another peculiar result of the above code is, that the INFO message passed to the bottom Logger (named 1.2) is also ignored, and not propagated.","(""Logger"", ""class"")"
"In order to enable all INFO messages to be logged from the bottom Logger (named 1.2), even if the middle Logger has a log level of WARNING, we add the following to the code (in bold):",NULL
"The result of this code is that the INFO message logged on the bottom Logger (named 1.2) is now logged, but it is still not propagated up the hierarchy.","(""Logger"", ""Logger logs INFO message as its core functionality"", ""INFO message""); (""Logger"", ""Logger logs INFO message as its core functionality"", ""INFO message"")"
The java.util.Logger class is the main access point to the Java logging API.,NULL
The string passed as parameter to the getLogger() factory method is the name of the Logger to create.,NULL
"The two names ""myApp.user"" and ""myApp.admin"" are children of the ""myApp"" name.","(""Myapp.User"", ""Myapp.User is a part of the Myapp package"", ""Myapp""); (""Myapp.Admin"", ""Myapp.Admin is a part of the Myapp package"", ""Myapp"")"
"The name ""myApp.admin.import.user"" is a branch of the name ""myApp.admin.import"", which is again a branch of the ""myApp.admin"" name.",NULL
"You can obtain the name of a Logger using the getName() method, in case you need it.",NULL
"It is convention to use the class name of the class creating the Logger, including package name, as name for the Logger.",NULL
The log() group of methods will log a message at a certain log level.,"(""Log"", ""The text mentions a group of methods called log."", ""Log"")"
"As mentioned earlier, the number inside the token refers to the index of the object parameter to insert, in the object parameter array passed to the log() message.",NULL
"The logp() methods work like the log() methods, except each method take an extra two parameters: The sourceClass and sourceMethod parameter.",NULL
These two parameters are intended to tell from what class and method the log message originated.,"(""Class"", ""The log message originates from both the class and the method, indicating a relationship between them."", ""Method"")"
"In other words, which class and method was the ""source"" of the log message.","(""Class"", ""class""); (""Method"", ""method"")"
"The logrb() methods work like the log() methods too, except they can obtain the log messages from a resource bundle.",NULL
This example looks up a message in the resource bundle named resources.myresources by the key key1.,NULL
"For instance, finest(), finer(), fine(), info(), warning() and severe() each corresponds to one of the log levels.","(""Finest"", ""The method Finest corresponds to the log level Finest level"", ""Log Level""); (""Finer"", ""The method Finer corresponds to the log level Finer level"", ""Log Level""); (""Fine"", ""The method Fine corresponds to the log level Fine level"", ""Log Level""); (""Info"", ""The method Info corresponds to the log level Info level"", ""Log Level""); (""Warning"", ""The method Warning corresponds to the log level Warning level"", ""Log Level""); (""Severe"", ""The method Severe corresponds to the log level Severe level"", ""Log Level"")"
Logging message using one of these methods corresponds to calling the log() method,"(""Logging message"", ""The Logging message class uses the Log method to perform its operations, as indicated by the reference to calling the log() method in the text."", ""Log"")"
You can add Handler's to the Logger using the addHandler() method.,"(""Logger"", ""The addHandler method is used to add Handler instances to the Logger class."", ""addHandler""); (""Handler"", ""Handlers are components that can be added to a Logger to manage output."", ""Logger"")"
"You can obtain all Handler's of a Logger using the getHandlers() method, like this:","(""Logger"", ""The method 'getHandlers' is used to obtain all Handlers of a Logger."", ""getHandlers""); (""Logger"", ""Handlers are associated with a Logger to manage its operations."", ""Handler""); (""Logger"", ""The method 'getHandlers' is used to obtain all Handlers of a Logger."", ""getHandlers""); (""Logger"", ""Handlers are associated with a Logger to manage its operations."", ""Handler"")"
"You set the Filter on a Logger using the setFilter() method, like this:","(""setFilter"", ""The setFilter method is used to set the Filter on the Logger class."", ""Logger"")"
The class MyFilterImpl should be your own implementation of the Filter interface.,"(""MyFilterImpl"", ""MyFilterImpl is described as an implementation of the Filter interface, indicating a relationship where MyFilterImpl extends or implements Filter."", ""Filter"")"
"You can obtain the Filter in use by calling the getFilter() method, like this:","(""getFilter"", ""The getFilter method is related to the Filter class because it is used to obtain the current filter in use."", ""Filter"")"
"This example sets the minimum log level of messages to be forwarded, to Level.INFO.","(""Level.INFO"", ""class""); (""Level.INFO"", ""class"")"
You can obtain the log level of a Logger using the getLevel() method:,NULL
You can obtain the parent Logger of a given Logger using the getParent() method.,NULL
You can check if a Logger forwards log messages to its parent Logger using the method getUseParentHandlers().,"(""Logger"", ""The getUseParentHandlers method is used to check if a Logger forwards log messages to its parent Logger."", ""getUseParentHandlers"")"
The Logger class has a few more methods that I haven't covered here.,"(""Logger"", ""The methods are functions associated with the Logger class."", ""methods"")"
"The java.util.logging.LogManager manages the internal Logger hierarchy, and initiates the configuration of the Logger's, either through the configuration class or configuration file.","(""LogManager"", ""LogManager manages the internal hierarchy of Logger."", ""Logger""); (""LogManager"", ""LogManager initiates configuration through the configuration class."", ""configuration class""); (""LogManager"", ""LogManager can also initiate configuration through a configuration file."", ""configuration file""); (""Logger"", ""Logger is part of the java.util.logging package."", ""java.util.logging"")"
"The first method on the LogManager simply re-reads the configuration from file (or class), in case these has changed.","(""LogManager"", ""The method belongs to the LogManager class and performs the action of re-reading configuration."", ""method"")"
You can also get access to an MXBean (Java Management Extensions) from the LogManager using the method getLoggingMXBean().,NULL
"The LogRecord contains the following getter methods, which can be used in e.g.",NULL
The getLevel() method returns the log level the message represented by this LogRecord was logged with.,"(""getLevel()"", ""method""); (""getLevel()"", ""method"")"
The getLoggerName() method returns the name of the Logger that logged this LogRecord.,"(""GetLoggerName"", ""The getLoggerName() method is used to retrieve the name of the Logger that logged the LogRecord."", ""Logger""); (""GetLoggerName"", ""The getLoggerName() method provides information about the LogRecord that was logged."", ""LogRecord"")"
The getMillis() method returns the time in milliseconds this LogRecord was recorded.,NULL
The getParameters() method returns the parameters to be inserted into the message of this LogRecord.,"(""GetParameters"", ""The method GetParameters is associated with the LogRecord class as it returns parameters to be inserted into the message of this LogRecord."", ""LogRecord"")"
The getResourceBundle() method returns the ResourceBundle (if any) used to localize the message of this LogRecord.,"(""getResourceBundle"", ""The method getResourceBundle returns an instance of ResourceBundle."", ""ResourceBundle""); (""getResourceBundle"", ""The method getResourceBundle is used in the context of a LogRecord to localize its message."", ""LogRecord"")"
The getResourceBundleName() method returns the name of the ResourceBundle (if any) used to localize the message of this LogRecord.,NULL
The getSequenceNumber() method returns a sequence number generated internally in the LogRecord constructor when the LogRecord is created.,"(""LogRecord"", ""The getSequenceNumber method is associated with the LogRecord class because it returns a sequence number generated during the LogRecord construction."", ""getSequenceNumber""); (""LogRecord"", ""The getSequenceNumber method is associated with the LogRecord class because it returns a sequence number generated during the LogRecord construction."", ""getSequenceNumber"")"
The getSourceClassName() returns the class name of the class logging the message represented by this LogRecord.,"(""getSourceClassName"", ""The method getSourceClassName is used to retrieve the class name of the class logging the message, which is represented by the LogRecord."", ""LogRecord"")"
The getSourceMethodName() returns the method name of the method logging the message represented by this LogRecord.,"(""GETSOURCEMETHODNAME"", ""The getSourceMethodName method operates on or returns information from a LogRecord class."", ""LOGRECORD"")"
The getThreadID() method returns the ID of the thread logging the message represented by this LogRecord.,"(""getThreadID"", ""The getThreadID method retrieves the thread ID associated with a LogRecord instance"", ""LogRecord""); (""getThreadID"", ""The getThreadID method retrieves the thread ID associated with a LogRecord instance"", ""LogRecord"")"
The getThrown() method returns the Throwable that was marked thrown when logging the message represented by this LogRecord.,NULL
In this text I will try to give you an overview of the java.util.logging API.,"(""Java.Util.Logging"", ""package"")"
This tutorial is about Javas built-in logging API in the java.util.logging package.,NULL
"Note: This tutorial does not cover the other popular Java logging API's (Log4J, SLF4J, Apache Commons Logging, LogBack etc.).","(""Log4J"", ""Both are popular Java logging APIs"", ""SLF4J""); (""SLF4J"", ""Both are popular Java logging APIs"", ""Apache Commons Logging""); (""Apache Commons Logging"", ""Both are popular Java logging APIs"", ""LogBack""); (""LogBack"", ""Both are popular Java logging APIs"", ""Log4J"")"
"If you can choose your own logging API freely, you may choose one of these other, popular logging API's instead of java.util.logging.",NULL
"However, if you are running your web applications on Google App Engine, like I do, then you have to use the java.util.logging API.","(""Google App Engine"", ""java.util.logging is used in Google App Engine for logging purposes."", ""java.util.logging""); (""Google App Engine"", ""java.util.logging is used in Google App Engine for logging purposes."", ""java.util.logging""); (""Google App Engine"", ""java.util.logging is used in Google App Engine for logging purposes."", ""java.util.logging"")"
Instances of this class are used together with UDP DatagramSockets and normal Socket's and ServerSocket's.,NULL
The InetAddress class has a lot of additional methods you can use.,"(""InetAddress"", ""The InetAddress class contains or offers additional methods."", ""methods"")"
"For instance, you can obtain the IP address as a byte array by calling getAddress() etc.",NULL
"To learn more about these methods, it is easier to read the JavaDoc for the InetAddress class though.","(""InetAddress"", ""class"")"
Java's JarURLConnection class is used to connect to a Java Jar file.,"(""JarURLConnection"", ""The JarURLConnection class is specifically used to connect to a Java Jar file."", ""Jar file"")"
"Of course, sometimes this protocol is already have been decided for you, e.g.",NULL
Sending the header in a separate roundtrip (the first) can be smart if the server can do some initial pre-validation of e.g.,NULL
"In order to implement a Java server that listens for incoming connections from clients via TCP/IP, you need to use a java.net.ServerSocket .",NULL
"In case you prefer to use Java NIO instead of Java Networking (standard API), then you can also use a ServerSocketChannel instead of the java.net.ServerSocket.",NULL
In order to accept incoming connections you must call the ServerSocket.accept() method.,NULL
The accept() method returns a Socket which behaves like an ordinary Java Socket.,NULL
Only one incoming connection is opened for each call to the accept() method.,"(""Accept"", ""The 'accept()' method facilitates the opening of 'Connection'."", ""Connection"")"
"Additionally, incoming connections can only be accepted while the thread running the server has called accept().","(""Thread"", ""The method 'accept' is called within a thread context for processing incoming connections."", ""accept""); (""Server"", ""The server uses the 'accept' method to handle incoming connections."", ""accept"")"
"In order to connect to a server over the internet (via TCP/IP) in Java, you need to create a java.net.Socket and connect it to the server.","(""Java.Net.Socket"", ""Java.Net.Socket is used to connect to a server over the internet via TCP/IP"", ""Server"")"
This code example connects to the server with IP address 78.46.84.171 on port 80.,NULL
"Don't forget to call flush() when you really, really want the data sent across the internet to the server.",NULL
The getByName() method returns an InetAddress instance with the IP address matching the given host name.,NULL
Receiving data via a DatagramSocket is done by first creating a DatagramPacket and then receiving data into it via the DatagramSocket's receive() method.,"(""DatagramSocket"", ""The receive() method is used to receive data into a DatagramPacket, indicating a functional relationship within the DatagramSocket class"", ""receive()"")"
"A real server program would probably call the receive() method in a loop, and pass all received DatagramPacket's to a pool of worker threads, just like a TCP server does with incoming connections (see Java Multithreaded Servers for more details).","(""Receive"", ""The 'Receive' method is used in conjunction with 'DatagramPacket' to receive data in a network communication context."", ""DatagramPacket""); (""Java Multithreaded Servers"", ""Java Multithreaded Servers likely provides context or framework for using the 'Receive' method in server applications."", ""Receive"")"
The java.net package contains two interesting classes: The URL class and the URLConnection class.,"(""Java.net"", ""The URL class is contained within the Java.net package"", ""URL""); (""Java.net"", ""The URLConnection class is contained within the Java.net package"", ""URLConnection"")"
These classes can be used to create client connections to web servers (HTTP servers).,NULL
"If you want to send an HTTP POST request instead, call the URLConnection.setDoOutput(true) method, like this:","(""URLConnection.setDoOutput(true)"", ""method"")"
The URL class can also be used to access files in the local file system.,"(""URL"", ""The URL class can access files in the local file system."", ""file system"")"
"Thus the URL class can be a handy way to open a file, if you need your code to not know whether the file came from the network or local file system.","(""URL"", ""The URL class can be used to open a file, suggesting that it provides functionality related to file operations."", ""open a file"")"
Here is an example of how to open a file in the local file system using the URL class:,NULL
"Notice how the only difference from accessing a file on a web server via HTTP is the the URL: ""file:/c:/data/test.txt"".",NULL
"Even though the Java Networking APIs enable you to open and close network connections via sockets, all communication happens via the Java IO classes InputStream and OutputStream.",NULL
Alternatively you can use the networking classes in the Java NIO API.,"(""Networking Classes"", ""The Networking Classes are part of the Java NIO API package, which provides functionalities for networking."", ""Java NIO API"")"
"These classes are similar to the classes found in the Java Networking API, except the Java NIO API can work in non-blocking mode.","(""Java NIO API"", ""The text discusses how the classes in the Java NIO API have non-blocking mode capabilities."", ""classes""); (""Java Networking API"", ""The text mentions classes found within the Java Networking API."", ""classes"")"
The first parameter to the open() method is a Path instance pointing to the file the AsynchronousFileChannel is to be associated with.,"(""Open"", ""The Open method uses the Path class as its parameter."", ""Path""); (""Open"", ""The Open method is used to associate with an AsynchronousFileChannel class."", ""AsynchronousFileChannel"")"
In this example we used the StandardOpenOption.READ which means that the file will be opened for reading.,NULL
Each way to read data call one of the read() methods of the AsynchronousFileChannel.,NULL
The first way to read data from an AsynchronousFileChannel is to call the read() method that returns a Future.,"(""AsynchronousFileChannel"", ""The read() method is used to perform read operations on the AsynchronousFileChannel."", ""read()""); (""read()"", ""The read() method returns a Future, indicating an asynchronous operation result."", ""Future"")"
This version of the read() method takes ByteBuffer as first parameter.,"(""Read"", ""The `read` method uses `ByteBuffer` as its first parameter, indicating a functional relationship where the `ByteBuffer` class acts as an input to the `read` method."", ""ByteBuffer"")"
"The read() method return immediately, even if the read operation has not finished.",NULL
You can check the when the read operation is finished by calling the isDone() method of the Future instance returned by the read() method.,"(""isDone"", ""The isDone method is called on the Future instance that is returned by the read method"", ""read"")"
Here is a longer example showing how to use this version of the read() method:,"(""Read"", ""Method"")"
"This example creates an AsynchronousFileChannel and then creates a ByteBuffer which is passed to the read() method as parameter, along with a position of 0.",NULL
After calling read() the example loops until the isDone() method of the returned Future returns true.,"(""read"", ""The isDone method is invoked on the result of the read method, indicating a functional relationship."", ""isDone""); (""Future"", ""The isDone method is a member function expected to be called on the Future class, indicating an object-method relationship."", ""isDone"")"
Once the read operation has completed the data read into the ByteBuffer and then into a String and printed to System.out .,"(""ByteBuffer"", ""The ByteBuffer class is used to read data into and then transfer it into a String."", ""String""); (""String"", ""The data is printed to the destination specified by the System.out package."", ""System.out""); (""ByteBuffer"", ""The ByteBuffer class is used to read data into and then transfer it into a String."", ""String""); (""String"", ""The data is printed to the destination specified by the System.out package."", ""System.out"")"
The second method of reading data from an AsynchronousFileChannel is to call the read() method version that takes a CompletionHandler as a parameter.,NULL
Once the read operation finishes the CompletionHandler's completed() method will be called.,"(""CompletionHandler"", ""The completed() method is called as part of the CompletionHandler class, indicating it belongs to or is used by the class in its operation."", ""completed"")"
"As parameters to the completed() method are passed an Integer telling how many bytes were read, and the ""attachment"" which was passed to the read() method.","(""Completed"", ""The 'completed' method uses the 'attachment' parameter, which was originally passed to the 'read' method."", ""Read""); (""Completed"", ""The 'completed' method receives an Integer parameter indicating how many bytes were read."", ""Integer"")"
"If the read operation fails, the failed() method of the CompletionHandler will get called instead.",NULL
Each way to write data call one of the write() methods of the AsynchronousFileChannel.,"(""Write"", ""The method 'write()' is used by the 'AsynchronousFileChannel' for data writing operations."", ""AsynchronousFileChannel"")"
If the file does not exist the write() method will throw a java.nio.file.NoSuchFileException .,NULL
The CompletionHandler's completed() method will get called when the write operation completes.,"(""CompletionHandler"", ""The 'completed' method belongs to the 'CompletionHandler' class and is invoked when the write operation completes."", ""completed""); (""CompletionHandler"", ""The 'completed' method belongs to the 'CompletionHandler' class and is invoked when the write operation completes."", ""completed"")"
"If the write fails for some reason, the failed() method will get called instead.",NULL
"Once you need to read the data, you need to switch the buffer from writing mode into reading mode using the flip() method call.","(""Flip"", ""Method"")"
You can do this in two ways: By calling clear() or by calling compact().,"(""Clear"", ""Both methods are alternative ways to perform a similar operation."", ""Compact""); (""Clear"", ""Both methods are alternative ways to perform a similar operation."", ""Compact"")"
The compact() method only clears the data which you have already read.,"(""COMPACT"", ""METHOD"")"
Here is an example that writes data into a Buffer via the put() method:,"(""Buffer"", ""The put() method is used to write data into a Buffer, signifying that put is a method that operates on instances of the Buffer class."", ""put"")"
"There are many other versions of the put() method, allowing you to write data into the Buffer in many different ways.","(""Put"", ""The `put()` method is used to write data into the Buffer, suggesting that the method operates on or interacts with the Buffer class."", ""Buffer""); (""Put"", ""The `put()` method is used to write data into the Buffer, suggesting that the method operates on or interacts with the Buffer class."", ""Buffer"")"
The flip() method switches a Buffer from writing mode to reading mode.,"(""Flip"", ""The method Flip operates on the Buffer class, switching its mode from writing to reading."", ""Buffer"")"
"Calling flip() sets the position back to 0, and sets the limit to where position just was.","(""Flip"", ""Method""); (""Flip"", ""Method"")"
Here is an example that reads data from a Buffer using the get() method:,NULL
"There are many other versions of the get() method, allowing you to read data from the Buffer in many different ways.",NULL
"The Buffer.rewind() sets the position back to 0, so you can reread all the data in the buffer.",NULL
"The limit remains untouched, thus still marking how many elements (bytes, chars etc.)",NULL
You can do so either by calling clear() or by calling compact().,"(""Clear"", ""Both are methods that can be called based on the text."", ""Compact""); (""Clear"", ""Both are methods that can be called based on the text."", ""Compact"")"
If you call clear() the position is set back to 0 and the limit to capacity.,NULL
"If there is any unread data in the Buffer when you call clear() that data will be ""forgotten"", meaning you no longer have any markers telling what data has been read, and what has not been read.",NULL
"If there is still unread data in the Buffer, and you want to read it later, but you need to do some writing first, call compact() instead of clear().","(""compact()"", ""The method compact() is used to manipulate the state of the Buffer class by making it ready for writing after reading."", ""Buffer""); (""clear()"", ""The method clear() is used to reset the Buffer class state, indicating its purpose in managing Buffer's operations."", ""Buffer"")"
compact() copies all unread data to the beginning of the Buffer.,NULL
"The limit property is still set to capacity, just like clear() does.","(""Limit"", ""The limit is set to capacity."", ""Capacity""); (""Clear"", ""The clear() method sets the limit."", ""Limit"")"
You can mark a given position in a Buffer by calling the Buffer.mark() method.,NULL
You can then later reset the position back to the marked position by calling the Buffer.reset() method.,"(""Buffer"", ""The method 'reset' is a function that acts on the class 'Buffer', indicating a class-method relationship."", ""reset"")"
It is possible to compare two buffers using equals() and compareTo().,"(""Equals"", ""Both methods can be used to perform comparisons between buffers."", ""CompareTo"")"
The FileChannel class has a transferTo() and a transferFrom() method which does this for you.,NULL
The FileChannel.transferFrom() method transfers data from a source channel into the FileChannel.,"(""FileChannel"", ""The method transferFrom() belongs to the FileChannel class."", ""transferFrom""); (""transferFrom"", ""The method transferFrom() operates on a target FileChannel instance."", ""FileChannel""); (""FileChannel"", ""The method transferFrom() belongs to the FileChannel class."", ""transferFrom""); (""transferFrom"", ""The method transferFrom() operates on a target FileChannel instance."", ""FileChannel"")"
The transferTo() method transfer from a FileChannel into some other channel.,NULL
The issue with SocketChannel is also present with the transferTo() method.,NULL
"You receive data from a DatagramChannel by calling its receive() method, like this:","(""DatagramChannel"", ""The receive method is called on the DatagramChannel class to receive data."", ""receive"")"
The receive() method will copy the content of a received packet of data into the given Buffer.,NULL
"You can send data via a DatagramChannel by calling its send() method, like this:",NULL
"When connected you can also use the read() and write() method, as if you were using a traditional channel.","(""Read"", ""The Read and Write methods are used together for operations on a channel, indicating a functional relationship."", ""Write""); (""Read"", ""The Read and Write methods are used together for operations on a channel, indicating a functional relationship."", ""Write"")"
The Java NIO FileChannel class is NIO's an alternative to reading files with the standard Java IO API.,"(""Java NIO"", ""FileChannel is a class within the Java NIO package."", ""FileChannel""); (""FileChannel"", ""FileChannel serves as an alternative to the standard Java IO API."", ""Java IO API"")"
To read data from a FileChannel you call one of the read() methods.,NULL
The int returned by the read() method tells how many bytes were written into the Buffer.,NULL
"Writing data to a FileChannel is done using the FileChannel.write() method, which takes a Buffer as parameter.",NULL
There is no guarantee of how many bytes the write() method writes to the FileChannel.,"(""Write"", ""The write() method is associated with the FileChannel class, indicating that it operates on, or is a method of, the FileChannel class."", ""FileChannel"")"
Therefore we repeat the write() call until the Buffer has no further bytes to write.,NULL
You can obtain the current position of the FileChannel object by calling the position() method.,NULL
The size() method of the FileChannel object returns the file size of the file the channel is connected to.,"(""Size()"", ""The size() method is associated with the FileChannel class as it provides functionality related to it"", ""FileChannel"")"
The FileChannel.force() method flushes all unwritten data from the channel to the disk.,"(""FileChannel"", ""The force() method is a function that belongs to the FileChannel class."", ""force"")"
"An operating system may cache data in memory for performance reasons, so you are not guaranteed that data written to the channel is actually written to disk, until you call the force() method.","(""Force()"", ""The force() method ensures that data written to a channel is actually written to disk."", ""Disk"")"
"The force() method takes a boolean as parameter, telling whether the file meta data (permission etc.)","(""Force"", ""Method"")"
The Java NIO Files class (java.nio.file.Files) provides several methods for manipulating files in the file system.,"(""Files"", ""The Files class belongs to the java.nio.file package."", ""java.nio.file.Files""); (""Files"", ""The Files class provides several methods for manipulating files in the file system."", ""methods"")"
"The Files class contains many methods, so check the JavaDoc too, if you need a method that is not described here.","(""Files"", ""The Files class contains many methods."", ""methods""); (""JavaDoc"", ""JavaDoc likely contains documentation for the methods."", ""methods"")"
The Files class just might have a method for it still.,"(""Files"", ""The method is associated with the Files class, suggesting it belongs to or is defined within or by the class."", ""method"")"
"The java.nio.file.Files class works with java.nio.file.Path instances, so you need to understand the Path class before you can work with the Files class.","(""Files"", ""The Files class works with instances of the Path class, indicating a functional relationship between them."", ""Path""); (""Files"", ""The Files class is part of the java.nio.file package, showing a hierarchical relationship."", ""java.nio.file""); (""Path"", ""The Path class is part of the java.nio.file package, showing a hierarchical relationship."", ""java.nio.file"")"
The Files.exists() method checks if a given Path exists in the file system.,"(""Files"", ""The 'exists' method is a member of the 'Files' class."", ""exists""); (""exists"", ""The 'exists' method checks if a 'Path' exists."", ""Path"")"
"Since Path instances may or may not point to paths that exist in the file system, you can use the Files.exists() method to determine if they do (in case you need to check that).","(""Files"", ""The method 'exists' belongs to the 'Files' class."", ""exists""); (""Path"", ""Instances of the 'Path' class can be used with the 'Files' class method 'exists' to check if the path exists in the file system."", ""Files"")"
"Second, the example calls the Files.exists() method with the Path instance as the first parameter.",NULL
This parameter is an array of options that influence how the Files.exists() determines if the path exists or not.,"(""Files.exists()"", ""The parameter influences how the Files.exists() method determines if the path exists."", ""parameter"")"
In this example above the array contains the LinkOption.NOFOLLOW_LINKS which means that the Files.exists() method should not follow symbolic links in the file system to determine if the path exists.,NULL
The Files.createDirectory() method creates a new directory from a Path instance.,"(""Files"", ""The createDirectory method is a function of the Files class."", ""createDirectory""); (""createDirectory"", ""The createDirectory method operates on a Path instance to create a directory."", ""Path""); (""Files"", ""The createDirectory method is a function of the Files class."", ""createDirectory""); (""createDirectory"", ""The createDirectory method operates on a Path instance to create a directory."", ""Path"")"
Inside the try-catch block the Files.createDirectory() method is called with the path as parameter.,"(""Files.createDirectory()"", ""The Files.createDirectory() method takes the path as a parameter as part of its invocation."", ""Path"")"
The Files.copy() method copies a file from one path to another.,NULL
"Then the example calls Files.copy(), passing the two Path instances as parameters.","(""Files"", ""The method 'copy' is called on the 'Files' class."", ""copy""); (""copy"", ""The 'copy' method takes 'Path' instances as parameters."", ""Path"")"
It is possible to force the Files.copy() to overwrite an existing file.,"(""Files"", ""The method copy() is associated with the class Files, as indicated by the notation Files.copy()."", ""copy"")"
Here an example showing how to overwrite an existing file using Files.copy():,"(""Files.copy()"", ""method"")"
This parameter instructs the copy() method to overwrite an existing file if the destination file already exists.,NULL
The Java NIO Files class also contains a function for moving files from one path to another.,"(""Files"", ""The Files class contains this function, indicating that the function is part of or related to the Files class."", ""function"")"
"Yes, the java.io.File class could also do that with its renameTo() method, but now you have the file move functionality in the java.nio.file.Files class too.","(""Java.io.File"", ""The RenameTo method is a member of the Java.io.File class, indicating a function it can perform."", ""RenameTo""); (""Java.nio.file.Files"", ""Both Java.nio.file.Files and Java.io.File are classes mentioned in the context of file manipulation, suggesting they serve similar functions in different Java packages."", ""Java.io.File"")"
This parameter tells the Files.move() method to overwrite any existing file at the destination path.,"(""Files.move()"", ""The Files.move() method is related to the file class as it is used to move or manage files."", ""file"")"
The Files.move() method may throw an IOException if moving the file fails.,"(""Files.move()"", ""Files.move() may throw an IOException if moving the file fails"", ""IOException"")"
"For instance, if a file already exists at the destination path, and you have left out the StandardCopyOption.REPLACE_EXISTING option, or if the file to move does not exist etc.","(""StandardCopyOption"", ""REPLACE_EXISTING is an option associated with the class StandardCopyOption, indicating a usage relationship where StandardCopyOption defines or contains REPLACE_EXISTING as an option for file operations."", ""REPLACE_EXISTING"")"
If the Files.delete() fails to delete the file for some reason (e.g.,NULL
The Files.walkFileTree() method contains functionality for traversing a directory tree recursively.,"(""Files.walkFileTree"", ""The Files.walkFileTree() method is a part of the Files class, indicating it is a method that belongs to this class."", ""Files"")"
The walkFileTree() method takes a Path instance and a FileVisitor as parameters.,NULL
"You have to implement the FileVisitor interface yourself, and pass an instance of your implementation to the walkFileTree() method.","(""FileVisitor"", ""The FileVisitor class provides an implementation that is passed as an instance to the walkFileTree method, establishing a functional relationship between the two."", ""walkFileTree"")"
"If you do not need to hook into all of these methods, you can extend the SimpleFileVisitor class, which contains default implementations of all methods in the FileVisitor interface.","(""SimpleFileVisitor"", ""SimpleFileVisitor extends FileVisitor by providing default implementations of its methods"", ""FileVisitor"")"
The visitFile() mehtod is called for every file visited during the file walk.,"(""Visitfile"", ""The description indicates that 'visitFile()' is being called, which is a function characteristic."", ""Visitfile"")"
The visitFileFailed() method is called in case visiting a file fails.,"(""Visitfilefailed"", ""The method is specifically invoked when an attempt to visit a file fails."", ""File"")"
Here is a walkFileTree() that extends SimpleFileVisitor to look for a file named README.txt :,"(""walkFileTree"", ""The method walkFileTree utilizes or relies on the class SimpleFileVisitor for functionality."", ""SimpleFileVisitor""); (""walkFileTree"", ""The method walkFileTree utilizes or relies on the class SimpleFileVisitor for functionality."", ""SimpleFileVisitor"")"
The Files.walkFileTree() can also be used to delete a directory with all files and subdirectories inside it.,NULL
The Files.delete() method will only delete a directory if it is empty.,"(""Files"", ""The delete method is associated with the Files class"", ""delete"")"
"By walking through all directories and deleting all files (inside visitFile()) in each directory, and afterwards delete the directory itself (inside postVisitDirectory()) you can delete a directory with all subdirectories and files.","(""VISITFILE"", ""Both methods are involved in the process of deleting directories and files recursively."", ""POSTVISITDIRECTORY"")"
"The java.nio.file.Files class contains many other useful functions, like functions for creating symbolic links, determining the file size, setting file permissions etc.",NULL
Check out the JavaDoc for the java.nio.file.Files class for more information about these methods.,NULL
And that is before the server has used any memory for processing the incoming messages (e.g.,NULL
"To keep the number of threads down, many servers use a design where the server keeps a pool of threads (e.g.",NULL
When you call select() or selectNow() on the Selector it gives you only the SelectableChannel instances that actually has data to read.,"(""SELECT"", ""The method 'SELECT' is called on the 'SELECTOR' class."", ""SELECTOR""); (""SELECTNOW"", ""The method 'SELECTNOW' is called on the 'SELECTOR' class."", ""SELECTOR""); (""SELECTOR"", ""The 'SELECTOR' provides 'SELECTABLECHANNEL' instances that have data to read."", ""SELECTABLECHANNEL"")"
"A data block could potentially contain a partial message (less than a message), a full message, or more than a message, for instance 1.5 or 2.5 messsages.",NULL
The first way to implement a resizable buffer is to start with a small buffer of e.g.,NULL
"If a message cannot fit into the 4KB buffer, a larger buffer of e.g.",NULL
For 1.000.000 concurrent connections that results in 1.000.000 x 4KB = 4GB which is possible in most servers today (2015).,NULL
Another workaround is to time out messages which have not been received within e.g.,NULL
The fact that TLV encodings makes memory management easier is one of the reasons why HTTP 1.1 is such a terrible protocol.,"(""TLV"", ""TLV encodings are used in the HTTP 1.1 protocol, which aids in memory management."", ""HTTP 1.1"")"
That is one of the problems they are trying to fix in HTTP 2.0 where data is transported in LTV encoded frames.,"(""HTTP 2.0"", ""class""); (""HTTP 2.0"", ""class"")"
This is also why we have designed our own network protocol for our VStack.co project that uses a TLV encoding.,NULL
Imagine if you have 1.000.000 connections which are mostly idle and all 1.000.000 connections were registered with the Selector.,NULL
"Then, when you call select() most of these Channel instances would be write-ready (they are mostly idle, remember?).","(""select()"", ""The method select() is called on Channel instances, indicating a relationship between the method and the Channel class."", ""Channel""); (""select()"", ""The method select() is called on Channel instances, indicating a relationship between the method and the Channel class."", ""Channel"")"
"Java NIO has more classes and components than these, but the Channel, Buffer and Selector forms the core of the API, in my opinion.",NULL
"The rest of the components, like Pipe and FileLock are merely utility classes to be used in conjunction with the three core components.","(""Pipe"", ""Both are utility classes meant to be used in conjunction with other core components"", ""FileLock"")"
"There are a few interesting interfaces accompanying these classes too, but I'll keep them out of this Java NIO overview for simplicity's sake.",NULL
"The Path interface is located in the java.nio.file package, so the fully qualified name of the Java Path interface is java.nio.file.Path.","(""Path"", ""The Path class is part of the java.nio.file package."", ""java.nio.file"")"
The java.nio.file.Path interface has nothing to do with the path environment variable.,NULL
"In many ways the java.nio.file.Path interface is similar to the java.io.File class, but there are some minor differences.","(""Path"", ""The Path interface is compared to the File class, indicating a relationship in terms of similar functionality with minor differences."", ""File"")"
"In many cases though, you can replace the use of the File class with use of the Path interface.","(""File"", ""The Path interface can replace the File class in certain cases"", ""Path""); (""File"", ""The Path interface can replace the File class in certain cases"", ""Path""); (""File"", ""The Path interface can replace the File class in certain cases"", ""Path"")"
In order to use a java.nio.file.Path instance you must create a Path instance.,NULL
You create a Path instance using a static method in the Paths class (java.nio.file.Paths) named Paths.get().,NULL
To use the Path interface and the Paths class we must first import them.,"(""Path"", ""Path is described alongside Paths as entities used together in context"", ""Paths"")"
It is the call to the Paths.get() method that creates the Path instance.,NULL
"The Paths.get() method is a factory method for Path instances, in other words.","(""Paths.get()"", ""The Paths.get() method is a factory method for creating Path instances, indicating direct usage to produce an instance of Path class."", ""Path"")"
Creating an absolute path is done by calling the Paths.get() factory method with the absolute file as parameter.,"(""Paths.get"", ""Paths.get is used to create an absolute path by being called with an absolute file as a parameter"", ""absolute path"")"
The Java NIO Path class can also be used to work with relative paths.,"(""Path"", ""The Path class belongs to the Java NIO package, indicating that it is part of the functionality provided for handling file system paths within the NIO package."", ""Java NIO"")"
The second example creates a Path instance which points to the path (file) d:\data\projects\a-project\myfile.txt .,NULL
If you use the .. code in the middle of a path string it will correspond to changing one directory up at that point in the path string.,NULL
The .. code after the a-project directory changes directory up the the parent directory projects and then the path references down into the another-project directory from there.,"(""A-Project"", ""The directories are related as navigation occurs from A-Project to Another-Project."", ""Another-Project""); (""A-Project"", ""The directories are related as navigation occurs from A-Project to Another-Project."", ""Another-Project"")"
and .. codes also work in combination with the two-string Paths.get() method.,NULL
Here are two Java Paths.get() examples showing simple examples of that:,"(""Paths.get()"", ""method"")"
There are more ways that the Java NIO Path class can be used to work with relative paths.,NULL
The Java Path method relativize() can create a new Path which represents the second Path relative to the first Path.,NULL
"For instance, with the path /data and /data/subdata/subsubdata/myfile.txt"", the second path can be expressed as /subdata/subsubdata/myfile.txt relative to the first path.",NULL
"If you add the relative path subdata/subsubdata/myfile.txt to the directory path /data, you get the full path /data/subdata/subsubdata/myfile.txt.","(""RELATIVE PATH"", ""The full path is constructed by adding the relative path to the directory path akin to a method execution."", ""FULL PATH"")"
If you you add the relative path ../../.. to the full file path /data/subdata/subsubdata/myfile.txt then you get /data,NULL
The normalize() method of the Path interface can normalize a path.,"(""Normalize"", ""The Normalize method belongs to the Path interface, indicating a relationship between the method and the class it is part of."", ""Path"")"
"and .. codes in the middle of the path string, and resolves what path the path string refers to.","(""Path"", ""Path and String are related as Path works with string representations of file paths."", ""String"")"
This Path example first creates a path string with a .. code in the middle.,"(""Path"", ""The class 'Path' is involved in a creation operation as indicated by the phrase 'first creates a path string'"", ""Creates"")"
"Then the example creates a Path instance from this path string, and prints that Path instance out (actually it prints Path.toString()).","(""Path"", ""The toString method is called on an instance of the Path class to get its string representation."", ""toString""); (""Path"", ""The toString method is called on an instance of the Path class to get its string representation."", ""toString"")"
"The example then calls normalize() on the created Path instance, which returns a new Path instance.",NULL
"As you can see, the normalized path does not contain the a-project\.. part, as this is redundant.",NULL
"You write to a SinkChannel by calling it's write() method, like this:","(""SinkChannel"", ""The write method is used to perform the writing operation on the SinkChannel class"", ""write"")"
To read from the source channel you call its read() method like this:,"(""Source Channel"", ""The read() method is used to obtain data from the source channel."", ""Read"")"
The int returned by the read() method tells how many bytes were read into the buffer.,"(""Read"", ""The method 'read' returns an 'int', indicating a functional relationship."", ""Int"")"
"Notice how the buffers are first inserted into an array, then the array passed as parameter to the channel.read() method.","(""Channel"", ""The 'read' method is associated with the 'Channel' class, suggesting that 'read' is a method belonging to or used with instances of 'Channel'."", ""Read""); (""Channel"", ""The 'read' method is associated with the 'Channel' class, suggesting that 'read' is a method belonging to or used with instances of 'Channel'."", ""Read"")"
The read() method then writes data from the channel in the sequence the buffers occur in the array.,"(""Read"", ""The read() method writes data from the channel, showing a functional link between the method and the class."", ""Channel""); (""Read"", ""The read() method processes data in the sequence the buffers occur, indicating a functional relationship."", ""Buffer"")"
"In other words, if you have a header and a body, and the header is fixed size (e.g.",NULL
"The array of buffers are passed into the write() method, which writes the content of the buffers in the sequence they are encountered in the array.","(""Buffers"", ""Buffers are passed as an argument to the Write() method to be written in sequence."", ""Write()"")"
"The Java NIO Selector is a component which can examine one or more Java NIO Channel instances, and determine which channels are ready for e.g.",NULL
"You create a Selector by calling the Selector.open() method, like this:",NULL
"As you saw in the previous section, when you register a Channel with a Selector the register() method returns a SelectionKey objects.","(""Channel"", ""Channel is registered with Selector using the register method."", ""Selector""); (""register"", ""register method returns a SelectionKey object when a Channel is registered with a Selector."", ""SelectionKey"")"
"You can also attach an object already while registering the Channel with the Selector, in the register() method.","(""register"", ""The register method is used when registering the Channel."", ""Channel""); (""Selector"", ""The Channel is registered with the Selector."", ""Channel"")"
Once you have register one or more channels with a Selector you can call one of the select() methods.,"(""Selector"", ""The select() method is a function that can be called on the Selector class."", ""select()""); (""Selector"", ""The select() method is a function that can be called on the Selector class."", ""select()"")"
"In other words, if you are interested in channels that are ready for reading, you will receive the channels that are ready for reading from the select() methods.",NULL
select() blocks until at least one channel is ready for the events you registered for.,"(""Select"", ""The Select method blocks until at least one Channel is ready for the events you registered for."", ""Channel"")"
select(long timeout) does the same as select() except it blocks for a maximum of timeout milliseconds (the parameter).,"(""select"", ""The method 'select' accepts 'timeout' as a parameter to limit the blocking duration."", ""timeout""); (""select"", ""The method 'select' accepts 'timeout' as a parameter to limit the blocking duration."", ""timeout"")"
The int returned by the select() methods tells how many channels are ready.,NULL
"That is, how many channels that became ready since last time you called select().","(""Select"", ""method""); (""Select"", ""method"")"
"If you call select() and it returns 1 because one channel has become ready, and you call select() one more time, and one more channel has become ready, it will return 1 again.","(""SELECT"", ""THE METHOD MAY BE CALLED MULTIPLE TIMES TO CHECK CHANNEL READINESS"", ""SELECT"")"
"If you have done nothing with the first channel that was ready, you now have 2 ready channels, but only one channel had become ready between each select() call.","(""Channel"", ""A channel becomes ready and can be selected using the select() method."", ""Select"")"
"Once you have called one of the select() methods and its return value has indicated that one or more channels are ready, you can access the ready channels via the ""selected key set"", by calling the selectors selectedKeys() method.","(""Select"", ""The select method is used to determine when channels are ready."", ""Channels""); (""SelectedKeys"", ""The selectedKeys method is used to access ready channels."", ""Channels""); (""Selectors"", ""The selectedKeys method is called from the selectors package."", ""SelectedKeys"")"
When you register a channel with a Selector the Channel.register() method returns a SelectionKey object.,NULL
It is these keys you can access via the selectedKeySet() method.,NULL
"The channel returned by the SelectionKey.channel() method should be cast to the channel you need to work with, e.g a ServerSocketChannel or SocketChannel etc.","(""SelectionKey"", ""The channel() method is a member of the SelectionKey class, providing its functionality."", ""channel""); (""channel"", ""The channel method can be cast to a ServerSocketChannel to enable interactions specific to that class."", ""ServerSocketChannel""); (""channel"", ""The channel method can be cast to a SocketChannel for specific operations related to that class."", ""SocketChannel"")"
"A thread that has called the select() method which is blocked, can be made to leave the select() method, even if no channels are yet ready.",NULL
This is done by having a different thread call the Selector.wakeup() method on the Selector which the first thread has called select() on.,"(""Selector"", ""The Selector class contains the wakeup method, which is used by a different thread to wake up the selector."", ""wakeup""); (""Selector"", ""The Selector class contains the select method that is used by a thread to wait for a selection event."", ""select""); (""wakeup"", ""The wakeup method influences the select method by waking up the thread that called select."", ""select"")"
"If a different thread calls wakeup() and no thread is currently blocked inside select(), the next thread that calls select() will ""wake up"" immediately.",NULL
When you are finished with the Selector you call its close() method.,NULL
Listening for incoming connections is done by calling the ServerSocketChannel.accept() method.,"(""ServerSocketChannel"", ""The accept method is a part of the ServerSocketChannel class, responsible for listening for incoming connections."", ""accept"")"
"When the accept() method returns, it returns a SocketChannel with an incoming connection.","(""Accept"", ""The Accept method returns a SocketChannel indicating a relationship where the method results in the creation or use of the class."", ""SocketChannel"")"
"Since you are typically not interested in listening just for a single connection, you call the accept() inside a while-loop.","(""Accept"", ""The accept() method is commonly used to wait for connections, indicating the use of a while-loop to listen for multiple connections."", ""Connection"")"
"In non-blocking mode the accept() method returns immediately, and may thus return null, if no incoming connection had arrived.","(""Accept"", ""The Accept method can return a Null value when there is no incoming connection in non-blocking mode."", ""Null"")"
You close a SocketChannel after use by calling the SocketChannel.close() method.,"(""SocketChannel"", ""The close method is called on a SocketChannel instance to close it after use."", ""close""); (""SocketChannel"", ""The SocketChannel.close() method specifically refers to a method associated with the SocketChannel class, indicating the operation to be performed on it."", ""SocketChannel.close()"")"
To read data from a SocketChannel you call one of the read() methods.,"(""SocketChannel"", ""The method read() is used to read data from the class SocketChannel."", ""read()"")"
The int returned by the read() method tells how many bytes were witten into the Buffer.,NULL
"Writing data to a SocketChannel is done using the SocketChannel.write() method, which takes a Buffer as parameter.","(""SocketChannel"", ""The write method is a function used to write data to a SocketChannel."", ""write""); (""write"", ""The write method takes a Buffer as a parameter."", ""Buffer"")"
There is no guarantee of how many bytes the write() method writes to the SocketChannel.,NULL
"When you do so, you can call connect(), read() and write() in asynchronous mode.","(""Connect"", ""These methods are mentioned together as part of asynchronous processing."", ""Read""); (""Connect"", ""These methods are mentioned together as part of asynchronous processing."", ""Write""); (""Read"", ""These methods are mentioned together as part of asynchronous processing."", ""Write"")"
"If the SocketChannel is in non-blocking mode, and you call connect(), the method may return before a connection is established.",NULL
"To determine whether the connection is established, you can call the finishConnect() method, like this:",NULL
In non-blocking mode the write() method may return without having written anything.,NULL
Therefore you need to call the write() method in a loop.,"(""Write"", ""Method"")"
In non-blocking mode the read() method may return without having read any data at all.,"(""READ"", ""The read() method operates without blocking under a non-blocking mode condition, which may result in reading no data."", ""NON-BLOCKING MODE"")"
"Also, parts of the NIO APIs are actually blocking - e.g.","(""NIO"", ""The NIO is a package offering non-blocking I/O operations, and APIs are part of the collection of methods and classes it provides."", ""APIs""); (""NIO"", ""The NIO is a package offering non-blocking I/O operations, and APIs are part of the collection of methods and classes it provides."", ""APIs"")"
"A selector is an object that can monitor multiple channels for events (like: connection opened, data arrived etc.).",NULL
"That means, that when a thread invokes a read() or write(), that thread is blocked until there is some data to read, or the data is fully written.","(""Read()"", ""method""); (""Write()"", ""method"")"
Rather than just read the data byte for byte from e.g.,NULL
"In other words, once the first reader.readLine() method returns, you know for sure that a full line of text has been read.","(""Reader"", ""The method 'Readline' is performed by the 'Reader' to read a line of text."", ""Readline"")"
"The readLine() blocks until a full line is read, that's why.","(""readLine"", ""method""); (""readLine"", ""method"")"
"Similarly, when the second readLine() call returns, you know that this line contains the age etc.",NULL
"The bufferFull() method has to keep track of how much data is read into the buffer, and return either true or false, depending on whether the buffer is full.","(""bufferFull"", ""The bufferFull method is responsible for tracking data in the buffer to determine if it is full."", ""buffer"")"
"The bufferFull() method scans through the buffer, but must leave the buffer in the same state as before the bufferFull() method was called.","(""BufferFull"", ""The 'bufferFull' method operates on the 'Buffer' class, checking its state."", ""Buffer"")"
"Similarly, if you need to keep a lot of open connections to other computers, e.g.",NULL
"If you have fewer connections with very high bandwidth, sending a lot of data at a time, perhaps a classic IO server implementation might be the best fit.","(""IO Server"", ""class"")"
Using Java Reflection you can access the annotations attached to Java classes at runtime.,NULL
"You can also specify METHOD or FIELD, or you can leave the target out alltogether so the annotation can be used for both classes, methods and fields.","(""Class"", ""Classes contain methods as members or components."", ""Method""); (""Class"", ""Classes can contain fields as they represent attributes or properties of the class."", ""Field""); (""Method"", ""Methods can access fields as they may manipulate or retrieve data from them."", ""Field""); (""Class"", ""Classes contain methods as members or components."", ""Method""); (""Class"", ""Classes can contain fields as they represent attributes or properties of the class."", ""Field""); (""Method"", ""Methods can access fields as they may manipulate or retrieve data from them."", ""Field"")"
"You can access the annotations of a class, method or field at runtime.","(""Class"", ""Annotations can be accessed at runtime for both classes and methods."", ""Method""); (""Class"", ""Annotations can be accessed at runtime for both classes and fields."", ""Field""); (""Method"", ""Annotations can be accessed at runtime for both methods and fields."", ""Field"")"
"Notice how the Method.getParameterAnnotations() method returns a two-dimensional Annotation array, containing an array of annotations for each method parameter.","(""METHOD.GETPARAMETERANNOTATIONS()"", ""Method.getParameterAnnotations() returns an Annotation array for each method parameter"", ""ANNOTATION"")"
This text will discuss how to both create arrays and get their class objects via Java Reflection.,"(""Arrays"", ""Arrays can be used to create class objects via Java Reflection"", ""Class"")"
Working with arrays via Java Reflection is done using the java.lang.reflect.Array class.,"(""java.lang.reflect"", ""The Array class is part of the java.lang.reflect package, which provides classes for working with Java reflection, including handling arrays."", ""Array"")"
"Do not confuse this class with the java.util.Arrays class in the Java Collections suite, which contains utility methods for sorting arrays, converting them to collections etc.","(""Java.util.Arrays"", ""The Java.util.Arrays class is part of the Java Collections package."", ""Java Collections""); (""Java.util.Arrays"", ""The Java.util.Arrays class contains utility methods."", ""Methods"")"
Creating arrays via Java Reflection is done using the java.lang.reflect.Array class.,NULL
The first parameter int.class given to the Array.newInstance() method tells what type each element in the array should be of.,"(""Array"", ""The 'newInstance' method belongs to the 'Array' class"", ""newInstance""); (""Array"", ""The 'newInstance' method belongs to the 'Array' class"", ""newInstance"")"
"For instance, you can access the primitive int array class object like this:","(""Int Array"", ""The text explicitly mentions accessing the class object of the primitive type int array."", ""Class"")"
The [ on the left means it is the class of an int array I am interested in.,NULL
"Notice the [L to the left of the class name, and the ; to the right.","(""Class"", ""class"")"
"As a side note, you cannot obtain the class object of primitives using Class.forName().","(""Class"", ""The method `forName` is associated with the `Class` entity as it is part of the functionality related to obtaining class objects."", ""forName"")"
I usually do something like this to obtain the class name for primitives as well as objects:,NULL
"The solution, or workaround as you might call it, is to create an empty array of the desired type and obtain the class object from that empty array.",NULL
"This presents a single, uniform method to access the array class of arrays of any type.","(""Method"", ""The method provides access to the array class, indicating a functional relationship."", ""Array Class"")"
"To make sure that the Class object really is an array, you can call the Class.isArray() method to check:",NULL
Once you have obtained the Class object for an array you can access its component type via the Class.getComponentType() method.,NULL
"For instance, the component type of an int[] array is the int.class Class object.","(""INT[]"", ""INT[] is an array, which means it is comprised of elements of type INT, suggesting a component relationship."", ""INT"")"
The component type of a String[] array is the java.lang.String Class object.,"(""String[]"", ""The component type of the String[] array is the java.lang.String class object."", ""java.lang.String"")"
"This example will print out the text ""java.lang.String"" which is the component type of the String array.",NULL
Inspecting classes is often the first thing you do when using Reflection.,"(""Classes"", ""The text indicates that inspecting classes is an important part of using Reflection."", ""Reflection"")"
For a full list you should consult the JavaDoc for java.lang.Class.,NULL
Before you can do any inspection on a class you need to obtain its java.lang.Class object.,NULL
"All types in Java including the primitive types (int, long, float etc.)",NULL
If you know the name of the class at compile time you can obtain a Class object like this:,NULL
"If you don't know the name at compile time, but have the class name as a string at runtime, you can do like this:","(""Class"", ""class""); (""Class"", ""class"")"
String className = ... //obtain class name as string at runtime Class class = Class.forName(className);,"(""String"", ""className is a variable of type String"", ""className""); (""className"", ""Class is obtained using className"", ""Class"")"
When using the Class.forName() method you must supply the fully qualified class name.,NULL
The Class.forName() method may throw a ClassNotFoundException if the class cannot be found on the classpath at runtime.,NULL
The fully qualified class name (including package name) is obtained using the getName() method like this:,NULL
"If you want the class name without the pacakge name you can obtain it using the getSimpleName() method, like this:","(""Class"", ""The method getSimpleName() is used to obtain the name of the class without its package name."", ""getSimpleName""); (""Class"", ""The method getSimpleName() is used to obtain the name of the class without its package name."", ""getSimpleName"")"
You can access the modifiers of a class via the Class object.,"(""Class"", ""The Class object is an instance representing the class, indicating a direct representation or association between the two."", ""Class object"")"
You can check the modifiers using these methods in the class java.lang.reflect.Modifier:,"(""java.lang.reflect"", ""The class Modifier is part of the package java.lang.reflect."", ""Modifier""); (""Modifier"", ""The methods are used within the class Modifier to check the modifiers."", ""methods"")"
You can also access information specified for this package in the Manifest file of the JAR file this package is located in on the classpath.,NULL
From the Class object you can access the superclass of the class.,NULL
"The superclass class object is a Class object like any other, so you can continue doing class reflection on that too.","(""Class"", ""The text indicates that a Class object is both a type of class and also an object, suggesting it can undergo reflection."", ""Class"")"
It is possible to get a list of the interfaces implemented by a given class.,NULL
NOTE: Only the interfaces specifically declared implemented by a given class is returned.,"(""Class"", ""The text specifies that the interfaces are implemented by the class."", ""Interfaces"")"
"If a superclass of the class implements an interface, but the class doesn't specifically state that it also implements that interface, that interface will not be returned in the array.","(""CLASS"", ""A class can implement an interface."", ""INTERFACE""); (""INTERFACE"", ""Interfaces are not included in the array if not explicitly implemented by the class."", ""ARRAY"")"
"Even if the class in practice implements that interface, because the superclass does.",NULL
To get a complete list of the interfaces implemented by a given class you will have to consult both the class and its superclasses recursively.,NULL
You can access the fields (member variables) of a class like this:,NULL
You can access the class annotations of a class like this:,"(""Class"", ""Class annotations are properties or metadata that can be accessed on a class."", ""Class Annotations""); (""Class"", ""Class annotations are properties or metadata that can be accessed on a class."", ""Class Annotations"")"
Using Java Reflection you can inspect the constructors of classes and instantiate objects at runtime.,"(""Java Reflection"", ""Java Reflection can be used to inspect constructors, which are methods."", ""constructors""); (""Java Reflection"", ""Java Reflection allows the inspection and instantiation of class objects at runtime."", ""classes"")"
The Constructor[] array will have one Constructor instance for each public constructor declared in the class.,"(""Constructor"", ""Constructor is a method belonging to or declared within the Class."", ""Class""); (""Constructor"", ""Constructor is a method belonging to or declared within the Class"", ""Class"")"
This example returns the public constructor of the given class which takes a String as parameter:,"(""Constructor"", ""The constructor is a feature of the class, used to initialize instances of that class."", ""Class"")"
"If no constructor matches the given constructor arguments, in this case String.class, a NoSuchMethodException is thrown.",NULL
"The Constructor.newInstance() method takes an optional amount of parameters, but you must supply exactly one parameter per argument in the constructor you are invoking.","(""Constructor"", ""The newInstance method is associated with the Constructor class as it is called upon to create a new instance using the constructor."", ""newInstance"")"
"It is possible to load and reload classes at runtime in Java, though it is not as straightforward as one might have hoped.",NULL
This text will explain when and how you can load and reload classes in Java.,"(""Class"", ""The class is loaded and may be part of a Java package."", ""Java"")"
"You can argue whether Java's dynamic class loading features are really part of Java Reflection, or a part of the core Java platform.","(""Java"", ""Java is a programming language that includes advanced features like Reflection which allow for dynamic class loading."", ""Reflection"")"
All classes in a Java application are loaded using some subclass of java.lang.ClassLoader.,"(""Class"", ""Classes in the application are loaded using some subclass of ClassLoader, indicating a functional relationship where a ClassLoader is responsible for loading classes."", ""ClassLoader""); (""ClassLoader"", ""ClassLoader is a part of the java.lang package, indicating a containment or inclusion relationship."", ""java.lang"")"
Loading classes dynamically must therefore also be done using a java.lang.ClassLoader subclass.,"(""ClassLoader"", ""ClassLoader is a type of class within the java.lang package, which is a standard namespace in Java."", ""java.lang"")"
"When a class is loaded, all classes it references are loaded too.","(""Class"", ""A class references other classes when it is loaded, indicating a relationship between them."", ""Class"")"
"This class loading pattern happens recursively, until all classes needed are loaded.",NULL
Unreferenced classes are not loaded until the time they are referenced.,NULL
"If a ClassLoader is asked to load a class, it will ask its parent class loader to load it.",NULL
"If the parent class loader can't find the class, the child class loader then tries to load it itself.","(""Parent Class Loader"", ""The child class loader follows the parent class loader to attempt loading the class if the parent fails"", ""Child Class Loader"")"
The steps a given class loader uses when loading classes are:,NULL
When you implement a class loader that is capable of reloading classes you will need to deviate a bit from this sequence.,"(""Class Loader"", ""class"")"
The classes to reload should not be requested loaded by the parent class loader.,"(""Classes"", ""The classes to reload should not be requested loaded by the parent class loader, implying a relationship of dependency or control between the classes and the parent class loader."", ""Parent Class Loader"")"
All you need to do is to obtain a ClassLoader and call its loadClass() method.,NULL
Java's builtin Class loaders always checks if a class is already loaded before loading it.,"(""Class"", ""Classes are checked if already loaded"", ""Check""); (""Class"", ""Classes are loaded if not already loaded"", ""Load"")"
Reloading the class is therefore not possible using Java's builtin class loaders.,"(""Class"", ""The class is being referenced in the context of Java, indicating that it is part of or used within the Java package or system."", ""Java"")"
To reload a class you will have to implement your own ClassLoader subclass.,"(""ClassLoader"", ""Subclass is a specific implementation or extension of ClassLoader"", ""Subclass""); (""ClassLoader"", ""ClassLoader is used to load a Class"", ""Class"")"
Even with a custom subclass of ClassLoader you have a challenge.,"(""ClassLoader"", ""A 'subclass' is related to 'ClassLoader' as it is described as a custom subclass, implying inheritance or extension of the ClassLoader functionality."", ""subclass"")"
"This method is final, and thus cannot be overridden in your ClassLoader subclass.",NULL
The resolve() method will not allow any given ClassLoader instance to link the same class twice.,"(""Resolve"", ""The Resolve method relates to the Classloader as it operates within its context."", ""Classloader""); (""Resolve"", ""The Resolve method involves the linking of classes, highlighting a direct interaction."", ""Class"")"
"Therefore, everytime you want to reload a class you must use a new instance of your ClassLoader subclass.",NULL
"This is not impossible, but necessary to know when designing for class reloading.",NULL
As stated earlier you cannot reload a class using a ClassLoader that has already loaded that class once.,"(""class"", ""A ClassLoader is used to load a class as mentioned."", ""ClassLoader"")"
Therefore you will have to reload the class using a different ClassLoader instance.,NULL
"Every class loaded in a Java application is identified by its fully qualified name (package name + class name), and the ClassLoader instance that loaded it.",NULL
"That means, that a class MyObject loaded by class loader A, is not the same class as the MyObject class loaded with class loader B.","(""MyObject"", ""The MyObject class is loaded by class loader A indicating that there is a 'loading' relationship between them"", ""class loader A""); (""MyObject"", ""The MyObject class is loaded by class loader B, indicating another 'loading' relationship"", ""class loader B"")"
"Notice how the MyObject class is referenced in the code, as the type of the object variable.",NULL
This causes the MyObject class to be loaded by the same class loader that loaded the class this code is residing in.,NULL
"If the myClassReloadingFactory object factory reloads the MyObject class using a different class loader than the class the above code resides in, you cannot cast the instance of the reloaded MyObject class to the MyObject type of the object variable.",NULL
"Since the two MyObject classes were loaded with different class loaders, the are regarded as different classes, even if they have the same fully qualified class name.","(""MyObject"", ""class""); (""MyObject"", ""class"")"
Trying to cast an object of the one class to a reference of the other will result in a ClassCastException.,NULL
"Either of these two methods will work if the type of the variable, the interface or superclass, is not reloaded when the implementing class or subclass is reloaded.",NULL
To make this work you will of course need to implement your class loader to let the interface or superclass be loaded by its parent.,"(""Class Loader"", ""The Class Loader is responsible for loading the Interface."", ""Interface""); (""Class Loader"", ""The Class Loader is responsible for loading the Superclass."", ""Superclass"")"
"When your class loader is asked to load the MyObject class, it will also be asked to load the MyObjectInterface class, or the MyObjectSuperclass class, since these are referenced from within the MyObject class.",NULL
Your class loader must delegate the loading of those classes to the same class loader that loaded the class containing the interface or superclass typed variables.,"(""Class Loader"", ""The class loader delegates loading which involves interfaces."", ""Interface""); (""Class Loader"", ""The class loader loads classes which include superclasses."", ""Superclass"")"
Notice how it delegates class loading to its parent except for the one class it is intended to be able to reload.,NULL
"If the loading of this class is delegated to the parent class loader, it cannot be reloaded later.","(""Class"", ""The loading of the Class is delegated to the Parent Class Loader, indicating a dependency or control relationship."", ""Parent Class Loader"")"
"Remember, a class can only be loaded once by the same ClassLoader instance.",NULL
It is not a production ready template for your own class loaders.,"(""Class Loaders"", ""class""); (""Class Loaders"", ""class"")"
"Your own class loaders should probably not be limited to a single class, but a collection of classes that you know you will need to reload.","(""Class"", ""A class is typically part of a collection of classes handled by class loaders"", ""Class loaders"")"
"In addition, you should probably not hardcode the class paths either.","(""Class Path"", ""class"")"
Here is the reflection.MyObject class that is loaded using the class loader.,NULL
Notice how it both extends a superclass and implements an interface.,NULL
The name of this class is why I refer to these dynamic interface implementations as dynamic proxies.,NULL
As mentioned earlier you must pass an InvocationHandler implementation to the Proxy.newProxyInstance() method.,"(""newProxyInstance"", ""The method newProxyInstance is associated with the Proxy class to create a dynamic proxy class instance."", ""Proxy"")"
The proxy parameter passed to the invoke() method is the dynamic proxy object implementing the interface.,"(""Invoke"", ""The proxy parameter is passed to the invoke() method indicating that the method operates with or on the proxy class."", ""Proxy"")"
The Method object passed into the invoke() method represents the method called on the interface the dynamic proxy implements.,NULL
"But now you can check via the mock if the DAO uses the connection properly, for instance if the connection.close() is called (or NOT called), if you expected that.",NULL
Thus the factory interface and your class could look something like this:,NULL
"When the MyAction class calls methods on the IMyFactory instance injected into its constructor by the container, the method calls are translated into calls to the IContainer.instance() method, which is the method you use to obtain instances from the container.",NULL
Using Java Reflection you can inspect the fields (member variables) of classes and get / set them at runtime.,"(""Java Reflection"", ""Java Reflection can be used to inspect the fields of classes."", ""fields""); (""Java Reflection"", ""Java Reflection can be used to get/set member variables at runtime."", ""member variables"")"
The Field[] array will have one Field instance for each public field declared in the class.,NULL
"If no field exists with the name given as parameter to the getField() method, a NoSuchFieldException is thrown.","(""GetField"", ""The GetField method can throw a NoSuchFieldException if no field exists with the specified name."", ""NoSuchFieldException"")"
"Once you have obtained a Field instance, you can get its field name using the Field.getName() method, like this:",NULL
"Once you have obtained a Field reference you can get and set its values using the Field.get() and Field.set()methods, like this:","(""Field"", ""The method Field.get() is used to obtain values from a Field class."", ""Field.get()""); (""Field"", ""The method Field.set() is used to set values in a Field class."", ""Field.set()""); (""Field"", ""The method Field.get() is used to obtain values from a Field class."", ""Field.get()""); (""Field"", ""The method Field.set() is used to set values in a Field class."", ""Field.set()"")"
The objectInstance parameter passed to the get and set method should be an instance of the class that owns the field.,NULL
"In the above example an instance of MyObject is used, because the someField is an instance member of the MyObject class.","(""MyObject"", ""someField is an instance member of the MyObject class"", ""someField"")"
"It the field is a static field (public static ...) pass null as parameter to the get and set methods, instead of the objectInstance parameter passed above.",NULL
When you write a class or interface you can specify that it should be paramerizable.,NULL
"Rather than create a list of Object you can parameterize java.util.List to create a list of say String, like this:",NULL
"When inspecting a parameterizable type itself at runtime via reflection, like java.util.List, there is no way of knowing what type is has been parameterized to.","(""Reflection"", ""Reflection is used to inspect the class Java.Util.List at runtime."", ""Java.Util.List""); (""Java.Util.List"", ""Java.Util.List is inspected at runtime to determine its parameterization."", ""Runtime"")"
If you have obtained a java.lang.reflect.Method object it is possible to obtain information about its generic return type.,NULL
Here is an example class with a method having a parameterized return type:,NULL
In this class it is possible to obtain the generic return type of the getStringList() method.,"(""Class"", ""The GetStringList method is a part of the Class as it is mentioned as a method within the class."", ""GetStringList"")"
"In other words, it is possible to detect that getStringList() returns a List<String> and not just a List.","(""getStringList"", ""The method getStringList returns a List."", ""List""); (""List"", ""The List contains elements of type String."", ""String"")"
"This piece of code will print out the text ""typeArgClass = java.lang.String"".","(""Java.Lang.String"", ""class"")"
The Type[] array typeArguments array will contain one item - a Class instance representing the class java.lang.String.,NULL
Here is an example class with a method taking a parameterized List as parameter:,"(""ExampleClass"", ""The method is a member of the class"", ""ExampleMethod"")"
The Type[] array parameterArgTypes array will contain one item - a Class instance representing the class java.lang.String.,NULL
Fields are class member variables - either static or instance variables.,NULL
The Type[] array fieldArgTypes array will contain one item - a Class instance representing the class java.lang.String.,"(""Class"", ""The Class instance represents the class java.lang.String, indicating a direct relationship."", ""java.lang.String"")"
Using Java Reflection you can inspect the methods of classes and invoke them at runtime.,"(""classes"", ""Classes contain methods that can be inspected and invoked using reflection."", ""methods"")"
This can be used to detect what getters and setters a given class has.,"(""Class"", ""Getters are methods used by a class to access its attributes."", ""Getters""); (""Class"", ""Setters are methods used by a class to modify its attributes."", ""Setters"")"
"You cannot ask for getters and setters explicitly, so you will have to scan through all the methods of a class and check if each method is a getter or setter.","(""Class"", ""Methods are functions that belong to a class and operate on its data."", ""Methods"")"
Here is a code example that finds getter and setters of a class:,NULL
The Method[] array will have one Method instance for each public method declared in the class.,"(""METHOD"", ""The METHOD array is described to contain instances of METHOD objects."", ""METHOD""); (""METHOD"", ""METHODs are declared in the CLASS."", ""CLASS"")"
"This example returns the public method named ""doSomething"", in the given class which takes a String as parameter:","(""DoSomething"", ""The method DoSomething takes a String as a parameter"", ""String"")"
"If no method matches the given method name and arguments, in this case String.class, a NoSuchMethodException is thrown.","(""Method"", ""The String.class is used as an argument to identify the specific method."", ""String""); (""Method"", ""A NoSuchMethodException is thrown if a method does not match the provided criteria."", ""NoSuchMethodException"")"
"In this example, if doSomething(String.class) is not static, you need to supply a valid MyObject instance instead of null;",NULL
"The Method.invoke(Object target, Object ... parameters) method takes an optional amount of parameters, but you must supply exactly one parameter per argument in the method you are invoking.",NULL
This Java module reflection tutorial will explain how to access the Java Module a Java class belongs to via Java reflection.,NULL
"Thus, each Java class belongs to a package, and the package belongs to a module.",NULL
A Java module is represented by the Java reflection class java.lang.Module in the Java module java.base.,NULL
"Via this class you can interact with the Java Platform Module System to obtain information about a given module, or modify a module.",NULL
"You can obtain an instance of the Module class via a Class instance, like this:","(""Module"", ""The Module class is obtained via a Class instance, indicating a relationship where the Class instance is a source for creating a Module instance."", ""Class"")"
You can check if a Module instance a represents a named module by calling the Module isNamed() method.,"(""Module"", ""The method isNamed is called on instances of the class Module to check if it represents a named module."", ""isNamed""); (""Module"", ""The method isNamed is called on instances of the class Module to check if it represents a named module."", ""isNamed"")"
You can check if a Module is a named module via the Module isOpen() method.,"(""Module"", ""The method isOpen() is part of the Module class."", ""isOpen()""); (""Module"", ""The method isOpen() is part of the Module class."", ""isOpen()"")"
Once you have access to a Module instance you can access its ModuleDescriptor via the getDescriptor() method.,"(""Module"", ""The getDescriptor() method is used on the Module instance."", ""getDescriptor()""); (""getDescriptor()"", ""The getDescriptor() method returns the ModuleDescriptor."", ""ModuleDescriptor""); (""Module"", ""The getDescriptor() method is used on the Module instance."", ""getDescriptor()""); (""getDescriptor()"", ""The getDescriptor() method returns the ModuleDescriptor."", ""ModuleDescriptor"")"
Here is an example of accessing a Java Module's ModuleDescriptor via getDescriptor() :,NULL
You can get the name of a named module from its module descriptor via the ModuleDescriptor name() method.,"(""ModuleDescriptor"", ""The 'name' method is used to get the name of a module from a module descriptor, which is an instance of the 'ModuleDescriptor' class."", ""name"")"
"You can read the list of packages exported by a Java module via Java reflection, via the ModuleDescriptor exports() method.","(""ModuleDescriptor"", ""The Method `exports` belongs to the `ModuleDescriptor` class and is used to obtain the list of packages exported by a module."", ""exports""); (""Java"", ""The `ModuleDescriptor` class is utilized in the context of Java modules, indicating its association with the Java package."", ""ModuleDescriptor"")"
You can check if a Java module is an automatic module or not via the ModuleDescriptor isAutomatic() method.,"(""ModuleDescriptor"", ""The isAutomatic() method is a functionality provided by the ModuleDescriptor class to check if a module is automatic."", ""isAutomatic"")"
You can check if a Java module is an open module or not via the ModuleDescriptor isOpen() method.,"(""ModuleDescriptor"", ""The isOpen() method is part of the ModuleDescriptor class."", ""isOpen"")"
You can read the module service dependencies via the ModuleDescriptor uses() method.,"(""ModuleDescriptor"", ""The 'uses' method is invoked on the 'ModuleDescriptor' class to read the module service dependencies."", ""uses"")"
Despite the common belief it is actually possible to access private fields and methods of other classes via Java Reflection.,"(""Java Reflection"", ""package"")"
To access a private field you will need to call the Class.getDeclaredField(String name) or Class.getDeclaredFields() method.,"(""Class"", ""The method 'getDeclaredField' is related to the 'Class' as it is used to access fields of a class."", ""getDeclaredField""); (""Class"", ""The method 'getDeclaredFields' is related to the 'Class' as it is used to access all fields of a class."", ""getDeclaredFields"")"
"The methods Class.getField(String name) and Class.getFields() methods only return public fields, so they won't work.","(""Class"", ""Class is the class where the getField method is defined."", ""getField""); (""Class"", ""Class is the class where the getFields method is defined."", ""getFields"")"
"Here is a simple example of a class with a private field, and below that the code to access that field via Java Reflection:",NULL
"This method only returns fields declared in that particular class, not fields declared in any superclasses.","(""Method"", ""The method is described as returning fields declared in a particular class."", ""Class"")"
"By calling Field.setAcessible(true) you turn off the access checks for this particular Field instance, for reflection only.","(""Field"", ""The method setAcessible is called on the Field class to modify access checks during reflection."", ""setAcessible"")"
"To access a private method you will need to call the Class.getDeclaredMethod(String name, Class[] parameterTypes) or Class.getDeclaredMethods() method.",NULL
"The methods Class.getMethod(String name, Class[] parameterTypes) and Class.getMethods() methods only return public methods, so they won't work.","(""Class.getMethod"", ""Both are methods that operate on public methods within a class"", ""Class.getMethods"")"
"Here is a simple example of a class with a private method, and below that the code to access that method via Java Reflection:",NULL
"This code example will print out the text ""returnValue = The Private Value"", which is the value returned by the method getPrivateString() when invoked on the PrivateObject instance created at the beginning of the code sample.","(""getPrivateString"", ""The method 'getPrivateString' is invoked on the class 'PrivateObject', indicating a relationship where the method belongs to or is utilized by the class."", ""PrivateObject"")"
"This method only returns methods declared in that particular class, not methods declared in any superclasses.",NULL
"By calling Method.setAcessible(true) you turn off the access checks for this particular Method instance, for reflection only.","(""Method"", ""The setAcessible method is used to configure the accessibility of the Method class for reflection purposes."", ""setAcessible"")"
"Java Reflection makes it possible to inspect classes, interfaces, fields and methods at runtime, without knowing the names of the classes, methods etc.",NULL
"It will explain the basics of Java Reflection including how to work with arrays, annotations, generics and dynamic proxies, and do dynamic class loading and reloading.","(""Reflection"", ""Reflection is useful for creating and manipulating Dynamic Proxies dynamically at runtime."", ""Dynamic Proxies""); (""Reflection"", ""Reflection is essential for performing Dynamic Class Loading and Reloading operations."", ""Dynamic Class Loading and Reloading""); (""Reflection"", ""Reflection allows reading and using Annotations at runtime."", ""Annotations"")"
"It will also show you how to do more specific Java Reflection tasks, like reading all getter methods of a class, or accessing private fields and methods of a class.","(""Class"", ""Getter methods are functions typically defined within a class to access its fields."", ""Getter Methods""); (""Class"", ""Private fields are variables defined within a class that are not accessible directly from outside the class."", ""Private Fields"")"
This example obtains the Class object from the class called MyObject.,NULL
"Using the class object the example gets a list of the methods in that class, iterates the methods and print out their names.","(""Class"", ""The methods are part of the class, as they belong to and operate within it"", ""Methods"")"
When using Java reflection the starting point is often a Class object representing some Java class you want to inspect via reflection.,NULL
"For instance, to obtain the Class object for a class named MyObject you could write:","(""MyObject"", ""class"")"
Now you have a reference to the Class object for the MyObject class.,"(""MyObject"", ""class"")"
"Once you have a reference to the Class object representing some class, you can see what fields that class contains.",NULL
Here is an example of accessing fields of a Java class:,"(""Java class"", ""class"")"
Using Java Reflection it is possible find out what constructors a given Java class contains and what parameters they take etc.,NULL
You can also see what methods a given class has from its Class object.,NULL
Here is an example of accessing the methods a given class via Java reflection:,NULL
You can also use Java reflection to find out what getter and setter methods a class has.,NULL
You can even access private fields and methods via Java reflection - even from outside the class that owns the private field or method.,NULL
"In case a Java class has annotations which are available at runtime, you can access them via Java reflection too.",NULL
"For instance, you can determine what type of class the array is an array of.",NULL
"For instance, if you are introspecting a String array, you can detect that the element type is String by inspecting the array class.","(""String"", ""String is the element type of the array class"", ""array""); (""String"", ""String is the element type of the array class"", ""array"")"
"Java reflection has a special Proxy class that can implement a Java Interface dynamically at runtime, rather than at compile time.","(""Proxy"", ""Proxy is a class that can implement the Interface dynamically at runtime."", ""Interface"")"
In Java it is possible to dynamically load and also reload classes using a Java ClassLoader.,"(""ClassLoader"", ""ClassLoader is responsible for dynamically loading and reloading classes in Java."", ""Class"")"
"The ClassLoader class is actually not part of the Java Reflection API, but since Java Reflection is often used to achieve ""dynamic"" behaviour (behavioral changes at runtime), and dynamic class loading and reloading kind of fits into this theme, I have decided to include that tutorial in my Java Reflection tutorial.",NULL
Dynamic class loading and reloading is explained in my Java Reflection - Dynamic Class Loading and Reloading tutorial.,"(""Dynamic Class Loading"", ""Dynamic Class Loading is a process that involves reloading."", ""Reloading""); (""Dynamic Class Loading"", ""Dynamic Class Loading is explained in the Java Reflection package."", ""Java Reflection"")"
The Java regex API is located in the java.util.regex package which has been part of standard Java (JSE) since Java 1.4.,NULL
"Although Java regex has been part of standard Java since Java 1.4, this Java regex tutorial covers the Java regex API released with Java 8.","(""Java Regex"", ""Java Regex is a part of the Java package, indicating a hierarchical relationship between Java Regex and Java as its parent package."", ""Java"")"
But first I will introduce the core classes of the Java regex API in the following section.,NULL
The Matcher class is used to match a given regular expression (Pattern instance) against a text multiple times.,"(""Matcher"", ""The Matcher class uses instances of the Pattern class to perform matches."", ""Pattern"")"
Both the Pattern and Matcher classes are covered in detail in their own texts.,"(""Pattern"", ""The text indicates that both Pattern and Matcher are classes covered in detail together, implying they are related in functionality or usage."", ""Matcher"")"
The third line uses the Pattern.matches() static method to check if the regular expression (pattern) matches the text.,"(""Pattern"", ""matches() is a static method of the Pattern class"", ""matches()"")"
"If the regular expression matches the text, then Pattern.matches() returns true.",NULL
If the regular expression does not match the text Pattern.matches() returns false.,NULL
"The example does not actually check if the found http:// string is part of a valid URL, with domain name and suffix (.com, .net etc.).",NULL
"Here is another Java regex example which uses the Matcher class to locate multiple occurrences of the substring ""is"" inside a text:","(""Matcher"", ""The Matcher class is part of the Java regex package and is used to locate substrings within a text."", ""Java regex""); (""Matcher"", ""The Matcher class is part of the Java regex package and is used to locate substrings within a text."", ""Java regex"")"
The special metacharacter meaning of an escaped metacharacter is ignored - only its actual literal value (e.g.,NULL
Java regular expressions support matching any of a specified set of characters using what is referred to as character classes.,NULL
"The character class (set of characters to match) is enclosed in the square brackets - the [ae] part of the regular expression, in other words.",NULL
"The character class will match one of the enclosed characters regardless of which, but no mor than one.",NULL
"For instance, the character class [a-z] will match all characters between a lowercase a and a lowercase z, both a and z included.","(""Character class"", ""class"")"
You can have more than one character range within a character class.,"(""Character Class"", ""class"")"
"For instance, the character class [a-zA-Z] will match all letters between a and z or between A and Z .",NULL
"For instance, the character class [0-9] will match the characters between 0 and 9, both included.","(""Character"", ""The 'Character' class includes characters from the range '[0-9]'."", ""[0-9]"")"
"If you want to match the square brackets inside a character class, here is how that looks:",NULL
The character class contains the two square brackets escaped (\\[ and \\]).,NULL
You can match digits of a number with the predefined character class with the code \d.,"(""Character Class"", ""class"")"
Matching non-digits can be done with the predefined character class [\D] (uppercase D).,"(""D"", ""class""); (""D"", ""class"")"
You can match word characters with the predefined character class with the code \w .,"(""Character Class"", ""class"")"
You can match non-word characters with the predefined character class [\W] (uppercase W).,"(""[\W]"", ""The description 'uppercase W' refers to the predefined character class '\W', indicating they are related as the class and its description."", ""uppercase W"")"
Here is a regular expression example using the non-word character class:,NULL
The Java String class has a few regular expression methods too.,NULL
The Java String split() method splits the string into N substrings and returns a String array with these substrings.,NULL
The split() method takes a regular expression as parameter and splits the string at all positions in the string where the regular expression matches a part of the string.,NULL
The Java Matcher class (java.util.regex.Matcher) is used to search through a text for multiple occurrences of a regular expression.,"(""Matcher"", ""The Matcher class is part of the java.util.regex package, indicating a hierarchical relationship."", ""java.util.regex.Matcher"")"
I will cover the core methods of the Java Matcher class in this tutorial.,"(""Matcher"", ""The method is a part of the Matcher class in the Java API."", ""method"")"
"For a full list, see the official JavaDoc for the Matcher class.",NULL
Here is a quick Java Matcher example so you can get an idea of how the Matcher class works:,"(""Matcher"", ""class""); (""Matcher"", ""class""); (""Matcher"", ""class"")"
"The matches() returns true if the regular expression matches the text, and false if not.","(""Matches"", ""The 'matches' method operates on 'regular expression' to determine a match with the text."", ""Regular Expression""); (""Matches"", ""The 'matches' method returns a boolean result based on comparing the 'text' against the regular expression."", ""Text"")"
You can do a whole lot more with the Matcher class.,"(""Matcher"", ""class""); (""Matcher"", ""class"")"
The Pattern class is covered separately in my Java Regex Pattern tutorial.,"(""Pattern"", ""The Java Regex Pattern is the context in which the Pattern class is discussed."", ""Java Regex Pattern"")"
Creating a Matcher is done via the matcher() method in the Pattern class.,"(""matcher()"", ""The matcher() method is part of the Pattern class."", ""Pattern""); (""matcher()"", ""The matcher() method is used to create a Matcher."", ""Matcher"")"
"The matches() method in the Matcher class matches the regular expression against the whole text passed to the Pattern.matcher() method, when the Matcher was created.","(""Matches"", ""The matches method is a part of the Matcher class."", ""Matcher""); (""Matches"", ""The matches method interacts with the pattern.matcher method."", ""Pattern.matcher""); (""Matcher"", ""The matcher is created using the pattern.matcher method."", ""Pattern.matcher"")"
"If the regular expression matches the whole text, then the matches() method returns true.","(""Matches"", ""The matches method is explicitly mentioned in the text"", ""Method"")"
You cannot use the matches() method to search for multiple occurrences of a regular expression in a text.,"(""Matches"", ""method"")"
"For that, you need to use the find(), start() and end() methods.","(""Find"", ""Method""); (""Start"", ""Method""); (""End"", ""Method"")"
The Matcher lookingAt() method works like the matches() method with one major difference.,NULL
"The lookingAt() method only matches the regular expression against the beginning of the text, whereas matches() matches the regular expression against the whole text.","(""LookingAt"", ""Both methods are related as they deal with matching regular expressions against text, but with different scopes."", ""Matches"")"
"In other words, if the regular expression matches the beginning of a text but not the whole text, lookingAt() will return true, whereas matches() will return false.","(""lookingAt"", ""Both lookingAt() and matches() are methods that assess regular expressions but differ in their evaluation criteria—lookingAt() returns true if the pattern matches at the start, whereas matches() requires a complete match."", ""matches""); (""lookingAt"", ""Both lookingAt() and matches() are methods that assess regular expressions but differ in their evaluation criteria—lookingAt() returns true if the pattern matches at the start, whereas matches() requires a complete match."", ""matches"")"
Matching the regular expression against the beginning of the text (lookingAt()) will return true.,NULL
"Matching the regular expression against the whole text (matches()) will return false, because the text has more characters than the regular expression.",NULL
"The Matcher find() method searches for occurrences of the regular expressions in the text passed to the Pattern.matcher(text) method, when the Matcher was created.","(""Matcher"", ""The find() method is a function of the Matcher class."", ""find""); (""Pattern"", ""The matcher() method is a function of the Pattern class."", ""matcher""); (""find"", ""The find() method is used to execute the matcher() method for searching occurrences."", ""matcher"")"
"If multiple matches can be found in the text, the find() method will find the first, and then for each subsequent call to find() it will move to the next match.",NULL
The methods start() and end() will give the indexes into the text where the found match starts and ends.,NULL
Actually end() returns the index of the character just after the end of the matching section.,NULL
"Thus, you can use the return values of start() and end() inside a String.substring() call.",NULL
The Matcher reset() method resets the matching state internally in the Matcher.,NULL
"In case you have started matching occurrences in a string via the find() method, the Matcher will internally keep a state about how far it has searched through the input text.","(""Find"", ""The find() method is used by the Matcher class to search through input text by matching occurrences."", ""Matcher"")"
By calling reset() the matching will start from the beginning of the text again.,"(""reset"", ""method"")"
"Of course you could do this with the start() and end() methods, but it is easier to do so with the group functions.","(""START"", ""Both are methods used in pairs to perform some tasks"", ""END""); (""GROUP FUNCTIONS"", ""Group functions can be an alternative or related method to start"", ""START""); (""GROUP FUNCTIONS"", ""Group functions can be an alternative or related method to end"", ""END"")"
The Matcher replaceAll() and replaceFirst() methods can be used to replace parts of the string the Matcher is searching through.,NULL
"The Matcher appendReplacement() and appendTail() methods are used to replace string tokens in an input text, and append the resulting string to a StringBuffer.","(""MATCHER"", ""The appendReplacement method is part of the Matcher class."", ""APPENDREPLACEMENT""); (""MATCHER"", ""The appendTail method is part of the Matcher class."", ""APPENDTAIL""); (""APPENDREPLACEMENT"", ""The appendReplacement method uses StringBuffer to append the resulting string."", ""STRINGBUFFER""); (""APPENDTAIL"", ""The appendTail method uses StringBuffer to append the resulting string."", ""STRINGBUFFER"")"
"When you have found a match using the find() method, you can call the appendReplacement().","(""Find"", ""The appendReplacement method is used after finding a match with the find method."", ""AppendReplacement"")"
"The appendReplacement() method keeps track of what has been copied into the StringBuffer, so you can continue searching for matches using find() until no more matches are found in the input text.","(""AppendReplacement"", ""The AppendReplacement method interacts with the StringBuffer class to track what has been copied into it."", ""StringBuffer""); (""AppendReplacement"", ""The AppendReplacement method works in conjunction with the find method to search for matches in the input text."", ""Find"")"
By calling appendTail() you can append these last characters to the StringBuffer too.,"(""appendTail"", ""The method appendTail() is used to append characters to an instance of the StringBuffer class."", ""StringBuffer"")"
"Notice how appendReplacement() is called inside the while(matcher.find()) loop, and appendTail() is called just after the loop.","(""AppendReplacement"", ""AppendReplacement is a method that is called within the while loop that uses the Matcher class."", ""Matcher""); (""AppendTail"", ""AppendTail is a method that is used just after the loop involving the Matcher class, indicating it operates on results of a Matcher operation."", ""Matcher"")"
"The Java Pattern class (java.util.regex.Pattern), is the main access point of the Java regular expression API.","(""java.util.regex"", ""Pattern is a class within the java.util.regex package."", ""Pattern"")"
"Whenever you need to work with regular expressions in Java, you start with Java's Pattern class.","(""Pattern"", ""The Pattern class is part of the Java package, which provides access to regular expressions functionality."", ""Java"")"
A regular expression is also sometimes referred to as a pattern (hence the name of the Java Pattern class).,NULL
You can use the Pattern.matches() method to quickly check if a text (String) matches a given regular expression.,NULL
Or you can compile a Pattern instance using Pattern.compile() which can be used multiple times to match the regular expression against multiple texts.,"(""Pattern"", ""The Pattern.compile() method is associated with the Pattern class as it is used to compile a Pattern instance."", ""Pattern.compile()"")"
The easiest way to check if a regular expression pattern matches a text is to use the static Pattern.matches() method.,"(""Pattern.matches()"", ""The method Pattern.matches() belongs to the Pattern class, indicating a relationship."", ""Pattern"")"
"This Pattern.matches() example searches the string referenced by the text variable for an occurrence of the word ""is"", allowing zero or more characters to be present before and after the word (the two .","(""Pattern"", ""The 'matches' method is a part of the 'Pattern' class, as indicated by the syntax 'Pattern.matches()'"", ""matches"")"
"The Pattern.matches() method is fine if you just need to check a pattern against a text a single time, and the default settings of the Pattern class are appropriate.","(""Pattern"", ""The matches() method is described as a part of the Pattern class."", ""matches()"")"
"If you need to match for multiple occurrences, and even access the various matches, or just need non-default settings, you need to compile a Pattern instance using the Pattern.compile() method.",NULL
"If you need to match a text against a regular expression pattern more than one time, you need to create a Pattern instance using the Pattern.compile() method.","(""Pattern"", ""The Pattern.compile() method belongs to the Pattern class, indicating a relationship between the class and its method."", ""Pattern.compile()"")"
You can also use the Pattern.compile() method to compile a Pattern using special flags.,NULL
The Java Pattern class contains a list of flags (int constants) that you can use to make the Pattern matching behave in certain ways.,NULL
"For more information of the flags you can use with the Java Pattern class, see the JavaDoc for Pattern .","(""Java Pattern"", ""The Java Pattern class is a specific type of pattern class referenced in the text."", ""Pattern""); (""Pattern"", ""JavaDoc likely contains documentation for the Pattern class."", ""JavaDoc"")"
The Matcher class has a matches() method that tests whether the pattern matches the text.,"(""Matcher"", ""The matches() method belongs to the Matcher class, indicating a class-method relationship."", ""matches()"")"
"Too keep this text short, the Matcher covered in more detail in the text about the Java Matcher class.","(""Matcher"", ""The Matcher class is mentioned as part of the Java Matcher class"", ""Java Matcher"")"
"The split() method in the Pattern class can split a text into an array of String's, using the regular expression (the pattern) as delimiter.",NULL
This Pattern.split() example splits the text in the text variable into 5 separate strings.,NULL
Each of these strings are included in the String array returned by the split() method.,NULL
The pattern() method of the Pattern class simply returns the pattern string (regular expression) that the Pattern instance was compiled from.,NULL
Character classes are constructst that enable you to specify a match against multiple characters instead of just one.,"(""Character Classes"", ""Character classes can be part of a package that provides regex functionalities"", ""Package"")"
"In other words, a character class matches a single character in the input text against multiple allowed characters in the character class.","(""Character Class"", ""Class"")"
Character classes are nested inside a pair of square brackets [].,NULL
"The character class [Jj] will match either a J or a j, and the rest of the expression will match the characters ohn in that exact sequence.","(""Character Class"", ""Class""); (""Character Class"", ""Class"")"
The Java regular expression syntax has a few predefined character classes you can use.,NULL
"For instance, the \d character class matches any digit, the \s character class matches any white space character, and the \w character matches any word character.","(""D"", ""Both are character classes used for character matching"", ""S""); (""S"", ""Both are character classes used for character matching"", ""W""); (""D"", ""Both are character classes used for character matching"", ""W"")"
"The predefined character classes do not have to be enclosed in square brackets, but you can if you want to combine them.","(""Character Class"", ""The character class can optionally be enclosed in square brackets."", ""Square Brackets""); (""Character Class"", ""Character classes can be combined using methods like 'combine'."", ""Combine"")"
The predefined character classes are listed in a table later in this text.,"(""Character Class"", ""Class"")"
"The Java GZIPInputStream class (java.util.zip.GZIPInputStream) can be used to decompress files that are compressed with the GZIP compression algorithm, for instance via the GZIPOutputStream class.","(""GZIPInputStream"", ""GZIPInputStream is a class implemented in the java.util.zip package and its fully qualified name is java.util.zip.GZIPInputStream."", ""java.util.zip.GZIPInputStream""); (""GZIPInputStream"", ""GZIPInputStream can decompress files that are compressed using GZIPOutputStream, indicating they are related through the GZIP compression/decompression process."", ""GZIPOutputStream""); (""java.util.zip.GZIPInputStream"", ""java.util.zip.GZIPInputStream is a part of the java.util.zip package."", ""java.util.zip"")"
In the example above I passed it a FileInputStream connected to a file named myfile.zip.,NULL
When you are finished reading data from the GZIPInputStream you should close it using its close() method.,NULL
The Java GZIPOutputStream class (java.util.zip.GZIPOutStream) can be used to GZIP compress data and write it to an OutputStream.,"(""GZIPOutputStream"", ""The class GZIPOutputStream is implemented by GZIPOutStream as part of its functionality."", ""GZIPOutStream""); (""GZIPOutputStream"", ""The class GZIPOutputStream is part of the package java.util.zip."", ""java.util.zip"")"
This Java ZIP tutorial explains how the core classes of the Java ZIP API works.,"(""Java ZIP"", ""The core classes are part of the Java ZIP API, indicating a package-class relationship."", ""Core Classes""); (""Java ZIP"", ""The core classes are part of the Java ZIP API, indicating a package-class relationship."", ""Core Classes"")"
The Java ZipFile class is used to work with ZIP files containing multiple files.,"(""Java ZipFile"", ""class"")"
The Java GZIPInputStream and GZIPOutputStream classes are used to ZIP compress a single file.,NULL
The above classes will be covered in detail their own tutorials (see the side menu for links).,NULL
The Java ZipFile class (java.util.zip.ZipFile) can be used to read files from a ZIP file.,NULL
This tutorial will show you how to use the ZipFile class.,"(""ZipFile"", ""class"")"
In order to use the Java ZipFile class you must first create a ZipFile instance.,NULL
"As you can see, the ZipFile class takes a single parameter in its constructor.","(""ZipFile"", ""class"")"
Each file in the ZIP file is represented by a ZipEntry (java.util.zip.ZipEntry).,NULL
To extract a file from the ZIP file you can call the method getEntry() method on the ZipFile class.,"(""getEntry"", ""The method getEntry() is called on the ZipFile class."", ""ZipFile"")"
This example gets a ZipEntry representing the file file1.txt which is contained in the ZIP file.,"(""ZIPENTRY"", ""ZipEntry is used to represent the file file1.txt contained in a ZIP file"", ""file1.txt"")"
The InputStream obtained from the getInputStream() of the ZipFile class can be read like any other Java InputStream.,"(""getInputStream"", ""The method getInputStream() is associated with the ZipFile class, as it is a method provided by ZipFile to obtain an InputStream."", ""ZipFile""); (""InputStream"", ""The class InputStream is related to the method getInputStream() because the method returns an InputStream object."", ""getInputStream"")"
You can list all entries contained in a ZipFile using the entries() method.,"(""ZipFile"", ""The entries method is used to list all entries contained within a ZipFile class instance, indicating a functional relationship where the method operates on instances of the class."", ""entries"")"
You can iterate the Enumeration returned by the entries() method like this:,NULL
The Zip Slip attack consists of adding entries to a ZipFile that contains relative file paths with one or more /.. sections in the path.,"(""ZipFile"", ""class""); (""ZipFile"", ""class"")"
An entry in the ZipFile has the relative path ../../../../etc/hosts .,NULL
The final path of that entry becomes: /apps/myapp/data/unzipped-file/../../../../etc/hosts which is equivalent of /etc/hosts .,NULL
"Unzipping this file could potentially overwrite hour hosts file (on a Linux OS), enabling the attacker to point e.g.",NULL
"The Java examples in this tutorial were created with Java 8, and Acme4J Client v. 2.1 and Acme4J Utils v. 0.3.",NULL
Here is a Java class capable of creating a private key for use with Acme4J:,NULL
Here is a class that can create a Let's Encrypt account:,"(""Let's Encrypt Account"", ""Class""); (""Let's Encrypt Account"", ""Class"")"
It is the execute() method that starts the account creation process.,"(""Execute"", ""The execute() method initiates the account creation process."", ""Account Creation Process"")"
The fully qualified name for the Order class is org.shredzone.acme4j.Order .,"(""Order"", ""The Order class is part of the org.shredzone.acme4j package as indicated by its fully qualified name."", ""org.shredzone.acme4j"")"
Calling create() results in a request being sent to Let's Encrypt.,"(""Create"", ""The method create() sends a request to the class Let's Encrypt."", ""Let's Encrypt"")"
Once you have called the order.create() method a request is sent to Let's Encrypt.,NULL
"The above example specifically looks for an HTTP authorization object, which is then triggered by calling challenge.trigger().","(""CHALLENGE.TRIGGER()"", ""The method challenge.trigger() is utilized to initiate or activate the HTTP authorization object, implying a direct interaction or dependency."", ""HTTP AUTHORIZATION OBJECT"")"
"Before the challenge is triggered, you must read the value from challenge.getAuthorization() and upload it in a file to your web server.","(""Challenge"", ""The method getAuthorization is likely a member of or related to the Challenge class"", ""GetAuthorization""); (""Web Server"", ""The class Web Server interacts with the Challenge class by needing to handle the value from it"", ""Challenge"")"
"... where ${domain} is the domain for which you are requesting the domain for (returned by challenge.getDomain() ), and ${token} is the value returned by challenge.getToken().",NULL
"If your code cannot access your web server to upload the challenge file before calling challenge.trigger(), you can run the code in your debugger, set a breakpoint before calling challenge.trigger(), pause the code at that breakpoint, read the token (file name) and authorization (file content) out of the challenge object, upload that to your web server, and then continue the code in the debugger.","(""Challenge"", ""The method Trigger is a part of the Challenge class as indicated by challenge.trigger()"", ""Trigger""); (""Debugger"", ""The code involving the Trigger method can be executed in a Debugger"", ""Trigger"")"
That is what happens in the last part of the processAuth() method.,"(""processAuth"", ""method"")"
"First, the code above waits until the Order object has status Status.VALID.","(""Order"", ""The Order class has a status attribute of type Status."", ""Status""); (""Status"", ""The Status class seems to define or use VALID as a package or constant, indicating a valid status state."", ""VALID"")"
The value of that Ant property will be inserted at the place of the ${...} code.,"(""Ant"", ""The Ant package seems related to the value mentioned, possibly referring to a property within the Ant build system."", ""value"")"
This example first defines a property named dir.build which has its value set to build.,"(""Dir.build"", ""Property"")"
"Second, this example defines a property named dir.build.classes which has its value set to ${dir.build}/classes .","(""Dir.Build"", ""Dir.Build.Classes is part of the organizational structure of Dir.Build, following package and class naming conventions."", ""Dir.Build.Classes"")"
"When Ant defines this property it will resolve the value of the referenced property dir.build, and insert its value where the property is reference.",NULL
"Thus, the second Ant property defined will have its final value set to build/classes because build is the value of the dir.build property referenced.","(""Ant"", ""Ant is associated with build/classes as a package constructs or references classes."", ""build/classes""); (""build/classes"", ""build/classes directory is set with reference to the dir.build property, suggesting a setting or building relationship."", ""dir.build"")"
"The echo task as defined here will print out the message ""This is version 1.2.3"" to the console.","(""Echo"", ""Echo uses Console to output messages"", ""Console"")"
"Just to recap, a ""Java build tool"" is a tool which can compile Java code, run the unit tests for it, package the compiled classes into a JAR file and many, many other things.","(""Java Build Tool"", ""Java Build Tool can compile Java Code"", ""Java Code""); (""Java Build Tool"", ""Java Build Tool can run Unit Tests"", ""Unit Tests""); (""Java Build Tool"", ""Java Build Tool packages Compiled Classes into a JAR File"", ""Compiled Classes""); (""Compiled Classes"", ""Compiled Classes are packaged into a JAR File"", ""JAR File"")"
This Ant tutorial is based on Ant version 1.9.6 which is the newest version of Ant at the time of writing (august 2015).,"(""Ant"", ""Ant version 1.9.6 is a specific version within the Ant package."", ""Ant version 1.9.6"")"
"Inside the project directory you have just created, create an empty file named build.xml.",NULL
"By default Ant looks for a build script named build.xml in your project root directory, so you might as well call your Ant build script build.xml.","(""Ant"", ""The 'Ant' package executes the 'build script'."", ""build script""); (""build script"", ""The 'build script' is specifically named 'build.xml'."", ""build.xml"")"
"You could use another name, but using build.xml makes your Ant commands shorter, and it makes it easier for other developers to find the Ant build script.",NULL
Open the build.xml file and insert the following text (XML) into it:,NULL
You can test this build file by opening a command prompt and change directory into the directory that contains the build.xml file and execute this command:,NULL
"This test was performed using Java 5, Butterfly Container 1.9.11-beta, and Guice 1.0.","(""Butterfly Container 1.9.11-beta"", ""Butterfly Container is used within the Java 5 environment"", ""Java 5""); (""Guice 1.0"", ""Guice operates within the Java 5 environment"", ""Java 5""); (""Butterfly Container 1.9.11-beta"", ""Butterfly Container is used within the Java 5 environment"", ""Java 5""); (""Guice 1.0"", ""Guice operates within the Java 5 environment"", ""Java 5"")"
"The test performs 10.000.000 instantiations of a TestProduct class using a no-arg constructor, for each DI mechanism.",NULL
Java is a statically typed language meaning that types (primtives and classes) cannot change at runtime.,"(""Java"", ""class"")"
"It is not like you can all of a sudden let your Java class members, method parameters and variables be untyped.",NULL
"This is done at the beginning, by the method call BO.setDao(dao).","(""BO"", ""setDao is a method being called on the BO class."", ""setDao""); (""setDao"", ""dao is an argument passed to the setDao method."", ""dao""); (""BO"", ""setDao is a method being called on the BO class."", ""setDao""); (""setDao"", ""dao is an argument passed to the setDao method."", ""dao"")"
"But, notice how no DI is used inside the BO.checkPersonIsValid() or the DAO.readPerson() methods.",NULL
I most likely never have to change implementation of the Person class.,NULL
In Java this will result in a class cast exception at runtime (or some similar type error exception).,NULL
"Each factory definition states how a given instance is to be created and configured, when calling the container.instance() method.",NULL
"The input parameters .hashcode() and .equals() methods determine if an input parameter has an instance associated with it already, or a new one needs to be created and associated with the input parameter for succeeding calls.",NULL
As you can see the constructor call was chained with a call to the setValue() method.,"(""Constructor"", ""The constructor call was linked with a call to the setValue() method, indicating a function call relationship."", ""SetValue"")"
"Notice how the length() method is called on the ""value"" parameter.","(""Length"", ""Method""); (""Length"", ""Method"")"
"If the setValue() method in the example above returns void, the factory will return the SomeObject instance the method was called on.",NULL
The factory defined by this script will return a SomeObject instance that has had the two methods setValue() and setValue2() invoked on it.,"(""SomeObject"", ""The setValue() method is invoked on an instance of the SomeObject class."", ""setValue""); (""SomeObject"", ""The setValue2() method is invoked on an instance of the SomeObject class."", ""setValue2""); (""SomeObject"", ""The setValue() method is invoked on an instance of the SomeObject class."", ""setValue""); (""SomeObject"", ""The setValue2() method is invoked on an instance of the SomeObject class."", ""setValue2"")"
"Here is a list of classes and primitives that parameters can be converted to, automatically:",NULL
Sometimes a constructor or method call in a factory definition matches more than one constructor or method in the owning class.,"(""Constructor"", ""Constructors are functions specifically intended to initialize a new object of a Class."", ""Class""); (""Method"", ""Methods perform operations and define behaviors linked to their residing Class."", ""Class"")"
You can cast to any type or class available on the classpath.,"(""Class"", ""The text suggests that a 'class' available on the 'classpath' can be used or manipulated, indicating a dependency or availability relationship."", ""Classpath"")"
"To call a static method instead of a constructor when creating an instance of some class, simply write as you would in Java:",NULL
Note: The container uses java.util.ArrayList and java.util.HashSet as the List and Set implementations.,"(""Java.util.ArrayList"", ""Java.util.ArrayList is a class that implements the List interface."", ""List""); (""Java.util.HashSet"", ""Java.util.HashSet is a class that implements the Set interface."", ""Set"")"
From version 2.5.9 Butterfly Container Script provides a shortcut to configuring Map instances.,NULL
First an instance of SomeObject is created and then the setValue() method is called on it.,NULL
Below is an example that register the newly created instance with a static method in the MyClass class.,NULL
You can inject instances of classes created locally in a factory definition.,NULL
"Notice how the setNewValue() method is called on the instance obtained from the bean1 factory, before it is injected into OtherObject's constructor.","(""setNewValue"", ""The setNewValue() method is called on the instance obtained from the bean1 class."", ""bean1""); (""bean1"", ""The instance from the bean1 class is injected into the OtherObject class's constructor."", ""OtherObject"")"
"Thus, the setFurtherValue() method of the someObject singleton is called for each instance of bean2 created, even if the method call is redundant.","(""SetFurtherValue"", ""The method SetFurtherValue is part of the SomeObject class as it is invoked on its singleton instance."", ""SomeObject""); (""SetFurtherValue"", ""SetFurtherValue is called for each instance of Bean2, indicating a relationship between the method and the Bean2 class instances."", ""Bean2"")"
"Notice how the bean2 definition obtains an instance from the bean1 factory, and calls the setValue() method on it before returning it.",NULL
"Input parameters can be given to the container.instance() method, like this:","(""Container.Instance()"", ""method""); (""Container.Instance()"", ""method"")"
"The container cannot determine the type of input parameters until runtime, when the container.instance() method is called.","(""Container"", ""The method 'instance()' is called on the Container class."", ""Instance"")"
Therefore it is only possible to call methods that exists in java.lang.Object on input parameters.,NULL
"Your application will ask the container for an object, and the container will make sure that all dependencies (config parameters, collaborating objects, texts etc.)",NULL
"Rather than having to design integration mechanisms yourself, and decide on configuration formats etc., you can have the dependency injection container do all that for you.",NULL
"The ""connectionTimeout"" factory is defined as a singleton returning whatever value the CONNECTION_TIMEOUT constant is set to in the Constants class.",NULL
The simplest way to add a function is to create a static method in a Java class that performs the logic for the function.,"(""Static Method"", ""The static method is described as adding a function, indicating the static method serves as the function itself."", ""Function""); (""Static Method"", ""The static method is created within a Java class, indicating that the Java class contains the static method."", ""Java Class"")"
Sometimes you may need to create an instance of some class and call a method on that instance.,"(""Class"", ""A method is often called on an instance of a class, indicating they are related through object-oriented programming concepts."", ""Method"")"
The beanB factory will call the beanA factory with the parameter returned from the static default() method.,NULL
"If input parameter 0 passed to the beanB factory is null, then the default() method will return the default value ""default value"".","(""BeanB"", ""The method 'default' is part of or used by the class 'BeanB', as it is called within its context as a factory."", ""Default""); (""Default"", ""The method 'default' returns the 'default value' as specified in its operation description."", ""Default Value"")"
"If you need to call the default() method more than once you can simplify the script a bit by mapping the default method to a factory, and then call this factory whenever the function is needed.",NULL
"The default() method has been mapped to a factory called ""default"".","(""Default"", ""The 'default()' method is mapped to a factory called 'default', indicating a relationship between the method and the factory."", ""Default"")"
This default factory is then called from the beanB factory instead of calling the static default() method directly.,"(""BeanB"", ""The default factory is called from the BeanB factory."", ""Default"")"
"There is no package and class name to disturb you when reading the script, and whenever you need the default function all you need to write is ""default(a, b)"", instead of ""com.myapp.util.Util.default(a, b)"".","(""Default"", ""The 'default' method is defined within the 'Util' class."", ""Util""); (""Util"", ""The 'Util' class is part of the 'com.myapp.util' package."", ""Com.myapp.util""); (""Default"", ""The 'default' method is defined within the 'Util' class."", ""Util""); (""Util"", ""The 'Util' class is part of the 'com.myapp.util' package."", ""Com.myapp.util"")"
Defining the static max() method as a factory (and thereby a function) is done like this:,"(""Max"", ""Method""); (""Max"", ""Method"")"
"This little script defines the ""max"" factory as a call to the static max() method with input parameter 0 and 1 passed to the max() method.","(""Max"", ""The 'max' factory is defined as a call to the 'max' method."", ""Factory"")"
"The max factory will call the max() method and return the value that is largest of either the input parameter 0 passed to the beanA factory, or the hard coded value 1.",NULL
"This example uses the java.text.SimpleDateFormat class and defines its instance method parse() as a function called ""toDate"".","(""SimpleDateFormat"", ""The parse method is an instance method of the SimpleDateFormat class, indicating a functional relationship."", ""parse"")"
Second the toDate factory is defined as a call to the toDateFactory and then a call to the parse() method on the instance returned from the toDateFactory.,NULL
The toDate factory takes a single parameter which is the string to parse into a java.util.Date instance.,NULL
"It is possible to extend Butterfly Container Script (BCS) with custom instantiation modes, if the standard modes (new instance, singleton etc.)","(""Butterfly Container Script"", ""Butterfly Container Script can be extended with custom Instantiation Modes"", ""Instantiation Modes""); (""Instantiation Modes"", ""Instantiation Modes includes Standard Modes"", ""Standard Modes""); (""Standard Modes"", ""New Instance is a type of Standard Mode"", ""New Instance""); (""Standard Modes"", ""Singleton is a type of Standard Mode"", ""Singleton"")"
"By calling the set() method with the current request as parameter, the request is associated with the thread calling the set() method.",NULL
By calling the get() method the request object associated with the calling thread can be obtained.,NULL
"The ""request"" factory is defined as a call to the get() method on the product returned from the ""requestCache"" factory.",NULL
"In other words, as a call to the get() method on the HttpRequestCache singleton.",NULL
"The ""session"" factory is defined as a call to the getSession() method of the product returned by the ""request"" factory.",NULL
"In other words, as a call to the getSession() method on the request object obtained from the HttpRequestCache singleton, which is the request object associated with the calling thread.","(""Request"", ""The Request object is obtained from the HttpRequestCache singleton, indicating a source-target relationship where HttpRequestCache acts as a provider for the Request object."", ""HttpRequestCache""); (""GetSession"", ""getSession() is a method that is called on the Request object, indicating a functional relationship where GetSession is dependent on Request to operate."", ""Request"")"
In order to make the the request and session factories return the correct objects you must first call the HttpRequestCache's set() method.,"(""HttpRequestCache"", ""The 'set' method belongs to the 'HttpRequestCache' class and is called to configure the HttpRequestCache properly."", ""set""); (""HttpRequestCache"", ""The 'set' method belongs to the 'HttpRequestCache' class and is called to configure the HttpRequestCache properly."", ""set"")"
"Another disadvantage is that all instantiation modes (singleton, thread singleton, flyweight etc.)","(""Thread Singleton"", ""A Thread Singleton is a type of Singleton where each thread gets its own instance."", ""Singleton""); (""Flyweight"", ""Flyweight is a design pattern that can be used alongside Singleton to minimize memory usage by sharing instances."", ""Singleton"")"
"If you use an anonymous subclass of JavaFactory, inserted instead of ""new MyFactory()"", the JavaFactoryBuilder cannot access the ""otherFactory"" field, even if it is public.","(""JavaFactory"", ""Both entities are classes, and JavaFactoryBuilder seems to interact with instances of JavaFactory."", ""JavaFactoryBuilder""); (""JavaFactory"", ""MyFactory is mentioned as an intended replacement for JavaFactory, suggesting a connection."", ""MyFactory""); (""JavaFactoryBuilder"", ""JavaFactoryBuilder cannot access the otherFactory field, indicating a relationship between the two."", ""otherFactory"")"
"Inner classes will do just fine too, as long as they are declared ""public static"".","(""Inner Classes"", ""class"")"
"This method takes 3 parameters: The name of the factory, the return type of the factory, and a subclass of JavaFactory which implements the factory.",NULL
"The name is used when calling the container.instance(""name"") method to obtain an instance from the factory.","(""Container"", ""The class Container has a method called instance, which is used to obtain an Instance."", ""Instance""); (""Container"", ""The method instance belongs to the Container class."", ""Method"")"
JavaFactoryBuilder has a method that omits the return type and instead extracts that information from the return type of the JavaFactory subclass's instance method.,NULL
Notice how no return type is passed in the addFactory() call.,NULL
Also notice how the return type of the instance() method is now MyObject.,"(""instance()"", ""The instance() method has a return type of MyObject, indicating a direct association between the method and class."", ""MyObject"")"
By declaring a field of type IGlobalFactory in the JavaFactory subclass the JavaFactoryBuilder knows that the factory depends on another factory.,NULL
"You can add as many factories as you want, using the addFactory() method.","(""addFactory"", ""method""); (""addFactory"", ""method"")"
The ScriptFactoryBuilder has a addFactories() method that takes an InputStream as parameter instead of a String.,"(""ScriptFactoryBuilder"", ""The method 'addFactories()' is associated with the 'ScriptFactoryBuilder' class."", ""addFactories()"")"
"Using this method you can load a container script from disk, over a network, from the classpath and also from inside a Jar file.",NULL
"To configure the container using a script contained in a file located on the classpath (including inside a Jar file), you can do like this:","(""Classpath"", ""Classpath often contains resources and references like Jar files which are key components within it."", ""Jar File"")"
"The init() method creates all singletons, starts services and other stuff that need to be done before the instances in the container can be used.","(""Init"", ""The init method creates all singletons, indicating a relationship where Init is responsible for creating Singletons."", ""Singleton""); (""Init"", ""The init method starts services, showing a relationship where Init is responsible for starting Services."", ""Service"")"
The instance() method needs the name of the object factory to get an instance from.,NULL
You can put as many input parameters into the instance() call as you like.,"(""INSTANCE"", ""The INSTANCE method can take INPUT PARAMETERS as arguments when it is called."", ""INPUT PARAMETERS"")"
The input parameters are defined as an optional parameter (Object ... parameters).,"(""Object"", ""The method 'parameters' accepts an Object as an optional parameter, indicating a class-method relationship."", ""parameters"")"
"When the dispose() method is called, the dispose life cycle phase is executed for all factories in the container, before the method call returns.","(""Dispose"", ""The dispose method initiates the dispose life cycle phase."", ""Dispose Life Cycle Phase""); (""Dispose Life Cycle Phase"", ""The dispose life cycle phase is executed for all factories."", ""Factory""); (""Factory"", ""The factories are contained within a container."", ""Container"")"
A thread calling get() will only get the object it had set itself by calling set().,NULL
"Then the value obtained from the container.instance(""myThreadLocal"") call will be the value the calling thread associated with itself, by calling MyClass.threadLocal.set().","(""CONTAINER"", ""The method 'instance' is called on the class 'Container', indicating that 'instance' is a method of 'Container'"", ""INSTANCE""); (""MYCLASS"", ""The method 'threadLocal.set()' is part of 'MyClass', indicating a relationship between the class 'MyClass' and the method 'threadLocal'"", ""THREADLOCAL"")"
ThreadLocal's can be used to associate a java.util.Locale with the calling thread.,NULL
"Basically what you will do is call a ThreadLocal.set() method with the Locale to associate with the calling thread, before calling container.instance().",NULL
"Notice how the Locale is not obtained by the ThreadLocal.get() method, but via the static method getLocale().",NULL
"The getLocale() method functions as a cast from Object to its return value Locale, enabling the container to determine the type of the returned object (Locale).",NULL
"Notice how the HttpServletRequest and HttpServletResponse are not obtained by the ThreadLocal.get() method, but via the static methods getRequest() and getResponse().","(""HttpServletRequest"", ""The getRequest() method is used to obtain an instance of HttpServletRequest."", ""getRequest()""); (""HttpServletResponse"", ""The getResponse() method is used to obtain an instance of HttpServletResponse."", ""getResponse()"")"
"The getRequest() method functions as a cast from Object to its return value HttpServletRequest, enabling the container to determine the type of the returned object (HttpServletRequest).",NULL
"Instantiation time localization means that you inject localized dependencies (texts, paths, number and date formatters etc.)","(""Instantiation Time Localization"", ""Instantiation time localization involves injecting dependencies."", ""Dependencies""); (""Dependencies"", ""Dependencies include texts as localized components."", ""Texts""); (""Dependencies"", ""Dependencies include paths as localized components."", ""Paths""); (""Dependencies"", ""Dependencies include number and date formatters as localized components."", ""Number And Date Formatters"")"
"As you can imagine, the more resources the MyComponent needs, the larger both the class and the configuration grows.",NULL
"As you can imagine, only the execute() method will grow as the number of localized dependencies grow.","(""Execute()"", ""Method""); (""Execute()"", ""Method"")"
"Assuming that the MyService class implements an interface called IService, you can create a mock implementation of the IService interface using this code:",NULL
This mockService factory returns a dynamic implementation of the IService interface based on Java's java.lang.reflect.Proxy class.,NULL
"The serviceMock instance passed to the getMock() method should be the mock object obtained from the mockService factory, using the container.instance(""mockService"") method call.",NULL
"In other words, the instance returned from the MockFactory.createProxy() method call.",NULL
This way it is possible to detect if close() is called on the database connection after some method call that uses the connection has completed.,NULL
"A suggestion would be to have a PersonDao.getConnection() method, even though you'd probably mostly use it during testing.",NULL
From version 2.1.9 it is possible to replace factories at runtime.,"(""Factory"", ""class"")"
"It is also possible to replace several script factories at a time, by using the ScriptFactoryBuilder.replaceFactories(InputStream) method.","(""ScriptFactoryBuilder"", ""The replaceFactories is a method of the ScriptFactoryBuilder class."", ""replaceFactories"")"
Rather than configuring the PersonDao by hand with dependencies (and their dependencies recursively) you just reuse the configuration of the PersonDao from the application container configuration (the file containerConfig.bcs).,"(""PersonDao"", ""PersonDao is reused from the application configuration"", ""application""); (""PersonDao"", ""PersonDao configuration is specified in containerConfig.bcs"", ""containerConfig.bcs"")"
"When designing Butterfly we considered using an XML format for configuration like several alternative DI containers do (Spring, Nano etc.).","(""Butterfly"", ""Butterfly was considered for configuration purposes using an XML format."", ""XML Format""); (""XML Format"", ""XML Format is considered as a method for configuration."", ""Configuration""); (""DI Containers"", ""Spring is an example of an alternative DI container."", ""Spring""); (""DI Containers"", ""Nano is an example of an alternative DI container."", ""Nano"")"
In this example a java.util.ArrayList() instance is created inside the call to setSomeList().,"(""SetSomeList"", ""The method SetSomeList creates an instance of the Java.Util.ArrayList class."", ""Java.Util.ArrayList"")"
As you can see the List.add() method is called twice to add the string and myDataSource factory product to the list.,NULL
The fact One of the advantages you get when designing your own language is the freedom to e.g make methods that return void chainable.,"(""Methods"", ""Method""); (""Methods"", ""Method"")"
"The [] around the values in the setSomeList() call signals that the values are to be put inside a List or array, depending on the setSomeList() parameter type.","(""setSomeList"", ""setSomeList() is related to List as the values are placed inside a List or array, depending on its parameter type."", ""List"")"
It is possible to map classes to tables and columns using annotations.,NULL
You cannot have more than one mapping for the same class using annotation based mapping alone.,NULL
Each annotation is only allowed once in the code for a given class by the Java compiler.,NULL
There are two types of annotations available: A class annotation Annotations for getters and setters.,"(""A Class Annotation"", ""Getters can be annotated with class-level annotations."", ""Getters""); (""A Class Annotation"", ""Setters can be annotated with class-level annotations."", ""Setters"")"
AClassMapping The class annotation (AClassMapping) is used ontop of your class name for your POJO classes.,NULL
"If you set the mappingMode to ""modify"" then Butterfly Persistence will first use automatic mapping to guess as much as it can, and then look at the annotations and modify the class mapping accordingly.",NULL
"The tableName element can be set to the name of the table the class is to be mapped to, if it cannot be guessed by the automatic mapping mechanism.","(""TableName"", ""The TableName element is used to map the class to a specific table."", ""Class"")"
"If you have a database generated (e.g auto-incremented) primary key that is mapped to a getter method, you will have to mark the getter method as database generated, to avoid having Butterly Persistence try to set that value in the database.",NULL
The class annotation (AClassMapping) is used ontop of your class name for your POJO classes.,NULL
"Notice how the second class definition uses manual mapping, so the getter and setter must be fully mapped to columns in the database.","(""Class"", ""The class definition likely involves methods for getter and setter functionalities."", ""Method"")"
The ASetterMapping annotation is used to map setters of classes to columns in database tables or SQL queries.,"(""ASetterMapping"", ""ASetterMapping is used to map setters to columns in database tables or SQL queries."", ""setter""); (""setter"", ""Setters are mapped to columns in database tables."", ""database table""); (""setter"", ""Setters are mapped to columns in SQL queries."", ""SQL query"")"
In this example the Employee.class object is the object mapping key.,"(""Employee"", ""class""); (""Employee"", ""class"")"
"However, if you want Butterfly Persistence to be able to auto-map the target class to the database, the object mapping key should be either a Class object, or an IObjectMappingKey instance.","(""Butterfly Persistence"", ""Butterfly Persistence uses Class for auto-mapping to the database."", ""Class""); (""Butterfly Persistence"", ""Butterfly Persistence uses IObjectMappingKey for auto-mapping to the database."", ""IObjectMappingKey"")"
"The IObjectMappingKey instance can contain more information about the class to be mapped, than a Class object can.","(""IObjectMappingKey"", ""IObjectMappingKey can contain more information about the class to be mapped than a Class object can, indicating a likely relationship in terms of functionality or hierarchy."", ""Class"")"
"An IObjectMappingKey instance has a getObjectClass() method that returns the Class object of the class to map, so automatic mapping is possible in either case.","(""IObjectMappingKey"", ""The 'getObjectClass' is a method of the 'IObjectMappingKey' class, suggesting the former belongs to or operates within the latter."", ""getObjectClass""); (""getObjectClass"", ""The 'getObjectClass' method returns a 'Class' object, indicating a functional output relationship."", ""Class""); (""IObjectMappingKey"", ""The 'IObjectMappingKey' interacts with the 'Class' entity through its method, suggesting an operational relationship."", ""Class"")"
When checking for tables with similar names to the class to map only the class name itself is used.,"(""Class"", ""Tables are checked for similarities to the class name"", ""Table Names"")"
The ObjectMapper generates various textual combinations based on the class name and checks the database meta data to see if any of these match.,"(""ObjectMapper"", ""The ObjectMapper uses the database to generate and check textual combinations based on class names."", ""database"")"
"The ObjectMapper mapper breaks the class name into words, based on the uppercase letters and numbers in the class name.","(""ObjectMapper"", ""class"")"
Based on these combinations the PersistentObject class name would be similar to the table names PersistentObject persistentObject persistentobject PERSISTENTOBJECT Persistent_Object persistent_object PERSISTENT_OBJECT PersistentObjects persistentObjects persistentobjects PERSISTENTOBJECTS PERSISTENTOBJECTs Persistent_Objects persistent_objects PERSISTENT_OBJECTS PERSISTENT_OBJECTs As you can see there is a reasonable chance that the table name will be guessed if it is similar to the class name.,NULL
"The Object Mapper uses reflection to iterate the methods of the class to be mapped, and filters out all other methods than getters and setters.",NULL
If your custom mapper implementation returns an object mapping from the getObjectMapping() method then automatic and annotation based mapping are not applied.,"(""getObjectMapping"", ""The getObjectMapping method returns an object mapping as part of the custom mapper implementation."", ""custom mapper implementation"")"
"If a table name is returned from the getTableName() method, then Butterfly Persistence will not try to guess a table name, nor look at the class annotation for table name.","(""GetTableName"", ""The GetTableName method is used within Butterfly Persistence to manage table name retrieval."", ""Butterfly Persistence""); (""GetTableName"", ""The GetTableName method determines if the class annotation should be used for table names."", ""Class Annotation""); (""GetTableName"", ""The GetTableName method is used within Butterfly Persistence to manage table name retrieval."", ""Butterfly Persistence""); (""GetTableName"", ""The GetTableName method determines if the class annotation should be used for table names."", ""Class Annotation"")"
If null is returned Butterfly Persistence will look at the class annotation to see if a table name is set there.,"(""Butterfly Persistence"", ""Butterfly Persistence uses the table name annotation to check for a table name."", ""table name"")"
If the getObjectMapping() method returned null Butterfly Persistence will call the modify() method to allow your custom object mapper to modify the automatically generated mapping.,"(""Getobjectmapping"", ""The 'getObjectMapping()' method returning null triggers a call to the 'modify()' method."", ""Modify""); (""Modify"", ""The 'modify()' method is part of the 'Butterfly Persistence' package, allowing custom object mapping."", ""Butterfly Persistence"")"
Before doing so Butterfly Persistence will have applied the annotations in the class to the mapping.,NULL
"If you want Butterfly Persistence to manage the opening of connections, pass a javax.sql.DataSource implementation into the constructor of the PersistenceManager.",NULL
The readLong() method comes in another version too which takes an optional list of parameters.,"(""Readlong"", ""The term 'readLong()' clearly indicates a method."", ""Method"")"
They will be inserted in the sequence they are passed to the readLong() method.,NULL
"The string (4,5,6,7) is an id string which could be returned by the readIdString() method.","(""Readidstring"", ""The Readidstring method returns a string, which is its output."", ""String"")"
The readIdString() method comes in a variant that takes an optional list of parameters.,"(""ReadIdString"", ""The method readIdString() takes a list of parameters"", ""Parameters"")"
The IJdbcDao has a few read() methods that allows you to decide what to do with each record in the ResultSet resulting from some SQL query.,NULL
To do so you must provide the read() method with an implementation of the IResultSetProcessor interface.,"(""Read"", ""The Read method requires an implementation of the IResultSetProcessor interface, indicating a usage or dependency relationship."", ""IResultSetProcessor""); (""Read"", ""The Read method requires an implementation of the IResultSetProcessor interface, indicating a usage or dependency relationship."", ""IResultSetProcessor"")"
The init() method is called before the iteration of the ResultSet begins.,"(""init"", ""The `init` method is invoked before the iteration process of the `ResultSet` class starts."", ""ResultSet""); (""init"", ""The `init` method is invoked before the iteration process of the `ResultSet` class starts."", ""ResultSet"")"
The process() method is called for each record in the ResultSet The read() method returns an object.,"(""Process"", ""The Process method is called for each record in the ResultSet, indicating a clear interaction or relationship between them."", ""ResultSet""); (""Read"", ""The Read method returns an object, which may involve processing similar to what the Process method does, suggesting a conceptual link."", ""Process"")"
This is the object is obtained from the getResult() method of the IResultSetProcessor.,NULL
Here is an example of how to use a IResultSetProcessor with the read() methods:,"(""IResultSetProcessor"", ""The class IResultSetProcessor is related to the method read because it is specifying how to use IResultSetProcessor with the read method."", ""read""); (""IResultSetProcessor"", ""The class IResultSetProcessor is related to the method read because it is specifying how to use IResultSetProcessor with the read method."", ""read"")"
It may be a good idea to create a base class for your IResultSetProcessor implementations with empty method implementations for init() and perhaps a default behaviour for getResult().,"(""IResultSetProcessor"", ""The method init() is a part of the class IResultSetProcessor."", ""init""); (""IResultSetProcessor"", ""The method getResult() is a part of the class IResultSetProcessor."", ""getResult"")"
The read() method comes in a version that takes an optional number of parameters.,NULL
Notice how the number 1975 is passed into the read() method at the end.,"(""Read"", ""Method"")"
The execute() method should execute the PreparedStatement and return the result of the execution.,"(""Execute"", ""The execute method operates on the PreparedStatement to perform its execution."", ""PreparedStatement"")"
The postProcess() method is normally used to call methods on the PreparedStatement after execution.,"(""Postprocess"", ""The Postprocess method is used to call methods on the Preparedstatement after execution, indicating a functional relationship between the two."", ""Preparedstatement"")"
"To read the ids of X records returned from a query into a string of the format (id1, id2, id3, ...) you will do like this:","(""X"", ""The record ids are associated with the X class as they're being read by the X class"", ""records"")"
"From version 5.3.9 you no longer need to cast the returned object, if you use a Class object as object mapping key.","(""Class"", ""The Class entity is used as an object mapping key."", ""object mapping key"")"
You can also parameterize the SQL statement and pass the parameters to the readList() method.,"(""Readlist"", ""The Readlist method can accept an SQL statement as a parameter, which indicates a functional linkage between the SQL class and the Readlist method."", ""Sql"")"
"This text contains a few examples of how to use the object DAO, IObjectDao, so you can get an idea about how to use the IObjectDao class:",NULL
In addition the Person class and persons table are defined like this:,"(""Person"", ""class"")"
"Thus, it doesn't matter how many fields in a class are mapped to columns in the ""items"" table.","(""Class"", ""class"")"
"Therefore you need to create a special object mapping for the given class, that only maps the fields you want to write to columns in the database.","(""Class"", ""The text suggests creating a special object mapping for the given class, indicating a relationship where the object mapping is associated with the class."", ""Object Mapping"")"
"The object mapping key could be any object you choose, but if you want help from Butterfly Persistence to map a class to the database, the object mapping key should be either a java.lang.Class object, or an ObjectMappingKey instance.",NULL
"For instance, Employee.class is the object mapping key in the method call below:","(""Employee"", ""The Employee class is used as an object mapping key in the method."", ""method"")"
"To enable easy, always-in-time custom object mapping Butterfly Persistence provides the ObjectMappingKey class for advanced object mapping keys.",NULL
Creating an ObjectMappingKey instance is done using the ObjectMappingKey class factory methods.,NULL
"That is because the ObjectMappingKey's factory methods gives each ObjectMappingKey instance a unique id, an int, which is used by its equals() and hashCode() methods.","(""ObjectMappingKey"", ""ObjectMappingKey instances are created using its factory methods, implying a creation relationship."", ""Factory Methods""); (""ObjectMappingKey"", ""The equals() method operates on ObjectMappingKey instances, suggesting a functional relationship."", ""Equals()""); (""ObjectMappingKey"", ""The hashCode() method is used by ObjectMappingKey instances, indicating a use relationship."", ""HashCode()"")"
"This speeds up object mapping cache lookups because the hashCode() method returns this int id, and because equals() also only compares int id's, instead of Class objects, table names etc.","(""HashCode"", ""Both methods are related as they are used for object comparison and caching strategies."", ""Equals""); (""Class"", ""The method HashCode is often associated with Class objects when implementing hash-based collections."", ""HashCode"")"
Instead of the class MyCustomObjectMapper you should use your own class.,"(""MyCustomObjectMapper"", ""The first class is suggested to be replaced by the second class, indicating a relationship of substitution or equivalence."", ""your own class"")"
The extended class CustomObjectMapperBase is an empty implementation of the ICustomObjectMapper interface.,NULL
Just call the IObjectMapping.removeGetterMapping(String name) or IObjectMapping.removeSetterMapping(String name) method to do so.,"(""IObjectMapping"", ""The method removeGetterMapping is associated with the IObjectMapping class."", ""removeGetterMapping""); (""IObjectMapping"", ""The method removeSetterMapping is associated with the IObjectMapping class."", ""removeSetterMapping"")"
The ObjectMappingKey class has some static shortcut factory methods to create object mapping keys that has custom object mappers for auto-generated columns.,"(""ObjectMappingKey"", ""The ObjectMappingKey class has factory methods to create object mapping keys."", ""factory methods""); (""factory methods"", ""Factory methods create object mapping keys."", ""object mapping keys""); (""object mapping keys"", ""Object mapping keys have custom object mappers."", ""object mappers"")"
The only thing required to use Butterfly Persistence is that you add the JAR file to the classpath of your application.,"(""Butterfly Persistence"", ""The JAR file is required for using the Butterfly Persistence package by adding it to the classpath."", ""JAR file"")"
"A lot of things are cached internally in the PersistenceManager instance, like object mappings, sql etc., so you should not create a new instance everytime you need it.",NULL
Version control systems typically also makes it easier for multiple people to collaborate - e.g.,NULL
"The Docker base image you are using may itself consist of multiple layers, and can itself be based on another base image etc., until you get down to the most basic Docker image you can create - a raw Linux container image with no special settings applied.",NULL
This example copies a single file from the Docker host at /myapp/target/myapp.jar to the Docker image at /myapp/myapp.jar .,NULL
This example copies the two files /myapp/config/prod/conf1.cfg and /myapp/conig/prod/conf2.cfg into the Docker image directory /myapp/config/ .,NULL
"In other words, you can create a directory inside the docker image, e.g.",NULL
"called /data which can later be mounted to a directory, e.g.",NULL
In a Maven repository a JAR file is identified by its group name (e.g.,NULL
"the organization that made it), its artifact name (the name of the project / software / tool / API), and a version number (e.g.",NULL
"This example declares a dependency on Log4J using the group name log4j, the artifact name log4j and the version 1.2.17 .","(""log4j"", ""The group name 'log4j' is associated with the Log4J package due to name similarity and conventional naming patterns."", ""Log4J""); (""log4j"", ""The artifact name 'log4j' indicates it is a specific version or component of the Log4J package."", ""Log4J"")"
By default the testCompile dependency configuration also includes the compiled classes and the dependencies from the compile dependency configuration.,NULL
The build task will compile all your Java classes and create a JAR file with them in.,NULL
Gradle outputs classes and JAR file to the directory named build inside your project root directory.,NULL
The compiled classes are written to build/classes and the JAR file to build/libs .,"(""build/classes"", ""Both are directories used for storing build outputs in the build process."", ""build/libs"")"
"This is because the classes, jar and assemble tasks are now all UP-TO-DATE from the last run.",NULL
"Running the clean task removes the build directory, and thus all compiled classes and created JAR files.","(""Clean"", ""The 'Clean' method is related to the 'Build Directory' class because it removes the build directory."", ""Build Directory""); (""Clean"", ""The 'Clean' method is related to 'JAR Files' because it removes all created JAR files."", ""JAR Files"")"
"Second, this example calls the myTask doFirst() method, passing along a closure as parameter.","(""myTask"", ""The doFirst method is called on the myTask class, indicating a relationship where the method is likely a member or function of the class."", ""doFirst"")"
"Third, this example calls the myTask doLast() method, passing along another closure as parameter.","(""myTask"", ""The 'doLast()' method is invoked on the 'myTask' class entity, indicating usage as a function call."", ""doLast()"")"
"When the task myTask is executed Gradle will first execute all closures passed as parameters the doFirst() method, and then all closures passed as parameters the doLast() method.","(""doFirst"", ""The doFirst() and doLast() methods are related because they are invoked sequentially during the execution of a task in Gradle."", ""doLast"")"
"First of all you do not need the semicolon ; after the doFirst() and doLast() method calls, if the code line with the method calls ends with a new line.","(""DOFIRST"", ""Both doFirst and doLast are mentioned together in the context of method calls, suggesting that they might be related as sequential operations or complementary methods in a similar functional context."", ""DOLAST"")"
"Second, you do not need the parentheses around the closure when calling doFirst() or doLast().","(""doFirst"", ""Both doFirst and doLast are methods mentioned in the context of calling closures"", ""doLast"")"
With these two syntax optimizations you can write the doFirst() and doLast() method calls like this:,"(""DoFirst"", ""Both are method calls mentioned in the text and are likely part of the same coding context"", ""DoLast"")"
Often you will not need to pass closures to both doFirst() and doLast() .,NULL
It is quite common to pass just a single closure to the doLast() method.,NULL
"Because this is such a common use case, Gradle has a shortcut for passing a closure to the doLast() method.",NULL
The two characters << corresponds to calling the doLast() method like this:,"(""DoLast"", ""The 'doLast()' method is invoked or represented using the '<<' characters."", ""Characters""); (""DoLast"", ""The 'doLast()' method is invoked or represented using the '<<' characters."", ""Characters"")"
You can even define the task on the same line as you pass the closure to the doLast() method.,NULL
You can also add multiple closures using the doLast() shortcut notation.,NULL
"A task could be compiling the source code, generating JavaDoc, zipping the compiled classes into a JAR file etc.",NULL
The build script is typically called build.gradle and is normally located in the root directory of the project you are building.,"(""Build.gradle"", ""Class""); (""Build.gradle"", ""Class"")"
When you specify another build script Gradle does not use its settings.gradle file.,"(""Gradle"", ""settings.gradle is a configuration file used by Gradle when building projects."", ""settings.gradle""); (""Gradle"", ""settings.gradle is a configuration file used by Gradle when building projects."", ""settings.gradle"")"
Gradle will use the build.gradle file found in the project directory (subproject-dir) and will execute the build task in that build script.,NULL
"Note, that the Predicate interface contains a single unimplemented method named test() which returns a boolean.",NULL
"After creating the two basic functions, a third Predicate is composed, which calls the test() methods of the two first functions.","(""Predicate"", ""The Predicate class is composed of methods such as test in this context."", ""test"")"
The Predicate interface (java.util.function.Predicate) contains a few methods that help you compose new Predicate instances from other Predicate instances.,NULL
The and() method is used to combine two other Predicate functions in the same way I showed in the beginning of this Java functional composition tutorial.,"(""And"", ""The and() method combines Predicate functions."", ""Predicate""); (""And"", ""The and() method is part of the Java programming language."", ""Java"")"
Here is an example of functional composition with the Predicate and() method:,"(""Predicate"", ""The 'and()' method belongs to the 'Predicate' class"", ""and()"")"
This Predicate composition example composes a new Predicate from two other Predicate instances using the and() method of one of the basic Predicate instances.,"(""Predicate"", ""The 'and' method is part of the Predicate class, used to compose a new Predicate from two other Predicate instances."", ""and"")"
The composed Predicate will return true from it's test() method if both of the Predicate instances it was composed from also return true.,"(""Predicate"", ""The test method belongs to the Predicate class as indicated by its description of returning true if both Predicate instances return true."", ""Test"")"
"The Predicate or() method is used to combine a Predicate instance with another, to compose a third Predicate instance.","(""or()"", ""The or() method is used to combine instances of the Predicate class."", ""Predicate"")"
"The composed Predicate will return true if either of the Predicate instances it is composed from return true, when their test() methods are called with same input parameter as the composed Predicate.",NULL
This Predicate or() functional composition example first creates two basic Predicate instances.,"(""Predicate"", ""The 'or()' method is a functional composition related to instances of the Predicate class"", ""or()"")"
"Second, the example creates a third Predicate composed from the first two, by calling the or() method on the first Predicate and passing the second Predicate as parameter to the or() method.","(""Predicate"", ""The Predicate class uses the or() method to combine predicates."", ""or()""); (""or()"", ""The or() method is part of the Predicate class structure."", ""Predicate"")"
The Java Function interface (java.util.function.Function) also contains a few methods that can be used to compose new Function instances from existing ones.,NULL
"The Java Function compose() method composes a new Function instance from the Function instance it is called on, and the Function instance passed as parameter to the compose() method.",NULL
"The Function returned by compose() will first call the Function passed as parameter to compose(), and then it will call the Function which compose() was called on.","(""Compose"", ""Compose is a method that returns an instance of the Function class."", ""Function""); (""Function"", ""Two Function instances are involved, one passed as a parameter and one that compose() is called on."", ""Function"")"
"This is easier to understand with an example, so here is a Java Function compose() example:","(""Compose"", ""The method 'Compose' is given as an example within the Java package context in the text."", ""Java"")"
The Java Function andThen() method works opposite of the compose() method.,"(""AndThen"", ""The AndThen method and the Compose method are related because they are both methods in Java used for function composition, but they work in opposite ways."", ""Compose"")"
"A Function composed with andThen() will first call the Function that andThen() was called on, and then it will call the Function passed as parameter to the andThen() method.",NULL
"Then the andThen() method is called on the multiply Function to compose a new Function, passing the add Function as parameter to andThen().","(""andThen"", ""The andThen method is applied to the multiply Function to create a new composed Function."", ""multiply Function""); (""andThen"", ""The andThen method takes the add Function as a parameter to compose it with the multiply Function."", ""add Function"")"
Calling the Function composed by andThen() with the value 3 will result in the following calculation 3 * 2 + 3 and the result will be 9.,"(""Function"", ""The method andThen() is likely a member or used by the class Function to compose operations."", ""andThen()"")"
"Note: As mentioned in the beginning, andThen() works opposite of compose().","(""AndThen"", ""The methods AndThen and Compose are described as having opposite functionalities."", ""Compose""); (""AndThen"", ""The methods AndThen and Compose are described as having opposite functionalities."", ""Compose"")"
"Therefore, calling a.andThen(b) is actually the same as calling b.compose(a) .","(""AndThen"", ""Calling 'a.andThen(b)' is functionally equivalent to calling 'b.compose(a)', suggesting a functional relationship between the two methods where one achieves similar functionality to the other when parameters are reversed."", ""Compose"")"
The Java Function interface (java.util.function.Function) interface is one of the most central functional interfaces in Java.,"(""Java Function"", ""The Java Function interface is contained within the java.util.function package."", ""java.util.function"")"
The only method you have to implement to implement the Function interface is the apply() method.,"(""Function"", ""The apply method is the only method that needs to be implemented for the Function interface."", ""apply"")"
"This Function implementation implements the apply() method so it takes a Long as parameter, and returns a Long.","(""Apply"", ""The apply method takes a Long as a parameter and returns a Long."", ""Long"")"
"Second, the example calls the apply() method on the AddThree instance.","(""apply()"", ""The method apply() is called on an instance of the AddThree class."", ""AddThree"")"
"As you can see, the Function interface implementation is now inlined in the declaration of the adderLambda variable, rather than in a separate class.",NULL
"The Java Predicate interface, java.util.function.Predicate, represents a simple function that takes a single value as parameter, and returns true or false.",NULL
"The Predicate interface contains more methods than the test() method, but the rest of the methods are default or static methods which you don't have to implement.","(""Predicate"", ""The 'test' method is part of the 'Predicate' class, indicating a method-class relationship."", ""test"")"
"You can implement the Predicate interface using a class, like this:",NULL
This lambda implementation of the Predicate interface effectively does the same as the implementation above that uses a class.,"(""Predicate"", ""The lambda implementation is an alternative way to implement the Predicate class."", ""lambda"")"
This Java Consumer implementation prints the value passed as parameter to it out to System.out.,"(""Consumer"", ""The Consumer class uses the System.out package to output the value passed to it."", ""System.out"")"
"Especially the idea of ""no side effects"" makes it hard to e.g.",NULL
"In the functional programming paradigm, functions are first class objects in the language.",NULL
Notice how the return value of the sum() function only depends on the input parameters.,"(""Sum"", ""The return value is a concept related to the method as it is what the method produces as output"", ""Return Value""); (""Sum"", ""Input parameters are related to the method because they are the inputs that the method operates on"", ""Input Parameters"")"
"Notice also that the sum() has no side effects, meaning it does not modify any state (variables) outside the function anywhere.","(""Sum"", ""Method"")"
"Notice how the method add() uses a member variable to calculate its return value, and it also modifies the state of the value member variable, so it has a side effect.",NULL
Notice how the createFactory() method returns a lambda expression as result.,"(""Createfactory"", ""The createFactory method returns a lambda expression as its result, indicating a functional relationship between them."", ""Lambda Expression"")"
Notice also that the createFactory() method takes two instances as parameters which are both implementations of interfaces (IProducer and IConfigurator).,NULL
Therefore they can be implemented by Java lambda expressions - and therefore the createFactory() method is a higher order function.,NULL
"A function may have local variables containing temporary state internally, but the function cannot reference any member variables of the class or object the function belongs to.",NULL
"State outside of a function refers both to member variables in the class or object the function, and member variables inside parameters to the functions, or state in external systems like file systems or databases.",NULL
"This is still a functional interface, because only run() is not implemented (abstract).","(""RUN"", ""METHOD"")"
The first example of a higher order function is the Collections.sort() method which takes a Comparator as parameter.,NULL
The lambda parameter is what makes Collections.sort() a higher order function.,NULL
"Second, the example calls the reversed() method on the Comparator lambda.","(""Reversed"", ""The 'reversed()' method is invoked on an instance or expression within the 'Comparator' class context."", ""Comparator""); (""Reversed"", ""The 'reversed()' method is invoked on an instance or expression within the 'Comparator' class context."", ""Comparator"")"
"The reversed() method returns a new Comparator lambda, which reverse the result returned by the first Comparator implementation.",NULL
"By ""reversing"" I mean that it simply returns -1 * comparator.compare(a,b)",NULL
"Because the reversed() method returns a lambda (function), the reversed() method is considered a higher order function.","(""Reversed"", ""The reversed method returns a lambda, indicating a functional relationship."", ""Lambda""); (""Reversed"", ""The reversed method is considered a higher order function because it returns a function."", ""Higher Order Function""); (""Reversed"", ""The reversed method returns a lambda, indicating a functional relationship."", ""Lambda""); (""Reversed"", ""The reversed method is considered a higher order function because it returns a function."", ""Higher Order Function"")"
"Third, the example sorts the List of Strings using the Collections.sort() method.",NULL
"In contrast, when you are using the Java Collections iteration features (e.g a Java Iterator or the Java for-each loop used with a Java Iterable) you have to implement the iteration of the elements yourself.","(""Java Iterator"", ""Both facilitate iteration over a collection in Java."", ""Java for-each loop""); (""Java Iterable"", ""A Java Iterable provides a method to create an Iterator for iteration."", ""Java Iterator""); (""Java Iterator"", ""Both facilitate iteration over a collection in Java."", ""Java for-each loop""); (""Java Iterable"", ""A Java Iterable provides a method to create an Iterator for iteration."", ""Java Iterator"")"
"Finally, the example calls the stream() method to obtain a Stream instance.","(""stream()"", ""The stream() method is called to obtain a Stream instance."", ""Stream"")"
The call to the map() method of the Stream interface is a non-terminal operation.,"(""Map"", ""The Map method is a function that operates on the Stream class."", ""Stream"")"
The map() method will be covered in more detail later on.,NULL
Notice how the second call to Stream map() is called on the Stream returned by the first map() call.,NULL
The Java Stream filter() can be used to filter out elements from a Java Stream.,"(""Java Stream"", ""The filter method is a function that operates on the Java Stream class to filter out elements."", ""filter"")"
Here is an example of calling the Java Stream filter() method:,"(""Stream"", ""The filter() method is a function that operates on or is called by Stream objects."", ""filter()""); (""Java"", ""Stream is a class within the Java package's API ecosystem."", ""Stream"")"
The Java Stream map() method converts (maps) an element to another object.,"(""Stream"", ""The method 'map()' is associated with the 'Stream' class, as it is a method that operates on stream instances."", ""map"")"
The Java Stream flatMap() methods maps a single element into multiple elements.,NULL
This example should give you an idea about how flatMap() can be used to map a single element into multiple elements.,"(""FlatMap"", ""Method"")"
This Java Stream flatMap() example first creates a List with 3 strings containing book titles.,"(""FlatMap"", ""FlatMap is a method used to transform elements from List"", ""List""); (""FlatMap"", ""FlatMap is a method used to transform elements from List"", ""List"")"
"Then a Stream for the List is obtained, and flatMap() called.","(""Stream"", ""A Stream is obtained for the List class, indicating a connection where Stream interacts with List."", ""List""); (""Stream"", ""The flatMap method is called on the Stream, indicating that flatMap operates on or is a part of the Stream."", ""flatMap"")"
The flatMap() operation called on the Stream has to return another Stream representing the flat mapped elements.,NULL
Note that this example finishes with a call to forEach() which is a terminal operation.,"(""FOR EACH"", ""The method forEach() is described as being a terminal operation in the text."", ""TERMINAL OPERATION"")"
The Java Stream distinct() method is a non-terminal operation that returns a new Stream which will only contain the distinct elements from the original stream.,NULL
Only the first occurrence of this element will be included in the Stream returned by distinct().,"(""distinct"", ""The method 'distinct()' operates on the class 'Stream' to return distinct elements."", ""Stream"")"
"Thus, the resulting List (from calling collect()) will only contain one, two and three.",NULL
The Java Stream limit() method can limit the number of elements in a stream to a number given to the limit() method as parameter.,"(""Stream"", ""The limit() method is used to limit the number of elements in a Stream by taking a number as a parameter."", ""limit() method"")"
The limit() method returns a new Stream which will at most contain the given number of elements.,"(""limit()"", ""The limit() method is associated with the Stream class, as it returns a new Stream containing a subset of its elements."", ""Stream"")"
"This example first creates a Stream, then calls limit() on it, and then calls forEach() with a lambda that prints out the elements in the stream.","(""Stream"", ""The limit() method is called on the Stream, suggesting an operation that transforms or manipulates the elements within the Stream."", ""limit""); (""Stream"", ""The forEach() method is used on the Stream to perform an action, specifically to print elements, indicating a direct interaction with the Stream."", ""forEach"")"
The Java Stream peek() method is a non-terminal operation that takes a Consumer (java.util.function.Consumer) as parameter.,"(""peek()"", ""The peek() method takes a Consumer (java.util.function.Consumer) as a parameter."", ""java.util.function.Consumer""); (""peek()"", ""The peek() method is an operation within the Java Stream class."", ""Java Stream"")"
The peek() method returns a new Stream which contains all the elements in the original stream.,NULL
"The purpose of the peek() method is, as the method says, to peek at the elements in the stream, not to transform them.","(""Peek"", ""The term 'peek' is associated with the 'peek() method' in the text, indicating that it represents a method within this context."", ""Method"")"
It is the call to count() at the end of the example that is the terminal operation.,NULL
"Since count() returns a long, the Stream chain of non-terminal operations (the map() calls) is ended.","(""count"", ""The count method is connected to the Stream as it is a terminal operation that concludes a chain of operations on a Stream."", ""Stream""); (""map"", ""The map method is involved in the Stream as a non-terminal operation that processes elements in the Stream."", ""Stream"")"
"The Java Stream anyMatch() method is a terminal operation that takes a single Predicate as parameter, starts the internal iteration of the Stream, and applies the Predicate parameter to each element.",NULL
"If the Predicate returns true for any of the elements, the anyMatch() method returns true.","(""Predicate"", ""The anyMatch() method checks if the Predicate class returns true for any elements."", ""anyMatch"")"
"In the example above, the anyMatch() method call will return true, because the first string element in the stream starts with ""One"".","(""anyMatch()"", ""The method anyMatch() is called on elements in a Stream to evaluate a match condition."", ""Stream"")"
"The Java Stream allMatch() method is a terminal operation that takes a single Predicate as parameter, starts the internal iteration of elements in the Stream, and applies the Predicate parameter to each element.",NULL
"If the Predicate returns true for all elements in the Stream, the allMatch() will return true.","(""Predicate"", ""The Predicate is a condition used by the allMatch method to evaluate if it returns true for all elements."", ""allMatch""); (""Stream"", ""The allMatch method operates on a Stream to check if a given Predicate returns true for all its elements."", ""allMatch"")"
"If not all elements match the Predicate, the allMatch() method returns false.","(""AllMatch"", ""The allMatch() method uses the Predicate to evaluate whether all elements match the given condition."", ""Predicate"")"
"In the example above, the allMatch() method will return false, because only one of the strings in the Stream starts with ""One"".",NULL
"The Java Stream noneMatch() method is a terminal operation that will iterate the elements in the stream and return true or false, depending on whether no elements in the stream matches the Predicate passed to noneMatch() as parameter.","(""Stream"", ""The noneMatch() method is a terminal operation that operates on the Stream."", ""noneMatch()""); (""noneMatch()"", ""The noneMatch() method takes a Predicate as a parameter."", ""Predicate"")"
"The noneMatch() method will return true if no elements are matched by the Predicate, and false if one or more elements are matched.","(""noneMatch"", ""The noneMatch() method uses the Predicate to evaluate elements."", ""Predicate"")"
"The Java Stream collect() method is a terminal operation that starts the internal iteration of elements, and collects the elements in the stream in a collection or object of some kind.","(""Java Stream"", ""The collect() method is a terminal operation associated with the Java Stream class, indicating a specific use or function of the stream."", ""collect()"")"
"Luckily, the Java class java.util.stream.Collectors contains a set of pre-implemented Collector implementations you can use, for the most common operations.",NULL
"In the example above, it was the Collector implementation returned by Collectors.toList() that was used.","(""Collectors"", ""The Collectors package contains the Collector class, which is indicated by the method usage Collectors.toList()."", ""Collector"")"
"The Java Stream count() method is a terminal operation which starts the internal iteration of the elements in the Stream, and counts the elements.","(""Stream"", ""The count method is used on the Stream class to perform a terminal operation that initiates iteration and counts elements."", ""count"")"
"This example first creates a List of strings, then obtain the Stream for that List, adds a flatMap() operation for it, and then finishes with a call to count().",NULL
"The count() method will start the iteration of the elements in the Stream which will result in the string elements being split up into words in the flatMap() operation, and then counted.","(""Count"", ""The count() method operates on the Stream to iterate through its elements."", ""Stream""); (""Flatmap"", ""The flatMap() operation divides the Stream's elements into words, which indicates a processing relationship."", ""Stream"")"
The Java Stream findAny() method can find a single element from the Stream.,NULL
You can check if an element was found via the Optional isPresent() method.,"(""Optional"", ""The isPresent method is associated with the Optional class as it is used to check the presence of a value within an Optional instance."", ""isPresent"")"
"The Java Stream findFirst() method finds the first element in the Stream, if any elements are present in the Stream.","(""Java Stream"", ""The method findFirst is a function provided by the Java Stream class"", ""findFirst"")"
"The findFirst() method returns an Optional from which you can obtain the element, if present.",NULL
You can check if the Optional returned contains an element via its isPresent() method.,NULL
"The Java Stream forEach() method is a terminal operation which starts the internal iteration of the elements in the Stream, and applies a Consumer (java.util.function.Consumer) to each element in the Stream.",NULL
The Java Stream min() method is a terminal operation that returns the smallest element in the Stream.,NULL
Which element is the smallest is determined by the Comparator implementation you pass to the min() method.,"(""Comparator"", ""The Comparator class is used to determine the order of elements by being passed to the min() method, which utilizes it to find the smallest element."", ""Min"")"
Notice how the min() method returns an Optional which may or may not contain a result.,NULL
"If the Stream is empty, the Optional get() method will throw a NoSuchElementException.",NULL
The Java Stream max() method is a terminal operation that returns the largest element in the Stream.,"(""Java Stream"", ""The 'max()' method is part of the 'Java Stream' class as it operates on stream data to perform a terminal operation."", ""max"")"
Which element is the largest is determined by the Comparator implementation you pass to the max() method.,NULL
Notice how the max() method returns an Optional which may or may not contain a result.,"(""Max"", ""The max method returns an instance of the Optional class, indicating a relationship where max wraps a potential result within Optional."", ""Optional"")"
The Java Stream reduce() method is a terminal operation that can reduce all elements in the stream to a single element.,"(""Stream"", ""The 'reduce' method is associated with the 'Stream' class as it is a terminal operation that applies to elements within a stream."", ""reduce"")"
This Optional contains the value (if any) returned by the lambda expression passed to the reduce() method.,"(""lambda expression"", ""The lambda expression is passed to the reduce() method to perform reduction."", ""reduce""); (""Optional"", ""The Optional class contains the value returned by the reduce() method, if any."", ""reduce"")"
"The Java Stream toArray() method is a terminal operation that starts the internal iteration of the elements in the stream, and returns an array of Object containing all the elements.","(""Stream"", ""The toArray method is a terminal operation that is part of the Stream class."", ""toArray""); (""Stream"", ""The toArray method is a terminal operation that is part of the Stream class."", ""toArray"")"
The Java Stream interface contains a static method called concat() which can concatenate two streams into one.,"(""Stream"", ""The method concat() is a static method within the Stream class, used for concatenating two streams."", ""concat"")"
Here is an example of using the Java Stream concat() method:,"(""Stream"", ""The method concat() is used with the Stream class for concatenating two streams."", ""concat()"")"
The Java Stream interface contains a static method called of() which can be used to create a Stream from one or more objects.,NULL
Here is an example of using the Java Stream of() metho:,"(""Stream"", ""The 'of()' method is part of the Stream class in Java."", ""of""); (""Java"", ""Stream is a class within the Java package."", ""Stream"")"
"A graph based stream processing API could instead support a ""sample"" operation where each node in the stream processing graph is asked for any value it may hold internally (e.g.",NULL
Some graph based stream processing APIs are also designed to kind of hide the iteration of the elements from the user of the API (e.g.,NULL
The full code for the command line argument parsers is listed at the end of this tutorial (it's just one class).,"(""Command Line Argument Parser"", ""class"")"
The interpretation of these command line arguments could be that the copy program should copy file.txt to a file named file2.txt and overwrite file2.txt if it already exists.,"(""Copy Program"", ""The Copy Program acts on File.txt as the source file to be copied."", ""File.txt""); (""Copy Program"", ""The Copy Program targets File2.txt as the destination file for the copied content."", ""File2.txt"")"
These command line arguments consists of one switch (-overwrite) and two targets (file.txt and file.2.txt).,NULL
"When the switch -overwrite is removed, the two arguments file.txt and file2.txt remain.","(""Switch"", ""The switch is related to the overwrite method because it directly influences its behavior."", ""Overwrite""); (""Arguments"", ""Arguments relate to file.txt as it is one of the specified inputs."", ""File.txt""); (""Arguments"", ""Arguments relate to file2.txt as it is one of the specified inputs."", ""File2.txt"")"
The command line argument parser consists of a single Java class named CliArgs.,"(""CliArgs"", ""class"")"
The CliArgs class takes an array of String as argument to its constructor.,"(""CliArgs"", ""The CliArgs class takes an array of String as argument to its constructor"", ""String"")"
The CliArgs class contains the following methods you can use to obtain switch information and values:,"(""CliArgs"", ""The methods are contained within the CliArgs class as part of its functionality"", ""methods"")"
The switchPresent() method can be used to ask if a given switch is present or not.,NULL
"If the command line arguments contains the -overwrite switch anywhere, the switchPresent() method will return true.",NULL
The switchValue() method can be use to obtain the value of a switch.,NULL
Here is a code example showing how to use switchValue() to read the value of the -port switch:,NULL
If you want the value of a switch parsed into a long or double you can use the switchLongValue() and switchDoubleValue() methods.,NULL
The switchValues() method is used to obtain multiple values for a switch.,NULL
The switchValues() method will return all values after the switch and until the next switch is met (next argument starting with a - character).,NULL
The values of the -from switch will be file1.txt and file2.txt.,NULL
The values of the -to switch will be copy1.txt and copy2.txt.,NULL
Instead you can create a swith POJO (Plain Old Java Object) class to hold all the switches.,"(""POJO"", ""class""); (""POJO"", ""class"")"
"You can now read all the switches from the command line directly into an instance of the CliSwitches class, using the switchPojo() method.",NULL
The CliArgs switchPojo() method will use the property names inside the class to match against switches in the command line.,NULL
The targets() method returns all the arguments which are not switches or switch values.,NULL
"The CliArgs class distinguishes between switch values and targets by assuming, that all arguments which have not been ""taken"" already as switch values must be targets.","(""CliArgs"", ""class""); (""CliArgs"", ""class"")"
"will the method targets() as executed in the code above, return the String",NULL
"Therefore the targets() method call will return the argument web-root , because web-root is the only argument that has not been ""taken"" yet, even if it is located in the middle of the argument list.",NULL
You may need to have at least N next bytes (e.g.,NULL
"To be able to move forth and back in the stream data, you may need to keep the next e.g.",NULL
To solve this problem I will develop a RollingBufferInputStream class which keeps at least N bytes available in a buffer.,"(""RollingBufferInputStream"", ""class"")"
"The RollingBufferInputStream class which I have developed, can be used to iterate an InputStream while at the same time making sure there is always block size bytes available in the buffer.","(""RollingBufferInputStream"", ""The RollingBufferInputStream class is used to iterate an InputStream."", ""InputStream"")"
"Note: Even if the class is called RollingBufferInputStream, it is not an InputStream subclass.","(""RollingBufferInputStream"", ""The text mentions that RollingBufferInputStream is called a class and indicates it is not a subclass of InputStream, suggesting a potential conceptual relationship or naming convention that might lead one to assume a subclass relationship, even though it does not exist."", ""InputStream"")"
"First you ask if the buffer has N available bytes, by calling hasAvailableBytes().",NULL
This outline mostly serves to show you the interface of the RollingBufferInputStream class.,NULL
"If the call to hasAvailableBytes() detects that there is not enough bytes available in the buffer, it will attempt to fill the buffer.",NULL
"Here is the full hasAvailableBytes() method implementation, so you can see how it works:","(""HasAvailableBytes"", ""Method""); (""HasAvailableBytes"", ""Method"")"
"Filling data into the buffer is done by the method fillDataFromStreamIntoBuffer(), which is shown here:","(""FillDataFromStreamIntoBuffer"", ""method"")"
"You could use the String.replace() method, but for large amounts of data, and high number of replacements, this performs badly.","(""String"", ""The replace() method belongs to the String class."", ""replace()"")"
The String.replace() method creates a new String instance - which is a copy of the original String with the replacements applied.,NULL
"If you have to perform 5 replacements, you have to call replace() 5 times, each time on the string returned by the last replace() call, like this:","(""replace()"", ""The result of one call to replace() is used as the input for the next call in sequence."", ""replace()""); (""REPLACE()"", ""The result of one call to replace() is used as the input for the next call in sequence."", ""REPLACE()"")"
"... where N = the size of the string, and M = the number of replacements to perform.",NULL
"Instead of using the String.replace() method I will here present a different, more scalable solution called a TokenReplacingReader.","(""String.replace()"", ""TokenReplacingReader is presented as an alternative solution to the String.replace() method"", ""TokenReplacingReader"")"
The token name (without the enclosing ${} ) is passed to the ITokenResolver.resolveToken(String tokenName) method.,"(""ITokenResolver"", ""The resolveToken method is associated with the ITokenResolver class as it appears to belong to or be invoked by it."", ""resolveToken""); (""resolveToken"", ""The resolveToken method takes a String parameter, indicating a direct relationship between the method and the class."", ""String"")"
"The TokenReplacingReader is itself a subclass of java.io.Reader, so any class that can use a Reader, can use a TokenReplacingReader.","(""TokenReplacingReader"", ""TokenReplacingReader is a subclass of java.io.Reader"", ""java.io.Reader"")"
The TokenReplacingReader does not use as much memory as the String.replace() method.,"(""String"", ""The 'replace' method belongs to the 'String' class as it is used with String objects."", ""replace"")"
"... where N is the size of the data to replace tokens in, and M is the number of replacements.",NULL
This is faster than the O(N * M) of the String.replace() method.,NULL
You could create a variant of the TokenReplacingReader which can replace XML entities (e.g.,NULL
"Additionally, since TokenReplacingReader is a java.io.Reader, and it gets its characters from a Reader itself, you can chain it with other java.io.Reader's or InputStreams which does other things (like unzipping, decrypting, converting from UTF-8, UTF-16 etc.)","(""TokenReplacingReader"", ""TokenReplacingReader is a subclass of java.io.Reader as it extends its functionalities."", ""java.io.Reader""); (""TokenReplacingReader"", ""TokenReplacingReader gets its characters from a Reader, indicating a usage relationship."", ""Reader""); (""java.io.Reader"", ""java.io.Reader can be chained with InputStreams, showing operational compatibility."", ""InputStreams"")"
Implementing a Java web crawler is a fun and challenging task often given in university programming classes.,NULL
That way the thread listening for incoming requests spends as much time as possible in the serverSocket.accept() call.,"(""ServerSocket.accept"", ""method"")"
That way the risk is minimized for clients being denied access to the server because the listening thread is not inside the accept() call.,NULL
"Here is the code for the WorkerRunnable class, which is passed to the worker thread constructor:","(""WORKERRUNNABLE"", ""class"")"
"As mentioned earlier the more time the thread calling serverSocket.accept() spends inside this method call, the more responsive the server will be.","(""ServerSocket.accept()"", ""method"")"
Only when the listening thread is inside the accept() call can clients connect to the server.,NULL
Clients can only connect to the server while the server is inside the serverSocket.accept() method call.,NULL
"The longer time the listening thread spends outside the serverSocket.accept() call, the higher the probability that the client will be denied access to the server.","(""ServerSocket"", ""The 'accept' method is typically invoked on an instance of the 'ServerSocket' class to listen for a connection to be made to the socket."", ""Accept"")"
That way the listening thread spends as little time as possible outside the serverSocket.accept() call.,"(""ServerSocket"", ""The accept() method is invoked on an instance of the ServerSocket class to accept incoming client connections."", ""Accept"")"
"For instance, if you process 1.000 requests concurrently and each request takes 1 second, then all requests will take 1.000 seconds to complete.",NULL
"To use IText PDF API for Java you must first download the IText JAR file from the IText website, and include it on your application class path.","(""IText PDF API"", ""The IText class is part of the IText PDF API package."", ""IText""); (""IText"", ""The IText is distributed as a JAR file."", ""JAR file""); (""JAR file"", ""The JAR file is included in the application class path."", ""class path"")"
"The com.itextpdf.text.Anchor class in IText represents an link, either to an external website, or internally in the document.","(""Com.itextpdf.text.Anchor"", ""The class Com.itextpdf.text.Anchor is part of the package Com.itextpdf.text."", ""Com.itextpdf.text"")"
"The com.itextpdf.text.Chunk class in IText represents the smallest possible ""chunk"" of text.",NULL
"If you need to generate a PDF document from scratch, you will use the Document class.","(""Document"", ""class"")"
"You can specify fonts for most text objects (Chunk, Phrase, Paragraph etc.)",NULL
The com.itextpdf.text.Image is used to add images to IText PDF documents.,"(""Com.itextpdf.text.Image"", ""The class Com.itextpdf.text.Image is used to add images to documents that are part of the IText package."", ""IText""); (""Com.itextpdf.text.Image"", ""The class Com.itextpdf.text.Image is used to add images to documents that are part of the IText package."", ""IText"")"
You set the absolute position of an image using the setAbsolutePosition() method.,"(""setAbsolutePosition"", ""The text specifically mentions that 'setAbsolutePosition' is a method for setting the absolute position of an image."", ""Method"")"
"If you already have a finished PDF, and just want to add a header, footer or watermark to it, IText provides the com.itextpdf.pdf.PdfStamper class.","(""IText"", ""PdfStamper is a class provided by the IText package for adding headers, footers, or watermarks to a PDF."", ""PdfStamper"")"
You can set the alignment of the paragraph using the setAlignment() method.,NULL
"You can write text as superscript or subscript using the Chunk class, and it's setTextRise() method.","(""CHUNK"", ""The method setTextRise() belongs to the Chunk class as it is used for modifying properties of text related to this class."", ""SETTEXTRISE"")"
You can add tables to a PDF document using the com.itextpdf.text.PdfPTable class in IText.,NULL
"To add cells to the table you call the addCell() method, passing PdfPCell instances, or other IText objects like Paragraph etc.","(""Addcell"", ""The addCell method is used for adding PdfPCell instances to a table."", ""Pdfpcell""); (""Addcell"", ""The addCell method can also handle Paragraph objects as input."", ""Paragraph"")"
"You can set the column widths using the setWidths() method, like this:","(""SetWidths"", ""The setWidths() method is used to set the column widths, establishing a direct functional relationship between the method and the column widths."", ""Column Widths"")"
"If you need a cell to span multiple columns you can do so using the setColspan() method, like this:","(""SetColspan"", ""Method"")"
"In text mode the settings of the added element (Phrase, Paragraph etc.)","(""Phrase"", ""Both are elements mentioned in text mode settings and likely part of a text manipulation API."", ""Paragraph""); (""Phrase"", ""Both are elements mentioned in text mode settings and likely part of a text manipulation API."", ""Paragraph"")"
Content added via the PdfCell.addElement() method is considered composite mode content.,"(""PdfCell"", ""The addElement method belongs to the PdfCell class and is used to add content to a cell."", ""addElement"")"
"You can set the default cell settings of new cells added, using the table.addCell() methods, like this:",NULL
The method setIndent() sets the indentation of the first paragraph in the cell.,"(""SetIndent"", ""The method SetIndent modifies the indentation, thereby interacting with a cell structure."", ""Cell"")"
The method setFollowingIndent() sets the indentation of the following paragraphs in the cell.,"(""SetFollowingIndent"", ""The method SetFollowingIndent is being used to manipulate the properties of the class Cell, specifically to set the indentation of its following paragraphs."", ""Cell"")"
The method setRightIndent() sets the right indentation of the cell content.,"(""SetRightIndent"", ""The method SetRightIndent modifies the property of Cell Content, specifically its right indentation."", ""Cell Content"")"
"If the cell is in composite mode, just set the leading on the element added, e.g.",NULL
The second method call sets the leading to 0 points + 1.5 x font height.,NULL
"You can set the rotation of the cell content using the setRotation() method, like this:","(""setRotation"", ""The method setRotation is used to set the rotation of the cell content, indicating a method-to-action relationship."", ""cell content"")"
"You can add underline and strikethrough text using the Chunk class, and its setUnderline() method.",NULL
Quite often Java applications keep objects in data structures that contain java.util.ArrayList instances.,"(""ArrayList"", ""The class 'ArrayList' is part of the 'java.util' package."", ""java.util"")"
This tutorial will also look at the performance of the OpenArrayList class - a class that mimics the java.util.ArrayList but designed with performance in mind.,NULL
Each element is obtained from the ArrayList instance using the get() method.,"(""ArrayList"", ""The get() method is used to obtain an element from the ArrayList class instance."", ""get"")"
The third way to iterate an ArrayList is to use an java.util.Iterator obtained from the ArrayList.,"(""ArrayList"", ""An Iterator is obtained from the ArrayList to iterate over its elements"", ""java.util.Iterator""); (""java.util.Iterator"", ""The Iterator class is part of the java.util package"", ""java.util"")"
The benchmarks were executed using JDK 1.8.0_u60 on a Intel Core i7-4770 Haswell server which was doing nothing but the benchmarks.,NULL
"You can also see that iterating an ArrayList using a standard Java for loop with a counter, and obtaining each element by calling the ArrayList get() method is about 10% faster for an ArrayList with 10 elements, and around 12,5% faster when the ArrayList contains 100 elements.","(""ArrayList"", ""The get method is a function of the ArrayList class used to obtain elements."", ""get""); (""Java"", ""ArrayList is a class within the Java package used for collection frameworks."", ""ArrayList"")"
The OpenArrayList class is a very simple imitation of the ArrayList which I have implemented to see if it could iterate a collection of elements faster than an ArrayList .,NULL
"This should be a tiny bit faster than calling the ArrayList get() method, although the JVM could optimize the get() method call away.","(""ArrayList"", ""The get() method is a method of the ArrayList class, used for accessing elements by their index."", ""get() method"")"
Another advantage of making the elements array public is that you can write to it or copy from it using System.arraycopy() which is very fast.,NULL
The fact that the performance is so close is probably a sign that the JVM has optimized the get() call away.,"(""JVM"", ""The JVM has optimized the get() method call away."", ""Get()"")"
"As you can see, the readMyData() method returns a MyData object.","(""READMYDATA"", ""The READMYDATA method returns a MYDATA object, indicating it operates on or produces an instance of the MYDATA class"", ""MYDATA"")"
What is worth noting about this read pattern is that every time you call the readMyData() method a new MyData object is returned.,"(""ReadMyData"", ""The ReadMyData method returns a new MyData object each time it is called"", ""MyData"")"
If the readMyData() method is called frequently that will lead to a lot of MyData objects being created.,"(""ReadMyData"", ""The readMyData method creates instances of the MyData class when it is called."", ""MyData"")"
Here is how the earlier readMyData() method would look using the read-into-existing pattern:,"(""READMYDATA"", ""The method readMyData is being used in accordance with the read-into-existing pattern to demonstrate its implementation."", ""READ-INTO-EXISTING PATTERN"")"
"It is now up to the caller of the readMyData() method to decide if an existing MyData instance should be reused, or if a new instance should be created.","(""ReadMyData"", ""The ReadMyData method is explicitly mentioned as acting upon or dealing with an instance of the MyData class."", ""MyData"")"
Reusing an object also means that the chance the object is located in the CPU cache is much higher than when you create a new object for each call to the readMyData() method.,"(""READMYDATA"", ""The READMYDATA method potentially uses or refers to OBJECTS as a part of its function"", ""OBJECT"")"
To change the previous example code to read data directly from the underlying source we need to change the implementation of the MyData class:,"(""MyData"", ""class"")"
"To use the MyData class in its new variation, you will use code like this:","(""MyData"", ""class"")"
Just call setSource() when you need to read data out of a new byte array.,NULL
"Third, only if you actually call both getVal1() and getVal2() will the corresponding data be read out of the underlying byte array.","(""GetVal1"", ""Both methods are mentioned together as part of the process to read data, indicating a relationship between them."", ""GetVal2"")"
"Assuming that each MyData object consists of 2 bytes from the underlying source, here is how the MyData class would look with a navigation method added:","(""MyData"", ""The navigation method is associated with the MyData class as it is added to its structure"", ""navigation""); (""MyData"", ""The navigation method is associated with the MyData class as it is added to its structure"", ""navigation"")"
The first change is the that the setSource() method now takes an extra parameter called offset.,NULL
The second change is that the getVal1() and getVal2() methods now use the value of the internal offset variable as index into the source array when reading values out.,"(""Getval1"", ""The method getVal1 uses the internal offset variable as an index."", ""Internal Offset""); (""Getval2"", ""The method getVal2 uses the internal offset variable as an index."", ""Internal Offset""); (""Getval1"", ""The method getVal1 uses the source array for reading values."", ""Source Array""); (""Getval2"", ""The method getVal2 uses the source array for reading values."", ""Source Array"")"
"The next() method increments the internal offset variable by 2, so that the offset variable points to the next record in the array.",NULL
The fourth change is the addition of the hasNext() method which returns true if the source byte array has more records (bytes) in it.,"(""hasNext()"", ""The hasNext() method is related to the source byte array because it is used to check if the array has more records (bytes) in it."", ""source byte array"")"
"As you can see, using the MyData class in the navigator pattern implementation is pretty straightforward.","(""MyData"", ""class"")"
"Additionally, if your server works on many tasks at the same time (e.g incoming HTTP requests), the other CPUs in your server may already be busy working on their own tasks.",NULL
"My own experiences come from from a mix of Java performance experiments, as well as the design and development of VStack.co - a fully hosted application backend which I have cofounded with WorpCloud Ltd.",NULL
"The Java ArrayList class only works for objects - not for primitive types (byte, int, long etc).",NULL
The code consist of 3 Java classes and 2 unit tests.,"(""Java Classes"", ""Class""); (""Java Classes"", ""Class"")"
100.000 x 1MB = 100GB (approximately - not precisely - but you get the picture).,NULL
"Note, that in languages with built-in garbage collection (like Java, C# etc.)","(""Java"", ""Both are programming languages with built-in garbage collection features."", ""C#""); (""Java"", ""Both are programming languages with built-in garbage collection features."", ""C#"")"
Even at 4GB (1.000.000 x 4KB) modern servers should be able to handle it.,NULL
"Additionally, if you use a small block size, you may have to expand blocks more often than if you use e.g.",NULL
"To obtain a ResizableArray instance, call the ResizableArrayBuffer's getArray() method, like this:","(""ResizableArrayBuffer"", ""getArray() is a method of the ResizableArrayBuffer class."", ""getArray()""); (""ResizableArrayBuffer"", ""getArray() is a method of the ResizableArrayBuffer class."", ""getArray()"")"
The ResizableArray class in the GitHub repository only contains a single write() method which takes a ByteBuffer as parameter.,"(""ResizableArray"", ""The write() method is a member of the ResizableArray class"", ""write"")"
"It should be pretty easy to add more write() methods yourself, though.",NULL
The value returned by write() is the number of bytes copied from the ByteBuffer.,NULL
"If the ResizableArray cannot contain all the data in the ByteBuffer after expanding itself to the max size, the write() method will return -1 and no data will have been copied at all!",NULL
"You do so simply by calling the free() method on the ResizableArray, like this:",NULL
"Calling free() takes care of returning the used block to the correct block queue, regardless of the size of the block allocated to the ResizableArray.","(""free()"", ""The method free() is responsible for returning memory blocks used by ResizableArray to the block queue."", ""ResizableArray""); (""free()"", ""The method free() is responsible for returning memory blocks used by ResizableArray to the block queue."", ""ResizableArray"")"
I have implemented batch mode put() and take() operations for both ring buffer implementations.,"(""Put"", ""The method Put is implemented as part of the Ring Buffer class."", ""Ring Buffer""); (""Take"", ""The method Take is implemented as part of the Ring Buffer class."", ""Ring Buffer""); (""Put"", ""The method Put is implemented as part of the Ring Buffer class."", ""Ring Buffer""); (""Take"", ""The method Take is implemented as part of the Ring Buffer class."", ""Ring Buffer"")"
My benchmarks showed that batch put() and take() operations provides up to 4 times the throughput of putting and taking a single element at a time.,NULL
Here is an implementation of the ring buffer that uses a fill count including the batch put() and take() operations.,"(""Ring Buffer"", ""The method Put is a batch operation on the Ring Buffer class."", ""Put""); (""Ring Buffer"", ""The method Take is a batch operation on the Ring Buffer class."", ""Take"")"
"Here is an implementation of the ring buffer that uses a read position and flip marker, including the batch put() and take() operations.","(""Ring Buffer"", ""The read position is used within the ring buffer to manage data reading."", ""Read Position""); (""Ring Buffer"", ""The flip marker is a component of the ring buffer that helps manage state transitions."", ""Flip Marker""); (""Ring Buffer"", ""Batch put is a method used in the ring buffer for adding multiple elements at once."", ""Batch Put""); (""Ring Buffer"", ""Take is a method used in the ring buffer to retrieve elements."", ""Take"")"
"The JMH Maven archetype will generate a new Java project with a single, example benchmark Java class, and a Maven pom.xml file.",NULL
The Maven pom.xml file contains the correct dependencies to compile and build your JMH microbenchmark suite.,NULL
"It is time to write your first JMH benchmark class, or at least see how it is done.","(""JMH Benchmark"", ""class""); (""JMH Benchmark"", ""class"")"
The generated MyBenchmark class is a JMH class template which you can use to implement your JMH benchmarks.,"(""MyBenchmark"", ""MyBenchmark is a class template designed to work with or within the JMH framework."", ""JMH"")"
"You can either implement your benchmarks directly in the generated MyBenchmark class, or create a new class in the same Java package.","(""MyBenchmark"", ""The MyBenchmark class can be implemented directly or a new class can be created within the same Java package"", ""Java"")"
To make it easy for you to write your first JMH benchmark I will just use the generated class in this example.,"(""JMH"", ""package""); (""Benchmark"", ""class""); (""JMH"", ""package""); (""Benchmark"", ""class"")"
You can put the code you want to measure inside the testMethod() method body.,"(""testMethod"", ""The 'testMethod' is mentioned as a method where you place the code to measure performance."", ""method"")"
"For now, just imagine that the testMethod() body actually contained a good benchmark implementation.","(""testMethod"", ""method"")"
"When you build your JMH benchmarks, Maven will always generate a JAR file named benchmarks.jar in the target directory (Maven's standard output directory).","(""Maven"", ""Maven is the build system that generates the benchmarks JAR file."", ""benchmarks""); (""benchmarks"", ""The benchmarks JAR file is generated in the target directory."", ""target"")"
It contains your compiled benchmark classes as well as all JMH classes needed to run the benchmark.,"(""Benchmark Classes"", ""JMH Classes are needed to run the Benchmark Classes."", ""JMH Classes"")"
"If your benchmarks has any external dependencies (JAR files from other projects needed to run your benchmarks), declare these dependencies inside the Maven pom.xml, and they will be included in the benchmarks.jar too.","(""pom.xml"", ""Dependencies declared in pom.xml are included in benchmarks.jar"", ""benchmarks.jar"")"
"Since benchmarks.jar is fully self contained, you can copy that JAR file to another computer to run your JMH benchmarks on that computer.","(""Benchmarks.jar"", ""The entity 'Benchmarks.jar' is described as a JAR package that is self-contained, suggesting it can be copied and used across different systems."", ""JAR""); (""Benchmarks.jar"", ""The entity 'Benchmarks.jar' is used specifically to run 'JMH' benchmarks, indicating a functional relationship."", ""JMH"")"
This means that you want the output shown using the time unit minutes (e.g.,NULL
"State variables are declared in special state classes, and an instance of that state class can then be provided as parameter to the benchmark method.",NULL
In this example I have added a nested static class named MyState.,NULL
Notice that the testMethod() benchmark method now takes an instance of MyState as parameter.,"(""testMethod"", ""The method testMethod takes an instance of the class MyState as a parameter."", ""MyState""); (""testMethod"", ""The method testMethod takes an instance of the class MyState as a parameter."", ""MyState"")"
Notice also that the testMethod() body has now been changed to use the MyState object when performing its sum calculation.,NULL
Notice the two new methods in the MyState class named doSetup() and doTearDown().,NULL
"If you have any doubts about when a setup or tear down method is called, try inserting a System.out.println() statement in the method.","(""System.out.println"", ""System.out.println may be used within the setup method for debugging or logging purposes."", ""setup method""); (""System.out.println"", ""System.out.println may be used within the tear down method for debugging or logging purposes."", ""tear down method"")"
"If your benchmark method is calculating multiple values that might end up being eliminated as dead code, you can either combine the two values into a single, and return that value (e.g.","(""Benchmark"", ""Method"")"
Notice how the testMethod() benchmark method now takes a Blackhole object as parameter.,NULL
Notice also how the calculated sum in the sum variable is now passed to the consume() method of the Blackhole instance.,"(""consume"", ""The consume() method is a function belonging to the Blackhole class, as it is invoked on an instance of Blackhole."", ""Blackhole""); (""consume"", ""The consume() method is a function belonging to the Blackhole class, as it is invoked on an instance of Blackhole."", ""Blackhole"")"
"If your benchmark method produces multiple results you can pass each of these results to a black hole, meaning calling consume() on the Blackhole instance for each value.","(""Benchmark"", ""A benchmark typically involves executing a method to measure performance."", ""Method""); (""Method"", ""The method results are passed to a Blackhole instance to prevent optimizations that could affect benchmarking."", ""Blackhole""); (""Consume"", ""Consume is likely a method of the Blackhole class that handles the passed results."", ""Blackhole"")"
"The JVM could even continue and never call the testMethod() because it knows it always returns 3, and just inline the constant 3 wherever the testMethod() was to be called.","(""Jvm"", ""The TestMethod is a method that could be called or inlined by the JVM during execution."", ""TestMethod"")"
Sometimes a lot of time is even spent just allocating and freeing memory (e.g.,NULL
"When you control object allocation, deallocation and reallocation you can make limits like e.g.",NULL
having a maximum of 10.000 messages in memory at a time.,NULL
"The batch size can thus vary from 1 to a maximum upper limit set by the system, e.g.",NULL
"To achieve lower latency, yet allowing for micro batching to happen, you can loop over the input channels (inbound network connections, directories etc.)",NULL
Therefore it can be beneficial to batch up data sent outside a process to minimize the overhead per data block (e.g.,NULL
"Instead of traversing the whole data structure to serve just one ""request"" (task, message etc.)",NULL
Notice how two different DAO's were called from inside the control's execute() method.,"(""control"", ""The execute method is called from within the control class."", ""execute""); (""DAO"", ""The DAO classes are called from inside the control class."", ""control"")"
"To make this happen you need to obtain a database connection (or equivalent object) inside the Control.execute() method, and pass this connection (or other object) to each DAO.","(""Control"", ""The method execute() belongs to the Control class."", ""execute()"")"
"Well, you could if you call a setConnection() method on them afterwards.","(""setConnection"", ""method""); (""setConnection"", ""method"")"
The DaoManager is a class that you put in between the Control and the DAO's.,"(""DaoManager"", ""DaoManager interfaces or intermediates between Control and DAO."", ""Control""); (""DaoManager"", ""DaoManager interfaces or intermediates between DAO and Control."", ""DAO""); (""DaoManager"", ""DaoManager interfaces or intermediates between Control and DAO."", ""Control""); (""DaoManager"", ""DaoManager interfaces or intermediates between DAO and Control."", ""DAO"")"
Once the DaoManager.executeAndClose() method finishes the database connection inside the DaoManager is closed.,"(""DaoManager"", ""The executeAndClose method is a function provided by the DaoManager class, indicating that executeAndClose is a method that belongs to the DaoManager class."", ""executeAndClose"")"
"As you can see from the code example in the previous section, the scope of the connection when managed by the DaoManager.executeAndClose() is the boundaries of the executeAndClose() method.","(""DaoManager"", ""The method executeAndClose is managed by the class DaoManager"", ""executeAndClose"")"
This could be the case in a desktop application if each control is registered independently as listeners on e.g.,NULL
It is the DaoManager's executeAndClose() method that demarcates the life span of the underlying connection.,"(""DAOMANAGER"", ""The EXECUTEANDCLOSE method is a function belonging to the DAOMANAGER class, indicating a role of EXECUTEANDCLOSE within the class DAOMANAGER."", ""EXECUTEANDCLOSE""); (""DAOMANAGER"", ""The EXECUTEANDCLOSE method is a function belonging to the DAOMANAGER class, indicating a role of EXECUTEANDCLOSE within the class DAOMANAGER."", ""EXECUTEANDCLOSE"")"
"If you call this method from each control's execute() method (or whatever the central execution method in your controls is called), each control will open and close a connection separately.","(""Execute"", ""The text refers to calling the execute() method, indicating that 'execute' functions as a method."", ""Method"")"
The ScopingDataSource will be moved to Butterfly Persistence from around version 5.2.0 or 5.4.0 which will be released in 2009.,"(""ScopingDataSource"", ""ScopingDataSource will be moved to the Butterfly Persistence package in future versions"", ""Butterfly Persistence"")"
The ScopingDataSource is an implementation of the standard Java interface javax.sql.DataSource.,NULL
"Once this method is called, whenever the tread that called this method calls the ScopingDataSource.getConnection() method, the same connection instance is returned.","(""ScopingDataSource"", ""The getConnection method is associated with the ScopingDataSource class as it is mentioned as ScopingDataSource.getConnection() in the text"", ""getConnection""); (""ScopingDataSource"", ""The getConnection method is associated with the ScopingDataSource class as it is mentioned as ScopingDataSource.getConnection() in the text"", ""getConnection"")"
"This ScopingConnection ignores all calls to the close() method, so the underlying connection can be reused.","(""CLOSE"", ""METHOD"")"
"When you are ready to close the connection your control calls the ScopingDataSource.endConnectionScope(), and the currently open connection (if any) is closed.","(""ScopingDataSource"", ""The method endConnectionScope is a functionality provided by the class ScopingDataSource for closing the connection."", ""endConnectionScope"")"
"From here on the ScopingDataSource behaves just like a regular DataSource, returning a new Connection for every call to getConnection().",NULL
"The calls to beginConnectionScope() and endConnectionScope() do not have to be located within the same method, nor within the same class.","(""beginConnectionScope"", ""The beginConnectionScope method is mentioned as part of the methods in the text."", ""method""); (""endConnectionScope"", ""The endConnectionScope method is mentioned as part of the methods in the text."", ""method""); (""method"", ""The text mentions that methods can be within a class, establishing a class-method relationship."", ""class"")"
"You can just extend the DBControlBase and override the doExecute() method, then all connection scoping is done for you.","(""DBControlBase"", ""The doExecute method can be overridden when the class DBControlBase is extended."", ""doExecute""); (""DBControlBase"", ""The doExecute method can be overridden when the class DBControlBase is extended."", ""doExecute"")"
"They can be called outside the Control.execute() method too, or inside a parent control.",NULL
"If your Control class implements an interface, you can implement a Dynamic Proxy which implements the same interface.","(""Control"", ""The Dynamic Proxy is described as implementing the same interface as the Control class, suggesting a clear relationship between them in terms of interface implementation."", ""Dynamic Proxy"")"
"When the execute() method is called on the control interface, this dynamic proxy will call the beginConnectionScope(), then call your controls execute() method, and finally the endConnectionScope().",NULL
The only difference is that you call beginTransactionScope() and endTransactionScope() instead.,"(""BeginTransactionScope"", ""These methods are related as they define the start and end of a transaction scope respectively"", ""EndTransactionScope"")"
"When a connection is obtained from the ScopingDataSource while inside a transaction scope, connection.setAutoCommit(false) is called.","(""ScopingDataSource"", ""The connection is obtained from the ScopingDataSource, indicating a relationship where the ScopingDataSource provides or manages the connection."", ""connection""); (""connection"", ""The connection uses the setAutoCommit method, indicating that setAutoCommit is called on the connection."", ""setAutoCommit"")"
"If an exception is thrown before the endTransactionScope() method is called, you should catch that exception and call abortTransactionScope(Exception) with that exception.",NULL
The first problem you run into when designing DAO classes is connection scoping.,"(""DAO"", ""class"")"
A naive implementation of a DAO class using JDBC to target a relational database might look like below (at least I have designed DAO's like this in the past).,NULL
Notice how the readPerson() method opens its own connection and closes it again once it is done.,NULL
You might also be able to hide connection closing from the domain logic by adding a close() method to the DAO.,"(""Close"", ""The close() method is part of the DAO class, intended for managing the closure of database connections."", ""DAO"")"
But somewhere in the domain logic you would have to call that close() method.,NULL
The method call daoFactory.beginConnectionScope() marks the beginning of a connection scope.,"(""DAOFACTORY"", ""This method is called on the DAOFACTORY class to begin a connection scope."", ""BEGINCONNECTIONSCOPE"")"
The method call daoFactory.endConnectionScope() ends the current connection scope and closes the connection associated with the scope.,NULL
This way neither of the DAO's need to have close() methods.,NULL
The methods beginTransaction() and endTransaction() mark the beginning and end of the transaction.,NULL
The beginTransaction() method will call connection.setAutoCommit(false) for the connection associated with the transaction scope.,"(""BeginTransaction"", ""The BeginTransaction method calls the SetAutoCommit method."", ""SetAutoCommit""); (""BeginTransaction"", ""The BeginTransaction method is associated with the Connection class."", ""Connection""); (""BeginTransaction"", ""The BeginTransaction method is associated with the Transaction Scope class."", ""Transaction Scope""); (""SetAutoCommit"", ""The SetAutoCommit method is used on the Connection class."", ""Connection""); (""BeginTransaction"", ""The BeginTransaction method calls the SetAutoCommit method."", ""SetAutoCommit""); (""BeginTransaction"", ""The BeginTransaction method is associated with the Connection class."", ""Connection""); (""BeginTransaction"", ""The BeginTransaction method is associated with the Transaction Scope class."", ""Transaction Scope""); (""SetAutoCommit"", ""The SetAutoCommit method is used on the Connection class."", ""Connection"")"
The endTransaction() method will attempt to commit the transaction and call setAutoCommit(false) again.,NULL
Notice the new method call in the catch-block of the transaction scope: daoFactory.abortTransaction(e).,NULL
This method call rolls the transaction back if an exception is thrown from any of the dao methods or from endTransaction().,NULL
"The DAO layer usually consists of a smaller set of classes, than the number of domain logic classes that uses it.","(""domain logic"", ""The domain logic classes use the DAO layer."", ""DAO layer"")"
"It is also a somewhat more controlled operation, since you can search for all DAO classes, and make sure they are changed to use the new persistence mechanism.","(""DAO"", ""Class"")"
"To solve the problems mentioned earlier, you can move some of the code to a DaoManager class.",NULL
Notice that the getPersonDao() method isn't synchronized even though it returns a kind of singleton.,"(""GetPersonDao"", ""The GetPersonDao method is related to Singleton as it is mentioned to return a 'kind of singleton.'"", ""Singleton"")"
"Rather than implementing a close() method in the DaoManager class, a template method will be added called executeAndClose().","(""DaoManager"", ""The method close is mentioned in relation to the DaoManager class as a potential implementation."", ""close""); (""DaoManager"", ""The method executeAndClose is described as a template method that will be added to the DaoManager class."", ""executeAndClose"")"
This instance then has it's execute() method invoked with the DaoManager itself as parameter.,"(""Execute"", ""The execute() method is invoked with DaoManager as a parameter, indicating a direct interaction between them."", ""DaoManager"")"
Now the scope of the connection is marked by the scope of the method call executeAndClose().,NULL
"Any exception handling related to the connection.close() call can be hidden away inside the executeAndClose() method, and reused throughout the application.",NULL
You can add a transaction() method similar to the executeAndClose() method which takes care of transaction management.,"(""Transaction"", ""Both methods handle transaction-related tasks, with executeAndClose() providing transaction management functions that transaction() may also implement or complement."", ""ExecuteAndClose"")"
"For instance, if both commit() and rollback() throws exceptions, both of these exception are not properly preserved or handled.",NULL
Using the transaction() method is analogous to using the executeAndClose() method:,NULL
This could be done by wrapping the call to transaction() inside the call to executeAndClose().,"(""Transaction"", ""The method 'Transaction' is wrapped inside the method 'ExecuteAndClose', indicating a functional relationship where 'ExecuteAndClose' calls 'Transaction'."", ""ExecuteAndClose"")"
"As you can see a DaoManager class can solve the problems of marking both connection life span and transaction boundaries, and automatically open and close connections and commit / rollback transactions.",NULL
"If you implement a base event listener class that all event listeners (or actions, or whatever your framework calls them) extend, you can put the DaoManager code in that class (or a subclass of the base class).","(""Base Event Listener"", ""The Base Event Listener is extended by the Event Listener."", ""Event Listener""); (""Base Event Listener"", ""The DaoManager code can be placed in the Base Event Listener class."", ""DaoManager"")"
Here is an example of a subclass that executes the persistence code marked in bold in the first code box in this section:,NULL
Now your domain logic class only contains the persistence code that is actually interesting.,"(""Domain Logic Class"", ""Class"")"
It may not always be possible or feasible to implement such a persistence action base class.,"(""Persistence Action Base"", ""class""); (""Persistence Action Base"", ""class"")"
It would be tempting to put that validation code inside the doPersistenceAction() method.,NULL
"But remember, a connection has been opened already when the DaoManager is instantiated, which happens before the doPersistenceAction() method is called.","(""DaoManager"", ""The class 'DaoManager' is related to the method 'doPersistenceAction' because the method is called after the 'DaoManager' is instantiated, indicating a usage relationship."", ""doPersistenceAction"")"
"Furthermore, if the validation fails and aborts the doPersistenceAction() method call, you have opened a connection without ever using it.","(""DoPersistenceAction"", ""The Connection class is related to the DoPersistenceAction method because the method call involves opening a connection."", ""Connection"")"
"If you are using a persistence API you will inject whatever class you obtain connections or their equivalents from (sessions in Hibernate, IDaos in Butterfly Persistence).","(""Persistence API"", ""The Persistence API is used to obtain connections or equivalents, which are represented by a class."", ""Class""); (""Class"", ""The class is used to obtain 'connections' indicating a structure that includes connection management."", ""Connections""); (""Persistence API"", ""Sessions in Hibernate refer to a concept linked to the Persistence API used for persistence."", ""Sessions""); (""Persistence API"", ""IDaos in Butterfly Persistence are components related to the Persistence API’s functionality."", ""IDaos"")"
"This is done to avoid obtaining the connection before the DaoCommand.execute() method is called, to postpone obtaining the connection as much as possible.",NULL
"Inside the DaoCommand.execute() method the getPersonDaoTx() will be called, and then getConnectionTx() will be called, and then connection.setAutoCommit(false) will be called at that time.","(""DAOCOMMAND"", ""The EXECUTE method belongs to the DAOCOMMAND class."", ""EXECUTE""); (""EXECUTE"", ""The GETPERSONDAOTX method is called within the EXECUTE method."", ""GETPERSONDAOTX""); (""EXECUTE"", ""The GETCONNECTIONTX method is called within the EXECUTE method."", ""GETCONNECTIONTX""); (""GETCONNECTIONTX"", ""The SETAUTOCOMMIT method is called on the CONNECTION within the GETCONNECTIONTX context."", ""SETAUTOCOMMIT"")"
"After this code is executed, you can now access the cookies in the cookieMap using the cookie names as keys (cookieMap.get(""cookieName"")).",NULL
"Second, it sets the expiration to 24 hours using the setMaxAge() method.",NULL
"Cookies are most often used to store user specific information, like e.g.","(""CookieManager"", ""The addCookie method is a function of the CookieManager class."", ""addCookie""); (""CookieManager"", ""The removeCookie method is a function of the CookieManager class."", ""removeCookie""); (""CookieManager"", ""The CookieManager class is part of the com.example.web package."", ""com.example.web"")"
The browser includes the Accept-Encoding HTTP header in requests sent to an HTTP server (e.g.,"(""Accept-Encoding"", ""The Accept-Encoding method is included in the HTTP headers of server requests, indicating its use within the context of the HTTP package."", ""HTTP"")"
That class is mapped to a set of URL's in the web.xml file.,NULL
"It does so by using a GZIPOutputStream internally, which is a standard Java class.","(""GZIPOutputStream"", ""GZIPOutputStream is a standard class within the Java package."", ""Java"")"
Remember to replace the class name with the fully qualified name of your own GZip Servlet filter class.,"(""GZip Servlet filter"", ""Class""); (""GZip Servlet filter"", ""Class"")"
"In general, If no header exists with the name passed to getHeader(), null is returned.","(""GETHEADER"", ""GETHEADER returns NULL if no header exists with the specified name"", ""NULL"")"
"NOTE: You will have to call this method before calling any getParameter() method, because calling the getParameter() method on an HTTP POST request will cause the servlet engine to parse the HTTP request body for parameters.","(""Method"", ""The Method must be called before calling the GetParameter method."", ""GetParameter""); (""GetParameter"", ""Calling the GetParameter method causes the Servlet Engine to parse the HTTP request body for parameters."", ""Servlet Engine""); (""Method"", ""The Method must be called before calling the GetParameter method."", ""GetParameter""); (""GetParameter"", ""Calling the GetParameter method causes the Servlet Engine to parse the HTTP request body for parameters."", ""Servlet Engine"")"
"For instance, you can access context parameters set in the web.xml file, you can forward the request to other servlets, and you can store application wide parameters in the ServletContext too.","(""ServletContext"", ""ServletContext is described as a place where application-wide parameters, which include context parameters, can be stored."", ""context parameters"")"
In order to write binary data back to the browser you cannot use the Writer obtained from response.getWriter().,"(""response"", ""The 'getWriter' method is part of the 'response' class, likely used to obtain a Writer object."", ""getWriter"")"
Instead you have to use the OutputStream obtained from the response.getOutputStream() method.,"(""response"", ""The method getOutputStream is called on the response object."", ""getOutputStream""); (""getOutputStream"", ""The getOutputStream method returns an OutputStream instance."", ""OutputStream"")"
The javax.servlet.http.HttpServlet class is a slightly more advanced base class than the GenericServlet shown in the Simple Servlet example.,NULL
"The HttpServlet class reads the HTTP request, and determines if the request is an HTTP GET, POST, PUT, DELETE, HEAD etc.","(""HttpServlet"", ""The HttpServlet class determines if a request is an HTTP GET method."", ""HTTP GET""); (""HttpServlet"", ""The HttpServlet class determines if a request is a POST method."", ""POST""); (""HttpServlet"", ""The HttpServlet class determines if a request is a PUT method."", ""PUT""); (""HttpServlet"", ""The HttpServlet class determines if a request is a DELETE method."", ""DELETE""); (""HttpServlet"", ""The HttpServlet class determines if a request is a HEAD method."", ""HEAD"")"
"HTTP GET requests only, you will extend the HttpServlet class, and override the doGet() method only.",NULL
"The HttpServlet class has methods you can override for each HTTP method (GET, POST etc.).","(""HttpServlet"", ""The HttpServlet class contains methods that can be overridden."", ""methods""); (""methods"", ""GET is an HTTP method that can be overridden within the HttpServlet class."", ""GET""); (""methods"", ""POST is an HTTP method that can be overridden within the HttpServlet class."", ""POST"")"
A Java Servlet is just an ordinary Java class which implements the interface,"(""Java Servlet"", ""A Java Servlet is described as a Java class in the text."", ""Java class"")"
The easiest way to implement this interface is to extend either the class GenericServlet or HttpServlet.,"(""interface"", ""The GenericServlet class can be used to implement the interface."", ""GenericServlet""); (""interface"", ""The HttpServlet class can be used to implement the interface."", ""HttpServlet"")"
"When an HTTP request arrives at the web server, targeted for your Servlet, the web server calls your Servlet's service() method.","(""Servlet"", ""The 'service()' method belongs to the 'Servlet' class and is invoked when an HTTP request is targeted at the Servlet."", ""service()"")"
"The service() method then reads the request, and generates a response which is sent back to the client (e.g.",NULL
"You will need to run your Java Servlets inside a Servlet compatible ""Servlet Container"" (e.g.",NULL
"The RequestDispatcher class enables your servlet to ""call"" another servlet from inside another servlet.","(""RequestDispatcher"", ""The RequestDispatcher class is used to call another Servlet, indicating a functional relationship."", ""Servlet"")"
The above code obtains a RequestDispatcher targeted at whatever Servlet (or JSP) that is mapped to the URL /anotherUrl.simple.,NULL
You can call the RequestDispatcher using either its include() or forward() method:,NULL
By calling either the include() or forward() method the servlet container activates whatever Servlet is mapped to the URL the RequestDispatcher.,"(""Include"", ""The include() method is called by the servlet container to activate the relevant servlet."", ""Servlet Container""); (""Forward"", ""The forward() method is utilized by the servlet container to activate the corresponding servlet."", ""Servlet Container""); (""Requestdispatcher"", ""The RequestDispatcher is used by the servlet container to dispatch requests to the appropriate servlet."", ""Servlet Container""); (""Servlet"", ""The servlet container is responsible for managing instances of the Servlet class."", ""Servlet Container"")"
There is a little difference between calling the forward() and include() method.,"(""Forward"", ""Both Forward and Include are methods being compared in terms of their functionality."", ""Include"")"
"The forward() method intended for use in forwarding the request, meaning after the response of the calling servlet has been committed.","(""Forward()"", ""Forward() is described as a method in the given text."", ""Method"")"
"The include() method merges the response written by the calling servlet, and the activated servlet.",NULL
"This way you can achieve ""server side includes"" using the include().",NULL
The red boxes represent state (variables) that your servlet's service() method should be careful about accessing.,"(""Method"", ""The method is accessing state variables."", ""State"")"
"Of course it is not only the member variables and static variables inside the servlet class itself, that you need to be careful about accessing.","(""Servlet"", ""Class""); (""Servlet"", ""Class"")"
"Static variables in any other class which are accessed by your servlet, must also be thread safe.",NULL
In order to create a servlet filter you must implement the javax.servlet.Filter interface.,"(""Javax.Servlet.Filter"", ""Servlet Filter implements the Javax.Servlet.Filter interface, indicating a typical subclassing or interface implementation relationship between a specific filter implementation and the general filter interface it adheres to."", ""Servlet Filter"")"
"When the servlet filter is loaded the first time, its init() method is called, just like with servlets.",NULL
"Notice how the doFilter() method checks a request parameter, myParam, to see if it equals the string ""blockTheRequest"".","(""DOFILTER"", ""The doFilter method checks the myParam parameter to see if it equals a specific string."", ""MYPARAM"")"
"If not, the request is forwarded to the target of the request, by calling the filterChain.doFilter() method.",NULL
"You need to configure the servlet filter in the web.xml file of your web application, before it works.","(""Servlet Filter"", ""The servlet filter needs to be configured in the web.xml file as part of the web application setup."", ""Web.xml""); (""Servlet Filter"", ""The servlet filter needs to be configured in the web.xml file as part of the web application setup."", ""Web.xml"")"
With this configuration all requests with URL's ending in .simple will be intercepted by the servlet filter.,NULL
Before a servlet can be invoked the servlet container must first load its class definition.,NULL
"When the servlet class is loaded, the servlet container creates an instance of the servlet.",NULL
"When a servlet instance is created, its init() method is invoked.","(""Servlet"", ""The Init method is invoked on the Servlet class, indicating a method invocation relationship."", ""Init"")"
The init() method allows a servlet to initialize itself before the first request is processed.,NULL
You can specify init parameters to the servlet in the web.xml file.,NULL
"For every request received to the servlet, the servlets service() method is called.","(""Servlet"", ""The Service method is associated with the Servlet class, as it is called every time a request is received by the servlet."", ""Service"")"
"As long as the servlet is active in the servlet container, the service() method can be called.",NULL
"When a servlet is unloaded by the servlet container, its destroy() method is called.",NULL
"Once the servlet has been activated via the service() method, the servlet processes the request, and generates a response.",NULL
This is done in the web.xml file of your Java web application.,NULL
"To configure a servlet in the web.xml file, you write this:",NULL
"Here you give the servlet a name, and writes the class name of the servlet.","(""Servlet"", ""The Servlet class is named using a method, which is represented as 'Name' in this context."", ""Name""); (""Servlet"", ""The Servlet class is named using a method, which is represented as 'Name' in this context."", ""Name"")"
"In the above example, all URL's ending in .html are sent to the servlet.",NULL
You can pass parameters to a servlet from the web.xml file.,"(""Servlet"", ""A servlet is configured using parameters from the web.xml file, indicating a configuration or setup relationship."", ""Web.xml"")"
Here is how you read the init parameters from inside your servlet - in the servlets init() method:,"(""Init"", ""The init method is used within the Servlet class to read initialization parameters."", ""Servlet"")"
A servlets init() method is called when the servlet container loads the servlet for the first time.,"(""Init"", ""The init() method is specifically associated with the Servlet class as it is called in context to a servlet's lifecycle."", ""Servlet""); (""Servlet"", ""The Servlet class is managed by the Servlet Container, which loads it and calls the init() method."", ""Servlet Container"")"
"No one can access the servlet until the servlet has been loaded, and the init() method has been called successfully.",NULL
"Remember, the servlets init() method is called when the servlet is loaded.","(""Init"", ""The init() method is associated with Servlet as that's the context it is invoked in during the servlet lifecycle."", ""Servlet"")"
Here is how you access the parameter from inside an HttpServlet subclass:,NULL
In this text I will show you a simple unit test implemented using JUnit 4.8.1.,"(""JUnit"", ""JUnit is used to implement unit tests"", ""unit test"")"
First I will show you the class I want to test:,NULL
I have kept the class very simple to make it eaiser to understand what is going on.,"(""Class"", ""class"")"
To test this class I need a unit test that test each of its public methods.,"(""Class"", ""The class contains public methods that need to be tested."", ""Method"")"
"The class only has one public method, concatenate(), so all I need to test is this method.","(""Class"", ""The 'concatenate()' method belongs to the 'Class' entity."", ""Concatenate""); (""Class"", ""The 'concatenate()' method belongs to the 'Class' entity."", ""Concatenate"")"
Each test method usually tests a single method of the target class.,NULL
"Sometimes, a test method can test more than one method in the target class, and sometimes, if the method to test is big, you split the test into multiple test methods.",NULL
Here is the JUnit unit test that test that the concatenate() method:,NULL
"The unit test class is an ordinary class, with one method, testConcatenate().",NULL
In this method we compare the output of the called method (concatenate()) with the expected output.,"(""Concatenate"", ""method"")"
"In other words, we compare ""onetwo"" (expected output) with the value returned by the concatenate() method, which is kept in the variable result.",NULL
"The assertEquals() method is a statically imported method, which normally resides in the org.junit.Assert class.",NULL
Notice the static import of this class at the top of MyUnitTest.,"(""MyUnitTest"", ""class""); (""MyUnitTest"", ""class""); (""MyUnitTest"", ""class"")"
Using the static import of the method is shorter than writing Assert.assertEquals().,"(""Assert"", ""The method 'assertEquals' is a member or function of the class 'Assert', since it is accessed through 'Assert.assertEquals'."", ""assertEquals"")"
You can have as many test methods in a unit test class as you want.,"(""Unit Test Class"", ""Unit Test Class contains Test Methods"", ""Test Methods""); (""Unit Test Class"", ""Unit Test Class contains Test Methods"", ""Test Methods"")"
This is how simple a unit test can be with JUnit 4.8.2 .,"(""JUnit"", ""package"")"
"As you may have figured out from the simple test, most of the secret of implementing JUnit unit tests, is in the use of the assert methods in the class org.junit.Assert.",NULL
In this text I will take a closer look at what assert methods are available in this class.,NULL
"The code for this class is not shown, but you don't really need the code in order to understand how to test it.","(""Class"", ""class"")"
The assertArrayEquals() method will test whether two arrays are equal to each other.,"(""assertArrayEquals"", ""The assertArrayEquals method tests whether two arrays are equal."", ""arrays"")"
"To check for element equality, the elements in the array are compared using their equals() method.","(""Equals"", ""The equals method is used to compare elements for equality in an array."", ""Elements""); (""Equals"", ""The equals method is used to compare elements for equality in an array."", ""Elements"")"
"More specifically, the elements of each array are compared one by one using their equals() method.","(""equals()"", ""method""); (""equals()"", ""method""); (""equals()"", ""method"")"
"Second the myUnit.getTheStringArray() method is called, which is the method we want to test.","(""MyUnit"", ""The method GetTheStringArray() belongs to the MyUnit class."", ""GetTheStringArray""); (""MyUnit"", ""The method GetTheStringArray() belongs to the MyUnit class."", ""GetTheStringArray"")"
"Third, the result of the myUnit.getTheStringArray() method call is compared to the expected array.","(""MYUNIT"", ""The GETTHESTRINGARRAY method belongs to the MYUNIT class, as denoted by the method call myUnit.getTheStringArray()."", ""GETTHESTRINGARRAY"")"
"If the arrays are equal, the assertArrayEquals() will proceed without errors.","(""ASSERTARRAYEQUALS"", ""The assertArrayEquals() method is used to compare arrays for equality, suggesting it operates on Arrays."", ""ARRAYS""); (""ASSERTARRAYEQUALS"", ""The assertArrayEquals() method is used to compare arrays for equality, suggesting it operates on Arrays."", ""ARRAYS"")"
"The assertEquals() method compares two objects for equality, using their equals() method.","(""assertEquals"", ""The assertEquals method compares two objects."", ""objects""); (""assertEquals"", ""The assertEquals method uses the equals method."", ""equals"")"
"First the myUnit.concatenate() method is called, and the result is stored in the variable result.","(""CONCATENATE"", ""The method 'concatenate' belongs to the class 'myUnit'."", ""MYUNIT""); (""RESULT"", ""The result variable stores the output of the 'concatenate' method."", ""CONCATENATE"")"
"Second, the result value is compared to the expected value ""onetwo"", using the assertEquals() method.",NULL
"If the two objects are equal according to their implementation of their equals() method, the assertEquals() method will return normally.","(""Equals() Method"", ""The Assertequals() Method compares objects, likely using the Equals() Method for determining equality."", ""Assertequals() Method"")"
"Otherwise the assertEquals() method will throw an exception, and the test will stop there.","(""assertEquals"", ""The assertEquals method can throw an exception, which is a part of its functionality."", ""exception"")"
"This example compared to String objects, but the assertEquals() method can compare any two objects to each other.","(""assertEquals()"", ""The assertEquals() method can compare String objects, indicating a usage relationship."", ""String"")"
The assertEquals() method also come in versions which compare primitive types like int and float to each other.,NULL
"The assertTrue() and assertFalse() methods tests a single variable to see if its value is either true, or false.","(""assertTrue()"", ""Both methods are used to test a variable for Boolean values, relating them as complementary methods for assertions."", ""assertFalse()"")"
"As you can see, the method call to myUnit.getTheBollean() is inlined inside the assertTrue() assertFalse() calls.",NULL
"If the getTheBoolean() method returns true, the assertTrue() method will return normally.",NULL
"If the getTheBoolean() method returns false, the assertFalse() method will return normally.","(""GetTheBoolean"", ""AssertFalse depends on the return value of GetTheBoolean to determine its behavior"", ""AssertFalse"")"
"Of course the above test will fail in either the assertTrue() or assertFalse() call, if the getTheBoolean() method returns the same value in both calls.",NULL
The assertNull() and assertNotNull() methods test a single variable to see if it is null or not null.,"(""Assertnull"", ""Both methods test a single variable in relation to its null status."", ""Assertnotnull"")"
The call to myUnit.getTheObject() is inlined in the assertNull() and assertNotNull() calls.,"(""GetTheObject"", ""GetTheObject() is called within the assertNull() method."", ""AssertNull""); (""GetTheObject"", ""GetTheObject() is called within the assertNotNull() method."", ""AssertNotNull""); (""GetTheObject"", ""GetTheObject() is called within the assertNull() method."", ""AssertNull""); (""GetTheObject"", ""GetTheObject() is called within the assertNotNull() method."", ""AssertNotNull"")"
"If the myUnit.getTheObject() returns null, the assertNull() method will return normally.","(""GetTheObject"", ""The assertNull() method is used to check the result returned by getTheObject()."", ""AssertNull"")"
"If a non-null value is returned, the assertNull() method will throw an exception, and the test will be aborted here.",NULL
"The assertNotNull() method works oppositely of the assertNull() method, throwing an exception if a null value is passed to it, and returning normally if a non-null value is passed to it.","(""AssertNotNull"", ""Both methods are related as they perform opposite checks regarding null values."", ""AssertNull"")"
The assertSame() and assertNotSame() methods tests if two object references point to the same object or not.,"(""AssertSame"", ""Both methods are used to test if two object references point to the same object or not"", ""AssertNotSame"")"
It is not enough that the two objects pointed to are equals according to their equals() methods.,"(""Equals"", ""The text refers to the 'equals()' being a method, linking it to the concept of methods in general."", ""Methods"")"
The calls to myUnit.getTheSameObject() are inlined into the assertSame() and assertNotSame() method calls.,NULL
"If the two references points to the same object, the assertSame() method will return normally.","(""AssertSame"", ""method""); (""AssertSame"", ""method"")"
"If the two objects do not poin to the same object, the assertNotSame() method will return normally.","(""assertNotSame"", ""method""); (""AssertNotSame"", ""method"")"
The assertThat() method compares an object to an org.hamcrest.Matcher to see if the given object matches whatever the Matcher requires it to match.,"(""ASSERTTHAT"", ""The assertThat() method uses an instance of org.hamcrest.Matcher to compare and match objects."", ""ORG.HAMCREST.MATCHER"")"
"If you are testing a component that uses a database, e.g.",NULL
"a DAO class, you may want to test that the component really inserts data into the database, updates it etc.",NULL
It is just a standard Java class - nothing secret about it.,"(""Java"", ""class""); (""Java"", ""class"")"
"Exactly what methods you will put in your own TestData class, depends on the data used by your application.","(""TestData"", ""The TestData class contains or is implemented with methods."", ""methods"")"
"Also, you may want some of the methods to take parameters, rather than e.g.","(""Methods"", ""method""); (""Methods"", ""method"")"
"Once you have such a TestData class, you can use and reuse it in your unit tests.",NULL
"The TestData class can contain all kinds of business wise complex test data setups, which are then easy to setup in the database, once they have been programmed once.",NULL
"Below is a diagram illustrating a unit test, a unit (which is being tested), and a dependency which is some class used by the unit.",NULL
"If a method or field is private, only instances of that class can access that method or field.","(""Method"", ""A method belongs to a class and access is restricted to instances of this class."", ""Class""); (""Field"", ""A field is a member of a class, and access is restricted to instances of this class."", ""Class"")"
"A protected method or field, on the other hand, is also accessible to other classes in the same package, and for subclasses of the unit too.","(""Method"", ""The method is accessible to classes within the same package."", ""Package""); (""Field"", ""The field is accessible to classes within the same package."", ""Package""); (""Method"", ""Both are protected members and share accessibility rules."", ""Field"")"
"By encapsulating calls to external dependencies (components) in protected methods, you can create a subclass mock of the unit to test, and override these protected methods, to make them record information about whether they were called or not.","(""Class"", ""A class can contain methods, and encapsulating calls in methods allows subclassing and mocking."", ""Method"")"
"By ""boundary class"" I mean classes that plug into some framework.","(""Boundary Class"", ""class"")"
You may need the whole framework running in order to test your boundary class.,"(""Framework"", ""The boundary class is likely part of or dependent on the framework package for testing."", ""Boundary"")"
"Examples of boundary classes are Servlets, Struts actions, custom Swing components, EJB's etc.",NULL
Each of these boundary classes need a larger framework or server running in order to test them.,"(""Boundary Class"", ""Boundary classes require a larger framework to operate within."", ""Framework""); (""Boundary Class"", ""Boundary classes need a server running to be tested."", ""Server"")"
"A way to get around that is to move the business logic out of the boundary class, and into it's own component.",NULL
Make sure that the business logic component does not know anything about the boundary classes.,"(""Business Logic Component"", ""The business logic component should not know anything about boundary classes, indicating separation of concerns."", ""Boundary Classes"")"
"For instance, if your boundary class is a servlet, your business logic class should not know anything about the HttpRequest or HttpResponse interfaces.","(""Servlet"", ""The Servlet class interacts with the HttpRequest class to handle incoming requests."", ""HttpRequest""); (""Servlet"", ""The Servlet class generates and sends responses via the HttpResponse class."", ""HttpResponse""); (""Servlet"", ""The Servlet class interacts with the HttpRequest class to handle incoming requests."", ""HttpRequest""); (""Servlet"", ""The Servlet class generates and sends responses via the HttpResponse class."", ""HttpResponse"")"
"Preferably, the business logic class only takes the parameters it needs, as the types it needs.","(""Business Logic"", ""Class"")"
"When your business logic class is separated from the boundary class, you can test the business logic class separately.",NULL
"When the boundary classes are minimized to dispatch logic, the risk of errors in them are a lot smaller, in case you choose not to unit test them.",NULL
"For an example of this, see the Servlet Unit Testing text, in which I show how to unit test the business logic of a servlet, by moving the business logic to a separate class.","(""Servlet"", ""The business logic of the servlet is refactored into a separate class, relating the two."", ""Class"")"
In this text I will give a few suggestions to how you can test such classes.,"(""Classes"", ""Class"")"
Let's look at how to write a unit test for this class.,"(""Class"", ""class"")"
The ByteArrayInputStream is then used as input into the MyIOUnitTest.read() method.,"(""ByteArrayInputStream"", ""The ByteArrayInputStream class is used as input to the read method."", ""read""); (""MyIOUnitTest"", ""The read method belongs to the MyIOUnitTest class."", ""read""); (""ByteArrayInputStream"", ""The ByteArrayInputStream class is used as input to the read method."", ""read""); (""MyIOUnitTest"", ""The read method belongs to the MyIOUnitTest class."", ""read"")"
Here is the unit test which uses a ByteArrayOutputStream to collect the data written to the OutputStream passed to the MyIOUnit.write() method:,"(""BYTEARRAYOUTPUTSTREAM"", ""ByteArrayOutputStream is used to collect data written to the OutputStream."", ""OUTPUTSTREAM""); (""MYIOUNIT.WRITE()"", ""MyIOUnit.write() uses OutputStream as an argument."", ""OUTPUTSTREAM"")"
"Notice how the output.toByteArray() method is called, and passed into a String.","(""ToByteArray"", ""The method toByteArray() is used to convert data, which is then passed into an instance of the String class for further use."", ""String""); (""ToByteArray"", ""The method toByteArray() is used to convert data, which is then passed into an instance of the String class for further use."", ""String"")"
"If your input or output component uses a Reader or Writer instead of an InputStream or OutputStream, you can use the classes CharArrayReader and CharArrayWriter instead of ByteArrayInputStream and ByteArrayOutputStream.","(""CharArrayReader"", ""CharArrayReader is used when 'Reader' is required."", ""Reader""); (""CharArrayWriter"", ""CharArrayWriter is used when 'Writer' is required."", ""Writer""); (""ByteArrayInputStream"", ""ByteArrayInputStream is used as an alternative for 'InputStream'."", ""InputStream""); (""ByteArrayOutputStream"", ""ByteArrayOutputStream is used as an alternative for 'OutputStream'."", ""OutputStream"")"
You may also be able to use the StringReader and StringWriter classes in your unit tests.,NULL
"Unit testing means testing the smaller units of your application, like classes and methods.","(""Class"", ""Methods are typically defined within classes, making them related entities in the context of object-oriented programming."", ""Method"")"
"JUnit 4.8.2 ships with Hamcrest internally, so you don't have to download it, and add it yourself.","(""JUnit"", ""JUnit includes Hamcrest internally, indicating a dependency or bundled relationship."", ""Hamcrest""); (""JUnit"", ""JUnit includes Hamcrest internally, indicating a dependency or bundled relationship."", ""Hamcrest"")"
"Matchers are used with the org.junit.Assert.assertThat() method, which looks like this:","(""Matchers"", ""Matchers are used with the org.junit.Assert package."", ""Org.Junit.Assert""); (""Matchers"", ""Matchers are used with the assertThat() method."", ""Assertthat()""); (""Org.Junit.Assert"", ""The assertThat() method is part of the org.junit.Assert package."", ""Assertthat()"")"
"The assertThat() method just takes care of the ""plumming"" - meaning calling the Matcher with the given object.",NULL
"In the example above, the org.hamcrest.CoreMatchers.is() method is used to create a Matcher.",NULL
"The Matcher returned by is() returns true, if the two values compared are equal, and false if not.",NULL
"The is() method returns one matcher, and the not() method returns another.",NULL
The matcher returned by not() negates the matcher output of the matcher given as input.,"(""Not"", ""The 'not()' method returns a matcher that negates the output of the given matcher."", ""Matcher"")"
"In this case, it is the output of the matcher returned by the is() method, that is negated.",NULL
You can write your own matchers and plug into the assertThat() method.,"(""Matcher"", ""Matchers can be plugged into the assertThat() method to extend its functionality."", ""assertThat() method"")"
The static method matches() creates a new matcher and returns it.,NULL
You just embed the call to the static method matches() inside the assertThat() method.,"(""assertThat"", ""The method matches() is called inside the method assertThat(), indicating a functional relationship."", ""Matches"")"
In several situations mock testing is easier than testing with the real collaborators of a class.,"(""Class"", ""class""); (""Class"", ""class"")"
When testing a DAO you may use a mock java.sql.Connection and java.sql.ResultSet object with the DAO to check that the DAO makes the correct JDBC calls.,"(""DAO"", ""DAO uses java.sql.Connection for database connection"", ""Java.sql.Connection""); (""DAO"", ""DAO uses java.sql.ResultSet to manage query results"", ""Java.sql.ResultSet""); (""DAO"", ""DAO interacts with JDBC for database operations"", ""JDBC"")"
It is not visible from the value returned by the DAO if it remembered to call ResultSet.close() and Connection.close() before returning.,"(""DAO"", ""The class DAO is responsible for calling ResultSet.close() to ensure that the result set is properly closed."", ""ResultSet.close()""); (""DAO"", ""The class DAO is responsible for calling Connection.close() to ensure that the connection is properly closed."", ""Connection.close()"")"
The above situation was exactly the case for the GenericDao class in Mr. Persister.,"(""GenericDao"", ""The GenericDao class is mentioned as being part of the framework or context provided by Mr. Persister."", ""Mr. Persister"")"
Ideally the JDBC driver would detect that when calling the PreparedStatement.executeUpdate() method.,NULL
Therefore we decided to compare the PreparedStatement.getParameterMetaData().getParameterCount() with parameters.length before calling PreparedStatement.executeUpdate().,"(""PreparedStatement"", ""The method getParameterMetaData is called on the PreparedStatement class."", ""getParameterMetaData""); (""getParameterMetaData"", ""The method getParameterCount is called on the result of getParameterMetaData."", ""getParameterCount""); (""parameters"", ""The getParameterCount method is likely used to compare with the parameters length."", ""getParameterCount""); (""PreparedStatement"", ""The executeUpdate method is called on the PreparedStatement class."", ""executeUpdate"")"
"This works with the HSQLDB driver, but the MySQL driver haven't implemented the PreparedStatement.getParameterMetaData() method.","(""MySQL Driver"", ""The MySQL Driver has not implemented the PreparedStatement.getParameterMetaData method."", ""PreparedStatement.getParameterMetaData"")"
Fortunately the MySQL driver does throw an exception if the ?-signs and the parameters set doesn't match when calling PreparedStatement.executeUpdate().,NULL
"In the classpath element I add the output locations of my project code, and test code.","(""CLASSPATH ELEMENT"", ""The classpath element includes the output locations of the project code."", ""PROJECT CODE""); (""CLASSPATH ELEMENT"", ""The classpath element also includes the output locations of the test code."", ""TEST CODE"")"
In the test element I declare which unit test class to execute.,"(""Unit Test"", ""class""); (""Unit Test"", ""class"")"
The classpath stuff is the same as in the first example.,"(""Classpath"", ""The 'classpath' is compared or related to the 'first example' in terms of sameness."", ""Example"")"
"In this example I execute all files that has the text ""Test"" and "".java"" in their file name, regardless of what directory they are located in, recursively.",NULL
"What I usually do instead, is to ""move the code out of the boundary class"", as I have described in the text Design for Testability.",NULL
"Basically, I would try to push the main business logic in the servlet into a separate class which has no dependencies on the Servlet API's, if possible.",NULL
"So, I will take the concatenation logic and move into a separate class, which can be tested independent from the MyServlet class.","(""Concatenation Logic"", ""The concatenation logic is being moved into a separate class from the MyServlet class, indicating a relationship where the former is likely utilized within or related to the latter."", ""MyServlet"")"
Notice how the concatenation logic has been moved to a class called MyConcatenator.,NULL
Notice how the concatenate() method only refers to a string array.,NULL
Notice again how it was not necessary to reference any servlet classes or interfaces in this unit test.,"(""Servlet"", ""class"")"
By real objects I mean the objects the tested unit (class) will be using in the real application.,NULL
"If you have a class Calculator, that needs a dao (Data Access Object) object to load the data it needs from a database, then the dao object is a ""real object"".","(""Calculator"", ""Calculator depends on the dao object to load data from a database."", ""dao"")"
In order to test the Calculator class you will have to provide it with a dao object that has a valid connection to the database.,"(""Calculator"", ""The Calculator class requires a dao object to function properly, indicating they are related."", ""dao""); (""dao"", ""The dao object needs a valid connection to the database, suggesting a direct relationship."", ""database"")"
Instead you can provide the Calculator instance with a fake dao class which just returns the data you need for the test.,"(""Calculator"", ""Calculator uses the dao class to access or manipulate data."", ""dao"")"
The fake dao class will not actually read the data from the database.,"(""Fake Dao"", ""The Fake Dao class is related to the Database because it is mentioned as interacting with the database to read data, which is typical behavior for a class managing database operations."", ""Database"")"
A replacement for a real object which makes it easier to test the Calculator class.,"(""Calculator"", ""class"")"
Nor can you see if the connection.close() method was called before returning the value.,"(""Connection"", ""The close method is associated with the Connection object to close the connection."", ""Close"")"
"If you add a String ""myReturnValue"" as return value to the stub and then call connection.prepareStatement(""select * from houses"") which returns a PreparedStatement, you will get an exception.","(""connection"", ""The prepareStatement method is called on the connection object."", ""prepareStatement""); (""prepareStatement"", ""Calling the prepareStatement method returns a PreparedStatement object."", ""PreparedStatement"")"
"The String return value cannot be returned from the connection.prepareStatement(""...""); You will have to make sure yourself that the return values and called methods on the stub match.","(""Connection"", ""The method PrepareStatement is being called on the Connection class"", ""PrepareStatement""); (""PrepareStatement"", ""The PrepareStatement method does not return a String type"", ""String"")"
If the connection.close() method has not been called a java.lang.AssertionError is thrown.,"(""Connection"", ""The Close method belongs to the Connection class"", ""Close""); (""AssertionError"", ""The AssertionError class is part of the Java.Lang package"", ""Java.Lang"")"
You just provide the real collaborator to the MockFactory instead of an interface (class object).,"(""MockFactory"", ""The MockFactory requires an actual Collaborator to be supplied, suggesting a dependency or usage relationship."", ""Collaborator"")"
You can even turn the proxyConnection into a stub temporarily by adding a return value to the proxy via the mock.addReturnValue(...).,"(""Mock"", ""The method addReturnValue is associated with the class Mock, used for adding a return value in a proxy scenario."", ""AddReturnValue"")"
"Subclass mock objects is a mock object that is created by subclassing the class you want to test, and overriding some of its methods.","(""Subclass mock objects"", ""Subclass mock objects is described as a type of mock object."", ""mock object""); (""Subclass mock objects"", ""Subclass mock objects are created by subclassing a specific class."", ""class""); (""methods"", ""Methods are overridden in the process of subclassing the class."", ""class""); (""Subclass mock objects"", ""Subclass mock objects is described as a type of mock object."", ""mock object""); (""Subclass mock objects"", ""Subclass mock objects are created by subclassing a specific class."", ""class""); (""methods"", ""Methods are overridden in the process of subclassing the class."", ""class"")"
The class MyUnit is the class I am trying to unit test.,NULL
"In this unit test, I want to check if the MyUnit class calls the MyDependency class correctly.","(""MyUnit"", ""The MyUnit class calls the MyDependency class, indicating a dependency relationship."", ""MyDependency"")"
"The first thing to do is to refactory the MyUnit class, so that all calls to the MyDependency class are encapsulated in their own methods.","(""MyUnit"", ""MyUnit class calls methods from the MyDependency class"", ""MyDependency"")"
"Notice how the two calls to MyDependency.callOne() and MyDependency.callTwo() are now encapsulated in two protected methods, callOne() and callTwo().","(""MyDependency"", ""MyDependency is the class that has the method callOne."", ""callOne""); (""MyDependency"", ""MyDependency is the class that has the method callTwo."", ""callTwo"")"
The second step is to create a subclass mock of the MyUnit class.,NULL
Here is a unit test method that uses the MyUnitMock class:,NULL
"Third, assertions are made about whether the callOne() and callTwo() method were invoked.",NULL
"As you can see, it is possible to test almost all of a class by using subclass mocks, as described above.",NULL
"There are, however, situations where it works better to use a completely separate mock dependency object with the original class instead.",NULL
"If the throwIllegalArgumentException() method returns normall, then this fail() call is executed, causing the test to fail.",NULL
"Correspondingly, if the throwIllegalArgumentException() method throws the expected IllegalArgumentException, it is caught in the catch-clause, and ignored.","(""ThrowIllegalArgumentException"", ""The method ThrowIllegalArgumentException is related to the class IllegalArgumentException because it throws an instance of this exception class."", ""IllegalArgumentException"")"
"Instead you want users trying to access your web app to see a nice ""This web app is down for maintenance..."" page.","(""This Web App"", ""The class 'This Web App' is connected to the class 'Maintenance Page' because the web app displays the maintenance page when it is down."", ""Maintenance Page"")"
"A ""This web app is down for maintenance..."" page lets them know that the down time is controlled and expected.",NULL
Here is how the web.xml configuration looks for such a setup:,NULL
"For instance, imagine that a user sends a request that takes 1 minute to process (e.g.",NULL
"I've posted the full solution including the servlet filter Java code, the web.xml configuration, the maintenance message page and the maintenance GUI page, for your convenience below.",NULL
"Apparently the field name ""comment"" caused the text (""Comment..."") in the textarea not to show up in Firefox... weird, right...?!",NULL
"In order to get a Java web server or servlet container to run your Java web application, you need to package the resources inside it (servlets, JSP's etc.)",NULL
... then the index.jsp page will be accessible at the URL,"(""Index.jsp"", ""Package"")"
"For instance, if you create a subdirectory called layout, and put a file inside it called theLayout.jsp, then you could access that file from the outside, via this URL:",NULL
"Inside the WEB-INF directory there are two important directories (classes and lib, and one important file (web.xml).","(""WEB-INF"", ""The 'classes' directory is inside the 'WEB-INF' directory."", ""classes""); (""WEB-INF"", ""The 'lib' directory is inside the 'WEB-INF' directory."", ""lib""); (""WEB-INF"", ""The 'web.xml' file is inside the 'WEB-INF' directory."", ""web.xml"")"
"The web.xml file contains information about the web application, which is used by the Java web server / servlet container in order to properly deploy and execute the web application.",NULL
"For instance, the web.xml contains information about which servlets a web application should deploy, and what URL's they should be mapped to.","(""Web.xml"", ""Web.xml contains configuration details about servlet deployment and their URL mapping in web applications."", ""Servlets""); (""Web.xml"", ""Web.xml contains configuration details about servlet deployment and their URL mapping in web applications."", ""Servlets"")"
I will not get into more detail about the web.xml file here.,NULL
The classes directory contains all compiled Java classes that are part of your web application.,NULL
"The classes should be located in a directory structure matching their package structure, just like if you were to run them directly from the commandline, or package them in a JAR file.","(""Classes"", ""Classes are organized into a directory structure that matches their package structure"", ""Package"")"
"You could, however, also put your own classes into a JAR file, and locate it here, rather than putting those classes in the classes directory.","(""Classes"", ""Classes can be bundled into a JAR package for distribution or deployment"", ""JAR"")"
Perl or C. A Servlet is an ordinary Java class that implements a special Servlet interface.,"(""Servlet"", ""A Servlet is a class that implements the Servlet interface"", ""Servlet"")"
"Here is a small servlet and JSP example to better illustrate the difference: public void service(ServletRequest request, ServletResponse response){ PrintWriter writer = ((HttpServletResponse) response)).getWriter(); writer.write(""<html>""); writer.write(""<body>""); writer.write(""<table>""); for(int i=0; i<10; i++){ writer.write(""<tr><td>""); writer.write("""" + i); writer.write(""</td></tr>""); } writer.write(""</table>""); writer.write(""</body>""); writer.write(""</html>""); } <html> <body> <table> <% for(int i=0; i<10; i++){ %><tr><td><%=i%></td></tr><% } %> </table> </body> </html> As you can see, the JSP example is much shorter than the Servlet example, and it is much easier to get an overview of the HTML.","(""ServletRequest"", ""The 'service' method takes 'ServletRequest' as a parameter, indicating a direct use in handling HTTP requests."", ""service""); (""ServletResponse"", ""The 'service' method takes 'ServletResponse' as a parameter, indicating a direct use in handling HTTP responses."", ""service""); (""HttpServletResponse"", ""The 'getWriter' method is called on an object cast to 'HttpServletResponse', demonstrating its method linkage."", ""getWriter""); (""PrintWriter"", ""The 'PrintWriter' class is used to obtain a writer instance that calls the 'write' method to output HTML content."", ""write"")"
This is illustrated below: component.control --> component.control --> component.control --> component.control --> component.control component.view --> component.view --> component.view --> component.view --> component.view First all components in the hierarchy executes their control logic (domain logic).,"(""COMPONENT.CONTROL"", ""COMPONENT.CONTROL represents control logic which may influence or interact with COMPONENT.VIEW, which represents the view logic in the system hierarchy."", ""COMPONENT.VIEW"")"
A Servlet is an ordinary Java class that implements a special Servlet interface.,NULL
JCTools is an open source toolkit and is released under the Apache License 2.0.,NULL
"A Fat JAR is a single JAR file that contains all the compiled Java classes from your project, and all compiled Java classes from all JAR files your project depends on (see Maven Dependencies).",NULL
"Fat JARs are handy when you need to build an executable JAR file, e.g.",NULL
"This makes execution much easier, because you don't have to list all the JAR files your microservice depends on, on the classpath.",NULL
"When you execute Maven package phase with the maven-assembly-plugin configuration shown earlier, Maven will output a Fat JAR in the target directory, into which Maven outputs all of its other build products (e.g.","(""Maven"", ""Maven uses the Maven-assembly-plugin during the package phase to create output like a Fat JAR."", ""Maven-assembly-plugin""); (""Maven-assembly-plugin"", ""The Maven-assembly-plugin is used to output a Fat JAR in the target directory."", ""JAR"")"
"The list contains more than 1.300 Maven archetypes, so it is not really that easy to find the archetype you need.",NULL
"Too look at the list of available Maven archetypes, you can pipe the output into a file, and open that file in e.g.",NULL
"Keep in mind, that when you execute the clean goal of Maven, the target directory is removed, meaning you lose all compiled classes from previous builds.","(""Clean"", ""The clean class is responsible for removing the target directory."", ""Target Directory""); (""Maven"", ""The clean class is a part of the Maven package."", ""Clean"")"
"That means, that Maven will have to build all of your project again from scratch, rather than being able to just compile the classes that were changed since last build.",NULL
"However, sometimes it can be nice to have a clean, fresh build, e.g.",NULL
The pom.xml file is the Maven POM file (Project Object Model).,"(""Maven"", ""POM is part of the Maven build system for managing project dependencies."", ""POM"")"
The .mvn directory is a directory where you can put some Maven configuration files.,"(""Maven"", ""package"")"
One of these Maven configuration files is the jvm.config file which can be used to configure the Java VM that is used by Maven to build your project.,"(""JVM.CONFIG"", ""The jvm.config file is used to configure the Java VM."", ""JAVA VM""); (""JAVA VM"", ""The Java VM is utilized by Maven to build projects."", ""MAVEN"")"
The resource files will be available for loading via the classpath.,"(""Classpath"", ""class""); (""Classpath"", ""class"")"
The default Java compiler version used by Maven is Java 1.5 .,NULL
"To make Maven compile your Java code with a newer version of the Java compiler, you need to specify the Java compiler explicitly in your project's POM file (pom.xml).","(""Maven"", ""Maven can be configured to compile Java code."", ""Java""); (""Java"", ""The POM file specifies the Java compiler settings."", ""POM"")"
Notice also that the version of the Maven Java compiler plugin has changed from 3.6.1 to 3.8.0 .,NULL
The first version of this Maven tutorial is based on Maven 3.6.3.,NULL
The POM file is named pom.xml and should be located in the root directory of your project.,NULL
"This command first executes the clean build life cycle, which removes compiled classes from the Maven output directory, and then it executes the install build phase.","(""Maven"", ""Maven utilizes 'compiled classes' as part of its output management."", ""Classes""); (""Build"", ""The build life cycle includes a sequence of life cycle phases."", ""Life Cycle""); (""Maven"", ""Maven utilizes 'compiled classes' as part of its output management."", ""Classes""); (""Build"", ""The build life cycle includes a sequence of life cycle phases."", ""Life Cycle"")"
These JAR files are needed on the classpath when you compile your project code.,NULL
"The example above needs the org.jsoup group's jsoup artifact in version 1.7.1, and the junit group's junit artifact in version 4.8.1.","(""JSoup"", ""Both are artifacts required for different purposes; JSoup for parsing and JUnit for testing"", ""JUnit"")"
"Thus Maven only needs to download the dependencies once, even if multiple projects depends on them (e.g.","(""Maven"", ""package"")"
Your Maven settings file is also located in your user-home/.m2 directory and is called settings.xml.,NULL
"The clean life cycle handles everything related to removing temporary files from the output directory, including generated source files, compiled classes, previous JAR files etc.",NULL
One way to choose what profile is being executed is in the settings.xml file.,"(""Settings.xml"", ""File"")"
"You do so by creating a simple Java class that extends a special Maven class, and then create a POM for the project.","(""Java Class"", ""A Java class extends a Maven class, indicating a subclass-superclass relationship."", ""Maven Class""); (""POM"", ""POM (Project Object Model) is related to the Java class as it serves as a configuration file for Java projects using Maven."", ""Java Class"")"
It is the argument -Dmaven.test.skip=true that makes Maven skip the tests completely.,NULL
To configure the Maven Surefire plugin to enable Java preview features you need the following configuration in your Maven POM file - in the <build><plugins>...</plugins></build> section:,NULL
To publish a JAR file with compiled Java classes to the Maven central repository you need to go through set of steps.,NULL
You can find more information about creating and publishing a public key / priate key pair from the Sonatype producers page: https://central.sonatype.org/pages/producers.html.,"(""Sonatype"", ""package"")"
"For a full POM file, check out the pom.xml in this github repository: RION Ops for Java GitHub Repository",NULL
From Maven 3.3 and forward you can set the memory limits in a file called jvm.config located in the .mvn directory inside your project directory.,NULL
Inside the jvm.config file you need the following settings to be able to control the memory limits of Maven during a Maven build:,"(""Maven"", ""The text refers to controlling the memory limits of Maven during a Maven build."", ""Maven"")"
"Once you have created the project root directory, create a file called pom.xml inside the directory.","(""Project Root Directory"", ""The file Pom.xml is created inside the Project Root Directory, indicating a containment relationship."", ""Pom.xml"")"
"When you have created the pom.xml file inside the project root directory it is a good idea to just test that Maven works, and that Maven understands the pom.xml file.",NULL
"To test the pom.xml file, open a command prompt and change directory (cd) into the project root directory.",NULL
Inside the helloworld directory (java package) insert a file named HelloWorld.java.,"(""Helloworld"", ""The Helloworld package contains the HelloWorld class."", ""Helloworld"")"
Maven will compile the Java source file and create a JAR file containing the compiled Java class.,NULL
"Inside the target directory you will find the finished JAR file, as well as lots of temporary files (e.g.",NULL
The Mem Ops Bytes class represents a sequence of bytes from a byte array.,"(""Mem Ops Bytes"", ""The class 'Mem Ops Bytes' is related to 'byte array' as it represents a sequence of bytes originating from a byte array."", ""byte array"")"
"To avoid fragmenting the Java heap with Bytes instances, the Bytes class is designed to be obtained from an ObjectPool .","(""Bytes"", ""The Bytes class is designed to be obtained from the ObjectPool, indicating a relationship where ObjectPool is likely a provider or manager of Bytes instances."", ""ObjectPool""); (""Bytes"", ""The Bytes class is designed to be obtained from the ObjectPool, indicating a relationship where ObjectPool is likely a provider or manager of Bytes instances."", ""ObjectPool"")"
"To use the Bytes class effectively you should create a BytesAllocatorAutoDefrag, a BytesFactory and an ObjectPool .","(""BytesAllocatorAutoDefrag"", ""BytesAllocatorAutoDefrag is used to allocate and manage memory for Bytes objects."", ""Bytes""); (""BytesFactory"", ""BytesFactory is used to create instances of Bytes."", ""Bytes""); (""ObjectPool"", ""ObjectPool manages a collection of Bytes objects to optimize memory use."", ""Bytes"")"
To obtain a Bytes instance from the ObjectPool you simply call the ObjectPool instance() method.,"(""ObjectPool"", ""The instance method is called on the ObjectPool class to obtain a Bytes instance."", ""instance""); (""Bytes"", ""Bytes is an instance obtained from the ObjectPool class, indicating a relationship between the two."", ""ObjectPool"")"
Calling free() will free the Bytes instance back to the ObjectPool and the allocated bytes back to the BytesAllocatorAutoDefrag.,"(""free"", ""The method 'free' is used with the 'Bytes' class to release its instance back to the pool."", ""Bytes""); (""Bytes"", ""The 'Bytes' instance is returned back to the 'ObjectPool', indicating a management relationship."", ""ObjectPool""); (""Bytes"", ""The allocated bytes from 'Bytes' class are handled by 'BytesAllocatorAutoDefrag', indicating an allocation management relationship."", ""BytesAllocatorAutoDefrag"")"
"In this section I will try to give you a few visual use case examples that shows how to use the Bytes class, and its fields.","(""Bytes"", ""The text discusses how to use the Bytes class within various examples."", ""class"")"
"The use cases are actually quite similar in how they use the Bytes class, even if they are doing different things.",NULL
The Mem Ops BytesAllocatorAutoDefrag class is capable of allocating smaller sections (blocks) of a bigger byte array.,NULL
"When you free a byte array section, the BytesAllocatorAutoDefrag class will automatically defragment its internal big byte array so the freed section is joined with adjacent free sections to form a larger free section from which future sections can be allocated.",NULL
To use the BytesAllocatorAutoDefrag class you must first create an instance of it.,"(""BytesAllocatorAutoDefrag"", ""class"")"
"In order to allocate a block (section) of bytes from the underlying byte array, you call the allocate() method.",NULL
"Once allocated, no other allocate() call can allocate the same block until it has been freed.","(""Allocate()"", ""method""); (""Allocate()"", ""method"")"
"The allocate() method returns the offset into the big, underlying byte array where the allocated block starts.",NULL
You can get a reference to the underlying byte array via the getData() method.,"(""getData"", ""method"")"
"Once you have allocated a block of bytes from the BytesAllocatorAutoDefrag you can access it via the data array, from the offset returned by allocate() and until offset + length - 1.",NULL
The free() method takes the start and end offset of the block to free.,"(""Free"", ""Method"")"
The Mem Ops BytesAllocatorManualDefrag class is capable of allocating smaller sections (blocks) of a bigger byte array.,"(""Mem Ops BytesAllocatorManualDefrag"", ""The class allocates smaller sections of a bigger byte array"", ""byte array"")"
"When you free a byte array section, the ByteArrayAllocatorAutoDefrag class will mark it as free, but will not defragment the underlying byte array until you explicitly to tell it to.",NULL
To use the BytesAllocatorManualDefrag class you must first create an instance of it.,"(""BytesAllocatorManualDefrag"", ""An instance is typically created for classes to utilize their methods and properties."", ""instance"")"
"Once you have allocated a block of bytes from the BytesAllocatorManualDefrag you can access it via the data array, from the offset returned by allocate() and until offset + length - 1.","(""BytesAllocatorManualDefrag"", ""The method 'allocate' is used in conjunction with the class 'BytesAllocatorManualDefrag' for allocating bytes."", ""allocate""); (""allocate"", ""The method 'allocate' determines the offset within the 'data' array for accessing the allocated block of bytes."", ""data"")"
To defragment the free blocks you call the defragment() method of the BytesAllocatorManualDefrag .,"(""BytesAllocatorManualDefrag"", ""The defragment method is a part of the BytesAllocatorManualDefrag class."", ""defragment""); (""BytesAllocatorManualDefrag"", ""The defragment method is a part of the BytesAllocatorManualDefrag class."", ""defragment"")"
It is during such idle times you should call defragment() .,NULL
"If your system is constantly very busy, there may never be an idle period during which to call defragment().","(""Defragment()"", ""Method""); (""Defragment()"", ""Method"")"
Calling defragment() will most likely result in a longer pause than if you immediately defragment free blocks like the ByteArrayAllocatorAutoDefrag does.,NULL
"Systems that need to create high numbers of objects at a rapid pace, but do not need all of these objects at the same time, can benefit from using object pools rather than instantiating the objects using the Java new XYZObject() .","(""Java"", ""XYZObject is instantiated using Java, indicating that Java serves as the programming language or platform in which XYZObject exists."", ""XYZObject"")"
The Bytes class represents a byte sequence allocated from a shared byte array.,"(""Bytes"", ""The Bytes class represents a byte sequence."", ""byte sequence""); (""byte sequence"", ""The byte sequence is allocated from a byte array."", ""byte array"")"
The Mem Ops ObjectPool class is capable of pooling instances of objects which can be reused.,"(""MEM OPS OBJECTPOOL"", ""CLASS"")"
To use the Mem Ops ObjectPool you must first create an instance of the com.nanosai.memops.objects.ObjectPool class.,NULL
Notice that the ObjectPool class constructor takes two parameters: The capacity and an IObjectFactory implementation.,"(""ObjectPool"", ""The ObjectPool class constructor takes an IObjectFactory implementation as a parameter."", ""IObjectFactory"")"
"As you can see, the IObjectFactory only contains a single method named instance().",NULL
The type returned from the instance() method is decided by you when you implement the IObjectFactory interface.,NULL
You free an object instance for reuse by calling the ObjectPool free() method.,"(""ObjectPool"", ""The free method is a part of the ObjectPool class, used to release an object instance for future reuse."", ""free"")"
"You just tell what module that contains the main class to run, and ModRun resolves and loads all its dependencies too.",NULL
"By loading the classes of a module with its own ClassLoader, ModRun can control what classes are visible to each module.","(""ClassLoader"", ""ModRun uses ClassLoader to control class visibility for each module"", ""ModRun"")"
A module can only see the classes from itself or from its dependencies (modules) and transitive dependencies.,"(""Module"", ""A module can see the classes from itself or its dependencies."", ""Class""); (""Module"", ""Modules have dependencies and transitive dependencies."", ""Module"")"
"A module cannot see classes from modules ""above"" itself in the dependency graph.","(""Module"", ""A module contains or is associated with classes."", ""Classes"")"
The JVM will consider classes loaded from the two different versions of the API as different classes because they are loaded with different ClassLoader instances.,"(""JVM"", ""The JVM interacts with ClassLoader instances to differentiate between classes from different versions of the API."", ""ClassLoader""); (""API"", ""The API is involved in the context where ClassLoader instances differentiate classes loaded from different versions."", ""ClassLoader"")"
Each instance of the module have the classes loaded from its dependency graph isolated from the other instances of the same module (at least it can - if you want to).,NULL
Loading the classes from each module with its own ClassLoader makes application multi tenancy easier.,"(""ClassLoader"", ""A ClassLoader is used to load classes from a module, indicating a relationship between the two entities."", ""module"")"
"ModRun can load multiple applications into the same JVM at the same time, and have their classes be completely isolated from each other, so one application cannot access the classes of another application.","(""Class"", ""Different instances of Class are completely isolated from each other in the JVM, as one application cannot access the classes of another application."", ""Class"")"
"Here is an example that creates a module from a Maven repository, loads a class from the module, creates an instance of the class and calls a method on the instance via reflection:","(""Module"", ""An instance is created from the module."", ""Instance""); (""Instance"", ""A method is called on the instance via reflection."", ""Method"")"
Installing Netty in your Java project only requires that you download the Netty JAR files and include them on the classpath.,NULL
"A Netty EventLoop is a loop that keeps looking for new events, e.g.","(""EventLoop"", ""class"")"
"Third, the NioServerSocketChannel class instance is set on the ServerBootstrap instance.",NULL
Its method initChannel() is called whenever a new incoming TCP connection is accepted by the TCP server.,"(""initChannel"", ""The method initChannel is used within the TCP context to handle incoming connections."", ""TCP"")"
"As you can see, the ChannelInitializer is added to the ServerBootstrap using the childHandler() method.","(""ChannelInitializer"", ""The ChannelInitializer is added to the ServerBootstrap, indicating a configuration or setup relationship."", ""ServerBootstrap""); (""childHandler"", ""The childHandler() method is used on the ServerBootstrap, indicating a functional relationship."", ""ServerBootstrap"")"
The serverBootstrap.bind() method returns a ChannelFuture which can be used to know when the binding of the server (binding to local address and TCP port) is done.,"(""ServerBootstrap"", ""The method 'bind' is a member of the 'ServerBootstrap' class, which indicates it is likely a method that helps in server setup."", ""bind""); (""bind"", ""The 'bind' method returns a 'ChannelFuture', indicating a relationship of function return type."", ""ChannelFuture"")"
"By calling sync() on the ChannelFuture the main thread that creates the server waits until the server has started, before continuing.","(""sync"", ""The method sync() is called on the ChannelFuture class."", ""ChannelFuture"")"
The channelRead() method is called whenever data is received from the SocketChannel the HelloServerHandler instance is attached to.,NULL
"As you can see, the channelRead() responds with ""Hello "" + whatever the client sent to the server.",NULL
The channelReadComplete() method is called when there is no more data to read from the SocketChannel.,"(""CHANNELREADCOMPLETE"", ""The method is invoked when there is no more data to read from the SocketChannel, indicating an interaction between the method and the class."", ""SOCKETCHANNEL"")"
The exceptionCaught() method is called if an exception is thrown while receiving or sending data from the SocketChannel.,NULL
That means that you create a Java application with a class with a main() method and inside that application you create one of the Netty servers.,NULL
The RION Ops RionObjectReader class can read a RION Object field into a Java object.,NULL
The easiest way to create an instance of the RionObjectReader is via the RionObjectReaderBuilder class.,"(""RionObjectReaderBuilder"", ""RionObjectReaderBuilder is used to create an instance of RionObjectReader"", ""RionObjectReader"")"
This class makes it easier to configure and create a RionObjectReader instance.,NULL
Here is an example of creating a RionObjectReader via the RionObjectReaderBuilder class:,"(""RionObjectReader"", ""RionObjectReader is created via the RionObjectReaderBuilder class"", ""RionObjectReaderBuilder"")"
The RionObjectReader readCyclic() method reads a cyclic object graph stored as RION in a byte array.,"(""RionObjectReader"", ""RionObjectReader contains the method readCyclic()"", ""readCyclic()""); (""RionObjectReader"", ""RionObjectReader reads data formatted as RION"", ""RION""); (""RionObjectReader"", ""RionObjectReader contains the method readCyclic()"", ""readCyclic()""); (""RionObjectReader"", ""RionObjectReader reads data formatted as RION"", ""RION"")"
The RION Ops RionObjectWriter class makes it easy to write Java objects as a RION field to a byte array.,"(""RionObjectWriter"", ""RionObjectWriter belongs to the RION Ops package"", ""RION Ops""); (""RionObjectWriter"", ""RionObjectWriter uses the write method to handle Java objects as a RION field"", ""write"")"
"To use the RionObjectWriter you must first create an instance of the RionObjectWriter class, com.nanosai.rionops.rion.object.RionObjectWriter.","(""RionObjectWriter"", ""The RionObjectWriter class is referred to as both the name of the class and an instance."", ""RionObjectWriter""); (""RionObjectWriter"", ""The RionObjectWriter class is part of the package com.nanosai.rionops.rion.object."", ""com.nanosai.rionops.rion.object.RionObjectWriter"")"
The easiest way to create a RionObjectWriter instance is via the RionObjectWriterBuilder class.,"(""RionObjectWriterBuilder"", ""The RionObjectWriterBuilder class is used to create an instance of the RionObjectWriter class."", ""RionObjectWriter"")"
"These examples build a RionObjectWriter which will serialize all fields (private, protected, default and public) found in the Pojo class to RION.","(""RionObjectWriter"", ""RionObjectWriter is capable of serializing data, which suggests a method-type relationship."", ""serialize""); (""Pojo"", ""RionObjectWriter serializes all fields found in the Pojo class, indicating a source-target relationship."", ""RionObjectWriter""); (""RionObjectWriter"", ""RionObjectWriter is capable of serializing data, which suggests a method-type relationship."", ""serialize""); (""Pojo"", ""RionObjectWriter serializes all fields found in the Pojo class, indicating a source-target relationship."", ""RionObjectWriter"")"
"Once created, the RionObjectWriter instance then only serialize objects of the given class.","(""RionObjectWriter"", ""RionObjectWriter creates an Instance to serialize objects"", ""Instance"")"
To serialize objects of multiple classes you will have to create a RionObjectWriter for each class.,"(""RionObjectWriter"", ""A RionObjectWriter is created for each class to serialize objects"", ""Classes"")"
Note: You only need one RionObjectWriter per root class you want to serialize.,NULL
"If a given class represents an object graph consisting of other classes referenced from within the root class (or any of its field's classes recursively), all of these classes will be serialized too.","(""Class"", ""A given class represents an object graph, indicating a composition or association relationship."", ""Object Graph""); (""Object Graph"", ""The object graph consists of other classes, such as the root class, forming a hierarchical structure."", ""Root Class""); (""Class"", ""A given class represents an object graph, indicating a composition or association relationship."", ""Object Graph""); (""Object Graph"", ""The object graph consists of other classes, such as the root class, forming a hierarchical structure."", ""Root Class"")"
"To elaborate, in the example above, if the Pojo class contained fields of class Pojo2 and Pojo3 internally, these would be serialized too because they are part of an object graph rooted by a Pojo object.","(""Pojo"", ""Pojo contains fields that are instances of Pojo2, indicating a composition or aggregation relationship."", ""Pojo2""); (""Pojo"", ""Pojo contains fields that are instances of Pojo3, indicating a composition or aggregation relationship."", ""Pojo3"")"
The RionObjectWriter contains an writeAcyclic() and writeCyclic() method for these purposes.,"(""RionObjectWriter"", ""The method writeAcyclic is part of the RionObjectWriter class and is used for writing purposes."", ""writeAcyclic""); (""RionObjectWriter"", ""The method writeCyclic is part of the RionObjectWriter class and is used for writing purposes."", ""writeCyclic"")"
The RionObjectWriter writeAcyclic() can write an acyclic object graph as RION into a byte array.,"(""RionObjectWriter"", ""The method 'writeAcyclic' is a function of the 'RionObjectWriter' class."", ""writeAcyclic"")"
"If the object is part of a cyclic (not acyclic) object graph, the writeAcyclic() method will enter an infinite recursion and eventually crash.","(""WriteAcyclic"", ""The method WriteAcyclic is mentioned in relation to cyclic object graphs, indicating they are part of the same context within the text."", ""Object Graph"")"
Here is an example of writing an object using the RionObjectWriter writeAcyclic() method:,"(""RionObjectWriter"", ""The method writeAcyclic is a member or function of the class RionObjectWriter."", ""writeAcyclic"")"
The RionObjectWriter writeCyclic() method can write a cyclic object graph as RION to a byte array.,NULL
Here is an example of writing a cyclic object graph to RION using the RionObjectWriter writeCyclic() method.,"(""RionObjectWriter"", ""The method writeCyclic is part of the RionObjectWriter class."", ""writeCyclic""); (""RION"", ""The RionObjectWriter class is used to work with RION, indicating it is related to the RION package."", ""RionObjectWriter"")"
"The RION Ops RionReader class, com.nanosai.rionops.rion.read.RionReader makes it easy to write RION fields from a Java byte array.",NULL
Setting a source byte array is done via the method setSource().,"(""SETTINGSOURCE"", ""The method setSource() is described as the action of setting a source byte array."", ""SETTINGSOURCE"")"
Here is an example of setting the source byte array on a RionReader via its setSource() method:,"(""RionReader"", ""The setSource method is an operation that belongs to the RionReader class, suggesting that it is used to set certain properties or behaviors of a RionReader instance."", ""setSource""); (""RionReader"", ""The setSource method is an operation that belongs to the RionReader class, suggesting that it is used to set certain properties or behaviors of a RionReader instance."", ""setSource"")"
"Third, the example loops as long as hasNext() returns true, and iterates through all the RION fields in the source byte array, one by one.","(""HasNext"", ""The method HasNext is likely used to iterate through RION fields, indicating a possible relationship between a method and a class in the given context."", ""RION"")"
You can read a RION Bytes field using the RionReader readBytes() method.,"(""RionReader"", ""The method readBytes() is associated with the class RionReader as it is a function belonging to that class."", ""readBytes"")"
The readBytes() method will read the bytes of the RION Bytes field into this byte array.,"(""ReadBytes"", ""The ReadBytes method interacts with the Bytes class by reading data from it."", ""Bytes""); (""ReadBytes"", ""The ReadBytes method is part of the RION package, which provides the context for this functionality."", ""RION"")"
Here is an example of reading a RION Bytes field with the readBytes() method:,"(""RION Bytes"", ""The readBytes() method reads a RION Bytes field."", ""ReadBytes""); (""RION Bytes"", ""The readBytes() method reads a RION Bytes field."", ""ReadBytes"")"
The value returned by the readBytes() method is the number of bytes read into the destination byte array.,"(""readBytes"", ""method""); (""readBytes"", ""method"")"
"The readBytes() method also comes in a version where you can specify the offset into the destination byte array to start writing the Bytes field value, and a maximal length (number of bytes) to read.","(""readBytes"", ""The readBytes method interacts with the Bytes field value by writing to it."", ""Bytes"")"
Here is an example of reading a RION Bytes field using that readBytes() method:,"(""RION"", ""The method readBytes() is used for reading a field from the RION package."", ""readBytes"")"
"This example tells the readBytes() method to start writing the Bytes field value into the destination array from offset 2, and to maximally read 10 bytes.",NULL
To read a RION Boolean field you can use the RionReader readBoolean() method.,NULL
Here is an example of reading RION Boolean field using the RionReader readBoolean() method:,"(""RionReader"", ""The readBoolean method is a function within the RionReader class."", ""readBoolean"")"
Here is an example of reading a Java Boolean object using the RionReader readBooleanObj() method:,"(""readBooleanObj()"", ""The method is utilized by or part of the RionReader class to read a Boolean object."", ""RionReader"")"
To read a RION Int64 field you can use the RionReader readInt64() method.,"(""RionReader"", ""The readInt64() method is a function provided by or used within the RionReader class."", ""readInt64""); (""RionReader"", ""The readInt64() method is a function provided by or used within the RionReader class."", ""readInt64"")"
Here is an example of reading a RION Int64 field using the RionReader readInt64() method:,NULL
Here is an example of reading a RION Int64 field into a Java Long object using the RionReader readInt64Obj() method:,"(""RionReader"", ""The method readInt64Obj is likely a method that belongs to the RionReader class since it's mentioned in conjunction with it for reading operations, indicating that it is a method provided by this class."", ""readInt64Obj""); (""readInt64Obj"", ""The readInt64Obj method is used for reading into a Java Long object, implicating a usage context within Java, connecting the method with this programming language environment."", ""Java"")"
These methods are named readFloat32() and readFloat64() Here are two examples of reading a RION Float field into a Java float and double variable:,NULL
Use the readFloat32Obj() or readFloat64Obj() methods if the RION Float field can be set to null in your concrete use case.,"(""ReadFloat32Obj"", ""Both methods are related as they perform similar functions with different specifications for Float32 and Float64."", ""ReadFloat64Obj"")"
The RionReader class has a method named readUtf8String() which can read a RION UTF-8 field into a Java String.,NULL
Here is an example of reading a RION UTF-8 field into a Java String with readUtf8String() :,"(""RION"", ""UTF-8 is a class format utilized within the RION package."", ""UTF-8""); (""Java String"", ""The method readUtf8String() returns a Java String."", ""readUtf8String()"")"
The readUtcCalendar() method of the RionReader class can read a RION UTC field as a Java Calendar instance.,NULL
When reading a composite RION field you need to use the RionReader moveInto() and moveOutOf() methods.,"(""RionReader"", ""The method moveInto is a member of the class RionReader."", ""moveInto""); (""RionReader"", ""The method moveOutOf is a member of the class RionReader."", ""moveOutOf"")"
"The moveInto() method will move the RionReader's internal state ""into"" the given RION field.","(""moveInto"", ""The 'moveInto' method affects the 'RionReader' class' internal state, indicating that moveInto is a method that operates on the class RionReader."", ""RionReader"")"
"That means, that the hasNext() method now returns true as long as the RION field you moved into has more nested fields.",NULL
"The moveOutOf() method moves the RionReader's internal state ""out of"" the given RION field.","(""MoveOutOf"", ""The moveOutOf method is associated with the RionReader class, as it modifies the internal state of the RionReader."", ""RionReader"")"
Now the hasNext() method will return true if the parent scope (parent RION field or the total source byte array for the RionReader) has more RION fields.,NULL
"At the outer nesting level (top level) of the above RION field sequence, the RionReader hasNext() will return true, as long as there are RION fields at this nesting level.",NULL
"Now the RionReader hasNext() method returns true 2 times, because there are 2 nested RION fields inside the RION Object field.","(""RionReader"", ""The hasNext method belongs to the RionReader class."", ""hasNext"")"
"Once the hasNext() method returns false, you ""move out of"" the composite RION field again.","(""hasNext"", ""The 'hasNext()' method determines when to exit the composite 'RION' field."", ""RION""); (""hasNext"", ""The 'hasNext()' method determines when to exit the composite 'RION' field."", ""RION"")"
You can improve on the above code in various ways - e.g.,NULL
"To read a RION Table field, you have to ""move into"" it with moveInto(), then read the first field which is an Int64 RION field representing the row count, and then 1 to N Key or Key Short fields representing the column headers (column names / keys) of the table, and then finally 1 to N fields per row.","(""MoveInto"", ""The moveInto() method is utilized in the context of reading fields within a RION package structure."", ""Rion""); (""Int64 Rion"", ""The Int64 RION field is a class type that represents the row count and is used within the RION package for reading table data."", ""Rion"")"
The RionReader class contains a method named isNull() which will tell you if the current RION field pointed to by the RionReader has the field value null.,"(""RionReader"", ""The isNull method is part of the RionReader class, indicating a class-method relationship."", ""isNull"")"
Here is an example of checking if a given RION field is null via the RionReader isNull() method:,"(""RionReader"", ""The isNull method is a function of the RionReader class, used to check if a RION field is null."", ""isNull"")"
"The RION Ops RionWriter class, com.nanosai.rionops.rion.write.RionWriter, enables you to write RION fields easily and efficiently.","(""RionWriter"", ""RionWriter is a class within the com.nanosai.rionops.rion.write.RionWriter package"", ""com.nanosai.rionops.rion.write.RionWriter"")"
You set the destination byte array of the RionWriter using the setDestination() method.,NULL
The RionWriter contains a method named writeBytes() which can be used to write a RION Bytes field to the destination byte array.,"(""RionWriter"", ""The method writeBytes is part of the RionWriter class."", ""writeBytes""); (""writeBytes"", ""The writeBytes method is used to write RION Bytes to the destination byte array."", ""RION Bytes"")"
Here is a Java example of writing a RION Bytes field from a byte array using the RionWriter writeBytes() method:,"(""RionWriter"", ""RionWriter is a class that provides the writeBytes method."", ""writeBytes""); (""Java"", ""The RION Bytes class is likely part of or used within Java."", ""RION Bytes"")"
The writeBytes() method also exists in a version that takes a source offset and source length which specifies from what offset and how many bytes forward in the source byte array to write to the RION Bytes field in the destination byte array.,NULL
The RionWriter method writeBoolean() writes a boolean value (true / false) as a RION Boolean field to the destination byte array.,"(""RionWriter"", ""The writeBoolean() method is part of the RionWriter class, indicating a class-method relationship."", ""writeBoolean()"")"
Here is a Java example of writing a RION Boolean field using the RionWriter writeBoolean() method:,NULL
The RionWriter method writeInt64() will write a 64 bit integer as a RION IntPos or IntNeg field to the destination byte array.,NULL
"Here are two examples of writing int64 values (long values) as RION IntPos and IntNeg fields to the destination byte array, using the RionWriter writeInt64() method:",NULL
The RionWriter methods writeFloat32() and writeFloat64() writes a 32 bit and 64 bit floating point number as a RION Float field to the destination byte array.,"(""RionWriter"", ""The method writeFloat32 belongs to the RionWriter class"", ""writeFloat32""); (""RionWriter"", ""The method writeFloat64 belongs to the RionWriter class"", ""writeFloat64"")"
"Here are two examples of writing a 32 bit and 64 bit floating point number as RION Float fields to the destination byte array, using the RionWriter writeFloat32() and writeFloat64() methods:","(""RionWriter"", ""writeFloat32 is a method that belongs to the RionWriter class"", ""writeFloat32""); (""RionWriter"", ""writeFloat64 is a method that belongs to the RionWriter class"", ""writeFloat64"")"
The RionWriter method writeUtf8() writes a Java String as a RION UTF-8 or UTF-8-Short field to the destination byte array.,NULL
Here is an example of writing a RION UTF-8 field to a byte array using the RionWriter writeUtf8() method:,NULL
The RionWriter method writeUtc() method writes a date and time in the shape of a Java Calendar as a RION UTC field (UTC date-time) to the destination byte array.,"(""RionWriter"", ""The method 'writeUtc' is associated with the class 'RionWriter'."", ""writeUtc""); (""writeUtc"", ""The method 'writeUtc' writes a UTC date-time in the shape of a 'Calendar' object."", ""Calendar""); (""RION"", ""The 'writeUtc' method writes the date in the format of 'RION' package."", ""writeUtc"")"
Here is an example of writing a Java Calendar as a RION UTC field to the destination byte array using the RionWriter writeUtc() method:,NULL
The RionWriter class has functionality that helps you reserve length bytes for composite RION fields and jump back up and fill them in correctly later.,"(""RionWriter"", ""The RionWriter class is responsible for reserving length bytes for composite RION fields."", ""length bytes"")"
One of the mechanisms in the RionWriter class that helps you reserve length bytes and set their value correctly later requires an internal stack to keep track of where the reserved length bytes are located.,NULL
Here is an example of setting the nested field stack for a RionWriter via its setNestedFieldStack() method:,NULL
"However, it is possible for all RION fields to take the value null, so it is possible to include e.g.",NULL
"The writeObjectBeginPush() method writes the beginning of the RION Object field, and reserves and reserve as many length bytes as you pass to it as parameter (2 in the example above).","(""WRITEOBJECTBEGINPUSH"", ""The WRITEOBJECTBEGINPUSH method is related to the RION OBJECT as it writes the beginning of this object field."", ""RION OBJECT"")"
"The writeObjectEndPop() method pops the RION Object field start index off the nested field stack, calculates the total length of the Object field and writes the total Object field length into its reserved length bytes.","(""WriteObjectEndPop"", ""The WriteObjectEndPop method is related to the RION class because it interacts with the RION Object field."", ""RION""); (""WriteObjectEndPop"", ""The WriteObjectEndPop method is related to the Object class as it involves calculations regarding the Object field's total length."", ""Object"")"
There are also versions of the writeObjectBegin() and writeObjectEnd() method that does not use the internal nested field stack.,"(""WriteObjectBegin"", ""Both are methods related by their function and context in handling object writing sequences."", ""WriteObjectEnd"")"
The String arguments passed to the main() method are the command line arguments passed to the application when it is executed.,"(""main()"", ""The main() method is typically the entry point of the application."", ""application"")"
The Main argument is the name of the object to run the main() method of.,"(""Main"", ""The 'main()' method is typically associated with the 'Main' class as the entry point for executing a program."", ""main()"")"
"The arguments ""arg1"" and ""arg2"" are passed in the String array to the main() method.","(""main()"", ""method""); (""main()"", ""method"")"
The until keyword makes sure to only iterate until myArray.length - 1.,NULL
"If you had needed i to also take the value of myArray.length in the final iteration, you could have used the to keyword instead of the until keyword.",NULL
"This means that you can define classes in Scala, and instantiate objects of these classes.","(""Class"", ""Classes can have instances, which are referred to as objects"", ""Object"")"
"That means, that a class defines what information objects of that class holds, and what behaviour (methods) it exposes.","(""Class"", ""The class exposes methods, defining the behavior of its objects."", ""Method"")"
The other aspects of Scala classes will be covered in separate texts.,"(""Scala"", ""class"")"
Here I have just shown you how to declare a method inside a class.,NULL
"Notice how this addToMyField() method does not have the equals sign, and no return type specified.","(""ADDTOMYFIELD"", ""METHOD"")"
"When an exception is thrown from inside the throwsException() method, the execution is interrupted and the execution jumps to the catch clause surrounding the code that threw the exception.","(""throwsException"", ""method"")"
"In the example above, when the throwsException() method is called, and it throws an exception, the statement below the throwsException() method call is never executed.","(""ThrowsException"", ""Method"")"
"In the example above, only one exception is caught, Exception which is the superclass of most exceptions.","(""Exception"", ""class"")"
"Rather than compute the .toUpperCase() value twice, by nesting them inside each if-statement, the uppercase version of aString is computed just once, and assigned to the variable aStringUC.",NULL
"You can thus use all the classes of the Java SDK's in Scala, and also your own, custom Java classes, or your favourite Java open source projects.",NULL
"Instead a Scala class can have what is called a singleton object, or sometime a companion object.","(""Class"", ""A Scala class can have a singleton object or companion object, implying a relationship where a class is associated with these types of objects."", ""Object"")"
"When a singleton object is named the same as a class, it is called a companion object.",NULL
A companion object must be defined inside the same source file as the class.,NULL
"In this class you can both instantiate Main and call sayHelloWorld() or call the sayHi() method on the companion object directly, like this:","(""Main"", ""The Main class contains the sayHelloWorld() method that can be called."", ""sayHelloWorld""); (""Main"", ""The Main class has a companion object on which the sayHi() method can be called."", ""sayHi"")"
This also means that you can use all Java classes in your Scala code.,NULL
The Scala version used in the examples in this tutorial is Scala 2.8.0 .,NULL
"The Stream Ops StreamOps class, com.nanosai.streamops.StreamOps, provides a convenient facade for the Stream Ops API.","(""StreamOps"", ""The StreamOps class is part of the com.nanosai.streamops.StreamOps package."", ""com.nanosai.streamops.StreamOps"")"
The StreamOps class can create the most commonly used components of the Stream Ops API.,"(""StreamOps"", ""The StreamOps class is a part of the Stream Ops API."", ""Stream Ops API"")"
"Thus, the StreamOps class is a good place to start, both when using Stream Ops, but also when exploring what you can do with Stream Ops and how it works.","(""StreamOps"", ""The StreamOps class is mentioned as a place to start when using or exploring 'Stream Ops', indicating a practical application or functional relationship."", ""Stream Ops"")"
In this tutorial we will only go over the components the StreamOps and related factory classes can create.,"(""StreamOps"", ""The StreamOps class is part of the components that can be created by related factory classes."", ""factory classes"")"
"You can create instances of these classes via the new operator, or you can use a StreamStorageFactory.","(""Class"", ""A StreamStorageFactory is used to create instances of the class"", ""StreamStorageFactory""); (""Class"", ""A StreamStorageFactory is used to create instances of the class"", ""StreamStorageFactory"")"
You can create a StreamStorageFS instance via the StreamStorageFactory createStreamStorageFS() method.,NULL
Here is an example of creating a StreamStorageFS instance via the createStreamStorageFS() method:,NULL
You can create a StreamStorageRootFS instance via the StreamStorageFactory createStreamStorageRootFS() method.,"(""createStreamStorageRootFS"", ""The method createStreamStorageRootFS is used to create an instance of the class StreamStorageRootFS."", ""StreamStorageRootFS""); (""StreamStorageFactory"", ""The class StreamStorageFactory contains the method createStreamStorageRootFS."", ""createStreamStorageRootFS"")"
"The Stream Ops StreamStorageFS class, com.nanosai.streamops.storage.file.StreamStorageFS, provides disk storage for a data stream.","(""Stream Ops Streamstoragefs"", ""The Stream Ops StreamStorageFS class is part of the com.nanosai.streamops.storage.file package"", ""Com.nanosai.streamops.storage.file"")"
"More specifically, the StreamStorageFS class can write an ordered sequence of records to disk, and later read the records from disk again in the exact same order.","(""StreamStorageFS"", ""class"")"
The StreamStorageFS class is one of the core classes of the Stream Ops data storage engine.,NULL
Many of the other classes in the Stream Ops data storage engine revolve around this class.,"(""Stream Ops"", ""package"")"
To use the StreamStorageFS class you must first create a StreamStorageFS instance.,NULL
"Once a StreamStorageFS instance is open for appending records, you can append a record to the stream via the append() method.",NULL
You can obtain a list of StreamStorageBlockFS instances from a StreamStorageFS by calling getStorageBlocks().,"(""StreamStorageFS"", ""The method getStorageBlocks() is called on an instance of the class StreamStorageFS."", ""getStorageBlocks""); (""getStorageBlocks"", ""The method getStorageBlocks() returns a list of StreamStorageBlockFS instances."", ""StreamStorageBlockFS"")"
The StreamStorageFS class contains a method to read bytes from a stream block file.,NULL
"The readBytes() method reads bytes from the file represented by the given StreamStorageBlockFS instance, into the byte[] array passed as parameter.",NULL
The readBytes() method will start fromByte bytes into the block file.,NULL
The Stream Ops for Java class named StreamStorageRootFS (com.nanosai.streamops.engine.storage.file.StreamStorageRootFS) class represents the root of a file based stream storage system.,"(""StreamStorageRootFS"", ""The class 'StreamStorageRootFS' belongs to the package 'com.nanosai.streamops.engine.storage.file.StreamStorageRootFS', as it follows the naming convention for classes within packages in Java."", ""com.nanosai.streamops.engine.storage.file.StreamStorageRootFS"")"
You can always obtain the root directory path a StreamStorageRootFS was created with via its getRootDirPath() method.,"(""StreamStorageRootFS"", ""The getRootDirPath method belongs to the StreamStorageRootFS class, as it is used to obtain the root directory path associated with an instance of this class."", ""getRootDirPath"")"
Here is an example of obtaining the root directory path of a StreamStorageRootFS via its getRootDirPath() method:,"(""StreamStorageRootFS"", ""The method getRootDirPath is used to obtain the root directory path of the class StreamStorageRootFS."", ""getRootDirPath"")"
"When you write records to a stream via the StreamStorageFS instance, the StreamStorageFS class will divide the records into multiple files.","(""StreamStorageFS"", ""The StreamStorageFS class is related to the stream as it is used to write records to it."", ""stream""); (""write"", ""The write method is related to the stream because it describes the action of writing records to the stream."", ""stream""); (""StreamStorageFS"", ""The StreamStorageFS class likely utilizes the write method to perform the action of writing to the stream."", ""write"")"
Creating a Buffer is done using the static buffer() method in the Buffer interface.,NULL
If you want the bytes stored in the Buffer to be encoded using a special encoding (e.g.,"(""Buffer"", ""class""); (""Buffer"", ""class"")"
"you can specify the encoding as the second parameter to the buffer() method, like this:",NULL
You can read the length of a Buffer using its length() method.,"(""length"", ""The method length is associated with the class Buffer as it is used to read the length of a Buffer."", ""Buffer"")"
You can write to a specific position inside a buffer using one of the set...() methods.,NULL
You can also write data to a Buffer using one of the append...() methods.,"(""Buffer"", ""The append...() methods are used to write data to the Buffer class, indicating their association with this class for data manipulation."", ""Append...() Methods"")"
You can read the data stored in a Buffer using the many get...() methods.,"(""Buffer"", ""The class Buffer contains or uses the get...() methods to perform operations on its data."", ""get...() methods""); (""Buffer"", ""The class Buffer contains or uses the get...() methods to perform operations on its data."", ""get...() methods"")"
After the vertx run part of the command you must write the fully qualified class name of the verticle to deploy.,"(""Verticle"", ""The 'run' part of the command refers to executing a method related to the Verticle class, specifically for deployment purposes."", ""method"")"
To deploy a verticle class you must run the vertx run classname command from the root directory of the compiled classes for the verticle to deploy.,NULL
"Thus, the root directory of your classes becomes the classpath for deploying the verticle.","(""Classes"", ""Classes become the classpath for deploying."", ""Classpath""); (""Classpath"", ""Classpath is used for deploying the verticle."", ""Verticle"")"
Whatever directory you run the vertx run command from is automatically added to the classpath when looking for the verticle class.,NULL
You can also run a Java verticle class which is located inside a JAR file.,"(""Java Verticle"", ""A Java verticle class is typically packaged inside a JAR file."", ""JAR"")"
Sometimes you need a classpath which contains more than one directory or JAR file.,"(""Classpath"", ""Class"")"
In those situations you can provide a normal classpath string as the -cp argument value.,NULL
Each entry (directory or JAR file) in the classpath string must be separated by either a semicolon (on Windows) or a colon (on Unix / Linux).,"(""Classpath"", ""Entries form components of a classpath used during execution in Java environments."", ""Entry"")"
This example contains two JAR files in the classpath separated by a semicolon.,NULL
"If you have a very long classpath your command line may get very long, and thus be hard to read in a text editor.","(""classpath"", ""Classpath is often associated with classes in programming environments as it determines where the system looks for class definitions."", ""class"")"
"Instead you can build the classpath up as an environment variable, one entry per line, and use that environment variable in the command line.","(""Classpath"", ""Classpath is described as being built up as an environment variable in the text."", ""Environment Variable"")"
run.cmd and you can execute it from a Windows command line.,"(""RUN.CMD"", ""METHOD"")"
Notice the use of / as directory separator and the use of : as classpath entry separator.,"(""DIRECTORY"", ""Directory is part of the path structure used in the classpath entry."", ""CLASSPATH"")"
That might be useful if you deploy a class file that is written in Groovy or Scala (but which are compiled into Java classes).,NULL
The first parameter to the getNow() method is the TCP port to connect to the remote HTTP server on.,"(""getNow"", ""The getNow method accepts the TCP port as a parameter, indicating it uses this port to establish a connection to the server."", ""TCP port"")"
The getNow() method exists in a version where you can leave the port out.,NULL
The second parameter to the getNow() method is the domain name of the remote HTTP server to connect to.,"(""GetNow"", ""The GetNow method involves an HTTP connection as it requires a domain name of the remote HTTP server."", ""Http"")"
The third parameter to the getNow() method is the URI to the resource to retrieve.,"(""Getnow"", ""The getNow() method uses a URI as its third parameter to specify the resource to retrieve."", ""Uri""); (""Uri"", ""The URI references the resource that is intended to be retrieved."", ""Resource""); (""Getnow"", ""The getNow() method uses a URI as its third parameter to specify the resource to retrieve."", ""Uri""); (""Uri"", ""The URI references the resource that is intended to be retrieved."", ""Resource"")"
The Handler implementation passed to the getNow() method is called when the headers of the HTTP response are received.,"(""Handler"", ""The Handler implementation is passed to the getNow() method."", ""Getnow"")"
"However, if you do need to access the body of the HTTP response, you need to register another handler on the HttpClientResponse that is passed as parameter to the first Handler's handle() method.","(""Handler"", ""handle() is a method of the Handler class."", ""handle()""); (""HttpClientResponse"", ""HttpClientResponse is passed as a parameter to a method in the Handler class."", ""Handler"")"
The Handler implementation passed to the bodyHandler() method of the HttpClientResponse is called when the full HTTP response body is received.,"(""Handler"", ""The Handler implementation is passed to the bodyHandler() method."", ""bodyHandler()""); (""bodyHandler()"", ""The bodyHandler() method is associated with the HttpClientResponse as it is called when the full HTTP response body is received."", ""HttpClientResponse"")"
"Once you have created the HTTP server, you can start it using its listen() method.",NULL
"The HttpServer class has more versions of the listen() method too, which gives you different options for starting the HTTP server.","(""HttpServer"", ""The listen() method is associated with the HttpServer class as it is used for starting the HTTP server within this class."", ""listen()"")"
"Every time an HTTP request arrives at the HTTP server, the handle() method of the Handler object is called.","(""HANDLE"", ""The HANDLE method is a part of the HANDLER class, as it is called on an instance of the HANDLER object."", ""HANDLER"")"
Inside the handle() method you can execute the code needed to handle the HTTP request.,"(""Handle"", ""The handle method is responsible for executing the code needed to handle the HTTP request."", ""Execute"")"
You can access HTTP headers and parameters from the HttpServerRequest object passed as parameter to the handle() method.,"(""HttpServerRequest"", ""The HttpServerRequest class is used as a parameter in the handle method, indicating a functional or usage relationship where the method utilizes the class for handling requests."", ""handle"")"
"After writing the headers back you can write the response body back via the write() method, like this:",NULL
You can call write() multiple times to add more data to the response body.,NULL
The write() method is asynchronous and returns immediately after queuing up the string or buffer.,"(""Write"", ""The write() method is described as asynchronous in the text."", ""Asynchronous"")"
This is done by calling the end() method as shown in the previous example.,"(""End"", ""The end() identifier in the text is explicitly referred to as a method."", ""Method"")"
The end() method can take either a String or Buffer as parameter.,NULL
To close an HTTP server you simply call its close() method like this:,"(""HTTP Server"", ""The method `close()` is used to close the HTTP server."", ""Close"")"
"The close() method executes asynchronously, so the HTTP server may not be fully closed by the time the close() method returns.",NULL
"You can pass a close handler as parameter to the close() method, to be notified when the HTTP server is fully closed.","(""Close"", ""The close method potentially shuts down the HTTP server."", ""HTTP Server""); (""Close Handler"", ""The close handler can be passed to the close method to handle events when it is invoked."", ""Close"")"
"You can just unzip the zip file and add these JAR files to the classpath of your Java application, and you are good to go.",NULL
As long as the JAR files are available on the classpath of your application.,"(""JAR"", ""JAR files are required to be available on the classpath for the application to function properly."", ""classpath"")"
You connect to a remote server by calling the connect() method.,"(""Connect"", ""method"")"
You obtain a reference to the NetSocket connected to the remote server via the AsyncResult instance passed to the handler's handle() method.,"(""handle"", ""The handle() method takes an AsyncResult instance as a parameter."", ""AsyncResult""); (""NetSocket"", ""The NetSocket is connected to the remote server, and this connection is referenced in the AsyncResult instance."", ""AsyncResult"")"
You can write data to the TCP connection via the NetSocket write() method.,NULL
The data may not be sent by the time the write() method returns.,NULL
The Handler's handle() method will get called when data is received from the remote server.,"(""Handler"", ""Handle() is a method belonging to the Handler class."", ""handle()"")"
You close the TCP client by calling the close() method of the NetClient instance.,"(""NetClient"", ""The close() method belongs to the NetClient class and is used to close the TCP client."", ""close()"")"
"Again, the NetClient's close() method is asynchronous, so the underlying TCP connection may not yet be closed by the time the close() method returns.","(""NetClient"", ""The close() method is a method of the NetClient class."", ""close"")"
"Once you have created the TCP server, you can start it using its listen() method.",NULL
This example starts the server and instructs it to listen on TCP port 10.000 .,NULL
The NetServer class contains more versions of the listen() method which gives you different options for starting the TCP server.,"(""NetServer"", ""The listen() method is contained within the NetServer class, indicating a direct relationship where the method provides functionality for the class."", ""listen()""); (""listen()"", ""The listen() method is used to start the TCP server, indicating that it is designed to work within the TCP package to enable server functionality."", ""TCP""); (""NetServer"", ""The listen() method is contained within the NetServer class, indicating a direct relationship where the method provides functionality for the class."", ""listen()""); (""listen()"", ""The listen() method is used to start the TCP server, indicating that it is designed to work within the TCP package to enable server functionality."", ""TCP"")"
The handle() method of the connect handler is called whenever a new TCP connection is created by a client of the TCP server.,NULL
The NetSocket object passed as parameter to the handle() method gives access to the incoming connection (socket etc.,NULL
You can do so via the NetSocket instance passed to the connect handler's handle() method.,NULL
The NetSocket class contains more versions of the write() method which enables you to write e.g.,NULL
When you are finished with the TCP server you can close it using its close() method.,NULL
"Closing the TCP server is an asynchronous actions, so the close() method may exit before the TCP server is actually closed.","(""Close"", ""The method 'close()' is used to close a TCP server, suggesting a functional relationship between the two."", ""TCP Server"")"
"If you need to be notified of when the TCP server has shut down, you can pass a Handler to the close() method.","(""Handler"", ""A Handler can be passed to the close() method to handle the event when the TCP server has shut down."", ""close()"")"
"The setTimer() method takes a time interval in milliseconds as first parameter, and a Handler implementation as second parameter.","(""setTimer"", ""The setTimer method takes a Handler implementation as one of its parameters, indicating that Handler is used within setTimer."", ""Handler"")"
The Handler's handle() method is called when the time interval has elapsed.,"(""Handler"", ""The handle() method is associated with the Handler class as it is likely a method defined within that class to handle specific actions after the time interval has elapsed."", ""handle""); (""Handler"", ""The handle() method is associated with the Handler class as it is likely a method defined within that class to handle specific actions after the time interval has elapsed."", ""handle"")"
This timer ID is also passed as parameter to the Handler's handle() method.,NULL
"The setPeriodic() method takes a time interval in milliseconds as first parameter, and a Handler implementation as second parameter.","(""SetPeriodic"", ""The setPeriodic method requires a Handler implementation as its second parameter."", ""Handler"")"
The Handler's handle() method is called every time the time interval has elapsed.,"(""Handler"", ""The handle() method is a function of the Handler class"", ""handle"")"
This timer ID is also passed to the Handler's handle() method whenever it is called.,NULL
Support for Scala and Clojure should be arriving soon (it was originally planned for v. 3.0 but I am not sure if they got it in).,"(""Scala"", ""package""); (""Clojure"", ""package"")"
You don't have to learn both a language and a new platform (e.g.,NULL
You will see later in this tutorial how to use both versions of the start() method.,NULL
Here is an example of overriding the stop() method in your own verticle:,"(""Verticle"", ""The stop() method is overridden in the Verticle class, suggesting an implementation relationship."", ""Stop"")"
Sending messages via the event bus can be done via either the send() or publish() method on the event bus.,"(""Send"", ""The send method operates on the event bus to facilitate message dispatch."", ""Event Bus""); (""Publish"", ""The publish method operates on the event bus to distribute messages."", ""Event Bus"")"
The send() method sends the message to just one of the listening verticles.,NULL
This is useful for distributing work load over multiple verticles (e.g.,"(""Verticles"", ""Method"")"
"The first message is sent via the publish() method, so both consumers receive the message.","(""Publish"", ""The publish method is used to send a message which the consumers receive"", ""Consumers"")"
"The second message is sent via the send() method, so only one of the consumers will receive the message.","(""Send"", ""The 'Send' method is used to send messages to consumers."", ""Message"")"
A verticle has a start() and a stop() method which are called when the verticle is deployed and when it is undeployed.,"(""Verticle"", ""Start() is a method of the Verticle class."", ""Start()""); (""Verticle"", ""Stop() is a method of the Verticle class."", ""Stop()""); (""Verticle"", ""Start() is a method of the Verticle class."", ""Start()""); (""Verticle"", ""Stop() is a method of the Verticle class."", ""Stop()"")"
"You should perform any necessary initialization work inside the start() method, and any necessary cleanup work inside the stop() method.","(""Start"", ""Both are methods used for managing the different stages of a process, where 'start' is for initialization and 'stop' is for cleanup."", ""Stop"")"
"For instance, you can specify how many verticle instances of a given verticle class to deploy.",NULL
The startsWith() and endsWith() methods check if the String starts with a certain substring,NULL
In the above example the two methods getTime() and setTime() can access the time member variable,NULL
The convertToInt() method has the same signature as the deserialize() method of the Deserializer deserialize() method,"(""CONVERTTOINT"", ""Both are methods, indicating similar usage or purpose"", ""DESERIALIZE""); (""DESERIALIZE"", ""DESERIALIZE appears to be a method of the DESERIALIZER class"", ""DESERIALIZER"")"
Deque.removeLast() is different from pollLast() which returns null if the Deque is empty,NULL
The floor() method does the opposite of the ceiling() method meaning it returns the greatest element that is less than or equal to the given parameter value,"(""FLOOR"", ""The FLOOR method is related to the CEILING method because it performs the opposite function by returning the greatest element less than or equal to the given parameter value"", ""CEILING""); (""FLOOR"", ""The FLOOR method is related to the CEILING method because it performs the opposite function by returning the greatest element less than or equal to the given parameter value"", ""CEILING"")"
You can also specify METHOD or FIELD or you can leave the target out alltogether so the annotation can be used for both classes methods and fields,"(""Method"", ""Annotations can be used for both classes and methods"", ""Class""); (""Method"", ""Annotations can be used for both methods and fields"", ""Field""); (""Class"", ""Annotations can be specified together for classes and fields"", ""Field"")"
For instance finest() finer() fine() info() warning() and severe() each corresponds to one of the log levels,"(""Finest"", ""Finest corresponds to a specific log level."", ""Log Level""); (""Finer"", ""Finer corresponds to a specific log level."", ""Log Level""); (""Fine"", ""Fine corresponds to a specific log level."", ""Log Level""); (""Info"", ""Info corresponds to a specific log level."", ""Log Level""); (""Warning"", ""Warning corresponds to a specific log level."", ""Log Level""); (""Severe"", ""Severe corresponds to a specific log level."", ""Log Level"")"
You can encrypt or decrypt data into an existing byte array by passing the destination byte array as parameter to the update() and or doFinal() method,"(""Update"", ""Both methods are used to perform operations on a byte array, specifically for encrypting or decrypting data."", ""doFinal"")"
Second if the lock is locked the threads are blocked in the wait() call inside the while(isLocked) loop in the lock() method,NULL
Deque.removeFirst() is different from pollFirst() which returns null if the Deque is empty,"(""removeFirst"", ""removeFirst and pollFirst are methods associated with the Deque class, where removeFirst may throw an exception if the Deque is empty, while pollFirst returns null."", ""pollFirst"")"
The peek() works like the element() method except it does not throw an exception if the Queue is empty,NULL
The addAll() method takes a Collection as parameter so you can pass either a List or Java Set as parameter,"(""AddAll"", ""The addAll method takes a Collection as parameter"", ""Collection""); (""Collection"", ""A List can be passed as a parameter to the Collection in the addAll method"", ""List""); (""Collection"", ""A Java Set can be passed as a parameter to the Collection in the addAll method"", ""Java Set"")"
The Java Properties class java.util.Properties is like a Java Map of Java String key and value pairs,"(""Properties"", ""The Properties class belongs to the java.util.Properties package"", ""java.util.Properties""); (""Properties"", ""Properties class functions similarly to a Map class"", ""Map""); (""Properties"", ""Properties class deals with String key and value pairs"", ""String"")"
java.io.InputStream means that you use the Java FileInputStream as an InputStream (FileInputStream behaves like an InputStream),NULL
Since PipedInputStream is a subclass of InputStream PipedInputStream has the same basic methods and use patterns as an InputStream,"(""PipedInputStream"", ""PipedInputStream is a subclass of InputStream, indicating an inheritance relationship."", ""InputStream""); (""PipedInputStream"", ""PipedInputStream shares methods and use patterns with InputStream, indicating a functional relationship."", ""InputStream"")"
Choice.select(int pos) is done by having a different thread call the Selector.wakeup() method on the Selector which the first thread has called select() on,NULL
While isLocked is true the thread calling lock() is parked waiting in the wait() call,NULL
The AtomicInteger class is located in the java.util.concurrent.atomic package so the full class name is java.util.concurrent.atomic.AtomicInteger,"(""AtomicInteger"", ""The AtomicInteger class is located in the java.util.concurrent.atomic package, indicating containment of the class within the package."", ""java.util.concurrent.atomic"")"
But no thread can actually execute unlock() until the thread waiting in lock() leaves the outer synchronized block,"(""Lock"", ""Unlock depends on Lock completing execution before it can proceed."", ""Unlock""); (""Lock"", ""Unlock depends on Lock completing execution before it can proceed."", ""Unlock"")"
The System class also has a getProperty() and setProperty() method which are shortcuts to the Properties getProperty() and setProperty() methods of the System Properties instance.,NULL
Closeable.close() closes the Selector and invalidates all SelectionKey instances registered with this Selector,"(""Closeable"", ""The method Closeable.close() is responsible for closing the Selector."", ""Selector""); (""Selector"", ""Closing the Selector invalidates all SelectionKey instances registered with this Selector."", ""SelectionKey""); (""Closeable"", ""The method Closeable.close() is responsible for closing the Selector."", ""Selector""); (""Selector"", ""Closing the Selector invalidates all SelectionKey instances registered with this Selector."", ""SelectionKey"")"
Any.stream() is similar to how you obtain an Iterator by calling the items.iterator() method but a Stream is a different animal than an Iterator,NULL
An interesting aspect to note about the BufferedInputStream is that is supports the mark() and reset() methods inherited from the InputStream,NULL
"You can search for an object on the stack to get it's index, using the search() method. The object's equals() method is called on every object on the Stack to determine if the searched-for object is present on the Stack.","(""SEARCH"", ""Both are methods used to interact with objects on the Stack."", ""EQUALS""); (""SEARCH"", ""The search method is used to find an object within the Stack class."", ""STACK"")"
Actually java.sql.Timestamp extends java.util.Date so anything you can do with a java.util.Date you can also do with a java.sql.Timestamp,"(""Java.sql.Timestamp"", ""Java.sql.Timestamp extends Java.util.Date, indicating an inheritance relationship between the two classes."", ""Java.util.Date"")"
"If the Deque is empty, removeFirst() will throw an exception. This is different from pollFirst() which returns null if the Deque is empty.",NULL
You read bytes from a Java ByteArrayInputStream just like you would from a regular InputStream via its read() method,NULL
You create a DateFormat using the getDateInstance() and getTimeInstance() method of the DateFormat class,NULL
You can use addBatch() and executeBatch() methods to execute batch updates.,NULL
The Java FileOutputStream class is a subclass of Java OutputStream meaning you can use a FileOutputStream as an OutputStream,NULL
In the example above I passed it a FileInputStream connected to a file named myfile.zip,"(""FileInputStream"", ""FileInputStream is used to create a stream to read from the file named myfile.zip."", ""myfile.zip"")"
java.util.logging.LogRecord Throwable is either passed as parameter to a Logger log method or set directly on a LogRecord which is then passed to a Logger,"(""Logger"", ""The method 'log' belongs to the 'Logger' class"", ""log""); (""LogRecord"", ""Instances of 'LogRecord' are passed to 'Logger'"", ""Logger"")"
As you can see a new StringBuilder is created passing along the first String to its constructor and the second String to its append() method before finally calling the toString() method,"(""StringBuilder"", ""StringBuilder is instantiated using its constructor."", ""constructor""); (""StringBuilder"", ""The append() method is called on the StringBuilder instance to add a string."", ""append""); (""StringBuilder"", ""The toString() method is called on the StringBuilder instance to convert it to a string."", ""toString"")"
A thread cannot call wait() notify() or notifyAll() without holding the lock on the object the method is called on,"(""Thread"", ""A thread cannot call the wait() method without holding the lock on the object."", ""Wait()""); (""Thread"", ""A thread cannot call the notify() method without holding the lock on the object."", ""Notify()""); (""Thread"", ""A thread cannot call the notifyAll() method without holding the lock on the object."", ""NotifyAll()""); (""Object"", ""The wait() method is called on an object."", ""Wait()""); (""Object"", ""The notify() method is called on an object."", ""Notify()""); (""Object"", ""The notifyAll() method is called on an object."", ""NotifyAll()"")"
The AtomicReferenceArray in the java.util.concurrent.atomic package is an array of object references which can be updated atomically,NULL
Spin locks and the methods wait() and notify() are covered in more detail in the text Thread Signaling,"(""Spin Locks"", ""The class Spin Locks likely utilizes the method Wait for locking mechanisms."", ""Wait""); (""Spin Locks"", ""The class Spin Locks likely utilizes the method Notify for signaling threads."", ""Notify""); (""Wait"", ""The method Wait is covered in more detail in the package Thread Signaling, indicating a conceptual relationship."", ""Thread Signaling""); (""Notify"", ""The method Notify is covered in more detail in the package Thread Signaling, indicating a conceptual relationship."", ""Thread Signaling"")"
The AtomicLong class is located in the java.util.concurrent.atomic package so the full class name is java.util.concurrent.atomic.AtomicLong,"(""AtomicLong"", ""The AtomicLong class is part of the java.util.concurrent.atomic package."", ""java.util.concurrent.atomic"")"
"The Arrays class contains a set of methods called binarySearch(). This method helps you perform a binary search in an array. The array must first be sorted. You can do so yourself, or via the Arrays.sort() method covered earlier in this text.",NULL
The Java Reader (java.io.Reader) and Java Writer class (java.io.Writer) in Java IO work much like the InputStream and OutputStream with the exception that Reader and Writer are character based,NULL
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicInteger,"(""GETANDINCREMENT"", ""GETANDINCREMENT is a method that operates on the AtomicInteger class"", ""ATOMICINTEGER""); (""INCREMENTANDGET"", ""INCREMENTANDGET is a method that operates on the AtomicInteger class"", ""ATOMICINTEGER""); (""GETANDADD"", ""GETANDADD is a method that operates on the AtomicInteger class"", ""ATOMICINTEGER""); (""ADDANDGET"", ""ADDANDGET is a method that operates on the AtomicInteger class"", ""ATOMICINTEGER"")"
"The tailSet() method works the same way as the headSet() method, except it returns all elements that are equal to or higher than the given parameter element","(""TailSet"", ""Both methods are used to retrieve elements based on a specified parameter, with TailSet retrieving elements equal to or higher than the parameter, and HeadSet retrieving elements lower."", ""HeadSet"")"
If a different thread calls wakeup() and no thread is currently blocked inside select() the next thread that calls select() will wake up immediately,"(""Wakeup"", ""Wakeup and Select are related because calling wakeup() affects the behavior of threads blocked in select()."", ""Select""); (""Wakeup"", ""Wakeup and Select are related because calling wakeup() affects the behavior of threads blocked in select()."", ""Select"")"
HashMap maps a key and a value. It does not guarantee any order of the elements stored internally in the map.TreeMap also maps a key and a value. Furthermore it guarantees the order in which keys or values are iterated - which is the sort order of the keys or values.,NULL
It is worth noting that both unlockRead() and unlockWrite() calls notifyAll() rather than notify(),"(""UNLOCKREAD"", ""UNLOCKREAD calls NOTIFYALL for notification purposes"", ""NOTIFYALL""); (""UNLOCKWRITE"", ""UNLOCKWRITE calls NOTIFYALL for notification purposes"", ""NOTIFYALL"")"
Notice the call to update() and then doFinal() for these two blocks of data,"(""Update"", ""The update() method is called before doFinal() as part of processing two blocks of data"", ""DoFinal"")"
You simply pass an offset and length to the update() and or doFinal() method,"(""Update"", ""Both Update and DoFinal are methods likely part of a cryptographic hash function or similar API. They could be used in conjunction to modify data and finalize a hash digest."", ""DoFinal"")"
The Java Collections addAll() method can add a variable number of elements to a Collection (typically either a List or a Set,"(""Addall"", ""The addAll() method is used to add elements to a Collection class."", ""Collection""); (""Addall"", ""The addAll() method adds elements specifically to a List, which is a type of Collection."", ""List""); (""Addall"", ""The addAll() method can also add elements to a Set, another type of Collection."", ""Set"")"
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block,"(""Thread"", ""A wait method requires a thread to be on hold until notified, illustrating a synchronization relationship."", ""Wait""); (""Thread"", ""A notify method signals a thread, indicating a release or continuation from a synchronized block."", ""Notify"")"
java.lang.ThreadLocal is possible to set an initial value for a Java ThreadLocal which will get used the first time get() is called before set() has been called with a new value,NULL
The Reader and Writer classes are stream oriented classes that enable a Java application to read and write streams of characters,NULL
If the doNotify() method had called notifyAll() instead of notify() all waiting threads had been awakened and checked for signals in turn,"(""DoNotify"", ""The doNotify method could call the notifyAll method to awaken threads."", ""NotifyAll""); (""DoNotify"", ""The doNotify method could call the notify method to awaken threads."", ""Notify"")"
The run() method is what is executed by the thread after you call start(),"(""Run"", ""The run() method is executed when the start() method is called, indicating a sequence relationship between these two methods."", ""Start"")"
You can convert Strings to uppercase and lowercase using the methods toUpperCase() and toLowerCase(),NULL
To make the Calculator class thread safe you could have declared the getValue() setValue() and add() methods synchronized,"(""Calculator"", ""Calculator is related to getValue because getValue is a method of the Calculator class"", ""getValue""); (""Calculator"", ""Calculator is related to setValue because setValue is a method of the Calculator class"", ""setValue""); (""Calculator"", ""Calculator is related to add because add is a method of the Calculator class"", ""add"")"
"If the call to take() happens before the call to release() the thread calling release() will still know that take() was called, because the signal is stored internally in the signal variable.",NULL
The getAndAdd() method does the same as the addAndGet() method except the getAndAdd() method returns the value of the element before a value is added to it,"(""getAndAdd"", ""The getAndAdd() method has a similar function to the addAndGet() method, with the difference lying in the value returned before addition."", ""addAndGet"")"
Adding and getting elements to a generic Map is done using the put() and get() methods just like you have always done,NULL
When guarding a critical section with a ReadWriteLock and the critical section may throw exceptions it is important to call the readUnlock() and writeUnlock() methods from inside a finallyclause,"(""readUnlock"", ""The method readUnlock is used in conjunction with the ReadWriteLock class to release a read lock."", ""ReadWriteLock""); (""writeUnlock"", ""The method writeUnlock is used in conjunction with the ReadWriteLock class to release a write lock."", ""ReadWriteLock"")"
The FileChannel class has a transferTo() and a transferFrom() method which does this for you,"(""FileChannel"", ""The transferTo method is part of the FileChannel class"", ""transferTo""); (""FileChannel"", ""The transferFrom method is part of the FileChannel class"", ""transferFrom"")"
To generate a KeyPair with a KeyPairGenerator you call the generateKeyPair() method,"(""KeyPairGenerator"", ""The generateKeyPair() method belongs to the KeyPairGenerator class as it is called using a KeyPairGenerator."", ""generateKeyPair""); (""generateKeyPair"", ""The generateKeyPair() method is used to generate a KeyPair."", ""KeyPair"")"
You can convert a OutputStream to a character based Writer using the Java OutputStreamWriter class,NULL
If you created your SortedSet with a Comparator you can obtain that Comparator via the SortedSet comparator() method,NULL
"In order to update the database you need to use a Statement. But, instead of calling the executeQuery() method, you call the executeUpdate() method.","(""Statement"", ""The executeUpdate method is used with a Statement to update the database."", ""executeUpdate""); (""Statement"", ""The executeQuery method is related to Statement as a method, although it is not used for updates in this context."", ""executeQuery""); (""Statement"", ""The executeUpdate method is used with a Statement to update the database."", ""executeUpdate""); (""Statement"", ""The executeQuery method is related to Statement as a method, although it is not used for updates in this context."", ""executeQuery"")"
Instances of this class are used together with UDP DatagramSockets and normal Socket and ServerSocket,"(""DatagramSockets"", ""Both are used for UDP network communication"", ""Socket""); (""Socket"", ""Socket and ServerSocket work together in client-server communication"", ""ServerSocket""); (""DatagramSockets"", ""Both are used for UDP network communication"", ""Socket""); (""Socket"", ""Socket and ServerSocket work together in client-server communication"", ""ServerSocket"")"
The Java InputStreamReader class java.io.InputStreamReader wraps a Java InputStream thereby turning the byte based InputStream into a character based Reader,NULL
The Math is located in the java.lang package and not in the java.math package,"(""Math"", ""The class Math is part of the java.lang package."", ""java.lang""); (""Math"", ""The class Math is mentioned as not being part of the java.math package."", ""java.math"")"
The Java StringReader class enables you to turn an ordinary String into a Reader,NULL
All elements inserted into the PriorityBlockingQueue must implement the java.lang.Comparable interface,"(""PriorityBlockingQueue"", ""All elements inserted into the PriorityBlockingQueue must implement the java.lang.Comparable interface, indicating a dependency relationship."", ""java.lang.Comparable"")"
As mentioned earlier the DataInputStream class is often used together with a DataOutputStream,"(""DataInputStream"", ""DataInputStream and DataOutputStream classes are often used together for data input and output operations"", ""DataOutputStream""); (""DataInputStream"", ""DataInputStream and DataOutputStream classes are often used together for data input and output operations"", ""DataOutputStream"")"
java.io.FileReader works much like the FileInputStream except the FileInputStream reads bytes whereas the FileReader reads characters,"(""FileReader"", ""FileReader is compared to FileInputStream in terms of their data reading functions, indicating they are related in context"", ""FileInputStream"")"
Deque.pollLast() is different than removeLast() which throws an exception if the Deque is empty,"(""pollLast"", ""pollLast and removeLast are both methods of the Deque class"", ""removeLast""); (""Deque"", ""pollLast is a method of the Deque class"", ""pollLast""); (""Deque"", ""removeLast is a method of the Deque class"", ""removeLast"")"
The java.util.concurrent.locks package has the following implementations of the Lock interface,"(""Java.Util.Concurrent.Locks"", ""The package contains implementations of the Lock interface."", ""Lock"")"
The methods start() and end() will give the indexes into the text where the found match starts and ends,NULL
The tailSet() method works the same way as the headSet() method except it returns all elements that are equal to or higher than the given parameter element,"(""tailSet"", ""The tailSet method and the headSet method are related as both perform similar operations on elements but return differing element ranges."", ""headSet""); (""tailSet"", ""The tailSet method and the headSet method are related as both perform similar operations on elements but return differing element ranges."", ""headSet"")"
A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object,NULL
Here is an example of listing all files in a directory via the Java File list() and listFiles() methods,NULL
You can peek at the element at the head of a Queue without taking the element out of the Queue. This is done via the Queue element() or peek() methods.,"(""Queue"", ""The method element() is used to access the elements of the Queue class without removing them."", ""element()""); (""Queue"", ""The peek() method is associated with the Queue class to view its head element without dequeuing it."", ""peek()"")"
The methods Class.getField(String name) and Class.getFields() methods only return public fields so they wont work,NULL
When you do so you can call connect() read() and write() in asynchronous mode,"(""Connect"", ""Both Connect and Read are methods that can be called in an asynchronous mode."", ""Read""); (""Connect"", ""Both Connect and Write are methods that can be called in an asynchronous mode."", ""Write""); (""Read"", ""Both Read and Write are methods that can be called in an asynchronous mode."", ""Write"")"
"if you are writing a component that needs to read input from a stream, try to make our component depend on an InputStream, rather than any of it's subclasses (e.g. FileInputStream).","(""FileInputStream"", ""FileInputStream is a subclass of InputStream indicating inheritance relationship."", ""InputStream"")"
For inexplicable reasons it is possible for threads to wake up even if notify() and notifyAll() has not been called,NULL
The applyLocalizedPattern() does the same as applyPattern() except it interpretes the characters in the pattern according to the Locale the DecimalFormat was created with,"(""ApplyLocalizedPattern"", ""ApplyLocalizedPattern is mentioned as doing the same function as ApplyPattern, indicating a functional relationship."", ""ApplyPattern""); (""ApplyLocalizedPattern"", ""ApplyLocalizedPattern interprets pattern characters according to the Locale, indicating a dependence or usage relationship."", ""Locale""); (""DecimalFormat"", ""The Locale is specified as the context with which the DecimalFormat was created, indicating a contextual relationship."", ""Locale"")"
"You can access these two parts of the duration using the Duration methods:getNano(),getSeconds()","(""DURATION"", ""Duration class has a method called getNano() to access nanoseconds"", ""GETNANO""); (""DURATION"", ""Duration class has a method called getSeconds() to access seconds"", ""GETSECONDS"")"
If you look back at the doSynchronized() method you will notice that the comment between lock() and unlock() states that the code in between these two calls take a long time to execute,"(""lock"", ""lock() and unlock() are used together for synchronization"", ""unlock""); (""lock"", ""lock() and unlock() are used together for synchronization"", ""unlock"")"
When the thread calling lock() right after calls queueObject.wait() it will remain blocked until some other thread calls unlock() which may never happen,NULL
Creating a pipe using Java IO is done via the PipedOutputStream and PipedInputStream classes. A PipedInputStream should be connected to a PipedOutputStream. The data written to the PipedOutputStream by one thread can be read from the connected PipedInputStream by another thread.,"(""PipedOutputStream"", ""A PipedInputStream should be connected to a PipedOutputStream, allowing data written by one thread to be read by another."", ""PipedInputStream"")"
Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block.,NULL
"TreeSet also guarantees the order of the elements when iterated, but the order is the sorting order of the elements. In other words, the order in which the elements whould be sorted if you used a Collections.sort() on a List or array containing these elements. This order is determined either by their natural order (if they implement Comparable), or by a specific Comparator implementation",NULL
"You can also obtain an Iterator from many of the Java Collection data structures, e.g. a List, Set, Map, Queue, Deque or Map.",NULL
Instead the critical section is guarded by the lock.lock() and lock.unlock() calls,NULL
The methods mark() and reset() methods are typically used when implementing parsers,"(""Mark"", ""Methods typically used together in parser implementation"", ""Reset""); (""Mark"", ""Methods typically used together in parser implementation"", ""Reset""); (""Mark"", ""Methods typically used together in parser implementation"", ""Reset"")"
Once you have obtained a Field reference you can get and set its values using the Field.get() and Field.set()methods like this,NULL
The poll() and remove() both removes the first element in the Queue,NULL
Any other thread calling lock() will be blocked until the thread that locked the lock calls unlock(),"(""Lock"", ""The Lock method is paired with the Unlock method, as the former initiates locking and the latter releases it."", ""Unlock"")"
The java.text.DateFormat class is used to format dates as strings according to a specific Locale,"(""DateFormat"", ""The DateFormat class uses the format method to format dates as strings."", ""format""); (""DateFormat"", ""The DateFormat class is part of the java.text package."", ""java.text""); (""DateFormat"", ""The DateFormat class uses a specific Locale."", ""Locale"")"
The InputStream class has two methods called mark() and reset() which subclasses of InputStream may or may not support,NULL
java.nio.channels.Selector is not the Channel that pushes the data into the Selector and from there into the component even if that is what the above diagram suggests,"(""Selector"", ""The Selector is mentioned in conjunction with the Channel, indicating a data flow relationship where Selector processes or routes data from the Channel."", ""Channel"")"
When connected you can also use the read() and write() method as if you were using a traditional channel,"(""Read"", ""Both methods are used when connected, similar to a traditional channel."", ""Write""); (""Read"", ""Both methods are used when connected, similar to a traditional channel."", ""Write"")"
"The mark() sets a mark internally in the InputStream which marks the point in the stream to which data has been read so far. The code using the InputStream can then continue reading data from it. If the code using the InputStream wants to go back to the point in the stream where the mark was set, the code calls reset() on the InputStream.","(""InputStream"", ""The method 'mark()' is called on an instance of the InputStream class to set a mark in the input stream for future reference."", ""mark""); (""InputStream"", ""The method 'reset()' is used on an instance of the InputStream class to return to the most recent mark set in the stream."", ""reset"")"
These two types of tasks are represented by the RecursiveAction and RecursiveTask classes,"(""RecursiveAction"", ""Both are classes used to represent task types in this context"", ""RecursiveTask""); (""RecursiveAction"", ""Both are classes used to represent task types in this context"", ""RecursiveTask"")"
The java.util.concurrent package has the following implementations of the BlockingQueue interface,"(""Java.util.concurrent"", ""The java.util.concurrent package contains implementations of the BlockingQueue interface, indicating a hierarchical or organizational relationship."", ""BlockingQueue"")"
If the objects in the Java List do not implement the Comparable interface or if you want to sort the objects in another order than their compare() implementation then you need to use a Comparator implementation (java.util.Comparator),NULL
The Java SimpleDateFormat class is also capable of formatting a Date object into a StringBuffer instead of returning an individual String with the date formatted,"(""SimpleDateFormat"", ""SimpleDateFormat is used for formatting Date objects"", ""Date""); (""SimpleDateFormat"", ""SimpleDateFormat can format a Date into a StringBuffer"", ""StringBuffer""); (""SimpleDateFormat"", ""SimpleDateFormat can return a formatted date as a String"", ""String"")"
If the markSupported() method returns false then mark() and reset() are not supported,NULL
The Matcher replaceAll() and replaceFirst() methods can be used to replace parts of the string the Matcher is searching through,NULL
In that way the PrintWriter is a bit different from other Writer subclasses which tend to have mostly constructors that can take other Writer instances as parameters (except for a few like OutputStreamWriter),"(""PrintWriter"", ""PrintWriter is described as different from other Writer subclasses."", ""Writer""); (""Writer"", ""OutputStreamWriter is an example of Writer subclasses that are different."", ""OutputStreamWriter"")"
The reduce() method can be combined with the filter() method too,"(""Reduce()"", ""The 'reduce()' method can be used in conjunction with the 'filter()' method, indicating they are related through their complementary functionalities."", ""Filter()"")"
In case you prefer to use Java NIO instead of Java Networking (standard API) then you can also use a ServerSocketChannel instead of the java.net.ServerSocket,NULL
The problem is that since the doNotify() call only calls notify() and not notifyAll() only one thread is awakened even if 4 threads are waiting on the same string instance (the empty string),"(""doNotify"", ""doNotify() calls the notify() method"", ""notify""); (""doNotify"", ""doNotify() distinguishes between notify() and notifyAll() methods depending on desired behavior"", ""notifyAll""); (""doNotify"", ""doNotify() calls the notify() method"", ""notify""); (""doNotify"", ""doNotify() distinguishes between notify() and notifyAll() methods depending on desired behavior"", ""notifyAll"")"
You can convert a FileOutputStream to a character based Writer using the Java OutputStreamWriter class,"(""FileOutputStream"", ""OutputStreamWriter converts a FileOutputStream to a character based Writer."", ""OutputStreamWriter""); (""OutputStreamWriter"", ""OutputStreamWriter converts a FileOutputStream to a character based Writer."", ""Writer"")"
The channel returned by the SelectionKey.channel() method should be cast to the channel you need to work with a ServerSocketChannel or SocketChannel etc,"(""SelectionKey.channel()"", ""The method SelectionKey.channel() can yield a channel object, which can be cast to work with a ServerSocketChannel."", ""ServerSocketChannel""); (""SelectionKey.channel()"", ""The method SelectionKey.channel() can yield a channel object, which can be cast to work with a SocketChannel."", ""SocketChannel"")"
java.io.Writer works just like combining the Reader with InputStream or the Writer with OutputStream,"(""Writer"", ""Writer and Reader are related as they are often used together in Java for handling I/O operations. Writer is similar to Reader but for writing, typically involving character streams."", ""Reader""); (""Writer"", ""The description compares Writer to a combination involving InputStream, suggesting a possible functional relationship in handling data streams."", ""InputStream""); (""Writer"", ""Writer is compared to a combination involving OutputStream, indicating a relationship in processing output data streams."", ""OutputStream"")"
Object.wait(long timeout) means that the majority of the time waited to be able to lock the lock and enter the critical section is spent waiting in the wait() call inside the lock() method not being blocked trying to enter the lock() method,"(""Wait"", ""The wait method is used within the lock method, indicating a functional dependency where wait is called as part of the locking process."", ""Lock""); (""Object"", ""The wait method is associated with the Object class, as it belongs to objects in Java for thread synchronization."", ""Wait""); (""Object"", ""While not directly stated, the association of both wait and lock methods under the context of Object implies that they are part of thread management techniques within a class context."", ""Lock"")"
Remember that even if the 4 threads call wait() and notify() on the same shared string instance the signals from the doWait() and doNotify() calls are stored individually in the two MyWaitNotify instances,"(""wait"", ""The methods wait and notify are complementary synchronization methods often used together to manage thread communication."", ""notify""); (""doWait"", ""The methods doWait and doNotify seem to be related as mirrored actions within the MyWaitNotify class, likely designed to manage waiting and notifying operations."", ""doNotify""); (""MyWaitNotify"", ""doWait is a method of the MyWaitNotify class, designed to handle wait operations."", ""doWait""); (""MyWaitNotify"", ""doNotify is a method of the MyWaitNotify class, designed to handle notify operations."", ""doNotify"")"
The rest of the components like Pipe and FileLock are merely utility classes to be used in conjunction with the three core components,"(""Pipe"", ""Pipe and FileLock are mentioned together as utility classes, suggesting they can be used in a complementary fashion."", ""FileLock"")"
java.io.PrintStream example first creates a PrintStream which is connected to an OutputStream,NULL
"If the Deque is empty, pollLast() returns null. This is different than removeLast() which throws an exception if the Deque is empty.","(""Deque"", ""pollLast() is a method that operates on the Deque class."", ""pollLast()""); (""Deque"", ""removeLast() is a method that operates on the Deque class."", ""removeLast()""); (""pollLast()"", ""pollLast() and removeLast() are methods of Deque with different behaviors for empty Deque."", ""removeLast()"")"
The Map computeIfAbsent() method works similarly to the compute() method but the lambda expression is only called if no entry exists already for the given key,"(""Map"", ""ComputeIfAbsent is a method that belongs to the Map class."", ""ComputeIfAbsent""); (""Map"", ""Compute is a method that belongs to the Map class."", ""Compute""); (""ComputeIfAbsent"", ""computeIfAbsent method behaves similarly to compute method, with the condition that the lambda expression executes only if no entry exists already for the key."", ""Compute"")"
You can get and set the nanoseconds using the getNanos() and setNanos(),NULL
This OutputStream write() example first creates a FileOutputStream to which the data will be written. Then the example enters a while loop. The condition to exit the while loop is the return value of the method hasMoreData().,"(""FileOutputStream"", ""The write() method is used to write data to the FileOutputStream. Thus, it is directly related as it operates on the FileOutputStream."", ""write"")"
Since the BufferedWriter collects the characters written internally in a buffer before writing them to the underlying Writer the speedup is not as noticeable as with other Writer classes (that do not use buffering),"(""BufferedWriter"", ""BufferedWriter relates to Writer as it uses an underlying Writer to output the collected characters. BufferedWriter enhances Writer with an internal buffer for characters."", ""Writer"")"
The Java compiler then generates the corresponding fields getter methods and a hashCode() and equals() method,"(""Java compiler"", ""The Java compiler generates the getter method."", ""getter method""); (""Java compiler"", ""The Java compiler generates the hashCode method."", ""hashCode""); (""Java compiler"", ""The Java compiler generates the equals method."", ""equals"")"
The bigger the result String grows the longer it takes to copy the characters from it into a new StringBuilder and again copy the characters from the StringBuilder into the temporary String created by the toString() method,"(""String"", ""Both classes are involved in the copying process where characters are moved from a String to a StringBuilder"", ""StringBuilder""); (""StringBuilder"", ""The toString method is used to create a temporary string from the StringBuilder"", ""toString"")"
"Instead of calling the stop() method you will have to implement your thread code so it can be stopped, you can implements Runnable which contains an extra method called doStop() which signals to the Runnable to stop.","(""Runnable"", ""Runnable contains the method doStop, which is used to signal the thread to stop."", ""DoStop""); (""Stop"", ""The stop method would typically indicate or control the stopping of the Runnable thread."", ""Runnable"")"
The logp() methods work like the log() methods except each method take an extra two parameters The sourceClass and sourceMethod parameter,NULL
But since the thread waiting in lock() has not yet called queueObject.wait() the call to queueObject.notify() passes into oblivion,"(""Lock"", ""The 'lock()' method causes a thread to wait, and 'queueObject.wait()' is mentioned in this context, suggesting a synchronization mechanism."", ""QueueObject.Wait""); (""QueueObject.Wait"", ""queueObject.wait() and queueObject.notify() are complementary methods typically used together for thread synchronization; one waits while the other signals to continue."", ""QueueObject.Notify"")"
It is possible to compare two buffers using equals() and compareTo(),"(""equals()"", ""Both methods are used to compare objects or data."", ""compareTo()""); (""equals()"", ""Both methods are used to compare objects or data."", ""compareTo()"")"
The names take() and release() may seem a bit odd when using a semaphore for signaling,NULL
If you need to read and write the date and time to a database use the java.sql.Date and java.sql.Timestamp classes,"(""Java.sql.Date"", ""Both classes are used for handling date and time when interacting with a database, indicating they are related in terms of functionality"", ""Java.sql.Timestamp"")"
Since PipedOutputStream is a subclass of OutputStream PipedOutputStream has the same basic methods and use patterns as an OutputStream,"(""PipedOutputStream"", ""PipedOutputStream is a subclass of OutputStream, indicating an inheritance relationship between these two classes"", ""OutputStream"")"
In the following sections I will explain how to use the ReentrantLock class as a Lock,NULL
In contrast to the signaling use case the methods take() and release() are now called by the same thread,NULL
The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called,NULL
The Matcher appendReplacement() and appendTail() methods are used to replace string tokens in an input text and append the resulting string to a StringBuffer,"(""Matcher"", ""The appendReplacement() method is associated with the Matcher class, indicating that it is likely a method of Matcher."", ""appendReplacement""); (""Matcher"", ""The appendTail() method is associated with the Matcher class, indicating that it is likely a method of Matcher."", ""appendTail""); (""appendReplacement"", ""The method appendReplacement() appends the resulting string to a StringBuffer, suggesting an interaction between the method and the class StringBuffer."", ""StringBuffer""); (""appendTail"", ""The method appendTail() appends the resulting string to a StringBuffer, suggesting an interaction between the method and the class StringBuffer."", ""StringBuffer"")"
The Java BufferedReader class is a subclass of the Java Reader class so you can use a BufferedReader anywhere a Reader is required,"(""BufferedReader"", ""BufferedReader is a subclass of Reader, indicating an inheritance relationship"", ""Reader"")"
You can convert a Java Set to a Java List by creating a List and calling its addAll() method passing the Set as parameter to the addAll() method,NULL
The add() and offer() methods differ in how the behave if the Queue is full so no more elements can be added,NULL
The Collections binarySearch() method can search a Java List for an element using a binary search algorithm. The List must be sorted in ascending order before you search it using binarySearch() .,NULL
If unlockWrite() was not called from inside a finallyclause and an exception was thrown from the critical section the ReadWriteLock would remain write locked forever causing all threads calling lockRead() or lockWrite() on that ReadWriteLock instance to halt indefinately,NULL
Third the characters written to the StringWriter are obtained via the two methods toString() and getBuffer(),"(""toString"", ""The method toString() is used to obtain characters written to the StringWriter, indicating a functional relationship between the method and the class."", ""StringWriter""); (""getBuffer"", ""The method getBuffer() is used to obtain characters written to the StringWriter, indicating a functional relationship between the method and the class."", ""StringWriter"")"
The decrementAndGet() subtracts 1 from the AtomicInteger value and returns its value after the subtraction. The getAndDecrement() also subtracts 1 from the AtomicInteger value but returns the value the AtomicInteger had before the subtraction.,NULL
"If the Deque is empty, removeLast() will throw an exception. This is different from pollLast() which returns null if the Deque is empty.",NULL
You may be familiar with these two wellknown PrintStream instances in Java System.out and System.err,"(""System"", ""System.out is a static field that provides access to a PrintStream method for standard output."", ""out""); (""System"", ""System.err is a static field that provides access to a PrintStream method for error output."", ""err"")"
"If adding the element fails, for instance if the Deque is full, the push() method will throw an exception. This is similar to how the addFirst() method works.","(""Push"", ""The Push method will throw an Exception if adding the element fails."", ""Exception""); (""Push"", ""The Push method is similar to the AddFirst method in terms of functionality."", ""AddFirst""); (""Push"", ""The Push method will throw an Exception if adding the element fails."", ""Exception""); (""Push"", ""The Push method is similar to the AddFirst method in terms of functionality."", ""AddFirst"")"
Finally you can access the localized values in the ResourceBundle via its different getString() and getObject() etc,NULL
"The tailMap() method is similar to the headMap() method, except that tailMap() returns all elements that are equal to or higher than the given parameter element.",NULL
That you would not call wait() and notify() on an internal monitor object but rather on the This is probably true,NULL
You can parse a String into a java.util.Date instance using the parse() method of the SimpleDateFormat instance,NULL
"If the Deque is empty, peekFirst() returns null. This is similar to how peek() works","(""Deque"", ""The method peekFirst is associated with the class Deque."", ""peekFirst""); (""Deque"", ""The method peek is associated with the class Deque."", ""peek"")"
When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start() like this,"(""Thread"", ""The run method is a member of the Thread class."", ""run""); (""Thread"", ""The start method is a member of the Thread class."", ""start""); (""run"", ""The run method and start method are both associated with the Thread class and are commonly used in the context of creating and starting a thread."", ""start""); (""Thread"", ""The run method is a member of the Thread class."", ""run""); (""Thread"", ""The start method is a member of the Thread class."", ""start""); (""run"", ""The run method and start method are both associated with the Thread class and are commonly used in the context of creating and starting a thread."", ""start"")"
java.util.logging.Handler is not a Filter even though it has the same effect,NULL
The Java PrintStream class contains the powerful format() and printf() methods (they do exactly the same but the name printf is more familiar to Cprogrammers),NULL
java.util.TreeSet Comparator will then decide the ordering of the elements in the TreeSet,"(""TreeSet"", ""The Comparator class is used to decide the ordering of elements within the TreeSet class."", ""Comparator""); (""TreeSet"", ""The TreeSet class is part of the java.util package."", ""java.util"")"
Exactly how to handle the calls to commit() and or rollback() is covered in the JDBC Transactions Tutorial,"(""COMMIT"", ""Commit is a method discussed in the JDBC Transactions Tutorial."", ""JDBC TRANSACTIONS TUTORIAL""); (""ROLLBACK"", ""Rollback is a method discussed in the JDBC Transactions Tutorial."", ""JDBC TRANSACTIONS TUTORIAL"")"
You may be tempted then to always call notifyAll() instead notify() but this is a bad idea performance wise,"(""NotifyAll"", ""Both are methods used for notification purposes, discussed in relation to performance trade-offs."", ""Notify"")"
The File class contains the method mkdir() and mkdirs() for that purpose,"(""File"", ""File class contains the method mkdir()"", ""mkdir()""); (""File"", ""File class contains the method mkdirs()"", ""mkdirs()"")"
The lock() method locks the Lock instance so that all threads calling lock() are blocked until unlock() is executed,NULL
The call to read() reads a character from the PushbackReader just like from any other Reader,"(""read()"", ""The 'read()' method operates on the 'PushbackReader' class"", ""PushbackReader""); (""PushbackReader"", ""The 'PushbackReader' class is described as having similar functionality to 'Reader'"", ""Reader"")"
java.io.BufferedInputStream is typically much faster than reading a single byte at a time from an InputStream especially for disk access and larger data amounts,NULL
Even though the Java Networking APIs enable you to open and close network connections via sockets all communication happens via the Java IO classes InputStream and OutputStream,NULL
The tailMap() method is similar to the headMap() method except that tailMap() returns all elements that are equal to or higher than the given parameter element,NULL
Again here the first() and next() methods return the unicode index of the found word boundary,NULL
"The `getAndIncrement()` method does the same as the `incrementAndGet()` method, except the `getAndIncrement()` method returns the value of the element *before* it is incremented.",NULL
When creating and starting a thread a common mistake is to call the run() method of the Thread instead of start(),"(""Thread"", ""The run method is a member function of the Thread class and should be called to define what the thread should execute."", ""run""); (""Thread"", ""The start method is a member function of the Thread class and is used to actually start the thread's execution."", ""start"")"
Obviously if the input parameter to contains() is null the contains() method will not use the equals() method to compare against each element but rather use the == operator,"(""Contains"", ""The 'contains' method uses the 'equals' method to compare elements."", ""Equals""); (""Contains"", ""The 'contains' method uses the '==' operator when the input parameter is null."", ""=="")"
Thus you can use the return values of start() and end() inside a String.substring() call,NULL
The PrintWriter class has all the same methods as the PrintStream except for the methods to write raw bytes,"(""PrintWriter"", ""The PrintWriter class has methods, indicating that methods are likely functions or behavior within the PrintWriter class."", ""Method""); (""PrintStream"", ""The PrintStream class also has methods, similar to PrintWriter, implying that methods are functions or behavior within this class."", ""Method"")"
"The Java SortedMap interface, java.util.SortedMap, is a subtype of the java.util.Map interface, with the addition that the elements stored in a Java SortedMap map are sorted internally. This means you can iterate the elements stored in a SortedMap in the sort order.","(""SortedMap"", ""SortedMap class is part of the java.util.SortedMap package."", ""java.util.SortedMap""); (""SortedMap"", ""The SortedMap class is a subtype of the java.util.Map interface."", ""java.util.Map"")"
Similarly the compareTo() method should throw a ClassCastException if the input parameter is not of the same class as the class of the object compareTo() is called on,"(""CompareTo"", ""The compareTo() method throws a ClassCastException when certain conditions are not met, indicating an error relationship between them."", ""ClassCastException""); (""CompareTo"", ""The compareTo() method is called on objects of a specific class, establishing a relationship with this class."", ""Class"")"
The class java.lang.Object defines three methods wait() notify() and notifyAll() to facilitate this,NULL
Both Java File and FileChannel works but in case you want a pure Java NIO solution use the Java NIO FileChannel class,NULL
The methods getAndIncrement() and incrementAndGet() works like getAndAdd() and addAndGet() but just add 1 to the value of the AtomicLong,"(""GetAndIncrement"", ""GetAndIncrement is a method that operates on the AtomicLong class."", ""AtomicLong""); (""IncrementAndGet"", ""IncrementAndGet is a method that operates on the AtomicLong class."", ""AtomicLong""); (""GetAndAdd"", ""GetAndAdd is a method that operates on the AtomicLong class."", ""AtomicLong""); (""AddAndGet"", ""AddAndGet is a method that operates on the AtomicLong class."", ""AtomicLong"")"
"celingEntry(), floorEntry(), higherEntry(), lowerEntry(),The NavigableMap also has methods to get the entry for a given key, rather than the key itself. These methods behave like the ceilingKey() etc. methods, except they return a Map.Entry instead of the key object itself.",NULL
The Java GZIPOutputStream class (java.util.zip.GZIPOutStream) can be used to GZIP compress data and write it to an OutputStream,"(""GZIPOutputStream"", ""GZIPOutputStream is a class that belongs to the java.util.zip package."", ""java.util.zip""); (""GZIPOutputStream"", ""GZIPOutputStream writes compressed data to an OutputStream."", ""OutputStream""); (""GZIPOutputStream"", ""GZIPOutputStream is a class that belongs to the java.util.zip package."", ""java.util.zip""); (""GZIPOutputStream"", ""GZIPOutputStream writes compressed data to an OutputStream."", ""OutputStream"")"
Object.wait(long timeout) allows other threads to call wait() or notify() too since these methods must be called from inside a synchronized block,"(""wait"", ""The method 'wait' is called on the class 'Object', indicating a relationship between the method and the class it belongs to."", ""Object""); (""notify"", ""The method 'notify' is called on the class 'Object', indicating a relationship between the method and the class it belongs to."", ""Object"")"
The java.util.TimeZone class is used in conjunction with the java.util.Calendar class,"(""TimeZone"", ""TimeZone belongs to the java.util package"", ""java.util""); (""Calendar"", ""Calendar belongs to the java.util package"", ""java.util""); (""TimeZone"", ""TimeZone is used in conjunction with the Calendar class"", ""Calendar"")"
You do so by calling the Cipher update() or doFinal() methods,NULL
The BlockingDeque interface in the java.util.concurrent class represents a deque which is thread safe to put into and take instances from,"(""java.util.concurrent"", ""BlockingDeque is an interface within the java.util.concurrent package"", ""BlockingDeque"")"
Here are two examples of taking an element from a Java Queue using its poll() and remove() methods,NULL
If you need an integer value use the round() floor() or ceil() method,NULL
Notice how it is possible to change that reference through both the setValue() and add() methods,NULL
a given date is or convert dates and times between time zones use the java.util.Calendar and java.util.GregorianCalendar classes,"(""Java.Util.Calendar"", ""Both are classes associated with handling dates and times, and they likely interact or are used together to perform time zone conversions."", ""Java.Util.GregorianCalendar""); (""Java.Util.Calendar"", ""Java.Util.Calendar is located within the Java.Util package, indicating a hierarchical relationship."", ""Java.Util""); (""Java.Util.GregorianCalendar"", ""Java.Util.GregorianCalendar is also within the Java.Util package, indicating a hierarchical relationship."", ""Java.Util"")"
If the call to take() happens before the call to release() the thread calling release() will still know that take() was called because the signal is stored internally in the signal variable,NULL
The compareAndSet() method can compare the reference stored in the AtomicReference instance with an expected reference and if they two references are the same (not equal as in equals() but same as in ==) then a new reference can be set on the AtomicReference instance,NULL
Anders Hejlsberg on checked vs. unchecked exceptions httpwww.artima.comintvhandcuffs.html James Gosling on checked exceptions httpwww.artima.comintvsolid.html Bill Venners on Exceptions httpwww.artima.cominterfacedesignexceptions.html Bruce Eckel on checked exceptions httpwww.artima.comintvtypingP.html Designing with Exceptions (Bill Venners www.artima.com) httpwww.artima.comdesigntechniquesdesexcept.html Effective Java (Joshua Bloch Addison Wesley 2001) Daniel Pietraru in favor of checked exceptions Exceptional Java Checked exceptions are priceless茂驴�?For everything else there is the RuntimeException,"(""Effective Java"", ""Effective Java discusses practices related to RuntimeException in context of Java programming"", ""RuntimeException""); (""Effective Java"", ""Effective Java discusses common practices related to RuntimeException in the context of Java programming"", ""RuntimeException"")"
But the thread waiting in the lock() method will not leave that block until the isLocked is set to false and a monitorObject.notify() is executed as it happens in unlock(),NULL
As you saw in the previous section when you register a Channel with a Selector the register() method returns a SelectionKey objects,NULL
By walking through all directories and deleting all files (inside visitFile()) in each directory and afterwards delete the directory itself (inside postVisitDirectory()) you can delete a directory with all subdirectories and files,"(""visitFile"", ""visitFile is called to delete files, and postVisitDirectory is subsequently called to delete directories, indicating an operational sequence for deleting directory contents and then the directory itself."", ""postVisitDirectory"")"
The lower() method does the opposite of the higher() method meaning it returns the highest element that is less than (not equal to) the given parameter,"(""Lower"", ""The lower() method returns an element that is less than the one returned by the higher() method, indicating they are opposite functions."", ""Higher"")"
In many cases though you can replace the use of the File class with use of the Path interface,NULL
Once the Mac instance is initialized you can calculate a MAC from data by calling the update() and doFinal() method,NULL
Deque.offerFirst(E e) is different from the addFirst() method which will throw an exception is adding an element to the beginning of the Deque fails,"(""OfferFirst"", ""OfferFirst is compared to AddFirst in terms of behavior when adding an element, highlighting a functional difference."", ""AddFirst""); (""OfferFirst"", ""OfferFirst is a method that operates on the Deque class, specifically adding elements at the beginning."", ""Deque""); (""AddFirst"", ""AddFirst is a method of the Deque class and is responsible for adding elements to its beginning."", ""Deque"")"
The main difference between the Runnable run() method and the Callable call() method is that the call() method can return an Object from the method call,"(""Runnable"", ""The run() method is a member of the Runnable class."", ""run""); (""Callable"", ""The call() method is a member of the Callable class."", ""call""); (""Runnable"", ""The run() method is a member of the Runnable class."", ""run""); (""Callable"", ""The call() method is a member of the Callable class."", ""call"")"
The toNanos() is different from the getNano() in that the getNano() only returns the part of the Duration which is less than one second,"(""toNanos"", ""toNanos is different from getNano in that getNano only returns the part of the Duration which is less than one second"", ""getNano"")"
Collection.add(E e) is different from the offer() method which will return false if it cannot insert the element,"(""Collection"", ""The 'add' method is part of the 'Collection' class."", ""add""); (""Collection"", ""The 'offer' method is part of the 'Collection' class."", ""offer"")"
To take an element from a Java Queue you can call either its poll() or remove() method,"(""Queue"", ""The poll() method is a functionality provided by the Queue class in Java."", ""poll()""); (""Queue"", ""The remove() method is another functionality provided by the Queue class."", ""remove()"")"
java.util.TreeMap Comparator will then be used to sort the keys of the key value pairs stored in the SortedMap,"(""TreeMap"", ""TreeMap uses Comparator to sort the keys of the key-value pairs stored in it."", ""Comparator""); (""TreeMap"", ""TreeMap is a type of SortedMap that stores key-value pairs."", ""SortedMap"")"
If a thread calls lock() twice without calling unlock() in between the second call to lock() will block,"(""Thread"", ""A thread can invoke the lock method."", ""Lock""); (""Thread"", ""A thread can invoke the unlock method."", ""Unlock""); (""Lock"", ""Both methods are related as they handle locking and unlocking mechanisms in synchronization contexts."", ""Unlock"")"
The start() call will return as soon as the thread is started. It will not wait until the run() method is done.,"(""start()"", ""The start() method initiates a process that involves the run() method"", ""run()"")"
"If the Deque is empty, peekFirst() returns null. This is similar to how peek() works, but the method name peekFirst() is a bit more saying about which end of the Deque you peek at.","(""DEQUE"", ""The method peekFirst() operates on the DEQUE class to check the first element."", ""PEEKFIRST()""); (""DEQUE"", ""The method peek() operates on the DEQUE class to check an element."", ""PEEK()""); (""PEEKFIRST()"", ""Both methods provide similar functionality for peeking in the DEQUE class."", ""PEEK()""); (""DEQUE"", ""The method peekFirst() operates on the DEQUE class to check the first element."", ""PEEKFIRST()""); (""DEQUE"", ""The method peek() operates on the DEQUE class to check an element."", ""PEEK()""); (""PEEKFIRST()"", ""Both methods provide similar functionality for peeking in the DEQUE class."", ""PEEK()"")"
If isLocked is true however the thread calling lock() is parked waiting in the monitorObject.wait() call,NULL
The remove() method will use the o.equals() to decide if the object o passed as parameter matches a given element in the BlockingQueue.,NULL
"In general you can call the?markSupported()?method to find out if?mark()?and?reset()are supported on a given?InputStream?or not, but the?BufferedInputStream?supports them.",NULL
If you compare the Lock and FairLock classes you will notice that there is somewhat more going on inside the lock() and unlock() in the FairLock class,"(""FairLock"", ""FairLock class uses the lock() method"", ""lock()""); (""FairLock"", ""FairLock class uses the unlock() method"", ""unlock()""); (""FairLock"", ""FairLock class uses the lock() method"", ""lock()""); (""FairLock"", ""FairLock class uses the unlock() method"", ""unlock()"")"
The third variant of getConnection() takes a database URL and a Properties object as parameter,NULL
"You can get the current line number from the?LineNumberReader?by calling the?getLineNumber()method. You can also set the current line number, should you need to, by calling the?setLineNumber()?method","(""LineNumberReader"", ""getLineNumber is a method associated with the LineNumberReader class, allowing retrieval of the current line number."", ""getLineNumber""); (""LineNumberReader"", ""setLineNumber is a method associated with the LineNumberReader class, allowing setting of the current line number."", ""setLineNumber"")"
Executing unlock() sets isLocked back to false and notifies (awakens) one of the threads waiting in the wait() call in the lock() method if any,NULL
The SimpleDateFormat class does this via a version of the format() method that takes the Date StringBuffer and a FieldPosition instance as parameters,NULL
The getAndIncrement() method does the same as the incrementAndGet() method except the getAndIncrement() method returns the value of the element before it is incremented,"(""GetAndIncrement"", ""Both methods perform similar operations, incrementing a value, but differ in when they return the value."", ""IncrementAndGet"")"
java.util.TreeMap Comparator will then be used to sort the keys of the key value pairs stored in the NavigableMap,"(""java.util.TreeMap"", ""The java.util.TreeMap uses Comparator for sorting its keys."", ""Comparator""); (""java.util.TreeMap"", ""The java.util.TreeMap is stored in the form of key-value pairs in the NavigableMap."", ""NavigableMap"")"
In other words the calling thread must call wait() or notify() from inside a synchronized block,NULL
As you can see both the waiting and notifying thread calls wait() and notify() from within a synchronized block,NULL
However unless you need to specify all these parameters explicitly for your ThreadPoolExecutor it is often easier to use one of the factory methods in the java.util.concurrent.Executors class as shown in the ExecutorService text,NULL
"You can choose between the following Deque implementations in the Java Collections API:java.util.LinkedList,java.util.ArrayDeque",NULL
Put shortly the thread waiting in lock() needs an unlock() call to execute successfully for it to exit lock() and the synchronized blocks inside it,"(""Lock"", ""The lock() method requires an unlock() call to proceed, indicating a synchronization relationship."", ""Unlock""); (""Lock"", ""The lock() method requires an unlock() call to proceed, indicating a synchronization relationship."", ""Unlock"")"
Java NIO has more classes and components than these but the Channel Buffer and Selector forms the core of the API in my opinion,"(""Java NIO"", ""The Channel class is part of the core classes and components mentioned for the Java NIO package."", ""Channel""); (""Java NIO"", ""The Buffer class is part of the core classes and components mentioned for the Java NIO package."", ""Buffer""); (""Java NIO"", ""The Selector class is part of the core classes and components mentioned for the Java NIO package."", ""Selector"")"
The DateTimeFormatter is located in the java.time.format package so the fully qualified class name is java.time.format.DateTimeFormatter,NULL
The ceilingEntry() is thus similar to the ceilingKey() method except the ceilingKey() method only returns the key and ceilingKey() returns a Map.Entry object containing both the key and value,NULL
"unless you need to specify all these parameters explicitly for your ThreadPoolExecutor, it is often easier to use one of the factory methods in the java.util.concurrent.Executors class",NULL
Once the read operation has completed the data read into the ByteBuffer and then into a String and printed to System.out,NULL
javax.lang.model.util.Elements is possible to specify generic types for most (if not all) of the components in the Java Collections API,NULL
The Java PrintWriter class contains the powerful format() and printf() methods,"(""PrintWriter"", ""The method 'format' is a member or function provided by the 'PrintWriter' class."", ""format""); (""PrintWriter"", ""The method 'printf' is a member or function provided by the 'PrintWriter' class."", ""printf"")"
If an InputStream subclass supports the mark() and reset() methods then that subclass should override the markSupported() to return true,NULL
Not until a thread has called release() will the thread calling take() be allowed to deliver its signal,"(""Release"", ""The relationship is that the method 'release()' must be called by the thread for the method 'take()' to be allowed to deliver its signal."", ""Take"")"
The poll() and remove() both removes the first element in the Queue. They differ in how they behave if the Queue is empty. The poll() method returns null if the Queue is empty. The remove() method throws an exception if the Queue is empty.,"(""Poll()"", ""The poll() method operates on the Queue class as it removes the first element from it."", ""Queue""); (""Remove()"", ""The remove() method operates on the Queue class as it removes the first element from it."", ""Queue""); (""Poll()"", ""The poll() method operates on the Queue class as it removes the first element from it."", ""Queue""); (""Remove()"", ""The remove() method operates on the Queue class as it removes the first element from it."", ""Queue"")"
Notice how the execute() method will throw an IllegalStateException if execute() is called after stop() has been called,NULL
The methods hashCode() and equals() play a distinct role in the objects you insert into Java collections,NULL
Notice the two synchronized blocks inside the set() and get() method,"(""SET"", ""Both SET and GET are methods that appear close together in the context, suggesting a synchronized operation is shared between them"", ""GET"")"
Therefore if a thread calls notify() before the thread to signal has called wait() the signal will be missed by the waiting thread,NULL
"celingEntry(), floorEntry(), higherEntry(), lowerEntry(),These methods behave like the ceilingKey() etc. methods, except they return a Map.Entry instead of the key object itself.",NULL
By default the ConsoleHandler uses a SimpleFormatter to format the messages before writing them to System.err,NULL
The hashCode() method of objects is used when you insert them into a HashTable HashMap or HashSet,"(""HashCode"", ""The hashCode() method is used when objects are inserted into a HashTable."", ""HashTable""); (""HashCode"", ""The hashCode() method is used when objects are inserted into a HashMap."", ""HashMap""); (""HashCode"", ""The hashCode() method is used when objects are inserted into a HashSet."", ""HashSet"")"
So as you can see a combination of the hashCode() and equals() methods are used when storing and when looking up objects in a hashtable,"(""HashCode"", ""The hashCode() method is used in combination with equals() when storing data in a Hashtable, indicating its role in object storage control."", ""Hashtable""); (""Equals"", ""The equals() method works with hashCode() to determine object equivalency and storage in a Hashtable."", ""Hashtable"")"
Here is a modified version of MySignal called MyWaitNotify that uses wait() and notify(),"(""MyWaitNotify"", ""MyWaitNotify is described as a modified version of MySignal, indicating it is derived from or based upon MySignal."", ""MySignal""); (""MyWaitNotify"", ""The MyWaitNotify class uses the wait method, suggesting it is part of its functionality."", ""wait""); (""MyWaitNotify"", ""The MyWaitNotify class uses the notify method, suggesting it is part of its functionality."", ""notify"")"
To set a new System stream use one of th emethods System.setIn() System.setOut() or System.setErr(),"(""System"", ""The setIn method is a part of the System package, indicating that it belongs to or is invoked upon the System package."", ""setIn""); (""System"", ""The setOut method is a part of the System package, indicating that it belongs to or is invoked upon the System package."", ""setOut""); (""System"", ""The setErr method is a part of the System package, indicating that it belongs to or is invoked upon the System package."", ""setErr"")"
"The add() and offer() methods differ in how the behave if the Queue is full, so no more elements can be added. The add() method throws an exception in that case, whereas the offer() method just returns false.",NULL
Both the Pattern and Matcher classes are covered in detail in their own texts,NULL
The Java Set interface as a method called removeAll() which removes all elements in the Set which are also present in another Collection,"(""Java Set"", ""The removeAll method is a function available in the Java Set interface."", ""RemoveAll""); (""RemoveAll"", ""The removeAll method operates on elements present in a Collection."", ""Collection"")"
The Map compute() method takes a key object and a lambda expression as parameters. The lambda expression must implement the java.util.function.BiFunction interface.,"(""compute"", ""The compute() method is a method of the Map class."", ""Map""); (""compute"", ""The lambda expression parameter of the compute() method implements the BiFunction interface from the java.util.function package."", ""java.util.function"")"
java.text.CollationKey is faster than the stringwise comparison the RuleBasedCollator uses normally,"(""RuleBasedCollator"", ""RuleBasedCollator uses java.text.CollationKey for faster string comparison"", ""java.text.CollationKey"")"
The ForkJoinPool located in the java.util.concurrent package so the full class name is java.util.concurrent.ForkJoinPool,"(""ForkJoinPool"", ""ForkJoinPool is located in the java.util.concurrent package"", ""java.util.concurrent"")"
Notice how notifyAll() is only called from enqueue() and dequeue() if the queue size is equal to the size bounds (0 or limit),NULL
In other words you can add all elements from a List or Set into a List with addAll(),"(""List"", ""The addAll method is used to add elements to the List."", ""addAll""); (""Set"", ""The addAll method can add all elements from a Set."", ""addAll""); (""List"", ""The addAll method is used to add elements to the List."", ""addAll""); (""Set"", ""The addAll method can add all elements from a Set."", ""addAll"")"
Since only one thread is allowed to take the semaphore all other threads calling take() will be blocked until release() is called,"(""Semaphore"", ""The take() method operates on the Semaphore class, allowing threads to attempt taking the semaphore."", ""Take""); (""Semaphore"", ""The release() method operates on the Semaphore class, which is used to unblock threads previously blocked by the take() method."", ""Release"")"
The format() and printf() methods allow you to mix text and data in very advanced ways using a formatting string,"(""Format"", ""Both are methods used for formatting strings and can be used to mix text and data in advanced ways."", ""Printf""); (""Format"", ""Both are methods used for formatting strings and can be used to mix text and data in advanced ways."", ""Printf"")"
The Collections replaceAll() method uses the equals() method of each element to determine if the element is equal to the element to replace or not,"(""Collections"", ""The replaceAll() method is a part of the Collections class, as indicated by the usage context."", ""replaceAll""); (""Collections"", ""The equals() method is mentioned in the context of being used with elements of the Collections class."", ""equals""); (""replaceAll"", ""The equals() method is utilized within the functionality of the replaceAll() method to compare elements."", ""equals"")"
The call to unread() pushes a character back into the PushbackReader. The next time read() is called the pushed back characters will be read first.,NULL
java.sql.ResultSet ResultSet has 3 different columns (Name Age Gender) and 3 records with different values for each column,"(""ResultSet"", ""Name is one of the columns in the ResultSet class, suggesting it corresponds to a method or field accessible within ResultSet."", ""Name""); (""ResultSet"", ""Age is one of the columns in the ResultSet class, suggesting it corresponds to a method or field accessible within ResultSet."", ""Age""); (""ResultSet"", ""Gender is one of the columns in the ResultSet class, suggesting it corresponds to a method or field accessible within ResultSet."", ""Gender"")"
First the ResourceBundle class will look for a ListResourceBundle and then for a PropertyResourceBundle,"(""ResourceBundle"", ""ResourceBundle class searches for ListResourceBundle first"", ""ListResourceBundle""); (""ResourceBundle"", ""ResourceBundle class searches for PropertyResourceBundle after ListResourceBundle"", ""PropertyResourceBundle""); (""ResourceBundle"", ""ResourceBundle class searches for ListResourceBundle first"", ""ListResourceBundle""); (""ResourceBundle"", ""ResourceBundle class searches for PropertyResourceBundle after ListResourceBundle"", ""PropertyResourceBundle"")"
The returned long value can be used to initialize java.util.Date java.sql.Date java.sql.Timestamp and java.util.GregorianCalendar objects,NULL
In fact the implementation of the ExecutorService interface present in the java.util.concurrent package is a thread pool implementation,NULL
Notice how the Collections.sort() method now takes a java.util.Comparator as parameter in addition to the List,NULL
For instance ordinary debug trace logging calls to entering() and exiting() would be called at the beginning and end of a method call,"(""Entering"", ""Entering and Exiting are related as they represent the start and end of a method call respectively."", ""Exiting"")"
Each of the methods ceilingEntry() floorEntry() higherEntry() and lowerEntry() will be covered in the following sections,"(""CeilingEntry"", ""method""); (""FloorEntry"", ""method""); (""HigherEntry"", ""method""); (""LowerEntry"", ""method"")"
java.text.SimpleDateFormat is not exactly clear how the FieldPosition instance is used,"(""SIMPLEDATEFORMAT"", ""The SimpleDateFormat class interacts with the FieldPosition class to determine how field positions are utilized in formatting operations."", ""FIELDPOSITION"")"
The LocalDate Java class is located in the java.time package so its fully qualified class name is java.time.LocalDate,NULL
If there is no more data to read from the underlying Reader then the BufferedReader readLine() method will return null,NULL
java.util.List is different from a Java Set where each element can occur only once,NULL
Deque.addLast(E e) is different from the offerLast() method which will return false if the element cannot be added to the Deque,NULL
Do not confuse this class with the java.util.Arrays class in the Java Collections suite which contains utility methods for sorting arrays converting them to collections etc,NULL
You obtain a Collection of the values stored in a Map via the values() method,"(""values()"", ""The values() method is a function of the Map class, used to retrieve stored values."", ""Map""); (""Collection"", ""Collection and Map are related because the values() method returns a Collection derived from Map."", ""Map"")"
Unfortunately if an exception is thrown during the write() call in the example above that exception will cause the program flow to break before the close() method is called,"(""Write"", ""The Close method is intended to be called after the Write method completes to ensure resources are released, indicating a sequential operation relationship."", ""Close"")"
Being a subclass of Hashtable you can actually use the get() and put() method of the Hashtable class which allow the use of nonstring keys and values,NULL
"A Java Properties instance clearly is as Hashtable, but it should not share the Hashtable interface. So - the ""Is a"" part of this rule should be interpreted as ""Should be usable as a"" instead. Using that formulation, Properties would not have been made a subclass of Hashtable, because Properties should not be usable as a Hashtable .","(""Java Properties"", ""Java Properties is implemented in a way that is similar to Hashtable."", ""Hashtable""); (""Java Properties"", ""Java Properties should not share the Hashtable interface."", ""interface""); (""Java Properties"", ""Java Properties was made a subclass of Hashtable, which is considered inappropriate in this context."", ""subclass"")"
"I mean, only the same, single thread is ever allowed to call inc(). Multiple threads can call count().","(""Inc"", ""Both Inc() and Count() are methods involved in threading and resource access control within the same context."", ""Count"")"
"If the Deque is empty, poll() returns null. This is different than remove() which throws an exception if the Deque is empty.",NULL
The peek() works like the element() method except it does not throw an exception if the Queue is empty. Instead it just returns null.,"(""Peek"", ""Peek works similarly to the Element method, except it returns null instead of throwing an exception when the Queue is empty."", ""Element""); (""Peek"", ""Peek operates on the Queue to check its head element without removal."", ""Queue""); (""Element"", ""Element method operates on the Queue to access its head element, throwing an exception if the Queue is empty."", ""Queue"")"
Notice the doStop() and keepRunning() methods. The doStop() is intended to be called from another thread than the thread executing the MyRunnable's run() method. The keepRunning() method is called internally by the thread executing the MyRunnable's run() method. As long as doStop() has not been called the keepRunning() method will return true - meaning the thread executing the run() method will keep running.,"(""DOSTOP"", ""Both are methods mentioned as part of the process where DOSTOP influences KEEPRUNNING."", ""KEEPRUNNING""); (""DOSTOP"", ""DOSTOP is called from outside while MYRUNNABLE is running."", ""MYRUNNABLE""); (""KEEPRUNNING"", ""KEEPRUNNING is used to check conditions within the MYRUNNABLE run method."", ""MYRUNNABLE""); (""RUN"", ""RUN is a method executed by MYRUNNABLE."", ""MYRUNNABLE"")"
System.err works like System.out except it is normally only used to output error texts,"(""System"", ""The method 'err' is a part of the 'System' class."", ""err""); (""System"", ""The method 'out' is a part of the 'System' class."", ""out"")"
To do so set the upper bound to 1 and have the call to take() and release() guard the critical section,"(""Take"", ""Both methods are used to guard the critical section and are related by their function in synchronization."", ""Release"")"
java.io.InputStream method is useful if you need to read all bytes from a file via a FileInputStream into a byte array,NULL
Notice how the getMonth() and getDayOfWeek() methods return an enum instead of an int,"(""GetMonth"", ""Both GetMonth and GetDayOfWeek are methods mentioned together in the context of enum return types."", ""GetDayOfWeek"")"
java.io.InputStreamReader example first creates a FileInputStream and then wraps it in an InputStreamReader,"(""FileInputStream"", ""The InputStreamReader wraps the FileInputStream, indicating a compositional or usage relationship where the InputStreamReader is used to read input from the FileInputStream."", ""InputStreamReader"")"
Deque.offerLast(E e) is different from the addLast() method which will throw an exception is adding an element to the end of the Deque fails,NULL
Java has 3 streams called System.in System.out and System.err which are commonly used to provide input to and output from Java applications,"(""System.in"", ""System.in and System.out are related as streams commonly used for input and output in Java applications"", ""System.out""); (""System.out"", ""System.out and System.err are related as streams commonly used for standard output and error output in Java applications"", ""System.err""); (""System.in"", ""System.in and System.err are related as input and error streams commonly used in Java applications"", ""System.err"")"
To access a private field you will need to call the Class.getDeclaredField(String name) or Class.getDeclaredFields() method,"(""Class"", ""The method `getDeclaredField` is invoked on the `Class` to access a specific private field."", ""getDeclaredField""); (""Class"", ""The method `getDeclaredFields` is invoked on the `Class` to access all private fields."", ""getDeclaredFields"")"
"If the Deque is empty, pollFirst() returns null. This is different than removeFirst() which throws an exception if the Deque is empty.",NULL
Once you have opened a socket (network connection) though you read and write data to and from it via Java IO InputStream and OutputStream classes,"(""InputStream"", ""InputStream is part of the Java IO package, used for reading data."", ""Java IO""); (""OutputStream"", ""OutputStream is part of the Java IO package, used for writing data."", ""Java IO""); (""Socket"", ""A Socket can be used to read data via the InputStream class."", ""InputStream""); (""Socket"", ""A Socket can write data via the OutputStream class."", ""OutputStream"")"
java.util.Set is different from a Java List where each element can occur more than once,"(""java.util"", ""The class 'Set' is part of the package 'java.util'."", ""Set""); (""java.util"", ""The class 'List' is part of the package 'java.util'."", ""List""); (""Set"", ""Set and List are both classes that are part of the Java Collections Framework, with different properties regarding element uniqueness."", ""List"")"
Keep in mind that if some of the operations in the transaction fail you would most likely want to call the rollback() method instead of commit(),NULL
The min() and max() methods return an Optional instance which has a get() method on which you use to obtain the value,"(""Min"", ""The min() method returns an instance of the Optional class."", ""Optional""); (""Max"", ""The max() method returns an instance of the Optional class."", ""Optional""); (""Optional"", ""The Optional class has a get() method to obtain its value."", ""Get""); (""Min"", ""The min() method returns an instance of the Optional class."", ""Optional""); (""Max"", ""The max() method returns an instance of the Optional class."", ""Optional""); (""Optional"", ""The Optional class has a get() method to obtain its value."", ""Get"")"
Only one thread can execute inside any of the two add() and subtract() methods at any given time,NULL
A Java Callable is different from a Runnable in that the Runnable interface run() method does not return a value and it cannot throw checked exceptions (only RuntimeExceptions),"(""Callable"", ""Callable and Runnable are both classes, and Callable is being compared to Runnable to highlight their differences."", ""Runnable""); (""run()"", ""The method run() is associated with the Runnable class as it is part of its interface."", ""Runnable"")"
The ConcurrentHashMap is very similar to the java.util.HashTable class except that ConcurrentHashMap offers better concurrency than HashTable does,"(""ConcurrentHashMap"", ""ConcurrentHashMap is a class that is similar to the java.util.HashTable class"", ""java.util.HashTable""); (""ConcurrentHashMap"", ""ConcurrentHashMap offers better concurrency than the HashTable class"", ""HashTable""); (""ConcurrentHashMap"", ""ConcurrentHashMap is a class that is similar to the java.util.HashTable class"", ""java.util.HashTable""); (""ConcurrentHashMap"", ""ConcurrentHashMap offers better concurrency than the HashTable class"", ""HashTable"")"
You shut down a ScheduledExecutorService using the shutdown() or shutdownNow() methods which are inherited from the ExecutorService interface,NULL
It is the last line of this example that calls the List stream() method to obtain the Stream representing the elements in the List.Once you have obtained a Stream from a List you can iterate the Stream by calling its forEach() method.,NULL
Using that formulation Properties would not have been made a subclass of Hashtable because Properties should not be usable as a Hashtable,"(""Properties"", ""Properties is discussed in the context of not being a subclass of Hashtable, implying a conceptual relationship between the two classes."", ""Hashtable"")"
Many of the core components in the Java Collection API rely on the correct implementation of the `hashCode()` and `equals()` methods.,"(""HashCode"", ""The methods 'hashCode' and 'equals' are typically used together in Java to ensure consistency in collections."", ""Equals"")"
System.in System.out and System.err are initialized by the Java runtime when a Java VM starts up so you dont have to instantiate any streams yourself (although you can exchange them at runtime),"(""Java runtime"", ""The Java runtime initializes the System.in stream when a Java VM starts up."", ""System.in""); (""Java runtime"", ""The Java runtime initializes the System.out stream when a Java VM starts up."", ""System.out""); (""Java runtime"", ""The Java runtime initializes the System.err stream when a Java VM starts up."", ""System.err""); (""Java VM"", ""The Java VM uses the Java runtime when it starts up."", ""Java runtime""); (""Java runtime"", ""The Java runtime initializes the System.in stream when a Java VM starts up."", ""System.in""); (""Java runtime"", ""The Java runtime initializes the System.out stream when a Java VM starts up."", ""System.out""); (""Java runtime"", ""The Java runtime initializes the System.err stream when a Java VM starts up."", ""System.err""); (""Java VM"", ""The Java VM uses the Java runtime when it starts up."", ""Java runtime"")"
"In case the write() method throws an exception, the close() method will never get called.","(""WRITE"", ""The CLOSE method is mentioned in relation to the event where the WRITE method throws an exception and CLOSE may not get called."", ""CLOSE"")"
You create a Path instance using a static method in the Paths class (java.nio.file.Paths) named Paths.get(),NULL
"If no permits are available, the acquire() call will block until a permit is released by another thread. Similarly, a release() calls is blocked if no more permits can be released into this semaphore.","(""Acquire"", ""The acquire() method is part of the semaphore class as it is used to obtain a permit from the semaphore."", ""Semaphore""); (""Release"", ""The release() method is part of the semaphore class as it is used to release a permit back into the semaphore."", ""Semaphore"")"
The submaps are the maps returned by various methods like headMap() subMap() and tailMap(),NULL
If your Java SortedMap was created using a Comparator you can obtain the Comparator used via the SortedMap comparator() method,NULL
You can change this pattern later using the applyPattern() or applyLocalizedPattern() method,"(""ApplyPattern"", ""Both methods are related because they provide functionality to change patterns."", ""ApplyLocalizedPattern"")"
The AtomicBoolean class is located in the java.util.concurrent.atomic package so the full class name is java.util.concurrent.atomic.AtomicBoolean,NULL
java.io.InputStreamReader example creates a FileInputStream and wraps it in a InputStreamReader,"(""FILEINPUTSTREAM"", ""FileInputStream is wrapped in InputStreamReader, indicating a typical usage pattern in Java IO where InputStreamReader takes FileInputStream as input"", ""INPUTSTREAMREADER"")"
When the process() method of the subclass is called the full process is executed including the stepBefore() and stepAfter() of the abstract superclass and the action() method of the subclass,"(""process"", ""The process method is part of the subclass, indicating an implementation relationship."", ""subclass""); (""stepBefore"", ""stepBefore method belongs to the abstract superclass, indicating it is part of its operations."", ""abstract superclass""); (""stepAfter"", ""stepAfter method belongs to the abstract superclass, indicating it is part of its operations."", ""abstract superclass""); (""action"", ""The action method belongs to the subclass, indicating a specific action implemented."", ""subclass"")"
If you want to set a different offset for the dest byte array there is a version of update() and doFinal() which takes an offset parameter extra,"(""UPDATE"", ""Both methods take an offset parameter, suggesting a similar functionality or role."", ""DOFINAL""); (""UPDATE"", ""Both methods take an offset parameter, suggesting a similar functionality or role."", ""DOFINAL"")"
java.security.cert.X509Certificate class represents an X.509 certificate which is used as identity certificate in HTTPS and TLS,NULL
java.io.PrintWriter example first creates a PrintWriter instance which is connected to a FileWriter,"(""PrintWriter"", ""PrintWriter is connected to FileWriter, indicating that it likely uses FileWriter to output data to a file."", ""FileWriter"")"
The Java CharArrayReader is handy when you have data in a char array but need to pass that data to some component which can only read from a Reader (or a Reader subclass),NULL
The compareAndSet() method can compare the reference stored in the AtomicStampedReference instance with an expected reference and the stored stamp with an expected stamp and if they two references and stamps are the same (not equal as in equals() but same as in ==) then a new reference can be set on the AtomicStampedReference instance,"(""COMPAREANDSET"", ""The CompareAndSet method is used to compare references within the AtomicStampedReference class."", ""ATOMICSTAMPEDREFERENCE""); (""COMPAREANDSET"", ""The CompareAndSet method utilizes logical equality, akin to the '==' operation, contrasting with the equals() method."", ""EQUALS"")"
The BoundedSemaphore class shown below has two testandset methods take() and release(),"(""BoundedSemaphore"", ""The testandset method is associated with the BoundedSemaphore class, indicating it could be a method that operates within this class."", ""testandset""); (""BoundedSemaphore"", ""The take method is part of the BoundedSemaphore class, suggesting it may handle operations relevant to this class."", ""take""); (""BoundedSemaphore"", ""The release method is a function of the BoundedSemaphore class, likely dealing with releasing resources or locks the class manages."", ""release"")"
For a 100% precise description of how to implement equals() and hashCode() you should check out the official JavaDoc,"(""equals()"", ""Methods equals() and hashCode() are commonly implemented together to ensure objects are treated correctly in collections."", ""hashCode()""); (""equals()"", ""The JavaDoc contains the official documentation on implementing the equals() method."", ""JavaDoc""); (""hashCode()"", ""The JavaDoc contains the official documentation on implementing the hashCode() method."", ""JavaDoc"")"
You could view the LocalDateTime as a combination of the LocalDate and LocalTime classes of the Java 8 date time API,NULL
InputStream.read() example creates an AsynchronousFileChannel and then creates a ByteBuffer which is passed to the read() method as parameter along with a position of 0,NULL
When the thread that locked the Lock in the first place tries to unlock it by calling unlock() it will be blocked trying to enter the synchronized(this) block in the unlock() method,NULL
Of course you could do this with the start() and end() methods but it is easier to do so with the group functions,"(""Start"", ""Both are methods often mentioned together for similar processes."", ""End""); (""Group"", ""Group functions offer an alternative to using the start and end methods."", ""Start""); (""Group"", ""Group functions offer an alternative to using the start and end methods."", ""End"")"
java.lang.StringBuffer text explains how to use the SimpleDateFormat class to format dates,"(""StringBuffer"", ""StringBuffer likely interacts with SimpleDateFormat for formatting dates in textual representation"", ""SimpleDateFormat"")"
The Java?ExecutorService?submit(Callable)?method is similar to the?submit(Runnable)?method except it takes a?Java Callable?instead of a?Runnable.?,"(""ExecutorService"", ""The method 'submit' belongs to the class 'ExecutorService'."", ""submit""); (""submit"", ""The 'submit' method can take a 'Callable' as an argument."", ""Callable""); (""submit"", ""The 'submit' method can also take a 'Runnable' as an argument."", ""Runnable"")"
Just to make it clear You should NOT use the put() and get() method of the Properties class!,"(""put"", ""The method 'put' belongs to the 'Properties' class, as indicated in the text."", ""Properties""); (""get"", ""The method 'get' belongs to the 'Properties' class, as indicated in the text."", ""Properties"")"
The Java compiler auto generates getter methods toString() hashcode() and equals() methods for these data fields so you dont have to write that boilerplate code yourself,NULL
java.nio.channels.Selector means that you cannot use FileChannel with a Selector since FileChannel cannot be switched into nonblocking mode,"(""FileChannel"", ""FileChannel cannot be used with Selector because it cannot be switched into nonblocking mode"", ""Selector"")"
Just set a new InputStream for System.in or a new OutputStream for System.out or System.err and all further data will be read written to the new stream,"(""InputStream"", ""InputStream is applied to System.in as a new source"", ""System.in""); (""OutputStream"", ""OutputStream is applied to System.out as a new destination"", ""System.out""); (""OutputStream"", ""OutputStream is applied to System.err as a new destination"", ""System.err"")"
Creating a pipe using Java IO is done via the PipedOutputStream and PipedInputStream classes,NULL
The biggest difference between java.sql.Date and java.sql.Timestamp is that the java.sql.Date only keeps the date not the time of the date it represents,NULL
Since the parameters of the Finder.find() and MyClass.doFind() methods match it is possible to create a lambda expression that implements Finder.find() and references the MyClass.doFind() method,NULL
Here is an example of obtaining the Comparator used by a SortedMap via its comparator() method,"(""Comparator"", ""The comparator() method is used to obtain the Comparator class used by a SortedMap."", ""comparator()""); (""SortedMap"", ""The comparator() method is a part of the SortedMap structure to retrieve the Comparator."", ""comparator()"")"
"The getAndDecrement() method does the same as the decrementAndGet() method, except the getAndDecrement() method returns the value of the element before it is decremented.","(""GetAndDecrement"", ""Both methods perform similar operations, with GetAndDecrement returning the value before it is decremented."", ""DecrementAndGet"")"
The Matcher lookingAt() method works like the matches() method with one major difference,NULL
In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not but the BufferedInputStream supports them,"(""BufferedInputStream"", ""BufferedInputStream supports markSupported method"", ""markSupported""); (""BufferedInputStream"", ""BufferedInputStream supports mark method"", ""mark""); (""BufferedInputStream"", ""BufferedInputStream supports reset method"", ""reset""); (""BufferedInputStream"", ""BufferedInputStream supports markSupported method"", ""markSupported""); (""BufferedInputStream"", ""BufferedInputStream supports mark method"", ""mark""); (""BufferedInputStream"", ""BufferedInputStream supports reset method"", ""reset"")"
Lock.lock() result is that any thread calling either lock() or unlock() will become blocked indefinately,"(""lock()"", ""The method lock() likely belongs to or interacts with the class Lock, as indicated by the context suggesting a locking mechanism."", ""Lock""); (""unlock()"", ""The method unlock() likely belongs to or interacts with the class Lock, as it is usually paired with lock() in locking mechanisms."", ""Lock"")"
The getAndDecrement() method does the same as the decrementAndGet() method except the getAndDecrement() method returns the value of the element before it is decremented,"(""getAndDecrement"", ""getAndDecrement returns the value of the element before it is decremented, unlike decrementAndGet"", ""decrementAndGet""); (""getAndDecrement"", ""getAndDecrement returns the value of the element before it is decremented, unlike decrementAndGet"", ""decrementAndGet"")"
The Collection interface has two methods to check if a Collection contains one or more certain elements. These are the contains() and containsAll() methods.,"(""Collection"", ""The method 'contains' is part of the Collection class to check for specific elements."", ""contains""); (""Collection"", ""The method 'containsAll' belongs to the Collection class for checking multiple elements."", ""containsAll"")"
"The newLine() method which can write a new-line character to the underlying Writer. In addition, you may need to call flush() if you need to be absolutely sure that the characters written until now is flushed out of the buffer and onto the network or disk.","(""NewLine"", ""Both NewLine and Flush are methods involved in managing the output process by writing and ensuring characters are delivered accurately."", ""Flush"")"
To calculate a MAC value you call the Mac update() or doFinal() method,"(""Mac"", ""The update method is a function of the Mac class."", ""update""); (""Mac"", ""The doFinal method is a function of the Mac class."", ""doFinal""); (""Mac"", ""The update method is a function of the Mac class."", ""update""); (""Mac"", ""The doFinal method is a function of the Mac class."", ""doFinal"")"
The java.util.concurrent package has the following implementations of the BlockingDeque interface,"(""Java.util.concurrent"", ""PACKAGE"")"
Notice how the calculate() method both locks the Calculator instance Lock before performing any calculations and also call the add() and subtract() methods which also locks the lock,"(""calculate"", ""The calculate() method is associated with the Calculator class."", ""Calculator""); (""add"", ""The add() method is called within the calculate() method."", ""calculate""); (""subtract"", ""The subtract() method is called within the calculate() method."", ""calculate"")"
After calling read() the example loops until the isDone() method of the returned Future returns true,"(""read()"", ""The method read() returns an object of the class Future"", ""Future""); (""Future"", ""The method isDone() is called on an object of the class Future"", ""isDone()"")"
Deque.pollFirst() is different than removeFirst() which throws an exception if the Deque is empty,NULL
Adding and getting elements to a generic Map is done using the put() and get() methods,NULL
Java IO contains many subclasses of the InputStream OutputStream Reader and Writer classes,"(""Java IO"", ""InputStream is a subclass within the Java IO package."", ""InputStream""); (""Java IO"", ""OutputStream is a subclass within the Java IO package."", ""OutputStream""); (""Java IO"", ""Reader is a subclass within the Java IO package."", ""Reader""); (""Java IO"", ""Writer is a subclass within the Java IO package."", ""Writer"")"
Even if you can get get() and put() to work I would recommend that you do not use these methods,"(""Get"", ""Both methods are discussed together, implying they are related in use or purpose."", ""Put"")"
Lock.unlock() will remain blocked until the thread waiting in lock() leaves the synchronized(this) block,"(""Lock"", ""unlock() is a method of the Lock class."", ""unlock""); (""Lock"", ""lock() is a method of the Lock class."", ""lock"")"
The Path interface is located in the java.nio.file package so the fully qualified name of the Java Path interface is java.nio.file.Path,"(""Path"", ""The Path class is part of the java.nio.file package."", ""java.nio.file"")"
Here are two examples of adding elements to a Java Queue via its add() and offer() methods,"(""Queue"", ""The add method is used to insert elements into a Queue"", ""add""); (""Queue"", ""The offer method is also used to insert elements into a Queue, similar to add"", ""offer"")"
The methods Class.getMethod(String name Class[] parameterTypes) and Class.getMethods() methods only return public methods so they wont work,NULL
"BlockingQueue.offer(E e, long timeout, TimeUnit unit) is different from the add() method which will throw an exception is adding an element to the end of the Deque fails","(""BlockingQueue"", ""The 'offer' method is associated with the 'BlockingQueue' class as it is defined as a part of it."", ""offer""); (""BlockingQueue"", ""The 'add' method is associated with the 'BlockingQueue' class as it is a method used within its context."", ""add""); (""BlockingQueue"", ""'Deque' is related to 'BlockingQueue' as the context discusses behavior within a queue-like structure."", ""Deque""); (""offer"", ""The 'offer' method is compared directly to the 'add' method, indicating a clear relation in terms of functionality."", ""add"")"
The ByteArrayInputStream class is a subclass of the InputStream class so you can use a ByteArrayInputStream as an InputStream,NULL
If you need to set a date on a java.sql.PreparedStatement or get a date from a java.sql.ResultSet you will interact with java.sql.Date,NULL
The java.nio.file.Files class works with java.nio.file.Path instances so you need to understand the Path class before you can work with the Files class,"(""java.nio.file"", ""The Files class is part of the java.nio.file package."", ""Files""); (""java.nio.file"", ""The Path class is part of the java.nio.file package."", ""Path""); (""Files"", ""The Files class works with Path instances and requires an understanding of the Path class to work with it."", ""Path""); (""java.nio.file"", ""The Files class is part of the java.nio.file package."", ""Files""); (""java.nio.file"", ""The Path class is part of the java.nio.file package."", ""Path""); (""Files"", ""The Files class works with Path instances and requires an understanding of the Path class to work with it."", ""Path"")"
Both PipedInputStream and PipedOutputStream has a connect() method that can connect one to the other,NULL
java.awt.List is the last line of this example that calls the List stream() method to obtain the Stream representing the elements in the List,"(""List"", ""The List class calls the stream() method."", ""stream()""); (""stream()"", ""The stream() method returns a Stream representing the elements."", ""Stream""); (""List"", ""The List class is part of the java.awt package."", ""java.awt"")"
Queue.poll() is different than remove() which throws an exception if the Deque is empty,"(""Queue"", ""poll() is a method that belongs to the Queue class"", ""poll()""); (""Queue"", ""remove() is another method that is possibly associated with the Queue class"", ""remove()""); (""Deque"", ""The remove() method is related to the Deque class because it throws an exception if the Deque is empty"", ""remove()"")"
java.util.Collection represents an ordered sequence of objects just like a Java List but its intended use is slightly different,"(""Collection"", ""Collection and List are related because both represent ordered sequences of objects, albeit with different intended uses."", ""List"")"
Another difference between call() and run() is that call() can throw an exception whereas run() cannot (except for unchecked exceptions subclasses of RuntimeException),"(""Call"", ""Call and Run are related as they are both methods being compared in terms of functionality"", ""Run""); (""Call"", ""Call can throw an Exception, indicating a functional relationship"", ""Exception""); (""Run"", ""Run cannot throw an exception except for unchecked ones which are subclasses of RuntimeException, indicating a relationship"", ""Runtimeexception"")"
As you can see the key Iterator returns every key stored in a Java Map one by one (one for each call to next()),NULL
The awaitTermination() method is typically called after calling shutdown() or shutdownNow(),NULL
Collection.remove(Object o) is different from poll() which returns null if the Deque is empty,"(""Collection.remove(Object o)"", ""Both are methods with different return conditions when interacting with a collection."", ""poll()""); (""poll()"", ""The method poll() is commonly used with the Deque class for processing element removal."", ""Deque""); (""Collection.remove(Object o)"", ""Both are methods with different return conditions when interacting with a collection."", ""poll()""); (""poll()"", ""The method poll() is commonly used with the Deque class for processing element removal."", ""Deque"")"
The Java GZIPInputStream and GZIPOutputStream classes are used to ZIP compress a single file,"(""GZIPInputStream"", ""Both classes are related as they are used for ZIP compression handling in Java."", ""GZIPOutputStream"")"
The java.util.concurrent package contains the following implementations of the ConcurrentMap interface,"(""Java.util.concurrent"", ""The ConcurrentMap class is implemented within the java.util.concurrent package."", ""ConcurrentMap"")"
Receiving data via a DatagramSocket is done by first creating a DatagramPacket and then receiving data into it via the DatagramSocket receive() method,NULL
"Notice how the while loop continues until a -1 value is read from the ByteArrayInputStream read() method. After that, the while loop exits, and the ByteArrayInputStream close() method is called.","(""ByteArrayInputStream"", ""The read method is associated with the ByteArrayInputStream class, likely invoked to read data from it."", ""read""); (""ByteArrayInputStream"", ""The close method is associated with the ByteArrayInputStream class, likely invoked to close the stream after operations are complete."", ""close"")"
Notice how we can call the addAndReturn() method using both String and Integer and their corresponding collections,NULL
"As you can see, the DecimalFormat is created with a formatting pattern. You can change this pattern later using the applyPattern() or applyLocalizedPattern() method.",NULL
For that you need to use the find() start() and end() methods,NULL
The Java Stack class actually implements the Java List interface but you rarely use a Stack as a List except perhaps if you need to inspect all elements currently stored on the stack,"(""Java Stack"", ""The Java Stack class implements the Java List interface."", ""Java List""); (""Java Stack"", ""The Java Stack class implements the Java List interface."", ""Java List"")"
In Java 6 to 13 there is only one implementation of the NavigableSet interface in the java.util package The java.util.TreeSet class,NULL
In many ways the java.nio.file.Path interface is similar to the java.io.File class but there are some minor differences,"(""Java.nio.file.Path"", ""The java.nio.file.Path interface is compared to the java.io.File class indicating a similarity in purpose or functionality"", ""Java.io.File"")"
java.io.CharArrayReader is also possible to write data to an ByteArrayOutputStream or CharArrayWriter,NULL
"The first method, addAndGet() adds a number to the AtomicInteger and returns its value after the addition. The second method, getAndAdd() also adds a number to the AtomicInteger but returns the value the AtomicInteger had before the value was added.",NULL
Here is an example of obtaining the Comparator used by a SortedSet via the comparator() method,"(""comparator"", ""The comparator method is used to obtain the Comparator class."", ""Comparator""); (""comparator"", ""The comparator method is used to obtain the Comparator for a SortedSet."", ""SortedSet"")"
You will call take() instead of notify() and release() instead of wait(),"(""Take"", ""The method take() is suggested as an alternative to calling notify()."", ""Notify""); (""Release"", ""The method release() is suggested as an alternative to calling wait()."", ""Wait"")"
The problem with calling wait() and notify() on the empty string or any other constant string is that the JVMCompiler internally translates constant strings into the same object,"(""Wait"", ""Both are methods that can be called on objects for thread synchronization"", ""Notify""); (""Empty String"", ""Empty String is transformed by the JVMCompiler, linking the two"", ""JVMCompiler"")"
"if the Deque is full, the offerFirst() method returns false. This is different from the addFirst() method which will throw an exception is adding an element to the beginning of the Deque fails.","(""Deque"", ""The offerFirst method is associated with the Deque class, as it operates on an instance of Deque."", ""offerFirst""); (""Deque"", ""The addFirst method is associated with the Deque class, as it operates on an instance of Deque."", ""addFirst""); (""offerFirst"", ""Both offerFirst and addFirst are methods of the Deque class, and they have similar functionalities of adding an element to the beginning."", ""addFirst"")"
You read characters from a Java PushbackReader just like you do from a Java Reader because PushbackReader is a Java Reader subclass,"(""PushbackReader"", ""PushbackReader is a subclass of Reader, making them related as part of an inheritance hierarchy"", ""Reader""); (""PushbackReader"", ""PushbackReader is used in the context of Java, indicating a belonging to the Java package"", ""Java""); (""Reader"", ""Reader is used in the context of Java, indicating a belonging to the Java package"", ""Java"")"
Since the Map does not contain any object stored by the key E the given default value will be returned which is the String default value passed as the last parameter to the getOrDefault() method,NULL
When you call select() or selectNow() on the Selector it gives you only the SelectableChannel instances that actually has data to read,"(""SELECT"", ""Select is a method of the Selector class used to retrieve channels with available data."", ""SELECTOR""); (""SELECTNOW"", ""SelectNow is a method of the Selector class providing a non-blocking way to retrieve channels with available data."", ""SELECTOR""); (""SELECTOR"", ""Selector works with SelectableChannel instances to manage channel data readiness."", ""SELECTABLECHANNEL"")"
"For the SortedSet to be able to determine the natural order of the elements, the elements must implement the java.lang.Comparable interface.","(""SortedSet"", ""SortedSet requires elements to implement java.lang.Comparable to determine the natural order of elements"", ""java.lang.Comparable"")"
For the SortedSet to be able to determine the natural order of the elements the elements must implement the java.lang.Comparable interface,"(""SortedSet"", ""SortedSet depends on elements implementing the Comparable interface to determine order"", ""Comparable""); (""SortedSet"", ""SortedSet depends on elements implementing the Comparable interface to determine order"", ""Comparable"")"
java.util.concurrent.RecursiveTask example is similar to the RecursiveAction example except it returns a result,"(""RecursiveTask"", ""RecursiveTask and RecursiveAction are both examples within the java.util.concurrent package and have similar functionalities, with the difference being that RecursiveTask returns a result."", ""RecursiveAction"")"
Notice the two synchronized blocks inside the set() and get() method. Notice how the blocks are placed last and first in the two methods.,"(""Set"", ""Both methods contain synchronized blocks and are mentioned together in the context of block placement."", ""Get"")"
This Keytool delete command will remove the KeyStore entry with the alias testkey from the KeyStore stored in the file keystore.jks,"(""Keytool"", ""Keytool utilizes the delete method"", ""delete""); (""delete"", ""delete acts upon the KeyStore"", ""KeyStore""); (""KeyStore"", ""KeyStore is stored or referenced in keystore.jks"", ""keystore.jks"")"
Deque.addFirst(E e) is different from the offerFirst() method which will return false if an element cannot be inserted in the beginning of the Deque,NULL
To access a private method you will need to call the Class.getDeclaredMethod(String name Class[] parameterTypes) or Class.getDeclaredMethods() method,"(""Class"", ""The method getDeclaredMethod is accessed via the Class entity, suggesting a functional relationship."", ""getDeclaredMethod""); (""Class"", ""The method getDeclaredMethods is accessed via the Class entity, suggesting a functional relationship."", ""getDeclaredMethods"")"
There are several overridden versions of both update() and doFinal() which takes different parameters,"(""Update"", ""Both update() and doFinal() are mentioned as methods with overridden versions."", ""DoFinal"")"
If you look at the example in the previous section imagine what happens if an exception is thrown between the call to lock.lock() and lock.unlock(),NULL
"The replace() method will only insert the new value if there is already an existing value mapped to the key. If no existing value is mapped to the given key, no value is inserted. This is different from how put() works, which always insert the value no matter what.","(""Replace"", ""Both Replace and Put are methods that manipulate values mapped to given keys, but they have different behaviors regarding insertion."", ""Put"")"
The logrb() methods work like the log() methods too except they can obtain the log messages from a resource bundle,"(""Logrb"", ""Logrb methods work similarly to log methods, indicating a functional or behavioral relationship between them."", ""Log""); (""Logrb"", ""Logrb methods can obtain log messages from a resource bundle, indicating a dependency or interaction relationship."", ""Resource Bundle""); (""Logrb"", ""Logrb methods work similarly to log methods, indicating a functional or behavioral relationship between them."", ""Log""); (""Logrb"", ""Logrb methods can obtain log messages from a resource bundle, indicating a dependency or interaction relationship."", ""Resource Bundle"")"
a stop() or pause() method too) then you can no longer create your Runnable implementation with a Java lambda expression,"(""Stop"", ""The Stop method can be used within the Runnable class to manage thread execution states."", ""Runnable""); (""Pause"", ""The Pause method can be utilized within the Runnable class to temporarily halt thread execution."", ""Runnable""); (""Runnable"", ""The Runnable is a class that is part of the Java package used for threading."", ""Java""); (""Stop"", ""The Stop method can be used within the Runnable class to manage thread execution states."", ""Runnable""); (""Pause"", ""The Pause method can be utilized within the Runnable class to temporarily halt thread execution."", ""Runnable""); (""Runnable"", ""The Runnable is a class that is part of the Java package used for threading."", ""Java"")"
java.security.KeyStore example loads the KeyStore file located in the keystore.ks file,"(""KeyStore"", ""The KeyStore class is part of the java.security package"", ""KeyStore"")"
The queueObject.doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout so another thread can actually call unlock() when no thread is executing inside the synchronized(this) block in lock() method,NULL
The read() and write() calls on the streams are blocking meaning if you try to use the same thread to both read and write this may result in the thread deadlocking itself,"(""Read"", ""Read and Write are methods that are mentioned together in the context of managing streams, indicating they are likely related as operations on the same resource."", ""Write"")"
"mutiple blocks from a large file, you call the update() once for each block of data, and finish with a call to doFinal() with the last data loce","(""Update"", ""Both methods participate in a sequential process to handle multiple data blocks, with Update handling each block and DoFinal handling the final block."", ""DoFinal"")"
That means that when a thread invokes a read() or write() that thread is blocked until there is some data to read or the data is fully written,NULL
You can convert a Java List to a Java Array using the List toArray() method,"(""List"", ""The List class utilizes the toArray() method to convert its elements to an array."", ""toArray()"")"
When the thread is done with the code in the critical section (the code between lock() and unlock()) the thread calls unlock(),"(""Lock()"", ""Lock() and Unlock() are related as they manage access control in a critical section. Lock() is used to secure the section while Unlock() is called to release it."", ""Unlock()"")"
The LinkedList class is a pretty standard Deque and Queue implementation,NULL
The System class also has a getProperty() and setProperty() method which are shortcuts to the Properties getProperty() and setProperty() methods of the System Properties instance,"(""System"", ""getProperty() is a method of the System class"", ""getProperty()""); (""System"", ""setProperty() is a method of the System class"", ""setProperty()""); (""Properties"", ""getProperty() is a method of the Properties class"", ""getProperty()""); (""Properties"", ""setProperty() is a method of the Properties class"", ""setProperty()""); (""System"", ""System Properties is an instance related to the System class"", ""System Properties"")"
The Handler in the Java Logging API use a java.util.logging.Formatter to format the LogRecord before writing it to an external system,NULL
The compare() method returns an int with the same meaning as the String.compareTo() method,"(""Compare"", ""The Compare method returns an integer with the same meaning as the String.compareTo method"", ""String.compareTo"")"
The method getBuffer() returns the StringBuffer used by the StringWriter to build the string from the written characters,"(""getBuffer"", ""The method getBuffer() returns the StringBuffer used in the process."", ""StringBuffer""); (""StringWriter"", ""StringWriter uses StringBuffer to build the string."", ""StringBuffer"")"
java.io.Writer is faster to write an array of characters to a Java BufferedWriter than writing one character at a time,"(""Writer"", ""Writer class can utilize BufferedWriter for efficient writing operations."", ""BufferedWriter""); (""java.io"", ""Writer class is part of the java.io package."", ""Writer""); (""java.io"", ""BufferedWriter class is part of the java.io package."", ""BufferedWriter""); (""Writer"", ""The Writer class uses the write method to output characters."", ""write"")"
java.util.Stack Java example pushes a Java String with the text 1 onto the Stack,"(""Stack"", ""The Stack class is part of the java.util package."", ""java.util""); (""pushes"", ""The 'pushes' method is an operation performed on the Stack class."", ""Stack""); (""String"", ""The 'pushes' method pushes a String onto the stack."", ""pushes"")"
Deque.peekFirst() is similar to how peek() works but the method name peekFirst() is a bit more saying about which end of the Deque you peek at,NULL
To sort a collection of strings according to the rules of a certain Locale you use a java.text.Collator instance created for that specific Locale,NULL
