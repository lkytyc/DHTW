The Collections reverse() method can reverse the elements in a Java List.,"(""Collections"", ""The reverse method belongs to the Collections class."", ""reverse""); (""reverse"", ""The reverse method operates on elements in a Java List."", ""List"")"
Here is an example of finding the minimum element in a Java List using Collections min() method:,"(""Collections"", ""The min() method is part of the Collections package, as it is used in conjunction with Collections."", ""min()""); (""List"", ""The min() method is applied to a List to find the minimum element, indicating that min() operates on List objects."", ""min()"")"
"Notice too, that the compareTo() method should throw a NullPointerException if the parameter object is null.","(""COMPARETO"", ""The COMPARETO method throws a NULLPOINTEREXCEPTION when the parameter object is null, indicating a direct relationship between the two entities."", ""NULLPOINTEREXCEPTION"")"
The LinkedList class is a pretty standard Deque and Queue implementation.,"(""LinkedList"", ""The LinkedList class implements the Deque interface."", ""Deque""); (""LinkedList"", ""The LinkedList class implements the Queue interface."", ""Queue"")"
You add elements to the beginning end of a Deque using the add() method.,
"If the element cannot be inserted into the Deque, the add() method will throw an exception.",
"If the element cannot be inserted into the Deque, the addLast() method will throw an exception.",
To peek at the last element of a Java Deque you can use the getLast() method.,"(""getLast"", ""The getLast method is used with the Deque class to access its last element."", ""Deque"")"
The remove() method removes the first element of a Java Deque.,"(""Remove"", ""The remove method is applied to the Deque class to remove its first element."", ""Deque""); (""Remove"", ""The remove method is part of the collection of methods available in Java."", ""Java"")"
"The pollFirst() method removes an element from the beginning of the Deque, just like poll().","(""PollFirst"", ""PollFirst is a method that operates on the Deque class to remove elements from the beginning."", ""Deque""); (""PollFirst"", ""PollFirst is similar to the Poll method in functionality."", ""Poll"")"
Here is an example of removing the last element from a Java Deque using the pollLast() method:,"(""Deque"", ""The method 'pollLast' is used in the context of a 'Deque'."", ""pollLast"")"
The Java Deque size() method returns the number of elements stored in the Java Deque at the time you invoke the method.,
"Because the Iterator has its generic type set to String, the Java compiler already knows that next() will return a String.",
"As you can see, a proper implementation of .equals() is essential for your own classes to work well with the Java Collection classes.",
"So, as you can see, a combination of the hashCode() and equals() methods are used when storing and when looking up objects in a hashtable.","(""HashCode"", ""The HashCode and Equals methods are often used together to ensure objects are correctly stored and retrieved in data structures like hashtables."", ""Equals""); (""HashCode"", ""The HashCode method is used in conjunction with hashtables to optimize object storage and retrieval."", ""Hashtable""); (""Equals"", ""The Equals method is crucial in hashtables for comparing object equality during lookup operations."", ""Hashtable"")"
"Then it uses a for-each loop to iterate the elements of the List, and print out the toString() value of each element.",
Here is an example of iterating the elements of an Iterable via its forEach() method:,"(""Iterable"", ""The forEach method is used to iterate over the elements of the Iterable class."", ""forEach"")"
"The reason the for-each loop is slower is, that each iteration will call the List iterator() method, which will create a new Iterator object.","(""List"", ""The 'iterator' method is called by instances of the 'List' class."", ""iterator"")"
"In other words, if the Iterator has not yet iterated over all of the elements in the collection the Iterator was obtained from - the hasNext() method will return true.",
The first three add() calls add a String instance to the end of the list.,
"The addAll() method takes a Collection as parameter, so you can pass either a List or Java Set as parameter.","(""AddAll"", ""The AddAll method takes a Collection as a parameter."", ""Collection""); (""Collection"", ""List is a type of Collection."", ""List""); (""Collection"", ""Java Set is a type of Collection."", ""Java Set"")"
"Notice that the get() method returns a Java Object, so we have to cast it to a String (because we know the value is a String).","(""Get"", ""The get() method is part of a Java class involving object retrieval and handling."", ""Java""); (""Get"", ""The get() method is used to retrieve a Java Object that is explicitly cast to a String."", ""String"")"
"This example creates a Map and stores three values in it using the keys A, B and C. Then the example calls the Map getOrDefault() method, passing the String E as key, along with a default value - the String default value.",
Since the Map does not contain any object stored by the key E the given default value will be returned - which is the String default value passed as the last parameter to the getOrDefault() method.,"(""GetOrDefault"", ""The getOrDefault method returns a default value of type String."", ""String""); (""GetOrDefault"", ""The getOrDefault method is used with the Map class to retrieve values."", ""Map""); (""GetOrDefault"", ""The getOrDefault method returns a default value of type String."", ""String""); (""GetOrDefault"", ""The getOrDefault method is used with the Map class to retrieve values."", ""Map"")"
"As you can see, the key Iterator returns every key stored in a Java Map, one by one (one for each call to next()).","(""Iterator"", ""The Iterator class is used to iterate through entries in a Map class."", ""Map""); (""Iterator"", ""The next method is called on an Iterator instance to return the next key in the sequence."", ""next""); (""Iterator"", ""The Iterator class is used to iterate through entries in a Map class."", ""Map""); (""Iterator"", ""The next method is called on an Iterator instance to return the next key in the sequence."", ""next"")"
The number of entries in a Java Map is also referred to as the Map size - hence the method name size() .,"(""Map"", ""The method 'size()' is related to the 'Map' class because it is used to determine the number of entries in a Map."", ""size"")"
The isEmpty() method will return false if the Map instance contains 1 or more entries.,
Here is an example of creating an instance of the Java TreeMap class which implements the NavigableMap interface:,"(""TreeMap"", ""TreeMap implements the NavigableMap interface"", ""NavigableMap"")"
"The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys ""c"", ""d"" and ""e"", as these keys are considered equal to or larger than the parameter value ""c"" passed to the tailMap() method.","(""TailMap"", ""TailMap is assigned the result of invoking the TailMap() method"", ""TailMap()""); (""SortedMap"", ""TailMap stores key-value pairs from a NavigableMap into a SortedMap"", ""NavigableMap"")"
The lowerEntry() method in the NavigableMap interface returns the key + value pair for the highest key which is lower than the parameter value passed to the lowerEntry() method.,"(""LowerEntry"", ""The lowerEntry() method is a method within the NavigableMap interface, which suggests a clear association between the two."", ""NavigableMap"")"
"The pollFirstEntry() method returns and removes the ""first"" entry (key + value) in the NavigableMap or null if the map is empty.","(""PollFirstEntry"", ""The PollFirstEntry method operates on the NavigableMap to remove and return its first entry if it exists."", ""NavigableMap"")"
"The descendingIterator() method allows you to iterate the elements of the NavigableSet (which is also a SortedSet) in reverse order, without changing the order of the elements internally.",
"To get properties from a Java Properties object you use the getProperty() method, passing the key of the property to get as parameter.",
"Using the InputStream you can load the file into a Java Properties instance, using either the load() or loadFromXML() methods explained earlier in this Java Properties tutorial.","(""load()"", ""The load() method is a function that can be used with the Java Properties class to load properties."", ""Java Properties""); (""loadFromXML()"", ""The loadFromXML() method allows for loading properties from an XML file, which is a functionality of the Java Properties class."", ""Java Properties""); (""InputStream"", ""The InputStream is used as an input source for the load() method to load data into a Java Properties object."", ""load()""); (""InputStream"", ""The InputStream is also used as input for the loadFromXML() method to load XML data into a Java Properties object."", ""loadFromXML()"")"
Here are two examples of taking an element from a Java Queue using its poll() and remove() methods:,
You can check if a Java Queue contains a certain element via its contains() method.,
The Java Set interface as a method called removeAll() which removes all elements in the Set which are also present in another Collection.,
You can check the size of a Java Set using the size() method.,
"You iterate the keys of a SortedMap by calling its keySet() method, like this:","(""SortedMap"", ""The keySet() method is used to iterate over the keys of a SortedMap."", ""keySet()"")"
The SortedMap interface has a method named headMap() which returns a new Map which contains the first elements of the SortedMap according to the sort order used.,"(""SortedMap"", ""The headMap method is part of the SortedMap interface."", ""headMap""); (""headMap"", ""The headMap method returns a new Map."", ""Map"")"
Here is an example of obtaining a submap from a Java SortedMap via its subMap() method:,
The Java Collections API only has one implementation of the Java SortedSet interface - the java.util.TreeSet class.,"(""Java Collections API"", ""The Java SortedSet Interface is a component of the Java Collections API."", ""Java SortedSet Interface""); (""Java SortedSet Interface"", ""The java.util.TreeSet class is an implementation of the Java SortedSet Interface."", ""java.util.TreeSet"")"
"Additionally, the Vector class uses several older (no longer recommended) parts of Java, like the Enumeration which is superseded by the Iterator interface.",
You push elements onto a Java Stack using its push() method.,"(""Java Stack"", ""The method 'push()' is used to add elements to the 'Java Stack' class."", ""push()"")"
Here is an example of obtaining the size of a Java Stack via its size() method:,
The lockWrite() method of a ReadWriteLock class shown below is an example of a test-and-set method.,"(""lockWrite"", ""The lockWrite method is a member or function of the ReadWriteLock class, indicating a typical class-method relationship."", ""ReadWriteLock"")"
The BoundedSemaphore class shown below has two test-and-set methods: take() and release().,"(""BoundedSemaphore"", ""The take() is a method of the BoundedSemaphore class."", ""take""); (""BoundedSemaphore"", ""The release() is a method of the BoundedSemaphore class."", ""release"")"
Here is an example showing how to implement the lock() method shown earlier using the AtomicBoolean class:,"(""lock()"", ""The method lock() is implemented using the AtomicBoolean class."", ""AtomicBoolean""); (""lock()"", ""The method lock() is implemented using the AtomicBoolean class."", ""AtomicBoolean"")"
"a stop() or pause() method too), then you can no longer create your Runnable implementation with a Java lambda expression.","(""Stop"", ""The Stop method is closely related to Runnable, implying it is used to control or modify the behavior of a Runnable object."", ""Runnable""); (""Pause"", ""The Pause method, like Stop, is used within the context of a Runnable object, indicating a functional relationship."", ""Runnable""); (""Runnable"", ""Runnable is a key component or interface in the Java programming language."", ""Java"")"
"If a thread (1) calls the parent.addChild(child) method at the same time as another thread (2) calls the child.setParent(parent) method, on the same parent and child instances, a deadlock can occur.",
"Here are the two classes used in the example above, Counter and CounterThread.",
"The easiest way to create a subclass of ThreadLocal is to simply create an anonymous subclass, right where you create the ThreadLocal variable.","(""ThreadLocal"", ""Creating a subclass of ThreadLocal implies an inheritance relationship where ThreadLocal serves as the parent class."", ""Subclass""); (""ThreadLocal"", ""Creating a subclass of ThreadLocal implies an inheritance relationship where ThreadLocal serves as the parent class."", ""Subclass"")"
"Here is an example of creating a ThreadLocal using its withInitial() static factory method, passing a simple Supplier implementation as parameter:","(""ThreadLocal"", ""The `withInitial()` is a static factory method of the `ThreadLocal` class, which is used to create a `ThreadLocal` instance."", ""withInitial()""); (""withInitial()"", ""The `withInitial()` method takes a `Supplier` implementation as a parameter, indicating a dependency or interaction between the method and the class."", ""Supplier"")"
Notice how the format() method calls the getThreadLocalSimpleDateFormat() method to obtain a Java SimpleDatFormat instance.,
"The Counter class could have been written like this instead, using a Lock instead of a synchronized block:",
"While isLocked is true, the thread calling lock() is parked waiting in the wait() call.",
"When the thread is done with the code in the critical section (the code between lock() and unlock()), the thread calls unlock().",
"Otherwise, a single call to unlock() will unlock the lock, even if the lock has been locked multiple times.",
"That you would not call wait() and notify() on an internal monitor object, but rather on the This is probably true.","(""Wait"", ""Method""); (""Notify"", ""Method""); (""Wait"", ""Method""); (""Notify"", ""Method"")"
This is how such exclusive access could look using a synchronized block in Java: public class SynchronizedCounter { long count = 0; public void inc() { synchronized(this) { count++; } } public long count() { synchronized(this) { return this.count; } } } Notice how the inc() and count() methods both contain a synchronized block.,"(""SynchronizedCounter"", ""The inc method is defined within the SynchronizedCounter class."", ""inc""); (""SynchronizedCounter"", ""The count method is defined within the SynchronizedCounter class."", ""count""); (""inc"", ""Both inc and count methods use a synchronized block to manage exclusive access in the class."", ""count""); (""SynchronizedCounter"", ""The inc method is defined within the SynchronizedCounter class."", ""inc""); (""SynchronizedCounter"", ""The count method is defined within the SynchronizedCounter class."", ""count""); (""inc"", ""Both inc and count methods use a synchronized block to manage exclusive access in the class."", ""count"")"
"import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicStampedReference; public class NonblockingTemplate { public static class IntendedModification { public AtomicBoolean completed = new AtomicBoolean(false); } private AtomicStampedReference<IntendedModification> ongoingMod = new AtomicStampedReference<IntendedModification>(null, 0); //declare the state of the data structure here.","(""NonblockingTemplate"", ""IntendedModification is a nested static class within NonblockingTemplate."", ""IntendedModification""); (""IntendedModification"", ""IntendedModification uses AtomicBoolean for the field named completed."", ""AtomicBoolean""); (""NonblockingTemplate"", ""NonblockingTemplate contains a field ongoingMod which is of type AtomicStampedReference."", ""AtomicStampedReference""); (""AtomicStampedReference"", ""AtomicStampedReference is parameterized with IntendedModification."", ""IntendedModification""); (""NonblockingTemplate"", ""IntendedModification is a nested static class within NonblockingTemplate."", ""IntendedModification""); (""IntendedModification"", ""IntendedModification uses AtomicBoolean for the field named completed."", ""AtomicBoolean""); (""NonblockingTemplate"", ""NonblockingTemplate contains a field ongoingMod which is of type AtomicStampedReference."", ""AtomicStampedReference""); (""AtomicStampedReference"", ""AtomicStampedReference is parameterized with IntendedModification."", ""IntendedModification"")"
Here is how the lockRead() and unlockRead() methods looks after that change:,
Here is how the lockWrite() and unlockWrite() methods look after that change:,"(""LockWrite"", ""Both methods are likely related as they are part of a locking mechanism, typically used in concurrent programming to manage write operations."", ""UnlockWrite"")"
"You can read more about it in the java.util.concurrent.Semaphore text, in my java.util.concurrent tutorial.",
The take() method sends a signal which is stored internally in the Semaphore.,"(""Take"", ""The take method interacts with an instance of the Semaphore class by sending a signal."", ""Semaphore"")"
"That way the signal is not missed, even if doNotify() is called before doWait().","(""DONOTIFY"", ""DONOTIFY is related to DOWAIT as it is part of a sequence where signals are managed; doNotify() is called before doWait()"", ""DOWAIT"")"
"If you look at the Synchronizer class above and look into this Lock implementation you will notice that threads are now blocked trying to access the lock() method, if more than one thread calls lock() simultanously.","(""Synchronizer"", ""The Lock class is part of the implementation related to the Synchronizer class."", ""Lock""); (""Lock"", ""The lock method is a functionality within the Lock class."", ""lock""); (""Synchronizer"", ""The Lock class is part of the implementation related to the Synchronizer class."", ""Lock""); (""Lock"", ""The lock method is a functionality within the Lock class."", ""lock"")"
"The thread calling unlock() will take the top QueueObject in the queue and call doNotify() on it, to awaken the thread waiting on that object.",
"The queueObject.doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout, so another thread can actually call unlock() when no thread is executing inside the synchronized(this) block in lock() method.",
"Below here is the PoolThreadRunnable class which implements the Runnable interface, so it can be executed by a Java thread:",
"Notice how the add() method returns a new ImmutableValue instance with the result of the add operation, rather than adding the value to itself.","(""Add"", ""The Add method returns a new instance of the ImmutableValue class as a result of the add operation."", ""ImmutableValue"")"
"The class java.lang.Object defines three methods, wait(), notify(), and notifyAll(), to facilitate this.","(""Java.lang.Object"", ""The class java.lang.Object defines the method wait()."", ""Wait()""); (""Java.lang.Object"", ""The class java.lang.Object defines the method notify()."", ""Notify()""); (""Java.lang.Object"", ""The class java.lang.Object defines the method notifyAll()."", ""NotifyAll()"")"
"In other words, the calling thread must call wait() or notify() from inside a synchronized block.",
The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called.,"(""Notify"", ""Both methods involve notifying threads and their functionality is linked in the context of thread synchronization"", ""NotifyAll"")"
"If the doNotify() method had called notifyAll() instead of notify(), all waiting threads had been awakened and checked for signals in turn.","(""doNotify"", ""The doNotify method can call the notifyAll method to wake up all waiting threads."", ""notifyAll""); (""doNotify"", ""The doNotify method can call the notify method to wake up a single waiting thread."", ""notify"")"
"The other of C and D would go back to waiting, because the thread discovering the signal clears it on the way out of doWait().","(""SIGNAL"", ""The doWait method is involved in clearing a signal during its execution."", ""DOWAIT"")"
"The method compareAndSet() allows you to compare the current value of the AtomicBoolean to an expected value, and if current value is equal to the expected value, a new value can be set on the AtomicBoolean.","(""CompareAndSet"", ""The method compareAndSet() operates on the AtomicBoolean class to compare and set its values based on a condition."", ""AtomicBoolean"")"
"The AtomicInteger class provides you with a int variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().",
You can get the value of an AtomicInteger instance via the get() method.,
Calling addAndGet() is also an atomic operation (like all operations on the AtomicIntegerArray).,
You should check out the JavaDoc for the AtomicIntegerArray class to learn more about those methods.,"(""AtomicIntegerArray"", ""Methods are functions that belong to the class AtomicIntegerArray."", ""methods"")"
"The AtomicLong class provides you with a long variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().",
You can set the value of an AtomicLong instance via the set() method.,
The Java AtomicLongArray class (java.util.concurrent.atomic.AtomicLongArray) represents an array of long .,"(""java.util.concurrent.atomic"", ""The AtomicLongArray class is contained within the java.util.concurrent.atomic package, indicating a package-class relationship."", ""AtomicLongArray"")"
You can get the value of a given element using the get() method on the AtomicLongArray.,"(""source_entity"", ""relationship_description"", ""target_entity""); (""xxx"", ""xxxxxxxxxxxxxxxxxxxxxxxxx"", ""xxx""); (""xxx"", ""xxxxxxxxxxxxxxxxxxxxxxxxx"", ""xxx""); (""Get"", ""The get method is used on the AtomicLongArray class"", ""AtomicLongArray"")"
You can set the value of a given element using the set() method on the AtomicLongArray.,"(""Set"", ""The set method belongs to or is used on an instance of the AtomicLongArray class."", ""AtomicLongArray"")"
"AtomicReference even has an advanced compareAndSet() method which lets you compare the reference to an expected value (reference) and if they are equal, set a new reference inside the AtomicReference object.",
Notice how it is no longer necessary to cast the referenced returned by get() because the compiler knows it will return a String reference.,"(""GET"", ""The method get() returns a reference to the class String, indicating a return type relationship."", ""STRING"")"
"The compareAndSet() method can compare the reference stored in the AtomicReference instance with an expected reference, and if they two references are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicReference instance.","(""CompareAndSet"", ""The compareAndSet() method operates on instances of the AtomicReference class to manage references."", ""AtomicReference"")"
If you have a typed AtomicStampedReference then getReference() returns a reference to the type you declared on the AtomicStampedReference variable when you created it.,"(""AtomicStampedReference"", ""The getReference() method is associated with the AtomicStampedReference class, providing access to the reference of the type declared."", ""getReference"")"
The AtomicStampedReference also contains a getStamp() method which can be used to obtain the internally stored stamp.,"(""AtomicStampedReference"", ""The getStamp method is part of the AtomicStampedReference class, indicating a class-method relationship."", ""getStamp"")"
"The compareAndSet() method can compare the reference stored in the AtomicStampedReference instance with an expected reference, and the stored stamp with an expected stamp, and if they two references and stamps are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicStampedReference instance.","(""CompareAndSet"", ""The compareAndSet method is a part of the functionality provided by the AtomicStampedReference class, as it operates on instances of this class to compare and set references."", ""AtomicStampedReference"")"
"The BlockingDeque interface in the java.util.concurrent class represents a deque which is thread safe to put into, and take instances from.",
"The ConcurrentMap has a few extra atomic methods in addition to the methods it inherits from its superinterface, java.util.Map.","(""ConcurrentMap"", ""ConcurrentMap inherits methods from java.util.Map, indicating a superclass relationship."", ""java.util.Map"")"
"The java.util.concurrent.ConcurrentNavigableMap class is a java.util.NavigableMap with support for concurrent access, and which has concurrent access enabled for its submaps.","(""ConcurrentNavigableMap"", ""ConcurrentNavigableMap is a type of NavigableMap with support for concurrent access"", ""NavigableMap""); (""ConcurrentNavigableMap"", ""ConcurrentNavigableMap is part of the java.util.concurrent package"", ""java.util.concurrent""); (""NavigableMap"", ""NavigableMap is part of the java.util package"", ""java.util"")"
"First, the BlockingQueueExample class which starts a Producer and a Consumer in separate threads.","(""BlockingQueueExample"", ""BlockingQueueExample class starts a Producer in a separate thread."", ""Producer""); (""BlockingQueueExample"", ""BlockingQueueExample class starts a Consumer in a separate thread."", ""Consumer"")"
The Java BlockingQueue add() method will add the element passed as parameter to this method if the BlockingQueue has space for it internally.,"(""BlockingQueue"", ""The add() method is related to the BlockingQueue class as it is a method that operates on or is used with instances of this class."", ""add()"")"
"If the BlockingQueue does not have space internally for this new element, the add() method throws an IllegalStateException.","(""add()"", ""The add() method throws an IllegalStateException if the BlockingQueue does not have space for a new element."", ""IllegalStateException""); (""BlockingQueue"", ""The BlockingQueue is related to the add() method as it operates on this class."", ""add()"")"
The remove() method will use the o.equals(element) to decide if the object o passed as parameter matches a given element in the BlockingQueue.,"(""Remove"", ""The remove() method is used to remove elements from the BlockingQueue class."", ""BlockingQueue""); (""Equals"", ""The equals() method is used within the remove() method to determine if the object matches an element."", ""Remove""); (""Equals"", ""The equals() method checks if the object o is equivalent to a given element."", ""Element""); (""Element"", ""The elements managed by BlockingQueue are being compared using the equals() method."", ""BlockingQueue"")"
"If the BlockingQueue does not contain any elements, the element() method will throw a NoSuchElementException.",
The result of that is that the call() method will return a String.,
"The Java ExecutorService interface, java.util.concurrent.ExecutorService, represents an asynchronous execution mechanism which is capable of executing tasks concurrently in the background.",
"The Java ExecutorService execute(Runnable) method takes a java.lang.Runnable object, and executes it asynchronously.","(""ExecutorService"", ""The execute(Runnable) method is a method of the ExecutorService class."", ""execute(Runnable)""); (""execute(Runnable)"", ""The execute(Runnable) method takes a Runnable object as a parameter."", ""Runnable""); (""Runnable"", ""The Runnable class is part of the java.lang package."", ""java.lang"")"
"The invokeAny() method takes a collection of Callable objects, or subinterfaces of Callable.","(""Invokeany"", ""The invokeAny() method is related to the Callable class because it takes a collection of Callable objects as input."", ""Callable"")"
The invokeAll() method invokes all of the Callable objects you pass to it in the collection passed as parameter.,"(""InvokeAll"", ""The InvokeAll method is used to invoke Callable objects as per the given description."", ""Callable"")"
The main difference between the Runnable run() method and the Callable call() method is that the call() method can return an Object from the method call.,
"The ExecutorService awaitTermination() method will block the thread calling it until either the ExecutorService has shutdown completely, or until a given time out occurs.","(""ExecutorService"", ""The awaitTermination method is a part of the ExecutorService, indicating it operates on or is associated with this class."", ""awaitTermination"")"
The awaitTermination() method is typically called after calling shutdown() or shutdownNow().,"(""AwaitTermination()"", ""awaitTermination() is typically called after calling shutdown()"", ""Shutdown()""); (""AwaitTermination()"", ""awaitTermination() is typically called after calling shutdownNow()"", ""ShutdownNow()"")"
In the following sections I will explain how to use the ReentrantLock class as a Lock.,
To unlock the Lock instance you must call its unlock() method.,"(""Lock"", ""The unlock method is associated with the Lock class."", ""unlock"")"
"To better understand how using a Lock looks different from using a synchronized block, I have created two simple concurrent Counter classes which protects their internal count in different ways.","(""Lock"", ""Lock is used within the Counter class to ensure thread-safe operations on the internal count"", ""Counter"")"
"Notice how the calculate() method both locks the Calculator instance's Lock before performing any calculations, and also call the add() and subtract() methods which also locks the lock.",
"If the Lock instance is already locked, the thread calling lock() is blocked until the Lock is unlocked.","(""Lock"", ""The method lock() is called on an instance of the Lock class, indicating that lock() belongs to or operates on Lock."", ""lock()"")"
The Java ReentrantLock getHoldCount() method returns the number of times a given thread has locked this Lock instance.,"(""getHoldCount"", ""The getHoldCount method is used to determine the number of times a thread has locked a Lock instance."", ""Lock""); (""ReentrantLock"", ""The ReentrantLock class provides a getHoldCount method to retrieve hold information."", ""getHoldCount"")"
"The Java CertPath class (java.security.cert.CertPath represents a chain of cryptographic identity certificates (Java Certificate objects), where each certificate is the digital signer of the next certificate in the chain.","(""CertPath"", ""The CertPath class is part of the java.security.cert package."", ""java.security.cert""); (""CertPath"", ""The CertPath class is closely associated with its method representation."", ""CertPath"")"
The CertPath getType() method returns a string telling what type of certificates (e.g.,
If you want to set a different offset for the dest byte array there is a version of update() and doFinal() which takes an offset parameter extra.,"(""Update"", ""Both methods have a version that takes an offset parameter as additional input for modifying a dest byte array."", ""DoFinal"")"
Notice the call to update() and then doFinal() for these two blocks of data.,
To generate an asymmetric key pair you can use the KeyPairGenerator (java.security.KeyPairGenerator).,"(""KeyPairGenerator"", ""KeyPairGenerator is specified as a class within the java.security package."", ""java.security.KeyPairGenerator"")"
You create a KeyGenerator instance by calling the static method getInstance() passing as parameter the name of the encryption algorithm to create a key for.,
Initializing a KeyGenerator instance is done by calling its init() method.,"(""KeyGenerator"", ""The init() method is associated with initializing an instance of the KeyGenerator class"", ""init""); (""KeyGenerator"", ""The init() method is associated with initializing an instance of the KeyGenerator class"", ""init"")"
Generating a key is done by calling the KeyGenerator generateKey() method.,"(""KeyGenerator"", ""The generateKey() method is a member of the KeyGenerator class"", ""generateKey()"")"
You can access the PublicKey of a KeyPair by calling its getPublic() method.,"(""KeyPair"", ""The getPublic method is called on the KeyPair to access the public key."", ""getPublic""); (""PublicKey"", ""The getPublic method returns an instance of the PublicKey class."", ""getPublic"")"
You can access the PrivateKey of a KeyPair by calling the getPrivate() method.,"(""getPrivate"", ""The method getPrivate is used to access the PrivateKey of a KeyPair."", ""PrivateKey""); (""PrivateKey"", ""PrivateKey is a part of a KeyPair that can be accessed using the getPrivate method."", ""KeyPair"")"
You can create a Java KeyStore instance by calling its getInstance() method.,
This Keytool -delete command will remove the KeyStore entry with the alias testkey from the KeyStore stored in the file keystore.jks .,"(""Keytool"", ""The 'delete' method is a command used with the Keytool to perform operations."", ""delete""); (""Keytool"", ""Keytool operates on the KeyStore to perform actions like deletions."", ""KeyStore""); (""delete"", ""The 'delete' method targets entries within the KeyStore for removal."", ""KeyStore""); (""KeyStore"", ""The KeyStore is stored in the keystore.jks file."", ""keystore.jks"")"
"You create a digital signature by calling the update() method one or more times, finishing with a call to sign().",
"If you need to read and write the date and time to a database, use the java.sql.Date and java.sql.Timestamp classes.","(""Java.sql.Date"", ""Both are classes used for handling date and time in databases, suggesting they serve related functionality."", ""Java.sql.Timestamp"")"
Here is an example of how to create a Duration object using the between() method:,
Here is an example that shows how to create a LocalDateTime object via the now() method:,"(""LocalDateTime"", ""The now() method is used to create instances of the LocalDateTime class."", ""now"")"
The LocalTime class in the Java 8 date time API represents a specific time of day without any time zone information.,"(""LocalTime"", ""LocalTime is a class within the Java 8 date time API package"", ""Java 8 date time API"")"
The parameter passed to the of() method is the ID of the time zone to create a ZoneId for.,"(""Of"", ""The 'of' method is used to create a ZoneId instance by accepting a time zone ID as its parameter."", ""Zoneid"")"
"If you need to set a date on a java.sql.PreparedStatement or get a date from a java.sql.ResultSet, you will interact with java.sql.Date.","(""PreparedStatement"", ""PreparedStatement can set a date using the Date class."", ""Date""); (""ResultSet"", ""ResultSet can retrieve a date using the Date class."", ""Date""); (""PreparedStatement"", ""PreparedStatement is contained within the java.sql package."", ""java.sql""); (""ResultSet"", ""ResultSet is contained within the java.sql package."", ""java.sql""); (""Date"", ""Date is contained within the java.sql package."", ""java.sql"")"
One difference in the java.sql.Timestamp from its superclass java.util.Date is its ability to hold the nanoseconds of a date too.,
You can get and set the nanoseconds using the getNanos() and setNanos().,
The Calendar class has a corresponding set() method so you can set these fields too.,
"You can access the date and time contained in a java.util.Date instance using the getTime() method, like this:",
You can compare java.util.Date instance because the class implements the java.lang.Comparable interface.,"(""Java.Util.Date"", ""Java.Util.Date is related to Java.Lang.Comparable because it implements the Java.Lang.Comparable interface."", ""Java.Lang.Comparable"")"
The java.util.TimeZone class is used in conjunction with the java.util.Calendar class.,"(""TimeZone"", ""The TimeZone class is used in conjunction with the java.util.Calendar class, indicating they are related."", ""java.util.Calendar"")"
As you can see the readNumberFromUrl() needs to declare throwing both the BadUrlException and the BadNumberException that are thrown from the readDataFromUrl() and converData() methods.,"(""readNumberFromUrl"", ""The readNumberFromUrl() method declares throwing the BadUrlException class."", ""BadUrlException""); (""readNumberFromUrl"", ""The readNumberFromUrl() method declares throwing the BadNumberException class."", ""BadNumberException""); (""readDataFromUrl"", ""The BadUrlException is thrown from the readDataFromUrl() method."", ""BadUrlException""); (""converData"", ""The BadNumberException is thrown from the converData() method."", ""BadNumberException"")"
As you can see the readNumberFromUrl() method now only declares throwing ApplicationException.,
"In the example with FileNotFoundException, if you catch IOException which is the superclass of FileNotFoundException, you will also catch FileNotFoundException.","(""IOException"", ""IOException is the superclass of FileNotFoundException, indicating an inheritance relationship."", ""FileNotFoundException"")"
"If the input.close() call fails, and an IOException is thrown, then it is caught, wrapped and rethrown.","(""Close"", ""The method 'close' can throw an exception of type 'IOException' during execution."", ""IOException"")"
The Throwable class has a method named addSuppressed() which takes a Throwable object as parameter.,"(""Throwable"", ""The addSuppressed method belongs to the Throwable class."", ""addSuppressed""); (""Throwable"", ""The addSuppressed method belongs to the Throwable class."", ""addSuppressed"")"
The applyPattern() method simply applies a new pattern to the DecimalFormat instance as if it were created with that pattern.,"(""ApplyPattern"", ""The ApplyPattern method is applied to the DecimalFormat instance, indicating a functional relationship where the method operates on the class."", ""DecimalFormat"")"
The applyLocalizedPattern() does the same as applyPattern() except it interpretes the characters in the pattern according to the Locale the DecimalFormat was created with.,"(""ApplyLocalizedPattern"", ""ApplyLocalizedPattern is related to ApplyPattern as both are methods that handle patterns, and the former interprets patterns according to a specific Locale."", ""ApplyPattern""); (""ApplyLocalizedPattern"", ""ApplyLocalizedPattern is related to DecimalFormat because it uses the Locale associated with the DecimalFormat instance."", ""DecimalFormat""); (""ApplyPattern"", ""ApplyPattern is related to DecimalFormat as it is a method intended for handling pattern interpretation within this class."", ""DecimalFormat"")"
"To sort a collection of strings according to the rules of a certain Locale, you use a java.text.Collator instance created for that specific Locale.",
The factory method Locale.forLanguageTag() can also be used to create a Locale instance.,
Finally you can access the localized values in the ResourceBundle via its different getString() and getObject() etc.,"(""ResourceBundle"", ""The getString() method is used to access localized values in the ResourceBundle class."", ""getString""); (""ResourceBundle"", ""The getObject() method is used to access localized values in the ResourceBundle class."", ""getObject"")"
For this example to work you should put a standard Java property file named MyBundle.properties in a Java package named i18n.,
Once you have created a SimpleDateFormat instance you can format dates using its format() method.,"(""SimpleDateFormat"", ""The method format() belongs to the SimpleDateFormat class, indicating that it is a method provided by instances of this class to format dates."", ""format"")"
The Date instance passed to the format() method is a java.util.Date instance.,
"The Java SimpleDateFormat class is also capable of formatting a Date object into a StringBuffer, instead of returning an individual String with the date formatted.",
You can parse a String into a java.util.Date instance using the parse() method of the SimpleDateFormat instance.,
You can set the time zone of a SimpleDateFormat using its setTimeZone() method.,"(""SimpleDateFormat"", ""The setTimeZone() method is used to set the time zone for the SimpleDateFormat class."", ""setTimeZone()"")"
"In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not, but the BufferedInputStream supports them.","(""Marksupported"", ""The Marksupported method is used to determine if the Mark method is supported."", ""Mark""); (""Marksupported"", ""The Marksupported method is used to determine if the Reset method is supported."", ""Reset""); (""Bufferedinputstream"", ""The BufferedInputStream class supports the Mark method."", ""Mark""); (""Bufferedinputstream"", ""The BufferedInputStream class supports the Reset method."", ""Reset"")"
"After that, the while loop exits, and the BufferedInputStream close() method is called.","(""BufferedInputStream"", ""The close method is a function that is called on the BufferedInputStream class to terminate or close it after operations are completed."", ""close"")"
"The setSource() method actually returns a reference to the ReusableBufferedInputStream, so you can actually create a ReusableBufferedInputStream and set the source in a single instruction:",
To write data to a Java BufferedOutputStream you can use its write() method.,"(""BufferedOutputStream"", ""The write method is used within the BufferedOutputStream class to write data."", ""write"")"
If you want to make sure that all written data is written to disk without having to close the BufferedOutputStream you can call its flush() method.,"(""BufferedOutputStream"", ""The `flush` method is called on the `BufferedOutputStream` class to ensure all data is written to disk."", ""flush"")"
"Once the try block is exited, the close() method of the BufferedOutputStream is called automatically, because the BufferedOutputStream was declared inside the parentheses of the try block.","(""BufferedOutputStream"", ""The close() method is called on the BufferedOutputStream class when the try block is exited, indicating an object-method relationship."", ""close"")"
"The Java BufferedReader class is a subclass of the Java Reader class, so you can use a BufferedReader anywhere a Reader is required.",
"The Java BufferedReader class also has a read() method that takes a char array as parameter, as well as a start offset and length.","(""BufferedReader"", ""The 'read' method belongs to the 'BufferedReader' class as it is described as a method within the class context."", ""read"")"
The Java BufferedReader has a special read method named readLine() which reads a full line of text from the BufferedReader's internal buffer.,
The Java BufferedWriter's flush() method flushes all data written to the BufferedWriter to the underlying data destination.,"(""flush()"", ""The flush() method is associated with the BufferedWriter class as it flushes all data written to the BufferedWriter to the underlying data destination."", ""BufferedWriter"")"
The mark() method of the ByteArrayInputStream class sets an internal mark at the current byte position - meaning right after the previous byte read.,
"Since the Java ByteArrayOutputStream class is a subclass of the Java OutputStream class, you write bytes to it using the same write methods that OutputStream has:","(""ByteArrayOutputStream"", ""ByteArrayOutputStream is a subclass of OutputStream."", ""OutputStream""); (""OutputStream"", ""The write method belongs to the OutputStream class."", ""write"")"
"Once you have finished writing to the ByteArrayOutputStream you can obtain all the bytes written as a Java byte array, using the ByteArrayOutputStream toByteArray() method.","(""ByteArrayOutputStream"", ""The toByteArray() method is a function of the ByteArrayOutputStream class used to retrieve the written byte data as a Java byte array."", ""toByteArray()"")"
You can read a Java float from the DataInputStream using its readFloat() method.,
You can read a Java unsigned short (only positive values) from the DataInputStream using its readUnsignedShort() method.,
You can read a Java long from the DataInputStream using its readLong() method.,
"To rename (or move) a file, call the method renameTo() on the File class.",
You can obtain a list of all the files in a directory by calling either the Java File list() method or the listFiles() method.,"(""File"", ""The list method is related to the File class as it is a method under this class."", ""list""); (""File"", ""The listFiles method is related to the File class as it is another method available under this class."", ""listFiles""); (""File"", ""The list method is related to the File class as it is a method under this class."", ""list""); (""File"", ""The listFiles method is related to the File class as it is another method available under this class."", ""listFiles"")"
Here is an example of listing all files in a directory via the Java File list() and listFiles() methods:,
To write data to a Java FileOutputStream you can use its write() method.,"(""FileOutputStream"", ""The 'write' method is a function of the 'FileOutputStream' class used for writing data."", ""write"")"
Here is an example of writing data to a Java FileOutputStream using its write() method:,"(""FileOutputStream"", ""The write() method is used with the FileOutputStream class to write data."", ""write""); (""FileOutputStream"", ""The write() method is used with the FileOutputStream class to write data."", ""write"")"
Here is an example of closing a Java FileOutputStream by calling its close() method:,"(""Fileoutputstream"", ""The 'Close' method is called to close the 'Fileoutputstream'."", ""Close"")"
You can convert a FileOutputStream to a character based Writer using the Java OutputStreamWriter class.,"(""FileOutputStream"", ""OutputStreamWriter is used to convert a FileOutputStream to a character-based Writer."", ""OutputStreamWriter""); (""OutputStreamWriter"", ""OutputStreamWriter is a type of Writer used for handling character-based writing."", ""Writer"")"
The Java FileWriter's flush() method flushes all data written to the FileWriter to the underlying file.,
Here is an example of flushing data written to a Java FileWriter by calling its flush() method:,
Notice how there is no longer any explicit close() method call to the FileWriter instance.,"(""FileWriter"", ""The close method is typically associated with handling instances of the FileWriter class to release resources."", ""close"")"
The Java InputStream class contains a method called readAllBytes() (since Java 9).,"(""InputStream"", ""The method readAllBytes() is part of the InputStream class."", ""readAllBytes""); (""Java"", ""The InputStream class is part of the Java package."", ""InputStream"")"
Here is an example of reading all bytes from a Java InputStream via readAllBytes():,
"If an InputStream subclass supports the mark() and reset() methods, then that subclass should override the markSupported() to return true.",
The read() method of an InputStreamReader returns an int which contains the char value of the char read.,"(""Read"", ""The Read method belongs to the InputStreamReader class."", ""InputStreamReader"")"
Notice how there is no longer any explicit close() method call to the CharArrayWriter instance.,
"Like with FilterInputStream, I see no sensible purpose for this class.","(""FilterInputStream"", ""FilterInputStream is explicitly mentioned as a class in the text"", ""Class""); (""source_entity"", ""relationship_description"", ""target_entity"")"
They make it somewhat easier to understand what the classes are targeting.,
The read() method of a Java PipedReader returns an int which contains the char value of the character read.,"(""Read"", ""The Read method is a function of the PipedReader class."", ""PipedReader"")"
"Third, the example calls the advanced printf() method of the PrintWriter which can insert formatted numbers into a text string.",
Closing a Java StringReader can be done using the close() method like this:,"(""StringReader"", ""The close() method is used to close a StringReader."", ""close()"")"
The Java OutputStream's flush() method flushes all data written to the OutputStream to the underlying data destination.,"(""flush"", ""The 'flush' method is used by the 'OutputStream' class to flush data to the underlying data destination."", ""OutputStream"")"
The Java OutputStreamWriter's flush() method flushes all data written to the OutputStreamWriter to the underlying data destination.,"(""OutputStreamWriter"", ""The flush() method is a function provided by the OutputStreamWriter class to clear data to its underlying destination."", ""flush()""); (""OutputStreamWriter"", ""The Java OutputStreamWriter belongs to its corresponding package that is not specifically named."", ""OutputStreamWriter"")"
"If you push back multiple bytes into the PushbackInputStream, the latest byte pushed back will be returned first from read(), just like on a stack.","(""PushbackInputStream"", ""The PushbackInputStream class has a method called read(). This relationship is typical in object-oriented programming, where classes contain methods that operate on instances of those classes."", ""read"")"
"You read bytes from the Java PushbackInputStream via its read() method, just like you do from a regular InputStream .",
"Remember, calling this write() method will advance the file position of the RandomAccessFile by 1.","(""Write"", ""The write() method is called on the RandomAccessFile class to advance the file position."", ""RandomAccessFile"")"
The Java Reader class has a method named skip() which can be used to skip over a number of characters in the input that you do not want to read.,
You do so by calling the nextToken() method of the StreamTokenizer inside a loop.,"(""StreamTokenizer"", ""The nextToken method is called within an instance of the StreamTokenizer class, indicating a method of the class."", ""nextToken"")"
"System.in, System.out and System.err are initialized by the Java runtime when a Java VM starts up, so you don't have to instantiate any streams yourself (although you can exchange them at runtime).",
You will normally use a Writer subclass rather than a Writer directly.,
The Java String parameter passed to the Class forName() method is the name of the JDBC driver class for the given JDBC driver.,
"By the way, imagine that the used Person class looks like this:",
Here is an example of creating a JDBC DatabaseMetaData object via the JDBC Connection getMetaData() method:,"(""Connection"", ""The method getMetaData() is called on the Connection class."", ""getMetaData""); (""Connection"", ""A DatabaseMetaData object is created through the Connection class."", ""DatabaseMetaData"")"
The ResultSet returned by the getColumns() method contains a list of columns for the given table.,"(""ResultSet"", ""The getColumns method returns a ResultSet containing a list of columns for the given table."", ""getColumns"")"
Before the first next() call the ResultSet is positioned before the first row.,
"Once the row is ready to be inserted into the ResultSet, call the insertRow() method.","(""ResultSet"", ""The insertRow() method is used to insert a row into the ResultSet class."", ""insertRow"")"
"If you need to insert another row, explicitly call moveToInsertRow() to signal this to the ResultSet.","(""moveToInsertRow"", ""The method moveToInsertRow is called on the class ResultSet to insert another row."", ""ResultSet"")"
The purpose of an abstract class is to function as a base for subclasses.,"(""Abstract Class"", ""An abstract class serves as a base for subclasses, indicating a hierarchical relationship."", ""Subclass"")"
"If a class has an abstract method, the whole class must be declared abstract.",
The example I showed you above with the URLProcessorBase class is actually an example of the Template Method design pattern.,"(""URLProcessorBase"", ""The URLProcessorBase class is mentioned as using the Template Method design pattern, which relates it to the concept of a method."", ""Method"")"
In the above example the subclass SmartClock has a method called getTimeInSeconds() which accesses the time variable of the superclass Clock.,
The utility class is called Arrays and is located in the standard Java package java.util.,
The purpose of a constructor is to initialize the fields in the class.,"(""Constructor"", ""A constructor is used to initialize the fields within a class."", ""Fields"")"
Now the isValid() method returns the value returned by the value.equals() method call.,"(""isValid"", ""The isValid method returns the result of calling the value.equals() method, indicating a relationship of dependency or usage between these two methods."", ""value.equals"")"
In many cases it would have made sense to place the getLicensePlate() method in the Vehicle class where the licensePlate field is located.,"(""GetLicensePlate"", ""The method getLicensePlate() is logically associated with the Vehicle class where the licensePlate field is located."", ""Vehicle"")"
"Here is the same instanceof example, but using a Truck object instead of a Car object: Truck truck = new Truck(); Vehicle vehicle = truck; boolean isCar = vehicle instanceof Car; After executing this code the isCar will contain the value false.","(""Truck"", ""Truck is assigned to the Vehicle type, indicating Truck is a subclass or implementer of a Vehicle."", ""Vehicle""); (""Vehicle"", ""The instance of Vehicle is checked against the Car class using the instanceof operator, suggesting a relationship in the type hierarchy."", ""Car"")"
The updateLicensePlate() method sets the license plate value on the licensePlate field in the Car class.,"(""UpdateLicensePlate"", ""The method updateLicensePlate is associated with the Car class as it sets the license plate value on a field within this class."", ""Car""); (""UpdateLicensePlate"", ""The method updateLicensePlate is associated with the Car class as it sets the license plate value on a field within this class."", ""Car"")"
"The getLicensePlate() method, however, returns the value of the licensePlate field in the Vehicle class.","(""GETLICENSEPLATE"", ""The GETLICENSEPLATE method is associated with the VEHICLE class because it returns a value from a field within this class."", ""VEHICLE"")"
"If you override a method in a subclass, and the method is all of a sudden removed or renamed or have its signature changed in the superclass, the method in the subclass no longer overrides the method in the superclass.",
Here is a Java instanceof example illustrating the comparison of null against a class:,
"That is because it is not the reference type that is compared against the target class or interface, but the actual type of the referenced object.",
"A Java interface is a bit like a Java class, except a Java interface can only contain method signatures and fields.","(""Java interface"", ""A Java interface is compared to a Java class in terms of functionality."", ""Java class""); (""Java interface"", ""Java interface contains method signatures."", ""method"")"
The class does not need to implement (declare) the variables of an interface.,"(""Class"", ""The class can implement the interface, indicating that they have a functional relationship."", ""Interface"")"
"You must always create an instance of some class that implements the interface, and reference that instance as an instance of the interface.","(""Class"", ""A class implements the interface, indicating a relationship of implementation."", ""Interface"")"
"While it is normally possible for a class to implement multiple interfaces even if the interfaces contain methods with the same signature, this is not possible if one or more of these methods are default methods.",
In both of the above situations the Java compiler requires that the class implementing the interface(s) explicitly implements the method which causes the problem.,"(""Class"", ""The class explicitly implements the method, indicating a relationship between the two."", ""Method"")"
The implementation in the class takes precedence over any default implementations.,
"Since the return value of produce() is Object, it can return any Java object.","(""Produce"", ""The produce method returns a value of type Object, indicating a direct relationship where the method's return type is the Object class."", ""Object""); (""Object"", ""The Object class is part of the Java programming language, indicating it belongs to the Java package."", ""Java"")"
"Notice how the object returned from the carProducer.produce() method call has to be cast to a Car instance, because the produce() method return type is Object.","(""produce"", ""The produce() method returns an Object that needs to be cast to a Car instance."", ""Car"")"
"As you can see, since the generic type for the CarProducer instance is set to Car, it is no longer necessary to cast the object returned from the produce() method, since the original method declaration in the MyProducer interface states, that this method returns the same type as is specified in the generic type when used.","(""CarProducer"", ""The CarProducer instance is parametrized with the generic type Car, indicating that CarProducer operates with or produces objects of type Car."", ""Car""); (""produce"", ""The produce method is declared in the MyProducer interface, meaning it is a part of the interface's contract."", ""MyProducer""); (""CarProducer"", ""The CarProducer instance is parametrized with the generic type Car, indicating that CarProducer operates with or produces objects of type Car."", ""Car""); (""produce"", ""The produce method is declared in the MyProducer interface, meaning it is a part of the interface's contract."", ""MyProducer"")"
Now the result variable would end up with the value 12.5.,
The example above defines a method called writeText inside a class named MyClass.,
This would happen sometime at runtime - depending on when the application tried to use the missing class.,"(""Class"", ""class""); (""Class"", ""class"")"
This example module descriptor declares that it requires the standard Java module named javafx.graphics.,"(""Module Descriptor"", ""The class 'Module Descriptor' uses the method 'Requires' to indicate a need for a module dependency."", ""Requires""); (""Requires"", ""The method 'Requires' specifies a dependency on the package 'Javafx.graphics'."", ""Javafx.graphics""); (""Module Descriptor"", ""The class 'Module Descriptor' uses the method 'Requires' to indicate a need for a module dependency."", ""Requires""); (""Requires"", ""The method 'Requires' specifies a dependency on the package 'Javafx.graphics'."", ""Javafx.graphics"")"
Here is how you run the main class from a Java module JAR file:,"(""Main"", ""class""); (""Main"", ""class"")"
In Java nested classes are classes that are defined inside another class.,"(""Nested Classes"", ""Nested Classes are defined inside Classes"", ""Classes"")"
Notice how you put new after the reference to the outer class in order to create an instance of the inner class.,
"As you can see, an anonymous class implementing an interface is pretty similar to an anonymous class extending another class.","(""Anonymous Class"", ""An anonymous class is implementing an interface, indicating a relationship between the two."", ""Interface"")"
"Users of the Cache class may never see the CacheEntry class, if they have no need to obtain information about the CacheEntry itself, but only the cached value.","(""Cache"", ""Cache utilizes CacheEntry for storing cached values"", ""CacheEntry"")"
"If the classes A and B are located in the same Java package, there is no problem with the code above.",
"Instead of having a fixed number of layer packages which keep growing in number of classes, you get a growing number of application functionality packages with a smaller number of classes inside.",
A Java Record is a special kind of Java class which has a concise syntax for defining immutable data-only classes.,"(""Java Record"", ""Java Record is a kind of class defined within the Java package"", ""Java"")"
You can add instance methods to a Java Record definition - just like you can with a regular Java class.,"(""Java Record"", ""Java Record can have instance methods added to it."", ""instance method""); (""instance method"", ""Instance methods can also be added to a regular Java class."", ""Java class"")"
Notice how the brandAsLowerCase() method calls the auto-generated brand() method internally.,"(""BrandAsLowerCase"", ""The BrandAsLowerCase method internally calls the Brand method, indicating a dependency or usage relationship."", ""Brand"")"
"As you can see, a new StringBuilder is created, passing along the first String to its constructor, and the second String to its append() method, before finally calling the toString() method.",
You can search for substrings in Strings using the indexOf() method.,
The Java String class also has a lastIndexOf() method which finds the last occurrence of a substring.,"(""String"", ""The lastIndexOf method belongs to the String class and is used to find the last occurrence of a substring."", ""lastIndexOf""); (""Java"", ""The String class is part of the Java package."", ""String"")"
The Java String class contains a method called trim() which can trim a string object.,"(""String"", ""The trim() method is part of the String class, allowing it to manipulate string objects."", ""trim()"")"
"If not, the default toString() method (inherited from the Object class) will get called.",
From Java 13 the Java String class got a new method called translateEscapes() which can translate escape codes that exist inside a String in the same way the Java compiler translates them.,"(""Java String"", ""The translateEscapes method is a new addition to the Java String class."", ""translateEscapes"")"
When you create an instance of a class (an object) the object can have methods you can execute.,"(""Class"", ""Classes contain methods that can be executed by instances of the class, known as objects."", ""Method"")"
The second line assigns the floating point value 199.99 to the floating point variable named myFloat.,
"When you click the ""Run..."" option, IntelliJ IDEA will first compile your Java class, and then run it.","(""IntelliJ IDEA"", ""IntelliJ IDEA compiles and runs the Java class"", ""Java Class"")"
"The logrb() methods work like the log() methods too, except they can obtain the log messages from a resource bundle.",
You can obtain the parent Logger of a given Logger using the getParent() method.,
The getParameters() method returns the parameters to be inserted into the message of this LogRecord.,"(""GetParameters"", ""The method GetParameters is associated with the LogRecord class as it returns parameters to be inserted into the message of this LogRecord."", ""LogRecord"")"
The getResourceBundle() method returns the ResourceBundle (if any) used to localize the message of this LogRecord.,"(""getResourceBundle"", ""The method getResourceBundle returns an instance of ResourceBundle."", ""ResourceBundle""); (""getResourceBundle"", ""The method getResourceBundle is used in the context of a LogRecord to localize its message."", ""LogRecord"")"
"Note: This tutorial does not cover the other popular Java logging API's (Log4J, SLF4J, Apache Commons Logging, LogBack etc.).","(""Log4J"", ""Both are popular Java logging APIs"", ""SLF4J""); (""SLF4J"", ""Both are popular Java logging APIs"", ""Apache Commons Logging""); (""Apache Commons Logging"", ""Both are popular Java logging APIs"", ""LogBack""); (""LogBack"", ""Both are popular Java logging APIs"", ""Log4J"")"
Receiving data via a DatagramSocket is done by first creating a DatagramPacket and then receiving data into it via the DatagramSocket's receive() method.,"(""DatagramSocket"", ""The receive() method is used to receive data into a DatagramPacket, indicating a functional relationship within the DatagramSocket class"", ""receive()"")"
The java.net package contains two interesting classes: The URL class and the URLConnection class.,"(""Java.net"", ""The URL class is contained within the Java.net package"", ""URL""); (""Java.net"", ""The URLConnection class is contained within the Java.net package"", ""URLConnection"")"
You can check the when the read operation is finished by calling the isDone() method of the Future instance returned by the read() method.,"(""isDone"", ""The isDone method is called on the Future instance that is returned by the read method"", ""read"")"
Each way to write data call one of the write() methods of the AsynchronousFileChannel.,"(""Write"", ""The method 'write()' is used by the 'AsynchronousFileChannel' for data writing operations."", ""AsynchronousFileChannel"")"
The int returned by the read() method tells how many bytes were written into the Buffer.,
There is no guarantee of how many bytes the write() method writes to the FileChannel.,"(""Write"", ""The write() method is associated with the FileChannel class, indicating that it operates on, or is a method of, the FileChannel class."", ""FileChannel"")"
You can obtain the current position of the FileChannel object by calling the position() method.,
The Files.createDirectory() method creates a new directory from a Path instance.,"(""Files"", ""The createDirectory method is a function of the Files class."", ""createDirectory""); (""createDirectory"", ""The createDirectory method operates on a Path instance to create a directory."", ""Path""); (""Files"", ""The createDirectory method is a function of the Files class."", ""createDirectory""); (""createDirectory"", ""The createDirectory method operates on a Path instance to create a directory."", ""Path"")"
The Java NIO Files class also contains a function for moving files from one path to another.,"(""Files"", ""The Files class contains this function, indicating that the function is part of or related to the Files class."", ""function"")"
Here is a walkFileTree() that extends SimpleFileVisitor to look for a file named README.txt :,"(""walkFileTree"", ""The method walkFileTree utilizes or relies on the class SimpleFileVisitor for functionality."", ""SimpleFileVisitor""); (""walkFileTree"", ""The method walkFileTree utilizes or relies on the class SimpleFileVisitor for functionality."", ""SimpleFileVisitor"")"
"By walking through all directories and deleting all files (inside visitFile()) in each directory, and afterwards delete the directory itself (inside postVisitDirectory()) you can delete a directory with all subdirectories and files.","(""VISITFILE"", ""Both methods are involved in the process of deleting directories and files recursively."", ""POSTVISITDIRECTORY"")"
"In many cases though, you can replace the use of the File class with use of the Path interface.","(""File"", ""The Path interface can replace the File class in certain cases"", ""Path""); (""File"", ""The Path interface can replace the File class in certain cases"", ""Path""); (""File"", ""The Path interface can replace the File class in certain cases"", ""Path"")"
The normalize() method of the Path interface can normalize a path.,"(""Normalize"", ""The Normalize method belongs to the Path interface, indicating a relationship between the method and the class it is part of."", ""Path"")"
"As you saw in the previous section, when you register a Channel with a Selector the register() method returns a SelectionKey objects.","(""Channel"", ""Channel is registered with Selector using the register method."", ""Selector""); (""register"", ""register method returns a SelectionKey object when a Channel is registered with a Selector."", ""SelectionKey"")"
"You can also attach an object already while registering the Channel with the Selector, in the register() method.","(""register"", ""The register method is used when registering the Channel."", ""Channel""); (""Selector"", ""The Channel is registered with the Selector."", ""Channel"")"
NOTE: Only the interfaces specifically declared implemented by a given class is returned.,"(""Class"", ""The text specifies that the interfaces are implemented by the class."", ""Interfaces"")"
All you need to do is to obtain a ClassLoader and call its loadClass() method.,
"When the MyAction class calls methods on the IMyFactory instance injected into its constructor by the container, the method calls are translated into calls to the IContainer.instance() method, which is the method you use to obtain instances from the container.",
"You cannot ask for getters and setters explicitly, so you will have to scan through all the methods of a class and check if each method is a getter or setter.","(""Class"", ""Methods are functions that belong to a class and operate on its data."", ""Methods"")"
To access a private field you will need to call the Class.getDeclaredField(String name) or Class.getDeclaredFields() method.,"(""Class"", ""The method 'getDeclaredField' is related to the 'Class' as it is used to access fields of a class."", ""getDeclaredField""); (""Class"", ""The method 'getDeclaredFields' is related to the 'Class' as it is used to access all fields of a class."", ""getDeclaredFields"")"
"By calling Field.setAcessible(true) you turn off the access checks for this particular Field instance, for reflection only.","(""Field"", ""The method setAcessible is called on the Field class to modify access checks during reflection."", ""setAcessible"")"
"The methods Class.getMethod(String name, Class[] parameterTypes) and Class.getMethods() methods only return public methods, so they won't work.","(""Class.getMethod"", ""Both are methods that operate on public methods within a class"", ""Class.getMethods"")"
"It will explain the basics of Java Reflection including how to work with arrays, annotations, generics and dynamic proxies, and do dynamic class loading and reloading.","(""Reflection"", ""Reflection is useful for creating and manipulating Dynamic Proxies dynamically at runtime."", ""Dynamic Proxies""); (""Reflection"", ""Reflection is essential for performing Dynamic Class Loading and Reloading operations."", ""Dynamic Class Loading and Reloading""); (""Reflection"", ""Reflection allows reading and using Annotations at runtime."", ""Annotations"")"
"For instance, if you are introspecting a String array, you can detect that the element type is String by inspecting the array class.","(""String"", ""String is the element type of the array class"", ""array""); (""String"", ""String is the element type of the array class"", ""array"")"
"For instance, the character class [a-zA-Z] will match all letters between a and z or between A and Z .",
"For that, you need to use the find(), start() and end() methods.","(""Find"", ""Method""); (""Start"", ""Method""); (""End"", ""Method"")"
"In other words, if the regular expression matches the beginning of a text but not the whole text, lookingAt() will return true, whereas matches() will return false.","(""lookingAt"", ""Both lookingAt() and matches() are methods that assess regular expressions but differ in their evaluation criterialookingAt() returns true if the pattern matches at the start, whereas matches() requires a complete match."", ""matches""); (""lookingAt"", ""Both lookingAt() and matches() are methods that assess regular expressions but differ in their evaluation criterialookingAt() returns true if the pattern matches at the start, whereas matches() requires a complete match."", ""matches"")"
"In case you have started matching occurrences in a string via the find() method, the Matcher will internally keep a state about how far it has searched through the input text.","(""Find"", ""The find() method is used by the Matcher class to search through input text by matching occurrences."", ""Matcher"")"
The Matcher replaceAll() and replaceFirst() methods can be used to replace parts of the string the Matcher is searching through.,
A regular expression is also sometimes referred to as a pattern (hence the name of the Java Pattern class).,
"Too keep this text short, the Matcher covered in more detail in the text about the Java Matcher class.","(""Matcher"", ""The Matcher class is mentioned as part of the Java Matcher class"", ""Java Matcher"")"
When you are finished reading data from the GZIPInputStream you should close it using its close() method.,
"But, notice how no DI is used inside the BO.checkPersonIsValid() or the DAO.readPerson() methods.",
"This little script defines the ""max"" factory as a call to the static max() method with input parameter 0 and 1 passed to the max() method.","(""Max"", ""The 'max' factory is defined as a call to the 'max' method."", ""Factory"")"
"In other words, as a call to the get() method on the HttpRequestCache singleton.",
The ScriptFactoryBuilder has a addFactories() method that takes an InputStream as parameter instead of a String.,"(""ScriptFactoryBuilder"", ""The method 'addFactories()' is associated with the 'ScriptFactoryBuilder' class."", ""addFactories()"")"
"Notice how the HttpServletRequest and HttpServletResponse are not obtained by the ThreadLocal.get() method, but via the static methods getRequest() and getResponse().","(""HttpServletRequest"", ""The getRequest() method is used to obtain an instance of HttpServletRequest."", ""getRequest()""); (""HttpServletResponse"", ""The getResponse() method is used to obtain an instance of HttpServletResponse."", ""getResponse()"")"
"The IObjectMappingKey instance can contain more information about the class to be mapped, than a Class object can.","(""IObjectMappingKey"", ""IObjectMappingKey can contain more information about the class to be mapped than a Class object can, indicating a likely relationship in terms of functionality or hierarchy."", ""Class"")"
This is the object is obtained from the getResult() method of the IResultSetProcessor.,
"This speeds up object mapping cache lookups because the hashCode() method returns this int id, and because equals() also only compares int id's, instead of Class objects, table names etc.","(""HashCode"", ""Both methods are related as they are used for object comparison and caching strategies."", ""Equals""); (""Class"", ""The method HashCode is often associated with Class objects when implementing hash-based collections."", ""HashCode"")"
The extended class CustomObjectMapperBase is an empty implementation of the ICustomObjectMapper interface.,
Just call the IObjectMapping.removeGetterMapping(String name) or IObjectMapping.removeSetterMapping(String name) method to do so.,"(""IObjectMapping"", ""The method removeGetterMapping is associated with the IObjectMapping class."", ""removeGetterMapping""); (""IObjectMapping"", ""The method removeSetterMapping is associated with the IObjectMapping class."", ""removeSetterMapping"")"
"Second, you do not need the parentheses around the closure when calling doFirst() or doLast().","(""doFirst"", ""Both doFirst and doLast are methods mentioned in the context of calling closures"", ""doLast"")"
The and() method is used to combine two other Predicate functions in the same way I showed in the beginning of this Java functional composition tutorial.,"(""And"", ""The and() method combines Predicate functions."", ""Predicate""); (""And"", ""The and() method is part of the Java programming language."", ""Java"")"
"The Java Function compose() method composes a new Function instance from the Function instance it is called on, and the Function instance passed as parameter to the compose() method.",
The first example of a higher order function is the Collections.sort() method which takes a Comparator as parameter.,
The call to the map() method of the Stream interface is a non-terminal operation.,"(""Map"", ""The Map method is a function that operates on the Stream class."", ""Stream"")"
Only the first occurrence of this element will be included in the Stream returned by distinct().,"(""distinct"", ""The method 'distinct()' operates on the class 'Stream' to return distinct elements."", ""Stream"")"
"The findFirst() method returns an Optional from which you can obtain the element, if present.",
"The Java Stream forEach() method is a terminal operation which starts the internal iteration of the elements in the Stream, and applies a Consumer (java.util.function.Consumer) to each element in the Stream.",
Which element is the largest is determined by the Comparator implementation you pass to the max() method.,
This Optional contains the value (if any) returned by the lambda expression passed to the reduce() method.,"(""lambda expression"", ""The lambda expression is passed to the reduce() method to perform reduction."", ""reduce""); (""Optional"", ""The Optional class contains the value returned by the reduce() method, if any."", ""reduce"")"
"Note: Even if the class is called RollingBufferInputStream, it is not an InputStream subclass.","(""RollingBufferInputStream"", ""The text mentions that RollingBufferInputStream is called a class and indicates it is not a subclass of InputStream, suggesting a potential conceptual relationship or naming convention that might lead one to assume a subclass relationship, even though it does not exist."", ""InputStream"")"
"You can specify fonts for most text objects (Chunk, Phrase, Paragraph etc.)",
"If you already have a finished PDF, and just want to add a header, footer or watermark to it, IText provides the com.itextpdf.pdf.PdfStamper class.","(""IText"", ""PdfStamper is a class provided by the IText package for adding headers, footers, or watermarks to a PDF."", ""PdfStamper"")"
"You can write text as superscript or subscript using the Chunk class, and it's setTextRise() method.","(""CHUNK"", ""The method setTextRise() belongs to the Chunk class as it is used for modifying properties of text related to this class."", ""SETTEXTRISE"")"
"You can add underline and strikethrough text using the Chunk class, and its setUnderline() method.",
"It is now up to the caller of the readMyData() method to decide if an existing MyData instance should be reused, or if a new instance should be created.","(""ReadMyData"", ""The ReadMyData method is explicitly mentioned as acting upon or dealing with an instance of the MyData class."", ""MyData"")"
The value returned by write() is the number of bytes copied from the ByteBuffer.,
Here is an implementation of the ring buffer that uses a fill count including the batch put() and take() operations.,"(""Ring Buffer"", ""The method Put is a batch operation on the Ring Buffer class."", ""Put""); (""Ring Buffer"", ""The method Take is a batch operation on the Ring Buffer class."", ""Take"")"
"Here is an implementation of the ring buffer that uses a read position and flip marker, including the batch put() and take() operations.","(""Ring Buffer"", ""The read position is used within the ring buffer to manage data reading."", ""Read Position""); (""Ring Buffer"", ""The flip marker is a component of the ring buffer that helps manage state transitions."", ""Flip Marker""); (""Ring Buffer"", ""Batch put is a method used in the ring buffer for adding multiple elements at once."", ""Batch Put""); (""Ring Buffer"", ""Take is a method used in the ring buffer to retrieve elements."", ""Take"")"
"If your benchmark method produces multiple results you can pass each of these results to a black hole, meaning calling consume() on the Blackhole instance for each value.","(""Benchmark"", ""A benchmark typically involves executing a method to measure performance."", ""Method""); (""Method"", ""The method results are passed to a Blackhole instance to prevent optimizations that could affect benchmarking."", ""Blackhole""); (""Consume"", ""Consume is likely a method of the Blackhole class that handles the passed results."", ""Blackhole"")"
The javax.servlet.http.HttpServlet class is a slightly more advanced base class than the GenericServlet shown in the Simple Servlet example.,
The easiest way to implement this interface is to extend either the class GenericServlet or HttpServlet.,"(""interface"", ""The GenericServlet class can be used to implement the interface."", ""GenericServlet""); (""interface"", ""The HttpServlet class can be used to implement the interface."", ""HttpServlet"")"
Each test method usually tests a single method of the target class.,
"A protected method or field, on the other hand, is also accessible to other classes in the same package, and for subclasses of the unit too.","(""Method"", ""The method is accessible to classes within the same package."", ""Package""); (""Field"", ""The field is accessible to classes within the same package."", ""Package""); (""Method"", ""Both are protected members and share accessibility rules."", ""Field"")"
"When your business logic class is separated from the boundary class, you can test the business logic class separately.",
Here is the unit test which uses a ByteArrayOutputStream to collect the data written to the OutputStream passed to the MyIOUnit.write() method:,"(""BYTEARRAYOUTPUTSTREAM"", ""ByteArrayOutputStream is used to collect data written to the OutputStream."", ""OUTPUTSTREAM""); (""MYIOUNIT.WRITE()"", ""MyIOUnit.write() uses OutputStream as an argument."", ""OUTPUTSTREAM"")"
You may also be able to use the StringReader and StringWriter classes in your unit tests.,
"To avoid fragmenting the Java heap with Bytes instances, the Bytes class is designed to be obtained from an ObjectPool .","(""Bytes"", ""The Bytes class is designed to be obtained from the ObjectPool, indicating a relationship where ObjectPool is likely a provider or manager of Bytes instances."", ""ObjectPool""); (""Bytes"", ""The Bytes class is designed to be obtained from the ObjectPool, indicating a relationship where ObjectPool is likely a provider or manager of Bytes instances."", ""ObjectPool"")"
To defragment the free blocks you call the defragment() method of the BytesAllocatorManualDefrag .,"(""BytesAllocatorManualDefrag"", ""The defragment method is a part of the BytesAllocatorManualDefrag class."", ""defragment""); (""BytesAllocatorManualDefrag"", ""The defragment method is a part of the BytesAllocatorManualDefrag class."", ""defragment"")"
The Bytes class represents a byte sequence allocated from a shared byte array.,"(""Bytes"", ""The Bytes class represents a byte sequence."", ""byte sequence""); (""byte sequence"", ""The byte sequence is allocated from a byte array."", ""byte array"")"
"As you can see, the ChannelInitializer is added to the ServerBootstrap using the childHandler() method.","(""ChannelInitializer"", ""The ChannelInitializer is added to the ServerBootstrap, indicating a configuration or setup relationship."", ""ServerBootstrap""); (""childHandler"", ""The childHandler() method is used on the ServerBootstrap, indicating a functional relationship."", ""ServerBootstrap"")"
"By calling sync() on the ChannelFuture the main thread that creates the server waits until the server has started, before continuing.","(""sync"", ""The method sync() is called on the ChannelFuture class."", ""ChannelFuture"")"
The easiest way to create an instance of the RionObjectReader is via the RionObjectReaderBuilder class.,"(""RionObjectReaderBuilder"", ""RionObjectReaderBuilder is used to create an instance of RionObjectReader"", ""RionObjectReader"")"
The RionObjectReader readCyclic() method reads a cyclic object graph stored as RION in a byte array.,"(""RionObjectReader"", ""RionObjectReader contains the method readCyclic()"", ""readCyclic()""); (""RionObjectReader"", ""RionObjectReader reads data formatted as RION"", ""RION""); (""RionObjectReader"", ""RionObjectReader contains the method readCyclic()"", ""readCyclic()""); (""RionObjectReader"", ""RionObjectReader reads data formatted as RION"", ""RION"")"
The RionObjectWriter writeAcyclic() can write an acyclic object graph as RION into a byte array.,"(""RionObjectWriter"", ""The method 'writeAcyclic' is a function of the 'RionObjectWriter' class."", ""writeAcyclic"")"
When reading a composite RION field you need to use the RionReader moveInto() and moveOutOf() methods.,"(""RionReader"", ""The method moveInto is a member of the class RionReader."", ""moveInto""); (""RionReader"", ""The method moveOutOf is a member of the class RionReader."", ""moveOutOf"")"
"Here are two examples of writing a 32 bit and 64 bit floating point number as RION Float fields to the destination byte array, using the RionWriter writeFloat32() and writeFloat64() methods:","(""RionWriter"", ""writeFloat32 is a method that belongs to the RionWriter class"", ""writeFloat32""); (""RionWriter"", ""writeFloat64 is a method that belongs to the RionWriter class"", ""writeFloat64"")"
The StreamStorageFS class contains a method to read bytes from a stream block file.,
"The readBytes() method reads bytes from the file represented by the given StreamStorageBlockFS instance, into the byte[] array passed as parameter.",
You can always obtain the root directory path a StreamStorageRootFS was created with via its getRootDirPath() method.,"(""StreamStorageRootFS"", ""The getRootDirPath method belongs to the StreamStorageRootFS class, as it is used to obtain the root directory path associated with an instance of this class."", ""getRootDirPath"")"
"When you write records to a stream via the StreamStorageFS instance, the StreamStorageFS class will divide the records into multiple files.","(""StreamStorageFS"", ""The StreamStorageFS class is related to the stream as it is used to write records to it."", ""stream""); (""write"", ""The write method is related to the stream because it describes the action of writing records to the stream."", ""stream""); (""StreamStorageFS"", ""The StreamStorageFS class likely utilizes the write method to perform the action of writing to the stream."", ""write"")"
You can read the data stored in a Buffer using the many get...() methods.,"(""Buffer"", ""The class Buffer contains or uses the get...() methods to perform operations on its data."", ""get...() methods""); (""Buffer"", ""The class Buffer contains or uses the get...() methods to perform operations on its data."", ""get...() methods"")"
Notice the use of / as directory separator and the use of : as classpath entry separator.,"(""DIRECTORY"", ""Directory is part of the path structure used in the classpath entry."", ""CLASSPATH"")"
"However, if you do need to access the body of the HTTP response, you need to register another handler on the HttpClientResponse that is passed as parameter to the first Handler's handle() method.","(""Handler"", ""handle() is a method of the Handler class."", ""handle()""); (""HttpClientResponse"", ""HttpClientResponse is passed as a parameter to a method in the Handler class."", ""Handler"")"
"Again, the NetClient's close() method is asynchronous, so the underlying TCP connection may not yet be closed by the time the close() method returns.","(""NetClient"", ""The close() method is a method of the NetClient class."", ""close"")"
Sending messages via the event bus can be done via either the send() or publish() method on the event bus.,"(""Send"", ""The send method operates on the event bus to facilitate message dispatch."", ""Event Bus""); (""Publish"", ""The publish method operates on the event bus to distribute messages."", ""Event Bus"")"
A verticle has a start() and a stop() method which are called when the verticle is deployed and when it is undeployed.,"(""Verticle"", ""Start() is a method of the Verticle class."", ""Start()""); (""Verticle"", ""Stop() is a method of the Verticle class."", ""Stop()""); (""Verticle"", ""Start() is a method of the Verticle class."", ""Start()""); (""Verticle"", ""Stop() is a method of the Verticle class."", ""Stop()"")"
The addAll() method takes a Collection as parameter so you can pass either a List or Java Set as parameter,"(""AddAll"", ""The addAll method takes a Collection as parameter"", ""Collection""); (""Collection"", ""A List can be passed as a parameter to the Collection in the addAll method"", ""List""); (""Collection"", ""A Java Set can be passed as a parameter to the Collection in the addAll method"", ""Java Set"")"
But no thread can actually execute unlock() until the thread waiting in lock() leaves the outer synchronized block,"(""Lock"", ""Unlock depends on Lock completing execution before it can proceed."", ""Unlock""); (""Lock"", ""Unlock depends on Lock completing execution before it can proceed."", ""Unlock"")"
A thread cannot call wait() notify() or notifyAll() without holding the lock on the object the method is called on,"(""Thread"", ""A thread cannot call the wait() method without holding the lock on the object."", ""Wait()""); (""Thread"", ""A thread cannot call the notify() method without holding the lock on the object."", ""Notify()""); (""Thread"", ""A thread cannot call the notifyAll() method without holding the lock on the object."", ""NotifyAll()""); (""Object"", ""The wait() method is called on an object."", ""Wait()""); (""Object"", ""The notify() method is called on an object."", ""Notify()""); (""Object"", ""The notifyAll() method is called on an object."", ""NotifyAll()"")"
"The Arrays class contains a set of methods called binarySearch(). This method helps you perform a binary search in an array. The array must first be sorted. You can do so yourself, or via the Arrays.sort() method covered earlier in this text.",
java.lang.ThreadLocal is possible to set an initial value for a Java ThreadLocal which will get used the first time get() is called before set() has been called with a new value,
Adding and getting elements to a generic Map is done using the put() and get() methods just like you have always done,
Deque.pollLast() is different than removeLast() which throws an exception if the Deque is empty,"(""pollLast"", ""pollLast and removeLast are both methods of the Deque class"", ""removeLast""); (""Deque"", ""pollLast is a method of the Deque class"", ""pollLast""); (""Deque"", ""removeLast is a method of the Deque class"", ""removeLast"")"
The tailSet() method works the same way as the headSet() method except it returns all elements that are equal to or higher than the given parameter element,"(""tailSet"", ""The tailSet method and the headSet method are related as both perform similar operations on elements but return differing element ranges."", ""headSet""); (""tailSet"", ""The tailSet method and the headSet method are related as both perform similar operations on elements but return differing element ranges."", ""headSet"")"
"You can also obtain an Iterator from many of the Java Collection data structures, e.g. a List, Set, Map, Queue, Deque or Map.",
java.io.Writer works just like combining the Reader with InputStream or the Writer with OutputStream,"(""Writer"", ""Writer and Reader are related as they are often used together in Java for handling I/O operations. Writer is similar to Reader but for writing, typically involving character streams."", ""Reader""); (""Writer"", ""The description compares Writer to a combination involving InputStream, suggesting a possible functional relationship in handling data streams."", ""InputStream""); (""Writer"", ""Writer is compared to a combination involving OutputStream, indicating a relationship in processing output data streams."", ""OutputStream"")"
Remember that even if the 4 threads call wait() and notify() on the same shared string instance the signals from the doWait() and doNotify() calls are stored individually in the two MyWaitNotify instances,"(""wait"", ""The methods wait and notify are complementary synchronization methods often used together to manage thread communication."", ""notify""); (""doWait"", ""The methods doWait and doNotify seem to be related as mirrored actions within the MyWaitNotify class, likely designed to manage waiting and notifying operations."", ""doNotify""); (""MyWaitNotify"", ""doWait is a method of the MyWaitNotify class, designed to handle wait operations."", ""doWait""); (""MyWaitNotify"", ""doNotify is a method of the MyWaitNotify class, designed to handle notify operations."", ""doNotify"")"
The bigger the result String grows the longer it takes to copy the characters from it into a new StringBuilder and again copy the characters from the StringBuilder into the temporary String created by the toString() method,"(""String"", ""Both classes are involved in the copying process where characters are moved from a String to a StringBuilder"", ""StringBuilder""); (""StringBuilder"", ""The toString method is used to create a temporary string from the StringBuilder"", ""toString"")"
The logp() methods work like the log() methods except each method take an extra two parameters The sourceClass and sourceMethod parameter,
But since the thread waiting in lock() has not yet called queueObject.wait() the call to queueObject.notify() passes into oblivion,"(""Lock"", ""The 'lock()' method causes a thread to wait, and 'queueObject.wait()' is mentioned in this context, suggesting a synchronization mechanism."", ""QueueObject.Wait""); (""QueueObject.Wait"", ""queueObject.wait() and queueObject.notify() are complementary methods typically used together for thread synchronization; one waits while the other signals to continue."", ""QueueObject.Notify"")"
Since PipedOutputStream is a subclass of OutputStream PipedOutputStream has the same basic methods and use patterns as an OutputStream,"(""PipedOutputStream"", ""PipedOutputStream is a subclass of OutputStream, indicating an inheritance relationship between these two classes"", ""OutputStream"")"
You can convert a Java Set to a Java List by creating a List and calling its addAll() method passing the Set as parameter to the addAll() method,
Even though the Java Networking APIs enable you to open and close network connections via sockets all communication happens via the Java IO classes InputStream and OutputStream,
Again here the first() and next() methods return the unicode index of the found word boundary,
Obviously if the input parameter to contains() is null the contains() method will not use the equals() method to compare against each element but rather use the == operator,"(""Contains"", ""The 'contains' method uses the 'equals' method to compare elements."", ""Equals""); (""Contains"", ""The 'contains' method uses the '==' operator when the input parameter is null."", ""=="")"
Both Java File and FileChannel works but in case you want a pure Java NIO solution use the Java NIO FileChannel class,
If you need an integer value use the round() floor() or ceil() method,
The poll() and remove() both removes the first element in the Queue. They differ in how they behave if the Queue is empty. The poll() method returns null if the Queue is empty. The remove() method throws an exception if the Queue is empty.,"(""Poll()"", ""The poll() method operates on the Queue class as it removes the first element from it."", ""Queue""); (""Remove()"", ""The remove() method operates on the Queue class as it removes the first element from it."", ""Queue""); (""Poll()"", ""The poll() method operates on the Queue class as it removes the first element from it."", ""Queue""); (""Remove()"", ""The remove() method operates on the Queue class as it removes the first element from it."", ""Queue"")"
"The add() and offer() methods differ in how the behave if the Queue is full, so no more elements can be added. The add() method throws an exception in that case, whereas the offer() method just returns false.",
Each of the methods ceilingEntry() floorEntry() higherEntry() and lowerEntry() will be covered in the following sections,"(""CeilingEntry"", ""method""); (""FloorEntry"", ""method""); (""HigherEntry"", ""method""); (""LowerEntry"", ""method"")"
To do so set the upper bound to 1 and have the call to take() and release() guard the critical section,"(""Take"", ""Both methods are used to guard the critical section and are related by their function in synchronization."", ""Release"")"
Once you have opened a socket (network connection) though you read and write data to and from it via Java IO InputStream and OutputStream classes,"(""InputStream"", ""InputStream is part of the Java IO package, used for reading data."", ""Java IO""); (""OutputStream"", ""OutputStream is part of the Java IO package, used for writing data."", ""Java IO""); (""Socket"", ""A Socket can be used to read data via the InputStream class."", ""InputStream""); (""Socket"", ""A Socket can write data via the OutputStream class."", ""OutputStream"")"
Many of the core components in the Java Collection API rely on the correct implementation of the `hashCode()` and `equals()` methods.,"(""HashCode"", ""The methods 'hashCode' and 'equals' are typically used together in Java to ensure consistency in collections."", ""Equals"")"
java.io.PrintWriter example first creates a PrintWriter instance which is connected to a FileWriter,"(""PrintWriter"", ""PrintWriter is connected to FileWriter, indicating that it likely uses FileWriter to output data to a file."", ""FileWriter"")"
InputStream.read() example creates an AsynchronousFileChannel and then creates a ByteBuffer which is passed to the read() method as parameter along with a position of 0,
java.lang.StringBuffer text explains how to use the SimpleDateFormat class to format dates,"(""StringBuffer"", ""StringBuffer likely interacts with SimpleDateFormat for formatting dates in textual representation"", ""SimpleDateFormat"")"
In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not but the BufferedInputStream supports them,"(""BufferedInputStream"", ""BufferedInputStream supports markSupported method"", ""markSupported""); (""BufferedInputStream"", ""BufferedInputStream supports mark method"", ""mark""); (""BufferedInputStream"", ""BufferedInputStream supports reset method"", ""reset""); (""BufferedInputStream"", ""BufferedInputStream supports markSupported method"", ""markSupported""); (""BufferedInputStream"", ""BufferedInputStream supports mark method"", ""mark""); (""BufferedInputStream"", ""BufferedInputStream supports reset method"", ""reset"")"
"The newLine() method which can write a new-line character to the underlying Writer. In addition, you may need to call flush() if you need to be absolutely sure that the characters written until now is flushed out of the buffer and onto the network or disk.","(""NewLine"", ""Both NewLine and Flush are methods involved in managing the output process by writing and ensuring characters are delivered accurately."", ""Flush"")"
Queue.poll() is different than remove() which throws an exception if the Deque is empty,"(""Queue"", ""poll() is a method that belongs to the Queue class"", ""poll()""); (""Queue"", ""remove() is another method that is possibly associated with the Queue class"", ""remove()""); (""Deque"", ""The remove() method is related to the Deque class because it throws an exception if the Deque is empty"", ""remove()"")"
Notice the two synchronized blocks inside the set() and get() method. Notice how the blocks are placed last and first in the two methods.,"(""Set"", ""Both methods contain synchronized blocks and are mentioned together in the context of block placement."", ""Get"")"
"The replace() method will only insert the new value if there is already an existing value mapped to the key. If no existing value is mapped to the given key, no value is inserted. This is different from how put() works, which always insert the value no matter what.","(""Replace"", ""Both Replace and Put are methods that manipulate values mapped to given keys, but they have different behaviors regarding insertion."", ""Put"")"
The logrb() methods work like the log() methods too except they can obtain the log messages from a resource bundle,"(""Logrb"", ""Logrb methods work similarly to log methods, indicating a functional or behavioral relationship between them."", ""Log""); (""Logrb"", ""Logrb methods can obtain log messages from a resource bundle, indicating a dependency or interaction relationship."", ""Resource Bundle""); (""Logrb"", ""Logrb methods work similarly to log methods, indicating a functional or behavioral relationship between them."", ""Log""); (""Logrb"", ""Logrb methods can obtain log messages from a resource bundle, indicating a dependency or interaction relationship."", ""Resource Bundle"")"
The Handler in the Java Logging API use a java.util.logging.Formatter to format the LogRecord before writing it to an external system,
