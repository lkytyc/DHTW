The Collections reverse() method can reverse the elements in a Java List.,"(""Collections"", ""The reverse() method is part of the Collections class"", ""reverse()""); (""reverse()"", ""The reverse() method can reverse the elements in a Java List"", ""List""); (""Collections"", ""The Collections class has a method that can operate on a List"", ""List""); (""Java"", ""List is a part of the Java package"", ""List"")"
Here is an example of finding the minimum element in a Java List using Collections min() method:,"(""Collections"", ""The Collections class contains the min() method, indicating a clear relationship between the two entities as the method is part of the class."", ""min()""); (""Java"", ""The Java package contains the List class, indicating a clear relationship between the two entities as the class is part of the package."", ""List""); (""Java"", ""The Java package contains the Collections class, indicating a clear relationship between the two entities as the class is part of the package."", ""Collections""); (""List"", ""The List class is related to the min() method as the method can be used to find the minimum element in a List, indicating a clear functional relationship between the two entities."", ""min()"")"
"Notice too, that the compareTo() method should throw a NullPointerException if the parameter object is null.",
The LinkedList class is a pretty standard Deque and Queue implementation.,"(""LinkedList"", ""LinkedList is a Deque implementation"", ""Deque"")"
You add elements to the beginning end of a Deque using the add() method.,
"If the element cannot be inserted into the Deque, the add() method will throw an exception.",
"If the element cannot be inserted into the Deque, the addLast() method will throw an exception.",
To peek at the last element of a Java Deque you can use the getLast() method.,
The remove() method removes the first element of a Java Deque.,
"The pollFirst() method removes an element from the beginning of the Deque, just like poll().","(""PollFirst"", ""The pollFirst() method is related to the Deque class because it operates on the Deque, removing an element from its beginning."", ""Deque""); (""Poll"", ""The poll() method is related to the Deque class because it is compared to pollFirst() which operates on the Deque, implying that poll() also operates on the Deque."", ""Deque"")"
Here is an example of removing the last element from a Java Deque using the pollLast() method:,
The Java Deque size() method returns the number of elements stored in the Java Deque at the time you invoke the method.,
"Because the Iterator has its generic type set to String, the Java compiler already knows that next() will return a String.","(""Iterator"", ""The Iterator class has a method called next(), indicating a relationship between the two."", ""next()""); (""next()"", ""The next() method returns a String, indicating a relationship between the method and the class."", ""String""); (""Iterator"", ""The Iterator has its generic type set to String, indicating a relationship between the class and the type."", ""String""); (""Java"", ""The Java compiler is aware of the Iterator class, indicating a relationship between the package and the class."", ""Iterator""); (""Java"", ""The Java compiler is aware of the String class, indicating a relationship between the package and the class."", ""String"")"
"As you can see, a proper implementation of .equals() is essential for your own classes to work well with the Java Collection classes.","(""Java Collection"", ""The Java Collection class is related to the .equals() method because a proper implementation of .equals() is essential for classes to work well with the Java Collection classes."", "".equals()"")"
"So, as you can see, a combination of the hashCode() and equals() methods are used when storing and when looking up objects in a hashtable.","(""Hashcode"", ""The Hashcode method is used when storing objects in a Hashtable"", ""Hashtable""); (""Equals"", ""The Equals method is used when looking up objects in a Hashtable"", ""Hashtable"")"
"Then it uses a for-each loop to iterate the elements of the List, and print out the toString() value of each element.",
Here is an example of iterating the elements of an Iterable via its forEach() method:,
"The reason the for-each loop is slower is, that each iteration will call the List iterator() method, which will create a new Iterator object.","(""List"", ""The List class has a method called iterator(), which establishes a relationship between the two entities."", ""iterator()""); (""iterator()"", ""The iterator() method creates a new Iterator object, indicating a relationship between the method and the class."", ""Iterator"")"
"In other words, if the Iterator has not yet iterated over all of the elements in the collection the Iterator was obtained from - the hasNext() method will return true.","(""Iterator"", ""The Iterator class has a hasNext() method, indicating a relationship between the two entities."", ""hasNext()""); (""Iterator"", ""The Iterator is obtained from a collection, indicating a relationship between the two entities, where the Iterator is dependent on the collection."", ""collection"")"
The first three add() calls add a String instance to the end of the list.,"(""Add"", ""The add() method is used to add a String instance to the end of the list, indicating a relationship between the add() method and the String class."", ""String""); (""Add"", ""The add() method is used to add elements to the end of the list, indicating a relationship between the add() method and the List class."", ""List"")"
"The addAll() method takes a Collection as parameter, so you can pass either a List or Java Set as parameter.","(""AddAll"", ""The addAll() method takes a Collection as parameter, indicating a relationship between the method and the class."", ""Collection""); (""AddAll"", ""The addAll() method can take a List as parameter, indicating a relationship between the method and the class."", ""List""); (""AddAll"", ""The addAll() method can take a Set as parameter, indicating a relationship between the method and the class."", ""Set""); (""Collection"", ""List is a subclass of Collection, indicating a relationship between the two classes."", ""List"")"
"Notice that the get() method returns a Java Object, so we have to cast it to a String (because we know the value is a String).","(""Get"", ""The get() method returns a Java Object, indicating a relationship between the Get method and the Java Object class."", ""Java Object""); (""Get"", ""The get() method is cast to a String, indicating a relationship between the Get method and the String class."", ""String"")"
"This example creates a Map and stores three values in it using the keys A, B and C. Then the example calls the Map getOrDefault() method, passing the String E as key, along with a default value - the String default value.","(""Map"", ""The Map class has a method called getOrDefault, which establishes a relationship between the two entities."", ""getOrDefault""); (""Map"", ""The Map class uses the String class as keys, which establishes a relationship between the two entities."", ""String"")"
Since the Map does not contain any object stored by the key E the given default value will be returned - which is the String default value passed as the last parameter to the getOrDefault() method.,"(""Map"", ""The Map class has a method called getOrDefault(), which suggests a relationship between the Map class and the getOrDefault() method."", ""getOrDefault()""); (""String"", ""The String class is related to the getOrDefault() method because the method returns a default value of type String, indicating a connection between the String class and the getOrDefault() method."", ""getOrDefault()"")"
"As you can see, the key Iterator returns every key stored in a Java Map, one by one (one for each call to next()).","(""Iterator"", ""The Iterator is related to the Map because it returns every key stored in a Java Map."", ""Map""); (""Iterator"", ""The Iterator is related to the next() method because the next() method is called on the Iterator to retrieve the next key."", ""next()"")"
The number of entries in a Java Map is also referred to as the Map size - hence the method name size() .,
The isEmpty() method will return false if the Map instance contains 1 or more entries.,
Here is an example of creating an instance of the Java TreeMap class which implements the NavigableMap interface:,"(""TreeMap"", ""TreeMap implements the NavigableMap interface"", ""NavigableMap""); (""TreeMap"", ""TreeMap is a part of the Java package"", ""Java"")"
"The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys ""c"", ""d"" and ""e"", as these keys are considered equal to or larger than the parameter value ""c"" passed to the tailMap() method.","(""TailMap"", ""The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys 'c', 'd' and 'e'"", ""NavigableMap""); (""TailMap"", ""The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys 'c', 'd' and 'e'"", ""SortedMap""); (""NavigableMap"", ""The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys 'c', 'd' and 'e', as these keys are considered equal to or larger than the parameter value 'c' passed to the tailMap() method"", ""TailMap""); (""SortedMap"", ""The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys 'c', 'd' and 'e'"", ""NavigableMap"")"
The lowerEntry() method in the NavigableMap interface returns the key + value pair for the highest key which is lower than the parameter value passed to the lowerEntry() method.,
"The pollFirstEntry() method returns and removes the ""first"" entry (key + value) in the NavigableMap or null if the map is empty.",
"The descendingIterator() method allows you to iterate the elements of the NavigableSet (which is also a SortedSet) in reverse order, without changing the order of the elements internally.","(""NavigableSet"", ""The descendingIterator() method is a part of the NavigableSet class, indicating a relationship between the two."", ""descendingIterator()"")"
"To get properties from a Java Properties object you use the getProperty() method, passing the key of the property to get as parameter.",
"Using the InputStream you can load the file into a Java Properties instance, using either the load() or loadFromXML() methods explained earlier in this Java Properties tutorial.","(""InputStream"", ""The InputStream is used to load the file into a Java Properties instance"", ""Java Properties""); (""Java Properties"", ""The load() method is used in conjunction with Java Properties"", ""load()""); (""Java Properties"", ""The loadFromXML() method is used in conjunction with Java Properties"", ""loadFromXML()""); (""InputStream"", ""The InputStream is used with the load() method to load the file"", ""load()"")"
Here are two examples of taking an element from a Java Queue using its poll() and remove() methods:,"(""Queue"", ""The Queue class has a poll() method, indicating a relationship between the two."", ""poll()""); (""Queue"", ""The Queue class has a remove() method, indicating a relationship between the two."", ""remove()"")"
You can check if a Java Queue contains a certain element via its contains() method.,
The Java Set interface as a method called removeAll() which removes all elements in the Set which are also present in another Collection.,"(""Set"", ""The Set class has a method called removeAll(), indicating a relationship between the two."", ""removeAll()""); (""removeAll()"", ""The removeAll() method is related to the Collection class because it removes elements present in another Collection, indicating a relationship between the two."", ""Collection"")"
You can check the size of a Java Set using the size() method.,
"You iterate the keys of a SortedMap by calling its keySet() method, like this:",
The SortedMap interface has a method named headMap() which returns a new Map which contains the first elements of the SortedMap according to the sort order used.,"(""SortedMap"", ""The SortedMap interface has a method named headMap() which returns a new Map, indicating that headMap() is a method of the SortedMap interface."", ""headMap()""); (""headMap()"", ""The headMap() method returns a new Map, indicating that headMap() is related to Map as its return type."", ""Map"")"
Here is an example of obtaining a submap from a Java SortedMap via its subMap() method:,"(""SortedMap"", ""The SortedMap class has a subMap method, indicating a relationship between the two entities."", ""subMap"")"
The Java Collections API only has one implementation of the Java SortedSet interface - the java.util.TreeSet class.,"(""Java Collections API"", ""The Java Collections API has an interface called Java SortedSet"", ""Java SortedSet""); (""Java SortedSet"", ""The Java SortedSet interface has an implementation called java.util.TreeSet"", ""java.util.TreeSet"")"
"Additionally, the Vector class uses several older (no longer recommended) parts of Java, like the Enumeration which is superseded by the Iterator interface.","(""Vector"", ""The Vector class uses the Enumeration, indicating a relationship between the two entities."", ""Enumeration""); (""Vector"", ""The Vector class is related to the Iterator interface because the Enumeration used by Vector is superseded by the Iterator interface."", ""Iterator""); (""Vector"", ""The Vector class is part of the Java package, indicating a relationship between the two entities."", ""Java""); (""Enumeration"", ""The Enumeration is part of the Java package, indicating a relationship between the two entities."", ""Java"")"
You push elements onto a Java Stack using its push() method.,
Here is an example of obtaining the size of a Java Stack via its size() method:,"(""Stack"", ""The size() method is a part of the Stack class, indicating a relationship between the two as the method is used to obtain the size of the Stack."", ""size()""); (""Java"", ""The Stack class is part of the Java package, indicating a relationship between the two as the Stack class is a component of the Java package."", ""Stack"")"
The lockWrite() method of a ReadWriteLock class shown below is an example of a test-and-set method.,
The BoundedSemaphore class shown below has two test-and-set methods: take() and release().,"(""BoundedSemaphore"", ""The BoundedSemaphore class has the take() method, indicating a relationship between the class and the method."", ""take()"")"
Here is an example showing how to implement the lock() method shown earlier using the AtomicBoolean class:,
"a stop() or pause() method too), then you can no longer create your Runnable implementation with a Java lambda expression.","(""Stop"", ""The Stop method is related to the Runnable class because it is mentioned in the context of creating a Runnable implementation."", ""Runnable""); (""Pause"", ""The Pause method is related to the Runnable class because it is mentioned in the context of creating a Runnable implementation."", ""Runnable""); (""Java"", ""The Java package is related to the Runnable class because the Runnable class is part of the Java package."", ""Runnable""); (""Java"", ""The Java package is related to the Stop method because the Stop method is used in a Java lambda expression."", ""Stop"")"
"If a thread (1) calls the parent.addChild(child) method at the same time as another thread (2) calls the child.setParent(parent) method, on the same parent and child instances, a deadlock can occur.","(""Thread"", ""Thread is related to Addchild because it calls the method"", ""Addchild""); (""Thread"", ""Thread is related to Setparent because it calls the method"", ""Setparent""); (""Parent"", ""Parent is related to Addchild because it has the method"", ""Addchild""); (""Child"", ""Child is related to Setparent because it has the method"", ""Setparent""); (""Parent"", ""Parent is related to Child because a parent can have a child"", ""Child"")"
"Here are the two classes used in the example above, Counter and CounterThread.",
"The easiest way to create a subclass of ThreadLocal is to simply create an anonymous subclass, right where you create the ThreadLocal variable.","(""ThreadLocal"", ""ThreadLocal is a subclass of Thread, indicating a clear inheritance relationship between the two classes"", ""Thread"")"
"Here is an example of creating a ThreadLocal using its withInitial() static factory method, passing a simple Supplier implementation as parameter:","(""ThreadLocal"", ""ThreadLocal has a method called withInitial, which is used to create a new instance of ThreadLocal"", ""withInitial"")"
Notice how the format() method calls the getThreadLocalSimpleDateFormat() method to obtain a Java SimpleDatFormat instance.,"(""Format"", ""The Format method calls the GetThreadLocalSimpleDateFormat method to obtain a Java SimpleDateFormat instance."", ""GetThreadLocalSimpleDateFormat""); (""GetThreadLocalSimpleDateFormat"", ""The GetThreadLocalSimpleDateFormat method returns a Java SimpleDateFormat instance."", ""SimpleDateFormat"")"
"The Counter class could have been written like this instead, using a Lock instead of a synchronized block:",
"While isLocked is true, the thread calling lock() is parked waiting in the wait() call.","(""LOCK"", ""The lock method is related to the isLocked method because the isLocked method determines whether the lock method can proceed."", ""ISLOCKED""); (""THREAD"", ""The thread class is related to the lock method because the thread calls the lock method."", ""LOCK""); (""THREAD"", ""The thread class is related to the wait method because the thread waits in the wait call."", ""WAIT"")"
"When the thread is done with the code in the critical section (the code between lock() and unlock()), the thread calls unlock().","(""Thread"", ""The thread uses the lock to access the critical section, indicating a relationship between the Thread and Lock entities."", ""Lock""); (""Thread"", ""The thread calls unlock when it is done with the critical section, indicating a relationship between the Thread and Unlock entities."", ""Unlock"")"
"Otherwise, a single call to unlock() will unlock the lock, even if the lock has been locked multiple times.",
"That you would not call wait() and notify() on an internal monitor object, but rather on the This is probably true.","(""WAIT"", ""Both WAIT and NOTIFY are methods that are called on an object, indicating a relationship between them as they are used in similar contexts."")
{completion_delimiter}

The final answer is:
(""entity"",""WAIT"",""method"", ""NOTIFY"")"
This is how such exclusive access could look using a synchronized block in Java: public class SynchronizedCounter { long count = 0; public void inc() { synchronized(this) { count++; } } public long count() { synchronized(this) { return this.count; } } } Notice how the inc() and count() methods both contain a synchronized block.,"(""SynchronizedCounter"", ""The inc method is a part of the SynchronizedCounter class, indicating a clear relationship between the two entities."", ""inc""); (""SynchronizedCounter"", ""The count method is a part of the SynchronizedCounter class, indicating a clear relationship between the two entities."", ""count"")"
"import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicStampedReference; public class NonblockingTemplate { public static class IntendedModification { public AtomicBoolean completed = new AtomicBoolean(false); } private AtomicStampedReference<IntendedModification> ongoingMod = new AtomicStampedReference<IntendedModification>(null, 0); //declare the state of the data structure here.","(""NonblockingTemplate"", ""NonblockingTemplate contains IntendedModification as an inner class"", ""IntendedModification""); (""NonblockingTemplate"", ""NonblockingTemplate uses AtomicStampedReference as a data member"", ""AtomicStampedReference""); (""NonblockingTemplate"", ""NonblockingTemplate uses AtomicBoolean as a data member through its inner class IntendedModification"", ""AtomicBoolean""); (""IntendedModification"", ""IntendedModification contains AtomicBoolean as a data member"", ""AtomicBoolean"")"
Here is how the lockRead() and unlockRead() methods looks after that change:,
Here is how the lockWrite() and unlockWrite() methods look after that change:,
"You can read more about it in the java.util.concurrent.Semaphore text, in my java.util.concurrent tutorial.","(""Java.Util.Concurrent.Semaphore"", ""Java.Util.Concurrent.Semaphore is a part of the Java.Util.Concurrent package, as indicated by its fully qualified name."", ""Java.Util.Concurrent""); (""Java.Util.Concurrent.Tutorial"", ""The Java.Util.Concurrent.Tutorial is related to the Java.Util.Concurrent package, as it is mentioned as a tutorial for the package."", ""Java.Util.Concurrent"")"
The take() method sends a signal which is stored internally in the Semaphore.,
"That way the signal is not missed, even if doNotify() is called before doWait().",
"If you look at the Synchronizer class above and look into this Lock implementation you will notice that threads are now blocked trying to access the lock() method, if more than one thread calls lock() simultanously.","(""Synchronizer"", ""The Synchronizer class is related to the Lock class because it uses the Lock implementation."", ""Lock""); (""Lock"", ""The Lock class is related to the lock() method because the lock() method is part of the Lock implementation."", ""lock()"")"
"The thread calling unlock() will take the top QueueObject in the queue and call doNotify() on it, to awaken the thread waiting on that object.","(""unlock()"", ""The thread calling unlock() will take the top QueueObject in the queue, indicating a relationship between the unlock() method and the QueueObject class."", ""QueueObject""); (""doNotify()"", ""The doNotify() method is called on the QueueObject, indicating a relationship between the doNotify() method and the QueueObject class."", ""QueueObject"")"
"The queueObject.doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout, so another thread can actually call unlock() when no thread is executing inside the synchronized(this) block in lock() method.","(""QueueObject"", ""The QueueObject is related to the DoWait method because it is the object on which the doWait() call is made."", ""DoWait""); (""QueueObject"", ""The QueueObject is related to the Lock method because it is the object being locked in the synchronized(this) block."", ""Lock""); (""QueueObject"", ""The QueueObject is related to the Unlock method because it is the object that can be unlocked when no thread is executing inside the synchronized(this) block."", ""Unlock""); (""DoWait"", ""The DoWait method is related to the Lock method because the doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout, which is related to the lock() method."", ""Lock"")"
"Below here is the PoolThreadRunnable class which implements the Runnable interface, so it can be executed by a Java thread:","(""PoolThreadRunnable"", ""PoolThreadRunnable implements the Runnable interface, indicating a clear relationship between the two entities as one is implementing the other"", ""Runnable""); (""PoolThreadRunnable"", ""PoolThreadRunnable is executed by a Java thread, indicating a relationship between the PoolThreadRunnable class and the Java package as the class is being used within the context of Java"", ""Java"")"
"Notice how the add() method returns a new ImmutableValue instance with the result of the add operation, rather than adding the value to itself.",
"The class java.lang.Object defines three methods, wait(), notify(), and notifyAll(), to facilitate this.","(""Java.Lang.Object"", ""Java.Lang.Object defines the Wait() method to facilitate synchronization"", ""Wait()""); (""Java.Lang.Object"", ""Java.Lang.Object defines the Notify() method to facilitate synchronization"", ""Notify()"")"
"In other words, the calling thread must call wait() or notify() from inside a synchronized block.","(""Thread"", ""The Thread class is related to the Wait method because the calling thread must call wait() from inside a synchronized block."", ""Wait""); (""Thread"", ""The Thread class is related to the Notify method because the calling thread must call notify() from inside a synchronized block."", ""Notify""); (""Thread"", ""The Thread class is related to the Synchronized block because the calling thread must be inside a synchronized block to call wait() or notify()."", ""Synchronized""); (""Wait"", ""The Wait method is related to the Synchronized block because wait() must be called from inside a synchronized block."", ""Synchronized"")"
The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called.,
"If the doNotify() method had called notifyAll() instead of notify(), all waiting threads had been awakened and checked for signals in turn.","(""DoNotify"", ""The doNotify method is related to notify because it had called notify instead of notifyAll, indicating a possible alternative or replacement relationship"", ""Notify""); (""DoNotify"", ""The doNotify method is related to notifyAll because it is mentioned as an alternative that doNotify could have called, indicating a possible replacement or comparison relationship"", ""Notifyall"")"
"The other of C and D would go back to waiting, because the thread discovering the signal clears it on the way out of doWait().","(""C"", ""C is related to doWait() because it is mentioned as being affected by the thread discovering the signal that is cleared on the way out of doWait()"" "", ""doWait()"")"
"The method compareAndSet() allows you to compare the current value of the AtomicBoolean to an expected value, and if current value is equal to the expected value, a new value can be set on the AtomicBoolean.",
"The AtomicInteger class provides you with a int variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().","(""AtomicInteger"", ""The AtomicInteger class provides a int variable, indicating a relationship between the AtomicInteger class and the int variable."", ""int"")"
You can get the value of an AtomicInteger instance via the get() method.,
Calling addAndGet() is also an atomic operation (like all operations on the AtomicIntegerArray).,
You should check out the JavaDoc for the AtomicIntegerArray class to learn more about those methods.,
"The AtomicLong class provides you with a long variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().",
You can set the value of an AtomicLong instance via the set() method.,
The Java AtomicLongArray class (java.util.concurrent.atomic.AtomicLongArray) represents an array of long .,
You can get the value of a given element using the get() method on the AtomicLongArray.,
You can set the value of a given element using the set() method on the AtomicLongArray.,
"AtomicReference even has an advanced compareAndSet() method which lets you compare the reference to an expected value (reference) and if they are equal, set a new reference inside the AtomicReference object.",
Notice how it is no longer necessary to cast the referenced returned by get() because the compiler knows it will return a String reference.,
"The compareAndSet() method can compare the reference stored in the AtomicReference instance with an expected reference, and if they two references are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicReference instance.","(""CompareAndSet"", ""The compareAndSet() method can compare the reference stored in the AtomicReference instance"", ""AtomicReference"")"
If you have a typed AtomicStampedReference then getReference() returns a reference to the type you declared on the AtomicStampedReference variable when you created it.,"(""AtomicStampedReference"", ""The getReference method is related to the AtomicStampedReference class because it is used to retrieve a reference from the AtomicStampedReference variable."", ""getReference""); (""AtomicStampedReference variable"", ""The AtomicStampedReference variable is related to the AtomicStampedReference class because it is an instance of the class."", ""AtomicStampedReference"")"
The AtomicStampedReference also contains a getStamp() method which can be used to obtain the internally stored stamp.,
"The compareAndSet() method can compare the reference stored in the AtomicStampedReference instance with an expected reference, and the stored stamp with an expected stamp, and if they two references and stamps are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicStampedReference instance.","(""CompareAndSet"", ""The compareAndSet method is used in conjunction with the AtomicStampedReference instance to compare and set references."", ""AtomicStampedReference""); (""CompareAndSet"", ""The compareAndSet method uses the equals method for comparison, but it checks for reference equality (==) instead of object equality."", ""Equals"")"
"The BlockingDeque interface in the java.util.concurrent class represents a deque which is thread safe to put into, and take instances from.",
"The ConcurrentMap has a few extra atomic methods in addition to the methods it inherits from its superinterface, java.util.Map.","(""ConcurrentMap"", ""ConcurrentMap inherits methods from java.util.Map, indicating a subclass relationship"", ""java.util.Map""); (""ConcurrentMap"", ""ConcurrentMap has atomic methods, indicating a composition relationship where ConcurrentMap contains or provides atomic methods"", ""atomic methods"")"
"The java.util.concurrent.ConcurrentNavigableMap class is a java.util.NavigableMap with support for concurrent access, and which has concurrent access enabled for its submaps.","(""ConcurrentNavigableMap"", ""ConcurrentNavigableMap is a type of NavigableMap, indicating an inheritance relationship between the two classes"", ""NavigableMap""); (""ConcurrentNavigableMap"", ""ConcurrentNavigableMap is part of the java.util.concurrent package, indicating a containment relationship between the package and the class"", ""java.util.concurrent"")"
"First, the BlockingQueueExample class which starts a Producer and a Consumer in separate threads.","(""BlockingQueueExample"", ""The BlockingQueueExample class starts a Producer in a separate thread, indicating a relationship between the two."", ""Producer""); (""BlockingQueueExample"", ""The BlockingQueueExample class starts a Consumer in a separate thread, indicating a relationship between the two."", ""Consumer"")"
The Java BlockingQueue add() method will add the element passed as parameter to this method if the BlockingQueue has space for it internally.,"(""BlockingQueue"", ""The BlockingQueue class has an add() method, indicating a relationship between the two entities as the method is a part of the class."", ""add()""); (""Java"", ""The Java package contains the BlockingQueue class, indicating a relationship between the two entities as the class is part of the package."", ""BlockingQueue"")"
"If the BlockingQueue does not have space internally for this new element, the add() method throws an IllegalStateException.","(""BlockingQueue"", ""The BlockingQueue class contains the add() method, which suggests a relationship between the two entities as the method is a part of the class's functionality."", ""add()""); (""add()"", ""The add() method is related to the IllegalStateException because the method throws this exception when the BlockingQueue does not have space internally for a new element, indicating a cause-and-effect relationship between the method's execution and the exception being thrown."", ""IllegalStateException"")"
The remove() method will use the o.equals(element) to decide if the object o passed as parameter matches a given element in the BlockingQueue.,"(""Remove"", ""The remove() method will use the o.equals(element) to decide if the object o passed as parameter matches a given element, indicating a relationship between the remove() method and the equals() method."", ""Equals""); (""Remove"", ""The remove() method is used in the context of the BlockingQueue, indicating a relationship between the remove() method and the BlockingQueue class."", ""Blockingqueue""); (""Equals"", ""The equals() method is called on the object o, indicating a relationship between the equals() method and the object o."", ""O"")"
"If the BlockingQueue does not contain any elements, the element() method will throw a NoSuchElementException.","(""BlockingQueue"", ""The BlockingQueue class contains the element method, indicating a relationship between the two entities."", ""element""); (""element"", ""The element method is related to the NoSuchElementException because it throws this exception when the BlockingQueue is empty, indicating a causal relationship between the method and the exception."", ""NoSuchElementException"")"
The result of that is that the call() method will return a String.,
"The Java ExecutorService interface, java.util.concurrent.ExecutorService, represents an asynchronous execution mechanism which is capable of executing tasks concurrently in the background.",
"The Java ExecutorService execute(Runnable) method takes a java.lang.Runnable object, and executes it asynchronously.","(""ExecutorService"", ""The ExecutorService class contains the execute method."", ""execute""); (""execute"", ""The execute method takes a Runnable object as a parameter."", ""Runnable""); (""ExecutorService"", ""The ExecutorService class uses a Runnable object in its execute method."", ""Runnable""); (""java.lang"", ""The Runnable class is part of the java.lang package."", ""Runnable"")"
"The invokeAny() method takes a collection of Callable objects, or subinterfaces of Callable.",
The invokeAll() method invokes all of the Callable objects you pass to it in the collection passed as parameter.,
The main difference between the Runnable run() method and the Callable call() method is that the call() method can return an Object from the method call.,"(""Runnable"", ""The Runnable class has a run() method"", ""run()""); (""Callable"", ""The Callable class has a call() method"", ""call()"")"
"The ExecutorService awaitTermination() method will block the thread calling it until either the ExecutorService has shutdown completely, or until a given time out occurs.",
The awaitTermination() method is typically called after calling shutdown() or shutdownNow().,"(""AwaitTermination"", ""The awaitTermination() method is typically called after calling shutdown() or shutdownNow(), indicating a sequence of operations where shutdown() precedes awaitTermination()."", ""Shutdown"")"
In the following sections I will explain how to use the ReentrantLock class as a Lock.,
To unlock the Lock instance you must call its unlock() method.,
"To better understand how using a Lock looks different from using a synchronized block, I have created two simple concurrent Counter classes which protects their internal count in different ways.","(""Lock"", ""The Lock class is related to the Counter class because the Counter class uses a Lock to protect its internal count."", ""Counter"")"
"Notice how the calculate() method both locks the Calculator instance's Lock before performing any calculations, and also call the add() and subtract() methods which also locks the lock.","(""Calculator"", ""The Calculator instance has a Lock, indicating a composition relationship between the two classes."", ""Lock""); (""calculate()"", ""The calculate() method locks the Lock, indicating that the method uses or interacts with the Lock."", ""Lock""); (""calculate()"", ""The calculate() method calls the add() method, indicating a method invocation relationship between the two methods."", ""add()""); (""calculate()"", ""The calculate() method calls the subtract() method, indicating a method invocation relationship between the two methods."", ""subtract()""); (""add()"", ""The add() method locks the Lock, indicating that the method uses or interacts with the Lock."", ""Lock"")"
"If the Lock instance is already locked, the thread calling lock() is blocked until the Lock is unlocked.","(""Lock"", ""The Lock class has a method called lock(), indicating a relationship between the Lock class and the lock() method."", ""lock()""); (""thread"", ""The thread is blocked until the Lock is unlocked, indicating a relationship between the thread and the Lock class."", ""Lock"")"
The Java ReentrantLock getHoldCount() method returns the number of times a given thread has locked this Lock instance.,"(""ReentrantLock"", ""The getHoldCount() method is a part of the ReentrantLock class, indicating a relationship between the two."", ""getHoldCount()""); (""ReentrantLock"", ""ReentrantLock is a type of Lock, indicating an inheritance relationship between the two."", ""Lock""); (""ReentrantLock"", ""The ReentrantLock class is part of the Java package, indicating a containment relationship between the two."", ""Java""); (""getHoldCount()"", ""The getHoldCount() method is part of the Java package, indicating a containment relationship between the two."", ""Java"")"
"The Java CertPath class (java.security.cert.CertPath represents a chain of cryptographic identity certificates (Java Certificate objects), where each certificate is the digital signer of the next certificate in the chain.","(""CertPath"", ""The CertPath class represents a chain of Java Certificate objects, indicating a relationship between the two classes."", ""Java Certificate""); (""java.security.cert.CertPath"", ""The java.security.cert.CertPath class represents a chain of Java Certificate objects, indicating a relationship between the two classes."", ""Java Certificate"")"
The CertPath getType() method returns a string telling what type of certificates (e.g.,
If you want to set a different offset for the dest byte array there is a version of update() and doFinal() which takes an offset parameter extra.,
Notice the call to update() and then doFinal() for these two blocks of data.,
To generate an asymmetric key pair you can use the KeyPairGenerator (java.security.KeyPairGenerator).,
You create a KeyGenerator instance by calling the static method getInstance() passing as parameter the name of the encryption algorithm to create a key for.,"(""KeyGenerator"", ""KeyGenerator is related to getInstance because getInstance is a method used to create a KeyGenerator instance"", ""getInstance""); (""getInstance"", ""getInstance is related to encryption algorithm because the encryption algorithm is passed as a parameter to getInstance"", ""encryption algorithm"")"
Initializing a KeyGenerator instance is done by calling its init() method.,
Generating a key is done by calling the KeyGenerator generateKey() method.,
You can access the PublicKey of a KeyPair by calling its getPublic() method.,"(""KeyPair"", ""A KeyPair has a PublicKey that can be accessed through it."", ""PublicKey""); (""KeyPair"", ""The getPublic method is called on a KeyPair to access its PublicKey."", ""getPublic"")"
You can access the PrivateKey of a KeyPair by calling the getPrivate() method.,"(""KeyPair"", ""A KeyPair has a PrivateKey that can be accessed by calling the getPrivate method."", ""PrivateKey""); (""KeyPair"", ""The getPrivate method is called on a KeyPair to access its PrivateKey."", ""getPrivate()"")"
You can create a Java KeyStore instance by calling its getInstance() method.,
This Keytool -delete command will remove the KeyStore entry with the alias testkey from the KeyStore stored in the file keystore.jks .,"(""Keytool"", ""The Keytool class is related to the KeyStore class because the Keytool command is used to manage the KeyStore entries."", ""KeyStore""); (""Keytool"", ""The Keytool class is related to the -delete method because the -delete command is a method of the Keytool class used to remove KeyStore entries."", ""-delete""); (""KeyStore"", ""The KeyStore class is related to the keystore.jks package because the KeyStore is stored in the keystore.jks file."", ""keystore.jks"")"
"You create a digital signature by calling the update() method one or more times, finishing with a call to sign().",
"If you need to read and write the date and time to a database, use the java.sql.Date and java.sql.Timestamp classes.","(""Java.Sql.Date"", ""Both are used for reading and writing date and time to a database, indicating a relationship in their usage and functionality."", ""Java.Sql.Timestamp""); (""Java.Sql"", ""Java.Sql is the package that contains the Java.Sql.Date class, indicating a containment relationship."", ""Java.Sql.Date"")"
Here is an example of how to create a Duration object using the between() method:,
Here is an example that shows how to create a LocalDateTime object via the now() method:,
The LocalTime class in the Java 8 date time API represents a specific time of day without any time zone information.,
The parameter passed to the of() method is the ID of the time zone to create a ZoneId for.,"(""Of"", ""The Of method is used to create a ZoneId, indicating a relationship between the Of method and the ZoneId class."", ""ZoneId""); (""Id"", ""The Id is passed as a parameter to create a ZoneId, indicating a relationship between the Id and the ZoneId class."", ""ZoneId"")"
"If you need to set a date on a java.sql.PreparedStatement or get a date from a java.sql.ResultSet, you will interact with java.sql.Date.","(""Java.Sql.PreparedStatement"", ""Java.Sql.PreparedStatement is related to Java.Sql.Date because you can set a date on a Java.Sql.PreparedStatement"", ""Java.Sql.Date""); (""Java.Sql.ResultSet"", ""Java.Sql.ResultSet is related to Java.Sql.Date because you can get a date from a Java.Sql.ResultSet"", ""Java.Sql.Date"")"
One difference in the java.sql.Timestamp from its superclass java.util.Date is its ability to hold the nanoseconds of a date too.,
You can get and set the nanoseconds using the getNanos() and setNanos().,
The Calendar class has a corresponding set() method so you can set these fields too.,
"You can access the date and time contained in a java.util.Date instance using the getTime() method, like this:",
You can compare java.util.Date instance because the class implements the java.lang.Comparable interface.,
The java.util.TimeZone class is used in conjunction with the java.util.Calendar class.,
As you can see the readNumberFromUrl() needs to declare throwing both the BadUrlException and the BadNumberException that are thrown from the readDataFromUrl() and converData() methods.,"(""ReadNumberFromUrl"", ""The ReadNumberFromUrl method declares throwing the BadUrlException, indicating a relationship between the two entities."", ""BadUrlException""); (""ReadNumberFromUrl"", ""The ReadNumberFromUrl method declares throwing the BadNumberException, indicating a relationship between the two entities."", ""BadNumberException""); (""ReadDataFromUrl"", ""The BadUrlException is thrown from the ReadDataFromUrl method, indicating a relationship between the two entities."", ""BadUrlException""); (""ConverData"", ""The BadNumberException is thrown from the ConverData method, indicating a relationship between the two entities."", ""BadNumberException""); (""ReadNumberFromUrl"", ""The ReadNumberFromUrl method is related to the ReadDataFromUrl method as it needs to declare throwing exceptions thrown by ReadDataFromUrl."", ""ReadDataFromUrl"")"
As you can see the readNumberFromUrl() method now only declares throwing ApplicationException.,
"In the example with FileNotFoundException, if you catch IOException which is the superclass of FileNotFoundException, you will also catch FileNotFoundException.",
"If the input.close() call fails, and an IOException is thrown, then it is caught, wrapped and rethrown.","(""Input"", ""The Input class has a method called Close, indicating a relationship between the two."", ""Close""); (""Close"", ""The Close method can throw an IOException, indicating a relationship between the two."", ""IOException"")"
The Throwable class has a method named addSuppressed() which takes a Throwable object as parameter.,"(""Throwable"", ""The Throwable class has a method named addSuppressed(), indicating a relationship between the Throwable class and the addSuppressed() method."", ""addSuppressed()"")"
The applyPattern() method simply applies a new pattern to the DecimalFormat instance as if it were created with that pattern.,
The applyLocalizedPattern() does the same as applyPattern() except it interpretes the characters in the pattern according to the Locale the DecimalFormat was created with.,"(""Applylocalizedpattern"", ""Applylocalizedpattern and Applypattern are related as they share similar functionality, with the key difference being Applylocalizedpattern interprets characters according to the Locale"", ""Applypattern""); (""Applylocalizedpattern"", ""Applylocalizedpattern is a method that is used in conjunction with the DecimalFormat class, as it is used to format numbers according to the Locale the DecimalFormat was created with"", ""Decimalformat"")"
"To sort a collection of strings according to the rules of a certain Locale, you use a java.text.Collator instance created for that specific Locale.","(""Collator"", ""A Collator instance is created for a specific Locale, indicating a relationship between the two."", ""Locale""); (""Java"", ""The Collator class is part of the java.text package, which is a part of the Java package, indicating a relationship between the two."", ""Collator"")"
The factory method Locale.forLanguageTag() can also be used to create a Locale instance.,"(""Locale"", ""Locale.forLanguageTag() is a method of the Locale class"", ""Locale.forLanguageTag()"")"
Finally you can access the localized values in the ResourceBundle via its different getString() and getObject() etc.,"(""ResourceBundle"", ""The ResourceBundle class has a method called getString(), indicating a clear relationship between the two."", ""getString()"")"
For this example to work you should put a standard Java property file named MyBundle.properties in a Java package named i18n.,
Once you have created a SimpleDateFormat instance you can format dates using its format() method.,
The Date instance passed to the format() method is a java.util.Date instance.,"(""Date"", ""The Date class is related to the format() method because the Date instance is passed to the format() method."", ""format()"")"
"The Java SimpleDateFormat class is also capable of formatting a Date object into a StringBuffer, instead of returning an individual String with the date formatted.","(""SimpleDateFormat"", ""The SimpleDateFormat class is capable of formatting a Date object"", ""Date""); (""SimpleDateFormat"", ""The SimpleDateFormat class is capable of formatting a Date object into a String"", ""String""); (""SimpleDateFormat"", ""The SimpleDateFormat class is capable of formatting a Date object into a StringBuffer"", ""StringBuffer""); (""Date"", ""A Date object can be formatted into a String"", ""String"")"
You can parse a String into a java.util.Date instance using the parse() method of the SimpleDateFormat instance.,"(""String"", ""The String is parsed into a Date using the SimpleDateFormat, indicating a relationship between the two."", ""SimpleDateFormat""); (""SimpleDateFormat"", ""The parse() method is a part of the SimpleDateFormat class, indicating a relationship between the method and the class."", ""parse()""); (""String"", ""The String is parsed into a java.util.Date, indicating a relationship between the two."", ""java.util.Date""); (""SimpleDateFormat"", ""The SimpleDateFormat is part of the java.util package, indicating a relationship between the class and the package."", ""java.util""); (""java.util.Date"", ""The java.util.Date is part of the java.util package, indicating a relationship between the class and the package."", ""java.util""); (""parse()"", ""The parse() method takes a String as input, indicating a relationship between the method and the class."", ""String"")"
You can set the time zone of a SimpleDateFormat using its setTimeZone() method.,
"In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not, but the BufferedInputStream supports them.","(""MarkSupported"", ""The MarkSupported method is related to BufferedInputStream because it can be used to check if mark() and reset() are supported on a given BufferedInputStream."", ""BufferedInputStream""); (""Mark"", ""The Mark method is related to BufferedInputStream because it is supported by BufferedInputStream."", ""BufferedInputStream""); (""Reset"", ""The Reset method is related to BufferedInputStream because it is supported by BufferedInputStream."", ""BufferedInputStream""); (""Mark"", ""The Mark method is related to InputStream because it can be called on an InputStream."", ""InputStream""); (""Reset"", ""The Reset method is related to InputStream because it can be called on an InputStream."", ""InputStream""); (""MarkSupported"", ""The MarkSupported method is related to InputStream because it can be used to check if mark() and reset() are supported on a given InputStream."", ""InputStream"")"
"After that, the while loop exits, and the BufferedInputStream close() method is called.",
"The setSource() method actually returns a reference to the ReusableBufferedInputStream, so you can actually create a ReusableBufferedInputStream and set the source in a single instruction:",
To write data to a Java BufferedOutputStream you can use its write() method.,
If you want to make sure that all written data is written to disk without having to close the BufferedOutputStream you can call its flush() method.,
"Once the try block is exited, the close() method of the BufferedOutputStream is called automatically, because the BufferedOutputStream was declared inside the parentheses of the try block.","(""BufferedOutputStream"", ""The close() method is a part of the BufferedOutputStream class, indicating a relationship between the two."", ""close()""); (""try"", ""The BufferedOutputStream was declared inside the parentheses of the try block, indicating a relationship between the try block and the BufferedOutputStream."", ""BufferedOutputStream"")"
"The Java BufferedReader class is a subclass of the Java Reader class, so you can use a BufferedReader anywhere a Reader is required.","(""BufferedReader"", ""BufferedReader is a subclass of Reader, indicating an inheritance relationship between the two classes"", ""Reader"")"
"The Java BufferedReader class also has a read() method that takes a char array as parameter, as well as a start offset and length.",
The Java BufferedReader has a special read method named readLine() which reads a full line of text from the BufferedReader's internal buffer.,"(""BufferedReader"", ""The BufferedReader class has a special read method named readLine(), indicating a clear relationship between the two entities as the method is a part of the class."", ""readLine()"")"
The Java BufferedWriter's flush() method flushes all data written to the BufferedWriter to the underlying data destination.,"(""BufferedWriter"", ""The flush() method is a part of the BufferedWriter class, indicating a clear relationship between the two entities as the method is used to perform an operation on the BufferedWriter."", ""flush()""); (""BufferedWriter"", ""The BufferedWriter is related to the data destination as it writes data to the underlying data destination, indicating a clear relationship between the two entities as the BufferedWriter performs an operation on the data destination."", ""data destination"")"
The mark() method of the ByteArrayInputStream class sets an internal mark at the current byte position - meaning right after the previous byte read.,"(""ByteArrayInputStream"", ""The mark() method is a part of the ByteArrayInputStream class, indicating a relationship between the two entities as the method belongs to the class."", ""mark()"")"
"Since the Java ByteArrayOutputStream class is a subclass of the Java OutputStream class, you write bytes to it using the same write methods that OutputStream has:","(""ByteArrayOutputStream"", ""ByteArrayOutputStream is a subclass of OutputStream, indicating a inheritance relationship between the two classes"", ""OutputStream""); (""ByteArrayOutputStream"", ""ByteArrayOutputStream uses the write method, indicating a usage relationship between the class and the method"", ""write"")"
"Once you have finished writing to the ByteArrayOutputStream you can obtain all the bytes written as a Java byte array, using the ByteArrayOutputStream toByteArray() method.",
You can read a Java float from the DataInputStream using its readFloat() method.,
You can read a Java unsigned short (only positive values) from the DataInputStream using its readUnsignedShort() method.,
You can read a Java long from the DataInputStream using its readLong() method.,
"To rename (or move) a file, call the method renameTo() on the File class.",
You can obtain a list of all the files in a directory by calling either the Java File list() method or the listFiles() method.,"(""File"", ""The File class has a method called list() to obtain a list of all the files in a directory"", ""list()""); (""File"", ""The File class has a method called listFiles() to obtain a list of all the files in a directory"", ""listFiles()"")"
Here is an example of listing all files in a directory via the Java File list() and listFiles() methods:,"(""File"", ""The File class contains the list() method, indicating a relationship between the two."", ""list()""); (""File"", ""The File class contains the listFiles() method, indicating a relationship between the two."", ""listFiles()"")"
To write data to a Java FileOutputStream you can use its write() method.,
Here is an example of writing data to a Java FileOutputStream using its write() method:,"(""FileOutputStream"", ""The write() method is a part of the FileOutputStream class, indicating a relationship between the two entities."", ""write()""); (""Java"", ""FileOutputStream is a class in the Java package, indicating a relationship between the two entities."", ""FileOutputStream"")"
Here is an example of closing a Java FileOutputStream by calling its close() method:,"(""FileOutputStream"", ""The close() method is a part of the FileOutputStream class, indicating a relationship between the two."", ""close()""); (""Java"", ""The FileOutputStream class is part of the Java package, indicating a relationship between the two."", ""FileOutputStream"")"
You can convert a FileOutputStream to a character based Writer using the Java OutputStreamWriter class.,"(""FileOutputStream"", ""FileOutputStream can be converted to a character based Writer using the Java OutputStreamWriter class, indicating a conversion relationship between the two."", ""OutputStreamWriter"")"
The Java FileWriter's flush() method flushes all data written to the FileWriter to the underlying file.,
Here is an example of flushing data written to a Java FileWriter by calling its flush() method:,
Notice how there is no longer any explicit close() method call to the FileWriter instance.,
The Java InputStream class contains a method called readAllBytes() (since Java 9).,"(""InputStream"", ""The InputStream class contains the readAllBytes() method, indicating a clear relationship between the two entities."", ""readAllBytes()""); (""Java"", ""The Java package is related to the InputStream class, as InputStream is part of the Java library."", ""InputStream"")"
Here is an example of reading all bytes from a Java InputStream via readAllBytes():,
"If an InputStream subclass supports the mark() and reset() methods, then that subclass should override the markSupported() to return true.","(""InputStream"", ""InputStream is related to mark() because mark() is a method that can be supported by InputStream subclasses"", ""mark()""); (""InputStream"", ""InputStream is related to reset() because reset() is a method that can be supported by InputStream subclasses"", ""reset()""); (""InputStream"", ""InputStream is related to markSupported() because markSupported() is a method that should be overridden by InputStream subclasses to return true if they support mark() and reset()"", ""markSupported()""); (""mark()"", ""mark() is related to markSupported() because markSupported() indicates whether mark() is supported"", ""markSupported()""); (""reset()"", ""reset() is related to markSupported() because markSupported() indicates whether reset() is supported"", ""markSupported()"")"
The read() method of an InputStreamReader returns an int which contains the char value of the char read.,
Notice how there is no longer any explicit close() method call to the CharArrayWriter instance.,
"Like with FilterInputStream, I see no sensible purpose for this class.",
They make it somewhat easier to understand what the classes are targeting.,
The read() method of a Java PipedReader returns an int which contains the char value of the character read.,"(""PipedReader"", ""The read() method is a part of the PipedReader class, indicating a clear relationship between the two."", ""read()""); (""Java"", ""PipedReader is a class in the Java package, indicating a clear relationship between the two."", ""PipedReader"")"
"Third, the example calls the advanced printf() method of the PrintWriter which can insert formatted numbers into a text string.",
Closing a Java StringReader can be done using the close() method like this:,
The Java OutputStream's flush() method flushes all data written to the OutputStream to the underlying data destination.,
The Java OutputStreamWriter's flush() method flushes all data written to the OutputStreamWriter to the underlying data destination.,"(""OutputStreamWriter"", ""The flush() method is a part of the OutputStreamWriter class, indicating a relationship between the two."", ""flush()""); (""java"", ""The OutputStreamWriter is part of the Java package, indicating a relationship between the two."", ""OutputStreamWriter"")"
"If you push back multiple bytes into the PushbackInputStream, the latest byte pushed back will be returned first from read(), just like on a stack.","(""PushbackInputStream"", ""The PushbackInputStream class has a read() method that returns the latest byte pushed back."", ""read()"")"
"You read bytes from the Java PushbackInputStream via its read() method, just like you do from a regular InputStream .","(""PushbackInputStream"", ""The PushbackInputStream class has a read() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""read()""); (""InputStream"", ""The InputStream class also has a read() method, indicating a relationship between the InputStream class and the read() method, as the method is part of this class."", ""read()"")"
"Remember, calling this write() method will advance the file position of the RandomAccessFile by 1.","(""RandomAccessFile"", ""The write() method is called on the RandomAccessFile class, indicating a relationship between the two entities."", ""write()"")"
The Java Reader class has a method named skip() which can be used to skip over a number of characters in the input that you do not want to read.,
You do so by calling the nextToken() method of the StreamTokenizer inside a loop.,"(""StreamTokenizer"", ""The nextToken() method is a part of the StreamTokenizer class, indicating a clear relationship between the two entities as the method is called on the class."", ""nextToken()"")"
"System.in, System.out and System.err are initialized by the Java runtime when a Java VM starts up, so you don't have to instantiate any streams yourself (although you can exchange them at runtime).","(""System.in"", ""System.in is initialized by the Java runtime when a Java VM starts up"", ""Java runtime""); (""System.out"", ""System.out is initialized by the Java runtime when a Java VM starts up"", ""Java runtime""); (""System.err"", ""System.err is initialized by the Java runtime when a Java VM starts up"", ""Java runtime""); (""Java VM"", ""The Java runtime is responsible for the Java VM startup"", ""Java runtime""); (""Java"", ""Java is the package that contains the Java VM"", ""Java VM"")"
You will normally use a Writer subclass rather than a Writer directly.,
The Java String parameter passed to the Class forName() method is the name of the JDBC driver class for the given JDBC driver.,"(""Java"", ""Java is related to String because Java is a programming language that uses the String class"", ""String""); (""Java"", ""Java is related to Class because Java is an object-oriented programming language that uses classes, including the Class class"", ""Class""); (""Java"", ""Java is related to JDBC because Java is a programming language that uses JDBC for database connectivity"", ""JDBC""); (""String"", ""String is related to Class because the String parameter is passed to the Class forName() method"", ""Class""); (""String"", ""String is related to JDBC because the String parameter represents the name of the JDBC driver class"", ""JDBC""); (""Class"", ""Class is related to JDBC because the Class forName() method is used to load the JDBC driver class"", ""JDBC""); (""forName()"", ""forName() is related to Class because forName() is a method of the Class class"", ""Class""); (""forName()"", ""forName() is related to JDBC because the forName() method is used to load the JDBC driver class"", ""JDBC"")"
"By the way, imagine that the used Person class looks like this:",
Here is an example of creating a JDBC DatabaseMetaData object via the JDBC Connection getMetaData() method:,"(""JDBC Connection"", ""The getMetaData() method is a part of the JDBC Connection class, indicating a relationship between the two."", ""getMetaData()""); (""JDBC Connection"", ""The JDBC DatabaseMetaData object is created via the JDBC Connection, indicating a relationship between the two."", ""JDBC DatabaseMetaData"")"
The ResultSet returned by the getColumns() method contains a list of columns for the given table.,"(""getColumns()"", ""The getColumns() method returns a ResultSet, indicating a clear relationship between the two entities."", ""ResultSet""); (""table"", ""The ResultSet contains a list of columns for the given table, indicating a relationship between the table and the ResultSet."", ""ResultSet"")"
Before the first next() call the ResultSet is positioned before the first row.,
"Once the row is ready to be inserted into the ResultSet, call the insertRow() method.",
"If you need to insert another row, explicitly call moveToInsertRow() to signal this to the ResultSet.",
The purpose of an abstract class is to function as a base for subclasses.,
"If a class has an abstract method, the whole class must be declared abstract.",
The example I showed you above with the URLProcessorBase class is actually an example of the Template Method design pattern.,
In the above example the subclass SmartClock has a method called getTimeInSeconds() which accesses the time variable of the superclass Clock.,"(""SmartClock"", ""SmartClock has a method called getTimeInSeconds(), indicating a relationship between the class and the method"", ""getTimeInSeconds()""); (""SmartClock"", ""SmartClock is a subclass of Clock, indicating a relationship between the two classes"", ""Clock"")"
The utility class is called Arrays and is located in the standard Java package java.util.,
The purpose of a constructor is to initialize the fields in the class.,"(""Constructor"", ""The constructor is related to the class because it is used to initialize the fields in the class."", ""Class""); (""Constructor"", ""The constructor is related to the fields because it is used to initialize them."", ""Fields"")"
Now the isValid() method returns the value returned by the value.equals() method call.,"(""IsValid"", ""The IsValid method is related to the Equals method because it returns the value returned by the Equals method call."", ""Equals""); (""Value"", ""The Value class is related to the Equals method because the Equals method is called on an instance of the Value class."", ""Equals"")"
In many cases it would have made sense to place the getLicensePlate() method in the Vehicle class where the licensePlate field is located.,"(""GetLicensePlate()"", ""The getLicensePlate() method is related to the Vehicle class because it would have made sense to place the method in the class where the licensePlate field is located."", ""Vehicle""); (""GetLicensePlate()"", ""The getLicensePlate() method is related to the LicensePlate field because the method is used to retrieve the license plate information."", ""LicensePlate"")"
"Here is the same instanceof example, but using a Truck object instead of a Car object: Truck truck = new Truck(); Vehicle vehicle = truck; boolean isCar = vehicle instanceof Car; After executing this code the isCar will contain the value false.","(""Truck"", ""Truck is a subclass of Vehicle, as indicated by the assignment of a Truck object to a Vehicle variable."", ""Vehicle""); (""Truck"", ""Truck and Car are related in that they are both being compared using the instanceof operator, implying a possible inheritance relationship between the two classes."", ""Car"")"
The updateLicensePlate() method sets the license plate value on the licensePlate field in the Car class.,"(""UpdateLicensePlate"", ""The UpdateLicensePlate method is related to the Car class because it sets a value on a field in the Car class."", ""Car""); (""UpdateLicensePlate"", ""The UpdateLicensePlate method is related to the LicensePlate field because it sets the value of this field."", ""LicensePlate"")"
"The getLicensePlate() method, however, returns the value of the licensePlate field in the Vehicle class.","(""GetLicensePlate()"", ""The GetLicensePlate() method is related to the Vehicle class because it is used to return the value of a field in the Vehicle class."", ""Vehicle""); (""GetLicensePlate()"", ""The GetLicensePlate() method is related to the LicensePlate field because it returns the value of this field."", ""LicensePlate"")"
"If you override a method in a subclass, and the method is all of a sudden removed or renamed or have its signature changed in the superclass, the method in the subclass no longer overrides the method in the superclass.","(""Subclass"", ""The subclass inherits from the superclass, and therefore any changes to the superclass can affect the subclass."", ""Superclass""); (""Method"", ""The method is overridden in the subclass, indicating a relationship between the method and the subclass."", ""Subclass"")"
Here is a Java instanceof example illustrating the comparison of null against a class:,"(""Java"", ""Java is related to instanceof because it is an operator used in the Java programming language"", ""instanceof""); (""Instanceof"", ""Instanceof is related to Java because it is an operator used in the Java programming language"", ""Java""); (""Null"", ""Null is related to Instanceof because the example illustrates the comparison of null against a class using the instanceof operator"", ""Instanceof""); (""Class"", ""Class is related to Instanceof because the example illustrates the comparison of null against a class using the instanceof operator"", ""Instanceof"")"
"That is because it is not the reference type that is compared against the target class or interface, but the actual type of the referenced object.","(""Reference"", ""The reference type is compared against the target class or interface, indicating a relationship between the two."", ""Target""); (""Reference"", ""The reference type is compared against the interface, indicating a relationship between the two."", ""Interface"")"
"A Java interface is a bit like a Java class, except a Java interface can only contain method signatures and fields.","(""Java Interface"", ""A Java interface is compared to a Java class, indicating a relationship between the two."", ""Java Class""); (""Java Interface"", ""A Java interface can only contain method signatures, indicating that method signatures are a part of a Java interface."", ""Method Signatures"")"
The class does not need to implement (declare) the variables of an interface.,
"You must always create an instance of some class that implements the interface, and reference that instance as an instance of the interface.","(""Class"", ""A class implements an interface, so they are related through the implementation relationship."", ""Interface""); (""Instance"", ""An instance is created from a class, so they are related through the instantiation relationship."", ""Class"")"
"While it is normally possible for a class to implement multiple interfaces even if the interfaces contain methods with the same signature, this is not possible if one or more of these methods are default methods.","(""Class"", ""A class can implement multiple interfaces, indicating a relationship between the class and the interfaces it implements."", ""Interfaces""); (""Class"", ""A class can contain methods, indicating a relationship between the class and its methods."", ""Methods""); (""Interfaces"", ""Interfaces can contain methods, indicating a relationship between the interfaces and the methods they define."", ""Methods""); (""Methods"", ""Methods can be default methods, indicating a relationship between methods and default methods."", ""Default Methods"")"
In both of the above situations the Java compiler requires that the class implementing the interface(s) explicitly implements the method which causes the problem.,"(""Java"", ""The Java compiler is related to the Compiler because it is the one requiring the class to implement the interface(s)."", ""Compiler""); (""Compiler"", ""The Compiler is related to the Method because it requires the class to explicitly implement the method."", ""Method""); (""Class"", ""The Class is related to the Interface because the class implements the interface(s)."", ""Interface""); (""Class"", ""The Class is related to the Method because the class implements the method."", ""Method"")"
The implementation in the class takes precedence over any default implementations.,
"Since the return value of produce() is Object, it can return any Java object.","(""Produce"", ""The produce() method returns an Object, indicating a relationship between the two entities."", ""Object""); (""Object"", ""The Object class is part of the Java package, indicating a relationship between the two entities."", ""Java"")"
"Notice how the object returned from the carProducer.produce() method call has to be cast to a Car instance, because the produce() method return type is Object.","(""carProducer"", ""The carProducer class has a produce method, indicating a relationship between the class and the method."", ""produce""); (""produce"", ""The produce method returns an object that needs to be cast to a Car instance, indicating a relationship between the method and the class."", ""Car"")"
"As you can see, since the generic type for the CarProducer instance is set to Car, it is no longer necessary to cast the object returned from the produce() method, since the original method declaration in the MyProducer interface states, that this method returns the same type as is specified in the generic type when used.","(""CarProducer"", ""The CarProducer class has a relationship with the produce method, as it is mentioned that the produce method is used in the context of the CarProducer instance."", ""produce""); (""MyProducer"", ""The MyProducer interface has a relationship with the produce method, as it is stated that the original method declaration is in the MyProducer interface."", ""produce""); (""CarProducer"", ""The CarProducer class has a relationship with the Car class, as the generic type for the CarProducer instance is set to Car."", ""Car"")"
Now the result variable would end up with the value 12.5.,
The example above defines a method called writeText inside a class named MyClass.,
This would happen sometime at runtime - depending on when the application tried to use the missing class.,
This example module descriptor declares that it requires the standard Java module named javafx.graphics.,"(""Example"", ""The Example module descriptor is related to the Module because it declares that it requires the standard Java module."", ""Module""); (""Module"", ""The Module is related to Java because it requires the standard Java module."", ""Java""); (""Java"", ""Java is related to JavaFX because JavaFX is a package of Java."", ""JavaFX""); (""JavaFX"", ""JavaFX is related to Graphics because Graphics is a package of JavaFX."", ""Graphics""); (""Example"", ""The Example module is related to the Descriptor because the Descriptor declares that it requires the standard Java module."", ""Descriptor"")"
Here is how you run the main class from a Java module JAR file:,"(""Main"", ""The Main class is run from a Java module, indicating a relationship between the Main class and the Java package."", ""Java""); (""Main"", ""The Main class is run from a JAR file, indicating a relationship between the Main class and the JAR package."", ""JAR"")"
In Java nested classes are classes that are defined inside another class.,"(""Nested Classes"", ""Nested Classes are defined inside Another Class, indicating a containment relationship between the two classes"", ""Another Class""); (""Java"", ""Java is the programming language in which Nested Classes are used, indicating a usage relationship between Java and Nested Classes"", ""Nested Classes"")"
Notice how you put new after the reference to the outer class in order to create an instance of the inner class.,
"As you can see, an anonymous class implementing an interface is pretty similar to an anonymous class extending another class.",
"Users of the Cache class may never see the CacheEntry class, if they have no need to obtain information about the CacheEntry itself, but only the cached value.",
"If the classes A and B are located in the same Java package, there is no problem with the code above.","(""A"", ""A is located in the Java package"", ""Java""); (""B"", ""B is located in the Java package"", ""Java"")"
"Instead of having a fixed number of layer packages which keep growing in number of classes, you get a growing number of application functionality packages with a smaller number of classes inside.","(""Layer"", ""The layer package contains a growing number of classes"", ""Classes""); (""Application"", ""The application functionality packages are related as they both provide functionality to the application"", ""Functionality""); (""Application"", ""The application functionality packages contain a smaller number of classes inside"", ""Classes"")"
A Java Record is a special kind of Java class which has a concise syntax for defining immutable data-only classes.,
You can add instance methods to a Java Record definition - just like you can with a regular Java class.,"(""Java Record"", ""Java Record has instance methods added to its definition"", ""instance methods""); (""Java class"", ""Java class also has instance methods added to its definition, similar to Java Record"", ""instance methods""); (""Java"", ""Java is the package that Java Record belongs to"", ""Java Record"")"
Notice how the brandAsLowerCase() method calls the auto-generated brand() method internally.,
"As you can see, a new StringBuilder is created, passing along the first String to its constructor, and the second String to its append() method, before finally calling the toString() method.","(""StringBuilder"", ""StringBuilder is related to String because it is created with a String and appends another String"", ""String""); (""StringBuilder"", ""StringBuilder is related to append() because append() is a method of StringBuilder"", ""append()""); (""StringBuilder"", ""StringBuilder is related to toString() because toString() is a method of StringBuilder"", ""toString()""); (""String"", ""String is related to append() because append() is a method that can be used with a String"", ""append()"")"
You can search for substrings in Strings using the indexOf() method.,
The Java String class also has a lastIndexOf() method which finds the last occurrence of a substring.,
The Java String class contains a method called trim() which can trim a string object.,"(""String"", ""The String class contains the trim() method, indicating a clear relationship between the two entities as the method is a part of the class."", ""trim()"")"
"If not, the default toString() method (inherited from the Object class) will get called.",
From Java 13 the Java String class got a new method called translateEscapes() which can translate escape codes that exist inside a String in the same way the Java compiler translates them.,"(""Java String class"", ""The Java String class has a method called translateEscapes(), indicating a clear relationship between the class and the method."", ""translateEscapes()""); (""Java"", ""The Java String class is part of the Java package, indicating a clear relationship between the package and the class."", ""Java String class"")"
When you create an instance of a class (an object) the object can have methods you can execute.,"(""Class"", ""An object is an instance of a class, indicating a clear relationship between the two entities."", ""Object""); (""Object"", ""The object can have methods, indicating that the object and methods are related as the methods belong to or are executed by the object."", ""Methods"")"
The second line assigns the floating point value 199.99 to the floating point variable named myFloat.,"(""MyFloat"", ""MyFloat is an instance of the Floating Point class"", ""Floating Point""); (""Assign"", ""The Assign method is used to assign a value to the MyFloat variable"", ""MyFloat"")"
"When you click the ""Run..."" option, IntelliJ IDEA will first compile your Java class, and then run it.","(""IntelliJ IDEA"", ""IntelliJ IDEA compiles and runs Java classes"", ""Java""); (""IntelliJ IDEA"", ""IntelliJ IDEA provides the Run... option to compile and run Java classes"", ""Run...""); (""IntelliJ IDEA"", ""IntelliJ IDEA compiles and runs Java classes"", ""Java""); (""IntelliJ IDEA"", ""IntelliJ IDEA provides the Run... option to compile and run Java classes"", ""Run..."")"
"The logrb() methods work like the log() methods too, except they can obtain the log messages from a resource bundle.","(""Logrb"", ""The logrb() methods work like the log() methods, indicating a relationship between the two methods"", ""Log"")"
You can obtain the parent Logger of a given Logger using the getParent() method.,"(""Logger"", ""The getParent() method is used in the context of a Logger, indicating a relationship between the Logger class and the getParent() method."", ""getParent()"")"
The getParameters() method returns the parameters to be inserted into the message of this LogRecord.,"(""Getparameters"", ""The getParameters() method returns the parameters to be inserted into the message of this LogRecord, indicating a relationship between the getParameters method and the LogRecord class."", ""Logrecord""); (""Getparameters"", ""The getParameters() method returns the parameters to be inserted into the message, indicating a relationship between the getParameters method and the message."", ""Message"")"
The getResourceBundle() method returns the ResourceBundle (if any) used to localize the message of this LogRecord.,"(""getResourceBundle()"", ""The getResourceBundle() method is related to LogRecord because it is used to retrieve a resource bundle for localizing the message of this LogRecord."", ""LogRecord""); (""getResourceBundle()"", ""The getResourceBundle() method is related to ResourceBundle because it returns an instance of ResourceBundle."", ""ResourceBundle"")"
"Note: This tutorial does not cover the other popular Java logging API's (Log4J, SLF4J, Apache Commons Logging, LogBack etc.).","(""Java"", ""Java is related to Log4J as Log4J is a Java logging API"", ""Log4J""); (""Java"", ""Java is related to SLF4J as SLF4J is a Java logging API"", ""SLF4J""); (""Java"", ""Java is related to Apache Commons Logging as Apache Commons Logging is a Java logging API"", ""Apache Commons Logging""); (""Java"", ""Java is related to LogBack as LogBack is a Java logging API"", ""LogBack""); (""Log4J"", ""Log4J and SLF4J are related as they are both popular Java logging APIs"", ""SLF4J""); (""Log4J"", ""Log4J and Apache Commons Logging are related as they are both popular Java logging APIs"", ""Apache Commons Logging""); (""Log4J"", ""Log4J and LogBack are related as they are both popular Java logging APIs"", ""LogBack""); (""SLF4J"", ""SLF4J and Apache Commons Logging are related as they are both popular Java logging APIs"", ""Apache Commons Logging""); (""SLF4J"", ""SLF4J and LogBack are related as they are both popular Java logging APIs"", ""LogBack"")"
Receiving data via a DatagramSocket is done by first creating a DatagramPacket and then receiving data into it via the DatagramSocket's receive() method.,"(""DatagramSocket"", ""The DatagramSocket and receive() are related because receive() is a method of the DatagramSocket class, indicating that the DatagramSocket uses the receive() method to receive data."", ""receive()""); (""DatagramSocket"", ""The DatagramSocket and DatagramPacket are related because a DatagramPacket is used in conjunction with a DatagramSocket to receive data, indicating a collaborative relationship between the two."", ""DatagramPacket"")"
The java.net package contains two interesting classes: The URL class and the URLConnection class.,
You can check the when the read operation is finished by calling the isDone() method of the Future instance returned by the read() method.,"(""Future"", ""The Future instance has an isDone() method, indicating a relationship between the two entities."", ""isDone()""); (""Future"", ""The Future instance is returned by the read() method, indicating a relationship between the two entities."", ""read()"")"
Each way to write data call one of the write() methods of the AsynchronousFileChannel.,
The int returned by the read() method tells how many bytes were written into the Buffer.,
There is no guarantee of how many bytes the write() method writes to the FileChannel.,
You can obtain the current position of the FileChannel object by calling the position() method.,
The Files.createDirectory() method creates a new directory from a Path instance.,"(""Files"", ""The Files class contains the createDirectory() method, indicating a relationship between the two."", ""createDirectory()"")"
The Java NIO Files class also contains a function for moving files from one path to another.,"(""Java NIO Files"", ""Java NIO Files contains or is related to the Files class"", ""Files""); (""Files"", ""The Files class contains a function for moving files from one path to another"", ""function"")"
Here is a walkFileTree() that extends SimpleFileVisitor to look for a file named README.txt :,"(""WalkFileTree"", ""WalkFileTree extends SimpleFileVisitor, indicating a clear inheritance relationship between the two classes"", ""SimpleFileVisitor""); (""WalkFileTree"", ""WalkFileTree is designed to look for a file named Readme.txt, indicating a clear association between the class and the file"", ""Readme.txt"")"
"By walking through all directories and deleting all files (inside visitFile()) in each directory, and afterwards delete the directory itself (inside postVisitDirectory()) you can delete a directory with all subdirectories and files.",
"In many cases though, you can replace the use of the File class with use of the Path interface.",
The normalize() method of the Path interface can normalize a path.,"(""Path"", ""The normalize() method is a part of the Path interface, indicating a clear relationship between the two."", ""normalize()""); (""Path interface"", ""The Path interface contains or is related to the Path class, indicating a relationship between the package and the class."", ""Path"")"
"As you saw in the previous section, when you register a Channel with a Selector the register() method returns a SelectionKey objects.","(""Channel"", ""A Channel is registered with a Selector, indicating a relationship between the two classes."", ""Selector""); (""Channel"", ""The register method of a Selector returns a SelectionKey object when a Channel is registered, establishing a connection between the Channel and SelectionKey classes."", ""SelectionKey""); (""Selector"", ""The register method of a Selector returns a SelectionKey object, indicating a relationship between the Selector and SelectionKey classes."", ""SelectionKey""); (""register"", ""The register method is used to register a Channel with a Selector, showing a relationship between the register method and the Channel class."", ""Channel""); (""register"", ""The register method is a part of the Selector, showing a relationship between the register method and the Selector class."", ""Selector"")"
"You can also attach an object already while registering the Channel with the Selector, in the register() method.","(""Channel"", ""The Channel is related to the Selector because it is registered with the Selector using the register() method."", ""Selector""); (""Channel"", ""The Channel is related to the register() method because the Channel is registered using this method."", ""register"")"
NOTE: Only the interfaces specifically declared implemented by a given class is returned.,
All you need to do is to obtain a ClassLoader and call its loadClass() method.,
"When the MyAction class calls methods on the IMyFactory instance injected into its constructor by the container, the method calls are translated into calls to the IContainer.instance() method, which is the method you use to obtain instances from the container.","(""MyAction"", ""MyAction class calls methods on the IMyFactory instance"", ""IMyFactory""); (""IMyFactory"", ""IMyFactory instance is obtained from the IContainer instance"", ""IContainer""); (""MyAction"", ""MyAction class uses the IContainer instance to obtain instances from the container"", ""IContainer"")"
"You cannot ask for getters and setters explicitly, so you will have to scan through all the methods of a class and check if each method is a getter or setter.","(""Class"", ""A class contains multiple methods"", ""Method""); (""Method"", ""Getters are a type of method"", ""Getters""); (""Method"", ""Setters are a type of method"", ""Setters""); (""Class"", ""A class has getters as part of its methods"", ""Getters"")"
To access a private field you will need to call the Class.getDeclaredField(String name) or Class.getDeclaredFields() method.,"(""Class"", ""The Class entity is related to the getDeclaredField entity because getDeclaredField is a method of the Class entity."", ""getDeclaredField"")"
"By calling Field.setAcessible(true) you turn off the access checks for this particular Field instance, for reflection only.",
"The methods Class.getMethod(String name, Class[] parameterTypes) and Class.getMethods() methods only return public methods, so they won't work.","(""Class"", ""Class has a method called getMethod"", ""getMethod""); (""Class"", ""Class has a method called getMethods"", ""getMethods""); (""getMethod"", ""getMethod takes a String parameter called name"", ""String"")"
"It will explain the basics of Java Reflection including how to work with arrays, annotations, generics and dynamic proxies, and do dynamic class loading and reloading.","(""Java Reflection"", ""Java Reflection is related to Arrays because it explains how to work with arrays"", ""Arrays""); (""Java Reflection"", ""Java Reflection is related to Annotations because it explains how to work with annotations"", ""Annotations""); (""Java Reflection"", ""Java Reflection is related to Generics because it explains how to work with generics"", ""Generics""); (""Java Reflection"", ""Java Reflection is related to Dynamic Proxies because it explains how to work with dynamic proxies"", ""Dynamic Proxies"")"
"For instance, if you are introspecting a String array, you can detect that the element type is String by inspecting the array class.",
"For instance, the character class [a-zA-Z] will match all letters between a and z or between A and Z .","(""Character"", ""The character class is related to the letter A because it includes all letters between a and z or between A and Z."", ""A""); (""Character"", ""The character class is related to the letter Z because it includes all letters between a and z or between A and Z."", ""Z""); (""Character"", ""The character class is related to the letter a because it includes all letters between a and z or between A and Z."", ""a""); (""Character"", ""The character class is related to the letter z because it includes all letters between a and z or between A and Z."", ""z""); (""A"", ""The letters A and Z are related because they both represent the range of uppercase letters that the character class matches."", ""Z""); (""a"", ""The letters a and z are related because they both represent the range of lowercase letters that the character class matches."", ""z""); (""A"", ""The letters A and a are related because they are both the starting point of the range of letters that the character class matches, with A being uppercase and a being lowercase."", ""a"")"
"For that, you need to use the find(), start() and end() methods.","(""FIND"", ""They are related because they are all mentioned together as methods to be used for the same purpose."", ""START""); (""FIND"", ""They are related because they are all mentioned together as methods to be used for the same purpose."", ""END"")"
"In other words, if the regular expression matches the beginning of a text but not the whole text, lookingAt() will return true, whereas matches() will return false.",
"In case you have started matching occurrences in a string via the find() method, the Matcher will internally keep a state about how far it has searched through the input text.","(""Matcher"", ""The Matcher is related to the find() method because the find() method is used in conjunction with the Matcher to search for occurrences in a string."", ""find()""); (""Matcher"", ""The Matcher is related to the input text because it keeps a state about how far it has searched through the input text."", ""input text"")"
The Matcher replaceAll() and replaceFirst() methods can be used to replace parts of the string the Matcher is searching through.,"(""Matcher"", ""The Matcher class has a replaceAll() method, indicating a relationship between the two."", ""replaceAll()""); (""Matcher"", ""The Matcher class has a replaceFirst() method, indicating a relationship between the two."", ""replaceFirst()"")"
A regular expression is also sometimes referred to as a pattern (hence the name of the Java Pattern class).,
"Too keep this text short, the Matcher covered in more detail in the text about the Java Matcher class.","(""Java"", ""The Java package is related to the Java Matcher class because the class is a part of the Java package."", ""Java Matcher"")"
When you are finished reading data from the GZIPInputStream you should close it using its close() method.,"(""GZIPInputStream"", ""The GZIPInputStream and the close() method are related to each other because the close() method is used to close the GZIPInputStream after reading data from it."", ""close()"")"
"But, notice how no DI is used inside the BO.checkPersonIsValid() or the DAO.readPerson() methods.","(""BO"", ""BO is a class that contains the method checkPersonIsValid, indicating that checkPersonIsValid is a part of BO""}"", ""checkPersonIsValid""); (""DAO"", ""DAO is a class that contains the method readPerson, indicating that readPerson is a part of DAO""}"", ""readPerson"")"
"This little script defines the ""max"" factory as a call to the static max() method with input parameter 0 and 1 passed to the max() method.","(""Max"", ""The Max factory is related to the max() method because it is defined as a call to the static max() method."", ""max()"")"
"In other words, as a call to the get() method on the HttpRequestCache singleton.",
The ScriptFactoryBuilder has a addFactories() method that takes an InputStream as parameter instead of a String.,"(""ScriptFactoryBuilder"", ""The ScriptFactoryBuilder has a method called addFactories(), indicating a clear relationship between the class and the method."", ""addFactories()""); (""addFactories()"", ""The addFactories() method takes an InputStream as a parameter, indicating a clear relationship between the method and the InputStream class."", ""InputStream"")"
"Notice how the HttpServletRequest and HttpServletResponse are not obtained by the ThreadLocal.get() method, but via the static methods getRequest() and getResponse().","(""HttpServletRequest"", ""HttpServletRequest is related to getRequest because getRequest is a method that obtains the HttpServletRequest"", ""getRequest""); (""HttpServletResponse"", ""HttpServletResponse is related to getResponse because getResponse is a method that obtains the HttpServletResponse"", ""getResponse""); (""ThreadLocal"", ""ThreadLocal is related to get because get is a method of ThreadLocal"", ""get""); (""ThreadLocal"", ""ThreadLocal is related to getRequest because getRequest is a static method that uses ThreadLocal internally"", ""getRequest""); (""ThreadLocal"", ""ThreadLocal is related to getResponse because getResponse is a static method that uses ThreadLocal internally"", ""getResponse""); (""HttpServletRequest"", ""HttpServletRequest is related to ThreadLocal because ThreadLocal is used to manage the HttpServletRequest instance"", ""ThreadLocal"")"
"The IObjectMappingKey instance can contain more information about the class to be mapped, than a Class object can.",
This is the object is obtained from the getResult() method of the IResultSetProcessor.,
"This speeds up object mapping cache lookups because the hashCode() method returns this int id, and because equals() also only compares int id's, instead of Class objects, table names etc.","(""HashCode"", ""Both HashCode and Equals methods are related as they are used for object mapping cache lookups and comparisons, with HashCode returning an int id and Equals comparing these int ids."", ""Equals""); (""Class"", ""The Class entity is related to the HashCode method because the method is used in the context of Class objects, specifically for returning an int id."", ""HashCode"")"
The extended class CustomObjectMapperBase is an empty implementation of the ICustomObjectMapper interface.,
Just call the IObjectMapping.removeGetterMapping(String name) or IObjectMapping.removeSetterMapping(String name) method to do so.,"(""IObjectMapping"", ""IObjectMapping is a class that has a method called removeGetterMapping, which indicates a clear relationship between the two entities as the method is part of the class's interface."", ""removeGetterMapping"")"
"Second, you do not need the parentheses around the closure when calling doFirst() or doLast().",
The and() method is used to combine two other Predicate functions in the same way I showed in the beginning of this Java functional composition tutorial.,"(""And"", ""The And method is used in combination with Predicate functions, indicating a relationship between the two."", ""Predicate""); (""And"", ""The And method is used in the context of a Java functional composition tutorial, indicating a relationship between the method and the Java package."", ""Java"")"
"The Java Function compose() method composes a new Function instance from the Function instance it is called on, and the Function instance passed as parameter to the compose() method.","(""Compose"", ""The Compose method is a part of the Function class and is used to compose a new Function instance."", ""Function"")"
The first example of a higher order function is the Collections.sort() method which takes a Comparator as parameter.,"(""Collections"", ""The Collections class contains the sort method"", ""sort"")"
The call to the map() method of the Stream interface is a non-terminal operation.,
Only the first occurrence of this element will be included in the Stream returned by distinct().,
"The findFirst() method returns an Optional from which you can obtain the element, if present.",
"The Java Stream forEach() method is a terminal operation which starts the internal iteration of the elements in the Stream, and applies a Consumer (java.util.function.Consumer) to each element in the Stream.","(""Java Stream"", ""The forEach() method is a part of the Java Stream class, indicating a relationship between the two entities as the method is used to operate on the stream."", ""forEach()""); (""forEach()"", ""The forEach() method applies a Consumer to each element in the Stream, indicating a relationship between the two entities as the method utilizes the Consumer interface."", ""java.util.function.Consumer"")"
Which element is the largest is determined by the Comparator implementation you pass to the max() method.,
This Optional contains the value (if any) returned by the lambda expression passed to the reduce() method.,"(""Optional"", ""The Optional entity contains the value returned by the lambda expression passed to the reduce() method, indicating a relationship between the Optional class and the reduce() method."", ""reduce()""); (""reduce()"", ""The reduce() method takes a lambda expression as an argument, establishing a relationship between the reduce() method and the lambda expression."", ""lambda expression"")"
"Note: Even if the class is called RollingBufferInputStream, it is not an InputStream subclass.",
"You can specify fonts for most text objects (Chunk, Phrase, Paragraph etc.)","(""Chunk"", ""Both Chunk and Paragraph are text objects that can have fonts specified for them"", ""Paragraph""); (""Phrase"", ""Both Phrase and Paragraph are text objects that can have fonts specified for them"", ""Paragraph"")"
"If you already have a finished PDF, and just want to add a header, footer or watermark to it, IText provides the com.itextpdf.pdf.PdfStamper class.",
"You can write text as superscript or subscript using the Chunk class, and it's setTextRise() method.",
"You can add underline and strikethrough text using the Chunk class, and its setUnderline() method.",
"It is now up to the caller of the readMyData() method to decide if an existing MyData instance should be reused, or if a new instance should be created.",
The value returned by write() is the number of bytes copied from the ByteBuffer.,
Here is an implementation of the ring buffer that uses a fill count including the batch put() and take() operations.,"(""Ring Buffer"", ""The Ring Buffer class uses the Put method for batch put operations."", ""Put""); (""Ring Buffer"", ""The Ring Buffer class uses the Take method for batch take operations."", ""Take"")"
"Here is an implementation of the ring buffer that uses a read position and flip marker, including the batch put() and take() operations.","(""Ring Buffer"", ""The Ring Buffer uses a Read Position, indicating a relationship between the two entities."", ""Read Position""); (""Ring Buffer"", ""The Ring Buffer uses a Flip Marker, indicating a relationship between the two entities."", ""Flip Marker""); (""Ring Buffer"", ""The Ring Buffer includes the Put operation, indicating a relationship between the two entities."", ""Put""); (""Ring Buffer"", ""The Ring Buffer includes the Take operation, indicating a relationship between the two entities."", ""Take""); (""Put"", ""The Put operation is mentioned alongside batch, indicating a relationship between the two entities."", ""Batch"")"
"If your benchmark method produces multiple results you can pass each of these results to a black hole, meaning calling consume() on the Blackhole instance for each value.",
The javax.servlet.http.HttpServlet class is a slightly more advanced base class than the GenericServlet shown in the Simple Servlet example.,"(""HttpServlet"", ""The HttpServlet class is a slightly more advanced base class than the GenericServlet, indicating a relationship of inheritance or extension."", ""GenericServlet""); (""HttpServlet"", ""The HttpServlet class belongs to the javax.servlet.http package, indicating a relationship of containment or membership."", ""javax.servlet.http"")"
The easiest way to implement this interface is to extend either the class GenericServlet or HttpServlet.,"(""GenericServlet"", ""Both GenericServlet and HttpServlet are classes that can be extended to implement an interface, as stated in the text."", ""HttpServlet""); (""GenericServlet"", ""The text implies that GenericServlet is a class used to implement an interface."", ""interface"")"
Each test method usually tests a single method of the target class.,"(""Test"", ""The test class contains the test method."", ""Method""); (""Method"", ""The test method is used to test a single method of the target class."", ""Target"")"
"A protected method or field, on the other hand, is also accessible to other classes in the same package, and for subclasses of the unit too.","(""Method"", ""A method is related to a package because it can be accessible to other classes in the same package"", ""Package""); (""Field"", ""A field is related to a package because it can be accessible to other classes in the same package"", ""Package""); (""Class"", ""A class is related to a package because it can be in the same package and access other classes and subclasses in the package"", ""Package""); (""Subclasses"", ""Subclasses are related to a class because they are subclasses of the unit and can access its methods and fields"", ""Class""); (""Method"", ""A method is related to a class because it can be a method of the class and accessible to other classes in the same package and subclasses"", ""Class""); (""Field"", ""A field is related to a class because it can be a field of the class and accessible to other classes in the same package and subclasses"", ""Class"")"
"When your business logic class is separated from the boundary class, you can test the business logic class separately.",
Here is the unit test which uses a ByteArrayOutputStream to collect the data written to the OutputStream passed to the MyIOUnit.write() method:,"(""MyIOUnit"", ""MyIOUnit is a class that has a method named write, so they are clearly related as the method belongs to the class"", ""write""); (""OutputStream"", ""OutputStream is a parent class of ByteArrayOutputStream, so they are clearly related as ByteArrayOutputStream is a subclass of OutputStream"", ""ByteArrayOutputStream""); (""MyIOUnit"", ""MyIOUnit has a method write that takes an OutputStream as a parameter, so they are clearly related as the method uses the OutputStream"", ""OutputStream""); (""write"", ""The write method uses an OutputStream as a parameter, so they are clearly related as the method operates on the OutputStream"", ""OutputStream""); (""MyIOUnit"", ""MyIOUnit has a method write that can use a ByteArrayOutputStream as the OutputStream parameter, so they are clearly related as the class can work with the ByteArrayOutputStream"", ""ByteArrayOutputStream"")"
You may also be able to use the StringReader and StringWriter classes in your unit tests.,
"To avoid fragmenting the Java heap with Bytes instances, the Bytes class is designed to be obtained from an ObjectPool .","(""Bytes"", ""The Bytes class is designed to be obtained from an ObjectPool, indicating a relationship between the two classes."", ""ObjectPool""); (""Bytes"", ""The Bytes class is part of the Java programming language, which suggests that it belongs to the Java package."", ""Java"")"
To defragment the free blocks you call the defragment() method of the BytesAllocatorManualDefrag .,
The Bytes class represents a byte sequence allocated from a shared byte array.,
"As you can see, the ChannelInitializer is added to the ServerBootstrap using the childHandler() method.","(""ChannelInitializer"", ""The ChannelInitializer is added to the ServerBootstrap, indicating a relationship between the two classes."", ""ServerBootstrap""); (""ServerBootstrap"", ""The childHandler() method is used with the ServerBootstrap, indicating a relationship between the class and the method."", ""childHandler()"")"
"By calling sync() on the ChannelFuture the main thread that creates the server waits until the server has started, before continuing.","(""ChannelFuture"", ""The ChannelFuture has a method called sync, which establishes a relationship between the two entities as the method is called on the class."", ""sync""); (""main thread"", ""The main thread waits on the ChannelFuture, which establishes a relationship between the two entities as the main thread is dependent on the ChannelFuture."", ""ChannelFuture"")"
The easiest way to create an instance of the RionObjectReader is via the RionObjectReaderBuilder class.,
The RionObjectReader readCyclic() method reads a cyclic object graph stored as RION in a byte array.,"(""RionObjectReader"", ""The RionObjectReader class contains the readCyclic() method, which indicates a clear relationship between the two entities as the method is a part of the class."", ""readCyclic()""); (""RionObjectReader"", ""The RionObjectReader class is related to RION because it reads a cyclic object graph stored as RION, indicating that RION is a format or structure that the class works with."", ""RION"")"
The RionObjectWriter writeAcyclic() can write an acyclic object graph as RION into a byte array.,"(""RionObjectWriter"", ""RionObjectWriter has a method called writeAcyclic()"", ""writeAcyclic()""); (""writeAcyclic()"", ""writeAcyclic() method can write an acyclic object graph as RION"", ""RION"")"
When reading a composite RION field you need to use the RionReader moveInto() and moveOutOf() methods.,"(""RionReader"", ""RionReader is related to moveInto() because moveInto() is a method of RionReader"", ""moveInto()"")"
"Here are two examples of writing a 32 bit and 64 bit floating point number as RION Float fields to the destination byte array, using the RionWriter writeFloat32() and writeFloat64() methods:","(""RionWriter"", ""RionWriter has a method called writeFloat32() which is used to write a 32 bit floating point number to the destination byte array"", ""writeFloat32()""); (""RionWriter"", ""RionWriter has a method called writeFloat64() which is used to write a 64 bit floating point number to the destination byte array"", ""writeFloat64()""); (""writeFloat32()"", ""writeFloat32() method writes a 32 bit floating point number as RION Float field to the destination byte array"", ""RION Float""); (""writeFloat64()"", ""writeFloat64() method writes a 64 bit floating point number as RION Float field to the destination byte array"", ""RION Float"")"
The StreamStorageFS class contains a method to read bytes from a stream block file.,
"The readBytes() method reads bytes from the file represented by the given StreamStorageBlockFS instance, into the byte[] array passed as parameter.","(""Readbytes()"", ""The readBytes() method is related to the StreamStorageBlockFS class because it reads bytes from the file represented by the given StreamStorageBlockFS instance""}"", ""Streamstorageblockfs"")"
You can always obtain the root directory path a StreamStorageRootFS was created with via its getRootDirPath() method.,
"When you write records to a stream via the StreamStorageFS instance, the StreamStorageFS class will divide the records into multiple files.","(""StreamStorageFS"", ""The StreamStorageFS class is related to records because it divides the records into multiple files."", ""records""); (""StreamStorageFS"", ""The StreamStorageFS class is related to stream because it is used to write records to a stream."", ""stream""); (""StreamStorageFS"", ""The StreamStorageFS class is related to files because it divides the records into multiple files."", ""files""); (""records"", ""The records are related to stream because they are written to a stream."", ""stream""); (""records"", ""The records are related to files because they are divided into multiple files."", ""files"")"
You can read the data stored in a Buffer using the many get...() methods.,
Notice the use of / as directory separator and the use of : as classpath entry separator.,"(""Directory"", ""Directory uses Separator as its directory separator"", ""Separator"")"
"However, if you do need to access the body of the HTTP response, you need to register another handler on the HttpClientResponse that is passed as parameter to the first Handler's handle() method.","(""Handler"", ""The Handler class has a method called handle, indicating a relationship between the two entities."", ""handle"")"
"Again, the NetClient's close() method is asynchronous, so the underlying TCP connection may not yet be closed by the time the close() method returns.",
Sending messages via the event bus can be done via either the send() or publish() method on the event bus.,"(""Event Bus"", ""The Event Bus and Send are related because Send is a method on the Event Bus."", ""Send""); (""Event Bus"", ""The Event Bus and Publish are related because Publish is a method on the Event Bus."", ""Publish"")"
A verticle has a start() and a stop() method which are called when the verticle is deployed and when it is undeployed.,"(""Verticle"", ""The Verticle class has a Start method which is called when the verticle is deployed."", ""Start"")"
The addAll() method takes a Collection as parameter so you can pass either a List or Java Set as parameter,"(""addAll()"", ""The addAll() method takes a Collection as parameter, indicating that addAll() is related to Collection as it operates on it"", ""Collection""); (""addAll()"", ""The addAll() method can take a List as parameter, indicating that addAll() is related to List as it can operate on it"", ""List"")"
But no thread can actually execute unlock() until the thread waiting in lock() leaves the outer synchronized block,"(""Thread"", ""A thread executes a lock, indicating a relationship between the two entities as the thread is waiting in the lock"", ""Lock""); (""Thread"", ""A thread can execute unlock, showing that the thread is related to the unlock method as it is the one performing the unlock action"", ""Unlock"")"
A thread cannot call wait() notify() or notifyAll() without holding the lock on the object the method is called on,"(""Thread"", ""A thread cannot call wait() without holding the lock on the object the method is called on, indicating a relationship between the Thread class and the Wait method"", ""Wait""); (""Thread"", ""A thread cannot call notify() without holding the lock on the object the method is called on, indicating a relationship between the Thread class and the Notify method"", ""Notify"")"
"The Arrays class contains a set of methods called binarySearch(). This method helps you perform a binary search in an array. The array must first be sorted. You can do so yourself, or via the Arrays.sort() method covered earlier in this text.","(""Arrays"", ""The Arrays class contains the binarySearch() method, indicating a relationship between the two entities as the method is part of the class."", ""binarySearch()""); (""Arrays"", ""The Arrays class contains the Arrays.sort() method, indicating a relationship between the two entities as the method is part of the class."", ""Arrays.sort()"")"
java.lang.ThreadLocal is possible to set an initial value for a Java ThreadLocal which will get used the first time get() is called before set() has been called with a new value,"(""Java ThreadLocal"", ""Java ThreadLocal is related to get because get is a method that can be called on a Java ThreadLocal object"", ""get""); (""Java ThreadLocal"", ""Java ThreadLocal is related to set because set is a method that can be called on a Java ThreadLocal object to set a new value"", ""set""); (""ThreadLocal"", ""ThreadLocal is related to java.lang because ThreadLocal is a class in the java.lang package"", ""java.lang""); (""java.lang"", ""java.lang is related to ThreadLocal because java.lang is the package where ThreadLocal is defined"", ""ThreadLocal""); (""get"", ""get is related to Java ThreadLocal because get is a method that is used to retrieve the value of a Java ThreadLocal object"", ""Java ThreadLocal"")"
Adding and getting elements to a generic Map is done using the put() and get() methods just like you have always done,"(""Map"", ""The Map class uses the put() method to add elements"", ""put()""); (""Map"", ""The Map class uses the get() method to retrieve elements"", ""get()"")"
Deque.pollLast() is different than removeLast() which throws an exception if the Deque is empty,"(""Deque"", ""Deque has a method called pollLast"", ""pollLast""); (""Deque"", ""Deque has a method called removeLast"", ""removeLast"")"
The tailSet() method works the same way as the headSet() method except it returns all elements that are equal to or higher than the given parameter element,
"You can also obtain an Iterator from many of the Java Collection data structures, e.g. a List, Set, Map, Queue, Deque or Map.","(""Iterator"", ""Iterator is obtained from many of the Java Collection data structures"", ""Collection""); (""Iterator"", ""Iterator can be obtained from a List"", ""List""); (""Iterator"", ""Iterator can be obtained from a Set"", ""Set""); (""Iterator"", ""Iterator can be obtained from a Map"", ""Map""); (""Iterator"", ""Iterator can be obtained from a Queue"", ""Queue""); (""Iterator"", ""Iterator can be obtained from a Deque"", ""Deque""); (""List"", ""List is one of the Java Collection data structures"", ""Collection""); (""Set"", ""Set is one of the Java Collection data structures"", ""Collection""); (""Map"", ""Map is one of the Java Collection data structures"", ""Collection""); (""Queue"", ""Queue is one of the Java Collection data structures"", ""Collection"")"
java.io.Writer works just like combining the Reader with InputStream or the Writer with OutputStream,"(""Writer"", ""Writer works just like combining the Reader with InputStream or the Writer with OutputStream, indicating a relationship between Writer and Reader"", ""Reader""); (""Writer"", ""Writer works just like combining the Reader with InputStream or the Writer with OutputStream, indicating a relationship between Writer and InputStream"", ""InputStream""); (""Writer"", ""Writer works just like combining the Reader with InputStream or the Writer with OutputStream, indicating a relationship between Writer and OutputStream"", ""OutputStream""); (""Reader"", ""Writer works just like combining the Reader with InputStream or the Writer with OutputStream, indicating a relationship between Reader and InputStream"", ""InputStream""); (""Writer"", ""Java Io is the package where the Writer class is located"", ""Java Io""); (""Reader"", ""Java Io is the package where the Reader class is located"", ""Java Io""); (""InputStream"", ""Java Io is the package where the InputStream class is located"", ""Java Io"")"
Remember that even if the 4 threads call wait() and notify() on the same shared string instance the signals from the doWait() and doNotify() calls are stored individually in the two MyWaitNotify instances,"(""MyWaitNotify"", ""MyWaitNotify is related to wait because the signals from the wait calls are stored individually in the MyWaitNotify instances"", ""wait""); (""MyWaitNotify"", ""MyWaitNotify is related to notify because the signals from the notify calls are stored individually in the MyWaitNotify instances"", ""notify""); (""MyWaitNotify"", ""MyWaitNotify is related to doWait because doWait calls are stored individually in the MyWaitNotify instances"", ""doWait""); (""MyWaitNotify"", ""MyWaitNotify is related to doNotify because doNotify calls are stored individually in the MyWaitNotify instances"", ""doNotify""); (""wait"", ""wait and notify are related because they are both used on the same shared string instance and their signals are stored individually in the MyWaitNotify instances"", ""notify"")"
The bigger the result String grows the longer it takes to copy the characters from it into a new StringBuilder and again copy the characters from the StringBuilder into the temporary String created by the toString() method,"(""String"", ""The String and StringBuilder are related because the characters from the String are copied into the StringBuilder."", ""StringBuilder""); (""String"", ""The String and toString() method are related because the toString() method is called on the temporary String created."", ""toString()"")"
The logp() methods work like the log() methods except each method take an extra two parameters The sourceClass and sourceMethod parameter,"(""Logp"", ""The logp() methods work like the log() methods, indicating a clear relationship between the two methods"", ""Log""); (""Logp"", ""The logp() method takes an extra parameter sourceClass, indicating a relationship between the logp() method and the sourceClass"", ""Sourceclass"")"
But since the thread waiting in lock() has not yet called queueObject.wait() the call to queueObject.notify() passes into oblivion,"(""Thread"", ""The thread is waiting in the lock, indicating a relationship between the Thread class and the Lock class or method"", ""Lock""); (""Thread"", ""The thread is waiting for the QueueObject to be notified, indicating a relationship between the Thread class and the QueueObject class"", ""QueueObject""); (""QueueObject"", ""The QueueObject has a wait method, indicating a relationship between the QueueObject class and the Wait method"", ""Wait""); (""QueueObject"", ""The QueueObject has a notify method, indicating a relationship between the QueueObject class and the Notify method"", ""Notify"")"
Since PipedOutputStream is a subclass of OutputStream PipedOutputStream has the same basic methods and use patterns as an OutputStream,
You can convert a Java Set to a Java List by creating a List and calling its addAll() method passing the Set as parameter to the addAll() method,"(""Set"", ""The Set is converted to a List by calling the addAll() method and passing the Set as a parameter"", ""List""); (""List"", ""The List has an addAll() method that is used to convert a Set to a List"", ""addAll()"")"
Even though the Java Networking APIs enable you to open and close network connections via sockets all communication happens via the Java IO classes InputStream and OutputStream,"(""Java Networking APIs"", ""The Java Networking APIs are related to the InputStream class because they enable network communication via InputStream"", ""InputStream""); (""Java Networking APIs"", ""The Java Networking APIs are related to the OutputStream class because they enable network communication via OutputStream"", ""OutputStream""); (""Java Networking APIs"", ""The Java Networking APIs are related to the Java IO package because Java IO contains the classes used for communication"", ""Java IO""); (""InputStream"", ""The InputStream and OutputStream classes are related to each other because they are both used for communication and are part of the Java IO package"", ""OutputStream""); (""InputStream"", ""The InputStream class is related to the Java IO package because it is part of the package"", ""Java IO"")"
Again here the first() and next() methods return the unicode index of the found word boundary,
Obviously if the input parameter to contains() is null the contains() method will not use the equals() method to compare against each element but rather use the == operator,"(""Contains"", ""The contains() method will use the equals() method to compare against each element if the input parameter is not null"", ""Equals"")"
Both Java File and FileChannel works but in case you want a pure Java NIO solution use the Java NIO FileChannel class,"(""Java File"", ""Both Java File and FileChannel are related as they are mentioned as alternatives for achieving the same goal"", ""FileChannel""); (""Java NIO"", ""Java NIO is related to FileChannel because FileChannel is part of the Java NIO solution"", ""FileChannel"")"
If you need an integer value use the round() floor() or ceil() method,
The poll() and remove() both removes the first element in the Queue. They differ in how they behave if the Queue is empty. The poll() method returns null if the Queue is empty. The remove() method throws an exception if the Queue is empty.,"(""Poll"", ""The poll() method is related to the Queue class because it operates on the Queue, removing the first element."", ""Queue""); (""Remove"", ""The remove() method is related to the Queue class because it operates on the Queue, removing the first element."", ""Queue"")"
"The add() and offer() methods differ in how the behave if the Queue is full, so no more elements can be added. The add() method throws an exception in that case, whereas the offer() method just returns false.","(""Add"", ""The Add method is related to the Queue because it is used to add elements to the Queue and throws an exception when the Queue is full."", ""Queue""); (""Offer"", ""The Offer method is related to the Queue because it is used to add elements to the Queue and returns false when the Queue is full."", ""Queue"")"
Each of the methods ceilingEntry() floorEntry() higherEntry() and lowerEntry() will be covered in the following sections,
To do so set the upper bound to 1 and have the call to take() and release() guard the critical section,"(""Take"", ""The Take method is related to the Critical Section because it is used to guard the critical section."", ""Critical Section""); (""Release"", ""The Release method is related to the Critical Section because it is used to guard the critical section."", ""Critical Section"")"
Once you have opened a socket (network connection) though you read and write data to and from it via Java IO InputStream and OutputStream classes,"(""Socket"", ""Socket is related to InputStream because you can read data from a socket using an InputStream"", ""InputStream""); (""Socket"", ""Socket is related to OutputStream because you can write data to a socket using an OutputStream"", ""OutputStream""); (""InputStream"", ""InputStream is part of the Java IO package"", ""Java IO""); (""OutputStream"", ""OutputStream is part of the Java IO package"", ""Java IO"")"
Many of the core components in the Java Collection API rely on the correct implementation of the `hashCode()` and `equals()` methods.,"(""Java Collection API"", ""The Java Collection API relies on the correct implementation of the hashCode() method."", ""hashCode()"")"
java.io.PrintWriter example first creates a PrintWriter instance which is connected to a FileWriter,"(""PrintWriter"", ""PrintWriter is connected to a FileWriter, indicating a relationship between the two classes"", ""FileWriter""); (""PrintWriter"", ""PrintWriter is part of the java.io package, indicating a containment relationship between the class and the package"", ""java.io"")"
InputStream.read() example creates an AsynchronousFileChannel and then creates a ByteBuffer which is passed to the read() method as parameter along with a position of 0,"(""InputStream"", ""The InputStream and read() method are related because the read() method is called on the InputStream."", ""read()""); (""AsynchronousFileChannel"", ""The AsynchronousFileChannel and InputStream are related because an AsynchronousFileChannel is used to create an InputStream."", ""InputStream""); (""ByteBuffer"", ""The ByteBuffer and read() method are related because the ByteBuffer is passed as a parameter to the read() method."", ""read()""); (""InputStream"", ""The InputStream and AsynchronousFileChannel are related because the AsynchronousFileChannel is used to create the InputStream."", ""AsynchronousFileChannel"")"
java.lang.StringBuffer text explains how to use the SimpleDateFormat class to format dates,"(""java.lang"", ""java.lang is the package where SimpleDateFormat is located"", ""SimpleDateFormat""); (""java.lang"", ""java.lang is the package where StringBuffer is located"", ""StringBuffer""); (""SimpleDateFormat"", ""The text explains how to use SimpleDateFormat in relation to a StringBuffer named text to format dates"")
{completion_delimiter}


The final answer is:
(""entity"",""StringBuffer"",""class"", ""StringBuffer"")"
In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not but the BufferedInputStream supports them,
"The newLine() method which can write a new-line character to the underlying Writer. In addition, you may need to call flush() if you need to be absolutely sure that the characters written until now is flushed out of the buffer and onto the network or disk.","(""Newline()"", ""The newLine() method writes a new-line character to the underlying Writer, indicating a relationship between the Newline() method and the Writer class"", ""Writer""); (""Flush()"", ""The flush() method is used to ensure that characters written to the Writer are flushed out of the buffer, indicating a relationship between the Flush() method and the Writer class"", ""Writer"")"
Queue.poll() is different than remove() which throws an exception if the Deque is empty,"(""Queue"", ""Queue has a method called poll"", ""poll""); (""Queue"", ""Queue has a method called remove"", ""remove""); (""Queue"", ""Queue is compared to Deque in terms of its methods"", ""Deque""); (""poll"", ""poll and remove are both methods of Queue and are being compared"", ""remove"")"
Notice the two synchronized blocks inside the set() and get() method. Notice how the blocks are placed last and first in the two methods.,
"The replace() method will only insert the new value if there is already an existing value mapped to the key. If no existing value is mapped to the given key, no value is inserted. This is different from how put() works, which always insert the value no matter what.","(""Replace"", ""The replace() method is related to Key because it is used to insert a new value mapped to the Key."", ""Key""); (""Put"", ""The put() method is related to Key because it always inserts the value no matter what, implying a relationship with the Key."", ""Key"")"
The logrb() methods work like the log() methods too except they can obtain the log messages from a resource bundle,
The Handler in the Java Logging API use a java.util.logging.Formatter to format the LogRecord before writing it to an external system,"(""Handler"", ""The Handler in the Java Logging API uses a Formatter to format the LogRecord"", ""Formatter""); (""Handler"", ""The Handler in the Java Logging API uses a Formatter to format the LogRecord before writing it to an external system"", ""LogRecord""); (""Formatter"", ""The Formatter is used to format the LogRecord before writing it to an external system"", ""LogRecord""); (""Handler"", ""The Handler is part of the Java Logging API"", ""Java Logging API""); (""Formatter"", ""The Formatter is part of the Java Logging API"", ""Java Logging API"")"
