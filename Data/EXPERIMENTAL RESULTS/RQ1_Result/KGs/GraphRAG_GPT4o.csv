The Collections reverse() method can reverse the elements in a Java List.,"(""Collections"", ""The reverse method is a part of the Collections class."", ""reverse""); (""Java"", ""The List class is part of the Java package."", ""List"")"
Here is an example of finding the minimum element in a Java List using Collections min() method:,"(""Collections"", ""The min method is a part of the Collections class, which provides utility methods for collection operations."", ""min""); (""List"", ""The min method is used to find the minimum element in a List, indicating a functional relationship between the List class and the min method."", ""min"")"
"Notice too, that the compareTo() method should throw a NullPointerException if the parameter object is null.","(""CompareTo"", ""The CompareTo method should throw a NullPointerException if the parameter object is null, indicating a relationship where the method uses the class."", ""NullPointerException"")"
The LinkedList class is a pretty standard Deque and Queue implementation.,"(""LinkedList"", ""The LinkedList class is a standard implementation of the Deque class."", ""Deque""); (""LinkedList"", ""The LinkedList class is a standard implementation of the Queue class."", ""Queue"")"
You add elements to the beginning end of a Deque using the add() method.,"(""Deque"", ""The add() method is used to add elements to a Deque."", ""add"")"
"If the element cannot be inserted into the Deque, the add() method will throw an exception.","(""Deque"", ""The add method is used to insert elements into the Deque class."", ""add"")"
"If the element cannot be inserted into the Deque, the addLast() method will throw an exception.","(""addLast"", ""The addLast method is a function that operates on the Deque class to insert an element."", ""Deque"")"
To peek at the last element of a Java Deque you can use the getLast() method.,"(""Deque"", ""The getLast method is used to peek at the last element of a Deque."", ""getLast"")"
The remove() method removes the first element of a Java Deque.,"(""Remove"", ""The remove() method is a function that operates on the Deque class to remove its first element."", ""Deque"")"
"The pollFirst() method removes an element from the beginning of the Deque, just like poll().","(""PollFirst"", ""The PollFirst method operates on the Deque class by removing an element from its beginning."", ""Deque""); (""Poll"", ""The Poll method operates on the Deque class similarly to PollFirst, by removing an element."", ""Deque"")"
Here is an example of removing the last element from a Java Deque using the pollLast() method:,"(""Deque"", ""The pollLast method is used to remove the last element from a Deque."", ""pollLast"")"
The Java Deque size() method returns the number of elements stored in the Java Deque at the time you invoke the method.,"(""size()"", ""The size() method is a function that operates on the Java Deque class to return the number of elements stored in it."", ""Java Deque"")"
"Because the Iterator has its generic type set to String, the Java compiler already knows that next() will return a String.","(""Iterator"", ""The method next() is associated with the Iterator class as it is a common method used to retrieve elements from an iterator."", ""next()""); (""String"", ""The method next() is expected to return a String, indicating a relationship between the method and the String class."", ""next()""); (""Java"", ""The Iterator class is part of the Java package, which provides the context for its usage."", ""Iterator"")"
"As you can see, a proper implementation of .equals() is essential for your own classes to work well with the Java Collection classes.","(""EQUALS"", ""The method EQUALS is essential for the proper functioning of the CLASS."", ""CLASS""); (""CLASS"", ""The CLASS is intended to work well with the JAVA COLLECTION package."", ""JAVA COLLECTION"")"
"So, as you can see, a combination of the hashCode() and equals() methods are used when storing and when looking up objects in a hashtable.","(""hashCode"", ""Both methods are used together for storing and looking up objects in a hashtable."", ""equals""); (""hashCode"", ""The hashCode method is used in the process of storing and looking up objects in a hashtable."", ""hashtable""); (""equals"", ""The equals method is used in the process of storing and looking up objects in a hashtable."", ""hashtable"")"
"Then it uses a for-each loop to iterate the elements of the List, and print out the toString() value of each element.","(""List"", ""The toString method is called on each element of the List to get its string representation."", ""toString"")"
Here is an example of iterating the elements of an Iterable via its forEach() method:,"(""Iterable"", ""The forEach method is used to iterate over the elements of the Iterable class."", ""forEach"")"
"The reason the for-each loop is slower is, that each iteration will call the List iterator() method, which will create a new Iterator object.","(""iterator()"", ""The iterator() method is called on the List class."", ""List""); (""iterator()"", ""The iterator() method creates a new Iterator object."", ""Iterator"")"
"In other words, if the Iterator has not yet iterated over all of the elements in the collection the Iterator was obtained from - the hasNext() method will return true.","(""Iterator"", ""The hasNext method is a function that belongs to the Iterator class, used to check if there are more elements to iterate over."", ""hasNext"")"
The first three add() calls add a String instance to the end of the list.,"(""Add"", ""The method 'Add' is used to add a 'String' instance to the list."", ""String"")"
"The addAll() method takes a Collection as parameter, so you can pass either a List or Java Set as parameter.","(""addAll"", ""The addAll method takes a Collection as a parameter."", ""Collection""); (""addAll"", ""The addAll method can take a List as a parameter."", ""List""); (""addAll"", ""The addAll method can take a Java Set as a parameter."", ""Java Set"")"
"Notice that the get() method returns a Java Object, so we have to cast it to a String (because we know the value is a String).","(""GET"", ""The get() method returns a Java Object, indicating a functional relationship where the method's output is of the class type Java Object."", ""JAVA OBJECT""); (""JAVA OBJECT"", ""The Java Object is cast to a String, indicating a type conversion relationship where the object is expected to be of the class type String."", ""STRING"")"
"This example creates a Map and stores three values in it using the keys A, B and C. Then the example calls the Map getOrDefault() method, passing the String E as key, along with a default value - the String default value.","(""Map"", ""The getOrDefault method is called on the Map class."", ""getOrDefault""); (""getOrDefault"", ""The getOrDefault method uses a String as a key and a default value."", ""String"")"
Since the Map does not contain any object stored by the key E the given default value will be returned - which is the String default value passed as the last parameter to the getOrDefault() method.,"(""getOrDefault"", ""The getOrDefault method is used to retrieve values from the Map class."", ""Map""); (""String"", ""The String class is related to the getOrDefault method as it is the type of the default value parameter."", ""getOrDefault"")"
"As you can see, the key Iterator returns every key stored in a Java Map, one by one (one for each call to next()).","(""Iterator"", ""The Iterator class uses the next() method to return each key stored in a Java Map."", ""next""); (""Iterator"", ""The Iterator class is used to iterate over the keys stored in a Java Map."", ""Map"")"
The number of entries in a Java Map is also referred to as the Map size - hence the method name size() .,"(""Map"", ""The method size() is used to determine the number of entries in a Map, hence they are related."", ""size"")"
The isEmpty() method will return false if the Map instance contains 1 or more entries.,"(""ISEMPTY"", ""The isEmpty() method is related to the Map class because it operates on instances of the Map class to determine if they contain entries."", ""MAP"")"
Here is an example of creating an instance of the Java TreeMap class which implements the NavigableMap interface:,"(""TreeMap"", ""TreeMap implements the NavigableMap interface"", ""NavigableMap"")"
"The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys ""c"", ""d"" and ""e"", as these keys are considered equal to or larger than the parameter value ""c"" passed to the tailMap() method.","(""tailMap"", ""The tailMap method returns a SortedMap containing key-value pairs."", ""SortedMap""); (""tailMap"", ""The tailMap method operates on a NavigableMap to filter keys."", ""NavigableMap"")"
The lowerEntry() method in the NavigableMap interface returns the key + value pair for the highest key which is lower than the parameter value passed to the lowerEntry() method.,"(""LowerEntry"", ""The LowerEntry method is part of the NavigableMap interface."", ""NavigableMap"")"
"The pollFirstEntry() method returns and removes the ""first"" entry (key + value) in the NavigableMap or null if the map is empty.","(""PollFirstEntry"", ""The PollFirstEntry method operates on the NavigableMap class by returning and removing the first entry from it."", ""NavigableMap"")"
"The descendingIterator() method allows you to iterate the elements of the NavigableSet (which is also a SortedSet) in reverse order, without changing the order of the elements internally.","(""DescendingIterator"", ""The DescendingIterator method is used to iterate over the elements of the NavigableSet in reverse order."", ""NavigableSet""); (""NavigableSet"", ""NavigableSet is a type of SortedSet."", ""SortedSet"")"
"To get properties from a Java Properties object you use the getProperty() method, passing the key of the property to get as parameter.","(""Properties"", ""The getProperty method is used to retrieve properties from a Properties object."", ""getProperty"")"
"Using the InputStream you can load the file into a Java Properties instance, using either the load() or loadFromXML() methods explained earlier in this Java Properties tutorial.","(""InputStream"", ""The InputStream class is used to load data into a Java Properties instance."", ""Java Properties""); (""load"", ""The load method is used to load data into a Java Properties instance."", ""Java Properties""); (""loadFromXML"", ""The loadFromXML method is used to load data into a Java Properties instance."", ""Java Properties""); (""Java Properties tutorial"", ""The Java Properties tutorial explains how to use the Java Properties class."", ""Java Properties"")"
Here are two examples of taking an element from a Java Queue using its poll() and remove() methods:,"(""Queue"", ""The poll() method is used to take an element from a Java Queue."", ""poll()""); (""Queue"", ""The remove() method is used to take an element from a Java Queue."", ""remove()"")"
You can check if a Java Queue contains a certain element via its contains() method.,"(""Queue"", ""The 'contains' method is used to check if a 'Queue' contains a certain element."", ""contains"")"
The Java Set interface as a method called removeAll() which removes all elements in the Set which are also present in another Collection.,"(""Set"", ""The removeAll method is a function that operates on the Set class."", ""removeAll""); (""removeAll"", ""The removeAll method removes elements from the Set that are also present in another Collection."", ""Collection"")"
You can check the size of a Java Set using the size() method.,"(""Set"", ""The size() method is used to check the size of a Set class in Java."", ""size()"")"
"You iterate the keys of a SortedMap by calling its keySet() method, like this:","(""SortedMap"", ""The keySet method is called on the SortedMap class to iterate its keys."", ""keySet"")"
The SortedMap interface has a method named headMap() which returns a new Map which contains the first elements of the SortedMap according to the sort order used.,"(""SortedMap"", ""The headMap method is a part of the SortedMap interface."", ""headMap""); (""headMap"", ""The headMap method returns a new Map."", ""Map"")"
Here is an example of obtaining a submap from a Java SortedMap via its subMap() method:,"(""SortedMap"", ""The subMap() method is used to obtain a submap from a SortedMap, indicating a functional relationship between the class and the method."", ""subMap"")"
The Java Collections API only has one implementation of the Java SortedSet interface - the java.util.TreeSet class.,"(""Java Collections API"", ""The Java Collections API includes the Java SortedSet interface."", ""Java SortedSet""); (""Java SortedSet"", ""The java.util.TreeSet class is an implementation of the Java SortedSet interface."", ""java.util.TreeSet"")"
"Additionally, the Vector class uses several older (no longer recommended) parts of Java, like the Enumeration which is superseded by the Iterator interface.","(""Vector"", ""The Vector class uses the Enumeration class, indicating a relationship where Vector relies on Enumeration for certain functionalities."", ""Enumeration""); (""Enumeration"", ""The Enumeration class is superseded by the Iterator class, indicating a relationship where Iterator is the modern replacement for Enumeration."", ""Iterator""); (""Vector"", ""The Vector class is a part of the Java package, indicating a relationship where Vector is a component of Java."", ""Java"")"
You push elements onto a Java Stack using its push() method.,"(""Java Stack"", ""The push() method is used to add elements to the Java Stack class."", ""push()"")"
Here is an example of obtaining the size of a Java Stack via its size() method:,"(""Stack"", ""The size() method is used to obtain the size of a Stack, indicating a functional relationship between the class and the method."", ""size()"")"
The lockWrite() method of a ReadWriteLock class shown below is an example of a test-and-set method.,"(""LOCKWRITE"", ""The LOCKWRITE method is a part of the READWRITELOCK class."", ""READWRITELOCK"")"
The BoundedSemaphore class shown below has two test-and-set methods: take() and release().,"(""BoundedSemaphore"", ""The method 'take' is a test-and-set method of the 'BoundedSemaphore' class."", ""take""); (""BoundedSemaphore"", ""The method 'release' is a test-and-set method of the 'BoundedSemaphore' class."", ""release"")"
Here is an example showing how to implement the lock() method shown earlier using the AtomicBoolean class:,"(""LOCK"", ""The LOCK method is implemented using the ATOMICBOOLEAN class."", ""ATOMICBOOLEAN"")"
"a stop() or pause() method too), then you can no longer create your Runnable implementation with a Java lambda expression.","(""Runnable"", ""Runnable is a class that can be implemented using Java, which is a programming language package."", ""Java""); (""stop"", ""The stop method can be used within a Runnable implementation."", ""Runnable""); (""pause"", ""The pause method can be used within a Runnable implementation."", ""Runnable"")"
"If a thread (1) calls the parent.addChild(child) method at the same time as another thread (2) calls the child.setParent(parent) method, on the same parent and child instances, a deadlock can occur.","(""ADDCHILD"", ""Both methods are called on the same parent and child instances, potentially causing a deadlock."", ""SET_PARENT"")"
"Here are the two classes used in the example above, Counter and CounterThread.","(""Counter"", ""CounterThread is likely related to Counter as it may use or extend the functionality of the Counter class."", ""CounterThread"")"
"The easiest way to create a subclass of ThreadLocal is to simply create an anonymous subclass, right where you create the ThreadLocal variable.","(""subclass"", ""A subclass is a specialized version of the ThreadLocal class."", ""ThreadLocal""); (""ThreadLocal"", ""ThreadLocal can have subclasses, which are derived from it."", ""subclass"")"
"Here is an example of creating a ThreadLocal using its withInitial() static factory method, passing a simple Supplier implementation as parameter:","(""ThreadLocal"", ""The method withInitial is a static factory method used to create an instance of the class ThreadLocal."", ""withInitial""); (""withInitial"", ""The method withInitial takes a Supplier implementation as a parameter."", ""Supplier"")"
Notice how the format() method calls the getThreadLocalSimpleDateFormat() method to obtain a Java SimpleDatFormat instance.,"(""FORMAT"", ""The format() method calls the getThreadLocalSimpleDateFormat() method."", ""GETTHREADLOCALSIMPLEDATEFORMAT""); (""GETTHREADLOCALSIMPLEDATEFORMAT"", ""The getThreadLocalSimpleDateFormat() method obtains a SimpleDatFormat instance."", ""SIMPLEDATFORMAT"")"
"The Counter class could have been written like this instead, using a Lock instead of a synchronized block:","(""Counter"", ""The Counter class uses a Lock instead of a synchronized block, indicating a relationship where Lock is used within Counter."", ""Lock"")"
"While isLocked is true, the thread calling lock() is parked waiting in the wait() call.","(""lock"", ""The lock() method is related to the isLocked class because it checks the lock status."", ""isLocked""); (""wait"", ""The wait() method is related to the lock() method because it is used to park the thread while waiting for the lock."", ""lock"")"
"When the thread is done with the code in the critical section (the code between lock() and unlock()), the thread calls unlock().","(""Lock"", ""The methods Lock and Unlock are related as they are used to manage access to a critical section of code, with Lock being called before entering and Unlock after exiting."", ""Unlock"")"
"Otherwise, a single call to unlock() will unlock the lock, even if the lock has been locked multiple times.","(""UNLOCK"", ""The method UNLOCK is used to unlock the LOCK class."", ""LOCK"")"
"That you would not call wait() and notify() on an internal monitor object, but rather on the This is probably true.",
This is how such exclusive access could look using a synchronized block in Java: public class SynchronizedCounter { long count = 0; public void inc() { synchronized(this) { count++; } } public long count() { synchronized(this) { return this.count; } } } Notice how the inc() and count() methods both contain a synchronized block.,"(""SynchronizedCounter"", ""The method 'inc' is a member of the class 'SynchronizedCounter'."", ""inc""); (""SynchronizedCounter"", ""The method 'count' is a member of the class 'SynchronizedCounter'."", ""count""); (""inc"", ""Both 'inc' and 'count' methods contain a synchronized block, indicating they are related in terms of thread safety operations within the 'SynchronizedCounter' class."", ""count"")"
"import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicStampedReference; public class NonblockingTemplate { public static class IntendedModification { public AtomicBoolean completed = new AtomicBoolean(false); } private AtomicStampedReference<IntendedModification> ongoingMod = new AtomicStampedReference<IntendedModification>(null, 0); //declare the state of the data structure here.","(""NonblockingTemplate"", ""IntendedModification is a nested class within NonblockingTemplate."", ""IntendedModification""); (""IntendedModification"", ""completed is a method within the IntendedModification class."", ""completed""); (""NonblockingTemplate"", ""ongoingMod is a field within the NonblockingTemplate class, using AtomicStampedReference."", ""ongoingMod""); (""AtomicStampedReference"", ""AtomicStampedReference is used to reference IntendedModification."", ""IntendedModification"")"
Here is how the lockRead() and unlockRead() methods looks after that change:,"(""LOCKREAD"", ""Both are methods mentioned in the context of a change."", ""UNLOCKREAD"")"
Here is how the lockWrite() and unlockWrite() methods look after that change:,"(""lockWrite"", ""Both are methods mentioned in the context of a change."", ""unlockWrite"")"
"You can read more about it in the java.util.concurrent.Semaphore text, in my java.util.concurrent tutorial.","(""Java.util.concurrent.Semaphore"", ""Java.util.concurrent.Semaphore is a class within the Java.util.concurrent package"", ""Java.util.concurrent"")"
The take() method sends a signal which is stored internally in the Semaphore.,"(""Take"", ""The take() method is associated with the Semaphore class as it sends a signal stored internally within it."", ""Semaphore"")"
"That way the signal is not missed, even if doNotify() is called before doWait().","(""doNotify"", ""doNotify and doWait are related because they are both methods that likely interact in a signaling mechanism."", ""doWait"")"
"If you look at the Synchronizer class above and look into this Lock implementation you will notice that threads are now blocked trying to access the lock() method, if more than one thread calls lock() simultanously.","(""Synchronizer"", ""The lock() method is part of the Synchronizer class, as it is mentioned in the context of the Synchronizer class."", ""lock""); (""Lock"", ""The lock() method is part of the Lock class implementation, as it is mentioned in the context of this Lock implementation."", ""lock"")"
"The thread calling unlock() will take the top QueueObject in the queue and call doNotify() on it, to awaken the thread waiting on that object.","(""Unlock"", ""The method Unlock interacts with the QueueObject by taking the top object from the queue."", ""QueueObject""); (""Unlock"", ""The method Unlock calls the method DoNotify to awaken the thread."", ""DoNotify""); (""QueueObject"", ""The method DoNotify is called on the QueueObject to awaken the thread waiting on it."", ""DoNotify"")"
"The queueObject.doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout, so another thread can actually call unlock() when no thread is executing inside the synchronized(this) block in lock() method.","(""QueueObject"", ""The method DoWait is called on the QueueObject class."", ""DoWait""); (""QueueObject"", ""The method Unlock can be called on the QueueObject class."", ""Unlock""); (""QueueObject"", ""The method Lock is associated with the QueueObject class."", ""Lock""); (""Lock"", ""The DoWait method is mentioned in the context of the Lock method."", ""DoWait""); (""Lock"", ""The Unlock method is mentioned in the context of the Lock method."", ""Unlock"")"
"Below here is the PoolThreadRunnable class which implements the Runnable interface, so it can be executed by a Java thread:","(""PoolThreadRunnable"", ""PoolThreadRunnable implements the Runnable interface, indicating a relationship where PoolThreadRunnable is a type of Runnable."", ""Runnable"")"
"Notice how the add() method returns a new ImmutableValue instance with the result of the add operation, rather than adding the value to itself.","(""Add"", ""The Add method returns a new instance of the ImmutableValue class."", ""ImmutableValue"")"
"The class java.lang.Object defines three methods, wait(), notify(), and notifyAll(), to facilitate this.","(""Java.lang.Object"", ""The method Wait() is defined within the class Java.lang.Object."", ""Wait()""); (""Java.lang.Object"", ""The method Notify() is defined within the class Java.lang.Object."", ""Notify()""); (""Java.lang.Object"", ""The method NotifyAll() is defined within the class Java.lang.Object."", ""NotifyAll()"")"
"In other words, the calling thread must call wait() or notify() from inside a synchronized block.","(""Wait"", ""Both Wait and Notify are methods that are typically used together in synchronized blocks for thread communication."", ""Notify"")"
The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called.,"(""Notify"", ""Both are methods that deal with thread notification."", ""NotifyAll"")"
"If the doNotify() method had called notifyAll() instead of notify(), all waiting threads had been awakened and checked for signals in turn.","(""doNotify"", ""The doNotify method calls the notifyAll method."", ""notifyAll""); (""doNotify"", ""The doNotify method calls the notify method."", ""notify"")"
"The other of C and D would go back to waiting, because the thread discovering the signal clears it on the way out of doWait().","(""doWait"", ""The method doWait is likely associated with the class C as it is mentioned in the context of thread signaling and waiting."", ""C""); (""doWait"", ""The method doWait is likely associated with the class D as it is mentioned in the context of thread signaling and waiting."", ""D"")"
"The method compareAndSet() allows you to compare the current value of the AtomicBoolean to an expected value, and if current value is equal to the expected value, a new value can be set on the AtomicBoolean.","(""CompareAndSet"", ""The method CompareAndSet is used to operate on the AtomicBoolean class by comparing and setting its value."", ""AtomicBoolean"")"
"The AtomicInteger class provides you with a int variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().","(""AtomicInteger"", ""The method compareAndSet is an advanced atomic operation provided by the AtomicInteger class."", ""compareAndSet"")"
You can get the value of an AtomicInteger instance via the get() method.,"(""AtomicInteger"", ""The get() method is used to retrieve the value of an AtomicInteger instance."", ""get"")"
Calling addAndGet() is also an atomic operation (like all operations on the AtomicIntegerArray).,"(""addAndGet"", ""The method addAndGet is an operation that can be performed on the class AtomicIntegerArray."", ""AtomicIntegerArray"")"
You should check out the JavaDoc for the AtomicIntegerArray class to learn more about those methods.,"(""AtomicIntegerArray"", ""The JavaDoc package provides documentation for the AtomicIntegerArray class."", ""JavaDoc"")"
"The AtomicLong class provides you with a long variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().","(""AtomicLong"", ""The compareAndSet method is an advanced atomic operation provided by the AtomicLong class."", ""compareAndSet"")"
You can set the value of an AtomicLong instance via the set() method.,"(""AtomicLong"", ""The set() method is used to set the value of an AtomicLong instance."", ""set"")"
The Java AtomicLongArray class (java.util.concurrent.atomic.AtomicLongArray) represents an array of long .,"(""AtomicLongArray"", ""The AtomicLongArray class is part of the java.util.concurrent.atomic package."", ""java.util.concurrent.atomic"")"
You can get the value of a given element using the get() method on the AtomicLongArray.,"(""Get"", ""The get() method is used on the AtomicLongArray class to retrieve the value of a given element."", ""AtomicLongArray"")"
You can set the value of a given element using the set() method on the AtomicLongArray.,"(""Set"", ""The set() method is used on the AtomicLongArray class to set the value of a given element."", ""AtomicLongArray"")"
"AtomicReference even has an advanced compareAndSet() method which lets you compare the reference to an expected value (reference) and if they are equal, set a new reference inside the AtomicReference object.","(""AtomicReference"", ""The compareAndSet method is a function provided by the AtomicReference class."", ""compareAndSet"")"
Notice how it is no longer necessary to cast the referenced returned by get() because the compiler knows it will return a String reference.,"(""GET"", ""The method GET returns a reference of type STRING, indicating a relationship between the method and the class."", ""STRING"")"
"The compareAndSet() method can compare the reference stored in the AtomicReference instance with an expected reference, and if they two references are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicReference instance.","(""compareAndSet"", ""The compareAndSet method is used to compare and set references within an AtomicReference instance."", ""AtomicReference"")"
If you have a typed AtomicStampedReference then getReference() returns a reference to the type you declared on the AtomicStampedReference variable when you created it.,"(""AtomicStampedReference"", ""The method getReference() is used to retrieve a reference from an AtomicStampedReference object."", ""getReference"")"
The AtomicStampedReference also contains a getStamp() method which can be used to obtain the internally stored stamp.,"(""AtomicStampedReference"", ""The getStamp method is a part of the AtomicStampedReference class."", ""getStamp"")"
"The compareAndSet() method can compare the reference stored in the AtomicStampedReference instance with an expected reference, and the stored stamp with an expected stamp, and if they two references and stamps are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicStampedReference instance.","(""compareAndSet()"", ""The compareAndSet() method is used to compare and set references within an AtomicStampedReference instance."", ""AtomicStampedReference""); (""compareAndSet()"", ""The compareAndSet() method uses a comparison similar to the equals() method, but checks for reference identity (==) rather than equality."", ""equals()""); (""compareAndSet()"", ""The compareAndSet() method uses the == operator to compare references for identity."", ""==""); (""equals()"", ""The equals() method is contrasted with the == operator in the context of reference comparison."", ""=="")"
"The BlockingDeque interface in the java.util.concurrent class represents a deque which is thread safe to put into, and take instances from.","(""BlockingDeque"", ""The BlockingDeque class is part of the java.util.concurrent package, which provides concurrency utilities."", ""java.util.concurrent"")"
"The ConcurrentMap has a few extra atomic methods in addition to the methods it inherits from its superinterface, java.util.Map.","(""ConcurrentMap"", ""ConcurrentMap contains methods, including atomic ones."", ""methods""); (""ConcurrentMap"", ""ConcurrentMap inherits methods from the java.util.Map package."", ""java.util.Map"")"
"The java.util.concurrent.ConcurrentNavigableMap class is a java.util.NavigableMap with support for concurrent access, and which has concurrent access enabled for its submaps.","(""ConcurrentNavigableMap"", ""ConcurrentNavigableMap is a subclass of NavigableMap."", ""NavigableMap""); (""ConcurrentNavigableMap"", ""ConcurrentNavigableMap is part of the java.util.concurrent package."", ""java.util.concurrent""); (""NavigableMap"", ""NavigableMap is part of the java.util package."", ""java.util"")"
"First, the BlockingQueueExample class which starts a Producer and a Consumer in separate threads.","(""BlockingQueueExample"", ""The BlockingQueueExample class starts a Producer in a separate thread."", ""Producer""); (""BlockingQueueExample"", ""The BlockingQueueExample class starts a Consumer in a separate thread."", ""Consumer"")"
The Java BlockingQueue add() method will add the element passed as parameter to this method if the BlockingQueue has space for it internally.,"(""BlockingQueue"", ""The add() method is a function that operates on the BlockingQueue class to add elements to it."", ""add"")"
"If the BlockingQueue does not have space internally for this new element, the add() method throws an IllegalStateException.","(""add()"", ""The add() method throws an IllegalStateException when the BlockingQueue does not have space for a new element."", ""IllegalStateException""); (""BlockingQueue"", ""The add() method is used with the BlockingQueue to add new elements."", ""add()"")"
The remove() method will use the o.equals(element) to decide if the object o passed as parameter matches a given element in the BlockingQueue.,"(""Remove"", ""The remove() method uses the equals() method to compare objects."", ""Equals""); (""Remove"", ""The remove() method is used in the context of the BlockingQueue class."", ""BlockingQueue"")"
"If the BlockingQueue does not contain any elements, the element() method will throw a NoSuchElementException.","(""BlockingQueue"", ""The element() method is used with the BlockingQueue class to retrieve elements."", ""element()""); (""element()"", ""The element() method throws a NoSuchElementException if the BlockingQueue is empty."", ""NoSuchElementException"")"
The result of that is that the call() method will return a String.,"(""CALL"", ""The CALL method returns a STRING, indicating a functional relationship where the method's output is of type STRING."", ""STRING"")"
"The Java ExecutorService interface, java.util.concurrent.ExecutorService, represents an asynchronous execution mechanism which is capable of executing tasks concurrently in the background.","(""ExecutorService"", ""ExecutorService is part of the java.util.concurrent package, as indicated by the package name prefix."", ""java.util.concurrent"")"
"The Java ExecutorService execute(Runnable) method takes a java.lang.Runnable object, and executes it asynchronously.","(""ExecutorService"", ""The execute method is a part of the ExecutorService class."", ""execute""); (""execute"", ""The execute method takes a Runnable object as a parameter."", ""Runnable""); (""Runnable"", ""The Runnable class is part of the java.lang package."", ""java.lang"")"
"The invokeAny() method takes a collection of Callable objects, or subinterfaces of Callable.","(""InvokeAny"", ""The InvokeAny method takes a collection of Callable objects, indicating a functional relationship where InvokeAny operates on Callable instances."", ""Callable"")"
The invokeAll() method invokes all of the Callable objects you pass to it in the collection passed as parameter.,"(""InvokeAll"", ""The InvokeAll method is used to invoke all of the Callable objects passed to it."", ""Callable"")"
The main difference between the Runnable run() method and the Callable call() method is that the call() method can return an Object from the method call.,"(""Runnable"", ""The run() method is associated with the Runnable class."", ""run()""); (""Callable"", ""The call() method is associated with the Callable class."", ""call()""); (""run()"", ""Both run() and call() are methods that are compared in terms of their functionality."", ""call()"")"
"The ExecutorService awaitTermination() method will block the thread calling it until either the ExecutorService has shutdown completely, or until a given time out occurs.","(""ExecutorService"", ""The awaitTermination method is a function that operates on the ExecutorService class, blocking the thread until the ExecutorService has shut down or a timeout occurs."", ""awaitTermination"")"
The awaitTermination() method is typically called after calling shutdown() or shutdownNow().,"(""AwaitTermination"", ""The awaitTermination() method is typically called after calling the shutdown() method."", ""Shutdown""); (""AwaitTermination"", ""The awaitTermination() method is typically called after calling the shutdownNow() method."", ""ShutdownNow"")"
In the following sections I will explain how to use the ReentrantLock class as a Lock.,"(""ReentrantLock"", ""ReentrantLock is a class that is used as a Lock."", ""Lock"")"
To unlock the Lock instance you must call its unlock() method.,"(""Lock"", ""The unlock method is used to unlock the Lock class instance."", ""unlock"")"
"To better understand how using a Lock looks different from using a synchronized block, I have created two simple concurrent Counter classes which protects their internal count in different ways.","(""Lock"", ""The Lock class is used to protect the internal count in the Counter class, indicating a relationship where Lock provides synchronization functionality to Counter."", ""Counter"")"
"Notice how the calculate() method both locks the Calculator instance's Lock before performing any calculations, and also call the add() and subtract() methods which also locks the lock.","(""Calculate"", ""The Calculate method is associated with the Calculator class as it operates on its instance."", ""Calculator""); (""Calculate"", ""The Calculate method locks the Lock class instance before performing calculations."", ""Lock""); (""Add"", ""The Add method locks the Lock class instance when called."", ""Lock""); (""Subtract"", ""The Subtract method locks the Lock class instance when called."", ""Lock"")"
"If the Lock instance is already locked, the thread calling lock() is blocked until the Lock is unlocked.","(""Lock"", ""The method lock() is associated with the Lock class as it is used to lock the Lock instance."", ""lock""); (""Lock"", ""The Lock class is mentioned in the context of being locked and unlocked, indicating its role in the locking mechanism."", ""Lock"")"
The Java ReentrantLock getHoldCount() method returns the number of times a given thread has locked this Lock instance.,"(""ReentrantLock"", ""The getHoldCount() method is a member of the ReentrantLock class."", ""getHoldCount""); (""getHoldCount"", ""The getHoldCount() method operates on a Lock instance."", ""Lock"")"
"The Java CertPath class (java.security.cert.CertPath represents a chain of cryptographic identity certificates (Java Certificate objects), where each certificate is the digital signer of the next certificate in the chain.","(""CertPath"", ""CertPath is a class within the java.security.cert package"", ""java.security.cert"")"
The CertPath getType() method returns a string telling what type of certificates (e.g.,"(""CertPath"", ""The getType method is a function that belongs to the CertPath class, indicating it operates on or is associated with CertPath."", ""getType"")"
If you want to set a different offset for the dest byte array there is a version of update() and doFinal() which takes an offset parameter extra.,"(""update"", ""Both methods have a version that takes an offset parameter for the destination byte array."", ""doFinal"")"
Notice the call to update() and then doFinal() for these two blocks of data.,"(""UPDATE"", ""The methods UPDATE and DOFINAL are called sequentially to process blocks of data."", ""DOFINAL"")"
To generate an asymmetric key pair you can use the KeyPairGenerator (java.security.KeyPairGenerator).,"(""KeyPairGenerator"", ""KeyPairGenerator is part of the java.security.KeyPairGenerator package"", ""java.security.KeyPairGenerator"")"
You create a KeyGenerator instance by calling the static method getInstance() passing as parameter the name of the encryption algorithm to create a key for.,"(""KeyGenerator"", ""The method getInstance() is used to create an instance of the KeyGenerator class."", ""getInstance"")"
Initializing a KeyGenerator instance is done by calling its init() method.,"(""KeyGenerator"", ""The init() method is used to initialize an instance of the KeyGenerator class."", ""init"")"
Generating a key is done by calling the KeyGenerator generateKey() method.,"(""KeyGenerator"", ""The generateKey method is a function of the KeyGenerator class."", ""generateKey"")"
You can access the PublicKey of a KeyPair by calling its getPublic() method.,"(""KeyPair"", ""The getPublic method is called on a KeyPair to access its PublicKey."", ""getPublic""); (""getPublic"", ""The getPublic method returns a PublicKey."", ""PublicKey"")"
You can access the PrivateKey of a KeyPair by calling the getPrivate() method.,"(""KeyPair"", ""The PrivateKey is a component of the KeyPair."", ""PrivateKey""); (""getPrivate"", ""The getPrivate() method is used to access the PrivateKey."", ""PrivateKey""); (""getPrivate"", ""The getPrivate() method is called on a KeyPair to retrieve its PrivateKey."", ""KeyPair"")"
You can create a Java KeyStore instance by calling its getInstance() method.,"(""Java KeyStore"", ""The getInstance method is called on the Java KeyStore class to create an instance."", ""getInstance"")"
This Keytool -delete command will remove the KeyStore entry with the alias testkey from the KeyStore stored in the file keystore.jks .,"(""Keytool"", ""The delete method is a command used by the Keytool class."", ""delete""); (""KeyStore"", ""The KeyStore class is stored in the keystore.jks package."", ""keystore.jks"")"
"You create a digital signature by calling the update() method one or more times, finishing with a call to sign().","(""UPDATE"", ""The UPDATE method is used in conjunction with the SIGN method to create a digital signature."", ""SIGN"")"
"If you need to read and write the date and time to a database, use the java.sql.Date and java.sql.Timestamp classes.","(""Java.Sql.Date"", ""Both classes are used for handling date and time in database operations."", ""Java.Sql.Timestamp"")"
Here is an example of how to create a Duration object using the between() method:,"(""Duration"", ""The between() method is used to create a Duration object."", ""between"")"
Here is an example that shows how to create a LocalDateTime object via the now() method:,"(""now"", ""The now() method is used to create a LocalDateTime object."", ""LocalDateTime"")"
The LocalTime class in the Java 8 date time API represents a specific time of day without any time zone information.,"(""LocalTime"", ""The LocalTime class is part of the Java 8 date time API package."", ""Java 8 date time API"")"
The parameter passed to the of() method is the ID of the time zone to create a ZoneId for.,"(""OF"", ""The of() method is used to create a ZoneId."", ""ZONEID"")"
"If you need to set a date on a java.sql.PreparedStatement or get a date from a java.sql.ResultSet, you will interact with java.sql.Date.","(""PreparedStatement"", ""PreparedStatement is part of the java.sql package"", ""java.sql""); (""ResultSet"", ""ResultSet is part of the java.sql package"", ""java.sql""); (""Date"", ""Date is part of the java.sql package"", ""java.sql""); (""PreparedStatement"", ""PreparedStatement can be used to set a Date"", ""Date""); (""ResultSet"", ""ResultSet can be used to get a Date"", ""Date"")"
One difference in the java.sql.Timestamp from its superclass java.util.Date is its ability to hold the nanoseconds of a date too.,"(""Java.sql.Timestamp"", ""Java.sql.Timestamp is a subclass of Java.util.Date, indicating an inheritance relationship."", ""Java.util.Date"")"
You can get and set the nanoseconds using the getNanos() and setNanos().,"(""GETNANOS"", ""Both methods are used to manipulate the nanoseconds value."", ""SETNANOS"")"
The Calendar class has a corresponding set() method so you can set these fields too.,"(""Calendar"", ""The set method is associated with the Calendar class as it allows setting fields within the class."", ""set"")"
"You can access the date and time contained in a java.util.Date instance using the getTime() method, like this:","(""Java.Util.Date"", ""The GetTime method is used to access the date and time contained in a Java.Util.Date instance."", ""GetTime"")"
You can compare java.util.Date instance because the class implements the java.lang.Comparable interface.,"(""Java.Util.Date"", ""Java.Util.Date implements the Java.Lang.Comparable interface"", ""Java.Lang.Comparable"")"
The java.util.TimeZone class is used in conjunction with the java.util.Calendar class.,"(""TimeZone"", ""The TimeZone class is part of the java.util package."", ""java.util""); (""Calendar"", ""The Calendar class is part of the java.util package."", ""java.util""); (""TimeZone"", ""The TimeZone class is used in conjunction with the Calendar class."", ""Calendar"")"
As you can see the readNumberFromUrl() needs to declare throwing both the BadUrlException and the BadNumberException that are thrown from the readDataFromUrl() and converData() methods.,"(""readNumberFromUrl"", ""The method readNumberFromUrl() declares throwing the BadUrlException."", ""BadUrlException""); (""readNumberFromUrl"", ""The method readNumberFromUrl() declares throwing the BadNumberException."", ""BadNumberException""); (""readDataFromUrl"", ""The method readDataFromUrl() throws the BadUrlException."", ""BadUrlException""); (""readDataFromUrl"", ""The method readDataFromUrl() throws the BadNumberException."", ""BadNumberException""); (""converData"", ""The method converData() throws the BadNumberException."", ""BadNumberException"")"
As you can see the readNumberFromUrl() method now only declares throwing ApplicationException.,"(""ReadNumberFromUrl"", ""The method ReadNumberFromUrl declares throwing the class ApplicationException."", ""ApplicationException"")"
"In the example with FileNotFoundException, if you catch IOException which is the superclass of FileNotFoundException, you will also catch FileNotFoundException.","(""IOException"", ""IOException is the superclass of FileNotFoundException, indicating an inheritance relationship."", ""FileNotFoundException"")"
"If the input.close() call fails, and an IOException is thrown, then it is caught, wrapped and rethrown.","(""input.close()"", ""The method input.close() can throw an IOException if it fails."", ""IOException"")"
The Throwable class has a method named addSuppressed() which takes a Throwable object as parameter.,"(""Throwable"", ""The addSuppressed method is a member of the Throwable class."", ""addSuppressed"")"
The applyPattern() method simply applies a new pattern to the DecimalFormat instance as if it were created with that pattern.,"(""ApplyPattern"", ""The ApplyPattern method is used to apply a new pattern to an instance of the DecimalFormat class."", ""DecimalFormat"")"
The applyLocalizedPattern() does the same as applyPattern() except it interpretes the characters in the pattern according to the Locale the DecimalFormat was created with.,"(""applyLocalizedPattern"", ""applyLocalizedPattern is related to applyPattern as it performs a similar function with a difference in character interpretation."", ""applyPattern""); (""applyLocalizedPattern"", ""applyLocalizedPattern uses Locale to interpret characters in the pattern."", ""Locale""); (""DecimalFormat"", ""DecimalFormat is created with a specific Locale, which affects how patterns are interpreted."", ""Locale"")"
"To sort a collection of strings according to the rules of a certain Locale, you use a java.text.Collator instance created for that specific Locale.","(""Collator"", ""A Collator instance is created for a specific Locale to sort strings according to its rules."", ""Locale""); (""Collator"", ""Collator is part of the java.text package."", ""java.text"")"
The factory method Locale.forLanguageTag() can also be used to create a Locale instance.,"(""forLanguageTag"", ""The method forLanguageTag is used to create an instance of the class Locale."", ""Locale"")"
Finally you can access the localized values in the ResourceBundle via its different getString() and getObject() etc.,"(""ResourceBundle"", ""The getString method is used to access localized values in the ResourceBundle class."", ""getString""); (""ResourceBundle"", ""The getObject method is used to access localized values in the ResourceBundle class."", ""getObject"")"
For this example to work you should put a standard Java property file named MyBundle.properties in a Java package named i18n.,"(""MyBundle.properties"", ""The class MyBundle.properties is located within the package i18n."", ""i18n"")"
Once you have created a SimpleDateFormat instance you can format dates using its format() method.,"(""SimpleDateFormat"", ""The format method is used by the SimpleDateFormat class to format dates."", ""format"")"
The Date instance passed to the format() method is a java.util.Date instance.,"(""format"", ""The format method takes a Date instance as an argument."", ""Date""); (""Date"", ""Date is an instance of the java.util.Date class."", ""java.util.Date"")"
"The Java SimpleDateFormat class is also capable of formatting a Date object into a StringBuffer, instead of returning an individual String with the date formatted.","(""SimpleDateFormat"", ""The SimpleDateFormat class is used to format Date objects."", ""Date""); (""SimpleDateFormat"", ""The SimpleDateFormat class can format a Date object into a StringBuffer."", ""StringBuffer""); (""SimpleDateFormat"", ""The SimpleDateFormat class can return a formatted date as a String."", ""String"")"
You can parse a String into a java.util.Date instance using the parse() method of the SimpleDateFormat instance.,"(""parse()"", ""The parse() method is used by the SimpleDateFormat class to parse a String into a java.util.Date instance."", ""SimpleDateFormat""); (""String"", ""A String is parsed into a java.util.Date instance using the parse() method."", ""java.util.Date""); (""SimpleDateFormat"", ""The SimpleDateFormat class is used to create a java.util.Date instance from a String."", ""java.util.Date"")"
You can set the time zone of a SimpleDateFormat using its setTimeZone() method.,"(""SimpleDateFormat"", ""The setTimeZone method is used to set the time zone of a SimpleDateFormat class."", ""setTimeZone"")"
"In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not, but the BufferedInputStream supports them.","(""MarkSupported"", ""The MarkSupported method is used to check if the Mark method is supported."", ""Mark""); (""MarkSupported"", ""The MarkSupported method is used to check if the Reset method is supported."", ""Reset""); (""BufferedInputStream"", ""The BufferedInputStream class supports the Mark method."", ""Mark""); (""BufferedInputStream"", ""The BufferedInputStream class supports the Reset method."", ""Reset""); (""MarkSupported"", ""The MarkSupported method is used to check support on a given InputStream."", ""InputStream""); (""Mark"", ""The Mark method is used on an InputStream."", ""InputStream""); (""Reset"", ""The Reset method is used on an InputStream."", ""InputStream"")"
"After that, the while loop exits, and the BufferedInputStream close() method is called.","(""BufferedInputStream"", ""The close method is called on the BufferedInputStream class."", ""close"")"
"The setSource() method actually returns a reference to the ReusableBufferedInputStream, so you can actually create a ReusableBufferedInputStream and set the source in a single instruction:","(""setSource"", ""The setSource() method returns a reference to the ReusableBufferedInputStream class."", ""ReusableBufferedInputStream"")"
To write data to a Java BufferedOutputStream you can use its write() method.,"(""BufferedOutputStream"", ""The write method is used to write data to a BufferedOutputStream."", ""write"")"
If you want to make sure that all written data is written to disk without having to close the BufferedOutputStream you can call its flush() method.,"(""BufferedOutputStream"", ""The flush method is a function that can be called on the BufferedOutputStream class to ensure all written data is flushed to disk."", ""flush"")"
"Once the try block is exited, the close() method of the BufferedOutputStream is called automatically, because the BufferedOutputStream was declared inside the parentheses of the try block.","(""BufferedOutputStream"", ""The close method is called on the BufferedOutputStream class."", ""close"")"
"The Java BufferedReader class is a subclass of the Java Reader class, so you can use a BufferedReader anywhere a Reader is required.","(""BufferedReader"", ""BufferedReader is a subclass of Reader, indicating an inheritance relationship."", ""Reader"")"
"The Java BufferedReader class also has a read() method that takes a char array as parameter, as well as a start offset and length.","(""BufferedReader"", ""The read method is a function of the BufferedReader class."", ""read"")"
The Java BufferedReader has a special read method named readLine() which reads a full line of text from the BufferedReader's internal buffer.,"(""BufferedReader"", ""The readLine method is a function of the BufferedReader class, used to read a full line of text from its internal buffer."", ""readLine"")"
The Java BufferedWriter's flush() method flushes all data written to the BufferedWriter to the underlying data destination.,"(""BufferedWriter"", ""The flush() method is a function that operates on the BufferedWriter class."", ""flush()""); (""flush()"", ""The flush() method is specifically designed to work with the BufferedWriter class to flush data."", ""BufferedWriter"")"
The mark() method of the ByteArrayInputStream class sets an internal mark at the current byte position - meaning right after the previous byte read.,"(""Mark"", ""The mark() method is a function of the ByteArrayInputStream class."", ""ByteArrayInputStream"")"
"Since the Java ByteArrayOutputStream class is a subclass of the Java OutputStream class, you write bytes to it using the same write methods that OutputStream has:","(""ByteArrayOutputStream"", ""ByteArrayOutputStream is a subclass of OutputStream"", ""OutputStream""); (""write"", ""The write method is used to write bytes to OutputStream"", ""OutputStream"")"
"Once you have finished writing to the ByteArrayOutputStream you can obtain all the bytes written as a Java byte array, using the ByteArrayOutputStream toByteArray() method.","(""ByteArrayOutputStream"", ""The toByteArray method is a function of the ByteArrayOutputStream class, used to obtain all the bytes written to the stream."", ""toByteArray"")"
You can read a Java float from the DataInputStream using its readFloat() method.,"(""DataInputStream"", ""The readFloat method is a function of the DataInputStream class, allowing it to read a Java float."", ""readFloat"")"
You can read a Java unsigned short (only positive values) from the DataInputStream using its readUnsignedShort() method.,"(""DataInputStream"", ""The readUnsignedShort method is a function provided by the DataInputStream class to read an unsigned short value."", ""readUnsignedShort"")"
You can read a Java long from the DataInputStream using its readLong() method.,"(""DataInputStream"", ""The readLong method is a function of the DataInputStream class, allowing it to read a Java long."", ""readLong"")"
"To rename (or move) a file, call the method renameTo() on the File class.","(""RenameTo"", ""The method RenameTo is called on the File class to rename or move a file."", ""File"")"
You can obtain a list of all the files in a directory by calling either the Java File list() method or the listFiles() method.,"(""File"", ""The list method is a method of the File class."", ""list""); (""File"", ""The listFiles method is a method of the File class."", ""listFiles""); (""Java"", ""The File class is part of the Java package."", ""File"")"
Here is an example of listing all files in a directory via the Java File list() and listFiles() methods:,"(""File"", ""The list method is associated with the File class as it is used to list files in a directory."", ""list""); (""File"", ""The listFiles method is associated with the File class as it is used to list files in a directory."", ""listFiles"")"
To write data to a Java FileOutputStream you can use its write() method.,"(""FileOutputStream"", ""The write method is used to write data to a FileOutputStream."", ""write"")"
Here is an example of writing data to a Java FileOutputStream using its write() method:,"(""FileOutputStream"", ""The write method is used to write data to the FileOutputStream class."", ""write"")"
Here is an example of closing a Java FileOutputStream by calling its close() method:,"(""FileOutputStream"", ""The close method is used to close the FileOutputStream class."", ""close"")"
You can convert a FileOutputStream to a character based Writer using the Java OutputStreamWriter class.,"(""FileOutputStream"", ""OutputStreamWriter is used to convert a FileOutputStream to a character-based Writer."", ""OutputStreamWriter""); (""OutputStreamWriter"", ""OutputStreamWriter is a class that acts as a bridge to convert byte streams to character streams, thus related to Writer."", ""Writer""); (""OutputStreamWriter"", ""OutputStreamWriter is a class within the Java package."", ""Java"")"
The Java FileWriter's flush() method flushes all data written to the FileWriter to the underlying file.,"(""flush()"", ""The flush() method is a function of the FileWriter class, used to flush data to the underlying file."", ""FileWriter"")"
Here is an example of flushing data written to a Java FileWriter by calling its flush() method:,"(""FileWriter"", ""The flush method is called on the FileWriter class to flush data written to it."", ""flush""); (""flush"", ""The flush method is part of the Java package, as it is used in the context of Java programming."", ""Java"")"
Notice how there is no longer any explicit close() method call to the FileWriter instance.,"(""CLOSE"", ""The CLOSE method is related to the FILEWRITER class as it is typically used to close instances of FILEWRITER."", ""FILEWRITER"")"
The Java InputStream class contains a method called readAllBytes() (since Java 9).,"(""InputStream"", ""The readAllBytes method is a part of the InputStream class."", ""readAllBytes""); (""readAllBytes"", ""The readAllBytes method was introduced in Java 9."", ""Java""); (""InputStream"", ""The InputStream class is part of the Java package."", ""Java"")"
Here is an example of reading all bytes from a Java InputStream via readAllBytes():,"(""InputStream"", ""The method readAllBytes() is used to read all bytes from the InputStream class."", ""readAllBytes"")"
"If an InputStream subclass supports the mark() and reset() methods, then that subclass should override the markSupported() to return true.","(""InputStream"", ""The method 'mark' is supported by the InputStream class."", ""mark""); (""InputStream"", ""The method 'reset' is supported by the InputStream class."", ""reset""); (""InputStream"", ""The method 'markSupported' is related to the InputStream class as it should be overridden by subclasses."", ""markSupported""); (""mark"", ""The 'markSupported' method is related to 'mark' as it indicates whether the 'mark' method is supported."", ""markSupported""); (""reset"", ""The 'markSupported' method is related to 'reset' as it indicates whether the 'reset' method is supported."", ""markSupported"")"
The read() method of an InputStreamReader returns an int which contains the char value of the char read.,"(""Read"", ""The read method is a function of the InputStreamReader class"", ""InputStreamReader"")"
Notice how there is no longer any explicit close() method call to the CharArrayWriter instance.,"(""CLOSE"", ""The CLOSE method is related to the CHARARRAYWRITER class as it is a method that can be called on an instance of this class."", ""CHARARRAYWRITER"")"
"Like with FilterInputStream, I see no sensible purpose for this class.","(""FilterInputStream"", ""FilterInputStream is mentioned as a class in the text."", ""class"")"
They make it somewhat easier to understand what the classes are targeting.,"(""Classes"", ""class"")"
The read() method of a Java PipedReader returns an int which contains the char value of the character read.,"(""Read"", ""The Read method is a function that belongs to the PipedReader class."", ""PipedReader"")"
"Third, the example calls the advanced printf() method of the PrintWriter which can insert formatted numbers into a text string.","(""Printf"", ""The Printf method is a method of the PrintWriter class, indicating that Printf is used within or by PrintWriter."", ""PrintWriter"")"
Closing a Java StringReader can be done using the close() method like this:,"(""StringReader"", ""The close method is used to close a StringReader instance."", ""close"")"
The Java OutputStream's flush() method flushes all data written to the OutputStream to the underlying data destination.,"(""OutputStream"", ""The flush() method is a function that operates on the OutputStream class to flush all data written to it to the underlying data destination."", ""flush()"")"
The Java OutputStreamWriter's flush() method flushes all data written to the OutputStreamWriter to the underlying data destination.,"(""flush()"", ""The flush() method is a function of the Java OutputStreamWriter class."", ""Java OutputStreamWriter""); (""flush()"", ""The flush() method is a function of the OutputStreamWriter class."", ""OutputStreamWriter"")"
"If you push back multiple bytes into the PushbackInputStream, the latest byte pushed back will be returned first from read(), just like on a stack.","(""PushbackInputStream"", ""The read method is used to retrieve bytes from the PushbackInputStream class."", ""read"")"
"You read bytes from the Java PushbackInputStream via its read() method, just like you do from a regular InputStream .","(""Java PushbackInputStream"", ""The read() method is used to read bytes from the Java PushbackInputStream class."", ""read()""); (""InputStream"", ""The read() method is also used to read bytes from a regular InputStream class."", ""read()"")"
"Remember, calling this write() method will advance the file position of the RandomAccessFile by 1.","(""WRITE"", ""The write() method is called on the RandomAccessFile class, indicating a functional relationship where the method operates on instances of the class."", ""RANDOMACCESSFILE"")"
The Java Reader class has a method named skip() which can be used to skip over a number of characters in the input that you do not want to read.,"(""Reader"", ""The skip method is a function of the Reader class, used to skip over characters in the input."", ""skip"")"
You do so by calling the nextToken() method of the StreamTokenizer inside a loop.,"(""NextToken"", ""The NextToken method is a function that belongs to the StreamTokenizer class, as it is called on an instance of StreamTokenizer."", ""StreamTokenizer"")"
"System.in, System.out and System.err are initialized by the Java runtime when a Java VM starts up, so you don't have to instantiate any streams yourself (although you can exchange them at runtime).","(""System.in"", ""System.in is initialized by the Java runtime."", ""Java runtime""); (""System.out"", ""System.out is initialized by the Java runtime."", ""Java runtime""); (""System.err"", ""System.err is initialized by the Java runtime."", ""Java runtime""); (""Java runtime"", ""Java runtime initializes when a Java VM starts up."", ""Java VM"")"
You will normally use a Writer subclass rather than a Writer directly.,"(""Writer"", ""The text suggests using a subclass of Writer, indicating a relationship between the Writer class and its subclasses."", ""Writer"")"
The Java String parameter passed to the Class forName() method is the name of the JDBC driver class for the given JDBC driver.,"(""Class"", ""The forName method belongs to the Class class."", ""forName""); (""JDBC"", ""The driver class is part of the JDBC package."", ""driver""); (""Java"", ""The String class is part of the Java package."", ""String"")"
"By the way, imagine that the used Person class looks like this:","(""Person"", ""class"")"
Here is an example of creating a JDBC DatabaseMetaData object via the JDBC Connection getMetaData() method:,"(""JDBC"", ""DatabaseMetaData is a class that is part of the JDBC package"", ""DatabaseMetaData""); (""Connection"", ""getMetaData is a method of the Connection class"", ""getMetaData""); (""JDBC"", ""Connection is a class that is part of the JDBC package"", ""Connection"")"
The ResultSet returned by the getColumns() method contains a list of columns for the given table.,"(""getColumns"", ""The getColumns method returns a ResultSet, indicating a relationship where the method produces an instance of the class."", ""ResultSet"")"
Before the first next() call the ResultSet is positioned before the first row.,"(""ResultSet"", ""The method 'next' is likely a method that operates on the 'ResultSet' class, as it is mentioned in the context of calling it on a ResultSet."", ""next"")"
"Once the row is ready to be inserted into the ResultSet, call the insertRow() method.","(""ResultSet"", ""The insertRow method is called on the ResultSet class to insert a row."", ""insertRow"")"
"If you need to insert another row, explicitly call moveToInsertRow() to signal this to the ResultSet.","(""MoveToInsertRow"", ""The method MoveToInsertRow is called on the ResultSet class to insert another row."", ""ResultSet"")"
The purpose of an abstract class is to function as a base for subclasses.,"(""Abstract Class"", ""An abstract class serves as a base for subclasses, indicating a hierarchical relationship."", ""Subclass"")"
"If a class has an abstract method, the whole class must be declared abstract.","(""Class"", ""An abstract method is a component of a class, and if a class contains an abstract method, the class itself must be declared abstract."", ""Abstract Method""); (""Class"", ""The statement refers to the requirement that if a class has an abstract method, the class must be declared abstract."", ""Class"")"
The example I showed you above with the URLProcessorBase class is actually an example of the Template Method design pattern.,"(""URLProcessorBase"", ""The URLProcessorBase class is an example of the Template Method design pattern, indicating that it likely implements or uses this method."", ""Template Method"")"
In the above example the subclass SmartClock has a method called getTimeInSeconds() which accesses the time variable of the superclass Clock.,"(""SmartClock"", ""The method getTimeInSeconds is a part of the SmartClock class."", ""getTimeInSeconds""); (""SmartClock"", ""SmartClock is a subclass of the Clock class."", ""Clock""); (""getTimeInSeconds"", ""The method getTimeInSeconds accesses the time variable of the Clock class."", ""Clock"")"
The utility class is called Arrays and is located in the standard Java package java.util.,"(""Arrays"", ""The class Arrays is located in the package java.util."", ""java.util"")"
The purpose of a constructor is to initialize the fields in the class.,"(""Constructor"", ""A constructor is used to initialize the fields in a class."", ""Fields"")"
Now the isValid() method returns the value returned by the value.equals() method call.,"(""isValid"", ""The isValid method returns the value from the value.equals method call, indicating a direct functional relationship between the two methods."", ""value.equals"")"
In many cases it would have made sense to place the getLicensePlate() method in the Vehicle class where the licensePlate field is located.,"(""GetLicensePlate"", ""The GetLicensePlate method is related to the Vehicle class because it is suggested to be placed within this class, where the licensePlate field is located."", ""Vehicle"")"
"Here is the same instanceof example, but using a Truck object instead of a Car object: Truck truck = new Truck(); Vehicle vehicle = truck; boolean isCar = vehicle instanceof Car; After executing this code the isCar will contain the value false.","(""Truck"", ""A Truck object is assigned to a Vehicle reference, indicating that Truck is a subclass or implementation of Vehicle."", ""Vehicle""); (""Vehicle"", ""The instanceof operator is used to check if a Vehicle object is an instance of the Car class, indicating a potential relationship between Vehicle and Car."", ""Car"")"
The updateLicensePlate() method sets the license plate value on the licensePlate field in the Car class.,"(""UpdateLicensePlate"", ""The UpdateLicensePlate method sets the value on the LicensePlate field."", ""LicensePlate""); (""UpdateLicensePlate"", ""The UpdateLicensePlate method is associated with the Car class."", ""Car"")"
"The getLicensePlate() method, however, returns the value of the licensePlate field in the Vehicle class.","(""GetLicensePlate"", ""The GetLicensePlate method is related to the Vehicle class because it returns the value of the licensePlate field within this class."", ""Vehicle"")"
"If you override a method in a subclass, and the method is all of a sudden removed or renamed or have its signature changed in the superclass, the method in the subclass no longer overrides the method in the superclass.","(""Subclass"", ""A subclass is a type of class that inherits from a superclass."", ""Superclass""); (""Method"", ""A method can be overridden in a subclass."", ""Subclass""); (""Method"", ""A method can be defined in a superclass and overridden in a subclass."", ""Superclass"")"
Here is a Java instanceof example illustrating the comparison of null against a class:,"(""Java"", ""The Java package is used to demonstrate the instanceof class example."", ""Instanceof"")"
"That is because it is not the reference type that is compared against the target class or interface, but the actual type of the referenced object.","(""REFERENCED OBJECT"", ""The referenced object is compared against the target class."", ""CLASS""); (""REFERENCED OBJECT"", ""The referenced object is compared against the target interface."", ""INTERFACE"")"
"A Java interface is a bit like a Java class, except a Java interface can only contain method signatures and fields.","(""Java Interface"", ""A Java interface is similar to a Java class in structure."", ""Java Class""); (""Java Interface"", ""A Java interface can contain method signatures."", ""Method Signatures""); (""Java Interface"", ""A Java interface can contain fields."", ""Fields"")"
The class does not need to implement (declare) the variables of an interface.,"(""Class"", ""The class is related to the interface as it does not need to implement the variables declared by the interface."", ""Interface"")"
"You must always create an instance of some class that implements the interface, and reference that instance as an instance of the interface.","(""Class"", ""A class implements the interface, indicating a relationship between the two."", ""Interface"")"
"While it is normally possible for a class to implement multiple interfaces even if the interfaces contain methods with the same signature, this is not possible if one or more of these methods are default methods.","(""Class"", ""A class can implement multiple interfaces, which may contain methods with the same signature."", ""Method""); (""Method"", ""Methods can be part of a package, and default methods are mentioned in the context of interfaces."", ""Package"")"
In both of the above situations the Java compiler requires that the class implementing the interface(s) explicitly implements the method which causes the problem.,"(""Java Compiler"", ""The Java Compiler requires that the class implementing the interface explicitly implements the method."", ""Interface""); (""Interface"", ""The interface requires the implementation of the method."", ""Method"")"
The implementation in the class takes precedence over any default implementations.,"(""Class"", ""The class may contain methods that have implementations."", ""Method""); (""Class"", ""The class is typically part of a package."", ""Package"")"
"Since the return value of produce() is Object, it can return any Java object.","(""Produce"", ""The method Produce returns an Object, indicating a relationship where Produce is a method that outputs an Object."", ""Object""); (""Object"", ""Object is a class that is part of the Java package, indicating a relationship where Object belongs to Java."", ""Java"")"
"Notice how the object returned from the carProducer.produce() method call has to be cast to a Car instance, because the produce() method return type is Object.","(""CarProducer"", ""The Produce method is called on the CarProducer class."", ""Produce""); (""Produce"", ""The Produce method returns an object that needs to be cast to a Car instance."", ""Car"")"
"As you can see, since the generic type for the CarProducer instance is set to Car, it is no longer necessary to cast the object returned from the produce() method, since the original method declaration in the MyProducer interface states, that this method returns the same type as is specified in the generic type when used.","(""CarProducer"", ""CarProducer is a class that produces instances of the Car class."", ""Car""); (""produce"", ""The produce method is declared in the MyProducer interface."", ""MyProducer""); (""produce"", ""The produce method returns an instance of the Car class."", ""Car"")"
Now the result variable would end up with the value 12.5.,"(""Result"", ""The result variable is assigned the value 12.5."", ""Value"")"
The example above defines a method called writeText inside a class named MyClass.,"(""WriteText"", ""The method WriteText is defined inside the class MyClass."", ""MyClass"")"
This would happen sometime at runtime - depending on when the application tried to use the missing class.,"(""Application"", ""The application tries to use the class at runtime, indicating a dependency or usage relationship."", ""Class"")"
This example module descriptor declares that it requires the standard Java module named javafx.graphics.,"(""Javafx.graphics"", ""The text indicates that the module descriptor requires the Java package named javafx.graphics."", ""Javafx.graphics"")"
Here is how you run the main class from a Java module JAR file:,"(""Main Class"", ""The Main Class is executed from the Java Module."", ""Java Module"")"
In Java nested classes are classes that are defined inside another class.,"(""nested classes"", ""Nested classes are a type of classes defined within another class."", ""classes"")"
Notice how you put new after the reference to the outer class in order to create an instance of the inner class.,"(""Outer Class"", ""The inner class is created as an instance of the outer class, indicating a relationship where the inner class is contained within or associated with the outer class."", ""Inner Class"")"
"As you can see, an anonymous class implementing an interface is pretty similar to an anonymous class extending another class.","(""Anonymous Class"", ""An anonymous class can implement an interface, indicating a relationship where the class provides specific implementations for the interface's methods."", ""Interface"")"
"Users of the Cache class may never see the CacheEntry class, if they have no need to obtain information about the CacheEntry itself, but only the cached value.","(""Cache"", ""The Cache class uses the CacheEntry class to store cached values, indicating a relationship where CacheEntry is a component or part of Cache."", ""CacheEntry"")"
"If the classes A and B are located in the same Java package, there is no problem with the code above.","(""A"", ""Class A is located in the Java package."", ""Java""); (""B"", ""Class B is located in the Java package."", ""Java"")"
"Instead of having a fixed number of layer packages which keep growing in number of classes, you get a growing number of application functionality packages with a smaller number of classes inside.","(""Layer Packages"", ""Layer Packages contain a number of Classes."", ""Classes""); (""Application Functionality Packages"", ""Application Functionality Packages contain a smaller number of Classes."", ""Classes"")"
A Java Record is a special kind of Java class which has a concise syntax for defining immutable data-only classes.,"(""Java Record"", ""Java Record is a type of class within the Java package"", ""Java"")"
You can add instance methods to a Java Record definition - just like you can with a regular Java class.,"(""Java Record"", ""Instance methods can be added to a Java Record, indicating a relationship between the class and the methods."", ""instance methods""); (""Java class"", ""Instance methods can be added to a Java class, indicating a relationship between the class and the methods."", ""instance methods""); (""Java Record"", ""Java Record is compared to a regular Java class, indicating a relationship between the two classes."", ""Java class"")"
Notice how the brandAsLowerCase() method calls the auto-generated brand() method internally.,"(""brandAsLowerCase"", ""The brandAsLowerCase method calls the brand method internally, indicating a direct functional relationship."", ""brand"")"
"As you can see, a new StringBuilder is created, passing along the first String to its constructor, and the second String to its append() method, before finally calling the toString() method.","(""StringBuilder"", ""The append method is called on the StringBuilder class."", ""append""); (""StringBuilder"", ""The toString method is called on the StringBuilder class."", ""toString""); (""StringBuilder"", ""The StringBuilder class is initialized with a String."", ""String"")"
You can search for substrings in Strings using the indexOf() method.,"(""indexOf"", ""The indexOf method is used to search for substrings within the Strings class."", ""Strings"")"
The Java String class also has a lastIndexOf() method which finds the last occurrence of a substring.,"(""String"", ""The lastIndexOf method is a function of the String class, used to find the last occurrence of a substring."", ""lastIndexOf"")"
The Java String class contains a method called trim() which can trim a string object.,"(""String"", ""The trim method is a function within the String class."", ""trim"")"
"If not, the default toString() method (inherited from the Object class) will get called.","(""TOSTRING"", ""The toString method is inherited from the Object class."", ""OBJECT""); (""TOSTRING"", ""The toString method is part of the Object class."", ""CLASS"")"
From Java 13 the Java String class got a new method called translateEscapes() which can translate escape codes that exist inside a String in the same way the Java compiler translates them.,"(""Java String"", ""The method translateEscapes is a new method added to the Java String class."", ""translateEscapes""); (""Java"", ""The Java String class is part of the Java package."", ""Java String"")"
When you create an instance of a class (an object) the object can have methods you can execute.,"(""Class"", ""An instance of a class is referred to as an object."", ""Object""); (""Object"", ""Objects can have methods that can be executed."", ""Methods"")"
The second line assigns the floating point value 199.99 to the floating point variable named myFloat.,
"When you click the ""Run..."" option, IntelliJ IDEA will first compile your Java class, and then run it.","(""IntelliJ IDEA"", ""IntelliJ IDEA is an IDE that supports running and compiling Java code."", ""Java""); (""IntelliJ IDEA"", ""IntelliJ IDEA compiles and runs the Java class."", ""class"")"
"The logrb() methods work like the log() methods too, except they can obtain the log messages from a resource bundle.","(""LOGRB"", ""Both methods are used for logging purposes, with LOGRB being a variant of LOG that can obtain log messages from a resource bundle."", ""LOG"")"
You can obtain the parent Logger of a given Logger using the getParent() method.,"(""Logger"", ""The getParent() method is used to obtain the parent Logger of a given Logger."", ""getParent"")"
The getParameters() method returns the parameters to be inserted into the message of this LogRecord.,"(""GetParameters"", ""The GetParameters method is used to return parameters that are inserted into the message of the LogRecord class."", ""LogRecord"")"
The getResourceBundle() method returns the ResourceBundle (if any) used to localize the message of this LogRecord.,"(""getResourceBundle"", ""The getResourceBundle method returns the ResourceBundle used for localization."", ""ResourceBundle""); (""getResourceBundle"", ""The getResourceBundle method is used to localize the message of this LogRecord."", ""LogRecord"")"
"Note: This tutorial does not cover the other popular Java logging API's (Log4J, SLF4J, Apache Commons Logging, LogBack etc.).","(""Log4J"", ""Both are popular Java logging packages."", ""SLF4J""); (""Log4J"", ""Both are popular Java logging packages."", ""Apache Commons Logging""); (""Log4J"", ""Both are popular Java logging packages."", ""LogBack""); (""SLF4J"", ""Both are popular Java logging packages."", ""Apache Commons Logging""); (""SLF4J"", ""Both are popular Java logging packages."", ""LogBack""); (""Apache Commons Logging"", ""Both are popular Java logging packages."", ""LogBack"")"
Receiving data via a DatagramSocket is done by first creating a DatagramPacket and then receiving data into it via the DatagramSocket's receive() method.,"(""DatagramSocket"", ""The receive() method is a function of the DatagramSocket class, used to receive data."", ""receive""); (""DatagramSocket"", ""Data is received into a DatagramPacket via the DatagramSocket."", ""DatagramPacket"")"
The java.net package contains two interesting classes: The URL class and the URLConnection class.,"(""Java.net"", ""The URL class is part of the java.net package."", ""URL""); (""Java.net"", ""The URLConnection class is part of the java.net package."", ""URLConnection""); (""URL"", ""Both URL and URLConnection are classes within the java.net package, indicating a potential relationship in functionality or usage."", ""URLConnection"")"
You can check the when the read operation is finished by calling the isDone() method of the Future instance returned by the read() method.,"(""Read"", ""The isDone() method is used to check the completion status of the read operation."", ""IsDone""); (""Read"", ""The read() method returns an instance of the Future class."", ""Future""); (""IsDone"", ""The isDone() method is called on the Future instance."", ""Future"")"
Each way to write data call one of the write() methods of the AsynchronousFileChannel.,"(""WRITE"", ""The WRITE method is a function of the ASYNCHRONOUSFILECHANNEL class, as it is used to write data through this class."", ""ASYNCHRONOUSFILECHANNEL"")"
The int returned by the read() method tells how many bytes were written into the Buffer.,"(""READ"", ""The read method interacts with the Buffer class by writing bytes into it."", ""BUFFER"")"
There is no guarantee of how many bytes the write() method writes to the FileChannel.,"(""WRITE"", ""The write() method is used in the context of the FileChannel class, indicating a functional relationship where the method operates on or with the class."", ""FILECHANNEL"")"
You can obtain the current position of the FileChannel object by calling the position() method.,"(""FileChannel"", ""The position method is called on the FileChannel class to obtain the current position."", ""position"")"
The Files.createDirectory() method creates a new directory from a Path instance.,"(""Files"", ""The createDirectory method is a member of the Files class."", ""createDirectory""); (""createDirectory"", ""The createDirectory method uses a Path instance to create a new directory."", ""Path"")"
The Java NIO Files class also contains a function for moving files from one path to another.,"(""Files"", ""The Files class contains a function for moving files, indicating a relationship between the class and the action of moving files."", ""moving files"")"
Here is a walkFileTree() that extends SimpleFileVisitor to look for a file named README.txt :,"(""walkFileTree"", ""The method walkFileTree extends the class SimpleFileVisitor."", ""SimpleFileVisitor""); (""walkFileTree"", ""The method walkFileTree is used to look for a file named README.txt."", ""README.txt"")"
"By walking through all directories and deleting all files (inside visitFile()) in each directory, and afterwards delete the directory itself (inside postVisitDirectory()) you can delete a directory with all subdirectories and files.","(""visitFile"", ""Both methods are used in the process of deleting directories and their contents."", ""postVisitDirectory"")"
"In many cases though, you can replace the use of the File class with use of the Path interface.","(""File"", ""The File class can be replaced by the Path interface, indicating a relationship where Path serves a similar purpose or function as File."", ""Path"")"
The normalize() method of the Path interface can normalize a path.,"(""Normalize"", ""The normalize method is a function that belongs to the Path class."", ""Path"")"
"As you saw in the previous section, when you register a Channel with a Selector the register() method returns a SelectionKey objects.","(""Channel"", ""A Channel can be registered with a Selector."", ""Selector""); (""register"", ""The register() method returns a SelectionKey object."", ""SelectionKey""); (""register"", ""The register() method is used to register a Channel."", ""Channel""); (""register"", ""The register() method is associated with a Selector."", ""Selector"")"
"You can also attach an object already while registering the Channel with the Selector, in the register() method.","(""register"", ""The register method is used to register the Channel with the Selector."", ""Channel""); (""register"", ""The register method is used to register the Channel with the Selector."", ""Selector"")"
NOTE: Only the interfaces specifically declared implemented by a given class is returned.,"(""CLASS"", ""The CLASS entity is related to the INTERFACES entity because the text mentions that interfaces are implemented by a class."", ""INTERFACES"")"
All you need to do is to obtain a ClassLoader and call its loadClass() method.,"(""ClassLoader"", ""The loadClass method is a function that is called on the ClassLoader class."", ""loadClass"")"
"When the MyAction class calls methods on the IMyFactory instance injected into its constructor by the container, the method calls are translated into calls to the IContainer.instance() method, which is the method you use to obtain instances from the container.","(""MyAction"", ""The MyAction class calls methods on the IMyFactory instance."", ""IMyFactory""); (""IMyFactory"", ""Methods on the IMyFactory instance are translated into calls to the IContainer.instance() method."", ""IContainer""); (""IContainer"", ""The instance method is used to obtain instances from the IContainer class."", ""instance"")"
"You cannot ask for getters and setters explicitly, so you will have to scan through all the methods of a class and check if each method is a getter or setter.","(""METHODS"", ""Methods are part of a class and need to be scanned to identify getters and setters."", ""CLASS""); (""GETTERS AND SETTERS"", ""Getters and setters are specific types of methods."", ""METHODS"")"
To access a private field you will need to call the Class.getDeclaredField(String name) or Class.getDeclaredFields() method.,"(""Class"", ""The getDeclaredField method is a method of the Class entity, used to access a private field by name."", ""getDeclaredField""); (""Class"", ""The getDeclaredFields method is a method of the Class entity, used to access all private fields."", ""getDeclaredFields"")"
"By calling Field.setAcessible(true) you turn off the access checks for this particular Field instance, for reflection only.","(""Field"", ""The method setAcessible is used to modify the access level of the Field class instance."", ""setAcessible"")"
"The methods Class.getMethod(String name, Class[] parameterTypes) and Class.getMethods() methods only return public methods, so they won't work.","(""Class"", ""The method getMethod is associated with the class Class as it is a method of this class."", ""getMethod""); (""Class"", ""The method getMethods is associated with the class Class as it is a method of this class."", ""getMethods"")"
"It will explain the basics of Java Reflection including how to work with arrays, annotations, generics and dynamic proxies, and do dynamic class loading and reloading.","(""Java Reflection"", ""Java Reflection includes working with arrays."", ""Arrays""); (""Java Reflection"", ""Java Reflection includes working with annotations."", ""Annotations""); (""Java Reflection"", ""Java Reflection includes working with generics."", ""Generics""); (""Java Reflection"", ""Java Reflection includes working with dynamic proxies."", ""Dynamic Proxies""); (""Java Reflection"", ""Java Reflection includes dynamic class loading."", ""Dynamic Class Loading""); (""Java Reflection"", ""Java Reflection includes reloading."", ""Reloading"")"
"For instance, if you are introspecting a String array, you can detect that the element type is String by inspecting the array class.","(""array"", ""The array class contains elements of type String, indicating a relationship between the array and the String class."", ""String"")"
"For instance, the character class [a-zA-Z] will match all letters between a and z or between A and Z .","(""Character"", ""The character class [a-zA-Z] is used to match all letters between a and z or between A and Z."", ""a-zA-Z"")"
"For that, you need to use the find(), start() and end() methods.","(""FIND"", ""Both are methods mentioned in the text."", ""START""); (""FIND"", ""Both are methods mentioned in the text."", ""END""); (""START"", ""Both are methods mentioned in the text."", ""END"")"
"In other words, if the regular expression matches the beginning of a text but not the whole text, lookingAt() will return true, whereas matches() will return false.","(""LookingAt"", ""Both are methods used to evaluate regular expressions against text."", ""Matches"")"
"In case you have started matching occurrences in a string via the find() method, the Matcher will internally keep a state about how far it has searched through the input text.","(""Find"", ""The find() method is used by the Matcher class to search through the input text."", ""Matcher"")"
The Matcher replaceAll() and replaceFirst() methods can be used to replace parts of the string the Matcher is searching through.,"(""Matcher"", ""The replaceAll method is a function of the Matcher class."", ""replaceAll""); (""Matcher"", ""The replaceFirst method is a function of the Matcher class."", ""replaceFirst"")"
A regular expression is also sometimes referred to as a pattern (hence the name of the Java Pattern class).,"(""Pattern"", ""The Pattern class is part of the Java package, as indicated by the text."", ""Java"")"
"Too keep this text short, the Matcher covered in more detail in the text about the Java Matcher class.","(""Matcher"", ""The Matcher is discussed in the context of the Java Matcher class, indicating a relationship between the two."", ""Java Matcher"")"
When you are finished reading data from the GZIPInputStream you should close it using its close() method.,"(""GZIPInputStream"", ""The close method is used to close the GZIPInputStream after reading data from it."", ""close"")"
"But, notice how no DI is used inside the BO.checkPersonIsValid() or the DAO.readPerson() methods.","(""BO"", ""The method checkPersonIsValid is a method of the class BO."", ""checkPersonIsValid""); (""DAO"", ""The method readPerson is a method of the class DAO."", ""readPerson"")"
"This little script defines the ""max"" factory as a call to the static max() method with input parameter 0 and 1 passed to the max() method.","(""Max"", ""The 'max' factory is defined as a call to the static 'max()' method."", ""Max"")"
"In other words, as a call to the get() method on the HttpRequestCache singleton.","(""Get"", ""The Get method is called on the HttpRequestCache class, indicating a relationship where the method is part of or used by the class."", ""HttpRequestCache"")"
The ScriptFactoryBuilder has a addFactories() method that takes an InputStream as parameter instead of a String.,"(""ScriptFactoryBuilder"", ""The addFactories method is a part of the ScriptFactoryBuilder class."", ""addFactories"")"
"Notice how the HttpServletRequest and HttpServletResponse are not obtained by the ThreadLocal.get() method, but via the static methods getRequest() and getResponse().","(""ThreadLocal.get()"", ""The HttpServletRequest is mentioned in the context of not being obtained by the ThreadLocal.get() method."", ""HttpServletRequest""); (""ThreadLocal.get()"", ""The HttpServletResponse is mentioned in the context of not being obtained by the ThreadLocal.get() method."", ""HttpServletResponse""); (""getRequest()"", ""The getRequest() method is used to obtain the HttpServletRequest."", ""HttpServletRequest""); (""getResponse()"", ""The getResponse() method is used to obtain the HttpServletResponse."", ""HttpServletResponse"")"
"The IObjectMappingKey instance can contain more information about the class to be mapped, than a Class object can.","(""IObjectMappingKey"", ""IObjectMappingKey is related to Class as it contains more information about the class to be mapped."", ""Class"")"
This is the object is obtained from the getResult() method of the IResultSetProcessor.,"(""GetResult"", ""The GetResult method is associated with the IResultSetProcessor class as it is a method that belongs to or is used by this class."", ""IResultSetProcessor"")"
"This speeds up object mapping cache lookups because the hashCode() method returns this int id, and because equals() also only compares int id's, instead of Class objects, table names etc.","(""hashCode()"", ""Both methods are mentioned in the context of object mapping cache lookups and are related by their use of int id for comparison."", ""equals()""); (""hashCode()"", ""The hashCode() method is typically associated with Class objects for generating hash codes."", ""Class""); (""equals()"", ""The equals() method is typically used to compare Class objects for equality."", ""Class"")"
The extended class CustomObjectMapperBase is an empty implementation of the ICustomObjectMapper interface.,"(""CustomObjectMapperBase"", ""CustomObjectMapperBase is an implementation of the ICustomObjectMapper interface"", ""ICustomObjectMapper"")"
Just call the IObjectMapping.removeGetterMapping(String name) or IObjectMapping.removeSetterMapping(String name) method to do so.,"(""IObjectMapping"", ""The method removeGetterMapping is a part of the IObjectMapping class."", ""removeGetterMapping""); (""IObjectMapping"", ""The method removeSetterMapping is a part of the IObjectMapping class."", ""removeSetterMapping"")"
"Second, you do not need the parentheses around the closure when calling doFirst() or doLast().","(""DOFIRST"", ""Both DOFIRST and DOLAST are methods mentioned in the context of calling closures."", ""DOLAST"")"
The and() method is used to combine two other Predicate functions in the same way I showed in the beginning of this Java functional composition tutorial.,"(""And"", ""The and() method is used to combine two Predicate functions."", ""Predicate""); (""And"", ""The and() method is part of Java functional composition."", ""Java"")"
"The Java Function compose() method composes a new Function instance from the Function instance it is called on, and the Function instance passed as parameter to the compose() method.","(""compose()"", ""The compose() method is a method that operates on instances of the Function class."", ""Function"")"
The first example of a higher order function is the Collections.sort() method which takes a Comparator as parameter.,"(""Collections.sort()"", ""The Collections.sort() method takes a Comparator as a parameter, indicating a relationship where the method uses the class."", ""Comparator"")"
The call to the map() method of the Stream interface is a non-terminal operation.,"(""Map"", ""The map() method is a method of the Stream interface, indicating a relationship where Map is a method belonging to the Stream class."", ""Stream"")"
Only the first occurrence of this element will be included in the Stream returned by distinct().,"(""distinct"", ""The method 'distinct' is used to return a Stream with only the first occurrence of each element."", ""Stream"")"
"The findFirst() method returns an Optional from which you can obtain the element, if present.","(""findFirst"", ""The findFirst method returns an Optional, indicating a relationship where the method's output is an Optional object."", ""Optional"")"
"The Java Stream forEach() method is a terminal operation which starts the internal iteration of the elements in the Stream, and applies a Consumer (java.util.function.Consumer) to each element in the Stream.","(""forEach()"", ""The forEach() method is a terminal operation of the Java Stream class."", ""Java Stream""); (""forEach()"", ""The forEach() method applies a Consumer to each element in the Stream, indicating a relationship with the java.util.function.Consumer class."", ""java.util.function.Consumer"")"
Which element is the largest is determined by the Comparator implementation you pass to the max() method.,"(""Comparator"", ""The Comparator class is used to determine the largest element when passed to the max() method."", ""max"")"
This Optional contains the value (if any) returned by the lambda expression passed to the reduce() method.,"(""Optional"", ""The reduce() method is used to return a value that is contained within the Optional class."", ""reduce"")"
"Note: Even if the class is called RollingBufferInputStream, it is not an InputStream subclass.","(""RollingBufferInputStream"", ""RollingBufferInputStream is mentioned in the context of being related to InputStream, suggesting a potential subclass relationship."", ""InputStream"")"
"You can specify fonts for most text objects (Chunk, Phrase, Paragraph etc.)","(""Chunk"", ""Both are text objects that can have fonts specified."", ""Phrase""); (""Chunk"", ""Both are text objects that can have fonts specified."", ""Paragraph""); (""Phrase"", ""Both are text objects that can have fonts specified."", ""Paragraph"")"
"If you already have a finished PDF, and just want to add a header, footer or watermark to it, IText provides the com.itextpdf.pdf.PdfStamper class.","(""IText"", ""The com.itextpdf.pdf.PdfStamper class is provided by the IText package."", ""com.itextpdf.pdf.PdfStamper"")"
"You can write text as superscript or subscript using the Chunk class, and it's setTextRise() method.","(""Chunk"", ""The setTextRise method is a function of the Chunk class, allowing text to be written as superscript or subscript."", ""setTextRise"")"
"You can add underline and strikethrough text using the Chunk class, and its setUnderline() method.","(""Chunk"", ""The setUnderline method is a function of the Chunk class, indicating a direct relationship where the method is used to manipulate or interact with instances of the class."", ""setUnderline"")"
"It is now up to the caller of the readMyData() method to decide if an existing MyData instance should be reused, or if a new instance should be created.","(""ReadMyData"", ""The ReadMyData method is responsible for handling instances of the MyData class, either by reusing an existing instance or creating a new one."", ""MyData"")"
The value returned by write() is the number of bytes copied from the ByteBuffer.,"(""WRITE"", ""The method WRITE operates on the CLASS BYTEBUFFER to copy bytes."", ""BYTEBUFFER"")"
Here is an implementation of the ring buffer that uses a fill count including the batch put() and take() operations.,"(""Ring Buffer"", ""The Fill Count method is used within the Ring Buffer class to manage the number of elements."", ""Fill Count""); (""Ring Buffer"", ""The Batch Put method is an operation of the Ring Buffer class for adding multiple elements."", ""Batch Put""); (""Ring Buffer"", ""The Take method is an operation of the Ring Buffer class for removing elements."", ""Take"")"
"Here is an implementation of the ring buffer that uses a read position and flip marker, including the batch put() and take() operations.","(""Ring Buffer"", ""The Read Position is a method used in the Ring Buffer class."", ""Read Position""); (""Ring Buffer"", ""The Flip Marker is a method used in the Ring Buffer class."", ""Flip Marker""); (""Ring Buffer"", ""The Batch Put is a method used in the Ring Buffer class."", ""Batch Put""); (""Ring Buffer"", ""The Take is a method used in the Ring Buffer class."", ""Take"")"
"If your benchmark method produces multiple results you can pass each of these results to a black hole, meaning calling consume() on the Blackhole instance for each value.","(""Benchmark Method"", ""The benchmark method results are passed to the Blackhole instance."", ""Blackhole""); (""Consume"", ""The consume() method is called on the Blackhole instance."", ""Blackhole"")"
The javax.servlet.http.HttpServlet class is a slightly more advanced base class than the GenericServlet shown in the Simple Servlet example.,"(""HttpServlet"", ""HttpServlet is a class within the javax.servlet.http package"", ""javax.servlet.http""); (""HttpServlet"", ""HttpServlet is a more advanced base class than GenericServlet"", ""GenericServlet"")"
The easiest way to implement this interface is to extend either the class GenericServlet or HttpServlet.,"(""GenericServlet"", ""Both are classes that can be extended to implement the interface."", ""HttpServlet""); (""HttpServlet"", ""Both are classes that can be extended to implement the interface."", ""GenericServlet"")"
Each test method usually tests a single method of the target class.,"(""TEST METHOD"", ""A test method is designed to test a single method of the target class."", ""TARGET CLASS"")"
"A protected method or field, on the other hand, is also accessible to other classes in the same package, and for subclasses of the unit too.","(""Method"", ""A method is accessible to other classes."", ""Classes""); (""Field"", ""A field is accessible to other classes."", ""Classes""); (""Method"", ""A method is accessible to other classes in the same package."", ""Package""); (""Field"", ""A field is accessible to other classes in the same package."", ""Package""); (""Method"", ""A method is accessible to subclasses."", ""Subclasses""); (""Field"", ""A field is accessible to subclasses."", ""Subclasses"")"
"When your business logic class is separated from the boundary class, you can test the business logic class separately.","(""Business Logic Class"", ""The Business Logic Class is separated from the Boundary Class, indicating a relationship between the two classes."", ""Boundary Class"")"
Here is the unit test which uses a ByteArrayOutputStream to collect the data written to the OutputStream passed to the MyIOUnit.write() method:,"(""MyIOUnit"", ""The write method is associated with the MyIOUnit class, indicating that it is a function or operation that can be performed by instances of MyIOUnit."", ""write""); (""ByteArrayOutputStream"", ""ByteArrayOutputStream is used to collect data written to an OutputStream, indicating a functional relationship where ByteArrayOutputStream acts as a buffer for OutputStream."", ""OutputStream"")"
You may also be able to use the StringReader and StringWriter classes in your unit tests.,"(""StringReader"", ""Both are classes that can be used in unit tests for handling strings."", ""StringWriter"")"
"To avoid fragmenting the Java heap with Bytes instances, the Bytes class is designed to be obtained from an ObjectPool .","(""Bytes"", ""The Bytes class is designed to be obtained from an ObjectPool, indicating a relationship where Bytes instances are managed or created by ObjectPool."", ""ObjectPool"")"
To defragment the free blocks you call the defragment() method of the BytesAllocatorManualDefrag .,"(""Defragment"", ""The defragment() method is a function that belongs to the BytesAllocatorManualDefrag class, indicating a method-class relationship."", ""BytesAllocatorManualDefrag"")"
The Bytes class represents a byte sequence allocated from a shared byte array.,"(""Bytes"", ""The Bytes class represents a byte sequence."", ""byte sequence""); (""Bytes"", ""The Bytes class is allocated from a shared byte array."", ""shared byte array"")"
"As you can see, the ChannelInitializer is added to the ServerBootstrap using the childHandler() method.","(""ChannelInitializer"", ""ChannelInitializer is added to the ServerBootstrap, indicating a relationship where ChannelInitializer is used within ServerBootstrap."", ""ServerBootstrap""); (""childHandler"", ""The childHandler() method is used with ServerBootstrap, suggesting that it is a method belonging to or used by ServerBootstrap."", ""ServerBootstrap"")"
"By calling sync() on the ChannelFuture the main thread that creates the server waits until the server has started, before continuing.","(""ChannelFuture"", ""The method sync() is called on the ChannelFuture class."", ""sync"")"
The easiest way to create an instance of the RionObjectReader is via the RionObjectReaderBuilder class.,"(""RionObjectReaderBuilder"", ""The RionObjectReaderBuilder class is used to create an instance of the RionObjectReader class."", ""RionObjectReader"")"
The RionObjectReader readCyclic() method reads a cyclic object graph stored as RION in a byte array.,"(""RionObjectReader"", ""The readCyclic method is a function of the RionObjectReader class."", ""readCyclic""); (""readCyclic"", ""The readCyclic method reads a cyclic object graph stored as RION."", ""RION"")"
The RionObjectWriter writeAcyclic() can write an acyclic object graph as RION into a byte array.,"(""RionObjectWriter"", ""The method writeAcyclic is a function of the class RionObjectWriter."", ""writeAcyclic"")"
When reading a composite RION field you need to use the RionReader moveInto() and moveOutOf() methods.,"(""RionReader"", ""The moveInto method is a part of the RionReader class, used for reading composite RION fields."", ""moveInto""); (""RionReader"", ""The moveOutOf method is a part of the RionReader class, used for reading composite RION fields."", ""moveOutOf"")"
"Here are two examples of writing a 32 bit and 64 bit floating point number as RION Float fields to the destination byte array, using the RionWriter writeFloat32() and writeFloat64() methods:","(""RionWriter"", ""The writeFloat32 method is a function of the RionWriter class, used to write 32-bit floating point numbers."", ""writeFloat32""); (""RionWriter"", ""The writeFloat64 method is a function of the RionWriter class, used to write 64-bit floating point numbers."", ""writeFloat64"")"
The StreamStorageFS class contains a method to read bytes from a stream block file.,"(""StreamStorageFS"", ""The method 'read' is contained within the 'StreamStorageFS' class."", ""read"")"
"The readBytes() method reads bytes from the file represented by the given StreamStorageBlockFS instance, into the byte[] array passed as parameter.","(""ReadBytes"", ""The ReadBytes method reads bytes from a file represented by an instance of the StreamStorageBlockFS class."", ""StreamStorageBlockFS""); (""ReadBytes"", ""The ReadBytes method reads bytes into the Byte[] array passed as a parameter."", ""Byte[]"")"
You can always obtain the root directory path a StreamStorageRootFS was created with via its getRootDirPath() method.,"(""StreamStorageRootFS"", ""The getRootDirPath method is associated with the StreamStorageRootFS class as it is a method that can be called on instances of this class."", ""getRootDirPath"")"
"When you write records to a stream via the StreamStorageFS instance, the StreamStorageFS class will divide the records into multiple files.","(""StreamStorageFS"", ""The StreamStorageFS instance is an instance of the StreamStorageFS class."", ""StreamStorageFS""); (""StreamStorageFS"", ""The StreamStorageFS class is responsible for dividing records into multiple files when written to a stream."", ""StreamStorageFS"")"
You can read the data stored in a Buffer using the many get...() methods.,"(""Buffer"", ""The get...() methods are used to read data stored in a Buffer class."", ""get...() methods"")"
Notice the use of / as directory separator and the use of : as classpath entry separator.,"(""classpath"", ""The classpath is related to the directory as it uses '/' as a directory separator."", ""directory""); (""classpath"", ""The classpath is related to the entry as it uses ':' as a classpath entry separator."", ""entry"")"
"However, if you do need to access the body of the HTTP response, you need to register another handler on the HttpClientResponse that is passed as parameter to the first Handler's handle() method.","(""HttpClientResponse"", ""HttpClientResponse is passed as a parameter to the Handler's handle() method."", ""Handler""); (""Handler"", ""handle is a method of the Handler class."", ""handle"")"
"Again, the NetClient's close() method is asynchronous, so the underlying TCP connection may not yet be closed by the time the close() method returns.","(""NetClient"", ""The close method is a part of the NetClient class, indicating that it is a method belonging to this class."", ""close""); (""close"", ""The close method is related to the TCP package as it deals with closing a TCP connection."", ""TCP"")"
Sending messages via the event bus can be done via either the send() or publish() method on the event bus.,"(""Send"", ""The Send method is used on the Event Bus to send messages."", ""Event Bus""); (""Publish"", ""The Publish method is used on the Event Bus to publish messages."", ""Event Bus"")"
A verticle has a start() and a stop() method which are called when the verticle is deployed and when it is undeployed.,"(""Verticle"", ""The Start method is called when the Verticle is deployed, indicating a lifecycle relationship."", ""Start""); (""Verticle"", ""The Stop method is called when the Verticle is undeployed, indicating a lifecycle relationship."", ""Stop"")"
The addAll() method takes a Collection as parameter so you can pass either a List or Java Set as parameter,"(""AddAll"", ""The AddAll method takes a Collection as a parameter."", ""Collection""); (""Collection"", ""A List can be passed as a parameter to the Collection class."", ""List""); (""Collection"", ""A Java Set can be passed as a parameter to the Collection class."", ""Java Set"")"
But no thread can actually execute unlock() until the thread waiting in lock() leaves the outer synchronized block,"(""UNLOCK"", ""The method UNLOCK is related to the method LOCK because UNLOCK cannot execute until the thread waiting in LOCK leaves the synchronized block."", ""LOCK"")"
A thread cannot call wait() notify() or notifyAll() without holding the lock on the object the method is called on,"(""Wait"", ""Both methods are related as they are synchronization methods that require holding a lock on the object."", ""Notify""); (""Wait"", ""Both methods are related as they are synchronization methods that require holding a lock on the object."", ""NotifyAll""); (""Notify"", ""Both methods are related as they are synchronization methods that require holding a lock on the object."", ""NotifyAll"")"
"The Arrays class contains a set of methods called binarySearch(). This method helps you perform a binary search in an array. The array must first be sorted. You can do so yourself, or via the Arrays.sort() method covered earlier in this text.","(""Arrays"", ""The binarySearch method is part of the Arrays class."", ""binarySearch""); (""Arrays"", ""The sort method is part of the Arrays class."", ""sort""); (""binarySearch"", ""The binarySearch method requires the array to be sorted, which can be done using the sort method."", ""sort"")"
java.lang.ThreadLocal is possible to set an initial value for a Java ThreadLocal which will get used the first time get() is called before set() has been called with a new value,"(""Java.lang.ThreadLocal"", ""The Get method is used to retrieve the initial value from the Java.lang.ThreadLocal class."", ""Get""); (""Java.lang.ThreadLocal"", ""The Set method is used to assign a new value to the Java.lang.ThreadLocal class."", ""Set"")"
Adding and getting elements to a generic Map is done using the put() and get() methods just like you have always done,"(""Map"", ""The put method is used to add elements to the Map class."", ""put""); (""Map"", ""The get method is used to retrieve elements from the Map class."", ""get"")"
Deque.pollLast() is different than removeLast() which throws an exception if the Deque is empty,"(""Deque"", ""pollLast is a method of the Deque class"", ""pollLast""); (""Deque"", ""removeLast is a method of the Deque class"", ""removeLast""); (""pollLast"", ""pollLast and removeLast are methods that handle elements in a Deque, with different behaviors when the Deque is empty"", ""removeLast"")"
The tailSet() method works the same way as the headSet() method except it returns all elements that are equal to or higher than the given parameter element,"(""TailSet"", ""Both methods are used to return subsets of elements based on a given parameter, with TailSet returning elements equal to or higher, and HeadSet returning elements lower."", ""HeadSet"")"
"You can also obtain an Iterator from many of the Java Collection data structures, e.g. a List, Set, Map, Queue, Deque or Map.","(""Iterator"", ""Iterator is a class that can be obtained from many of the Java Collection data structures."", ""Java Collection""); (""Iterator"", ""Iterator can be obtained from a List, which is a type of Java Collection."", ""List""); (""Iterator"", ""Iterator can be obtained from a Set, which is a type of Java Collection."", ""Set""); (""Iterator"", ""Iterator can be obtained from a Map, which is a type of Java Collection."", ""Map""); (""Iterator"", ""Iterator can be obtained from a Queue, which is a type of Java Collection."", ""Queue""); (""Iterator"", ""Iterator can be obtained from a Deque, which is a type of Java Collection."", ""Deque"")"
java.io.Writer works just like combining the Reader with InputStream or the Writer with OutputStream,"(""Writer"", ""Writer is related to Reader as they are both used for handling input and output operations in Java."", ""Reader""); (""Writer"", ""Writer is related to InputStream as they are both used for handling input operations in Java."", ""InputStream""); (""Writer"", ""Writer is related to OutputStream as they are both used for handling output operations in Java."", ""OutputStream"")"
Remember that even if the 4 threads call wait() and notify() on the same shared string instance the signals from the doWait() and doNotify() calls are stored individually in the two MyWaitNotify instances,"(""WAIT"", ""The method doWait() likely calls or is related to the wait() method."", ""DOWAIT""); (""NOTIFY"", ""The method doNotify() likely calls or is related to the notify() method."", ""DONOTIFY""); (""DOWAIT"", ""The doWait() method is part of the MyWaitNotify class."", ""MYWAITNOTIFY""); (""DONOTIFY"", ""The doNotify() method is part of the MyWaitNotify class."", ""MYWAITNOTIFY"")"
The bigger the result String grows the longer it takes to copy the characters from it into a new StringBuilder and again copy the characters from the StringBuilder into the temporary String created by the toString() method,"(""StringBuilder"", ""The toString() method is used to create a temporary String from the StringBuilder."", ""toString""); (""String"", ""Characters are copied from the String into a new StringBuilder."", ""StringBuilder""); (""StringBuilder"", ""Characters are copied from the StringBuilder into a temporary String created by the toString() method."", ""String"")"
The logp() methods work like the log() methods except each method take an extra two parameters The sourceClass and sourceMethod parameter,"(""LOGP"", ""The LOGP methods work like the LOG methods, indicating a functional similarity or extension."", ""LOG""); (""LOGP"", ""The LOGP methods take SOURCECLASS as an extra parameter, indicating a dependency or input requirement."", ""SOURCECLASS""); (""LOGP"", ""The LOGP methods take SOURCEMETHOD as an extra parameter, indicating a dependency or input requirement."", ""SOURCEMETHOD"")"
But since the thread waiting in lock() has not yet called queueObject.wait() the call to queueObject.notify() passes into oblivion,"(""LOCK"", ""The method LOCK is related to QUEUEOBJECT.WAIT as the thread is waiting in LOCK before calling QUEUEOBJECT.WAIT."", ""QUEUEOBJECT.WAIT""); (""QUEUEOBJECT.WAIT"", ""The method QUEUEOBJECT.WAIT is related to QUEUEOBJECT.NOTIFY because QUEUEOBJECT.NOTIFY is called after QUEUEOBJECT.WAIT."", ""QUEUEOBJECT.NOTIFY"")"
Since PipedOutputStream is a subclass of OutputStream PipedOutputStream has the same basic methods and use patterns as an OutputStream,"(""PipedOutputStream"", ""PipedOutputStream is a subclass of OutputStream, indicating an inheritance relationship."", ""OutputStream""); (""PipedOutputStream"", ""PipedOutputStream shares the same basic methods and use patterns as OutputStream, suggesting a functional relationship."", ""OutputStream"")"
You can convert a Java Set to a Java List by creating a List and calling its addAll() method passing the Set as parameter to the addAll() method,"(""List"", ""The addAll method is called on a List to add elements from another collection."", ""addAll""); (""Set"", ""The addAll method takes a Set as a parameter to add its elements to a List."", ""addAll""); (""Set"", ""A Set is converted to a List by using the addAll method."", ""List"")"
Even though the Java Networking APIs enable you to open and close network connections via sockets all communication happens via the Java IO classes InputStream and OutputStream,"(""Java Networking APIs"", ""Java Networking APIs use InputStream for network communication."", ""InputStream""); (""Java Networking APIs"", ""Java Networking APIs use OutputStream for network communication."", ""OutputStream"")"
Again here the first() and next() methods return the unicode index of the found word boundary,"(""FIRST"", ""Both FIRST and NEXT are methods mentioned in the context of returning the unicode index of a found word boundary."", ""NEXT"")"
Obviously if the input parameter to contains() is null the contains() method will not use the equals() method to compare against each element but rather use the == operator,"(""CONTAINS"", ""The CONTAINS method uses the EQUALS method to compare elements when the input parameter is not null."", ""EQUALS"")"
Both Java File and FileChannel works but in case you want a pure Java NIO solution use the Java NIO FileChannel class,"(""Java File"", ""Both are classes mentioned as working solutions in the context of Java NIO."", ""FileChannel""); (""FileChannel"", ""FileChannel is a class that is part of the Java NIO package."", ""Java NIO"")"
If you need an integer value use the round() floor() or ceil() method,"(""Round"", ""Both are methods used to obtain integer values from a number."", ""Floor""); (""Round"", ""Both are methods used to obtain integer values from a number."", ""Ceil""); (""Floor"", ""Both are methods used to obtain integer values from a number."", ""Ceil"")"
The poll() and remove() both removes the first element in the Queue. They differ in how they behave if the Queue is empty. The poll() method returns null if the Queue is empty. The remove() method throws an exception if the Queue is empty.,"(""Poll"", ""The Poll method operates on the Queue class by removing the first element."", ""Queue""); (""Remove"", ""The Remove method operates on the Queue class by removing the first element."", ""Queue""); (""Poll"", ""Both Poll and Remove methods are used to remove the first element in the Queue, but they differ in behavior when the Queue is empty."", ""Remove"")"
"The add() and offer() methods differ in how the behave if the Queue is full, so no more elements can be added. The add() method throws an exception in that case, whereas the offer() method just returns false.","(""Add"", ""The Add method is related to the Queue class as it is a method that operates on a Queue."", ""Queue""); (""Offer"", ""The Offer method is related to the Queue class as it is a method that operates on a Queue."", ""Queue"")"
Each of the methods ceilingEntry() floorEntry() higherEntry() and lowerEntry() will be covered in the following sections,"(""CeilingEntry"", ""Both are methods that will be covered in the following sections"", ""FloorEntry""); (""CeilingEntry"", ""Both are methods that will be covered in the following sections"", ""HigherEntry""); (""CeilingEntry"", ""Both are methods that will be covered in the following sections"", ""LowerEntry""); (""FloorEntry"", ""Both are methods that will be covered in the following sections"", ""HigherEntry""); (""FloorEntry"", ""Both are methods that will be covered in the following sections"", ""LowerEntry""); (""HigherEntry"", ""Both are methods that will be covered in the following sections"", ""LowerEntry"")"
To do so set the upper bound to 1 and have the call to take() and release() guard the critical section,"(""take"", ""Both methods are used to guard the critical section, indicating they are related in managing access to shared resources."", ""release"")"
Once you have opened a socket (network connection) though you read and write data to and from it via Java IO InputStream and OutputStream classes,"(""Socket"", ""The InputStream class is used to read data from a Socket."", ""InputStream""); (""Socket"", ""The OutputStream class is used to write data to a Socket."", ""OutputStream""); (""Java IO"", ""The InputStream class is part of the Java IO package."", ""InputStream""); (""Java IO"", ""The OutputStream class is part of the Java IO package."", ""OutputStream"")"
Many of the core components in the Java Collection API rely on the correct implementation of the `hashCode()` and `equals()` methods.,"(""Java Collection API"", ""The hashCode method is a core component that the Java Collection API relies on for correct implementation."", ""hashCode""); (""Java Collection API"", ""The equals method is a core component that the Java Collection API relies on for correct implementation."", ""equals"")"
java.io.PrintWriter example first creates a PrintWriter instance which is connected to a FileWriter,"(""Java.io.PrintWriter"", ""PrintWriter is a class within the Java.io.PrintWriter package"", ""PrintWriter""); (""PrintWriter"", ""PrintWriter is connected to a FileWriter instance"", ""FileWriter"")"
InputStream.read() example creates an AsynchronousFileChannel and then creates a ByteBuffer which is passed to the read() method as parameter along with a position of 0,"(""InputStream"", ""The read method is associated with the InputStream class as it is a method that operates on input streams."", ""read""); (""AsynchronousFileChannel"", ""The ByteBuffer is used in conjunction with the AsynchronousFileChannel to read data asynchronously."", ""ByteBuffer""); (""read"", ""The read method takes ByteBuffer as a parameter to store the data being read."", ""ByteBuffer"")"
java.lang.StringBuffer text explains how to use the SimpleDateFormat class to format dates,"(""StringBuffer"", ""StringBuffer is part of the java.lang package"", ""java.lang""); (""SimpleDateFormat"", ""SimpleDateFormat is part of the java.lang package"", ""java.lang""); (""StringBuffer"", ""The text explains how to use the SimpleDateFormat class, which may involve using StringBuffer for string manipulation"", ""SimpleDateFormat"")"
In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not but the BufferedInputStream supports them,"(""markSupported"", ""The markSupported method is used to check if the mark method is supported."", ""mark""); (""markSupported"", ""The markSupported method is used to check if the reset method is supported."", ""reset""); (""BufferedInputStream"", ""BufferedInputStream supports the mark method."", ""mark""); (""BufferedInputStream"", ""BufferedInputStream supports the reset method."", ""reset""); (""BufferedInputStream"", ""BufferedInputStream can use the markSupported method to check support for mark and reset."", ""markSupported""); (""InputStream"", ""The markSupported method is used to check if mark and reset are supported on a given InputStream."", ""markSupported"")"
"The newLine() method which can write a new-line character to the underlying Writer. In addition, you may need to call flush() if you need to be absolutely sure that the characters written until now is flushed out of the buffer and onto the network or disk.","(""NewLine"", ""Both are methods that deal with writing and managing output in a Writer context."", ""Flush"")"
Queue.poll() is different than remove() which throws an exception if the Deque is empty,"(""Queue"", ""The method 'poll' is associated with the class 'Queue'."", ""poll""); (""Queue"", ""The method 'remove' is associated with the class 'Queue'."", ""remove""); (""Deque"", ""The method 'remove' is associated with the class 'Deque'."", ""remove""); (""poll"", ""The methods 'poll' and 'remove' are compared in terms of their behavior when the Deque is empty."", ""remove"")"
Notice the two synchronized blocks inside the set() and get() method. Notice how the blocks are placed last and first in the two methods.,"(""Set"", ""Both methods contain synchronized blocks, indicating a relationship in their functionality or usage."", ""Get"")"
"The replace() method will only insert the new value if there is already an existing value mapped to the key. If no existing value is mapped to the given key, no value is inserted. This is different from how put() works, which always insert the value no matter what.","(""Replace"", ""Both are methods that handle value insertion in different ways."", ""Put""); (""Replace"", ""The replace() method is described in the text."", ""Replace""); (""Put"", ""The put() method is described in the text."", ""Put"")"
The logrb() methods work like the log() methods too except they can obtain the log messages from a resource bundle,"(""LOGRB"", ""The LOGRB methods work like the LOG methods, indicating a functional similarity or shared purpose."", ""LOG"")"
The Handler in the Java Logging API use a java.util.logging.Formatter to format the LogRecord before writing it to an external system,"(""Handler"", ""The Handler uses a Formatter to format the LogRecord."", ""java.util.logging.Formatter""); (""Handler"", ""The Handler formats the LogRecord before writing it to an external system."", ""LogRecord""); (""Java Logging API"", ""The Handler is part of the Java Logging API."", ""Handler""); (""java.util.logging.Formatter"", ""The Formatter is used to format the LogRecord."", ""LogRecord"")"
