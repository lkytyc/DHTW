The Collections reverse() method can reverse the elements in a Java List.,"[""('method', 'dependency', 'class'): (reverse, can reverse, list)""]"
Here is an example of finding the minimum element in a Java List using Collections min() method:,"[""('class', 'dependency', 'method'): (collections, uses, min)"", ""('method', 'implementation', 'class'): (min, is implemented in, collections)""]"
"Notice too, that the compareTo() method should throw a NullPointerException if the parameter object is null.","[""('method', 'dependency', 'class'): (compareto, should throw, nullpointerexception)"", ""('method', 'interrupt', 'class'): (compareto, throw, nullpointerexception)""]"
The LinkedList class is a pretty standard Deque and Queue implementation.,"[""('class', 'implementation', 'class'): (linkedlist, is a standard implementation of, deque)"", ""('class', 'implementation', 'class'): (linkedlist, is a standard implementation of, queue)""]"
You add elements to the beginning end of a Deque using the add() method.,"[""('method', 'dependency', 'class'): (add, used for, deque)"", ""('class', 'implementation', 'method'): (deque, uses, add)""]"
"If the element cannot be inserted into the Deque, the add() method will throw an exception.","[""('class', 'dependency', 'method'): (deque, relies on for insertion, add)"", ""('method', 'interrupt', 'class'): (add, will throw exception when cannot be inserted into, deque)""]"
"If the element cannot be inserted into the Deque, the addLast() method will throw an exception.","[""('class', 'dependency', 'method'): (deque, cannot be inserted into, addlast)"", ""('class', 'containment', 'method'): (deque, inserted into, addlast)""]"
To peek at the last element of a Java Deque you can use the getLast() method.,"[""('class', 'dependency', 'method'): (deque, uses, getlast)"", ""('class', 'implementation', 'method'): (deque, implements, getlast)""]"
The remove() method removes the first element of a Java Deque.,"[""('class', 'containment', 'method'): (deque, has element removed by, remove)""]"
"The pollFirst() method removes an element from the beginning of the Deque, just like poll().","[""('method', 'dependency', 'class'): (pollfirst, removes an element from, deque)"", ""('method', 'dependency', 'class'): (poll, removes an element from, deque)""]"
Here is an example of removing the last element from a Java Deque using the pollLast() method:,"[""('method', 'dependency', 'class'): (polllast, used on, deque)"", ""('method', 'implementation', 'class'): (polllast, removes from, deque)""]"
The Java Deque size() method returns the number of elements stored in the Java Deque at the time you invoke the method.,"[""('class', 'dependency', 'method'): (deque, returns the number of elements stored in, size())"", ""('class', 'containment', 'method'): (deque, has, size())""]"
"Because the Iterator has its generic type set to String, the Java compiler already knows that next() will return a String.","[""('class', 'dependency', 'class'): (iterator, has its generic type set to, string)"", ""('class', 'dependency', 'class'): (iterator, has next() that returns a, string)"", ""('method', 'dependency', 'class'): (next, returns a, string)""]"
"As you can see, a proper implementation of .equals() is essential for your own classes to work well with the Java Collection classes.","[""('method', 'dependency', 'class'): (.equals(), is essential for, collection)"", ""('method', 'implementation', 'class'): (.equals(), work well with, collection)""]"
"So, as you can see, a combination of the hashCode() and equals() methods are used when storing and when looking up objects in a hashtable.","[""('method', 'dependency', 'method'): (hashcode, used with, equals)"", ""('method', 'dependency', 'class'): (hashcode, used with, hashtable)"", ""('method', 'dependency', 'class'): (equals, used with, hashtable)""]"
"Then it uses a for-each loop to iterate the elements of the List, and print out the toString() value of each element.","[""('class', 'containment', 'method'): (list, contains, tostring)""]"
Here is an example of iterating the elements of an Iterable via its forEach() method:,"[""('method', 'dependency', 'class'): (foreach, relies on, iterable)"", ""('method', 'implementation', 'class'): (foreach, iterates over, iterable)""]"
"The reason the for-each loop is slower is, that each iteration will call the List iterator() method, which will create a new Iterator object.",[]
"In other words, if the Iterator has not yet iterated over all of the elements in the collection the Iterator was obtained from - the hasNext() method will return true.",[]
The first three add() calls add a String instance to the end of the list.,"[""('class', 'containment', 'class'): (list, contains, string)"", ""('method', 'dependency', 'class'): (add, relies on, list)"", ""('class', 'containment', 'class'): (list, contains, string)""]"
"The addAll() method takes a Collection as parameter, so you can pass either a List or Java Set as parameter.","[""('method', 'dependency', 'interface'): (addall, takes as parameter, collection)"", ""('method', 'dependency', 'class'): (addall, takes as parameter, list)"", ""('method', 'dependency', 'class'): (addall, takes as parameter, set)"", ""('method', 'dependency', 'class'): (addall, takes as parameter, java set)"", ""('interface', 'containment', 'class'): (collection, can contain, list)"", ""('interface', 'containment', 'class'): (collection, can contain, set)"", ""('interface', 'containment', 'class'): (collection, can contain, java set)"", ""('class', 'similarity', 'class'): (list, is similar to, set)"", ""('class', 'similarity', 'class'): (list, is similar to, java set)"", ""('class', 'similarity', 'class'): (set, is similar to, java set)""]"
"Notice that the get() method returns a Java Object, so we have to cast it to a String (because we know the value is a String).","[""('class', 'conversion', 'class'): (object, cast to, string)"", ""('method', 'dependency', 'class'): (get, returns, string)""]"
"This example creates a Map and stores three values in it using the keys A, B and C. Then the example calls the Map getOrDefault() method, passing the String E as key, along with a default value - the String default value.","[""('class', 'dependency', 'method'): (map, calls the getordefault() method, getordefault)"", ""('class', 'implementation', 'method'): (map, stores values using and then calls, getordefault)""]"
Since the Map does not contain any object stored by the key E the given default value will be returned - which is the String default value passed as the last parameter to the getOrDefault() method.,"[""('class', 'dependency', 'method'): (map, does not contain any object stored by the key e, getordefault)"", ""('method', 'dependency', 'class'): (getordefault, returns the given default value, string)"", ""('class', 'containment', 'class'): (map, does not contain, string)""]"
"As you can see, the key Iterator returns every key stored in a Java Map, one by one (one for each call to next()).","[""('class', 'dependency', 'class'): (iterator, returns every key stored in, map)"", ""('class', 'implementation', 'class'): (iterator, uses to retrieve keys from, map)"", ""('class', 'dependency', 'method'): (map, relies on iterator for key retrieval with, next)""]"
The number of entries in a Java Map is also referred to as the Map size - hence the method name size() .,"[""('method', 'dependency', 'class'): (size(), size, map)""]"
The isEmpty() method will return false if the Map instance contains 1 or more entries.,"[""('method', 'dependency', 'class'): (isempty(), returns false if contains, map)"", ""('class', 'dependency', 'method'): (map, relies on, isempty())""]"
Here is an example of creating an instance of the Java TreeMap class which implements the NavigableMap interface:,"[""('class', 'implementation', 'interface'): (treemap, implements, navigablemap)""]"
"The tailMap variable will reference a SortedMap containing all key + value pairs from the NavigableMap for the keys ""c"", ""d"" and ""e"", as these keys are considered equal to or larger than the parameter value ""c"" passed to the tailMap() method.","[""('class', 'containment', 'class'): (navigablemap, contains, sortedmap)"", ""('method', 'dependency', 'class'): (tailmap, references, sortedmap)"", ""('class', 'dependency', 'class'): (sortedmap, is referenced by, navigablemap)"", ""('class', 'creation', 'class'): (navigablemap, creates, sortedmap)""]"
The lowerEntry() method in the NavigableMap interface returns the key + value pair for the highest key which is lower than the parameter value passed to the lowerEntry() method.,"[""('interface', 'dependency', 'method'): (navigablemap, has_method, lowerentry)"", ""('method', 'implementation', 'interface'): (lowerentry, is_part_of, navigablemap)""]"
"The pollFirstEntry() method returns and removes the ""first"" entry (key + value) in the NavigableMap or null if the map is empty.","[""('method', 'dependency', 'class'): (pollfirstentry, returns and removes entry from, navigablemap)"", ""('class', 'dependency', 'method'): (navigablemap, has entry returned and removed by, pollfirstentry)""]"
"The descendingIterator() method allows you to iterate the elements of the NavigableSet (which is also a SortedSet) in reverse order, without changing the order of the elements internally.","[""('method', 'dependency', 'class'): (descendingiterator, allows iteration on, navigableset)"", ""('method', 'dependency', 'class'): (descendingiterator, allows iteration on, sortedset)"", ""('class', 'similarity', 'class'): (navigableset, is also a type of, sortedset)""]"
"To get properties from a Java Properties object you use the getProperty() method, passing the key of the property to get as parameter.","[""('method', 'dependency', 'class'): (getproperty, relies on to retrieve, properties)"", ""('class', 'dependency', 'method'): (properties, is relied on by, getproperty)""]"
"Using the InputStream you can load the file into a Java Properties instance, using either the load() or loadFromXML() methods explained earlier in this Java Properties tutorial.","[""('class', 'dependency', 'class'): (inputstream, can load into, properties)"", ""('class', 'dependency', 'method'): (inputstream, can be used with, load)"", ""('class', 'dependency', 'method'): (inputstream, can be used with, loadfromxml)"", ""('class', 'dependency', 'method'): (properties, can be loaded by, load)"", ""('class', 'dependency', 'method'): (properties, can be loaded by, loadfromxml)"", ""('method', 'difference', 'method'): (load, is different from, loadfromxml)""]"
Here are two examples of taking an element from a Java Queue using its poll() and remove() methods:,"[""('method', 'dependency', 'method'): (poll, used in conjunction with, remove)"", ""('class', 'containment', 'method'): (queue, uses, poll)"", ""('class', 'containment', 'method'): (queue, uses, remove)"", ""('method', 'similarity', 'method'): (poll, compared to, remove)""]"
You can check if a Java Queue contains a certain element via its contains() method.,[]
The Java Set interface as a method called removeAll() which removes all elements in the Set which are also present in another Collection.,"[""('interface', 'dependency', 'method'): (set, has method, removeall)"", ""('method', 'dependency', 'interface'): (removeall, takes elements from, collection)"", ""('interface', 'dependency', 'interface'): (set, uses, collection)""]"
You can check the size of a Java Set using the size() method.,"[""('method', 'dependency', 'class'): (size, is obtained from, set)"", ""('class', 'dependency', 'method'): (set, has size, size)""]"
"You iterate the keys of a SortedMap by calling its keySet() method, like this:",[]
The SortedMap interface has a method named headMap() which returns a new Map which contains the first elements of the SortedMap according to the sort order used.,"[""('class', 'containment', 'class'): (sortedmap, contains, map)"", ""('class', 'creation', 'class'): (sortedmap, creates, map)"", ""('class', 'dependency', 'class'): (map, depends on, sortedmap)"", ""('class', 'containment', 'method'): (sortedmap, contains, headmap)"", ""('method', 'creation', 'class'): (headmap, creates, map)""]"
Here is an example of obtaining a submap from a Java SortedMap via its subMap() method:,"[""('class', 'containment', 'method'): (sortedmap, obtains, submap)"", ""('method', 'creation', 'class'): (submap, created from, sortedmap)""]"
The Java Collections API only has one implementation of the Java SortedSet interface - the java.util.TreeSet class.,"[""('class', 'implementation', 'interface'): (java.util.treeset, is the implementation of, java sortedset)""]"
"Additionally, the Vector class uses several older (no longer recommended) parts of Java, like the Enumeration which is superseded by the Iterator interface.","[""('class', 'dependency', 'class'): (vector, uses, enumeration)"", ""('class', 'dependency', 'interface'): (vector, uses, iterator)""]"
You push elements onto a Java Stack using its push() method.,[]
Here is an example of obtaining the size of a Java Stack via its size() method:,"[""('method', 'dependency', 'class'): (size, obtained from, stack)"", ""('class', 'dependency', 'method'): (stack, has, size())"", ""('class', 'implementation', 'method'): (stack, uses, size())""]"
The lockWrite() method of a ReadWriteLock class shown below is an example of a test-and-set method.,"[""('method', 'dependency', 'class'): (lockwrite, is a method of, readwritelock)"", ""('method', 'implementation', 'class'): (lockwrite, is an example of a test-and-set method in, readwritelock)""]"
The BoundedSemaphore class shown below has two test-and-set methods: take() and release().,"[""('class', 'containment', 'method'): (boundedsemaphore, has methods, take)"", ""('class', 'containment', 'method'): (boundedsemaphore, has methods, release)"", ""('method', 'dependency', 'method'): (release, is paired with, take)""]"
Here is an example showing how to implement the lock() method shown earlier using the AtomicBoolean class:,"[""('class', 'implementation', 'method'): (atomicboolean, is used to implement, lock)""]"
"a stop() or pause() method too), then you can no longer create your Runnable implementation with a Java lambda expression.",[]
"If a thread (1) calls the parent.addChild(child) method at the same time as another thread (2) calls the child.setParent(parent) method, on the same parent and child instances, a deadlock can occur.","[""('method', 'dependency', 'method'): (parent.addchild, can cause deadlock with, child.setparent)"", ""('method', 'dependency', 'method'): (child.setparent, can cause deadlock with, parent.addchild)"", ""('method', 'implementation', 'method'): (parent.addchild, calls at the same time as, child.setparent)"", ""('method', 'implementation', 'method'): (child.setparent, calls at the same time as, parent.addchild)""]"
"Here are the two classes used in the example above, Counter and CounterThread.","[""('class', 'implementation', 'class'): (counter, used in the example above with, counterthread)"", ""('class', 'dependency', 'class'): (counterthread, relies on, counter)""]"
"The easiest way to create a subclass of ThreadLocal is to simply create an anonymous subclass, right where you create the ThreadLocal variable.","[""('class', 'containment', 'class'): (threadlocal, is a subclass of, threadlocal)""]"
"Here is an example of creating a ThreadLocal using its withInitial() static factory method, passing a simple Supplier implementation as parameter:","[""('class', 'dependency', 'class'): (threadlocal, relies on, supplier)"", ""('class', 'implementation', 'class'): (threadlocal, uses, supplier)"", ""('class', 'dependency', 'method'): (threadlocal, depends on, threadlocal.withinitial)"", ""('class', 'implementation', 'method'): (supplier, implements, threadlocal.withinitial)"", ""('class', 'dependency', 'method'): (supplier, relies on, threadlocal.withinitial)""]"
Notice how the format() method calls the getThreadLocalSimpleDateFormat() method to obtain a Java SimpleDatFormat instance.,"[""('method', 'dependency', 'method'): (format, calls, getthreadlocalsimpledateformat)"", ""('method', 'dependency', 'class'): (format, uses, simpledatformat)"", ""('method', 'dependency', 'class'): (getthreadlocalsimpledateformat, returns, simpledatformat)""]"
"The Counter class could have been written like this instead, using a Lock instead of a synchronized block:","[""('class', 'replacement', 'class'): (counter, could have been written using, lock)"", ""('class', 'implementation', 'class'): (counter, written with, lock)""]"
"While isLocked is true, the thread calling lock() is parked waiting in the wait() call.","[""('method', 'dependency', 'method'): (lock, is waiting in, wait)"", ""('method', 'dependency', 'method'): (wait, is used when, lock)""]"
"When the thread is done with the code in the critical section (the code between lock() and unlock()), the thread calls unlock().","[""('method', 'dependency', 'method'): (lock, relies on for critical section execution, unlock)"", ""('method', 'dependency', 'method'): (unlock, is called after, lock)""]"
"Otherwise, a single call to unlock() will unlock the lock, even if the lock has been locked multiple times.","[""('method', 'dependency', 'method'): (unlock, is used to release, lock)"", ""('method', 'dependency', 'method'): (lock, requires, unlock)""]"
"That you would not call wait() and notify() on an internal monitor object, but rather on the This is probably true.","[""('method', 'dependency', 'method'): (wait, should not be called together, notify)"", ""('method', 'dependency', 'method'): (notify, should not be called together, wait)""]"
This is how such exclusive access could look using a synchronized block in Java: public class SynchronizedCounter { long count = 0; public void inc() { synchronized(this) { count++; } } public long count() { synchronized(this) { return this.count; } } } Notice how the inc() and count() methods both contain a synchronized block.,"[""('method', 'dependency', 'method'): (synchronized, is used in, inc)"", ""('method', 'dependency', 'method'): (synchronized, is used in, count)"", ""('method', 'implementation', 'method'): (inc, is part of, synchronized)"", ""('method', 'implementation', 'method'): (count, is part of, synchronized)"", ""('method', 'similarity', 'method'): (inc, has similar synchronization as, count)""]"
"import java.util.concurrent.atomic.AtomicBoolean; import java.util.concurrent.atomic.AtomicStampedReference; public class NonblockingTemplate { public static class IntendedModification { public AtomicBoolean completed = new AtomicBoolean(false); } private AtomicStampedReference<IntendedModification> ongoingMod = new AtomicStampedReference<IntendedModification>(null, 0); //declare the state of the data structure here.","[""('class', 'dependency', 'class'): (atomicboolean, is_used_by, atomicstampedreference)"", ""('class', 'containment', 'class'): (atomicstampedreference, contains, atomicboolean)""]"
Here is how the lockRead() and unlockRead() methods looks after that change:,"[""('method', 'dependency', 'method'): (lockread, looks after that change with, unlockread)"", ""('method', 'implementation', 'method'): (lockread, interacts through messaging with, unlockread)""]"
Here is how the lockWrite() and unlockWrite() methods look after that change:,"[""('method', 'dependency', 'method'): (unlockwrite, is relied upon by, lockwrite)""]"
"You can read more about it in the java.util.concurrent.Semaphore text, in my java.util.concurrent tutorial.",[]
The take() method sends a signal which is stored internally in the Semaphore.,"[""('method', 'dependency', 'class'): (take, sends a signal to, semaphore)"", ""('method', 'implementation', 'class'): (take, sends a signal which is stored internally in, semaphore)""]"
"That way the signal is not missed, even if doNotify() is called before doWait().","[""('method', 'dependency', 'method'): (dowait, is called after, donotify)"", ""('method', 'dependency', 'method'): (donotify, is called before, dowait)""]"
"If you look at the Synchronizer class above and look into this Lock implementation you will notice that threads are now blocked trying to access the lock() method, if more than one thread calls lock() simultanously.","[""('class', 'dependency', 'class'): (synchronizer, relies on, lock)"", ""('class', 'implementation', 'class'): (lock, is part of, synchronizer)"", ""('class', 'containment', 'class'): (synchronizer, contains, lock)""]"
"The thread calling unlock() will take the top QueueObject in the queue and call doNotify() on it, to awaken the thread waiting on that object.","[""('method', 'implementation', 'method'): (unlock, calls, donotify)"", ""('method', 'implementation', 'class'): (unlock, uses, queueobject)"", ""('method', 'dependency', 'class'): (donotify, relies on, queueobject)""]"
"The queueObject.doWait() call is placed outside the synchronized(this) block to avoid nested monitor lockout, so another thread can actually call unlock() when no thread is executing inside the synchronized(this) block in lock() method.","[""('method', 'dependency', 'method'): (queueobject.dowait, relies on, unlock)"", ""('method', 'dependency', 'method'): (queueobject.dowait, avoids, synchronized)"", ""('method', 'dependency', 'method'): (queueobject.dowait, waits for, lock)"", ""('method', 'dependency', 'method'): (unlock, is called when, synchronized)"", ""('method', 'dependency', 'method'): (unlock, is called when, lock)""]"
"Below here is the PoolThreadRunnable class which implements the Runnable interface, so it can be executed by a Java thread:","[""('class', 'implementation', 'interface'): (poolthreadrunnable, implements, runnable)"", ""('class', 'dependency', 'class'): (poolthreadrunnable, can be executed by, thread)""]"
"Notice how the add() method returns a new ImmutableValue instance with the result of the add operation, rather than adding the value to itself.","[""('method', 'creation', 'class'): (add, returns a new instance of, immutablevalue)"", ""('class', 'dependency', 'method'): (immutablevalue, is returned by, add)""]"
"The class java.lang.Object defines three methods, wait(), notify(), and notifyAll(), to facilitate this.","[""('class', 'containment', 'method'): (java.lang.object, defines, wait)"", ""('class', 'containment', 'method'): (java.lang.object, defines, notify)"", ""('class', 'containment', 'method'): (java.lang.object, defines, notifyall)"", ""('method', 'dependency', 'method'): (wait, is used with, notify)"", ""('method', 'dependency', 'method'): (wait, is used with, notifyall)"", ""('method', 'dependency', 'method'): (notify, is used with, wait)"", ""('method', 'dependency', 'method'): (notify, is used with, notifyall)"", ""('method', 'dependency', 'method'): (notifyall, is used with, wait)"", ""('method', 'dependency', 'method'): (notifyall, is used with, notify)""]"
"In other words, the calling thread must call wait() or notify() from inside a synchronized block.","[""('method', 'dependency', 'method'): (wait, must be called from inside a synchronized block where notify is called, notify)"", ""('method', 'dependency', 'method'): (notify, must be called from inside a synchronized block where wait is called, wait)""]"
The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called.,"[""('method', 'dependency', 'method'): (notify(), have similar behavior to, notifyall())"", ""('method', 'similarity', 'method'): (notify(), have similar function as, notifyall())"", ""('method', 'implementation', 'method'): (notify(), interact through messaging with, notifyall())""]"
"If the doNotify() method had called notifyAll() instead of notify(), all waiting threads had been awakened and checked for signals in turn.","[""('method', 'dependency', 'method'): (donotify(), calls, notify())"", ""('method', 'difference', 'method'): (notify(), differs from, notifyall())"", ""('method', 'difference', 'method'): (notify(), differs from, notifyall())"", ""('method', 'dependency', 'method'): (donotify(), calls, notifyall())""]"
"The other of C and D would go back to waiting, because the thread discovering the signal clears it on the way out of doWait().",[]
"The method compareAndSet() allows you to compare the current value of the AtomicBoolean to an expected value, and if current value is equal to the expected value, a new value can be set on the AtomicBoolean.","[""('method', 'dependency', 'class'): (compareandset, allows modification of, atomicboolean)"", ""('method', 'implementation', 'class'): (compareandset, is used with, atomicboolean)""]"
"The AtomicInteger class provides you with a int variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().","[""('class', 'containment', 'method'): (atomicinteger, contains, compareandset)"", ""('class', 'dependency', 'method'): (atomicinteger, relies on, compareandset)""]"
You can get the value of an AtomicInteger instance via the get() method.,[]
Calling addAndGet() is also an atomic operation (like all operations on the AtomicIntegerArray).,"[""('method', 'implementation', 'class'): (addandget, is_implemented_through, atomicintegerarray)""]"
You should check out the JavaDoc for the AtomicIntegerArray class to learn more about those methods.,[]
"The AtomicLong class provides you with a long variable which can be read and written atomically, and which also contains advanced atomic operations like compareAndSet().","[""('class', 'implementation', 'method'): (atomiclong, provides, compareandset)""]"
You can set the value of an AtomicLong instance via the set() method.,"[""('class', 'dependency', 'method'): (atomiclong, can be set via, set)"", ""('class', 'implementation', 'method'): (atomiclong, set value using, set)""]"
The Java AtomicLongArray class (java.util.concurrent.atomic.AtomicLongArray) represents an array of long .,[]
You can get the value of a given element using the get() method on the AtomicLongArray.,"[""('class', 'dependency', 'method'): (atomiclongarray, has method, get)""]"
You can set the value of a given element using the set() method on the AtomicLongArray.,"[""('method', 'dependency', 'class'): (set, used on, atomiclongarray)"", ""('method', 'implementation', 'class'): (set, called on, atomiclongarray)""]"
"AtomicReference even has an advanced compareAndSet() method which lets you compare the reference to an expected value (reference) and if they are equal, set a new reference inside the AtomicReference object.","[""('class', 'dependency', 'method'): (atomicreference, has, compareandset)"", ""('class', 'containment', 'method'): (atomicreference, contains, compareandset)""]"
Notice how it is no longer necessary to cast the referenced returned by get() because the compiler knows it will return a String reference.,[]
"The compareAndSet() method can compare the reference stored in the AtomicReference instance with an expected reference, and if they two references are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicReference instance.","[""('method', 'dependency', 'class'): (compareandset, relies on, atomicreference)"", ""('method', 'implementation', 'class'): (compareandset, interacts with, atomicreference)""]"
If you have a typed AtomicStampedReference then getReference() returns a reference to the type you declared on the AtomicStampedReference variable when you created it.,"[""('class', 'dependency', 'method'): (atomicstampedreference, returns a reference to the type declared on, getreference)"", ""('method', 'dependency', 'class'): (getreference, returns a reference to the type declared on, atomicstampedreference)""]"
The AtomicStampedReference also contains a getStamp() method which can be used to obtain the internally stored stamp.,"[""('class', 'containment', 'method'): (atomicstampedreference, contains, getstamp)"", ""('method', 'dependency', 'class'): (getstamp, is_part_of, atomicstampedreference)""]"
"The compareAndSet() method can compare the reference stored in the AtomicStampedReference instance with an expected reference, and the stored stamp with an expected stamp, and if they two references and stamps are the same (not equal as in equals() but same as in ==), then a new reference can be set on the AtomicStampedReference instance.","[""('method', 'dependency', 'class'): (compareandset, relies on, atomicstampedreference)"", ""('method', 'implementation', 'class'): (compareandset, interacts with, atomicstampedreference)""]"
"The BlockingDeque interface in the java.util.concurrent class represents a deque which is thread safe to put into, and take instances from.",[]
"The ConcurrentMap has a few extra atomic methods in addition to the methods it inherits from its superinterface, java.util.Map.","[""('class', 'dependency', 'interface'): (concurrentmap, relies on methods from, java.util.map)""]"
"The java.util.concurrent.ConcurrentNavigableMap class is a java.util.NavigableMap with support for concurrent access, and which has concurrent access enabled for its submaps.","[""('class', 'dependency', 'class'): (java.util.concurrent.concurrentnavigablemap, is a type of, java.util.navigablemap)"", ""('class', 'containment', 'class'): (java.util.concurrent.concurrentnavigablemap, has, java.util.navigablemap)"", ""('class', 'implementation', 'class'): (java.util.concurrent.concurrentnavigablemap, implements, java.util.navigablemap)""]"
"First, the BlockingQueueExample class which starts a Producer and a Consumer in separate threads.",[]
The Java BlockingQueue add() method will add the element passed as parameter to this method if the BlockingQueue has space for it internally.,"[""('class', 'dependency', 'method'): (blockingqueue, uses, add)"", ""('method', 'dependency', 'class'): (add, is used by, blockingqueue)""]"
"If the BlockingQueue does not have space internally for this new element, the add() method throws an IllegalStateException.","[""('class', 'dependency', 'class'): (blockingqueue, throws, illegalstateexception)"", ""('method', 'dependency', 'class'): (add, throws, illegalstateexception)"", ""('class', 'containment', 'method'): (blockingqueue, has, add)""]"
The remove() method will use the o.equals(element) to decide if the object o passed as parameter matches a given element in the BlockingQueue.,"[""('method', 'dependency', 'class'): (remove, uses, blockingqueue)"", ""('method', 'implementation', 'class'): (remove, interacts with, blockingqueue)""]"
"If the BlockingQueue does not contain any elements, the element() method will throw a NoSuchElementException.","[""('class', 'dependency', 'class'): (blockingqueue, throws, nosuchelementexception)"", ""('method', 'dependency', 'class'): (element, is thrown by, blockingqueue)"", ""('class', 'containment', 'method'): (blockingqueue, does not contain, element)""]"
The result of that is that the call() method will return a String.,"[""('method', 'dependency', 'class'): (call, will return, string)""]"
"The Java ExecutorService interface, java.util.concurrent.ExecutorService, represents an asynchronous execution mechanism which is capable of executing tasks concurrently in the background.",[]
"The Java ExecutorService execute(Runnable) method takes a java.lang.Runnable object, and executes it asynchronously.","[""('class', 'dependency', 'class'): (executorservice, takes, runnable)"", ""('class', 'dependency', 'class'): (executorservice, executes, runnable)"", ""('class', 'implementation', 'class'): (executorservice, execute, runnable)"", ""('class', 'dependency', 'class'): (runnable, is executed by, executorservice)"", ""('class', 'implementation', 'class'): (runnable, execute, executorservice)"", ""('method', 'dependency', 'class'): (execute, is method of, executorservice)""]"
"The invokeAny() method takes a collection of Callable objects, or subinterfaces of Callable.","[""('method', 'dependency', 'class'): (invokeany, takes, callable)""]"
The invokeAll() method invokes all of the Callable objects you pass to it in the collection passed as parameter.,"[""('method', 'dependency', 'class'): (invokeall, invokes, callable)"", ""('method', 'implementation', 'class'): (invokeall, interacts with, callable)""]"
The main difference between the Runnable run() method and the Callable call() method is that the call() method can return an Object from the method call.,"[""('method', 'difference', 'method'): (run(), has different return type, call())"", ""('method', 'difference', 'method'): (run(), differs in return value, call())"", ""('method', 'dependency', 'class'): (run(), is part of, runnable)"", ""('method', 'dependency', 'interface'): (call(), is part of, callable)"", ""('method', 'difference', 'method'): (call(), differs from, run())""]"
"The ExecutorService awaitTermination() method will block the thread calling it until either the ExecutorService has shutdown completely, or until a given time out occurs.","[""('class', 'dependency', 'method'): (executorservice, relies on, awaittermination)"", ""('method', 'interrupt', 'class'): (awaittermination, interrupts, executorservice)""]"
The awaitTermination() method is typically called after calling shutdown() or shutdownNow().,"[""('method', 'dependency', 'method'): (awaittermination, is typically called after, shutdown)"", ""('method', 'dependency', 'method'): (awaittermination, is typically called after, shutdownnow)"", ""('method', 'difference', 'method'): (shutdown, is different from, shutdownnow)""]"
In the following sections I will explain how to use the ReentrantLock class as a Lock.,"[""('class', 'implementation', 'class'): (reentrantlock, used as, lock)"", ""('class', 'dependency', 'class'): (lock, relies on, reentrantlock)""]"
To unlock the Lock instance you must call its unlock() method.,[]
"To better understand how using a Lock looks different from using a synchronized block, I have created two simple concurrent Counter classes which protects their internal count in different ways.","[""('class', 'dependency', 'class'): (counter, protects their internal count using, lock)"", ""('class', 'implementation', 'class'): (lock, protects the internal count of, counter)""]"
"Notice how the calculate() method both locks the Calculator instance's Lock before performing any calculations, and also call the add() and subtract() methods which also locks the lock.","[""('method', 'dependency', 'method'): (calculate, relies on, add)"", ""('method', 'dependency', 'method'): (calculate, relies on, subtract)"", ""('method', 'dependency', 'class'): (calculate, locks, lock)"", ""('method', 'dependency', 'class'): (add, relies on, lock)"", ""('method', 'dependency', 'class'): (subtract, relies on, lock)"", ""('method', 'implementation', 'method'): (calculate, calls, add)"", ""('method', 'implementation', 'method'): (calculate, calls, subtract)""]"
"If the Lock instance is already locked, the thread calling lock() is blocked until the Lock is unlocked.","[""('class', 'dependency', 'class'): (lock, is blocked until the lock is unlocked by, lock)""]"
The Java ReentrantLock getHoldCount() method returns the number of times a given thread has locked this Lock instance.,"[""('class', 'dependency', 'class'): (reentrantlock, returns the number of times a given thread has locked, lock)"", ""('class', 'dependency', 'class'): (reentrantlock, locked by a thread, lock)"", ""('class', 'implementation', 'method'): (reentrantlock, locked through, getholdcount)"", ""('method', 'dependency', 'class'): (getholdcount, returns a value based on, lock)""]"
"The Java CertPath class (java.security.cert.CertPath represents a chain of cryptographic identity certificates (Java Certificate objects), where each certificate is the digital signer of the next certificate in the chain.",[]
The CertPath getType() method returns a string telling what type of certificates (e.g.,"[""('method', 'implementation', 'class'): (gettype, returns a string telling what type of certificates, certpath)"", ""('class', 'containment', 'method'): (certpath, has a method called, gettype)""]"
If you want to set a different offset for the dest byte array there is a version of update() and doFinal() which takes an offset parameter extra.,"[""('method', 'dependency', 'method'): (update, has a version of, dofinal)"", ""('method', 'dependency', 'method'): (dofinal, has a version of, update)""]"
Notice the call to update() and then doFinal() for these two blocks of data.,"[""('method', 'dependency', 'method'): (update, notice the call to update() and then dofinal(), dofinal)"", ""('method', 'dependency', 'method'): (dofinal, is called after update() in these two blocks of data, update)""]"
To generate an asymmetric key pair you can use the KeyPairGenerator (java.security.KeyPairGenerator).,[]
You create a KeyGenerator instance by calling the static method getInstance() passing as parameter the name of the encryption algorithm to create a key for.,"[""('method', 'dependency', 'class'): (getinstance, called by, keygenerator)""]"
Initializing a KeyGenerator instance is done by calling its init() method.,"[""('class', 'dependency', 'method'): (keygenerator, is initialized by calling, init)"", ""('class', 'implementation', 'method'): (keygenerator, initializes through, init)""]"
Generating a key is done by calling the KeyGenerator generateKey() method.,[]
You can access the PublicKey of a KeyPair by calling its getPublic() method.,"[""('class', 'dependency', 'method'): (keypair, can be accessed by calling, getpublic)"", ""('class', 'implementation', 'method'): (keypair, is accessed through, getpublic)""]"
You can access the PrivateKey of a KeyPair by calling the getPrivate() method.,"[""('class', 'dependency', 'method'): (keypair, can be accessed by calling, getprivate)"", ""('class', 'containment', 'class'): (keypair, has a, privatekey)"", ""('method', 'dependency', 'class'): (getprivate, is used to access, privatekey)""]"
You can create a Java KeyStore instance by calling its getInstance() method.,[]
This Keytool -delete command will remove the KeyStore entry with the alias testkey from the KeyStore stored in the file keystore.jks .,"[""('class', 'dependency', 'class'): (keytool, relies on, keystore)""]"
"You create a digital signature by calling the update() method one or more times, finishing with a call to sign().","[""('method', 'dependency', 'method'): (update, relies on to finish with, sign)"", ""('method', 'dependency', 'method'): (sign, relies on, update)""]"
"If you need to read and write the date and time to a database, use the java.sql.Date and java.sql.Timestamp classes.","[""('class', 'dependency', 'class'): (java.sql.date, used with, java.sql.timestamp)"", ""('class', 'similarity', 'class'): (java.sql.date, used for same purpose as, java.sql.timestamp)""]"
Here is an example of how to create a Duration object using the between() method:,"[""('method', 'creation', 'class'): (between, creates, duration)""]"
Here is an example that shows how to create a LocalDateTime object via the now() method:,"[""('class', 'dependency', 'method'): (localdatetime, relies on, now)""]"
The LocalTime class in the Java 8 date time API represents a specific time of day without any time zone information.,[]
The parameter passed to the of() method is the ID of the time zone to create a ZoneId for.,"[""('method', 'creation', 'class'): (of, creates, zoneid)"", ""('method', 'dependency', 'class'): (of, relies on, zoneid)""]"
"If you need to set a date on a java.sql.PreparedStatement or get a date from a java.sql.ResultSet, you will interact with java.sql.Date.","[""('class', 'dependency', 'class'): (java.sql.preparedstatement, interacts with, java.sql.resultset)"", ""('class', 'dependency', 'class'): (java.sql.preparedstatement, interacts with, java.sql.date)"", ""('class', 'dependency', 'class'): (java.sql.resultset, interacts with, java.sql.date)""]"
One difference in the java.sql.Timestamp from its superclass java.util.Date is its ability to hold the nanoseconds of a date too.,[]
You can get and set the nanoseconds using the getNanos() and setNanos().,"[""('method', 'dependency', 'method'): (getnanos, uses, setnanos)"", ""('method', 'dependency', 'method'): (setnanos, uses, getnanos)""]"
The Calendar class has a corresponding set() method so you can set these fields too.,"[""('class', 'dependency', 'method'): (calendar, has a corresponding, set)"", ""('class', 'implementation', 'method'): (calendar, has a corresponding set() method, set)""]"
"You can access the date and time contained in a java.util.Date instance using the getTime() method, like this:","[""('class', 'dependency', 'method'): (java.util.date, uses, gettime())"", ""('class', 'implementation', 'method'): (java.util.date, implements, gettime())""]"
You can compare java.util.Date instance because the class implements the java.lang.Comparable interface.,"[""('class', 'implementation', 'interface'): (java.util.date, implements, java.lang.comparable)""]"
The java.util.TimeZone class is used in conjunction with the java.util.Calendar class.,"[""('class', 'dependency', 'class'): (java.util.timezone, is used in conjunction with, java.util.calendar)""]"
As you can see the readNumberFromUrl() needs to declare throwing both the BadUrlException and the BadNumberException that are thrown from the readDataFromUrl() and converData() methods.,"[""('method', 'dependency', 'class'): (readnumberfromurl, needs to declare throwing, badurlexception)"", ""('method', 'dependency', 'class'): (readnumberfromurl, needs to declare throwing, badnumberexception)"", ""('method', 'dependency', 'method'): (readnumberfromurl, relies on, readdatafromurl)"", ""('method', 'dependency', 'method'): (readnumberfromurl, relies on, convertdata)"", ""('method', 'dependency', 'class'): (readdatafromurl, throws, badurlexception)"", ""('method', 'dependency', 'class'): (convertdata, throws, badnumberexception)"", ""('method', 'implementation', 'class'): (readnumberfromurl, declares throwing, badurlexception)"", ""('method', 'implementation', 'class'): (readnumberfromurl, declares throwing, badnumberexception)""]"
As you can see the readNumberFromUrl() method now only declares throwing ApplicationException.,"[""('method', 'dependency', 'class'): (readnumberfromurl, declares throwing, applicationexception)""]"
"In the example with FileNotFoundException, if you catch IOException which is the superclass of FileNotFoundException, you will also catch FileNotFoundException.","[""('class', 'dependency', 'class'): (ioexception, catches, filenotfoundexception)"", ""('class', 'containment', 'class'): (ioexception, is superclass of, filenotfoundexception)""]"
"If the input.close() call fails, and an IOException is thrown, then it is caught, wrapped and rethrown.","[""('class', 'dependency', 'class'): (input, relies on to throw, ioexception)"", ""('class', 'dependency', 'method'): (input, calls, close)"", ""('class', 'dependency', 'class'): (input, wraps and rethrows, ioexception)""]"
The Throwable class has a method named addSuppressed() which takes a Throwable object as parameter.,"[""('class', 'dependency', 'method'): (throwable, has, addsuppressed)"", ""('class', 'implementation', 'method'): (throwable, interacts with, addsuppressed)""]"
The applyPattern() method simply applies a new pattern to the DecimalFormat instance as if it were created with that pattern.,"[""('method', 'dependency', 'class'): (applypattern, applies to, decimalformat)"", ""('method', 'implementation', 'class'): (applypattern, is used with, decimalformat)""]"
The applyLocalizedPattern() does the same as applyPattern() except it interpretes the characters in the pattern according to the Locale the DecimalFormat was created with.,"[""('method', 'similarity', 'method'): (applylocalizedpattern, does the same as, applypattern)"", ""('method', 'dependency', 'class'): (applylocalizedpattern, interpretes according to the locale of, decimalformat)"", ""('method', 'dependency', 'class'): (applypattern, used with, decimalformat)""]"
"To sort a collection of strings according to the rules of a certain Locale, you use a java.text.Collator instance created for that specific Locale.",[]
The factory method Locale.forLanguageTag() can also be used to create a Locale instance.,"[""('method', 'creation', 'class'): (locale.forlanguagetag, is used to create, locale)""]"
Finally you can access the localized values in the ResourceBundle via its different getString() and getObject() etc.,"[""('class', 'containment', 'method'): (resourcebundle, access values via, getstring)"", ""('class', 'containment', 'method'): (resourcebundle, access values via, getobject)"", ""('class', 'implementation', 'method'): (resourcebundle, use, getstring)"", ""('method', 'dependency', 'class'): (getstring, relies on, resourcebundle)"", ""('method', 'dependency', 'class'): (getobject, relies on, resourcebundle)""]"
For this example to work you should put a standard Java property file named MyBundle.properties in a Java package named i18n.,[]
Once you have created a SimpleDateFormat instance you can format dates using its format() method.,"[""('class', 'dependency', 'method'): (simpledateformat, uses, format)"", ""('class', 'implementation', 'method'): (simpledateformat, implements, format)""]"
The Date instance passed to the format() method is a java.util.Date instance.,"[""('class', 'dependency', 'method'): (java.util.date, passed to, format)"", ""('method', 'dependency', 'class'): (format, is called with, java.util.date)""]"
"The Java SimpleDateFormat class is also capable of formatting a Date object into a StringBuffer, instead of returning an individual String with the date formatted.","[""('class', 'dependency', 'class'): (simpledateformat, is capable of formatting, date)"", ""('class', 'dependency', 'class'): (simpledateformat, is capable of formatting, stringbuffer)"", ""('class', 'conversion', 'class'): (simpledateformat, formats into, string)"", ""('class', 'conversion', 'class'): (date, is formatted into, string)"", ""('class', 'conversion', 'class'): (date, is formatted into, stringbuffer)"", ""('class', 'dependency', 'class'): (string, is result of formatting, date)""]"
You can parse a String into a java.util.Date instance using the parse() method of the SimpleDateFormat instance.,"[""('class', 'conversion', 'class'): (string, can be parsed into, java.util.date)"", ""('class', 'dependency', 'class'): (string, uses, simpledateformat)"", ""('class', 'dependency', 'class'): (java.util.date, uses, simpledateformat)"", ""('class', 'conversion', 'class'): (string, is converted to, java.util.date)"", ""('class', 'dependency', 'class'): (java.util.date, relies on, simpledateformat)"", ""('class', 'dependency', 'method'): (simpledateformat, uses, parse())""]"
You can set the time zone of a SimpleDateFormat using its setTimeZone() method.,"[""('class', 'dependency', 'method'): (simpledateformat, uses, settimezone)"", ""('class', 'implementation', 'method'): (simpledateformat, settimezone, settimezone)""]"
"In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not, but the BufferedInputStream supports them.","[""('method', 'dependency', 'method'): (marksupported, is used to determine support for, mark)"", ""('method', 'dependency', 'method'): (marksupported, is used to determine support for, reset)"", ""('method', 'implementation', 'class'): (marksupported, is supported by, bufferedinputstream)"", ""('method', 'implementation', 'class'): (marksupported, is supported by, inputstream)"", ""('method', 'dependency', 'method'): (mark, is used with, reset)"", ""('method', 'implementation', 'class'): (mark, is used by, bufferedinputstream)"", ""('method', 'implementation', 'class'): (mark, is used by, inputstream)"", ""('method', 'dependency', 'method'): (reset, is used with, mark)"", ""('method', 'implementation', 'class'): (reset, is used by, bufferedinputstream)"", ""('method', 'implementation', 'class'): (reset, is used by, inputstream)"", ""('class', 'containment', 'class'): (bufferedinputstream, is a type of, inputstream)""]"
"After that, the while loop exits, and the BufferedInputStream close() method is called.","[""('class', 'dependency', 'method'): (bufferedinputstream, is closed by, close)"", ""('class', 'dependency', 'method'): (bufferedinputstream, relies on, close)""]"
"The setSource() method actually returns a reference to the ReusableBufferedInputStream, so you can actually create a ReusableBufferedInputStream and set the source in a single instruction:","[""('method', 'dependency', 'class'): (setsource, returns a reference to, reusablebufferedinputstream)"", ""('method', 'implementation', 'class'): (setsource, interacts with, reusablebufferedinputstream)""]"
To write data to a Java BufferedOutputStream you can use its write() method.,"[""('class', 'dependency', 'method'): (bufferedoutputstream, uses, write)"", ""('class', 'implementation', 'method'): (bufferedoutputstream, writes data through, write)""]"
If you want to make sure that all written data is written to disk without having to close the BufferedOutputStream you can call its flush() method.,"[""('class', 'dependency', 'method'): (bufferedoutputstream, relies on for disk write, flush)"", ""('method', 'dependency', 'class'): (flush, enables disk write for, bufferedoutputstream)""]"
"Once the try block is exited, the close() method of the BufferedOutputStream is called automatically, because the BufferedOutputStream was declared inside the parentheses of the try block.",[]
"The Java BufferedReader class is a subclass of the Java Reader class, so you can use a BufferedReader anywhere a Reader is required.","[""('class', 'dependency', 'class'): (bufferedreader, can be used as, reader)"", ""('class', 'implementation', 'class'): (bufferedreader, is a subclass of, reader)""]"
"The Java BufferedReader class also has a read() method that takes a char array as parameter, as well as a start offset and length.","[""('class', 'dependency', 'method'): (bufferedreader, has a read method, read)"", ""('class', 'implementation', 'method'): (bufferedreader, uses, read)""]"
The Java BufferedReader has a special read method named readLine() which reads a full line of text from the BufferedReader's internal buffer.,"[""('class', 'dependency', 'method'): (bufferedreader, has a special read method named, readline)"", ""('class', 'implementation', 'method'): (bufferedreader, reads a full line of text from, readline)""]"
The Java BufferedWriter's flush() method flushes all data written to the BufferedWriter to the underlying data destination.,"[""('class', 'dependency', 'method'): (bufferedwriter, relies on, flush())"", ""('method', 'dependency', 'class'): (flush(), relies on, bufferedwriter)"", ""('class', 'implementation', 'method'): (bufferedwriter, uses, flush())"", ""('class', 'implementation', 'method'): (bufferedwriter, interacts through, flush())""]"
The mark() method of the ByteArrayInputStream class sets an internal mark at the current byte position - meaning right after the previous byte read.,"[""('class', 'dependency', 'method'): (bytearrayinputstream, has a method, mark)"", ""('method', 'implementation', 'class'): (mark, is part of, bytearrayinputstream)""]"
"Since the Java ByteArrayOutputStream class is a subclass of the Java OutputStream class, you write bytes to it using the same write methods that OutputStream has:","[""('class', 'dependency', 'class'): (bytearrayoutputstream, is a subclass of, outputstream)"", ""('class', 'dependency', 'method'): (bytearrayoutputstream, uses, write)"", ""('class', 'dependency', 'method'): (outputstream, has, write)""]"
"Once you have finished writing to the ByteArrayOutputStream you can obtain all the bytes written as a Java byte array, using the ByteArrayOutputStream toByteArray() method.",[]
You can read a Java float from the DataInputStream using its readFloat() method.,"[""('class', 'dependency', 'method'): (datainputstream, uses, readfloat)""]"
You can read a Java unsigned short (only positive values) from the DataInputStream using its readUnsignedShort() method.,"[""('class', 'dependency', 'method'): (datainputstream, uses, readunsignedshort)"", ""('class', 'implementation', 'method'): (datainputstream, implements, readunsignedshort)""]"
You can read a Java long from the DataInputStream using its readLong() method.,"[""('class', 'dependency', 'method'): (datainputstream, uses, readlong())"", ""('method', 'dependency', 'class'): (readlong(), depends on, datainputstream)""]"
"To rename (or move) a file, call the method renameTo() on the File class.","[""('class', 'dependency', 'method'): (file, relies on, renameto)"", ""('class', 'implementation', 'method'): (file, calls, renameto)""]"
You can obtain a list of all the files in a directory by calling either the Java File list() method or the listFiles() method.,"[""('class', 'dependency', 'method'): (file, obtained by, list)"", ""('class', 'dependency', 'method'): (file, obtained by, listfiles)"", ""('method', 'similarity', 'method'): (list, equivalent to, listfiles)""]"
Here is an example of listing all files in a directory via the Java File list() and listFiles() methods:,"[""('method', 'difference', 'method'): (list, differs from, listfiles)""]"
To write data to a Java FileOutputStream you can use its write() method.,"[""('class', 'dependency', 'method'): (fileoutputstream, uses, write)""]"
Here is an example of writing data to a Java FileOutputStream using its write() method:,"[""('class', 'dependency', 'method'): (fileoutputstream, uses, write)"", ""('class', 'implementation', 'method'): (fileoutputstream, implements, write)""]"
Here is an example of closing a Java FileOutputStream by calling its close() method:,"[""('class', 'implementation', 'method'): (fileoutputstream, closes using, close)""]"
You can convert a FileOutputStream to a character based Writer using the Java OutputStreamWriter class.,"[""('class', 'conversion', 'class'): (fileoutputstream, can be converted to, outputstreamwriter)"", ""('class', 'conversion', 'class'): (fileoutputstream, can be converted to, writer)"", ""('class', 'implementation', 'class'): (outputstreamwriter, is used to implement, writer)""]"
The Java FileWriter's flush() method flushes all data written to the FileWriter to the underlying file.,"[""('class', 'implementation', 'method'): (filewriter, uses, flush)""]"
Here is an example of flushing data written to a Java FileWriter by calling its flush() method:,[]
Notice how there is no longer any explicit close() method call to the FileWriter instance.,"[""('method', 'dependency', 'class'): (close, is_no_longer_explicitly_called_on, filewriter)""]"
The Java InputStream class contains a method called readAllBytes() (since Java 9).,"[""('class', 'containment', 'method'): (inputstream, contains, readallbytes)""]"
Here is an example of reading all bytes from a Java InputStream via readAllBytes():,"[""('class', 'dependency', 'method'): (inputstream, read via, readallbytes)"", ""('class', 'implementation', 'method'): (inputstream, readallbytes from, readallbytes)""]"
"If an InputStream subclass supports the mark() and reset() methods, then that subclass should override the markSupported() to return true.","[""('method', 'dependency', 'method'): (mark(), supports, reset())"", ""('method', 'dependency', 'method'): (mark(), should override, marksupported())"", ""('method', 'dependency', 'method'): (reset(), should override, marksupported())"", ""('method', 'implementation', 'class'): (mark(), override, inputstream)"", ""('method', 'implementation', 'class'): (reset(), override, inputstream)"", ""('method', 'implementation', 'class'): (marksupported(), return true, inputstream)""]"
The read() method of an InputStreamReader returns an int which contains the char value of the char read.,"[""('class', 'dependency', 'method'): (inputstreamreader, returns, read)"", ""('method', 'dependency', 'class'): (read, relies on, inputstreamreader)""]"
Notice how there is no longer any explicit close() method call to the CharArrayWriter instance.,[]
"Like with FilterInputStream, I see no sensible purpose for this class.",[]
They make it somewhat easier to understand what the classes are targeting.,[]
The read() method of a Java PipedReader returns an int which contains the char value of the character read.,"[""('class', 'dependency', 'method'): (pipedreader, returns, read)"", ""('method', 'dependency', 'class'): (read, is method of, pipedreader)""]"
"Third, the example calls the advanced printf() method of the PrintWriter which can insert formatted numbers into a text string.","[""('method', 'dependency', 'class'): (printf, is a method of, printwriter)""]"
Closing a Java StringReader can be done using the close() method like this:,"[""('class', 'dependency', 'method'): (stringreader, can be closed using, close)"", ""('class', 'implementation', 'method'): (stringreader, is closed by calling, close)""]"
The Java OutputStream's flush() method flushes all data written to the OutputStream to the underlying data destination.,"[""('class', 'dependency', 'method'): (outputstream, relies on for data destination, flush())"", ""('class', 'containment', 'method'): (outputstream, contains method, flush())"", ""('class', 'implementation', 'method'): (outputstream, implements method, flush())"", ""('class', 'containment', 'class'): (outputstream, has method, outputstream)""]"
The Java OutputStreamWriter's flush() method flushes all data written to the OutputStreamWriter to the underlying data destination.,"[""('class', 'dependency', 'method'): (outputstreamwriter, uses, flush)"", ""('method', 'dependency', 'class'): (flush, used by, outputstreamwriter)"", ""('class', 'containment', 'method'): (outputstreamwriter, has method, outputstreamwriter.flush)"", ""('class', 'dependency', 'method'): (outputstreamwriter, relies on, outputstreamwriter.flush)"", ""('method', 'dependency', 'class'): (outputstreamwriter.flush, is part of, outputstreamwriter)"", ""('class', 'implementation', 'method'): (outputstreamwriter, implements, outputstreamwriter.flush)"", ""('method', 'dependency', 'class'): (flush, interrupts, outputstreamwriter)""]"
"If you push back multiple bytes into the PushbackInputStream, the latest byte pushed back will be returned first from read(), just like on a stack.","[""('class', 'dependency', 'method'): (pushbackinputstream, relies on for read operation, read)"", ""('method', 'dependency', 'class'): (read, is relied on by, pushbackinputstream)""]"
"You read bytes from the Java PushbackInputStream via its read() method, just like you do from a regular InputStream .","[""('method', 'dependency', 'class'): (read, performed on, inputstream)""]"
"Remember, calling this write() method will advance the file position of the RandomAccessFile by 1.","[""('class', 'dependency', 'method'): (randomaccessfile, relies on, write)"", ""('method', 'dependency', 'class'): (write, advances, randomaccessfile)""]"
The Java Reader class has a method named skip() which can be used to skip over a number of characters in the input that you do not want to read.,[]
You do so by calling the nextToken() method of the StreamTokenizer inside a loop.,"[""('class', 'dependency', 'method'): (streamtokenizer, calls, nexttoken)"", ""('class', 'implementation', 'method'): (streamtokenizer, has method, nexttoken)""]"
"System.in, System.out and System.err are initialized by the Java runtime when a Java VM starts up, so you don't have to instantiate any streams yourself (although you can exchange them at runtime).","[""('class', 'dependency', 'class'): (system.in, initialized by, java vm)"", ""('class', 'dependency', 'class'): (system.out, initialized by, java vm)"", ""('class', 'dependency', 'class'): (system.err, initialized by, java vm)"", ""('class', 'containment', 'class'): (java vm, starts up with, system.in)"", ""('class', 'containment', 'class'): (java vm, starts up with, system.out)"", ""('class', 'containment', 'class'): (java vm, starts up with, system.err)"", ""('class', 'replacement', 'class'): (system.in, can be exchanged with, system.out)"", ""('class', 'replacement', 'class'): (system.out, can be exchanged with, system.err)"", ""('class', 'similarity', 'class'): (system.in, is similarly initialized as, system.out)"", ""('class', 'similarity', 'class'): (system.in, is similarly initialized as, system.err)"", ""('class', 'similarity', 'class'): (system.out, is similarly initialized as, system.err)""]"
You will normally use a Writer subclass rather than a Writer directly.,[]
The Java String parameter passed to the Class forName() method is the name of the JDBC driver class for the given JDBC driver.,"[""('class', 'dependency', 'method'): (class, relies on, forname)"", ""('class', 'implementation', 'method'): (class, interacts with, forname)""]"
"By the way, imagine that the used Person class looks like this:",[]
Here is an example of creating a JDBC DatabaseMetaData object via the JDBC Connection getMetaData() method:,"[""('class', 'creation', 'class'): (connection, creates, databasemetadata)"", ""('class', 'dependency', 'method'): (connection, uses, getmetadata)"", ""('class', 'containment', 'class'): (connection, contains, databasemetadata)""]"
The ResultSet returned by the getColumns() method contains a list of columns for the given table.,"[""('method', 'creation', 'class'): (getcolumns, returned, resultset)""]"
Before the first next() call the ResultSet is positioned before the first row.,"[""('method', 'dependency', 'class'): (next, is called after the position of, resultset)""]"
"Once the row is ready to be inserted into the ResultSet, call the insertRow() method.",[]
"If you need to insert another row, explicitly call moveToInsertRow() to signal this to the ResultSet.",[]
The purpose of an abstract class is to function as a base for subclasses.,[]
"If a class has an abstract method, the whole class must be declared abstract.","[""('class', 'dependency', 'method'): (class, has, method)"", ""('class', 'containment', 'method'): (class, contains, method)""]"
The example I showed you above with the URLProcessorBase class is actually an example of the Template Method design pattern.,[]
In the above example the subclass SmartClock has a method called getTimeInSeconds() which accesses the time variable of the superclass Clock.,"[""('class', 'dependency', 'class'): (smartclock, has a method called gettimeinseconds() which accesses the time variable of the, clock)"", ""('method', 'dependency', 'class'): (gettimeinseconds, accesses the time variable of the, clock)"", ""('method', 'implementation', 'class'): (gettimeinseconds, is a method of, smartclock)"", ""('class', 'containment', 'class'): (smartclock, is a subclass of, clock)""]"
The utility class is called Arrays and is located in the standard Java package java.util.,[]
The purpose of a constructor is to initialize the fields in the class.,"[""('method', 'dependency', 'class'): (constructor, initialize the fields in, class)"", ""('class', 'containment', 'method'): (class, has a, constructor)""]"
Now the isValid() method returns the value returned by the value.equals() method call.,"[""('method', 'dependency', 'method'): (isvalid, returns the value of, value.equals)"", ""('method', 'dependency', 'method'): (value.equals, is returned by, isvalid)""]"
In many cases it would have made sense to place the getLicensePlate() method in the Vehicle class where the licensePlate field is located.,"[""('method', 'dependency', 'class'): (getlicenseplate, relies on, vehicle)"", ""('method', 'implementation', 'class'): (getlicenseplate, is implemented in, vehicle)""]"
"Here is the same instanceof example, but using a Truck object instead of a Car object: Truck truck = new Truck(); Vehicle vehicle = truck; boolean isCar = vehicle instanceof Car; After executing this code the isCar will contain the value false.","[""('class', 'conversion', 'class'): (truck, is converted to, vehicle)"", ""('class', 'containment', 'class'): (vehicle, is a superclass of, truck)"", ""('class', 'containment', 'class'): (truck, is a subclass of, vehicle)""]"
The updateLicensePlate() method sets the license plate value on the licensePlate field in the Car class.,"[""('method', 'dependency', 'class'): (updatelicenseplate, sets the license plate value on the, car)"", ""('method', 'implementation', 'class'): (updatelicenseplate, updates, car)""]"
"The getLicensePlate() method, however, returns the value of the licensePlate field in the Vehicle class.","[""('method', 'dependency', 'class'): (getlicenseplate, returns the value of the licenseplate field in, vehicle)"", ""('method', 'implementation', 'class'): (getlicenseplate, returns the value of, vehicle)""]"
"If you override a method in a subclass, and the method is all of a sudden removed or renamed or have its signature changed in the superclass, the method in the subclass no longer overrides the method in the superclass.","[""('method', 'dependency', 'class'): (method, relies on, superclass)"", ""('class', 'dependency', 'class'): (subclass, relies on, superclass)"", ""('method', 'dependency', 'class'): (method, is overridden by, subclass)"", ""('class', 'implementation', 'method'): (subclass, overrides, method)"", ""('method', 'implementation', 'class'): (method, is implemented by, subclass)"", ""('method', 'difference', 'method'): (method, is removed or renamed or has its signature changed from, method)"", ""('class', 'dependency', 'method'): (subclass, has, method)""]"
Here is a Java instanceof example illustrating the comparison of null against a class:,[]
"That is because it is not the reference type that is compared against the target class or interface, but the actual type of the referenced object.","[""('class', 'implementation', 'interface'): (class, is interacted with through, interface)""]"
"A Java interface is a bit like a Java class, except a Java interface can only contain method signatures and fields.",[]
The class does not need to implement (declare) the variables of an interface.,"[""('class', 'dependency', 'interface'): (class, does not need to implement, interface)"", ""('class', 'implementation', 'interface'): (class, does not need to implement, interface)""]"
"You must always create an instance of some class that implements the interface, and reference that instance as an instance of the interface.","[""('class', 'implementation', 'interface'): (instance, implements, interface)"", ""('class', 'dependency', 'class'): (instance, relies on, class)"", ""('class', 'implementation', 'interface'): (class, implements, interface)""]"
"While it is normally possible for a class to implement multiple interfaces even if the interfaces contain methods with the same signature, this is not possible if one or more of these methods are default methods.","[""('class', 'dependency', 'interface'): (class, relies on, interface)"", ""('class', 'dependency', 'method'): (class, relies on, method)"", ""('interface', 'containment', 'method'): (interface, contains, method)"", ""('class', 'implementation', 'interface'): (class, implements, interface)"", ""('interface', 'dependency', 'method'): (interface, contains, method)""]"
In both of the above situations the Java compiler requires that the class implementing the interface(s) explicitly implements the method which causes the problem.,"[""('class', 'implementation', 'interface'): (class, implements, interface)"", ""('class', 'dependency', 'method'): (class, requires, method)"", ""('interface', 'dependency', 'method'): (interface, defines, method)""]"
The implementation in the class takes precedence over any default implementations.,[]
"Since the return value of produce() is Object, it can return any Java object.",[]
"Notice how the object returned from the carProducer.produce() method call has to be cast to a Car instance, because the produce() method return type is Object.","[""('method', 'creation', 'class'): (carproducer.produce, returns, object)""]"
"As you can see, since the generic type for the CarProducer instance is set to Car, it is no longer necessary to cast the object returned from the produce() method, since the original method declaration in the MyProducer interface states, that this method returns the same type as is specified in the generic type when used.","[""('class', 'implementation', 'interface'): (carproducer, implements, myproducer)"", ""('class', 'dependency', 'interface'): (carproducer, relies on, myproducer)"", ""('class', 'dependency', 'method'): (carproducer, relies on, produce)""]"
Now the result variable would end up with the value 12.5.,[]
The example above defines a method called writeText inside a class named MyClass.,"[""('class', 'implementation', 'method'): (myclass, contains, writetext)""]"
This would happen sometime at runtime - depending on when the application tried to use the missing class.,[]
This example module descriptor declares that it requires the standard Java module named javafx.graphics.,[]
Here is how you run the main class from a Java module JAR file:,[]
In Java nested classes are classes that are defined inside another class.,[]
Notice how you put new after the reference to the outer class in order to create an instance of the inner class.,[]
"As you can see, an anonymous class implementing an interface is pretty similar to an anonymous class extending another class.","[""('class', 'implementation', 'interface'): (class, implementing, interface)""]"
"Users of the Cache class may never see the CacheEntry class, if they have no need to obtain information about the CacheEntry itself, but only the cached value.","[""('class', 'containment', 'class'): (cache, contains, cacheentry)""]"
"If the classes A and B are located in the same Java package, there is no problem with the code above.",[]
"Instead of having a fixed number of layer packages which keep growing in number of classes, you get a growing number of application functionality packages with a smaller number of classes inside.",[]
A Java Record is a special kind of Java class which has a concise syntax for defining immutable data-only classes.,"[""('class', 'dependency', 'class'): (java record, is a special kind of, java class)"", ""('class', 'similarity', 'class'): (java record, is a kind of, java class)"", ""('class', 'containment', 'class'): (java class, has, java record)""]"
You can add instance methods to a Java Record definition - just like you can with a regular Java class.,"[""('class', 'similarity', 'class'): (java record, can add instance methods like, java class)""]"
Notice how the brandAsLowerCase() method calls the auto-generated brand() method internally.,"[""('method', 'dependency', 'method'): (brand, is called by, brandaslowercase)""]"
"As you can see, a new StringBuilder is created, passing along the first String to its constructor, and the second String to its append() method, before finally calling the toString() method.","[""('class', 'dependency', 'method'): (stringbuilder, relies on, append)"", ""('class', 'dependency', 'method'): (stringbuilder, relies on, tostring)""]"
You can search for substrings in Strings using the indexOf() method.,"[""('method', 'dependency', 'class'): (indexof, used in, string)"", ""('class', 'dependency', 'method'): (string, uses, indexof)""]"
The Java String class also has a lastIndexOf() method which finds the last occurrence of a substring.,[]
The Java String class contains a method called trim() which can trim a string object.,"[""('method', 'implementation', 'class'): (trim, is implemented on, string)""]"
"If not, the default toString() method (inherited from the Object class) will get called.","[""('method', 'dependency', 'class'): (tostring, inherited from, object)""]"
From Java 13 the Java String class got a new method called translateEscapes() which can translate escape codes that exist inside a String in the same way the Java compiler translates them.,"[""('method', 'dependency', 'class'): (translateescapes, is part of, java)"", ""('class', 'dependency', 'class'): (string, is part of, java)""]"
When you create an instance of a class (an object) the object can have methods you can execute.,"[""('class', 'creation', 'class'): (class, can create an instance of, object)"", ""('class', 'containment', 'method'): (object, can have, method)"", ""('class', 'creation', 'class'): (class, can be used to create, object)""]"
The second line assigns the floating point value 199.99 to the floating point variable named myFloat.,[]
"When you click the ""Run..."" option, IntelliJ IDEA will first compile your Java class, and then run it.",[]
"The logrb() methods work like the log() methods too, except they can obtain the log messages from a resource bundle.","[""('method', 'similarity', 'method'): (logrb, work like, log)"", ""('method', 'dependency', 'method'): (logrb, can be compared to, log)""]"
You can obtain the parent Logger of a given Logger using the getParent() method.,"[""('class', 'dependency', 'method'): (logger, uses, getparent)"", ""('class', 'dependency', 'class'): (logger, relies on, logger)"", ""('method', 'dependency', 'class'): (getparent, used by, logger)""]"
The getParameters() method returns the parameters to be inserted into the message of this LogRecord.,"[""('method', 'dependency', 'class'): (getparameters, returns parameters to be inserted into the message of, logrecord)"", ""('method', 'implementation', 'class'): (getparameters, returns parameters to be inserted into the message of, logrecord)""]"
The getResourceBundle() method returns the ResourceBundle (if any) used to localize the message of this LogRecord.,"[""('method', 'dependency', 'class'): (getresourcebundle, returns, resourcebundle)"", ""('method', 'dependency', 'class'): (getresourcebundle, used by, logrecord)"", ""('class', 'containment', 'class'): (logrecord, uses, resourcebundle)""]"
"Note: This tutorial does not cover the other popular Java logging API's (Log4J, SLF4J, Apache Commons Logging, LogBack etc.).",[]
Receiving data via a DatagramSocket is done by first creating a DatagramPacket and then receiving data into it via the DatagramSocket's receive() method.,"[""('class', 'dependency', 'class'): (datagramsocket, relies on, datagrampacket)"", ""('class', 'implementation', 'class'): (datagramsocket, receives data into, datagrampacket)"", ""('class', 'dependency', 'method'): (datagramsocket, uses, receive)"", ""('class', 'implementation', 'method'): (datagrampacket, is used with, receive)""]"
The java.net package contains two interesting classes: The URL class and the URLConnection class.,"[""('class', 'containment', 'class'): (java.net, contains, url)"", ""('class', 'containment', 'class'): (java.net, contains, urlconnection)"", ""('class', 'similarity', 'class'): (url, is similar to, urlconnection)""]"
You can check the when the read operation is finished by calling the isDone() method of the Future instance returned by the read() method.,"[""('method', 'dependency', 'class'): (read, returned by, future)"", ""('class', 'dependency', 'method'): (future, has method, isdone)"", ""('method', 'dependency', 'method'): (read, calls, isdone)""]"
Each way to write data call one of the write() methods of the AsynchronousFileChannel.,"[""('class', 'implementation', 'method'): (asynchronousfilechannel, implements, write)""]"
The int returned by the read() method tells how many bytes were written into the Buffer.,"[""('method', 'dependency', 'class'): (read, tells how many bytes were written into, buffer)"", ""('class', 'dependency', 'method'): (buffer, has bytes written into by, read)""]"
There is no guarantee of how many bytes the write() method writes to the FileChannel.,"[""('method', 'dependency', 'class'): (write, writes to, filechannel)""]"
You can obtain the current position of the FileChannel object by calling the position() method.,"[""('class', 'dependency', 'method'): (filechannel, relies on, position)"", ""('method', 'dependency', 'class'): (position, is obtained by, filechannel)""]"
The Files.createDirectory() method creates a new directory from a Path instance.,"[""('method', 'creation', 'class'): (files.createdirectory, creates, path)"", ""('method', 'dependency', 'class'): (files.createdirectory, relies on, path)""]"
The Java NIO Files class also contains a function for moving files from one path to another.,[]
Here is a walkFileTree() that extends SimpleFileVisitor to look for a file named README.txt :,"[""('method', 'implementation', 'class'): (walkfiletree, extends, simplefilevisitor)"", ""('method', 'dependency', 'class'): (walkfiletree, relies on, simplefilevisitor)""]"
"By walking through all directories and deleting all files (inside visitFile()) in each directory, and afterwards delete the directory itself (inside postVisitDirectory()) you can delete a directory with all subdirectories and files.","[""('method', 'dependency', 'method'): (visitfile, relies on for file deletion, postvisitdirectory)"", ""('method', 'dependency', 'method'): (postvisitdirectory, relies on for directory deletion, visitfile)""]"
"In many cases though, you can replace the use of the File class with use of the Path interface.",[]
The normalize() method of the Path interface can normalize a path.,"[""('method', 'dependency', 'class'): (normalize(), can normalize a, path)"", ""('class', 'dependency', 'method'): (path, has a method of, normalize())""]"
"As you saw in the previous section, when you register a Channel with a Selector the register() method returns a SelectionKey objects.","[""('class', 'dependency', 'class'): (selector, registers, channel)"", ""('class', 'dependency', 'class'): (selector, returns, selectionkey)"", ""('method', 'creation', 'class'): (register, creates, selectionkey)"", ""('class', 'dependency', 'class'): (channel, is registered with, selector)"", ""('class', 'dependency', 'class'): (channel, returns, selectionkey)"", ""('method', 'dependency', 'class'): (register, is used by, channel)"", ""('class', 'dependency', 'method'): (selectionkey, is returned by, register)""]"
"You can also attach an object already while registering the Channel with the Selector, in the register() method.","[""('class', 'dependency', 'class'): (selector, relies on, channel)"", ""('class', 'dependency', 'method'): (selector, relies on, register)"", ""('class', 'dependency', 'class'): (selector, relies on, object)"", ""('class', 'dependency', 'method'): (channel, relies on, register)"", ""('class', 'containment', 'class'): (selector, contains, object)"", ""('method', 'dependency', 'class'): (register, relies on, channel)"", ""('method', 'dependency', 'class'): (register, relies on, object)""]"
NOTE: Only the interfaces specifically declared implemented by a given class is returned.,"[""('class', 'implementation', 'interface'): (class, implements, interface)""]"
All you need to do is to obtain a ClassLoader and call its loadClass() method.,"[""('class', 'dependency', 'method'): (classloader, calls, loadclass)"", ""('class', 'implementation', 'method'): (classloader, uses, loadclass)""]"
"When the MyAction class calls methods on the IMyFactory instance injected into its constructor by the container, the method calls are translated into calls to the IContainer.instance() method, which is the method you use to obtain instances from the container.","[""('class', 'dependency', 'interface'): (myaction, calls methods on, imyfactory)"", ""('class', 'dependency', 'method'): (myaction, relies on, icontainer.instance)"", ""('class', 'implementation', 'method'): (myaction, sends method calls to, icontainer.instance)""]"
"You cannot ask for getters and setters explicitly, so you will have to scan through all the methods of a class and check if each method is a getter or setter.","[""('class', 'dependency', 'method'): (class, relies on, method)"", ""('class', 'containment', 'method'): (class, contains, getters)"", ""('class', 'containment', 'method'): (class, contains, setters)"", ""('method', 'dependency', 'class'): (method, is part of, class)"", ""('method', 'similarity', 'method'): (getters, are similar to, setters)"", ""('method', 'dependency', 'method'): (getters, rely on, method)"", ""('method', 'dependency', 'method'): (setters, rely on, method)""]"
To access a private field you will need to call the Class.getDeclaredField(String name) or Class.getDeclaredFields() method.,"[""('method', 'dependency', 'method'): (class.getdeclaredfield, needs to be called together with, class.getdeclaredfields)"", ""('method', 'dependency', 'method'): (class.getdeclaredfields, is an alternative to, class.getdeclaredfield)""]"
"By calling Field.setAcessible(true) you turn off the access checks for this particular Field instance, for reflection only.",[]
"The methods Class.getMethod(String name, Class[] parameterTypes) and Class.getMethods() methods only return public methods, so they won't work.","[""('method', 'dependency', 'method'): (class.getmethod, won't work because only returns public methods and is limited by this, class.getmethods)"", ""('method', 'difference', 'method'): (class.getmethod, differs from because only returns public methods and is more limited than, class.getmethods)""]"
"It will explain the basics of Java Reflection including how to work with arrays, annotations, generics and dynamic proxies, and do dynamic class loading and reloading.",[]
"For instance, if you are introspecting a String array, you can detect that the element type is String by inspecting the array class.","[""('class', 'containment', 'class'): (array, contains, string)"", ""('class', 'dependency', 'class'): (string, relies on, array)""]"
"For instance, the character class [a-zA-Z] will match all letters between a and z or between A and Z .",[]
"For that, you need to use the find(), start() and end() methods.","[""('method', 'dependency', 'method'): (start, used with, end)""]"
"In other words, if the regular expression matches the beginning of a text but not the whole text, lookingAt() will return true, whereas matches() will return false.","[""('method', 'difference', 'method'): (lookingat, will return true whereas the other will return false, matches)"", ""('method', 'preference', 'method'): (lookingat, is preferred in certain situations over, matches)""]"
"In case you have started matching occurrences in a string via the find() method, the Matcher will internally keep a state about how far it has searched through the input text.","[""('class', 'dependency', 'method'): (matcher, internally keeps a state about how far it has searched through the input text via, find)"", ""('method', 'dependency', 'class'): (find, is used by, matcher)""]"
The Matcher replaceAll() and replaceFirst() methods can be used to replace parts of the string the Matcher is searching through.,"[""('class', 'dependency', 'method'): (matcher, is used with, replaceall)"", ""('class', 'dependency', 'method'): (matcher, is used with, replacefirst)"", ""('method', 'dependency', 'class'): (replacefirst, is a method of, matcher)"", ""('method', 'dependency', 'class'): (replaceall, is a method of, matcher)""]"
A regular expression is also sometimes referred to as a pattern (hence the name of the Java Pattern class).,[]
"Too keep this text short, the Matcher covered in more detail in the text about the Java Matcher class.",[]
When you are finished reading data from the GZIPInputStream you should close it using its close() method.,"[""('class', 'dependency', 'method'): (gzipinputstream, should be closed by, close)"", ""('method', 'dependency', 'class'): (close, is used to close, gzipinputstream)""]"
"But, notice how no DI is used inside the BO.checkPersonIsValid() or the DAO.readPerson() methods.","[""('method', 'dependency', 'method'): (bo.checkpersonisvalid, is used without, dao.readperson)"", ""('method', 'dependency', 'method'): (dao.readperson, is not used inside, bo.checkpersonisvalid)""]"
"This little script defines the ""max"" factory as a call to the static max() method with input parameter 0 and 1 passed to the max() method.",[]
"In other words, as a call to the get() method on the HttpRequestCache singleton.","[""('method', 'dependency', 'class'): (get, is called on, httprequestcache)""]"
The ScriptFactoryBuilder has a addFactories() method that takes an InputStream as parameter instead of a String.,"[""('class', 'dependency', 'method'): (scriptfactorybuilder, has a method, addfactories)"", ""('class', 'dependency', 'class'): (scriptfactorybuilder, takes as parameter, inputstream)""]"
"Notice how the HttpServletRequest and HttpServletResponse are not obtained by the ThreadLocal.get() method, but via the static methods getRequest() and getResponse().","[""('class', 'dependency', 'class'): (httpservletrequest, obtained via static methods, httpservletresponse)"", ""('class', 'dependency', 'class'): (httpservletrequest, not obtained by, threadlocal)"", ""('class', 'dependency', 'class'): (httpservletresponse, not obtained by, threadlocal)"", ""('class', 'dependency', 'method'): (httpservletrequest, obtained by, getrequest)"", ""('class', 'dependency', 'method'): (httpservletresponse, obtained by, getresponse)"", ""('method', 'dependency', 'class'): (getrequest, used to obtain, httpservletrequest)"", ""('method', 'dependency', 'class'): (getresponse, used to obtain, httpservletresponse)"", ""('class', 'implementation', 'class'): (httpservletrequest, interacts with, httpservletresponse)"", ""('class', 'implementation', 'method'): (httpservletrequest, interacts with, getrequest)"", ""('class', 'implementation', 'method'): (httpservletresponse, interacts with, getresponse)"", ""('method', 'implementation', 'method'): (getrequest, interacts with, getresponse)""]"
"The IObjectMappingKey instance can contain more information about the class to be mapped, than a Class object can.",[]
This is the object is obtained from the getResult() method of the IResultSetProcessor.,"[""('interface', 'dependency', 'method'): (iresultsetprocessor, is obtained from, getresult)"", ""('method', 'creation', 'interface'): (getresult, is used to obtain, iresultsetprocessor)""]"
"This speeds up object mapping cache lookups because the hashCode() method returns this int id, and because equals() also only compares int id's, instead of Class objects, table names etc.","[""('method', 'dependency', 'method'): (hashcode, returns to speed up, equals)"", ""('method', 'implementation', 'method'): (equals, uses to implement, hashcode)""]"
The extended class CustomObjectMapperBase is an empty implementation of the ICustomObjectMapper interface.,"[""('class', 'implementation', 'interface'): (customobjectmapperbase, implements, icustomobjectmapper)""]"
Just call the IObjectMapping.removeGetterMapping(String name) or IObjectMapping.removeSetterMapping(String name) method to do so.,"[""('class', 'containment', 'method'): (iobjectmapping, has method, iobjectmapping.removegettermapping)"", ""('class', 'containment', 'method'): (iobjectmapping, has method, iobjectmapping.removesettermapping)"", ""('method', 'dependency', 'method'): (iobjectmapping.removegettermapping, used in conjunction with, iobjectmapping.removesettermapping)""]"
"Second, you do not need the parentheses around the closure when calling doFirst() or doLast().","[""('method', 'similarity', 'method'): (dofirst, can be called without parentheses like, dolast)"", ""('method', 'similarity', 'method'): (dolast, can be called without parentheses like, dofirst)""]"
The and() method is used to combine two other Predicate functions in the same way I showed in the beginning of this Java functional composition tutorial.,"[""('method', 'dependency', 'class'): (and, is used to combine, predicate)"", ""('method', 'implementation', 'class'): (and, is used to combine, predicate)""]"
"The Java Function compose() method composes a new Function instance from the Function instance it is called on, and the Function instance passed as parameter to the compose() method.","[""('class', 'creation', 'class'): (function, composes a new instance from, function)"", ""('method', 'dependency', 'class'): (compose, is called on, function)"", ""('class', 'implementation', 'class'): (function, is composed with, function)"", ""('method', 'creation', 'class'): (compose, creates a new function instance from, function)""]"
The first example of a higher order function is the Collections.sort() method which takes a Comparator as parameter.,"[""('method', 'dependency', 'class'): (collections.sort, takes as parameter, comparator)"", ""('method', 'implementation', 'class'): (collections.sort, interacts with, comparator)""]"
The call to the map() method of the Stream interface is a non-terminal operation.,"[""('interface', 'dependency', 'method'): (stream, call to the map() method of, map)"", ""('method', 'dependency', 'interface'): (map, is called on, stream)""]"
Only the first occurrence of this element will be included in the Stream returned by distinct().,"[""('method', 'dependency', 'class'): (distinct, returns, stream)"", ""('class', 'containment', 'method'): (stream, includes, distinct)""]"
"The findFirst() method returns an Optional from which you can obtain the element, if present.","[""('method', 'dependency', 'class'): (findfirst, returns, optional)""]"
"The Java Stream forEach() method is a terminal operation which starts the internal iteration of the elements in the Stream, and applies a Consumer (java.util.function.Consumer) to each element in the Stream.","[""('class', 'dependency', 'class'): (stream, applies, java.util.function.consumer)"", ""('method', 'dependency', 'class'): (foreach, applies, java.util.function.consumer)"", ""('class', 'containment', 'class'): (stream, contains, java.util.function.consumer)"", ""('class', 'dependency', 'class'): (java.util.function.consumer, is_applied_by, stream)"", ""('method', 'implementation', 'class'): (foreach, interacts_through, java.util.function.consumer)""]"
Which element is the largest is determined by the Comparator implementation you pass to the max() method.,"[""('method', 'dependency', 'class'): (max, relies on, comparator)"", ""('method', 'implementation', 'class'): (max, is determined by, comparator)""]"
This Optional contains the value (if any) returned by the lambda expression passed to the reduce() method.,"[""('class', 'dependency', 'method'): (optional, contains, reduce)""]"
"Note: Even if the class is called RollingBufferInputStream, it is not an InputStream subclass.",[]
"You can specify fonts for most text objects (Chunk, Phrase, Paragraph etc.)",[]
"If you already have a finished PDF, and just want to add a header, footer or watermark to it, IText provides the com.itextpdf.pdf.PdfStamper class.",[]
"You can write text as superscript or subscript using the Chunk class, and it's setTextRise() method.","[""('class', 'dependency', 'method'): (chunk, uses, settextrise)""]"
"You can add underline and strikethrough text using the Chunk class, and its setUnderline() method.","[""('class', 'dependency', 'method'): (chunk, uses, setunderline)"", ""('class', 'implementation', 'method'): (chunk, has method, setunderline)""]"
"It is now up to the caller of the readMyData() method to decide if an existing MyData instance should be reused, or if a new instance should be created.",[]
The value returned by write() is the number of bytes copied from the ByteBuffer.,"[""('method', 'dependency', 'class'): (write, returns value from, bytebuffer)"", ""('class', 'dependency', 'method'): (bytebuffer, is source for, write)""]"
Here is an implementation of the ring buffer that uses a fill count including the batch put() and take() operations.,"[""('method', 'implementation', 'method'): (put, included in batch operations with, take)"", ""('method', 'implementation', 'method'): (take, included in batch operations with, put)""]"
"Here is an implementation of the ring buffer that uses a read position and flip marker, including the batch put() and take() operations.","[""('method', 'implementation', 'method'): (put, is implemented with, take)"", ""('method', 'implementation', 'method'): (take, is implemented with, put)""]"
"If your benchmark method produces multiple results you can pass each of these results to a black hole, meaning calling consume() on the Blackhole instance for each value.","[""('class', 'implementation', 'method'): (blackhole, calling consume() on, consume)""]"
The javax.servlet.http.HttpServlet class is a slightly more advanced base class than the GenericServlet shown in the Simple Servlet example.,"[""('class', 'similarity', 'class'): (javax.servlet.http.httpservlet, is a base class similar to, genericservlet)""]"
The easiest way to implement this interface is to extend either the class GenericServlet or HttpServlet.,"[""('class', 'dependency', 'class'): (genericservlet, extends or is extended by, httpservlet)"", ""('class', 'implementation', 'class'): (genericservlet, implements or is implemented by, httpservlet)""]"
Each test method usually tests a single method of the target class.,"[""('method', 'dependency', 'class'): (test method, tests, target class)"", ""('method', 'implementation', 'class'): (test method, tests, target class)""]"
"A protected method or field, on the other hand, is also accessible to other classes in the same package, and for subclasses of the unit too.","[""('method', 'dependency', 'class'): (method, is accessible to, class)""]"
"When your business logic class is separated from the boundary class, you can test the business logic class separately.","[""('class', 'dependency', 'class'): (business logic class, is separated from, boundary class)""]"
Here is the unit test which uses a ByteArrayOutputStream to collect the data written to the OutputStream passed to the MyIOUnit.write() method:,"[""('class', 'dependency', 'class'): (myiounit, uses, outputstream)"", ""('method', 'dependency', 'class'): (myiounit.write, uses, outputstream)"", ""('class', 'implementation', 'class'): (myiounit, writes to, bytearrayoutputstream)"", ""('class', 'dependency', 'class'): (outputstream, is collected by, bytearrayoutputstream)"", ""('class', 'containment', 'class'): (bytearrayoutputstream, collects, outputstream)"", ""('method', 'implementation', 'class'): (myiounit.write, writes to, bytearrayoutputstream)"", ""('class', 'dependency', 'class'): (bytearrayoutputstream, is used by, myiounit)"", ""('class', 'dependency', 'class'): (myiounit, uses, bytearrayoutputstream)"", ""('method', 'dependency', 'class'): (myiounit.write, is part of, myiounit)""]"
You may also be able to use the StringReader and StringWriter classes in your unit tests.,"[""('class', 'dependency', 'class'): (stringreader, may also be able to use, stringwriter)"", ""('class', 'dependency', 'class'): (stringwriter, may also be able to use, stringreader)""]"
"To avoid fragmenting the Java heap with Bytes instances, the Bytes class is designed to be obtained from an ObjectPool .","[""('class', 'dependency', 'class'): (bytes, is designed to be obtained from, objectpool)""]"
To defragment the free blocks you call the defragment() method of the BytesAllocatorManualDefrag .,"[""('class', 'dependency', 'method'): (bytesallocatormanualdefrag, call defragment() method on, defragment)"", ""('method', 'implementation', 'method'): (defragment, is implemented by, defragment())"", ""('class', 'dependency', 'method'): (bytesallocatormanualdefrag, has method, defragment())""]"
The Bytes class represents a byte sequence allocated from a shared byte array.,[]
"As you can see, the ChannelInitializer is added to the ServerBootstrap using the childHandler() method.","[""('class', 'containment', 'class'): (serverbootstrap, added to, channelinitializer)"", ""('class', 'implementation', 'method'): (serverbootstrap, using, childhandler)"", ""('class', 'dependency', 'method'): (channelinitializer, added by, childhandler)""]"
"By calling sync() on the ChannelFuture the main thread that creates the server waits until the server has started, before continuing.","[""('class', 'dependency', 'method'): (channelfuture, waits until the server has started by calling, sync)""]"
The easiest way to create an instance of the RionObjectReader is via the RionObjectReaderBuilder class.,"[""('class', 'dependency', 'class'): (rionobjectreader, relies on, rionobjectreaderbuilder)""]"
The RionObjectReader readCyclic() method reads a cyclic object graph stored as RION in a byte array.,"[""('class', 'dependency', 'method'): (rionobjectreader, reads, readcyclic)"", ""('class', 'implementation', 'method'): (rionobjectreader, reads, readcyclic)""]"
The RionObjectWriter writeAcyclic() can write an acyclic object graph as RION into a byte array.,[]
When reading a composite RION field you need to use the RionReader moveInto() and moveOutOf() methods.,"[""('class', 'dependency', 'method'): (rionreader, uses, moveinto)"", ""('class', 'dependency', 'method'): (rionreader, uses, moveoutof)"", ""('class', 'implementation', 'method'): (rionreader, implements, moveinto)"", ""('class', 'implementation', 'method'): (rionreader, implements, moveoutof)"", ""('method', 'dependency', 'method'): (moveinto, is used by, moveoutof)""]"
"Here are two examples of writing a 32 bit and 64 bit floating point number as RION Float fields to the destination byte array, using the RionWriter writeFloat32() and writeFloat64() methods:","[""('class', 'implementation', 'method'): (rionwriter, uses, writefloat32)"", ""('class', 'implementation', 'method'): (rionwriter, uses, writefloat64)"", ""('method', 'difference', 'method'): (writefloat32, is different from, writefloat64)""]"
The StreamStorageFS class contains a method to read bytes from a stream block file.,"[""('method', 'dependency', 'class'): (read, relies on, streamstoragefs)""]"
"The readBytes() method reads bytes from the file represented by the given StreamStorageBlockFS instance, into the byte[] array passed as parameter.","[""('class', 'dependency', 'method'): (streamstorageblockfs, relies on for reading bytes, readbytes)"", ""('method', 'dependency', 'class'): (readbytes, reads bytes from, streamstorageblockfs)""]"
You can always obtain the root directory path a StreamStorageRootFS was created with via its getRootDirPath() method.,"[""('class', 'dependency', 'method'): (streamstoragerootfs, uses, getrootdirpath)"", ""('class', 'containment', 'method'): (streamstoragerootfs, has, getrootdirpath)""]"
"When you write records to a stream via the StreamStorageFS instance, the StreamStorageFS class will divide the records into multiple files.","[""('class', 'implementation', 'class'): (streamstoragefs, divides records into multiple files via, streamstoragefs)"", ""('class', 'containment', 'class'): (streamstoragefs, contains records in multiple files, streamstoragefs)""]"
You can read the data stored in a Buffer using the many get...() methods.,"[""('class', 'dependency', 'method'): (buffer, relies on, get...())"", ""('method', 'dependency', 'class'): (get...(), relies on, buffer)"", ""('class', 'implementation', 'method'): (buffer, uses, get...())""]"
Notice the use of / as directory separator and the use of : as classpath entry separator.,[]
"However, if you do need to access the body of the HTTP response, you need to register another handler on the HttpClientResponse that is passed as parameter to the first Handler's handle() method.","[""('class', 'dependency', 'class'): (httpclientresponse, needs to register, handler)"", ""('class', 'dependency', 'class'): (handler, is registered on, httpclientresponse)"", ""('class', 'implementation', 'method'): (handler, is passed to, handle)"", ""('class', 'dependency', 'class'): (handler, is used to access, httpclientresponse)""]"
"Again, the NetClient's close() method is asynchronous, so the underlying TCP connection may not yet be closed by the time the close() method returns.","[""('class', 'dependency', 'method'): (netclient, has, close)"", ""('method', 'dependency', 'class'): (close, returns before, netclient)"", ""('class', 'implementation', 'method'): (netclient, uses, close)"", ""('method', 'dependency', 'class'): (close, has effect on, netclient)""]"
Sending messages via the event bus can be done via either the send() or publish() method on the event bus.,"[""('method', 'implementation', 'method'): (send, can be done via, publish)"", ""('method', 'implementation', 'class'): (send, done via, event bus)"", ""('method', 'dependency', 'class'): (send, on, event bus)"", ""('method', 'dependency', 'class'): (publish, on, event bus)""]"
A verticle has a start() and a stop() method which are called when the verticle is deployed and when it is undeployed.,"[""('method', 'implementation', 'method'): (start, are called when the verticle is deployed, stop)"", ""('method', 'implementation', 'method'): (stop, are called when the verticle is undeployed, start)""]"
The addAll() method takes a Collection as parameter so you can pass either a List or Java Set as parameter,"[""('class', 'dependency', 'method'): (list, can be passed as parameter, addall)"", ""('class', 'dependency', 'method'): (set, can be passed as parameter, addall)"", ""('interface', 'dependency', 'method'): (collection, is parameter of, addall)""]"
But no thread can actually execute unlock() until the thread waiting in lock() leaves the outer synchronized block,"[""('method', 'dependency', 'method'): (lock, cannot be executed until leaving the outer synchronized block, unlock)"", ""('method', 'dependency', 'method'): (unlock, is executed after, lock)""]"
A thread cannot call wait() notify() or notifyAll() without holding the lock on the object the method is called on,"[""('method', 'dependency', 'method'): (wait, cannot be called without notify, notify)"", ""('method', 'dependency', 'method'): (wait, cannot be called without notifyall, notifyall)"", ""('method', 'dependency', 'method'): (notify, cannot be called without notifyall, notifyall)"", ""('method', 'similarity', 'method'): (wait, similar to notify and notifyall, notify)"", ""('method', 'similarity', 'method'): (notify, similar to wait and notifyall, notifyall)"", ""('method', 'similarity', 'method'): (notifyall, similar to wait and notify, notifyall)""]"
"The Arrays class contains a set of methods called binarySearch(). This method helps you perform a binary search in an array. The array must first be sorted. You can do so yourself, or via the Arrays.sort() method covered earlier in this text.","[""('class', 'containment', 'method'): (arrays, contains, arrays.binarysearch)"", ""('class', 'containment', 'method'): (arrays, contains, arrays.sort)"", ""('method', 'dependency', 'method'): (arrays.sort, is used for, arrays.binarysearch)"", ""('method', 'dependency', 'method'): (arrays.binarysearch, requires, arrays.sort)""]"
java.lang.ThreadLocal is possible to set an initial value for a Java ThreadLocal which will get used the first time get() is called before set() has been called with a new value,"[""('class', 'dependency', 'method'): (java.lang.threadlocal, is used by, get)"", ""('class', 'dependency', 'method'): (java.lang.threadlocal, is used by, set)"", ""('class', 'dependency', 'method'): (threadlocal, is used by, get)"", ""('class', 'dependency', 'method'): (threadlocal, is used by, set)"", ""('method', 'dependency', 'method'): (get, is related to, set)"", ""('class', 'implementation', 'method'): (java.lang.threadlocal, implements, get)"", ""('class', 'implementation', 'method'): (java.lang.threadlocal, implements, set)"", ""('class', 'implementation', 'method'): (threadlocal, implements, get)"", ""('class', 'implementation', 'method'): (threadlocal, implements, set)""]"
Adding and getting elements to a generic Map is done using the put() and get() methods just like you have always done,"[""('method', 'dependency', 'method'): (put, used with, get)"", ""('method', 'dependency', 'class'): (put, used with, map)"", ""('method', 'dependency', 'class'): (get, used with, map)""]"
Deque.pollLast() is different than removeLast() which throws an exception if the Deque is empty,"[""('method', 'difference', 'method'): (deque.polllast, is different than, deque.removelast)""]"
The tailSet() method works the same way as the headSet() method except it returns all elements that are equal to or higher than the given parameter element,"[""('method', 'similarity', 'method'): (tailset, works the same way as, headset)"", ""('method', 'difference', 'method'): (tailset, returns all elements that are equal to or higher than the given parameter element instead of, headset)""]"
"You can also obtain an Iterator from many of the Java Collection data structures, e.g. a List, Set, Map, Queue, Deque or Map.","[""('class', 'dependency', 'class'): (iterator, can be obtained from, list)"", ""('class', 'dependency', 'class'): (iterator, can be obtained from, set)"", ""('class', 'dependency', 'class'): (iterator, can be obtained from, map)"", ""('class', 'dependency', 'class'): (iterator, can be obtained from, queue)"", ""('class', 'dependency', 'class'): (iterator, can be obtained from, deque)"", ""('class', 'similarity', 'class'): (list, is similar to, set)"", ""('class', 'similarity', 'class'): (list, is similar to, map)"", ""('class', 'similarity', 'class'): (list, is similar to, queue)"", ""('class', 'similarity', 'class'): (list, is similar to, deque)"", ""('class', 'similarity', 'class'): (set, is similar to, map)"", ""('class', 'similarity', 'class'): (set, is similar to, queue)"", ""('class', 'similarity', 'class'): (set, is similar to, deque)"", ""('class', 'similarity', 'class'): (map, is similar to, queue)"", ""('class', 'similarity', 'class'): (map, is similar to, deque)"", ""('class', 'similarity', 'class'): (queue, is similar to, deque)""]"
java.io.Writer works just like combining the Reader with InputStream or the Writer with OutputStream,"[""('class', 'dependency', 'class'): (java.io.writer, works like combining with, reader)"", ""('class', 'dependency', 'class'): (java.io.writer, works like combining with, inputstream)"", ""('class', 'dependency', 'class'): (java.io.writer, works like combining with, outputstream)"", ""('class', 'similarity', 'class'): (java.io.writer, works just like, reader)"", ""('class', 'similarity', 'class'): (java.io.writer, works just like, inputstream)"", ""('class', 'similarity', 'class'): (java.io.writer, works just like, outputstream)"", ""('class', 'similarity', 'class'): (reader, works just like combining with, inputstream)"", ""('class', 'similarity', 'class'): (reader, works just like combining with, outputstream)"", ""('class', 'similarity', 'class'): (inputstream, works just like combining with, outputstream)""]"
Remember that even if the 4 threads call wait() and notify() on the same shared string instance the signals from the doWait() and doNotify() calls are stored individually in the two MyWaitNotify instances,"[""('method', 'dependency', 'method'): (wait, relies on, notify)"", ""('method', 'implementation', 'class'): (wait, interacts through, mywaitnotify)"", ""('method', 'implementation', 'class'): (notify, interacts through, mywaitnotify)"", ""('class', 'dependency', 'method'): (mywaitnotify, relies on, wait)"", ""('class', 'dependency', 'method'): (mywaitnotify, relies on, notify)""]"
The bigger the result String grows the longer it takes to copy the characters from it into a new StringBuilder and again copy the characters from the StringBuilder into the temporary String created by the toString() method,"[""('class', 'conversion', 'class'): (string, copied into, stringbuilder)"", ""('class', 'conversion', 'class'): (stringbuilder, copied into, string)"", ""('class', 'dependency', 'class'): (string, grows, stringbuilder)"", ""('class', 'conversion', 'class'): (string, created from, stringbuilder)""]"
The logp() methods work like the log() methods except each method take an extra two parameters The sourceClass and sourceMethod parameter,"[""('method', 'similarity', 'method'): (logp, works like, log)"", ""('method', 'dependency', 'method'): (logp, takes extra parameters like, log)""]"
But since the thread waiting in lock() has not yet called queueObject.wait() the call to queueObject.notify() passes into oblivion,"[""('method', 'dependency', 'method'): (lock, relies on for wait operation, queueobject.wait)"", ""('method', 'dependency', 'method'): (queueobject.notify, requires waiting thread from, lock)"", ""('method', 'dependency', 'method'): (queueobject.wait, relies on notification from, queueobject.notify)""]"
Since PipedOutputStream is a subclass of OutputStream PipedOutputStream has the same basic methods and use patterns as an OutputStream,"[""('class', 'dependency', 'class'): (pipedoutputstream, is a subclass of, outputstream)"", ""('class', 'similarity', 'class'): (pipedoutputstream, has the same basic methods and use patterns as, outputstream)""]"
You can convert a Java Set to a Java List by creating a List and calling its addAll() method passing the Set as parameter to the addAll() method,"[""('class', 'conversion', 'class'): (set, can be converted to, list)"", ""('class', 'dependency', 'method'): (list, relies on addall method of, addall)"", ""('class', 'creation', 'class'): (list, is created from, set)"", ""('class', 'dependency', 'method'): (set, relies on addall method of, addall)""]"
Even though the Java Networking APIs enable you to open and close network connections via sockets all communication happens via the Java IO classes InputStream and OutputStream,[]
Again here the first() and next() methods return the unicode index of the found word boundary,"[""('method', 'dependency', 'method'): (first, return the unicode index of the found word boundary, next)"", ""('method', 'dependency', 'method'): (next, return the unicode index of the found word boundary, first)""]"
Obviously if the input parameter to contains() is null the contains() method will not use the equals() method to compare against each element but rather use the == operator,"[""('method', 'dependency', 'method'): (contains, will not use, equals)"", ""('method', 'dependency', 'method'): (equals, is used by, contains)""]"
Both Java File and FileChannel works but in case you want a pure Java NIO solution use the Java NIO FileChannel class,[]
If you need an integer value use the round() floor() or ceil() method,"[""('method', 'similarity', 'method'): (round, can be used as an alternative to, floor)"", ""('method', 'similarity', 'method'): (round, can be used as an alternative to, ceil)"", ""('method', 'similarity', 'method'): (floor, can be used as an alternative to, ceil)""]"
The poll() and remove() both removes the first element in the Queue. They differ in how they behave if the Queue is empty. The poll() method returns null if the Queue is empty. The remove() method throws an exception if the Queue is empty.,"[""('method', 'difference', 'method'): (poll, behaves differently when the queue is empty, remove)"", ""('method', 'dependency', 'class'): (poll, returns null if empty, queue)"", ""('method', 'dependency', 'class'): (remove, throws exception if empty, queue)""]"
"The add() and offer() methods differ in how the behave if the Queue is full, so no more elements can be added. The add() method throws an exception in that case, whereas the offer() method just returns false.","[""('method', 'difference', 'method'): (add, differ in behavior when the queue is full, offer)"", ""('method', 'dependency', 'class'): (add, throws an exception when full, queue)"", ""('method', 'dependency', 'class'): (offer, returns false when full, queue)"", ""('method', 'difference', 'method'): (offer, return false instead of throwing an exception, add)""]"
Each of the methods ceilingEntry() floorEntry() higherEntry() and lowerEntry() will be covered in the following sections,"[""('method', 'dependency', 'method'): (ceilingentry, will be covered in the same sections as, floorentry)"", ""('method', 'dependency', 'method'): (ceilingentry, will be covered in the same sections as, higherentry)"", ""('method', 'dependency', 'method'): (ceilingentry, will be covered in the same sections as, lowerentry)"", ""('method', 'dependency', 'method'): (floorentry, will be covered in the same sections as, higherentry)"", ""('method', 'dependency', 'method'): (floorentry, will be covered in the same sections as, lowerentry)"", ""('method', 'dependency', 'method'): (higherentry, will be covered in the same sections as, lowerentry)"", ""('method', 'similarity', 'method'): (ceilingentry, are similar methods to, floorentry)"", ""('method', 'similarity', 'method'): (ceilingentry, are similar methods to, higherentry)"", ""('method', 'similarity', 'method'): (ceilingentry, are similar methods to, lowerentry)"", ""('method', 'similarity', 'method'): (floorentry, are similar methods to, higherentry)"", ""('method', 'similarity', 'method'): (floorentry, are similar methods to, lowerentry)"", ""('method', 'similarity', 'method'): (higherentry, are similar methods to, lowerentry)"", ""('method', 'difference', 'method'): (ceilingentry, is different from, floorentry)"", ""('method', 'difference', 'method'): (ceilingentry, is different from, higherentry)"", ""('method', 'difference', 'method'): (ceilingentry, is different from, lowerentry)"", ""('method', 'difference', 'method'): (floorentry, is different from, higherentry)"", ""('method', 'difference', 'method'): (floorentry, is different from, lowerentry)"", ""('method', 'difference', 'method'): (higherentry, is different from, lowerentry)""]"
To do so set the upper bound to 1 and have the call to take() and release() guard the critical section,"[""('method', 'dependency', 'method'): (release, guard the critical section with, take)""]"
Once you have opened a socket (network connection) though you read and write data to and from it via Java IO InputStream and OutputStream classes,"[""('class', 'dependency', 'class'): (inputstream, read and write data to and from, outputstream)"", ""('class', 'dependency', 'class'): (outputstream, read and write data to and from, inputstream)""]"
Many of the core components in the Java Collection API rely on the correct implementation of the `hashCode()` and `equals()` methods.,"[""('class', 'dependency', 'method'): (java collection, relies on, hashcode)"", ""('class', 'dependency', 'method'): (java collection, relies on, equals)"", ""('method', 'dependency', 'method'): (hashcode, relies on, equals)""]"
java.io.PrintWriter example first creates a PrintWriter instance which is connected to a FileWriter,"[""('class', 'dependency', 'class'): (java.io.printwriter, is connected to, filewriter)""]"
InputStream.read() example creates an AsynchronousFileChannel and then creates a ByteBuffer which is passed to the read() method as parameter along with a position of 0,"[""('class', 'creation', 'class'): (inputstream, creates, asynchronousfilechannel)"", ""('class', 'creation', 'class'): (inputstream, creates, bytebuffer)"", ""('class', 'dependency', 'method'): (inputstream, passes to, read)"", ""('class', 'dependency', 'class'): (asynchronousfilechannel, interacts with, bytebuffer)"", ""('class', 'dependency', 'method'): (asynchronousfilechannel, used by, read)"", ""('class', 'dependency', 'method'): (bytebuffer, passed to, read)""]"
java.lang.StringBuffer text explains how to use the SimpleDateFormat class to format dates,"[""('class', 'dependency', 'class'): (java.lang.stringbuffer, uses, simpledateformat)"", ""('class', 'dependency', 'class'): (simpledateformat, used by, java.lang.stringbuffer)""]"
In general you can call the markSupported() method to find out if mark() and reset() are supported on a given InputStream or not but the BufferedInputStream supports them,"[""('class', 'implementation', 'class'): (bufferedinputstream, is a type of, inputstream)""]"
"The newLine() method which can write a new-line character to the underlying Writer. In addition, you may need to call flush() if you need to be absolutely sure that the characters written until now is flushed out of the buffer and onto the network or disk.","[""('method', 'dependency', 'class'): (newline, relies on, writer)"", ""('method', 'dependency', 'class'): (flush, relies on, writer)"", ""('method', 'implementation', 'class'): (newline, writes to, writer)"", ""('method', 'implementation', 'class'): (flush, ensures writing to, writer)"", ""('method', 'dependency', 'method'): (newline, may need, flush)""]"
Queue.poll() is different than remove() which throws an exception if the Deque is empty,"[""('method', 'difference', 'method'): (queue.poll, is different than, queue.remove)""]"
Notice the two synchronized blocks inside the set() and get() method. Notice how the blocks are placed last and first in the two methods.,"[""('method', 'dependency', 'method'): (set, synchronized blocks are placed last, get)"", ""('method', 'implementation', 'method'): (set, interacts through messaging, get)"", ""('method', 'implementation', 'method'): (get, interacts through messaging, set)""]"
"The replace() method will only insert the new value if there is already an existing value mapped to the key. If no existing value is mapped to the given key, no value is inserted. This is different from how put() works, which always insert the value no matter what.","[""('method', 'difference', 'method'): (replace, works differently than, put)"", ""('method', 'preference', 'method'): (put, is preferred in terms of inserting values over, replace)""]"
The logrb() methods work like the log() methods too except they can obtain the log messages from a resource bundle,"[""('method', 'similarity', 'method'): (logrb, work like, log)"", ""('method', 'dependency', 'method'): (logrb, obtain log messages from, log)""]"
The Handler in the Java Logging API use a java.util.logging.Formatter to format the LogRecord before writing it to an external system,"[""('class', 'dependency', 'class'): (java.util.logging.handler, uses, java.util.logging.formatter)"", ""('class', 'dependency', 'class'): (java.util.logging.formatter, formats, logrecord)"", ""('class', 'dependency', 'class'): (java.util.logging.handler, writes, logrecord)""]"
